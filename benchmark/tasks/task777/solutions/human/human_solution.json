[
  {
    "language": "Fortran",
    "code": "module mod_modulo_util\n  implicit none\n  integer(8), parameter :: md = 998244353_8\n  integer(8), allocatable :: f(:), invf(:)\ncontains\n  subroutine init(n)\n    integer, intent(in) :: n\n    integer :: i\n    if (allocated(f)) deallocate(f)\n    if (allocated(invf)) deallocate(invf)\n    allocate(f(0:n),invf(0:n))\n    f = 0_8\n    invf = 0_8\n    f(0) = 1_8\n    do i = 1, n\n      f(i) = mod(f(i-1)*int(i,8),md)\n    end do\n    invf(n) = inv(f(n))\n    do i = n, 1, -1\n      invf(i-1) = mod(invf(i)*int(i,8),md)\n    end do\n  end\n  integer(8) function perm(n,k)\n    integer, intent(in) :: n, k\n    perm = 0_8\n    if (k > n .or. n < 0 .or. k < 0) return\n    perm = mod(f(n)*invf(n-k),md)\n  end\n  integer(8) function comb(n,k)\n    integer, intent(in) :: n, k\n    comb = mod(perm(n,k)*invf(k),md)\n  end\n  integer(8) function homo(n,k)\n    integer, intent(in) :: n, k\n    homo = comb(n+k-1,k)\n  end\n  function inv(n) result(y)\n    integer(8), intent(in) :: n\n    integer(8) :: a, b, x, y, t, q\n    a = mod(n,md)\n    b = md\n    x = 0_8\n    y = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      t = b\n      b = mod(a,b)\n      a = t\n      t = y\n      y = x\n      x = t-q*x\n    end do\n    y = mod(mod(y,md)+md,md)\n  end\n  function pow(a,b) result(r)\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer :: i\n    integer(8) :: r, p\n    r = 1_8\n    p = a\n    do i = 0, 32\n      if (btest(b,i)) r = mod(r*p,md)\n      p = mod(p*p,md)\n    end do\n  end\n  integer(8) function fact(n)\n    integer, intent(in) :: n\n    fact = 0_8\n    if (n < 0) return\n    fact = f(n)\n  end\nend module mod_modulo_util\nprogram banned_x\n  use mod_modulo_util\n  implicit none\n  integer :: n, x, i, j, k, t, w\n  integer(8) :: ans = 0_8, tmp\n  read(*,*) n, x\n  call init(3*n)\n  do i = 0, n\n    tmp = 0_8\n    do j = 0, min(x-1,i)\n      if (2*j < x-1) cycle\n      k = i-j\n      if (i < k) cycle\n      t = j-k\n      if (t >= 0) then\n        w = x-1-j-k\n        tmp = mod(tmp+comb(t,w),md)\n      else if (2*j == x-1) then\n        tmp = mod(tmp+1_8,md)\n      end if\n    end do\n    do j = 0, x-2\n      tmp = mod(tmp+comb(i,j-i),md)\n    end do\n    ans = mod(ans+mod(tmp*comb(n,i),md),md)\n  end do\n  write(*,'(i0)') ans\nend program banned_x"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) FOR(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\ntemplate<class T> using V=vector<T>;\ntemplate<class T> using VV=V<V<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\trep(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?1:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tstatic constexpr int base=mod;\n\tint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\tv=vv%mod;\n\t\tif(v<0)v+=mod;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tbool operator!=(const ModInt&rhs)const{\n\t\treturn v!=rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ll(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\n//using mint=ModInt<1000000007>;\nusing mint=ModInt<998244353>;\n\nconst int Vmax=min<int>(2000010,mint::base);\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nconst int Nmax=3010;\nmint dp[Nmax*2][Nmax][2];\n\nsigned main(){\n\tint n=read(),x=read();\n\tdp[0][0][0]=1;\n\trep(i,n)rep(j,i*2+1)rep(k,2){\n\t\tdp[i+1][j+1][k|1]+=dp[i][j][k];\n\t\tdp[i+1][j+2][k]+=dp[i][j][k];\n\t}\n\tmint ans=0;\n\trep(i,n+1){\n\t\tmint w;\n\t\tif(i*2>x&&x%2)w+=1;\n\t\trep(j,x)\n\t\t\tw+=dp[i][j][0]+dp[i][j][1];\n\t\tFOR(k,1,i/2+1){\n\t\t\tint rem=x-1-2*k;\n\t\t\tif(rem>=0){\n\t\t\t\tcerr<<i<<\" \"<<k<<\" \"<<rem<<\" \"<<dp[i-2*k][rem][1]<<endl;\n\t\t\t\tw+=dp[i-2*k][rem][1];\n\t\t\t}\n\t\t}\n\t\tcerr<<i<<\" \"<<w<<endl;\n\t\tans+=Choose(n,i)*w;\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  // mint(long long);\n  inline mint(long long v)\n      : v(fast == 0 ? (v < 0 ? (v % MODS[kind] + MODS[kind]) % MODS[kind]\n                             : (v >= MODS[kind] ? v % MODS[kind] : v))\n                    : (v)) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n  void take_mod() { v %= MODS[kind]; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  /*\n  if (fast == 1) {\n    a.v += b.v;\n    return a;\n  }\n  */\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n// vector<vector<mint<>>> comb_table;\nmint<> comb_table[3050][3050];\n\nmint<> comb(LL N, LL K) {\n  if (N < K) return 0;\n  if (K < 0) return 0;\n  return comb_table[N][K];\n}\n\nvoid init(int N) {\n  //  comb_table.resize(N + 6);\n  for (int i = 0; i <= N; i++) {\n    //    comb_table[i].resize(i + 1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for (int j = 1; j < i; j++) {\n      comb_table[i][j] = comb_table[i - 1][j - 1] + comb_table[i - 1][j];\n    }\n  }\n}\n\nmint<> dp[6005][3005];\nvoid solve(long long N, long long X) {\n  init(N);\n  mint<> zero = 0;\n  // auto dp = exvector(zero, 2 * N + 5, N + 5);\n  for (int j = 0; j <= N + 1; j++) dp[0][j] = 0;\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 3010\n#define P 998244353\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,m,C[N][N],ans;\nvoid inc(int &x,int y){x+=y;if (x>=P) x-=P;}\nsigned main()\n{\n\tn=read(),m=read();\n\tC[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++)\n\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%P;\n\t}\n\tfor (int i=0;i<=n;i++)\n\t{\n\t\tint s=0;\n\t\tfor (int j=0;j<=m-1-i;j++) inc(s,C[i][j]);\n\t\tfor (int j=1;j<=i;j++) //j是第一个前缀和>m的位置 j~i均为2 1~i-j+1均为2 \n\t\tif (j*2>m&&(i-j+1<j?(i-j+1)*2+(j-(i-j+1)+1):j*2)<=m+1)\n\t\t\tif (i-j+1<j) inc(s,C[j-(i-j+1)-1][m+1-((i-j+1)*2+(j-(i-j+1)+1))]);\n\t\t\telse if (j*2==m+1) inc(s,1);\n\t\tinc(ans,1ll*s*C[n][n-i]%P);\n\t}\n\tcout<<ans;\n\treturn 0;\n\t//NOTICE LONG LONG!!!!!\n}\n//先把0去掉 则要考虑求长度为0~n的满足条件的序列数量\n//找到第一个前缀和>x的位置 然后若当前不是后缀 下一位必须是2 首位也必须是2 \n//即第一个前缀和>x的位置及之后全都是2 "
  },
  {
    "language": "C++",
    "code": "const long long MOD = 998244353;\nconst int N = 3004;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n, x;\nll calc[N];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n >> x;\n    calc[0] = 1;\n    for (int len = 1; len <= n; len++)\n    {\n        for (int summ = len; summ <= 2 * len; summ++)\n        {\n            if (summ < x)\n            {\n                calc[len] = calc[len] + cnk(len, summ - len);\n                if (calc[len] >= MOD) calc[len] -= MOD;\n            }\n            else\n            {\n                if (summ <= x || (summ - x + 1) % 2 == 1)\n                {\n                    continue;\n                }\n                int L = (summ - x + 1) / 2;\n                int summa = summ - 4 * L;\n                int dlina = len - 2 * L;\n                if (summa != 2 * dlina)\n                {\n                    calc[len] = calc[len] + cnk(dlina, summa - dlina);\n                    if (calc[len] >= MOD) calc[len] -= MOD;\n                }\n            }\n        }\n        if (2 * len >= x && x % 2 == 1) calc[len]++;\n    }\n    ll ans = 0;\n    for (int i = 0; i <= n; i++)\n    {\n        ans = (ans + calc[i] * cnk(n, i)) % MOD;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nnamespace n91 {\n\nusing i8 = std::int_least8_t;\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u8 = std::uint_least8_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nclass rep {\n  const usize f, l;\n\npublic:\n  class itr {\n    friend rep;\n    usize i;\n    constexpr itr(const usize x) noexcept : i(x) {}\n\n  public:\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  constexpr rep(const usize first, const usize last) noexcept\n      : f(first), l(last) {}\n  constexpr itr begin() const noexcept { return itr(f); }\n  constexpr itr end() const noexcept { return itr(l); }\n};\nclass revrep {\n  const usize f, l;\n\npublic:\n  class itr {\n    friend revrep;\n    usize i;\n    constexpr itr(usize x) noexcept : i(x) {}\n\n  public:\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  constexpr revrep(usize first, usize last) noexcept : f(--first), l(--last) {}\n  constexpr itr begin() const noexcept { return itr(l); }\n  constexpr itr end() const noexcept { return itr(f); }\n};\ntemplate <class T> using vec_alias = std::vector<T>;\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) {\n  return a < b ? b - a : a - b;\n}\n\n} // namespace n91\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\n#include <vector>\nnamespace n91 {\n\ntemplate <class T> class fact_binom {\npublic:\n  using value_type = T;\n  using container_type = std::vector<value_type>;\n  using size_type = typename container_type::size_type;\n\nprivate:\n  container_type factrial, inv_fact;\n\npublic:\n  fact_binom() : factrial(), inv_fact() {}\n  explicit fact_binom(const size_type n) : factrial(n + 1), inv_fact(n + 1) {\n    factrial[0] = static_cast<value_type>(1);\n    for (size_type i = 0; i != n; ++i) {\n      factrial[i + 1] = static_cast<value_type>(i + 1) * factrial[i];\n    }\n    inv_fact[n] = static_cast<value_type>(1) / factrial[n];\n    for (size_type i = n; i != 0; --i) {\n      inv_fact[i - 1] = inv_fact[i] * static_cast<value_type>(i);\n    }\n  }\n\n  value_type operator()(const size_type n, const size_type r) const {\n    return factrial[n] * inv_fact[r] * inv_fact[n - r];\n  }\n};\n\n} // namespace n91\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <utility>\n\nnamespace n91 {\n\nvoid main_() {\n  using mint = modint<998244353>;\n  usize n, x;\n  std::cin >> n >> x;\n  const usize f_max = (n + x + 1) * 2;\n  n91::fact_binom<mint> binom(f_max);\n  mint ans = 0;\n  if (x % 2 == 0) {\n    std::vector<mint> count(n + x + 1);\n    for (const auto i : rep(0, x)) {\n      for (usize j = 0; j * 2 <= i; ++j) {\n        count[i - j] += binom(i - j, j);\n      }\n    }\n    for (usize i = x + 1; i <= 2 * x - 3; i += 2) {\n      const usize rem = 2 * x - i - 2;\n      for (usize j = 0; j * 2 <= rem; ++j) {\n        count[x - 1 - j] += binom(rem - j, j);\n      }\n    }\n    for (const auto i : rep(0, n + 1)) {\n      ans += count[i] * binom(n, i);\n    }\n  } else {\n    std::vector<mint> count(n + x + 1);\n    if (x != 1) {\n      for (const auto i : rep(0, x)) {\n        for (usize j = 0; j * 2 <= i; ++j) {\n          count[i - j] += binom(i - j, j);\n        }\n      }\n    }\n    for (usize i = x + 1; i < 2 * x - 2; i += 2) {\n      const usize rem = 2 * x - i - 2;\n      for (usize j = 0; j * 2 <= rem; ++j) {\n        count[x - 1 - j] += binom(rem - j, j);\n      }\n    }\n    for (usize i = 2 * x - 2; i / 2 <= n; i += 2) {\n      count[i / 2] += 1;\n    }\n    for (const auto i : rep(0, n + 1)) {\n      ans += count[i] * binom(n, i);\n    }\n  }\n  std::cout << ans.value() << std::endl;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n\nusing namespace std;\n\nconst int N=3010,mod=998244353;\nint n,x,f[N][N<<1],fac[N],inv[N],ans;\n\ninline void upd(int &x,int y){x+=y; x-=x>=mod?mod:0;}\n\nvoid init(int n){\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\trep (i,2,n) fac[i]=(ll)fac[i-1]*i%mod,inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;\n\trep (i,2,n) inv[i]=(ll)inv[i]*inv[i-1]%mod;\n}\nint C(int n,int m){return (ll)fac[n]*inv[m]%mod*inv[n-m]%mod;}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>x; init(n);\n\tf[0][0]=1;\n\trep (i,1,n) rep (j,1,x){\n\t\tupd(f[i][j],f[i-1][j-1]);\n\t\tif (j>1) upd(f[i][j],f[i-1][j-2]);\n\t}\n\trep (i,0,n){\n\t\tint res=0;\n\t\trep (j,0,x-2) upd(res,f[i][j]);\n\t\trep (j,0,i)\n\t\t\tif (i-j<=j&&x-1-2*(i-j)>=0) upd(res,f[j-(i-j)][x-1-2*(i-j)]);\n\t\t\telse if (i-j>j&&j*2==x-1) upd(res,1);\n\t\tupd(ans,(ll)C(n,i)*res%mod);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#define rint register int\n#define LL long long\n#define P 998244353\n#define MAXN 100005\nusing namespace std;\n\nint n, x, ans, c[MAXN][MAXN];\n\ninline int add(int x, int y) {return x+y<P?x+y:x+y-P;}\ninline int sub(int x, int y) {return x<y?x-y+P:x-y;}\n\nint solve(int tot)\n{\n\tint ans=0;\n\tif(x&1 || 2*tot<x) ans=1;\n\tfor(rint i=tot; i<tot*2; ++i)\n\t{\n\t\tif(i>=x && (i-x)%2==0) continue;\n\t\tif(i<x) {ans=add(ans, c[tot][i-tot]); continue;}\n\t\tint temp=(i-x+1)/2;\n\t\tint resnum=i-temp*4, respos=tot-temp*2;\n\t\tif(temp*2<tot && resnum>=respos && resnum<=respos*2) ans=add(ans, c[respos][resnum-respos]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &x);\n\tc[0][0]=1;\n\tfor(rint i=1; i<=n; ++i)\n\t{\n\t\tc[i][0]=1;\n\t\tfor(rint j=1; j<=i; ++j) c[i][j]=add(c[i-1][j], c[i-1][j-1]);\n\t}\n\tfor(rint i=0; i<=n; ++i) ans=(ans+1LL*c[n][i]*solve(n-i))%P;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 998244353;\nconst int MAX = 3100;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(){\n\tint N, X; cin >> N >> X;\n\tCOMinit();\n\tll ans = 0;\n\tfor(int i=0; i<=N; i++){\n\t\tfor(int j=i; j<=2*i; j++){\n\t\t\tll cnt = 0;\n\t\t\tif(j < X){\n\t\t\t\tcnt = (cnt + COM(i, j-i)) % MOD;\n\t\t\t}else{\n\t\t\t\tint two = (j-X+2)/2;\n\t\t\t\tif(4*two < j){\n\t\t\t\t\tint midsum = j - 4*two;\n\t\t\t\t\tint midnum = i - 2*two;\n\t\t\t\t\tif(midsum % 2 != X % 2){\n\t\t\t\t\t\tcnt = (cnt + COM(midnum, midsum-midnum)) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(2*two >= i && j == 2*i && X % 2 != 0){ cnt++; cnt %= MOD; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = (ans + cnt * COM(N, i) % MOD) % MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=3005;\nconst int mod=998244353;\nint n,x;\nint fac[maxn*2],ifac[maxn*2];\nint C(int a,int b){\n\treturn a<b?0:1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&x);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2*n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*(mod-mod/i)*ifac[mod%i]%mod; \n\t}\n\tREP(i,2*n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tint tot=0;\n\trep(i,n+1){\n\t\tint ans=0;\n\t\trep(s,x)ans=(ans+C(i,s-i))%mod;\n\t\trep(j,i){\n\t\t\tint l=i-j+1,r=j;\n\t\t\tif(l>r){\n\t\t\t\tif(x-1==2*j)ans=(ans+1)%mod;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=x-1-2*(i-j);\n\t\t\tif(s<0)continue;\n\t\t\tans=(ans+C(r-l+1,s-(r-l+1)))%mod;\n\t\t} \n\t\ttot=(tot+1LL*ans*C(n,i)%mod)%mod; \n\t}\n\tprintf(\"%d\\n\",tot);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\ntemplate<int mod>\nstruct ModInt {\n    long long x;\n \n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    explicit operator int() const {return x;}\n \n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n \n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n \n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n \n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt power(long long p) const{\n        int a = x;\n        if (p==0) return 1;\n        if (p==1) return ModInt(a);\n        if (p%2==1) return (ModInt(a)*ModInt(a)).power(p/2)*ModInt(a);\n        else return (ModInt(a)*ModInt(a)).power(p/2);\n    }\n\n    ModInt power(const ModInt p) const{\n        return ((ModInt)x).power(p.x);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\nusing modint = ModInt<mod>;\n\nstruct ModFac{\n  public:\n    vector<modint> f,i_f;\n    int n;\n\n    ModFac(int n_){\n      n=n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    ModFac(modint n_){\n      n=(int)n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    \n    modint factorial(int x){\n      //cout << f.size() << endl;\n      return f[x];\n    }\n        \n    modint inv_factorial(int x){\n      return i_f[x];\n    }\n    \n    modint comb(int m,int k){\n      if (m<0 or k<0) return 0;\n      if (m<k) return 0;\n      return f[m]*i_f[k]*i_f[m-k];\n    }\n};\n\n\nint n,x;\nModFac MF(1000010);\n\nmodint f(int k,int m){\n    int p=x-1-2*(k-m-1);\n    //cout << p << endl;\n    if(m<=k-m-2){\n        if(x-1==2*(m+1)) return 1;\n        else return 0;\n    }\n    //cout << 2*m-k+2 << \" \" << p-(2*m-k+2) << \" \" << MF.comb(2*m-k+2,p-(2*m-k+2)) << endl;\n    return MF.comb(2*m-k+2,p-(2*m-k+2));\n}\n\nvoid solve(){\n    cin >> n >> x;\n    if(x==1){\n        cout << ((modint)2).power(n) << endl;\n        return;\n    }\n    if(x==2){\n        cout << 1+n << endl;\n        return;\n    }\n    modint ans=0;\n    Rep(k,1,n+1){\n        rep(j,k-1){\n            //cout << k << \" \" << j << endl;\n            ans+=MF.comb(n,k)*f(k,j);\n        }\n        modint res=0;\n        rep(j,x-k) res+=MF.comb(n,k)*MF.comb(k,j);\n        //cout << k << \" \" << res/MF.comb(n,k) << endl; \n        ans+=res;\n    }\n    cout << ans+1 << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int mygetchar()\n{\n#ifdef WIN32\n\treturn _getchar_nolock();\n#else\n\treturn getchar_unlocked();\n#endif\n}\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = mygetchar();\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == '-') f = -1;\n\t\tc = mygetchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tx = x * 10 + c - '0';\n\t\tc = mygetchar();\n\t}\n\treturn x * f;\n}\n\nconst int MOD = 998244353;\ninline void add(int &x, int y) {x += y; if (x >= MOD) x -= MOD;}\ninline int inc(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int mul(int x, int y) {return (ll)x * y % MOD;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nconst int MAXN = 3005;\nint n, X, c[MAXN][MAXN], ans = 0;\n\ninline int Solve(int len)\n{\n\tint res = 0;\n\tif (len * 2 < X || X & 1) res = 1;\n\tfor (int i = 0; i < len; i ++)\n\t{\n\t\tif (len + i < X)\n\t\t\tadd(res, c[len][i]);\n\t\telse if ((len + i - X) & 1)\n\t\t{\n\t\t\tint S = len + i, l = (S - X + 1) / 2;\n\t\t\tif (len > l + l && i >= l + l) add(res, c[len - l - l][i - l - l]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tn = read(), X = read();\n\tfor (int i = 0; i <= n * 2; i ++) c[i][0] = 1;\n\tfor (int i = 1; i <= n * 2; i ++)\n\t\tfor (int j = 1; j <= i; j ++)\n\t\t\tc[i][j] = inc(c[i - 1][j], c[i - 1][j - 1]);\n\tfor (int i = 0; i <= n; i ++)\n\t\tadd(ans, mul(c[n][i], Solve(n - i)));\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nconst int N = 6010;\nll fact[N], invf[N];\nll dp[N][N];\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nll nPr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(fact[n], invf[n-r]);\n}\n\nll nCr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(mul(fact[n], invf[r]), invf[n-r]);\n}\n\nint main() {\n    ll n, x;\n    cin >> n >> x;\n\n    fact[0] = invf[0] = 1;\n    FOR(i,1,N-1){\n        fact[i] = (fact[i-1] * i) % mod;\n        invf[i] = divll(invf[i-1], i);\n    }\n\n    dp[0][0] = 1;\n    REP(i,n) REP(j,N-2){\n        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod;\n        dp[i+1][j+2] = (dp[i+1][j+2] + dp[i][j]) % mod;\n    }\n\n    ll ans = 1;\n    FOR(m,1,n){\n        // cout << \"m \" << m << endl;\n        ll tmp = 0;\n        REP(j,x) tmp = (tmp + dp[m][j]) % mod;\n        FOR(t,1,(m-1)/2){\n            ll d = x - 1 - 2 * t;\n            if (d > 0 && d < 2 * (m - 2 * t)) tmp = (tmp + dp[m - 2 * t][d]) % mod;\n            // if (2 * t == x) break;\n            // ll nn = m - 2 * t;\n            // for (ll xx = x - 3; xx > 0 && xx + 4 * t >= x; xx -= 2){\n            //     ll d = 0;\n            //     if (nn == 1){\n            //         if (xx == 1) d = 1;\n            //     }else{\n            //         d = dp[nn][xx];\n            //         if (xx >= 4) d = (d - dp[nn-2][xx-4]) % mod;\n            //     }\n            //     tmp += d;\n            //     cout << nn << \" \" << xx << \" \" << d << endl;\n            // }\n            // cout << d << \" \" << m - 2 * t << \" \" << dp[m - 2 * t][d] << endl;\n        }\n        if (x % 2 == 1 && 2 * m > x) tmp++;\n        // cout << tmp << endl;\n        ans = (ans + tmp * nCr(n, m)) % mod;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << x.v;\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\n\nvector<vector<LL>> comb_table;\n\n\nLL comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return comb_table[N][K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+6);\n  for(int i=0; i<=N; i++) {\n    comb_table[i].resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<i; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n      comb_table[i][j] %= MOD;\n    }\n  }\n  \n}\n\n\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1);\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2);\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n\n    }\n  }\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 3010\n#define P 998244353\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,m,C[N<<1][N<<1],ans;\nvoid inc(int &x,int y){x+=y;if (x>=P) x-=P;}\nsigned main()\n{\n\tn=read(),m=read();\n\tC[0][0]=1;\n\tfor (int i=1;i<=max(n,m);i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++)\n\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%P;\n\t}\n\tfor (int i=0;i<=n;i++)\n\t{\n\t\tint s=0;\n\t\tfor (int j=0;j<=m-1-i;j++) inc(s,C[i][j]);\n\t\tfor (int j=1;j<=i;j++) //j是第一个前缀和>m的位置 j~i均为2 1~i-j+1均为2 \n\t\tif (j*2>m&&(i-j+1<j?(i-j+1)*2+(j-(i-j+1)+1):j*2)<=m+1)\n\t\t\tif (i-j+1<j) inc(s,C[j-(i-j+1)-1][m+1-((i-j+1)*2+(j-(i-j+1)+1))]);\n\t\t\telse if (j*2==m+1) inc(s,1);\n\t\tinc(ans,1ll*s*C[n][n-i]%P);\n\t}\n\tcout<<ans;\n\treturn 0;\n\t//NOTICE LONG LONG!!!!!\n}\n//先把0去掉 则要考虑求长度为0~n的满足条件的序列数量\n//找到第一个前缀和>x的位置 然后若当前不是后缀 下一位必须是2 首位也必须是2 \n//即第一个前缀和>x的位置及之后全都是2 "
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 3e3 + 10, mod = 998244353;\n\nll ncr[2 * N][2 * N];\n\nll solve(int n, int x);\nll solve2(int n, int sum);\nll choose(int n, int k);\n\nint main() {\n\tfast_cin();\n\tint n, x;\n\tcin >> n >> x;\n\tfor (int i = 0; i < 2 * N; ++i) {\n\t\tncr[i][0] = ncr[i][i] = 1;\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % mod;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int k = 0; k <= n; ++k) {\n\t\tll temp = solve(k, x);\n\t\t// cout << k << ' ' << temp << endl;\n\t\ttemp *= choose(n, k);\n\t\tans += temp;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}\n\nll solve(int n, int x) {\n\tll ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tif (2 * i + (n - i) < x) {\n\t\t\tans += choose(n, i);\n\t\t}\n\t}\n\tfor (int i = 1; 2 * i <= min(n, x - 1); ++i) {\n\t\tans += solve2(n - 2 * i, x - 1 - 2 * i);\n\t}\n\tif (x % 2 == 1 and n >= x) {\n\t\t++ans;\n\t}\n\tans %= mod;\n\treturn ans;\n}\n\nll solve2(int n, int sum) {\n\treturn choose(n, sum - n);\n}\n\nll choose(int n, int k) {\n\tif (k < 0 or k > n) {\n\t\treturn 0;\n\t} else {\n\t\treturn ncr[n][k];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\nconst long long tomod = 998244353;\nconst int maxn = 6001;\nint last;\nvoid add(long long &a, long long b){\n\ta += b;\n\tif(a > tomod)a -= tomod;\n}\nlong long dp[2][maxn];\nint main(){\n\tint len, lim;\n\tcin >> len >> lim;\n\tdp[last][0] = 1ll;\n\tfor(int i = 0;i < len;++i, last ^= 1){\n\t\tmemcpy(dp[last ^ 1], dp[last], sizeof(dp[0]));\n\t\tfor(int j = lim - 1;j > 1;--j){\n\t\t\tadd(dp[last ^ 1][j], dp[last][j - 2]);\n\t\t}\n\t\tfor(int j = lim - 1;j > 0;--j){\n\t\t\tadd(dp[last ^ 1][j], dp[last][j - 1]);\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0;i < lim;++i)add(ans, dp[last][i]);\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=6005,INF=1<<30;\nll cnt[MAX][MAX];\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    int N,X;cin>>N>>X;\n    ll sum=0;\n    \n    for(int i=0;i<X;i++){\n        for(int j=0;j<=N;j++){\n            if(i<j) continue;\n            \n            int rem=i-j;\n            cnt[i][j]=comb(j,rem);\n            \n            sum+=cnt[i][j]*comb(N,j);\n            sum%=mod;\n        }\n    }\n    \n    for(int i=X+1;i<=2*N;i+=2){\n        if(i==2){\n            sum+=N;\n            sum%=mod;\n            continue;\n        }\n        if(i==3) continue;\n        int rd=(i-(X-1))*2;\n        if(i-rd<0){\n            if(X%2==1){\n                int c=(i+1)/2;\n                sum+=comb(N,c);\n                sum%=mod;\n            }\n        }else{\n            for(int j=0;j+rd/2<=N;j++){\n                sum+=cnt[i-rd][j]*comb(N,j+rd/2);\n                sum%=mod;\n            }\n        }\n    }\n    \n    cout<<sum<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353, maxn = 5555;\nint mul(long long a, long long b){\n\treturn a * b % mod;\n}\nint pw(int a, int b){\n\tint r = 1;\n\tfor(; b; b >>= 1, a = mul(a, a)) if(b&1) r = mul(r, a);\n\treturn r;\n}\nint fat[maxn], ifat[maxn], p2[maxn];\nvoid init(){\n\tp2[0] = 1;\n\tfor(int i = 1; i < maxn; i++) p2[i] = mul(2, p2[i - 1]);\n\tfat[0] = 1;\n\tfor(int i = 1; i < maxn; i++) fat[i] = mul(i, fat[i - 1]);\n\tifat[maxn - 1] = pw(fat[maxn - 1], mod - 2);\n\tfor(int i = maxn - 2; i >= 0; i--) ifat[i] = mul(i + 1, ifat[i + 1]);\n\tfor(int i = 0; i < maxn; i++) assert(mul(fat[i], ifat[i]) == 1);\n}\nint ncr(int n, int r){\n\tif(n < r) return 0;\n\treturn mul(fat[n], mul(ifat[r], ifat[n - r]));\n}\nint main(){\n\tinit();\n\tint n, x; cin >> n >> x;\n\tint ans = 0;\n\tfor(int sum = 0; sum < x; sum++){\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif(i <= sum && sum <= 2 * i){\n\t\t\t\tans += mul(ncr(i, sum - i), ncr(n, i));\n\t\t\t\tif(ans >= mod) ans -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 1; j + j <= i; j++){\n\t\t\tint can = i - 2 * j;\n\t\t\tint sum = x - 1 - i;\n\t\t\tif(can > sum && sum >= 0){\n\t\t\t\tans += mul(ncr(can, sum), ncr(n, i));\n\t\t\t\tif(ans >= mod) ans -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tif(x&1){\n\t\tfor(int i = (x + 1) / 2; i <= n; i++){\n\t\t\tans += ncr(n, i);\n\t\t\tif(ans >= mod) ans -= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#include <tuple>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\n\nint mod = 998244353;\nint N, X;\nint comb[3001][6001];\nint f[3001][6001];\nint tate[3002][6002];\nint yoko[3002][6002];\n\nint F(int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\treturn f[a][b];\n}\n\nint Tate(int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\treturn tate[a][b];\n}\n\nint Yoko(int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\treturn yoko[a][b];\n}\n\nint calc(int n, int i) {\n\tint j;\n\tint res = 0;\n\t\n\tfor (j = n - 2 * i - 1; j <= n - i - 1; j++) {\n\t\tres += F(j, X - 2 - 2 * i);\n\t\tres %= mod;\n\t}\n\tfor (j = 0; j < X - 2 - 2 * i; j++) {\n\t\tres += F(n - i - 1, j);\n\t\tres %= mod;\n\t}\n\t\n\t//cout << \"calc(\" << n << \", \" << i << \") = \" << res << endl;\n\treturn res;\n}\n\nint solve(int n) {\n\tint i;\n\tint ret = 0;\n\t\n\tfor (i = 0; i < n; i++) {\t//22…2, i個 + 1 + 何か\n\t\tret += calc(n, i);\n\t\tret %= mod;\n\t}\n\t\n\t//全部2の場合は個別に計算\n\tif (X % 2 == 0) ret += (n * 2 < X);\n\telse ret++;\n\t\n\tret %= mod;\n\treturn ret;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcomb[0][0] = 1;\n\tfor (i = 1; i < 3001; i++) {\n\t\tcomb[i][0] = 1;\n\t\tfor (j = 1; j < 6001; j++) {\n\t\t\tcomb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n\t\t\tcomb[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 3001; i++) {\n\t\tfor (j = i; j <= 2 * i; j++) {\n\t\t\tf[i][j] = comb[i][j - i];\n\t\t}\n\t}\n\t\n\tfor (j = 0; j < 6001; j++) {\n\t\ttate[0][j] = 0;\n\t\tfor (i = 1; i < 3002; i++) {\n\t\t\ttate[i][j] = tate[i - 1][j] + f[i - 1][j];\n\t\t\ttate[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 3001; i++) {\n\t\tyoko[i][0] = 0;\n\t\tfor (j = 1; j < 6002; j++) {\n\t\t\tyoko[i][j] = yoko[i][j - 1] + f[i][j - 1];\n\t\t\tyoko[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tcin >> N >> X;\n\t\n\tint ans = 0;\n\tfor (i = 0; i <= N; i++) {\t//zero\n\t\tint res = comb[N][i] * solve(N - i);\n\t\tres %= mod;\n\t\tans += res;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 3002;\nconst int root = 15311432;\nconst int root_1 = 469870224;\nconst int root_pw = 1<<23;\nconst int mod = 998244353;\n\nint n, x, rev[MAX_N*4], inv[MAX_N*4];\nint pw2[MAX_N], C[MAX_N][MAX_N], f[MAX_N][MAX_N*2], g[MAX_N][MAX_N];\n\nvoid read_input() {\n    cin >> n >> x;\n}\n\nint64_t pw(int n, int k) {\n    if (k==0)\n        return 1;\n    int64_t tmp = pw(n, k/2);\n    if (k%2)\n        return tmp * tmp % mod * n % mod;\n    return tmp * tmp % mod;\n}\n\nvoid NTT(vector<int> &a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        int wlen = invert ? root_1 : root;\n        for (int i = len; i < root_pw; i <<= 1)\n            wlen = (int)(1LL * wlen * wlen % mod);\n\n        for (int i = 0; i < n; i += len) {\n            int w = 1;\n            for (int j = 0; j < len / 2; j++) {\n                int u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);\n                a[i+j] = u + v < mod ? u + v : u + v - mod;\n                a[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;\n                w = (int)(1LL * w * wlen % mod);\n            }\n        }\n    }\n\n    if (invert) {\n        //int n_1 = pw(n, mod-2);\n        int n_1 = inv[n];\n        for (int & x : a)\n            x = (int)(1LL * x * n_1 % mod);\n    }\n}\n\nvoid square(vector<int> &a) {\n    int n = 1;\n    while (n < 2*a.size())\n        n <<= 1;\n    a.resize(n);\n    // PR0(a, a.size());\n\n    NTT(a, false);\n    // PR0(a, a.size());\n\n    for (int i=0; i<n; ++i)\n        a[i] = 1LL * a[i] * a[i] % mod;\n\n    NTT(a, true);\n}\n\nvoid init() {\n    int tmp = 1;\n    while (tmp<(n+1)*2)\n        tmp <<= 1;\n\n    inv[1] = 1;\n    for (int i=2; i<=tmp; ++i)\n       inv[i] = mod - 1LL * inv[mod%i] * (mod / i) % mod;\n\n    for (int i=1, j=0; i<tmp; ++i) {\n        int bit = tmp>>1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n        rev[i] = j;\n    }\n    // PR0(rev, tmp);\n\n    for (int i=0; i<=n; ++i)\n        C[i][0] = C[i][i] = 1;\n\n    for (int i=1; i<=n; ++i) {\n        for (int j=1; j<i; ++j)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;\n    }\n\n    pw2[0] = 1;\n    for (int i=1; i<=n; ++i)\n        pw2[i] = pw2[i-1] * 2 % mod;\n\n    f[0][0] = 1;\n\n    for (int l=1; l<=n; ++l) {\n        for (int s=0; s<=x; ++s) {\n            f[l][s] = f[l-1][s];\n            if (s>=1)\n                f[l][s] = (f[l][s] + f[l-1][s-1]) % mod;\n            if (s>=2)\n                f[l][s] = (f[l][s] + f[l-1][s-2]) % mod;\n        }\n    }\n    // debug(f[n][2]);\n}\n\nint case1() {\n    vector<int> h;\n\n    for (int t=0; t<=x/2; ++t) {\n        h.assign(n+1, 0);\n\n        for (int l=0; l<=n; ++l) {\n            if (l<=t)\n                h[l] = pw2[l];\n            else\n                h[l] = (1LL * h[l-1] * 2 - C[l-1][t] + mod) % mod;\n        }\n\n        square(h);\n        // if (t==1)\n        //     PR0(h, n+1);\n\n        for (int l=0; l<=n; ++l)\n            g[l][t] = h[l];\n    }\n    // debug(g[2][1]);\n\n    int res = 0;\n\n    for (int l=0; n-l-2>=0; ++l) {\n        for (int s=(x+1)%2; s+2<=x; s += 2) {\n            // cerr << l << ' ' << s << ' ' << f[l][s] * g[n-l-2][(x-2-s)/2] << '\\n';\n            res = (res + 1LL * f[l][s] * g[n-l-2][(x-2-s)/2]) % mod;\n        }\n    }\n\n    if (x%2==0)\n        res = (res + g[n-1][(x-1)/2]) % mod;\n    else\n        res = (res + pw2[n]) % mod;\n\n    return res;\n}\n\nint case2() {\n    int res = 0;\n\n    for (int s=x%2; s<x; s += 2)\n        res = (res + f[n][s]) % mod;\n\n    return res;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tread_input();\n\tinit();\n\tcout << (case1() + case2()) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(auto&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(auto&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(auto&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(auto&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(auto&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto& operator<<(auto& o,TRI<S,T,U>& t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 3005;\n\ntemplate <uint mod>\nclass ModInt {\nprivate:\n    uint v;\n    static uint norm(const uint& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const uint& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static uint inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    uint operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        uint v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i);\n\t\tfac[i] = fac[i-1] * i;\n\t\tfinv[i] = finv[i-1] * inv[i];\n\t}\n}\n\nmod comb(int a, int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a] * finv[b] * finv[a-b];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, X;\n    cin >> n >> X;\n    make();\n    mod ans = 0;\n    rep(i,n+1){\n        rep(j,n-i+1){\n            int sm = i+2*j;\n            if(i == 0){\n                if(sm < X || (sm + X) % 2){\n                    ans += comb(n, j);\n                }\n            }else{\n                if(sm < X){\n                    ans += comb(n, i+j) * comb(i+j, i);\n                }else if((i+X)%2){\n                    int t = (sm-(X-1))/2;\n                    if(j >= 2*t){\n                        ans += comb(i+j-2*t,i)*comb(n, i+j);\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// KALAM\n# include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3000 + 77 , NN = 300000 + 77 , Mod = 998244353;\nint n , k , dp[N][(N << 1)] , A;\nint Fact[NN] , InvFact[NN];\ninline int Pow(int x , long long y){\n\tint C = 1;\n\twhile(y){\n\t\tif(y & 1)\n         C = C * 1ll * x % Mod;\n\t\tx = x * 1ll * x % Mod;\n\t\ty >>= 1;\n\t}\n\treturn C;\n}\ninline int Choice(int x , int y){\n\tif(x > y || x < 0)\n      return 0;\n\treturn Fact[y] * 1ll * InvFact[x] % Mod * 1ll * InvFact[y - x] % Mod;\n}\nint main() {\n   Fact[0] = InvFact[0] = 1;\n\tfor(int i = 1;i < NN;i++)\n      Fact[i] = (Fact[i - 1] * 1ll * i) % Mod;\n\tInvFact[NN - 1] = Pow(Fact[NN - 1] , Mod - 2);\n\tfor(int i = NN - 2;i > 0;-- i)\n\t\tInvFact[i] = (InvFact[i + 1] * 1ll * (i + 1)) % Mod;\n\n   dp[0][0] = dp[1][1] = dp[1][2] = 1;\n\n   cin >> n >> k;\n   for(int i = 2;i <= n;++ i)\n      for(int j = 2;j < (N << 1);++ j)\n         dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j - 2]) % Mod;\n   for(int i = 0;i <= n;++ i)\n      for(int j = 0;j < k;++ j) {\n         int ways = dp[i][j];\n         ways = ways * 1ll * Choice(i , n) % Mod;\n         A = (A + ways) % Mod;\n      }\n   for(int j = k + 1;j <= (n << 1);j += 2)\n      for(int i = 0;i <= n;++ i) {\n         if(i * 2 < j)\n            continue ;\n         int ways = Choice(i , n);\n         int need = (j - k + 1) / 2;\n         if(need * 2 < i) {\n            int s = j - need * 4;\n            if(need > j)\n               continue ;\n            ways = ways * 1ll * dp[i - need * 2][s] % Mod;\n         } else if(i * 2 != j) {\n            ways = 0;\n         }\n         A = (A + ways) % Mod;\n      }\n   printf(\"%d\\n\" , A);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mems(a,x) memset(a,x,sizeof(a))\n#define first fi\n#define second se\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353,MS=105,N=3005;\nll inv(ll x){return x==1?x:(mod-mod/x)*inv(mod%x)%mod;}\nll inv(ll x,ll mod){return x==1?x:(mod-mod/x)*inv(mod%x,mod)%mod;}\nll qpow(ll a,ll n){ll ans=1;while(n){if(n&1) ans=ans*a%mod;a=a*a%mod;n>>=1;}return ans;}\nll mul(ll a,ll b){ll ans=0;while(b){if(b&1) ans=(ans+a)%mod;a=(a+a)%mod;b>>=1;};return ans;}\nll qpow(ll a,ll n,ll mod){ll ans=1;while(n){if(n&1) ans=ans*a%mod;a=a*a%mod;n>>=1;}return ans;}\nll mul(ll a,ll b,ll mod){ll ans=0;while(b){if(b&1) ans=(ans+a)%mod;a=(a+a)%mod;b>>=1;};return ans;}\nstruct vec\n{\n    double x,y;\n    vec(double x=0,double y=0):x(x),y(y){}\n    vec operator+(const vec&o)const{ return vec(x+o.x,y+o.y);}\n    vec operator-(const vec&o)const{ return vec(x-o.x,y-o.y);}\n    double operator*(const vec&o)const{ return x*o.x+y*o.y;}\n    double operator^(const vec&o)const{ return x*o.y-y*o.x;}\n    vec operator/(const double&o)const{ return vec(x/o,y/o);}\n    vec operator*(const double&o)const{ return vec(x*o,y*o);}\n    void sc(){scanf(\"%lf%lf\",&x,&y);}\n    double len(){return sqrt(x*x+y*y);}\n};\nstruct Mat\n{\n    ll a[MS][MS];\n    int n,m;\n    Mat(int n=0,int m=0):n(n),m(m) { mems(a,0);}\n    Mat operator*(const Mat&B)const\n    {\n        Mat C(n,B.m);\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=B.m;j++)\n                for(int k=1;k<=m;k++)\n                C.a[i][j]=(C.a[i][j]+a[i][k]*B.a[k][j])%mod;\n        return C;\n    }\n};\nint n,x,c[N][N];\nll dp[N][N<<1];\nll C(ll n,ll m)\n{\n    if(m==0||n==m) return 1;\n    if(m==1) return n;\n    if(c[n][m]) return c[n][m];\n    return c[n][m]=(C(n-1,m-1)+C(n-1,m))%mod;\n}\nll solve(int m)\n{\n    ll ans=0;\n    for(int i=0;i<x;i++) (ans+=dp[m][i])%=mod;\n    for(int i=x+1;i<=2*m;i+=2)\n    {\n        int t=max(0,m-(i-(x-1))),s=i-2*(m-t);\n        if(t>=0&&s>=0)\n            (ans+=dp[t][s])%=mod;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&x);\n    dp[0][0]=1;\n    for(int i=0;i<n;i++)\n        for(int j=i;j<=i*2;j++)\n    {\n        (dp[i+1][j+1]+=dp[i][j])%=mod;\n        (dp[i+1][j+2]+=dp[i][j])%=mod;\n    }\n    ll ans=0;\n    for(int i=0;i<=n;i++)\n        ans=(ans+C(n,i)*solve(i))%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 998244353;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\nsigned main() {\n\tomajinai;\n\tint n, x; cin >> n >> x;\n\tmake_kai(4*n + 1, p1);\n\tint ans = 0;\n\tfor (int a0 = 0; a0 <= n; a0++) {\n\t\tint res = 0;\n\t\tint a12 = n - a0;\n\t\tfor (int sum = 0; sum <= 2 * (n - a0); sum++) {\n\t\t\tif (sum < x) {\n\t\t\t\tint a2 = sum - a12;\n\t\t\t\tres += com(a12, a2, p1);\n\t\t\t}\n\t\t\telse if (sum % 2 != x % 2) {\n\t\t\t\tif (sum >= 2 * x - 2) {\n\t\t\t\t\tif (sum ==2*a12) {\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint b2 = (sum - x + 1) / 2;\n\t\t\t\t\tint inn = sum - 4 * b2;\n\t\t\t\t\tint c12 = a12 - 2 * b2;\n\t\t\t\t\tres += com(c12, inn - c12, p1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres %= p1;\n\t\tres *= com(n, a0, p1);\n\t\tans += res; ans %= p1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\ntemplate<int SZ> struct Combo {\n    mi smallInv[SZ], fac[SZ], ifac[SZ]; \n    vpi factors; vi cnt[SZ];\n\n    void genInv() {\n        if (sz(factors) == 1 && factors[0].s == 1) {\n            F0R(i,2) smallInv[i] = i;\n            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime\n                int x = (MOD+i-1)/i;\n                smallInv[i] = smallInv[i*x-MOD]*x;\n            }\n        } else {\n            F0R(i,SZ) {\n                int x = invGeneral(i,MOD);\n                if (x == -1) smallInv[i] = 0;\n                else smallInv[i] = x;\n            }\n        }\n    }\n    \n    void init() {\n        // factors = factor(MOD); \n        factors = {{MOD,1}}; \n        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ) {\n            cnt[i] = cnt[i-1]; int I = i;\n            F0R(j,sz(factors)) while (I % factors[j].f == 0)\n                I /= factors[j].f, cnt[i][j] ++;\n            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];\n        }\n    }\n\n    mi comb(int a, int b) {\n        if (a < b || b < 0) return 0;\n        auto tmp = fac[a]*ifac[b]*ifac[a-b];\n        F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp *= exp(mi(factors[i].f),t);\n        }\n        return tmp;\n    }\n};\n\nCombo<3001> C;\nint N,X;\nmi tmp[6001];\n\nvoid case1() {\n    F0R(i,N+1) FOR(sum,i,min(X,2*i+1)) tmp[i] += C.comb(i,sum-i);\n}\n\nvoid case2() {\n    for (int sum = X-3; sum > 0; sum -= 2) {\n        int twos = X-1-sum;\n        FOR(i,1,N+1) if (i <= sum && sum <= 2*i) tmp[i+twos] += C.comb(i,sum-i);\n    }\n}\n\nvoid case3() {\n    if (X%2 == 1) {\n        for (int i = max(X-1,1); i <= N; ++i) tmp[i] += 1;\n    }\n    // if (X%2 == 1)\n}\n\nint main() {\n    setIO(); re(N,X); C.init();\n    case1();\n    case2();\n    case3();\n    mi ans = 0;\n    F0R(i,N+1) ans += C.comb(N,i)*tmp[i];\n    ps(ans);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 998244353\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, X;\n\nint dpa[3030][6060]; // len, sum\ni64 dpb[3030][3030]; // two lines; allowed max 2s, sum of # of 0 and 2\nint comb[3030][3030]; // C(i,j)\nint combacc[3030][3030];\nint combacc2[3030][3030];\n\ni64 cumu[3030];\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &X);\n\n\tcomb[0][0] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tcomb[i][0] = 1;\n\t\tfor (int j = 1; j <= N; ++j) comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;\n\t}\n\tfor (int i = 0; i <= N; ++i) {\n\t\tcombacc[i][0] = comb[i][0];\n\t\tfor (int j = 1; j <= N; ++j) {\n\t\t\tcombacc[i][j] = (combacc[i][j - 1] + comb[i][j]) % MOD;\n\t\t}\n\t}\n\tfor (int j = 0; j <= N; ++j) combacc2[0][j] = combacc[0][j];\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 0; j <= N; ++j) {\n\t\t\tcombacc2[i][j] = (combacc2[i - 1][j] + combacc[i][j]) % MOD;\n\t\t}\n\t}\n\t/*\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 0; j <= N; ++j) {\n\t\t\tADD(combacc[i][j], combacc[i - 1][j]);\n\t\t}\n\t}\n\t*/\n\n\tdpa[0][0] = 1;\n\tfor (int i = 0; i <= N; ++i) {\n\t\tfor (int j = 0; j <= 2 * i; ++j) {\n\t\t\tfor (int k = 0; k <= 2; ++k) ADD(dpa[i + 1][j + k], dpa[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= N; ++i) {\n\t\tdpb[0][i] = i + 1;\n\t}\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 0; j <= N; ++j) cumu[j] = dpb[i - 1][j];\n\t\tfor (int j = 1; j <= N; ++j) ADD(cumu[j], cumu[j - 1]);\n\t\tfor (int j = 1; j <= N; ++j) ADD(cumu[j], cumu[j - 1]);\n\n\t\tfor (int j = 0; j <= N; ++j) {\n\t\t\t// both contains 2\n\t\t\tif (j >= 2) ADD(dpb[i][j], cumu[j - 2]);\n\n\t\t\t// only one contains 2\n\t\t\tADD(dpb[i][j], combacc2[j][i] * 2);\n\n\t\t\t// correction (no 2)\n\t\t\tADD(dpb[i][j], MOD - (j + 1));\n\t\t}\n\t\t//for (int j = 0; j <= N; ++j) printf(\"%d %d: %lld\\n\", i, j, dpb[i][j]);\n\t}\n\n\ti64 ret = 0;\n\tfor (int s = 0; s <= 2 * N; ++s) {\n\t\t// ... 1 s 1 ...\n\t\tfor (int l = 2; l <= N; ++l) {\n\t\t\tif (s % 2 == X % 2) {\n\t\t\t\tint maxp = (X - s - 2) / 2 - 1;\n\t\t\t\tif (maxp >= 0) ADD(ret, (i64)dpa[l - 2][s] * combacc[N - l][maxp] % MOD * (N - l + 1));\n\t\t\t\t//printf(\"%d %d: %d %lld\\n\", s, l, maxp, (i64)dpa[l - 2][s] * combacc[N - l][maxp] % MOD * (N - l + 1));\n\t\t\t} else {\n\t\t\t\tint maxp = (X - s - 3) / 2;\n\t\t\t\tif (maxp >= 0) ADD(ret, (i64)dpa[l - 2][s] * dpb[maxp][N - l]);\n\t\t\t\t//printf(\"%d %d: %lld\\n\", s, l, (i64)dpa[l - 2][s] * dpb[maxp][N - l]);\n\t\t\t}\n\t\t\t//printf(\"%d %d %lld\\n\", s, l, ret);\n\t\t}\n\t}\n\t//printf(\"%lld\\n\", ret);\n\n\t// ... 1 ...\n\tif (X % 2 == 1) {\n\t\tint maxp = (X - 1) / 2 - 1;\n\t\tfor (int i = 0; i <= maxp; ++i) ADD(ret, (i64)comb[N - 1][i] * N);\n\t\t//if (maxp >= 0) ADD(ret, (i64)combacc[N - 1][maxp] * N);\n\t} else {\n\t\tint maxp = (X - 2) / 2;\n\t\tif (maxp >= 0) ADD(ret, (i64)dpb[maxp][N - 1]);\n\t}\n\t//printf(\"%lld\\n\", ret);\n\n\t// ...\n\tint yt;\n\tif (X % 2 == 1) yt = N;\n\telse yt = X / 2 - 1;\n\n\tfor (int i = 0; i <= yt; ++i) ADD(ret, comb[N][i]);\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n\tModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\tbool operator<(const ModInt &x)const{return a<x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{return facts[n]*finvs[k]*finvs[n-k];}\n\tinline Mint perm(int n,int k)const{return facts[n]*finvs[n-k];} \n};\nModIntTable<mint,19>mtable;\n\nint N,X;\nmint res[3333];\nvoid calc(){\n\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=i;j<=2*i&&j<X;j++){\n\t\t\t\tres[i]+=mtable.binom(i,j-i);\n\t\t\t\n\t\t}\n\t}\n\n\tfor(int i=1;i<=N&&i*2<X;i++){\n\t\tint m=X-1-2*i;\n\t\tfor(int j=(m+1)/2;j<=m;j++){\n\t\t\tint num=2*i+j;\n\t\t\tif(num>N)break;\n\t\t\tres[num]+=mtable.binom(j,m-j);\n\t\t}\n\t}\n\n\tif(X&1){\n\t\tfor(int i=X;i<=N;i++)res[i]+=1;\n\t}\n}\n\nsigned main(){\n\tcin>>N>>X;\n\n\tcalc();\n\n\tmint ans;\n\tfor(int i=0;i<=N;i++)ans+=res[i]*mtable.binom(N,i);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  //mint(long long);\n  mint(long long v) : v( fast == 0 ? (v % MODS[kind] + MODS[kind]) % MODS[kind]  : v % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  if(kind==1) {\n    a.v += b.v;\n    return a;\n\n  }\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  if(kind==1) {\n    a.v += b;\n    return a;\n\n  }\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\nvector<vector<mint<>>> comb_table;\n\n\nmint<> comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return comb_table[N][K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+6);\n  for(int i=0; i<=N; i++) {\n    comb_table[i].resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<i; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n    }\n  }\n  \n}\n\n\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  \n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1);// % MOD ;\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2);// % MOD;\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 998244353\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nstruct Fact{\n\tvector<long> f;\n\tvector<long> rf;\n\tlong pow(long N,long K){\n\t\tif(K == 0){\n\t\t\treturn 1;\n\t\t}\n\t\telse if(K % 2 == 0){\n\t\t\tlong t = pow(N,K/2);\n\t\t\treturn t*t%mod;\n\t\t}\n\t\telse{\n\t\t\treturn N*pow(N,K-1)%mod;\n\t\t}\n\t}\n\tFact(int N):f(N+1),rf(N+1){\n\t\tfor(int i=0;i<N+1;i++){\n\t\t\tif(i == 0){\n\t\t\t\tf[i] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tf[i] = (f[i-1]*i)%mod;\n\t\t\t}\n\t\t}\n\t\tfor(int i=N;i>=0;i--){\n\t\t\tif(i == N){\n\t\t\t\trf[i] = pow(f[N],mod-2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trf[i] = rf[i+1]*(i+1)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong GetFact(int N){\n\t\treturn f[N];\n\t}\n\tlong GetPerm(int N,int R){\n\t\treturn f[N] * rf[N-R] % mod;\n\t}\n\tlong GetConv(int N,int R){\n\t\treturn ((f[N]*rf[R])%mod*rf[N-R])%mod;\n\t}\n\tlong GetRev(int N){\n\t\tif(N == 0){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn rf[N] * f[N-1] % mod;\n\t\t}\n\t}\n};\nvoid Calc(){\n\tint N = rei();\n\tint X = rei();\n\tlong ans = 0;\n\tFact F(N);\n\tfor(int i=0;i*2<X;i++){\n\t\tfor(int j=0;j+i*2<X;j++){\n\t\t\tif(i+j > N){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans += F.GetConv(N,i+j) * F.GetConv(i+j,i) % mod;\n\t\t}\n\t}\n\tif(X % 2 == 1){\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tif(i*2 > X){\n\t\t\t\tans += F.GetConv(N,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=X+1;i<=2*N;i+=2){\n\t\tint tworow = (i-X+1);\n\t\tint s = i-tworow*2;\n\t\tfor(int t=0;t*2<=s;t++){\n\t\t\tint o = s - t*2;\n\t\t\tif(o+tworow+t > N){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(o != 0){\n\t\t\t\tans += F.GetConv(N,o+tworow+t) * F.GetConv(o+t,t) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tans %= mod;\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#include <iostream>\n#include <bitset>\n#define PII pair <int, int>\n#define PPI pair <PII, int>\n#define x first\n#define y second\n#define P 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N, X;\n\nll F[2][6010][2][3], G[3010][6010], C[6010][6010];\n\nvoid add(ll &x, ll y) {\n    x = (x + y) % P;\n}\nint main() {\n    scanf(\"%d%d\", &N, &X);\n    G[0][0] = 1;\n    ll ans = 0;\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < X; j++) {\n            add(G[i + 1][j], G[i][j]);\n            add(G[i + 1][j + 1], G[i][j]);\n            add(G[i + 1][j + 2], G[i][j]);\n        }\n    if(X % 2 == 1) {\n        for(int i = 0; i <= N; i++)\n            for(int j = 0; j <= i; j++)\n                C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n        for(int i = X; i <= N; i++)\n            add(ans, C[N][i]);\n    }\n    for(int i = 0; i < X; i++) add(ans, G[N][i]);\n    int a = 0, b = 1;\n    memset(F, 0, sizeof F);\n    F[a][0][0][1] = 1;\n    for(int i = 0; i < N - 1; i++, swap(a, b)) {\n        memset(F[b], 0, sizeof F[b]);\n        for(int o = 0; o < X; o++)\n            for(int s = 0; s < 2; s++)\n                for(int k = 1; k < 3; k++)\n                    for(int l = 0; l + k < 3; l++) {\n                        add(F[b][o + l][s][k + l], F[a][o][s][k]);\n                        if(l) add(F[b][o + l][!s][l], F[a][o][s][k]);\n                    }\n        for(int o = 1; o < X; o++)\n            for(int k = 1; k < 3; k++)\n                for(int l = 1; l + k < 3; l++)\n                    add(ans, 1LL * F[b][o][1][k] * G[N - i - 2][X - 1 - o - l] % P);\n    }\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n\tModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\tbool operator<(const ModInt &x)const{return a<x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{return facts[n]*finvs[k]*finvs[n-k];}\n\tinline Mint perm(int n,int k)const{return facts[n]*finvs[n-k];} \n};\nModIntTable<mint,19>mtable;\n\nint N,X;\nmint res[3333];\nvoid calc(){\n\tres[0]=1;\n\tfor(int i=1;i<=N;i++){\n\t\tres[i]=res[i-1]*2;\n\t\tfor(int j=max(X-2,0ll);j<X;j++){\n\t\t\tif(j<i-1||(i-1)*2<j)continue;\n\t\t\tmint w=mtable.binom(i-1,j-(i-1));\n\t\t\tfor(int k=1;k<=2;k++){\n\t\t\t\tif(j+k>=X)res[i]-=w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=1;i<=N&&i*2<X;i++){\n\t\tint m=X-1-2*i;\n\t\tfor(int j=(m+1)/2;j<=m;j++){\n\t\t\tint num=2*i+j;\n\t\t\tif(num>N)break;\n\t\t\tres[num]+=mtable.binom(j,m-j);\n\t\t}\n\t}\n\n\tif(X&1){\n\t\tfor(int i=X;i<=N;i++)res[i]+=1;\n\t}\n}\n\nsigned main(){\n\tcin>>N>>X;\n\n\tcalc();\n\n\tmint ans;\n\tfor(int i=0;i<=N;i++)ans+=res[i]*mtable.binom(N,i);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n314 159\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=3005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=998244353;\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll C[maxn][maxn];\n\nint main()\n{\n\tIOS;\n\tll n,x;\n\tcin>>n>>x;\n\n\tREP(i,maxn-1) for(int j=0;j<=i;j++){\n\t\tif(j==0||j==i) C[i][j]=1;\n\t\telse{\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t\tif(C[i][j]>=MOD) C[i][j]-=MOD;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int len=0;len<=n;len++){\n\t\tll sum=0;\n\n\t\tfor(int a=1;a+a<=len;a++){\n\t\t\tif(x-1-len>=0){\n\t\t\t\tsum+=C[len-a-a][x-1-len];\n\t\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int t=len;t<x;t++){\n\t\t\tsum+=C[len][t-len];\n\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t}\n\t\tif(x%2==1&&2*len>=x&&len>=x) sum++;\n\t\t// cout<<len<<' '<<sum<<' '<<C[n][n-len]<<'\\n';\n\t\tans+=sum*C[n][n-len]%MOD;\n\t\tif(ans>=MOD) ans-=MOD;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#include <tuple>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\n\nint mod = 998244353;\nint N, X;\nint comb[3001][6001];\nint f[3001][6001];\nint tate[3002][6002];\nint yoko[3002][6002];\n\nint Tate(int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\treturn tate[a][b];\n}\n\nint Yoko(int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\treturn yoko[a][b];\n}\n\nint calc(int n, int i) {\n\tint a = Tate(n - i + 1, X - 1 - 2 * i);\n\tint b = Tate(n - 2 * i, X - 1 - 2 * i);\n\tint c = Yoko(n - i, X - 1 - 2 * i);\n\tint res = (a - b + mod) % mod;\n\tres += c;\n\tres %= mod;\n\t//cout << \"calc(\" << n << \", \" << i << \") = \" << res << endl;\n\treturn res;\n}\n\nint solve(int n) {\n\tint i;\n\tint ret = 0;\n\t\n\tfor (i = 0; i <= n; i++) {\n\t\tret += calc(n, i);\n\t\tret %= mod;\n\t}\n\treturn ret;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcomb[0][0] = 1;\n\tfor (i = 1; i < 3001; i++) {\n\t\tcomb[i][0] = 1;\n\t\tfor (j = 1; j < 6001; j++) {\n\t\t\tcomb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n\t\t\tcomb[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 3001; i++) {\n\t\tfor (j = i; j <= 2 * i; j++) {\n\t\t\tf[i][j] = comb[i][j - i];\n\t\t}\n\t}\n\t\n\tfor (j = 0; j < 6001; j++) {\n\t\ttate[0][j] = 0;\n\t\tfor (i = 1; i < 3002; i++) {\n\t\t\ttate[i][j] = tate[i - 1][j] + f[i - 1][j];\n\t\t\ttate[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 3001; i++) {\n\t\tyoko[i][0] = 0;\n\t\tfor (j = 1; j < 6002; j++) {\n\t\t\tyoko[i][j] = yoko[i][j - 1] + f[i][j - 1];\n\t\t\tyoko[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tcin >> N >> X;\n\t\n\tint ans = 0;\n\tfor (i = 0; i <= N; i++) {\t//zero\n\t\tint res = comb[N][i] * solve(N - i);\n\t\tres %= mod;\n\t\tans += res;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 998244353\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(auto&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(auto&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(auto&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(auto&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(auto&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto& operator<<(auto& o,TRI<S,T,U>& t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 3005;\n\ntemplate <uint mod>\nclass ModInt {\nprivate:\n    uint v;\n    static uint norm(const uint& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const uint& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static uint inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    uint operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        uint v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i);\n\t\tfac[i] = fac[i-1] * i;\n\t\tfinv[i] = finv[i-1] * inv[i];\n\t}\n}\n\nmod comb(int a, int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a] * finv[b] * finv[a-b];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, X;\n    cin >> n >> X;\n    make();\n    mod ans = 0;\n    rep(i,n+1){\n        rep(j,n-i+1){\n            int sm = i+2*j;\n            if(i == 0){\n                if(sm < X || (sm + X) % 2){\n                    ans += comb(n, j);\n                }\n            }else{\n                if(sm < X){\n                    ans += comb(n, i+j) * comb(i+j, i);\n                }else if((i+X)%2){\n                    int t = (sm-(X-1))/2;\n                    if(j >= 2*t){\n                        ans += comb(i+j-2*t,i)*comb(n, i+j);\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "9 13"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout.precision(12);\n    cout.setf(ios_base::fixed, ios_base::floatfield);\n    \n    static bool not_prime[100000];\n    vector<int> ps;\n    not_prime[1] = true;\n    for(int i=2;i<100000;i++){\n        if(not_prime[i]) continue;\n        for(int64_t j=2;j*i<100000;j++) not_prime[i*j] = true;\n    }\n    for(int i=2;i<100000;i++) if(not_prime[i] == false) ps.push_back(i);\n\n    int n;\n    cin >> n;\n    int64_t a[10001];\n    for(int i=n;i>=0;i--) cin >> a[i];\n\n    int zc = 0;\n    for(int i=0;a[i]==0;i++) zc++;\n    if(zc > 0){\n        for(int i=0;i<=n-zc;i++){\n            a[i] = a[i+zc];\n            a[i+zc] = 0;\n        }\n        n -= zc;\n    }\n\n    set<int64_t> kouho;\n    int64_t a0 = a[0] >= 0 ? a[0] : -a[0];\n    for(int p : ps){\n        if(a0 % p == 0){\n            kouho.insert(p);\n        }\n        while(a0 % p == 0){\n            a0 /= p;\n            if(a0 <= 1) goto pok;\n        }\n    }pok:;\n    if(a0 > 1) kouho.insert(a0);\n\n    for(auto kit = kouho.begin(); kit!=kouho.end(); ++kit){\n        auto ans = *kit;\n        for(int x=ans-1;x>=ans-1000;x--){\n            int64_t v = a[n];\n            for(int i=n-1;i>=0;i--){\n                v = (v*x%ans + a[i]) % ans;\n            }\n            if(v%ans != 0){\n                goto next;\n            }\n        }\n\n        cout << ans << endl;\n        next:;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <random>\n#include <stack>\n#include <set>\n#include <unordered_set>\n\n#define bug(x) cout<<\"zdongdebug: \"<<x<<endl;\n#define bug2(x, y) cout<<\"zdongdebug: \"<<x<<\" \"<<y<<endl;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3005;\nconst int mod = 998244353;\nll c[maxn][maxn];\nll f[maxn][maxn];\nvoid pd(ll&ret,ll val){\n  ret+=val;\n  if(ret>=mod)ret-=mod;\n}\nvoid init() {\n  f[0][0] = 1;\n  for (int i = 0; i < maxn; i++)c[i][0] = c[i][i] = 1;\n  for (int i = 1; i < maxn; i++)\n    for (int j = 1; j < i; j++) {\n      c[i][j] = c[i - 1][j] + c[i - 1][j - 1];\n      if (c[i][j] >= mod)c[i][j] -= mod;\n    }\n}\n\nint n,m;\nint sq[maxn];\nint ans;\nvoid dfs(int pos) {\n  if(pos == n) {\n    for(int i=0;i<n;i++){\n      int sum = 0;\n      for(int j=i;j<n;j++){\n        sum+=sq[j];\n        if(sum==m)return;\n      }\n    }\n    ans++;\n    if(ans>mod)ans-=mod;\n    return;\n  }\n  for(int i=0;i<3;i++){\n    sq[pos]=i;\n    dfs(pos+1);\n  }\n}\n\nint main() {\n#ifdef suiyuan2009\n  freopen(\"/Users/suiyuan2009/CLionProjects/icpc/input.txt\", \"r\", stdin);\n#endif\n  init();\n  cin>>n>>m;\n // dfs(0);\n // bug(ans)\n  for(int i=1;i<=n;i++) {\n    for (int j = 1; j < m; j++) {\n      if (2 * i < j)break;\n      f[i][j] = c[i][2 * i - j];\n    }\n    if((m&1)&&2*i>m)f[i][2*i]=1;\n    for (int j = 1; j + j <i&&(j+j<m-1);j++) {\n      if(m-1+2*j!=2*i)\n      pd(f[i][m-1+2*j],f[i-j-j][m-1-2*j]);\n    }\n  }\n  //bug(f[1][2])\n  ll ret = 1;\n  for(int i=1;i<=n;i++){\n    ll sum = 0;\n    for(int j=1;j<=i+i;j++)pd(sum, f[i][j]);\n    pd(ret, sum*c[n][i]%mod);\n  }\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\n#define rep(i,n) for(ll i = 0; i < ll(n); i++)\n#define reep(i,n) for(ll i = n; i >-1; i--)\n#define deb(variable) cout<<#variable<<\"=\"<<variable<<endl;\n#define pb push_back\nconst ll INF=99999999999999999;\nconst ll MOD=998244353;\nconst ll MAX_N=100010;\nll a,b,c,d,e,x,y,z,k,m,n,l,q,ans=0;\nvl v;\nll kaijo[3001];\nstring s;\nll gyaku(ll a){\n    b=1;\n    ll beki[40];\n    beki[0]=a;\n    k=MOD-2;\n    rep(i,30){\n        beki[i+1]=(beki[i]*beki[i])%MOD;\n    }\n    for(ll i=0;k>0;i++){\n        if(k%2==1)b=(b*beki[i])%MOD;\n        k=k/2;\n    }\n\n    return b;\n}\nll solve(ll x,ll y){\n    y-=x;\n    k=x-labs(y);\n    a=0;\n    for(ll i=0;i*2+k<x+1;i++){\n        a=(((a+kaijo[n]*gyaku(kaijo[k+i]))%MOD*gyaku(kaijo[i]))%MOD*gyaku(kaijo[x-k-i*2]))%MOD;\n    }\n\n    return a;\n}\nint main(){\n    cin>>n>>x;\n    ll bbeki[3001];\n    bbeki[0]=1;\n    rep(i,3000){\n        bbeki[i+1]=(bbeki[i]*3)%MOD;\n    }\n\n    kaijo[0]=1;\n    rep(i,3000){\n        kaijo[i+1]=(kaijo[i]*(i+1))%MOD;\n    }\n\n    //if(x>1){\n        rep(i,n-1){\n            ans+=solve(i,x-1);\n        }\n        rep(i,n-1){\n            ans+=solve(i,x-2);\n        }\n    //}\n\n    ans=ans%MOD;\n\ncout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << x.v;\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\nvector<mint<>> table;\nvector<vector<mint<>>> comb_table;\n\n\nmint<> comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return comb_table[N][K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+6);\n  \n  for(int i=0; i<=N; i++) {\n    comb_table[i].resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<i; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n    }\n  }\n  \n}\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1);\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2);\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n\n    }\n  }\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) FOR(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\ntemplate<class T> using V=vector<T>;\ntemplate<class T> using VV=V<V<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\trep(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?1:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tstatic constexpr int base=mod;\n\tint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\tv=vv%mod;\n\t\tif(v<0)v+=mod;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tbool operator!=(const ModInt&rhs)const{\n\t\treturn v!=rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ll(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\n//using mint=ModInt<1000000007>;\nusing mint=ModInt<998244353>;\n\nconst int Vmax=min<int>(2000010,mint::base);\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nconst int Nmax=3010;\nmint dp[Nmax][Nmax*2][2];\n\nsigned main(){\n\tint n=read(),x=read();\n\tdp[0][0][0]=1;\n\trep(i,n)rep(j,i*2+1)rep(k,2){\n\t\tdp[i+1][j+1][k|1]+=dp[i][j][k];\n\t\tdp[i+1][j+2][k]+=dp[i][j][k];\n\t}\n\tmint ans=0;\n\trep(i,n+1){\n\t\tmint w;\n\t\tif(i*2>x&&x%2)w+=1;\n\t\trep(j,x)\n\t\t\tw+=dp[i][j][0]+dp[i][j][1];\n\t\tFOR(k,1,i/2+1){\n\t\t\tint rem=x-1-2*k;\n\t\t\tif(rem>=0){\n\t\t\t\tcerr<<i<<\" \"<<k<<\" \"<<rem<<\" \"<<dp[i-2*k][rem][1]<<endl;\n\t\t\t\tw+=dp[i-2*k][rem][1];\n\t\t\t}\n\t\t}\n\t\tcerr<<i<<\" \"<<w<<endl;\n\t\tans+=Choose(n,i)*w;\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << x.v;\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\nvector<mint<>> kaijo;\nvoid init() {\n  kaijo.push_back(mint<>(1));\n  for (int i = 1; i <= 400000; i++) {\n    kaijo.push_back(kaijo.back() * i);\n  }\n}\n\nmint<> comb(LL N, LL K) {\n  if (K < 0) return mint<>(0);\n  if (K > N) return mint<>(0);\n  return kaijo[N] / kaijo[N - K] / kaijo[K];\n}\n\n\nvoid solve(long long N, long long X){\n  init();\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1);\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2);\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n\n    }\n  }\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, vector<vector<int>>& scc, stack<int>& S, vector<int>& inS, vector<int>& low,vector<int>& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(vector<int>());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph& g, vector<vector<int>>& scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tvector<int> num(n), low(n);\n\tstack<int> S;\n\tvector<int> inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n);\n\t\tinv[n - 1] = mod_inv(fact[n - 1]);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\nll dp[3030][3030];\nll dp2[3030][3030];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tconstexpr ll mod = 998244353;\n\tll n, x;\n\tcin >> n >> x;\n\tdp[0][0] = 1;\n\tREP(i, n)REP(j, x) {\n\t\tREP(k, 3)(dp[i + 1][j + k] += dp[i][j]) %= mod;\n\t}\n\tdp2[0][0] = 1;\n\tREP(i, n)REP(j, x+1) {\n\t\tREP(k, 2)(dp2[i + 1][j + 1 + k] += dp2[i][j]) %= mod;\n\t}\n\n\tll ans = 0;\n\tREP(i, x)(ans += dp[n][i]) %= mod;\n\tCombination comb(n, mod);\n\tif (x % 2 == 1) {\n\t\trep(i, x - 1, n + 1) {\n\t\t\tif (i == 0)continue;\n\t\t\tll tmp = n - i;\n\t\t\t(ans += comb.nCr(n, tmp)) %= mod;\n\t\t}\n\t}\n\n\tfor (int i = x + 1; i - (x - 1) < x -1; i += 2) {\n\t\tll l = i - (x-1);\n\t\tll d = x - 1 - l;\n\t\tll num = l;\n\t\tREP(j, n + 1) {\n\t\t\tif (j + num > n)continue;\n\t\t\tll tmp = j + num;\n\t\t\t(ans += comb.nCr(n, tmp) * dp2[j][d] % mod) %= mod;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    int m=fact.size();\n    if(n<m) return;\n    \n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n    \n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    if(n==0) return Mint(1);\n    k=min(k,n);\n    init(k);    \n    vector<Mint> dp(k+1);\n    dp[0]=Mint(1);\n    for(int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);    \n    Mint res;\n    for(int i=1;i<=k;i++)\n      res+=Mint(i).pow(n)*finv[i]*dp[k-i];    \n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nusing M = Mint<int, 998244353>;\nsigned main(){\n  M::init(1e5);\n\n  auto calc=[&](int a,int b){return M::C(b,a-b);};\n  \n  int n,x;\n  cin>>n>>x;\n\n  M ans(1);\n  for(int s=0;s<x;s++)\n    for(int p=1;p<=n;p++)\n      ans+=calc(s,p)*M::C(n,p);\n\n  for(int s=x+1;s<=n*2;s+=2){\n    int i=(s-x+1)/2;\n    if(s-4*i<0){\n      if(~s&1) ans+=M::C(n,s/2);\n    }else{    \n      for(int p=2*i;p<=n;p++)\n        ans+=calc(s-4*i,p-2*i)*M::C(n,p);\n    }\n  }\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define x first\n#define y second\n#define N 131072\n#define pi acos(-1)\nint mod=998244353;\nLL fra[10005];\nLL inv[10005];\nLL f_pow(LL a,LL b){\n\tLL res=1,temp=a;\n\twhile(b){\n\t\tif(b&1)res=res*temp%mod;\n\t\ttemp=temp*temp%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nvoid build(){\n\tfra[0]=1;\n\tfor(int i = 1;i<10005;i++){\n\t\tfra[i]=fra[i-1]*i%mod;\n\t}\n\tinv[10004]=f_pow(fra[10004],mod-2);\n\tfor(int i = 10003;i>=0;i--){\n\t\tinv[i]=inv[i+1]*(i+1)%mod;\n\t}\n}\nLL C(LL a,LL b){\n\treturn fra[a]*inv[b]%mod*inv[a-b]%mod;\n}\nint main(){\n\tbuild();\n\tint n,x;\n\tscanf(\"%d %d\",&n,&x);\n\tint len[3005];\n\tfill(len,len+n+1,0);\n\tlen[0]=1;\n\tfor(int i = 1;i<=n;i++){\n\t\tfor(int j = 0;j<x;j++){\n\t\t\tint two=j-i,one=i-two;\n\t\t\tif(one<0||two<0)\n\t\t\tcontinue;\n\t\t\t//printf(\"%d %d\\n\",two,one);\n\t\t\tlen[i]+=C(two+one,one);\n\t\t\tlen[i]%=mod;\n\t\t}\n\t\tif(x&1){\n\t\t\tif(i*2>x)\n\t\t\t\tlen[i]++;\n\t\t}\n\t//\tprintf(\"%d\\n\",len[i]);\n\t\tif(i>=2){\n\t\t\tfor(int k = 2;k<=i;k+=2){\n\t\t\t\tint templ=i-k;\n\t\t\t\tint j = x-1-k;\n\t\t\t\tint two= j-templ,one=templ-two;\n\t\t\t\tif(one<=0||two<0){\n\t\t\t\t\t//printf(\"%d\\n\",len[i]);\n\t\t\t\t\t//continue;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlen[i]+=C(two+one,one);\n\t\t\t\t\tlen[i]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tprintf(\"%d\\n\",len[i]);\n\t}\n\tLL ans=0;\n\tfor(int i = 0;i<=n;i++){\n\t\tans+=len[i]*C(n,i)%mod;\n\t//\tprintf(\"%d %d\\n\",len[i],C(n,i));\n\t\tans%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\n\n\nll dp[3030][6060],sum[3030][6060];\nint main(){\n    mod_build();\n    int n,x;\n    cin>>n>>x;\n    ll ans=0;\n    rep(i,n+1)rep(j,2*n+1){\n        dp[i][j]=comb(i,j-i);\n        sum[i][j]=comb(i,j-i);\n    }\n    rep(i,n)rep(j,2*n+1){\n        (dp[i+1][j]+=dp[i][j])%=mod;\n    }\n    rep(i,n+1)rep(j,2*n){\n        (sum[i][j+1]+=sum[i][j])%=mod;\n    }\n    rep(k,n+1){\n        ll res=0;\n        rep(i,k){\n            if(x<2*i+2)break;\n            int s=x-2*i-2;\n            res+=sum[k-i-1][x-2*i-3];\n            res+=dp[k-i-1][x-2*i-2]-(k-2*i-2>=0?dp[k-2*i-2][x-2*i-2] : 0);\n            res=(res+mod)%mod;\n        }\n        if(x%2==1||2*k<x)++res;\n        ans+=res*comb(n,k)%mod;\n    }\n    cout<<ans%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = (a*b) % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = 1;\n    fact[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact[i] = fact[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = 1;\n    seq_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = 1;\n    fact_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint main(){\n    int N, X;\n    cin >> N >> X;\n    create_mod_tables(6010);\n\n    static int64_t dp[3001][6010], dp2[3001][6010];\n    dp[0][0] = 1;\n    dp2[0][0] = 1;\n    for(int i=0; i<N; i++) for(int j=0; j<=2*N; j++){\n        for(int k=0; k<=2; k++) add(dp[i+1][j+k], dp[i][j]);\n        for(int k=1; k<=2; k++) add(dp2[i+1][j+k], dp2[i][j]);\n    }\n    int64_t ans = 0;\n    for(int j=0; j<X; j++) add(ans, dp[N][j]);\n\n    for(int y=1; X+y<=2*N; y+=2){\n        if(y+1 < X-1){\n            for(int n=1; n+y+1<=N; n++){\n                int64_t result = dp2[n][X-y-2];\n                mul(result, comb_mod(N, n+y+1));\n                add(ans, result);\n            }\n        }else{\n            if(X%2) add(ans, comb_mod(N, (X+y)/2));\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\n#ifdef LOCAL\n#define show(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<998244353>;\ntemplate<> const Mint Mint::G = Mint(3);\n\nconst int MN = 3030;\nMint fact[10000], iFac[10000];\n\nMint C(int n, int k) {\n    if (n < k || k < 0) return Mint(0);\n    return fact[n] * iFac[k] * iFac[n - k];\n}\n\nMint dp[MN][2 * MN];\n\nvoid first() {\n    fact[0] = 1;\n    for (int i = 1; i < 10000; i++) {\n        fact[i] = fact[i - 1] * i;\n    }\n    for (int i = 0; i < 10000; i++) {\n        iFac[i] = fact[i].inv();\n    }\n    dp[0][0] = Mint(1);\n    for (int i = 1; i < MN; i++) {\n        for (int j = 0; j < 2 * MN; j++) {\n            dp[i][j] += dp[i - 1][j];\n            if (j - 1 >= 0) dp[i][j] += dp[i - 1][j - 1];\n            if (j - 2 >= 0) dp[i][j] += dp[i - 1][j - 2];\n        }\n    }\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    first();\n\n    int n, x;\n    cin >> n >> x;\n\n    Mint sm = 0;\n    for (int i = 0; i <= x - 1; i++) sm += dp[n][i];\n\n    for (int c = 1; x - 1 - 2 * c >= 0 && n - 2 * c >= 0; c++) {\n        int n2 = n - 2 * c;\n        for (int i = 0; i <= n2; i++) {\n            sm += dp[i][x - 1 - 2 * c] * C(n2 - i + 2 * c - 1, 2 * c - 1);\n        }\n    }\n\n    if (x % 2) {\n        for (int he = x; he <= n; he++) {\n            sm += C(n, he);\n        }\n    }\n    cout << sm << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=998244353,N=5e5+5;\nint fac[N],inv[N];\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1; \n\t}\n\treturn res;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n}\nint C(int n,int m){\n\tif(n<0||m<0||n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint X;\nvoid add(int &x,int y){\n\tx=(x+y)%mod;\n}\nint calc(int n){\n\tint ans=(2*n<X || X&1);\n\tfor(int i=n;i<=n+n-1;++i)\n\t\tif(i<X) add(ans,C(n,i-n));\n\t\telse if((i-X+1)%2==0){\n\t\t\tint p=(i-X+1)/2;\n\t\t\tadd(ans,C(n-(p<<1),i-(p<<2)-(n-(p<<1))));\n\t\t}\n\treturn ans;\n}\nsigned main(){\n\tint n,ans=0;\n\tcin>>n>>X;\n\tinit(max(n,X));\n\tfor(int i=0;i<=n;++i)\n\t\tadd(ans,C(n,i)*calc(i)%mod);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst long long MOD=998244353;\n\nlong long add_mod(long long x,long long y){\n\treturn (x+y)%MOD;\n}\n\nlong long sub_mod(long long x,long long y){\n\treturn (x-y+MOD)%MOD;\n}\n\nlong long mul_mod(long long x,long long y){\n\treturn x*y%MOD;\n}\n\nlong long inv_mod(long long x){\n\tif(x == 1) return 1;\n\tlong long d = MOD/x+1;\n\treturn d*inv_mod(x-(MOD%x))%MOD;\n}\n\nlong long div_mod(long long x, long long y){\n\treturn x*inv_mod(y)%MOD;\n}\n\nlong long pow_mod(long long x,long long y){\n\tlong long r = 1;\n\tfor(long long n = x;y != 0;y /= 2,n = mul_mod(n,n)){\n\t\tif(y % 2){\n\t\t\tr = mul_mod(r,n);\n\t\t}\n\t}\n\treturn r;\n}\n\nint i,j,k,n,x;\nlong long dp[9999];\nlong long c[3000][3000];\n\nint main(){\n  long long ans = 0;\n  cin >> n >> x;\n  dp[0] = 1;\n  for(i = 0;i < n;i++){\n    for(j = 2*i;j >= 0;j--){\n      dp[j+2] = add_mod(dp[j+2],add_mod(dp[j+1],dp[j]));\n    }\n    dp[1] = add_mod(dp[1],dp[0]);\n  }\n  for(i = 0;i < x;i++)ans = add_mod(ans,dp[i]);\n  if(x%2){\n    memset(dp,0,sizeof(dp));\n    dp[0] = 1;\n    for(i = 0;i < n;i++){\n      for(j = 2*i;j >= 0;j--){\n        dp[j+2] = add_mod(dp[j+2],dp[j]);\n      }\n    }\n    for(i = x+1;i <= 2*n;i+=2) ans = add_mod(ans,dp[i]);\n  }\n  else{\n    c[0][0] = 1;\n    for(i = 1;i < n;i++){\n      c[i][0] = 1;\n      for(j = 1;j <= i;j++){\n        c[i][j] = add_mod(c[i-1][j-1],c[i-1][j]);\n      }\n    }\n    for(i = 1;i < n-1;i++){\n      for(j = 1;j <= i;j++){\n        for(k = x/2-j;k <= n-1-i;k++){\n          ans = add_mod(ans,mul_mod(c[i][j],c[n-1-i][k]));\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 998244353;\nll inv[10000100];\nll FactorialInv[10000100];\nll Factorial[10000100];\nll beki(ll a, ll b){\n    a %= mod;\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    const int MAX = 10000002;\n    Factorial[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= MAX; i++){\n        Factorial[i] = Factorial[i - 1] * i % mod;\n    }\n    FactorialInv[MAX] = beki(Factorial[MAX], mod - 2);\n    for(ll i = MAX - 1; i >= 0; i--) {\n        FactorialInv[i] = FactorialInv[i+1] * (i+1) % mod;\n    }\n    for(int i = 1; i <= MAX; i++) {\n        inv[i] = FactorialInv[i] * Factorial[i-1] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\nll N, X;\nll ans;\n\nint main() {\n    //cout.precision(10);\n    cin >> N >> X;\n    init_combination();\n    for(ll sum = 0; sum <= 2 * N; sum++) {\n        if(sum >= X and sum % 2 == X % 2) continue;\n        if(sum < X) {\n            for(ll num = 0; num <= sum; num++) {\n                ll two = sum - num;\n                ll one = num - two;\n                ll zero = N - two - one;\n                if(two < 0 or one < 0 or zero < 0) continue;\n                ll tmp = combination(N, one) * combination(N - one, two) % mod;\n                ans += tmp;\n                ans %= mod;\n            }\n        }\n        if(sum >= X) {\n            ll sidetwo = (sum - X + 1);\n            for(ll mid = 0; mid <= sum; mid++) {\n                ll two = (sum - 2 * sidetwo) - mid;\n                ll one = mid - two;\n                ll zero = N - sidetwo - two - one;\n                //cerr << sum << \" \" << sidetwo << \" \" << two << \" \" << one << \" \" << zero << endl;\n                if(sidetwo < 0 or two < 0 or one < 0 or zero < 0) continue;\n                ll tmp = combination(N, zero) * combination(one + two, one) % mod;\n                ans += tmp;\n                ans %= mod;\n            }\n            if(sidetwo * 2 > sum and X % 2 == 1) {\n                ll tmp = combination(N, sum / 2);\n                //cerr << sum << \" \" << sidetwo << endl;\n                ans += tmp;\n                ans %= mod;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dp[6100][6100];\nconst ll M = 998244353;\nll ch(int a,int b) {\n\tif(b < 0 || b > a) return 0;\n\tif(b == 0 || b == a) return 1;\n\tif(dp[a][b] != -1) return dp[a][b];\n\tll val = ch(a-1,b-1)+ch(a-1,b);\n\tif(val >= M) val -= M;\n\treturn dp[a][b] = val;\n}\nint main() {\n\tint n,x;\n\tcin >> n >> x;\n\tmemset(dp,-1,sizeof(dp));\n\tll tot = 0;\n\tfor(int i=0;i<x;i++) {\n\t\tfor(int j=0;j<=x-1-i;j++) {\n\t\t\ttot += ch(i,j)*ch(n,i);\n\t\t\ttot %= M;\n\t\t}\n\t}\n\t//cout << tot << '\\n';\n\tif(x%2) {\n\t\tint st = max(x-1,(x+1)/2);\n\t\tfor(int i=st;i<=n;i++) {\n\t\t\ttot += ch(n,i);\n\t\t\ttot %= M;\n\t\t}\n\t\t//cout << tot << '\\n';\n\t}\n\tfor(int i=1;2*i<x-1;i++) {\n\t\tfor(int j=0;x-1-2*i-j>=0;j++) {\n\t\t\ttot += ch(x-1-2*i-j,j)*ch(n,x-1-j);\n\t\t\ttot %= M;\n\t\t\t//cout << ch(x-1-2*i-j,j) << \" * \" << ch(n,x-1-j) << \"ad\\n\";\n\t\t}\n\t\t//cout << tot << '\\n';\n\t}\n\ttot %= M;\n\tcout << tot << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\n//#define MOD 1000000007\n#define MOD 998244353\n#define mod 998244353\nstruct mint {\n\tint i;\n\tmint() : i(0) {}\n\tmint(int x) {\n\t\ti = int(x % MOD);\n\t\tif (i < 0) i += MOD;\n\t}\n\ttemplate<class T> mint(T x) {\n\t\ti = int(x % MOD);\n\t\tif (i < 0) i += MOD;\n\t}\n\tmint operator+(const mint x) const {return i + x.i;}\n\tmint operator-(const mint x) const {return i - x.i;}\n\tmint operator*(const mint x) const {return (long long)i * x.i;}\n\tmint operator/(const mint x) const {return (long long)i * x.pow(MOD - 2).i;}\n\tmint inv() {return pow(MOD - 2);}\n\ttemplate<class T> mint pow(T p) const {\n\t\tlong long r = 1;\n\t\tlong long t = i;\n\t\tfor(; p > 0; p >>= 1) {\n\t\t\tif (p & 1) r = r * t % MOD;\n\t\t\tt = t * t % MOD;\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate<class T1, class T2> static mint pow(T1 a, T2 b) {\n\t\tlong long r = 1;\n\t\tlong long t = (long long)(a % MOD);\n\t\tfor(; b > 0; b >>= 1) {\n\t\t\tif (b & 1) r = r * t % MOD;\n\t\t\tt = t * t % MOD;\n\t\t}\n\t\treturn r;\n\t}\n\tmint& operator+=(const mint x) {\n\t\ti = (i + x.i) % MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint x) {\n\t\ti = i - x.i;\n\t\tif (i < 0) i += MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint x) {\n\t\ti = (int)((long long)i * x.i % MOD);\n\t\treturn *this;\n\t}\n\tmint& operator/=(const mint x) {\n\t\ti = (long long)i * x.pow(MOD - 2).i % MOD;\n\t\treturn *this;\n\t}\n};\n\nstd::ostream& operator<<(std::ostream& os, const mint& m) {\n\treturn os << m.i;\n}\n\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n} comb(7000);\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    mint ans(0);\n    {\n        vector<mint> dp(2*n+1);\n        dp[0] = 1;\n        rep(_, n) {\n            for(int i = 2*n-2; i >= 0; i--) {\n                dp[i+2] += dp[i];\n                dp[i+1] += dp[i];\n            }\n        }\n        for(int i = 0; i < x - 1; i++) ans += dp[i];\n    }\n    {\n        vector<mint> dp(2*n+1);\n        dp[0] = 1;\n        for(int k = 1; k <= n; k++) {\n            for(int i = 2*n-2; i >= 0; i--) {\n                dp[i+2] += dp[i];\n                dp[i+1] += dp[i];\n                dp[i] = 0;\n            }\n            for(int t = x - 1; t >= 0; t -= 2) {\n                int c = (x - 1 - t) / 2;\n                int call = c * 2 + k;\n                ans += dp[t] * comb(n, call);\n            }\n        }\n    }\n    if (x & 1) {\n        for(int c = x - 1; c <= n; c++) {\n            ans += comb(n, c);\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nclock_t t=clock();\nnamespace my_std{\n\tusing namespace std;\n\t#define pii pair<int,int>\n\t#define fir first\n\t#define sec second\n\t#define MP make_pair\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define go(x) for (int i=head[x];i;i=edge[i].nxt)\n\t#define templ template<typename T>\n\t#define sz 3333\n\t#define mod 998244353ll\n\ttypedef long long ll;\n\ttypedef double db;\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ttempl inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n\tchar __sr[1<<21],__z[20];int __C=-1,__zz=0;\n\tinline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n\tinline void print(register int x)\n\t{\n\t\tif(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;\n\t\twhile(__z[++__zz]=x%10+48,x/=10);\n\t\twhile(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\\n';\n\t}\n\tvoid file()\n\t{\n\t\t#ifdef NTFOrz\n\t\tfreopen(\"a.in\",\"r\",stdin);\n\t\t#endif\n\t}\n\tinline void chktime()\n\t{\n\t\t#ifdef NTFOrz\n\t\tcout<<(clock()-t)/1000.0<<'\\n';\n\t\t#endif\n\t}\n\t#ifdef mod\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n\tll inv(ll x){return ksm(x,mod-2);}\n\t#else\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n\t#endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nint n,X;\nll C[sz][sz];\nll f[sz][sz<<1];\n\nint main()\n{\n\tfile();\n\tread(n,X);\n\tf[0][0]=1;\n\trep(i,0,sz-5) rep(j,0,sz*2-5) (f[i+1][j]+=f[i][j])%=mod,(f[i+1][j+1]+=f[i][j])%=mod,(f[i+1][j+2]+=f[i][j])%=mod;\n\trep(i,0,sz-1) C[i][0]=1;\n\trep(i,1,sz-1) rep(j,1,i) (C[i][j]=C[i-1][j]+C[i-1][j-1])%=mod;\n\tll ans=0;\n\trep(i,0,X-1) (ans+=f[n][i])%=mod;\n\trep(j,0,n-1) for (int k=1;X-2*k-1>=0&&k*2<=n-j;k++) (ans+=C[n-j-1][k*2-1]*f[j][X-2*k-1]%mod)%=mod;\n\tif (X&1) rep(i,X/2+X/2+1,n) (ans+=C[n][i])%=mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 3555;\nconst int K = 700 ;\nint c[N][N], dp[N][N], a[N];\nint n, x, b[N], res;\nvoid gen(int m){\n    if (m == n + 1){\n        int q = 1;\n        for (int i = 1; q &&  i <= n; i++){\n            int s = 0;\n            for (int j = i;q &&  j <= n; j++){\n                s += b[j];\n                if (s == x) q = 0;\n            }\n        }\n        if (q == 1){\n            for (int i = 1; i <= n; i++) if (b[i] != 0) cout << b[i] << \" \";\n            cout << endl;\n        }\n        res += q;\n        return;\n    }\n    b[m] = 0;\n    gen(m + 1);\n    b[m] = 1;\n    gen(m + 1);\n    b[m] = 2;\n    gen(m + 1);\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> x;\n   // gen(1);\n    c[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        c[i][0] = 1;\n        for (int j = 1; j <= i; j++){\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n        }\n    }\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n + n; j++){\n            dp[i][j] = dp[i - 1][j - 1];\n            if (j > 1) dp[i][j] = (dp[i][j] + dp[i - 1][j - 2]) % mod;\n        }\n    }\n    for (int i = 0; i <= n; i++){\n        for (int j = 0; j < x; j++) a[i] = (a[i] + dp[i][j]) % mod;\n        for (int j = 1; j <= i; j++){\n            int l = j + 1;\n            int r = i - j;\n            if (r < l) continue;\n            if (x - 1 - 2 * j >= 0 && (r - l + 1) * 2 != (x - 1 - 2 * j)) a[i] = (a[i] + dp[r - l + 1][x - 1 - 2 * j]) % mod;\n        }\n        if (i != 0 && 2 * i > x && x % 2 == 1) a[i] = (a[i] + 1) % mod;\n    }\n    int ans = 0;\n    for (int i = 0; i <= n; i++){;\n        ans = (ans + c[n][i] * a[i]) % mod;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 6010, mod = 998244353;\nint fac[N+10],ifac[N+10];\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tFor(i,1,n) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n]=power(fac[n],mod-2);\n\tDow(i,n-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,f[N][N],g[N][N],cnt[N],s[N];\n\nint main(){\n\tn=read(),m=read(),init(N);\n\tf[0][0]=1;\n\tFor(i,0,m) g[i][0]=1;\n\tFor(i,1,m)\n\t\tFor(j,1,n) f[i][j]=Mod(f[i-1][j-1]+f[i-2][j-1]),g[i][j]=Mod(g[i-1][j]+f[i][j]);\n\tint ans=0;\n\tfor (int i=0,k=2;i<=m-2;i+=2,k++){//强制选 i 和 i+1\n\t\tFor(j,0,m-1-(i+1)) cnt[k+j]=Mod(cnt[k+j]+g[m-1-(i+1)][j]);\n\t\tFor(j,0,m-1-(i+1)) if (f[m-1-(i+1)][j]){\n\t\t\tint l=k+j;\n\t\t\t//For(p,1,k-2) cnt[l+p]=Mod(cnt[l+p]+f[m-1-(i+1)][j]);\n\t\t\ts[l+1]=Mod(s[l+1]+f[m-1-(i+1)][j]);\n\t\t\ts[l+(k-1)]=Mod(s[l+(k-1)]+mod-f[m-1-(i+1)][j]);\n\t\t}\n\t}\n\tFor(i,1,n+1) s[i]=Mod(s[i]+s[i-1]),cnt[i]=Mod(cnt[i]+s[i]);\n\tif (m&1){\n\t\tFor(k,1,n+1) cnt[k]=Mod(cnt[k]+1);\n\t} else {\n\t\tFor(i,1,m/2) cnt[i]=Mod(cnt[i]+1);\n\t}\n\tFor(i,1,n+1) if (cnt[i]) ans=(ans+1ll*cnt[i]*C(n,i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\n\nlong long dp[3010][6010] = {};\nlong long powing(long long a, long long b) {\n\tlong long ans = 1;\n\twhile (b != 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nlong long inv(long long now) {\n\treturn powing(now, MOD - 2);\n}\nlong long omote[20000];\nlong long gyaku[20000];\nlong long combination(long long a, long long b) {\n\tlong long ans = omote[a];\n\tans *= gyaku[b];\n\tans %= MOD;\n\tans *= gyaku[a - b];\n\tans %= MOD;\n\treturn ans;\n}\nlong long hype(long long a, long long b) {\n\treturn combination(a + b - 1, b);\n}\nint main(){\n\tsolve();\n\tint n, x;\n\tcin >> n >> x;\n\tomote[0] = 1;\n\tgyaku[0] = 1;\n\tfor (long long i = 1; i < 20000; ++i) {\n\t\tomote[i] = omote[i - 1] * i;\n\t\tomote[i] %= MOD;\n\t\tgyaku[i] = inv(omote[i]);\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int q = 0; q < x; ++q) {\n\t\t\tif (dp[i][q] == 0) continue;\n\t\t\tdp[i + 1][q + 1] += dp[i][q];\n\t\t\tdp[i + 1][q + 2] += dp[i][q];\n\t\t\tdp[i + 1][q + 1] %= MOD;\n\t\t\tdp[i + 1][q + 2] %= MOD;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int q = 0; q < x; ++q) {\n\t\t\tif (dp[i][q] == 0) continue;\n\t\t\tans += dp[i][q] * hype(i+1, n - i);\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tif (x % 2 == 1) {\n\t\tfor (int i = (x + 1) / 2; i <= n; ++i) {\n\t\t\tans += hype(i + 1, n - i);\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tfor (int i = 1;i * 2 <= n; ++i) {\n\t\tfor (int two = 0;; ++two) {\n\t\t\tlong long remaining = x - 1 - 2 * two;\n\t\t\tif (remaining < 0) break;\n\t\t\tlong long cnt = i * 2 + two + remaining;\n\t\t\tif (cnt > n) continue;\n \t\t\tlong long tmp_ans = hype(cnt + 1, n - cnt);\n\t\t\tlong long bobo = 0;\n\t\t\tif (remaining >= 1&&two >= 1) {\n\t\t\t\tbobo += 2LL * combination(remaining - 1 + two - 1, two - 1);\n\t\t\t}\n\t\t\tif (remaining >= 2) {\n\t\t\t\tbobo += combination(remaining - 2 + two, two);\n\t\t\t}\n\t\t\ttmp_ans *= bobo;\n\t\t\ttmp_ans %= MOD;\n\t\t\tans += tmp_ans;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 3002;\nconst int MOD = 998244353;\n\nint n, x;\nint pw2[MAX_N], C[MAX_N][MAX_N], f[MAX_N][MAX_N*2], g[MAX_N][MAX_N];\n\nvoid read_input() {\n    cin >> n >> x;\n}\n\n//void NTT(vector<int> &a, bool invert) {\n//    for (int i=0; i<n; ++i) {\n//        if (rev_bit[i] > i)\n//            swap(a[i], a[rev_bit[i]]);\n//    }\n//\n//    int n = a.size();\n//\n//    for (int len=2; len<=n; len <<= 1) {\n//        int wlen = invert ? ROOT : ROOT_1;\n//        for (int i=len; i<=ROOT_PW; i <<= 1)\n//            wlen = 1LL * wlen * wlen % MOD;\n//\n//        for (int i=0; i<n; i += len) {\n//            int w = 1;\n//            for (int j=0; j<len/2; ++j) {\n//                int u = a[i+j], v = 1LL * a[i+j+len/2] * w % MOD;\n//                a[i+j] = (u+v<MOD ? u + v : u + v - MOD);\n//                a[i+j+len/2] = (u-v>=0 ? u - v : u - v + MOD);\n//                w = 1LL * w * wlen % MOD;\n//            }\n//        }\n//    }\n//\n//    if (invert) {\n//        for (int i=0; i<n; ++i)\n//            a[i] = 1LL * a[i] * inv[n] % MOD;\n//    }\n//}\n\nvoid square(vector<int> &a) {\n//    vector<int> fa(a.begin(), a.end());\n//\n//    int n = 1;\n//\n//    while (n<a.size())\n//        n <<= 1;\n//\n//    fa.resize(n);\n//    NTT(a, false);\n//\n//    for (int i=0; i<n; ++i)\n//        fa[i] = 1LL * fa[i] * fa[i] % MOD;\n//    NTT(fa, true);\n\n    vector<int> res(a.size());\n\n    for (int i=0; i<a.size(); ++i) {\n        for (int j=0; i+j<a.size(); ++j) {\n            res[i+j] = (res[i+j] + 1LL * a[i] * a[j]) % MOD;\n        }\n    }\n\n    a = res;\n}\n\nvoid init() {\n//    for (int i=0; i<=n*2; ++i)\n//        inv[i] = pw(i, MOD-2);\n\n    for (int i=0; i<=n; ++i)\n        C[i][0] = C[i][i] = 1;\n\n    for (int i=1; i<=n; ++i) {\n        for (int j=1; j<i; ++j)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;\n    }\n\n    pw2[0] = 1;\n    for (int i=1; i<=n; ++i)\n        pw2[i] = pw2[i-1] * 2 % MOD;\n\n    f[0][0] = 1;\n\n    for (int l=1; l<=n; ++l) {\n        for (int s=0; s<=x; ++s) {\n            f[l][s] = f[l-1][s];\n            if (s>=1)\n                f[l][s] = (f[l][s] + f[l-1][s-1]) % MOD;\n            if (s>=2)\n                f[l][s] = (f[l][s] + f[l-1][s-2]) % MOD;\n        }\n    }\n    // debug(f[n][2]);\n}\n\nint case1() {\n    vector<int> h;\n\n    for (int t=0; t<=x/2; ++t) {\n        h.assign(n+1, 0);\n\n        for (int l=0; l<=n; ++l) {\n            if (l<=t)\n                h[l] = pw2[l];\n            else\n                h[l] = (1LL * h[l-1] * 2 - C[l-1][t] + MOD) % MOD;\n        }\n\n        square(h);\n        // if (t==1)\n        //     PR0(h, n+1);\n\n        for (int l=0; l<=n; ++l)\n            g[l][t] = h[l];\n    }\n    // debug(g[2][1]);\n\n    int res = 0;\n\n    for (int l=0; n-l-2>=0; ++l) {\n        for (int s=(x+1)%2; s+2<=x; s += 2) {\n            // cerr << l << ' ' << s << ' ' << f[l][s] * g[n-l-2][(x-2-s)/2] << '\\n';\n            res = (res + 1LL * f[l][s] * g[n-l-2][(x-2-s)/2]) % MOD;\n        }\n    }\n\n    if (x%2==0)\n        res = (res + g[n-1][(x-1)/2]) % MOD;\n    else\n        res = (res + pw2[n]) % MOD;\n\n    return res;\n}\n\nint case2() {\n    int res = 0;\n\n    for (int s=x%2; s<x; s += 2)\n        res = (res + f[n][s]) % MOD;\n\n    return res;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tread_input();\n\tinit();\n\t// debug(case1());\n    // debug(case2());\n\tcout << (case1() + case2()) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int mod = 998244353;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nconst int maxN = 3005;\nint c[maxN][maxN];\nint x, n;\nint f[maxN];\nint dp[maxN][2 * maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> x;\n    c[0][0] = 1;\n    for (int i = 1; i < maxN; i++) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; j++) {\n            c[i][j] = sum(c[i - 1][j], c[i - 1][j - 1]);\n        }\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i + 1 <= n; i++) {\n        for (int j = 0; j <= 2 * i + 2; j++) {\n            dp[i + 1][j + 1] = sum(dp[i + 1][j + 1], dp[i][j]);\n            dp[i + 1][j + 2] = sum(dp[i + 1][j + 2], dp[i][j]);\n        }\n    }\n    for (int t = x + 1; t <= 2 * n; t++) {\n        int k1 = (t - x + 1) / 2;\n        if (t % 2 == x % 2) continue;\n        if (x % 2 == 0 && 2 * k1 >= x) continue;\n        if (2 * k1 + 2 * k1 >= t) {\n            if (x % 2 == 0) continue;\n            if (t % 2 != 0) continue;\n            f[t / 2] += 1;\n            if (f[t / 2] >= mod) f[t / 2] -= mod;\n            continue;\n        }\n        int le = t - 4 * k1;\n        for (int j = 0; j <= le; j++) {\n            f[j + 2 * k1] = f[j + 2 * k1] + dp[j][le];\n            if (f[j + 2 * k1] >= mod) f[j + 2 * k1] -= mod;\n        }\n    }\n    /*if (x % 2 == 1) {\n        for (int i = (x / 2 + 1); i <= n; i++) {\n            f[i]++;\n        }\n    }\n    else {\n        for (int sum = x + 1; sum <= 2 * x - 1; sum += 2) {\n            f[sum / 2 + 1]++;\n        }\n    }*/\n    int ans = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j < x; j++) {\n            f[i] = sum(f[i], dp[i][j]);\n        }\n        ans = sum(ans, mult(f[i], c[n][i]));\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const long long MOD = 998244353;\nconst int N = 500044;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n, x;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n >> x;\n    vector<ll> calc(n + 1);\n    calc[0] = 1;\n    for (int len = 1; len <= n; len++)\n    {\n        for (int summ = len; summ <= 2 * len; summ++)\n        {\n            if (summ < x)\n            {\n                calc[len] = (calc[len] + cnk(len, summ - len)) % MOD;\n            }\n            else\n            {\n                if (summ <= x || (summ - x + 1) % 2 == 1)\n                {\n                    continue;\n                }\n                int L = (summ - x + 1) / 2;\n                int R = len - L;\n                int summa = summ - 4 * L;\n                if (summa + 2 * L != x - 1) cout << \"My bad\\n\", exit(0);\n                int dlina = len - 2 * L;\n                //cout << len << \" \" << summ << \" \" << L << \" \" << dlina << endl;\n                if (summa != 2 * dlina) calc[len] = (calc[len] + cnk(dlina, summa - dlina)) % MOD;\n            }\n        }\n        if (2 * len >= x && x % 2 == 1) calc[len] = (calc[len] + 1) % MOD;\n        //cout << len << \" \" << calc[len] << endl << endl;\n    }\n    ll ans = 0;\n    for (int i = 0; i <= n; i++)\n    {\n        ans = (ans + calc[i] * cnk(n, i)) % MOD;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<1>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\nvec fact,inv;\nvoid init(int n){\n  fact.assign(n+1,1);\n  inv.assign(n+1,1);\n  REP(i,n) fact[i+1] = fact[i]*(i+1), inv[i+1] /= fact[i+1];\n}\n\nmint cmb(int n, int r){\n  if(n < r) return 0;\n  return fact[n]*inv[r]*inv[n-r];\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,k;\n  cin >> n >> k;\n\n  init(10000);\n\n  mint ans = 0;\n  mat s(k+1,vec(k+1,0));\n  vec t(k+1,0);\n  REP(i,k+1) REP(j,k+1) if(j>=i-j) s[i][j] = cmb(j,i-j);\n  REP(i,k) REP(j,k+1) s[i+1][j] += s[i][j];\n  REP(i,k+1){\n    t[i] = cmb(n,i);\n    if(i) t[i] += t[i-1];\n  }\n\n  REP(i,n+1){\n    if(k%2==0 && i*2 >= k) break;\n    ans += cmb(n,i);\n  }\n\n  REP(i,n){\n    if(i*2+1 >= k) break;\n    int l = k-(i*2+1)-1;\n    REP(j,l){\n      if(i+1+j > n) break;\n      ans += s[l-1][j]*cmb(n,i+1+j);\n    }\n    REP(j,l+1){\n      ans += (t[j+i*2+1]-t[j+i])*cmb(j,l-j); \n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef UTIL_INCLUDED\n#define UTIL_INCLUDED\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n// #define DEBUGGING\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\n\nnamespace __init {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(0);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifndef DEBUG_FILE\n#ifdef DEBUGGING\n#include \"../debug.cpp\"\n#else\n#define DEBUG(...) 0\n#endif\n#endif\n\n#endif\n\nconst ll MOD = 998244353;\n\nclass Combination {\nprivate:\n    template <typename T> using V = vector<ll>;\n    ll N;\n    ll MOD;\n    V<ll> factv, rfactv;\n\npublic:\n    /*\n     * MOD must be a prime number.\n     */\n    Combination(ll N, ll MOD)\n        : N(N), \n          MOD(MOD),\n          factv(N + 1, 1),\n          rfactv(N + 1)\n    {\n        for(ll i = 1; i <= N; i++) {\n            factv[i] = factv[i - 1] * i % MOD;\n        }\n        for(ll i = 0; i <= N; i++) {\n            rfactv[i] = pow(factv[i], MOD - 2);\n        }\n    }\n\n    ll fact(ll n) {\n        return factv[n];\n    }\n\n    ll rfact(ll n) {\n        return rfactv[n];\n    }\n\n    ll pow(ll a, ll b) {\n        return b ? (b & 1 ? a : 1) * pow(a * a % MOD, b / 2) % MOD : 1;\n    }\n\n    ll comb(ll n, ll k) {\n        return factv[n] * rfactv[n - k] % MOD * rfactv[k] % MOD;\n    }\n};\n\nint main() {\n    ll N, X;\n    cin >> N >> X;\n\n    Combination comb(1e5, MOD);\n    ll ans = 0;\n    for(ll one = 0; one <= N; one++) {\n        for(ll two = 0; one + two <= N; two++) {\n            ll cells = one + two;\n            ll sum = one + 2 * two;\n            if(sum == X) continue;\n            if(sum < X) {\n                ll tmp = comb.comb(N, cells) * comb.comb(cells, two) % MOD;\n                (ans += tmp) %= MOD;\n            }\n            if(sum > X) {\n                ll rest = sum - X;\n                if(rest % 2 == 0) continue;\n                ll tmp;\n                if(one == 0) {\n                    tmp = comb.comb(N, cells) % MOD;\n                } else { \n                    ll cnt = rest / 2 + 1;\n                    if(cnt * 2 > two) continue;\n                    tmp = comb.comb(N, cells) * comb.comb(cells - 2 * cnt, two - 2 * cnt) % MOD;\n                }\n                (ans += tmp) %= MOD;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\n#include<random>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n#include <cstdint>\nstruct mint {\n\tusing i64 = std::int_fast64_t;\n\tconst static i64 mod = 1000000007;\n\ti64 n;\npublic:\n\tmint(const i64 n = 0) : n((n % mod + mod) % mod) {}\n\tmint pow(int m) const {\n\t\ti64 a = n, r = 1;\n\t\twhile(m > 0) {\n\t\t\tif(m & 1) { r *= a; r %= mod; }\n\t\t\ta = (a * a) % mod; m /= 2;\n\t\t}\n\t\treturn mint(r);\n\t}\n\tmint &operator++() { *this += 1; return *this; }\n\tmint &operator--() { *this -= 1; return *this; }\n\tmint operator++(int) { mint ret = *this; *this += 1; return ret; }\n\tmint operator--(int) { mint ret = *this; *this -= 1; return ret; }\n\tmint operator~() const { return (this -> pow(mod - 2)); } // inverse\n\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n == rhs.n;\n\t}\n\tfriend mint &operator+=(mint& lhs, const mint& rhs) {\n\t\tlhs.n += rhs.n;\n\t\tif (lhs.n >= mod) lhs.n -= mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator-=(mint& lhs, const mint& rhs) {\n\t\tlhs.n -= rhs.n;\n\t\tif (lhs.n < 0) lhs.n += mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator*=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * rhs.n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator/=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * (~rhs).n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n + rhs.n);\n\t}\n\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n - rhs.n);\n\t}\n\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * rhs.n);\n\t}\n\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * (~rhs).n);\n\t}\n};\nistream& operator>>(istream& is, mint& m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, mint& m) { os << m.n; return os; }\n\n#define MAX_N 1000000\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n\tlong long d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nlong long mod_inverse(long long a, long long m) {\n\tlong long x, y;\n\tif(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n\telse return -1;\n}\nvector<long long> fact(MAX_N+1, INF);\nlong long mod_fact(long long n, long long& e) {\n\tif(fact[0] == INF) {\n\t\tfact[0]=1;\n\t\tif(MAX_N != 0) fact[1]=1;\n\t\tfor(lint i = 2; i <= MAX_N; ++i) {\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t}\n\t}\n\te = 0;\n\tif(n == 0) return 1;\n\tlong long res = mod_fact(n / MOD, e);\n\te += n / MOD;\n\tif((n / MOD) % 2 != 0) return (res * (MOD - fact[n % MOD])) % MOD;\n\treturn (res * fact[n % MOD]) % MOD;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n\tif(n < 0 || k < 0 || n < k) return 0;\n\tlong long e1, e2, e3;\n\tlong long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n\tif(e1 > e2 + e3) return 0;\n\treturn (a1 * mod_inverse((a2 * a3) % MOD, MOD)) % MOD;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, x;\n\tcin >> n >> x;\n\tif(x == 2) {\n\t\tcout << 1 + n << endl;\n\t\treturn 0;\n\t}\n\tmint ans = 1;\n\tFOR(m, 1, n + 1) {\n\t\tif(x == 1) {\n\t\t\tans += mod_comb(n, m);\n\t\t\tcontinue;\n\t\t}\n\t\tmint tmp = 0;\n\t\tREP(i, m + 1) {\n\t\t\tif(i * 2 + (m - i) * 1 >= x) break;\n\t\t\ttmp += mod_comb(m, i);\n\t\t}\n\t\tFOR(i, 1, m) {\n\t\t\tif(i < m - i) {\n\t\t\t\tif(2 * i == x - 1) tmp++;\n\t\t\t} else {\n\t\t\t\ttmp += mod_comb(m - 2 * (m - i), x - 1 - 2 * (m - i) - (i - (m - i)));\n\t\t\t}\n\t\t}\n\t\tans += tmp * mod_comb(n, m);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, X, f[N][N << 1], fac[N << 1], inv[N << 1];\n\ninline int C(int x, int y) {\n    return x < y ? 0 : 1LL * fac[x] * inv[y] % Mod * inv[x - y] % Mod;\n}\n\nint main() {\n    cin >> n >> X;\n\n    inv[0] = inv[1] = fac[0] = fac[1] = 1;\n    for (int i = 2; i <= n; ++i)\n        fac[i] = 1LL * fac[i - 1] * i % Mod,\n        inv[i] = 1LL * inv[Mod % i] * (Mod - Mod / i) % Mod;\n\n    for (int i = 1; i <= n; ++i)\n        inv[i] = 1LL * inv[i - 1] * inv[i] % Mod;\n\n    f[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < X * 2; ++j)\n            (f[i + 1][j + 1] += f[i][j]) %= Mod,\n            (f[i + 1][j + 2] += f[i][j]) %= Mod;\n\n    long long ans = 1;\n    for (int i = 1; i <= n; ++i) {\n        long long tmp = 0;\n        for (int j = 0; j < X; ++j)\n            (tmp += f[i][j]) %= Mod;\n        for (int j = X + 1; j <= 2 * i; j += 2) {\n            if (j < i) continue;\n            int p = i - (j - X + 1), q = X - 1 - (j - X + 1);\n            //if (j < 2 * X && p >= 0 && q >= 0) (tmp += f[p][q]) %= Mod;\n            if (j >= X * 2) (tmp += (j == (i << 1) ? (X & 1) : 0)) %= Mod;\n            else (tmp += (p >= 0 && q >= 0 ? f[p][q] : 0)) %= Mod;\n        }\n//        if (i >= X && (X & 1))\n//            ++tmp;\n        (ans += 1LL * tmp * C(n, i) % Mod) %= Mod;\n    }\n    cout << ans % Mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int mod = 998244353;\nconst int N = 100000;\nint n, x;\nlong long a[N + 1], ni[N + 1];\nlong long f[N + 1];\nlong long calc(long long x, long long y)\n{\n    if (y < 0) return 0;\n    long long z = 1;\n    while (y)\n    {\n        if (y & 1) (z *= x) %= mod;\n        (x *= x) %= mod, y /=2;\n    }\n    return z;\n}\nlong long C(int x, int y)\n{\n    if (y < 0 || x < y) return 0;\n    return a[x] * ni[y] % mod * ni[x - y] % mod;\n}\nint main()\n{\n    scanf(\"%d %d\", &n, &x);\n    a[0] = 1;\n    for (int i = 1; i <= N ; i ++)\n        a[i] =  a[i - 1] * i % mod;\n    ni[N] = calc(a[N], mod - 2);\n    for (int i = N - 1 ; i >= 0; i --)\n        ni[i] = ni[i + 1] * (i + 1) % mod;\n    f[0] = 1;\n    for (int i = 1; i <= n; i ++)\n    {\n        for (int j = 0; j <= i; j ++)\n            if (i + j < x)\n                f[i] += C(i, j);\n        if (i + i > x && (x & 1))\n            f[i] ++;\n        if (i + i > x)\n        {\n            for (int j = 1; j <= i / 2 ; j++)\n                if (j * 2 < x - 1)\n                {\n                    int sum = i - j * 2;\n                    if (x - 1 - j * 2 - sum != sum)\n                        f[i] += C(sum, x  - 1 - j * 2 - sum);\n                }\n        }\n        f[i] %= mod;\n    }\n    long long ans = 0;\n    for (int i = 0; i <= n ; i++) {\n        (ans += f[i] * C(n, i)) %= mod;\n    }\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef long long i64;\nconst int inf = (int)1.05e9;\n\nconst i64 mod = 998244353;\n\ni64 mof(i64 x)\n{\n\tif(x < mod * 2) {\n\t\treturn (x >= mod) ? x - mod : x;\n\t}\n\treturn x % mod;\n}\n\nint main()\n{\n\tint n, x;\n\n\tscanf(\"%d%d\", &n, &x);\n\n\tvector<vector<i64>> waf(n + 1);\n\tfor(auto& w : waf) {\n\t\tw.resize(2 * n + 1, 0);\n\t}\n\n\twaf[0][0] = 1;\n\n\tfor(int i = 1; i <= n; i++) {\n\n\t\twaf[i][1] = waf[i - 1][0];\n\n\t\tfor(int j = 2; j <= 2 * n; j++) {\n\t\t\twaf[i][j] = mof(waf[i - 1][j - 1] + waf[i - 1][j - 2]);\n\t\t}\n\t}\n\n\tvector<vector<i64>> choose(n + 1);\n\tfor(auto& c : choose) {\n\t\tc.resize(n + 1, 0);\n\t}\n\n\tfor(int i = 0; i <= n; i++) {\n\t\tchoose[i][0] = 1;\n\t}\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif(i < j) {\n\t\t\t\tchoose[i][j] = 0;\n\t\t\t} else {\n\t\t\t\tchoose[i][j] = mof(choose[i - 1][j] + choose[i - 1][j - 1]);\n\t\t\t}\n\t\t\t// printf(\"%d C %d = %lld\\n\", i, j, choose[i][j]);\n\t\t}\n\t}\n\n\ti64 ans = 1;\n\n\tfor(int i = 0; i < x; i++) {\n\t\ti64 s = 0;\n\t\tfor(int m = 1; m <= n; m++) {\n\t\t\ts = mof(s + waf[m][i] * choose[n][m]);\n\t\t}\n\t\tans = mof(ans + s);\n\t\t// printf(\"waf %d -> %lld\\n\", i, s);\n\t}\n\n\tfor(int len = x + 1; len <= 2 * n; len++) {\n\n\t\tif((len - x) % 2 == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint k = len - x;\n\n\t\tif(x - 1 <= k + 1) {\n\n\t\t\tif(len % 2 == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = mof(ans + choose[n][len / 2]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tint rem = (x - 1) - (k + 1);\n\t\tint right = (k + 1) / 2;\n\n\t\ti64 s = 0;\n\t\tfor(int m = 1; m + 2 * right <= n; m++) {\n\t\t\ts = mof(s + waf[m][rem] * choose[n][n - m - (right * 2)]);\n\t\t}\n\t\tans = mof(ans + s);\n\n\t\t//printf(\"%d -> %lld\\n\", len, s);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n\n/* waffle */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,x;\nll comb[3005][3005];\n\n\nint main(void){\n    comb[0][0]=1;\n    for(int i=1;i<=3000;i++){\n        for(int j=1;j<i;j++){\n            comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n        }\n        comb[i][0]=1;\n        comb[i][i]=1;\n    }\n\n    scanf(\"%d%d\",&n,&x);\n    ll ans=0;\n    // 1 no kosuu\n    for(int i=0;i<=n;i++){\n        for(int j=0;(j+i)<=n;j++){\n            //printf(\"%d %d %lld\\n\",i,j,ans);\n            if(i+j*2<x){\n                ll val=comb[i+j][i];\n                val=comb[n][i+j]*val%MOD;\n                ans+=val;\n                ans%=MOD;\n            }else{\n                int diff=i+j*2-x;\n                if(diff%2==0LL)continue;\n                int u2=(i+j*2-(x-1))/2;\n                if(u2*2>j && i!=0)continue;\n                ll val;\n                if(i==0){\n                    val=1;\n                }else{\n                    val=comb[i+j-u2*2][i];\n                }\n                val=comb[n][i+j]*val%MOD;\n                ans+=val;\n                ans%=MOD;\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long LL;\nconst int _=1e2;\nconst int maxn=3e3+_;\nconst LL mod=998244353;\ninline LL ad(LL x,LL y){return (x>=mod-y)?x-mod+y:x+y;}\ninline LL re(LL x,LL y){return (x<y)?x-y+mod:x-y;}\nint n,x;\nLL C[maxn][maxn],f[maxn][maxn];//只放1、2长度为i和为j的序列方案数 \nvoid yu()\n{\n\tC[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=ad(C[i-1][j-1],C[i-1][j]);\n\t}\n\tf[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<x;j++)\n\t\t\tif(f[i][j])\n\t\t\t{\n\t\t\t\tf[i+1][j+1]=ad(f[i+1][j+1],f[i][j]);\n\t\t\t\tf[i+1][j+2]=ad(f[i+1][j+2],f[i][j]);\n\t\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&x); yu();\n\tLL ans=1;\n\tfor(int L=1;L<=n;L++)\n\t{\n\t\tLL sum=0;\n\t\tfor(int S=1;S<=2*L;S++)\n\t\t{\n\t\t\tif(S<x)sum=ad(sum,f[L][S]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif((x%2==0)^(S%2==0))\n\t\t\t\t{\n\t\t\t\t\tif(L*2==S)sum=ad(sum,1);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint lp=(S-x+2)/2+1,rp=(x+2*L-S)/2;//最左/右的1的位置 \n\t\t\t\t\t\tif(1<=lp&&lp<=L&&1<=rp&&rp<=L&&lp<=rp)\n\t\t\t\t\t\t\tsum=ad(sum,f[rp-lp+1][S-2*(L-(rp-lp+1))]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=ad(ans,C[n][L]*sum%mod);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 998244353;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 6e3 + 5;\n\nmi fact[MAX];\nmi ifact[MAX];\nmi len[MAX];\nmi dp[MAX][MAX]; // length, sum\nmi ones[MAX][MAX]; // length, sum\nmi twos[MAX][MAX];// mx 2's, num used\nmi twos_total[MAX][MAX]; //mx 2's used at most in total, num used\nmi rest[MAX][MAX];// mx 2's, num total\nmi rest_total[MAX][MAX];\nmi po[MAX];\nmi prefix[MAX];\nmi up_prefix[MAX];\nmi choose(int a, int b){\n    if(b < 0) return 0;\n    if(a < b) return 0;\n    return fact[a] * ifact[b] * ifact[a - b];\n}\nmi sum_prefix(int l, int r){\n    return prefix[r] - (l == 0 ? 0 : prefix[l - 1]);\n}\nmi sum_up_prefix(int l, int r){\n    return up_prefix[r] - (l == 0 ? 0 : up_prefix[l - 1]);\n}\nmi progression(int l, int r, int st, int d){\n    return (sum_up_prefix(l, r) - sum_prefix(l, r) * l) * d + sum_prefix(l, r) * st;\n}\nint n, x;\nint main(){\n    fact[0] = 1; ifact[0] = 1; po[0] = 1;\n    for(int i = 1; i < MAX; i++) fact[i] = fact[i - 1] * i, ifact[i] = ifact[i - 1] / i, po[i] = po[i - 1] * 2;\n    ios_base :: sync_with_stdio(0); cin.tie(0);\n    cin >> n >> x;\n    prefix[0] = 1;\n    for(int i = 1; i <= n; i++) prefix[i] = prefix[i - 1] + choose(n, i), up_prefix[i] = up_prefix[i - 1] + choose(n, i) * i;\n    mi ans = 0;\n    if(x % 2 == 0) for(int i = 0; i < x / 2; i++) ans += choose(n, i);\n    else ans += po[n];\n    dp[0][0] = 1;\n    for(int i = 0; i <= n; i++) for(int j = 0; j < x; j++) dp[i + 1][j + 2] += dp[i][j], dp[i + 1][j + 1] += dp[i][j];\n    for(int i = 0; i <= n; i++) for(int j = 0; j < x; j++) ones[i + 2][j + 2] = dp[i][j];\n    ones[1][1] += 1;\n    for(int i = 0; i <= n; i++) for(int j = 0; j + i <= n; j++) twos[max(i, j)][i + j] += 1;\n    for(int j = 0; j <= n; j++) for(int i = 1; i <= max(n, x); i++) twos[i][j] += twos[i - 1][j];\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < n; j++){\n            if(j <= i){\n                rest[i][j] = progression(0, j, j + 1, -1);\n            }\n            else{\n                rest[i][j] = progression(j - i, j, i + 1, -1) + progression(max(0, j - 2 * i), j - (i + 1), max(1, 2 * i + 1 - j), 1);\n            }\n        }\n    }\n    for(int j = 0; j < n; j++){\n        rest_total[0][j]  += choose(n, j);\n        for(int i = 1; i <= n; i++){\n            if(i > j) rest_total[i][j] = rest_total[i - 1][j];\n            else rest_total[i][j] = rest_total[i - 1][j] + choose(n, j - i) * (i + 1);\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            if(ones[i][j] == 0) continue;\n            int mx = min((x - j - 1) / 2, n - 1);\n            if(j % 2 == x % 2){\n                ans += ones[i][j] * rest_total[mx][n - i];\n            }\n            else{\n                ans += ones[i][j] * rest[mx][n - i];\n            }\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 998244353;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 6e3 + 5;\nmi fact[MAX], ifact[MAX], len[MAX], dp[MAX][MAX], ones[MAX][MAX], rest[MAX][MAX], rest_total[MAX][MAX], po[MAX], prefix[MAX], up_prefix[MAX];\nmi choose(int a, int b){\n    if(b < 0 || a < b) return 0;\n    return fact[a] * ifact[b] * ifact[a - b];\n}\nmi sum_prefix(int l, int r){ return prefix[r] - (l == 0 ? 0 : prefix[l - 1]); }\nmi sum_up_prefix(int l, int r){ return up_prefix[r] - (l == 0 ? 0 : up_prefix[l - 1]); }\nmi progression(int l, int r, int st, int d){ return (sum_up_prefix(l, r) - sum_prefix(l, r) * l) * d + sum_prefix(l, r) * st; }\nint n, x;\nint main(){\n    fact[0] = 1; ifact[0] = 1; po[0] = 1;\n    for(int i = 1; i < MAX; i++) fact[i] = fact[i - 1] * i, ifact[i] = ifact[i - 1] / i, po[i] = po[i - 1] * 2;\n    ios_base :: sync_with_stdio(0); cin.tie(0);\n    cin >> n >> x;\n    prefix[0] = 1; mi ans = 0; dp[0][0] = 1; ones[1][1] += 1;\n    for(int i = 1; i <= n; i++) prefix[i] = prefix[i - 1] + choose(n, i), up_prefix[i] = up_prefix[i - 1] + choose(n, i) * i;\n    if(x % 2 == 0) for(int i = 0; i < x / 2; i++) ans += choose(n, i);\n    else ans += po[n];\n    for(int i = 0; i <= n; i++) for(int j = 0; j < x; j++) dp[i + 1][j + 2] += dp[i][j], dp[i + 1][j + 1] += dp[i][j];\n    for(int i = 0; i <= n; i++) for(int j = 0; j < x; j++) ones[i + 2][j + 2] = dp[i][j];\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < n; j++){\n            if(j <= i) rest[i][j] = progression(0, j, j + 1, -1);\n            else rest[i][j] = progression(j - i, j, i + 1, -1) + progression(max(0, j - 2 * i), j - (i + 1), max(1, 2 * i + 1 - j), 1);\n        }\n    }\n    for(int j = 0; j < n; j++){\n        rest_total[0][j]  += choose(n, j);\n        for(int i = 1; i <= n; i++){\n            if(i > j) rest_total[i][j] = rest_total[i - 1][j];\n            else rest_total[i][j] = rest_total[i - 1][j] + choose(n, j - i) * (i + 1);\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            if(ones[i][j] == 0) continue;\n            int mx = min((x - j - 1) / 2, n - 1);\n            if(j % 2 == x % 2) ans += ones[i][j] * rest_total[mx][n - i];\n            else ans += ones[i][j] * rest[mx][n - i];\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 3010\n#define ll long long\n#define mod 998244353\nusing namespace std;\nint f[maxn][maxn * 2], C[maxn][maxn];\nint main()\n{\n\tint n, x;\n\tscanf(\"%d%d\", &n, &x);\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tC[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tC[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n\t}\n\tf[0][0] = 1;\n\tfor (int i = 0; i <= n - 1; i++)\n\t\tfor (int j = 0; j <= x; j++)\n\t\t{\n\t\t\tf[i + 1][j + 1] = (f[i + 1][j + 1] + f[i][j]) % mod;\n\t\t\tf[i + 1][j + 2] = (f[i + 1][j + 2] + f[i][j]) % mod;\n\t\t}\n\tint res = 0;\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tint tmp = 0;\n\t\tfor (int j = 0; j <= x - 1; j++)\n\t\t\ttmp = (tmp + f[i][j]) % mod;\n\t\tfor (int j = x + 1; j <= 2 * i; j += 2)\n\t\t{\n\t\t\tint need = (j - x + 1) / 2;\n\t\t\tif (2 * need <= i && x - 1 - 2 * need >= 0) tmp = (tmp + f[i - 2 * need][x - 1 - 2 * need]) % mod;\n\t\t\tif (2 * need > i && (x - 1) % 2 == 0 && (x - 1) / 2 + need == i) tmp = (tmp + 1) % mod;\n\t\t}\n\t\tres = (res + (ll)tmp * C[n][i] % mod) % mod;\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mod 998244353LL\n\nll c[6010][6010];\nint n,m;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline ll pls(const ll &x,const ll &y) { return (x+y<mod)?x+y:x+y-mod; }\ninline ll mns(const ll &x,const ll &y) { return (x-y<0)?x-y+mod:x-y; }\ninline ll ksm(ll x,ll y) { ll res=1;for (;y;y>>=1,x=x*x%mod) if (y&1) res=res*x%mod;return res; }\n\ninline void pre_gao()\n{\n\tfor (int i=0;i<=6000;i++)\n\t{\n\t\tc[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) c[i][j]=pls(c[i-1][j-1],c[i-1][j]);\n\t}\n}\n\ninline ll calc(const int &x,const int &y) { return (x<0||y<0||x>y||y>x*2)?0:c[x][y-x]; }\n\ninline ll gao(const int &x,const int &y)\n{\n\tif (y<m) return calc(x,y);\n\tif (y>=m*2) return ((m&1)&&y==x*2);\n\tint hh=y-m-1;\n\tif (hh&1) return 0;\n\tint hhh=m+1;\n\tint now=x-(y-hhh)/2-1-hh/2;\n\treturn calc(now-1,hhh-hh-4);\n}\n\nint main()\n{\n\tn=rd();m=rd();pre_gao();\n\tll ans=0;\n\tfor (int i=0;i<=n;i++) for (int j=i;j<=i*2;j++) ans=pls(ans,gao(i,j)*c[n][i]%mod);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int N = 3003; \n\nmint bino[N][N];\nmint dp[N][2*N];\n\nvoid solve() {\n    int n, x;\n    cin >> n >> x;\n    auto make_bino = [&](){\n        for (int i = 0; i < N; i++) {\n            bino[i][0] = 1;\n            bino[i][i] = 1;\n        }\n        for (int i = 1; i < N; i++) {\n            for (int j = 1; j < i; j++) {\n                bino[i][j] = bino[i-1][j-1] + bino[i-1][j];\n            }\n        }\n    };\n    memset(dp, 0, sizeof dp);\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= 2*n ; j++) {\n            dp[i][j] += dp[i-1][j];\n            dp[i][j+1] += dp[i-1][j];\n            dp[i][j+2] += dp[i-1][j];\n        }\n    }\n    mint res = 0;\n    for (int sum = 0; sum < x; sum++) {\n        res += dp[n][sum];\n    }\n    make_bino();\n    for (int sum = x+1; sum <= 2*n; sum+=2) {\n        int k = 1 + (sum-x-1)/2;\n        int r = sum - 4 * k;\n        if (r < 0) {\n            if (x&1) {\n                res += bino[n][sum/2];\n                continue;\n            }else break;\n        }\n        for (int i = (r&1); i <= n-2*k; i+=2) {\n            int j = (r-i)/2;\n            int zero = n - i-j-2*k;\n            if (zero < 0) break;\n            res += bino[i+j][i] * bino[n][zero];\n        }\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\nusing namespace std;\nconst int mod = 998244353;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return w*s;}\nint n,X,fac[101100],Ifac[101011];\ninline ll ksm (ll x,ll y){ll res=1;while(y){if(y&1) res=res*x%mod;x=x*x%mod;y>>=1;}return res;}\ninline void Init(){\n\tIfac[0]=fac[0]=1;\n\tfor(rint i=1;i<=10000;++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tIfac[10000]=ksm(fac[10000],mod-2);\n\tfor(rint i=9999;i;--i) Ifac[i]=1ll*(i+1)*Ifac[i+1]%mod;\n}\ninline int C(int a,int b){if(a<b) return 0;return 1ll*fac[a]*Ifac[b]%mod*Ifac[a-b]%mod;}\ninline int pls(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int get(int len){\n\tint Ans=0;\n\tif(2*len<X||(X%2==1)) Ans=1;\n\tfor(rint i=len;i<=2*len-1;++i){\n\t\tif(i<X) Ans=pls(Ans,C(len,i-len));\n\t\telse {\n\t\t\tif((i-X)%2==0) continue;\n\t\t\tint o=(i-X+1)/2;\n\t\t\tint p=len-2*o,q=i-4*o;\n\t\t\tAns=pls(Ans,C(p,q-p));\n\t\t}\n\t}\n\treturn Ans;\n}\nint main()\n{\t\n\tn=read(),X=read();\n\tInit();\n\tll Ans=0;\n\tfor(rint i=0;i<=n;++i){\n\t\tAns=pls(Ans,1ll*C(n,i)*get(i)%mod);\n\t}cout<<Ans;\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\ntemplate <class T> inline void chmin(T &a, const T& b) { if (b < a) a = b; }\ntemplate <class T> inline void chmax(T &a, const T& b) { if (b > a) a = b; }\n/* clang-format on */\n\nconst ll MOD = 998244353ll;\n\nll power(ll x, ll e) {\n  ll v = 1;\n  for (; e > 0; e >>= 1) {\n    if (e & 1) {\n      v = v * x % MOD;\n    }\n    x = x * x % MOD;\n  }\n  return v;\n}\n\nll inverse(ll x) {\n  return power(x, MOD - 2);\n}\n\nvector<ll> fact, factInv;\nvoid initFact(int N) {\n  fact.resize(N + 1);\n  factInv.resize(N + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= N; i++) {\n    fact[i] = fact[i - 1] * i % MOD;\n  }\n  factInv[N] = inverse(fact[N]);\n  for (int i = N - 1; i >= 0; i--) {\n    factInv[i] = factInv[i + 1] * (i + 1) % MOD;\n  }\n}\n\nll choose(int n, int k) {\n  if (n < 0 || k < 0 || k > n) {\n    return 0;\n  } else {\n    return fact[n] * factInv[k] % MOD * factInv[n - k] % MOD;\n  }\n}\n\nvec<ll, 2> tbl;\nvoid init(int N) {\n  initFact(N);\n  tbl.resize(N + 1);\n  for (int i = 0; i <= N; i++) {\n    tbl[i].resize(N + 2);\n    tbl[i][0] = 0;\n    for (int j = 0; j <= N; j++) {\n      tbl[i][j + 1] = (tbl[i][j] + choose(i - j, j)) % MOD;\n    }\n  }\n}\n\nll solveLess(int N, int X) {\n  ll res = 0;\n  for (int two = 0; two <= N; two++) {\n    int one = N - two;\n    if (2 * two + one < X) {\n      ll ways = choose(N, two);\n      res = (res + ways) % MOD;\n    }\n  }\n  return res;\n}\n\nll solveOverSub(int N, int R, int T) {\n  ll lb = max({0, R - N + 1});\n  ll ub = min({N, R / 2, T - N + R});\n  if (lb > ub) return 0;\n  ll res = (tbl[R][ub + 1] - tbl[R][lb] + MOD) % MOD;\n  return res;\n}\n\nll solveOver(int N, int X) {\n  ll res = 0;\n  if (2 * N > X && X % 2 == 1) {\n    ++res;\n  }\n  for (int two = 0; two < N && 2 * two + 1 < X; two++) {\n    res += solveOverSub(N - two - 1, X - 2 * two - 2, two);\n    res %= MOD;\n  }\n  return res;\n}\n\nll solve(int N, int X) {\n  return (solveLess(N, X) + solveOver(N, X)) % MOD;\n}\n\nint main() {\n#ifdef DEBUG\n  ifstream cin(\"in.txt\");\n#endif\n  init(6010);\n  int N, X;\n  while (cin >> N >> X) {\n    ll res = 0;\n    for (int zero = 0; zero <= N; zero++) {\n      ll ways = solve(N - zero, X) * choose(N, zero) % MOD;\n      res = (res + ways) % MOD;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define mp make_pair\ntypedef pair<int,int> P;\n#define REP(i,x,y) for(int i=x;i<=y;i++)\n#define abs(x) ((x)>0?(x):-(x))\nconst int maxn = 10006, inf = 0x3f3f3f3f;\nint n;\nint a[maxn];\nint gcd(int a,int b){\n\tif(a<b) swap(a,b);\n\tif(!b) return a;\n\treturn gcd(b,a%b);\n}\nvector<int> isp(maxn,-1);\nvoid init(){\n\tisp[0]=isp[1]=0;\n\tfor(int i=2;i<maxn;i++){\n\t\tif(isp[i]){\n\t\t\tfor(int j=2;j*i<maxn;j++) isp[i*j]=0;\n\t\t}\n\t}\n}\nset<int> ans;\nll cal(ll i,ll p){\n\tll ans=0;\n\tfor(int j=0;j<=n;j++){\n\t\tans = 1LL * ans * i % p + a[j];\n\t\tans %= p;\n\t}\n\treturn ans;\n}\nvoid div(int p){\n\tfor(int i=n;i;i--){\n\t\ta[i-1]+=a[i]/p;\n\t}\n\tn--;\n}\nint main(){\n\tinit();\n\tcin>>n;\n\tfor(int i=0;i<=n;i++) cin>>a[i];\n\tint d=abs(a[0]);\n\tfor(int i=1;i<=n;i++) d=gcd(d,abs(a[i]));\n\tint dd=d;\n\tfor(int i=2;i<=d&&i<maxn;i++){\n\t\tif(isp[i]&&!ans.count(i)&&d%i==0) {\n\t\t\tans.insert(i);\n\t\t\td/=i;\n\t\t}\n\t}\n\tif(d>1) ans.insert(d);\n\tfor(int i=0;i<=n;i++) a[i]/=dd;\n\tint tot=1;\n\tfor(int i=0;i<isp.size();i++){if(!isp[i]) continue;\n\t\tint p=i;\n\t\tint fl=0;\n\t\tfor(int j=p-1;j>=0;j--){\n\t\t\tif(cal(j,p)) {\n\t\t\t\tfl=1;\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!fl && !ans.count(p)) {\n\t\t\tans.insert(p);\n\t\t\tdiv(p);\n\t\t}\n\t}\n\tfor(auto p:ans) cout<<p<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define inline __inline__ __attribute__((always_inline))\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\nusing namespace std;\nconst int N=3005,P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint f[N][N<<1],c[N],inv[N],x,n,res;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&x),res=1;\n\tinv[0]=inv[1]=1;fp(i,2,n)inv[i]=mul(P-P/i,inv[P%i]);\n\tc[0]=1;fp(i,1,n)c[i]=1ll*c[i-1]*inv[i]%P*(n-i+1)%P;\n\tf[0][0]=1;fp(i,0,n-1)fp(j,0,i<<1)upd(f[i+1][j+2],f[i][j]),upd(f[i+1][j+1],f[i][j]);\n\tfp(i,1,n){\n\t\tint s=0;\n\t\tfp(j,0,x-1)upd(s,f[i][j]);\n\t\tfor(R int j=x+1;j<=(i<<1);j+=2)if(j>=i){\n\t\t\tint p=i-(j-x+1),q=x-1-(j-x+1);\n\t\t\tif(j>=x*2)upd(s,j==(i<<1)?x&1:0);\n\t\t\t\telse upd(s,p>=0&&q>=0?f[p][q]:0);\n\t\t}\n\t\tupd(res,mul(s,c[i]));\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nconstexpr ll mod = 998244353;\nconstexpr ll modsize = 100010;\nvector<ll> fac(modsize);\nvector<ll> inv(modsize);\nvector<ll> facinv(modsize);\n\nvoid modcalc() {\n\tif (modsize == 0) abort();\n\tfac[0] = 1; fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = 1; facinv[1] = 1;\n\tfor (ll i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modinv(ll a) {\n\tif (a == 0) abort();\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0 || n == 0 && k > 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn fac[n + k - 1] * facinv[k] % mod * facinv[n - 1] % mod;\n}\n\nll dp[3010][6010];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tmodcalc();\n\n\tll n, x;\n\tcin >> n >> x;\n\tdp[0][0] = 1;\n\trep(i, n) {\n\t\trep(j, 6008) {\n\t\t\trep(k, 3) {\n\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\tif (dp[i + 1][j + k] >= mod) dp[i + 1][j + k] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\trep(i, x) ans += dp[n][i];\n\tans %= mod;\n\tif (x & 1) {\n\t\tfor (int i = (x + 1) / 2; i <= n; i++) ans += modcomb(n, i);\n\t\tans %= mod;\n\t}\n\tfor (int i = 1; i <= (x - 2) / 2; i++) {\n\t\tint rem = x - 1 - 2 * i;\n\t\tfor (int two = 0; two <= (rem - 1) / 2; two++) {\n\t\t\tint one = rem - 2 * two;\n\t\t\tll cnt = modcomb(one + two, one);\n\t\t\tcnt *= modcomb(n, one + two + 2 * i);\n\t\t\tans += cnt % mod;\n\t\t}\n\t\tans %= mod;\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long LL;\nconst int N=6005;\nconst int MOD=998244353;\nint add (int x,int y)   {x=x+y;return x>=MOD?x-MOD:x;}\nint mul (int x,int y)   {return (LL)x*y%MOD;}\nint dec (int x,int y)   {x=x-y;return x<0?x+MOD:x;}\nint Pow (int x,int y)\n{\n\tif (y==1) return x;\n\tint lalal=Pow(x,y>>1);\n\tlalal=mul(lalal,lalal);\n\tif (y&1) lalal=mul(lalal,x);\n\treturn lalal;\n}\nint n,x;\nint JC[N],inv[N];\nvoid Init (int n)\n{\n\tJC[0]=1;for (int u=1;u<=n;u++) JC[u]=mul(JC[u-1],u);\n\tinv[n]=Pow(JC[n],MOD-2);\n\tfor (int u=n-1;u>=0;u--) inv[u]=mul(inv[u+1],u+1);\n}\nint C (int x,int y)\t{return mul(inv[x-y],mul(JC[x],inv[y]));}\nint calc (int x,int y)\n{\n\tif (x<0) return 0;\n\tif (y<0) return 0;\n\tif (x>y) return 0;\n\treturn C(x,y-x);\n}\nint main()\n{\n\tInit(6000);\n\tscanf(\"%d%d\",&n,&x);\n\tint ans=0;\n\tfor (int u=0;u<=n;u++)\n\t{\n\t\tint tmp=0;\n\t\tfor (int i=u;i<=2*u;i++)\n\t\t{\n\t\t\tif (i<x) \n\t\t\t{\n\t\t\t//\tprintf(\"%d %d %d\\n\",u,i,calc(u,i));\n\t\t\t\ttmp=add(tmp,calc(u,i));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint t=i-x;\n\t\t\t\tif (t%2==0) continue;\n\t\t\t\tint tt=t/2+1;\n\t\t\t\tint a=u-2*tt;\n\t\t\t\t//printf(\"%d %d %d %d\\n\",a,i,t,tt);\n\t\t\t\tif (a<=0) \n\t\t\t\t{\n\t\t\t\t\tif (i==u*2)\ttmp=add(tmp,1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint b=i-tt*2*2;\n\t\t\t\t\t//printf(\"%d %d %d %d\\n\",i,t,a,b);\n\t\t\t\t\ttmp=add(tmp,calc(a,b));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"u:%d %d\\n\",u,tmp);\n\t\tans=add(ans,mul(tmp,C(n,u)));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n\nconst int MOD = 998244353;\nconst int MAX = 6100;\nusing mint = Fp<MOD>;\n\n\nint main() {\n    int N, K; cin >> N >> K;\n\n    // 二項係数とその累積和\n    vector<vector<mint> > com(MAX, vector<mint>(MAX, 0));\n    vector<vector<mint> > scom(MAX, vector<mint>(MAX+1, 0));\n    com[0][0] = 1;\n    for (int i = 1; i < MAX; ++i) {\n        com[i][0] = 1;\n        for (int j = 1; j < MAX; ++j) com[i][j] = com[i-1][j-1] + com[i-1][j];\n    }\n    for (int i = 0; i < MAX; ++i) {\n        for (int j = 0; j < MAX; ++j) {\n            scom[i][j+1] = scom[i][j] + com[i][j];\n        }\n    }\n\n    // 0\n    mint res =  0;\n\n    // 2 しかやらない場合\n    for (int i = 0; i <= N; ++i) {\n        if (K % 2 == 0 && i*2 >= K) continue;\n        res += com[N][i];\n    }\n    //cout << res << endl;\n    \n    for (int i = 0; i*2+1 < K; ++i) {\n        int L = (K-1) - (i*2+1);\n        mint tmp1 = 0;\n        for (int m = 0; m <= min(L, N - (i+1)); ++m) {\n            tmp1 += scom[m][L-m] * com[N][m+i+1];\n\n            //cout << i << \"+, \" << m << \": \" << scom[m][L-m] << \", \" << com[N][m+i+1] << endl;\n        }\n        mint tmp2 = 0;\n        for (int m = 0; m <= min(L, N - (i+1)); ++m) {\n            tmp2 += com[m][L-m] * (scom[N][min(N, i*2+1+m)+1] - scom[N][i+1+m]);\n\n            //cout << i << \"-, \" << m << \": \" << com[m][L-m] << \", \" << (scom[N][N+1] - scom[N][i+1+m]) << endl;\n        }\n        res += tmp1 + tmp2;\n\n        //cout << i << \": \" << L << \", \" << tmp1 << \", \" << tmp2 << endl;\n    }\n    cout << res << endl;\n}\n    \n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nconst int N = 6010;\nll fact[N], invf[N];\nll dp[N][N];\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nll nPr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(fact[n], invf[n-r]);\n}\n\nll nCr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(mul(fact[n], invf[r]), invf[n-r]);\n}\n\nint main() {\n    ll n, x;\n    cin >> n >> x;\n\n    fact[0] = invf[0] = 1;\n    FOR(i,1,N-1){\n        fact[i] = (fact[i-1] * i) % mod;\n        invf[i] = divll(invf[i-1], i);\n    }\n\n    dp[0][0] = 1;\n    REP(i,n) REP(j,N-2){\n        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % mod;\n        dp[i+1][j+2] = (dp[i+1][j+2] + dp[i][j]) % mod;\n    }\n\n    ll ans = 1;\n    FOR(m,1,n){\n        // cout << \"m \" << m << endl;\n        ll tmp = 0;\n        REP(j,x) tmp = (tmp + dp[m][j]) % mod;\n        FOR(t,1,(m-1)/2){\n            ll d = x - 1 - 2 * t;\n            if (d > 0) tmp = (tmp + dp[m - 2 * t][d]) % mod;\n            // if (2 * t == x) break;\n            // ll nn = m - 2 * t;\n            // for (ll xx = x - 3; xx > 0 && xx + 4 * t >= x; xx -= 2){\n            //     ll d = 0;\n            //     if (nn == 1){\n            //         if (xx == 1) d = 1;\n            //     }else{\n            //         d = dp[nn][xx];\n            //         if (xx >= 4) d = (d - dp[nn-2][xx-4]) % mod;\n            //     }\n            //     tmp += d;\n            //     cout << nn << \" \" << xx << \" \" << d << endl;\n            // }\n            // cout << d << \" \" << m - 2 * t << \" \" << dp[m - 2 * t][d] << endl;\n        }\n        if (x % 2 == 1 && 2 * m > x) tmp++;\n        // cout << tmp << endl;\n        ans = (ans + tmp * nCr(n, m)) % mod;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define DB long double\nusing namespace std;\n#define P 998244353\ninline int ad(int x,int y){return (x+y>=P)?(x+y-P):(x+y);}\ninline int mt(int x,int y){return 1ll*x*y%P;}\ninline void mo(int &x){x=(x>=P)?(x-P):x; x=(x<0)?(x+P):x;}\ntemplate<typename T>inline void ckmx(T &x,T y){x=max(x,y);}\ntemplate<typename T>inline void ckmi(T &x,T y){x=min(x,y);}\ntemplate<typename T>void read(T &x){\n\tx=0;int f=1;\n\tchar c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if (c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-48;\n\tx*=f;\n}\nint n,x;\nint g[3010][6010];\nint f[3010][6010];\nint cnt[3010]; \nint c[3010][3010];\nvoid prec(int n){\n\tfor(int i=0;i<=n;++i){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;++j)\n\t\t\tmo(c[i][j]=c[i-1][j]+c[i-1][j-1]);\n\t}\n}\nint main(){\n\tread(n);read(x);\n\tprec(n);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tf[i][i]=1;\n\t\tfor(int j=i+1;j<=n+n;++j)\n\t\t\tmo(f[i][j]=f[i-1][j-1]+f[i-1][j-2]);\n\t}\n\tfor(int i=0;i<x;++i)\n\t\tfor(int j=0;j<=n;++j)\n\t\t\tmo(cnt[j]+=f[j][i]);\n\tfor(int i=x+1;i<=n+n;i+=2){\n\t\tint zs=(i-(x-1))/2;\n\t\tif(zs*2>x-1){\n\t\t\tif(x&1) mo(++cnt[i/2]);\n\t\t\tcontinue;\t\n\t\t}\n\t\tfor(int j=zs;j<=n;++j)\n\t\t\tmo(cnt[j+zs]+=f[j-zs][x-1-zs*2]);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=n;++i)\n\t\tmo(ans+=mt(cnt[i],c[n][i]));\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=3005;\nconst int mod=998244353;\nint n,x;\nint fac[maxn*2],ifac[maxn*2];\nint C(int a,int b){\n\treturn (b<0||a<b)?0:1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&x);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2*n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*(mod-mod/i)*ifac[mod%i]%mod; \n\t}\n\tREP(i,2*n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tint tot=0;\n\trep(i,n+1){\n\t\tint ans=0;\n\t\trep(s,x)ans=(ans+C(i,s-i))%mod;\n\t\trep(j,i){\n\t\t\tint l=i-j+1,r=j;\n\t\t\tif(l>r){\n\t\t\t\tif(x-1==2*j)ans=(ans+1)%mod;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=x-1-2*(i-j);\n\t\t\tif(s<0)continue;\n\t\t\tans=(ans+C(r-l+1,s-(r-l+1)))%mod;\n\t\t} \n\t\ttot=(tot+1LL*ans*C(n,i)%mod)%mod; \n\t}\n\tprintf(\"%d\\n\",tot);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nlong long c[3001][3001];\nint dp[3001][6001][2];\nint dp2[3001][3001];\nint dp3[3001][3001];\nint dp4[3001][3001];\nint dp5[6001][2];\n\nint main() {\n    int n, x, i, j, k;\n    long long ans = 0;\n    \n    scanf(\"%d %d\", &n, &x);\n    \n    for (i = 0; i <= n; i++) {\n        c[i][0] = c[i][i] = 1;\n        for (j = 1; j < i; j++) {\n            c[i][j] = c[i - 1][j - 1] + c[i - 1][j];\n            if (c[i][j] >= mod) c[i][j] -= mod;\n        }\n    }\n    \n    dp[1][1][1] = 1;\n    for (i = 1; i < n; i++) {\n        for (j = 0; j <= n * 2; j++) {\n            for (k = 0; k < 2; k++) {\n                if (dp[i][j][k] == 0) continue;\n                \n                dp[i + 1][j + 2][0] += dp[i][j][k];\n                if (dp[i + 1][j + 2][0] >= mod) dp[i + 1][j + 2][0] -= mod;\n                \n                dp[i + 1][j + 1][1] += dp[i][j][k];\n                if (dp[i + 1][j + 1][1] >= mod) dp[i + 1][j + 1][1] -= mod;\n            }\n        }\n    }\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 1; j < x; j++) {\n            if (j % 2 == x % 2) continue;\n            if (dp[i][j][1] == 0) continue;\n            \n            dp2[i][(x - j) / 2] += dp[i][j][1];\n            if (dp2[i][(x - j) / 2] >= mod) dp2[i][(x - j) / 2] -= mod;\n        }\n    }\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            if (dp2[i][j] == 0) continue;\n            \n            dp3[i][j] += dp2[i][j];\n            if (dp3[i][j] >= mod) dp3[i][j] -= mod;\n            \n            if (i + j + 1 <= n) {\n                dp3[i + j + 1][j] -= dp2[i][j];\n                if (dp3[i + j + 1][j] < 0) dp3[i + j + 1][j] += mod;\n            }\n        }\n    }\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            dp3[i][j] += dp3[i - 1][j];\n            if (dp3[i][j] >= mod) dp3[i][j] -= mod;\n        }\n    }\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            if (dp3[i][j] == 0) continue;\n            \n            dp4[i][j] += dp3[i][j];\n            if (dp4[i][j] >= mod) dp4[i][j] -= mod;\n            \n            if (i + j + 1 <= n) {\n                dp4[i + j + 1][j] -= dp3[i][j];\n                if (dp4[i + j + 1][j] < 0) dp4[i + j + 1][j] += mod;\n            }\n        }\n    }\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            dp4[i][j] += dp4[i - 1][j];\n            if (dp4[i][j] >= mod) dp4[i][j] -= mod;\n        }\n    }\n    \n    dp5[0][0] = 1;\n    for (i = 0; i < n; i++) {\n        for (j = i * 2; j >= 0; j--) {\n            for (k = 0; k < 2; k++) {\n                if (dp5[j][k] == 0) continue;\n                \n                dp5[j + 2][k] += dp5[j][k];\n                if (dp5[j + 2][k] >= mod) dp5[j + 2][k] -= mod;\n                \n                dp5[j + 1][1] += dp5[j][k];\n                if (dp5[j + 1][1] >= mod) dp5[j + 1][1] -= mod;\n            }\n        }\n    }\n    \n    if (x % 2 == 0) {\n        for (i = 0; i < x / 2; i++) {\n            ans += c[n][i];\n            if (ans >= mod) ans -= mod;\n        }\n    } else {\n        for (i = 0; i <= n; i++) {\n            ans += c[n][i];\n            if (ans >= mod) ans -= mod;\n        }\n    }\n    \n    for (i = 1; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            if (dp4[i][j] == 0) continue;\n            \n            ans += dp4[i][j] * c[n][i] % mod;\n            if (ans >= mod) ans -= mod;\n        }\n    }\n    \n    for (i = 0; i < x; i++) {\n        if (i % 2 == x % 2) {\n            ans += dp5[i][1];\n            if (ans >= mod) ans -= mod;\n        }\n    }\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N, X;\nll con[6010][6010];\nll mod = 998244353;\nll ans;\n\nint main()\n{\n    cin >> N >> X;\n\n    for(int i = 0; i < 6010; i++)for(int j = 0; j < 6010; j++)\n    {\n        if(i == j)con[i][j] = 1;\n        else if(j == 0)con[i][j] = 1;\n        else con[i][j] = (con[i - 1][j] + con[i - 1][j - 1]) % mod;\n    }\n\n    for(int i = 0; i <= N; i++)\n    {\n        ll tmp = 0;\n        for(int j = 0; j <= i; j++)\n        {\n            if(2 * j < X - 1)continue;\n            int t = (X - 1) - j;\n            if(j - t != 0 && t < i - j)continue;\n            tmp += con[max(0, j - (i - j))][max(0, t - (i - j))] * con[N][i];\n            tmp %= mod;\n        }\n        ans += tmp;\n        ans %= mod;\n    }\n\n    for(int i = 0; i <= N; i++)\n    {\n        ll tmp = 0;\n        for(int j = 0; j <= i; j++)\n        {\n            if(i - j + j * 2 < X - 1)\n            {\n                tmp += con[N][i] * con[i][j] % mod;\n                tmp %= mod;\n            }\n        }\n        ans += tmp;\n        ans %= mod;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr lint MOD = 998244353;\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\nlint nPr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return fac[n] * facInv[n-r] % MOD;\n}\nlint power(lint x, lint n, lint mod=MOD)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= mod;\n        (x *= x) %= mod;\n       n >>= 1;\n    }\n   return ans;\n}\nlint doublefac(lint n)\n{\n    if (n < 0) return 0;\n    lint k = (n + 1) / 2;\n    if (n & 1) return fac[k * 2] * power(facInv[2], k) % MOD * power(fac[k], MOD - 2) % MOD;\n    else return fac[k] * power(facInv[2], k) % MOD;\n}\nint main()\n{\n    int N, X;\n    cin >> N >> X;\n\n    facInit(N);\n    lint ret = 0;\n    REP(i, N + 1) REP(j, N - i + 1)\n    {\n        if (i + 2 * j < X or (X % 2 and i == 0)) ret += nCr(N, N - i - j) * nCr(i + j, i) % MOD;\n        else\n        {\n            if (i >= X) continue;\n            if ((X - 1 - i) % 2) continue;\n            int d = (i + 2 * j - X + 1) / 2;\n            if (d * 2 > j) continue;\n            ret += nCr(N, N - i - j) * nCr(i + j - 2 * d, i) % MOD;\n        }\n    }\n    cout << ret % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define\tINF\t0x3f3f3f3f\n#define\tLL\tlong long\n#define\tMAXN\t3010\n#define\tmod\t998244353\nusing namespace std;\nint n, x, ans;\nint fac[MAXN], inv[MAXN];\n\ntemplate <typename T> void chkmin(T &x, T y){x = min(x, y);}\ntemplate <typename T> void chkmax(T &x, T y){x = max(x, y);}\ntemplate <typename T> void read(T &x){\n\tx = 0; int f = 1; char ch = getchar();\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}\n\tx *= f;\n}\n\nint mul(const int &x, const int &y){return 1ll * x * y % mod;}\nint inc(const int &x, const int &y){return (x + y >= mod) ? (x + y - mod) : (x + y);}\nint dec(const int &x, const int &y){return (x - y < 0) ? (x - y + mod) : (x - y);}\nvoid update(int &x, const int &y){x = (x + y >= mod) ? (x + y - mod) : (x + y);}\n\nint qpow(int a, int b){\n\tint ret = 1;\n\twhile (b) {\n\t\tif (b & 1) ret = mul(ret, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid init(int n){\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfac[i] = mul(fac[i - 1], i);\n\tinv[n] = qpow(fac[n], mod - 2);\n\tfor (int i = n - 1; i >= 1; --i)\n\t\tinv[i] = mul(inv[i + 1], i + 1);\n}\n\nint C(int n, int m){\n\treturn mul(fac[n], mul(inv[m], inv[n - m]));\n}\n\nint main(){\n\tread(n), read(x);\n\tinit(n);\n\tans = 1;\n\tfor (int s = 1; s < x; ++s){\n\t\tfor (int len = s / 2 + s % 2; len <= n && len <= s; ++len)\n\t\t\tupdate(ans, mul(C(len, s - len), C(n, len)));\n\t}\n\tfor (int s = x + 1; s <= 2 * n; s += 2){\n\t\tint i = (s - (x - 1)) / 2;\n\t\tif (2 * i >= x - 1) {\n\t\t\tif (x & 1) {\n\t\t\t\tint len = s / 2;\n\t\t\t\tupdate(ans, C(n, len));\n\t\t\t}\n\t\t} else {\n\t\t\tint ss = x - 1 - 2 * i;\n\t\t\tfor (int len = ss / 2 + ss % 2; len + 2 * i <= n && len <= ss; ++len)\n\t\t\t\tupdate(ans, mul(C(len, ss - len), C(n, len + 2 * i)));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, X, f[N][N << 1], fac[N << 1], inv[N << 1];\n\ninline int C(int x, int y) {\n    return x < y ? 0 : 1LL * fac[x] * inv[y] % Mod * inv[x - y] % Mod;\n}\n\nint main() {\n    cin >> n >> X;\n\n    inv[0] = inv[1] = fac[0] = fac[1] = 1;\n    for (int i = 2; i <= n; ++i)\n        fac[i] = 1LL * fac[i - 1] * i % Mod,\n        inv[i] = 1LL * inv[Mod % i] * (Mod - Mod / i) % Mod;\n\n    for (int i = 1; i <= n; ++i)\n        inv[i] = 1LL * inv[i - 1] * inv[i] % Mod;\n\n    f[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < X * 2; ++j)\n            (f[i + 1][j + 1] += f[i][j]) %= Mod,\n            (f[i + 1][j + 2] += f[i][j]) %= Mod;\n\n    long long ans = 1;\n    for (int i = 1; i <= n; ++i) {\n        long long tmp = 0;\n        for (int j = 0; j < X; ++j)\n            (tmp += f[i][j]) %= Mod;\n        for (int j = X + 1; j <= 2 * i; j += 2) {\n            if (j < i) continue;\n            int p = i - (j - X + 1), q = X - 1 - (j - X + 1);\n            if (j >= X * 2) (tmp += (j == (i << 1) ? X & 1 : 0)) %= Mod;\n            else (tmp += (p >= 0 && q >= 0 ? f[p][q] : 0)) %= Mod;\n        }\n        (ans += 1LL * tmp * C(n, i) % Mod) %= Mod;\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = (a*b) % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = 1;\n    fact[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact[i] = fact[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = 1;\n    seq_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = 1;\n    fact_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint main(){\n    int N, X;\n    cin >> N >> X;\n    create_mod_tables(6010);\n\n    static int64_t dp[3001][6010], sub[3001][6010];\n    dp[0][0] = 1;\n    sub[0][0] = 1;\n    for(int i=0; i<N; i++) for(int j=0; j<=2*N; j++){\n        for(int k=0; k<=2; k++) add(dp[i+1][j+k], dp[i][j]);\n        for(int k=1; k<=2; k++) add(sub[i+1][j+k], sub[i][j]);\n    }\n    int64_t ans = 0;\n    for(int j=0; j<X; j++) add(ans, dp[N][j]);\n\n    for(int t=X+1; t<=2*N; t+=2){\n        int s = t+1-X;\n        if(X%2 == 0 && X <= s) break;\n        if(s <= X-1){\n            for(int d=0; d<=N; d++){\n                int64_t result = 1;\n                mul(result, sub[d][X-1-s]);\n                int stp = s/2 + d + (t - (X-1))/2;\n                if(stp > N) continue;\n                mul(result, comb_mod(N, stp));\n                add(ans, result);\n            }\n        }else{\n            add(ans, comb_mod(N, t/2));\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int MOD = 998244353;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nconst int N = 3007;\nint f[N], inv[N];\nvoid prec() {\n    f[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = mod(f[i - 1] * i);\n    inv[N - 1] = fp(f[N - 1], MOD - 2);\n    for (int i = N - 2; i >= 0; --i)\n        inv[i] = mod(inv[i + 1] * (i + 1));\n}\nint C(int n, int k) {\n    return mod(f[n] * mod(inv[k] * inv[n - k]));\n}   \nvoid add(int &a, int b) {\n    a = mod(a + b);\n}   \n\nint dp1[N][2 * N], dp2[N][2 * N], pref[2][N][2 * N];\nvoid calc_dp() {\n    dp1[0][0] = 1;\n    for (int i = 0; i + 1 < N; ++i) {\n        for (int j = 0; j <= i * 2; ++j) {\n            for (int x = 1; x <= 2; ++x) {\n                add(dp1[i + 1][j + x], dp1[i][j]);\n            }\n        }   \n    }   \n    dp2[1][2] = 1;\n    for (int i = 1; i + 1 < N; ++i) {\n        for (int j = 0; j <= i * 2; ++j) {\n            for (int x = 1; x <= 2; ++x) {\n                add(dp2[i + 1][j + x], dp2[i][j]);\n            }\n        }   \n    }   \n    dp1[1][2] = 0;\n    for (int i = 1; i + 1 < N; ++i) {\n        for (int j = 0; j <= i * 2; ++j) {\n            add(dp1[i + 1][j + 2], -dp2[i][j]);\n        }   \n    }\n    for (int t = 0; t < 2; ++t) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j + 1 < 2 * N; ++j) {\n                pref[t][i][j + 1] = pref[t][i][j];\n                if ((j&1)==t)\n                    add(pref[t][i][j+1], dp1[i][j]); \n            }   \n        }   \n    }   \n}   \n\nint get(int len, int l, int r, int t) {\n    //cant be 2 in front and in back\n\n    //cout << \"get \" << len << ' ' << sum << \" : \" << dp1[len][sum] << endl;\n\n    return mod(pref[t][len][r + 1] - pref[t][len][l]);\n}   \n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    prec();\n    calc_dp();\n\n    int n, x;\n    cin >> n >> x;\n\n    //there is no 1\n    int ans = 0;\n    for (int c1 = 0; c1 <= n; ++c1) {\n        for (int c2 = 0; c1 + c2 <= n; ++c2) {\n            if (c1 + 2 * c2 < x) {\n                add(ans, C(n, c1) * C(n - c1, c2));\n            }   \n        }   \n    }   \n\n    #ifdef HOME\n    cout << ans << endl;\n    #endif\n\n    for (int c2 = 0; c2 <= n; ++c2) {\n        if (x % 2 && c2 * 2 >= x) {\n            add(ans, C(n, c2));\n        }   \n    }   \n\n    #ifdef HOME\n    cout << ans << endl;\n    #endif\n\n    for (int len = 1; len <= n; ++len) {\n        for (int k = 1; k * 2 < len; ++k) {\n            int mid = len - 2 * k;\n\n            int l = max(1ll, x - 4 * k);\n            int r = x - 2 * k - 1;\n            if (l <= r) {\n                int w = (x&1)^1;\n                add(ans, get(mid, l, r, w) * C(n, len));\n            }\n        }   \n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define inline __inline__ __attribute__((always_inline))\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\nusing namespace std;\nconst int N=3005,P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint f[N][N],c[N],inv[N],x,n,res;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&x),res=1;\n\tinv[0]=inv[1]=1;fp(i,2,n)inv[i]=mul(P-P/i,inv[P%i]);\n\tc[0]=1;fp(i,1,n)c[i]=1ll*c[i-1]*inv[i]%P*(n-i+1)%P;\n\tf[0][0]=1;fp(i,0,n-1)fp(j,0,i<<1)upd(f[i+1][j+2],f[i][j]),upd(f[i+1][j+1],f[i][j]);\n\tfp(i,1,n){\n\t\tint s=0;\n\t\tfp(j,0,x-1)upd(s,f[i][j]);\n\t\tfor(R int j=x+1;j<=(i<<1);j+=2)if(j>=i){\n\t\t\tint p=i-(j-x+1),q=x-1-(j-x+1);\n//\t\t\tif(j>=x*2)upd(s,j==(i<<1)?x&1:0);\n//\t\t\t\telse upd(s,p>=0&&q>=0?f[p][q]:0);\n\t\t\tif(j>=x*2){if(j==i*2)upd(s,x&1);}\n\t\t\t\telse if(p>=0&&q>=0)upd(s,f[p][q]);\n\t\t}\n\t\tupd(res,mul(s,c[i]));\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\nll P = 998244353;\n\nclass C {\npublic:\n  int n;\n  vector<long long> fac, inv, facInv;\n\n  long long power(long long e, long long x) {\n    if (x == 0)\n      return 1;\n    if (x == 1)\n      return e;\n    if (x % 2 == 0)\n      return power((e * e) % P, x / 2);\n    return (e * power(e, x - 1)) % P;\n  }\n\n  C(int n_) {\n    n = n_;\n    fac.resize(n + 1);\n    inv.resize(n + 1);\n    facInv.resize(n + 1);\n    fac[0] = fac[1] = 1;\n    for (int i = 2; i <= n; i++)\n      fac[i] = (i * fac[i - 1]) % P;\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      inv[i] = power(i, P - 2);\n    facInv[0] = facInv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      facInv[i] = (inv[i] * facInv[i - 1]) % P;\n  }\n\n  long long comb(int N, int K) {\n    if (N < K || K < 0 || N < 0)\n      return 0;\n    if (N == 0 || K == 0 || K == N)\n      return 1;\n    return ((fac[N] * facInv[K]) % P * facInv[N - K]) % P;\n  }\n\n  long long hcomb(int N, int K) {\n    if (N == 0 && K == 0)\n      return 1;\n    return comb(N + K - 1, K);\n  }\n\n  long long mul(long long a, long long b) { return (a * b) % P; }\n\n  long long add(long long a, long long b) { return (a + b) % P; }\n\n  // find c\n  // where a^c = b (mod P)\n  long long dlp(long long a, long long b) {\n    long long m = ceil(sqrt(P));\n    map<long long, long long> mp;\n    for (int i = 0; i < m; i++)\n      mp[power(a, i)] = i;\n    long long ainvm = power(power(a, m), P - 2);\n    cout << m << endl;\n    for (int i = 0; i < m; i++) {\n      if (mp.find(b) != mp.end()) {\n        return i * m + mp[b];\n      }\n      b = mul(b, ainvm);\n    }\n    return -1;\n  }\n};\n\nC cmb(202020);\n\nll f(ll l, ll sum) {\n  ll two = sum - l;\n  ll one = l - two;\n  if (two < 0 || one < 0) return 0;\n  return ((cmb.fac[one + two] * cmb.facInv[one]) % P * cmb.facInv[two]) % P;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, x;\n  cin >> n >> x;\n  ll ans = 0;\n  for (int i = 0; i <= n; i++) {\n    for (int s = 0; s < x; s++) {\n      ll temp = ((cmb.fac[n] * cmb.facInv[i]) % P * cmb.facInv[n - i]) % P;\n      ans += (temp * f(i, s)) % P;\n      ans %= P;\n    }\n  }\n  for (int i = 1; x + i <= 2 * n; i += 2) {\n    if (i + 1 >= x - 1) {\n      if (x % 2) {\n        ans += ((cmb.fac[n] * cmb.facInv[(x + i) / 2]) % P * cmb.facInv[n - (x + i) / 2]) % P;\n        ans %= P;\n      }\n    } else {\n      for (int j = 0; j <= n; j++) {\n        ans += (f(j, x - i - 2) * cmb.comb(n, i + j + 1));\n        ans %= P;\n      }\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n\nconst int MOD = 998244353;\nconst int MAX = 3100;\nusing mint = Fp<MOD>;\n\n\nint main() {\n    int N, K; cin >> N >> K;\n\n    // 二項係数とその累積和\n    vector<vector<mint> > com(MAX, vector<mint>(MAX, 0));\n    vector<vector<mint> > scom(MAX, vector<mint>(MAX+1, 0));\n    com[0][0] = 1;\n    for (int i = 1; i < MAX; ++i) {\n        com[i][0] = 1;\n        for (int j = 1; j < MAX; ++j) com[i][j] = com[i-1][j-1] + com[i-1][j];\n    }\n    for (int i = 0; i < MAX; ++i) {\n        for (int j = 0; j < MAX; ++j) {\n            scom[i][j+1] = scom[i][j] + com[i][j];\n        }\n    }\n\n    // 0\n    mint res =  0;\n\n    // 2 しかやらない場合\n    for (int i = 0; i <= N; ++i) {\n        if (K % 2 == 0 && i*2 >= K) continue;\n        res += com[N][i];\n    }\n    //cout << res << endl;\n    \n    for (int i = 0; i*2+1 < K; ++i) {\n        int L = (K-1) - (i*2+1);\n        mint tmp1 = 0;\n        for (int m = 0; m <= min(L, N - (i+1)); ++m) {\n            tmp1 += scom[m][L-m] * com[N][m+i+1];\n\n            //cout << i << \"+, \" << m << \": \" << scom[m][L-m] << \", \" << com[N][m+i+1] << endl;\n        }\n        mint tmp2 = 0;\n        for (int m = 0; m <= min(L, N - (i+1)); ++m) {\n            tmp2 += com[m][L-m] * (scom[N][min(N, i*2+1+m)+1] - scom[N][i+1+m]);\n\n            //cout << i << \"-, \" << m << \": \" << com[m][L-m] << \", \" << (scom[N][N+1] - scom[N][i+1+m]) << endl;\n        }\n        res += tmp1 + tmp2;\n\n        //cout << i << \": \" << L << \", \" << tmp1 << \", \" << tmp2 << endl;\n    }\n    cout << res << endl;\n}\n    \n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nnamespace n91 {\n\n\tusing i8 = std::int_least8_t;\n\tusing i32 = std::int_least32_t;\n\tusing i64 = std::int_least64_t;\n\tusing u8 = std::uint_least8_t;\n\tusing u32 = std::uint_least32_t;\n\tusing u64 = std::uint_least64_t;\n\tusing isize = std::ptrdiff_t;\n\tusing usize = std::size_t;\n\n\tclass rep {\n\t\tconst usize f, l;\n\n\tpublic:\n\t\tclass itr {\n\t\t\tfriend rep;\n\t\t\tusize i;\n\t\t\tconstexpr itr(const usize x) noexcept : i(x) {}\n\n\t\tpublic:\n\t\t\tvoid operator++() noexcept { ++i; }\n\t\t\tconstexpr usize operator*() const noexcept { return i; }\n\t\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t\t};\n\t\tconstexpr rep(const usize first, const usize last) noexcept\n\t\t\t: f(first), l(last) {}\n\t\tconstexpr itr begin() const noexcept { return itr(f); }\n\t\tconstexpr itr end() const noexcept { return itr(l); }\n\t};\n\tclass revrep {\n\t\tconst usize f, l;\n\n\tpublic:\n\t\tclass itr {\n\t\t\tfriend revrep;\n\t\t\tusize i;\n\t\t\tconstexpr itr(usize x) noexcept : i(x) {}\n\n\t\tpublic:\n\t\t\tvoid operator++() noexcept { --i; }\n\t\t\tconstexpr usize operator*() const noexcept { return i; }\n\t\t\tconstexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n\t\t};\n\t\tconstexpr revrep(usize first, usize last) noexcept : f(--first), l(--last) {}\n\t\tconstexpr itr begin() const noexcept { return itr(l); }\n\t\tconstexpr itr end() const noexcept { return itr(f); }\n\t};\n\ttemplate <class T> using vec_alias = std::vector<T>;\n\ttemplate <class T> auto md_vec(const usize n, const T &value) {\n\t\treturn std::vector<T>(n, value);\n\t}\n\ttemplate <class... Args> auto md_vec(const usize n, Args... args) {\n\t\treturn std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n\t}\n\ttemplate <class T> constexpr T difference(const T &a, const T &b) {\n\t\treturn a < b ? b - a : a - b;\n\t}\n\n} // namespace n91\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\tconstexpr u64 &value() noexcept { return a; }\n\tconstexpr const u64 &value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint &operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <utility>\n\nnamespace n91 {\n\n\tvoid main_() {\n\t\tusing mint = modint<998244353>;\n\t\tusize n, x;\n\t\tstd::cin >> n >> x;\n\t\tconst usize f_max = (n + x + 1) * 2;\n\t\tstd::vector<mint> fact(f_max + 1), ifac(f_max + 1);\n\t\tfact[0] = 1;\n\t\tfor (const auto i : rep(1, f_max + 1)) {\n\t\t\tfact[i] = fact[i - 1] * i;\n\t\t}\n\t\tifac[f_max] = mint(1) / fact[f_max];\n\t\tfor (const auto i : revrep(1, f_max + 1)) {\n\t\t\tifac[i - 1] = ifac[i] * i;\n\t\t}\n\t\tconst auto binom = [&](const usize n, const usize r) {\n\t\t\treturn fact[n] * ifac[r] * ifac[n - r];\n\t\t};\n\t\tmint ans = 0;\n\t\tif (x % 2 == 0) {\n\t\t\tstd::vector<mint> count(n + x + 1);\n\t\t\tfor (const auto i : rep(0, x)) {\n\t\t\t\tfor (usize j = 0; j * 2 <= i; ++j) {\n\t\t\t\t\tcount[i - j] += binom(i - j, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (usize i = x + 1; i <= 2 * x - 3; i += 2) {\n\t\t\t\tconst usize rem = 2 * x - i - 2;\n\t\t\t\tfor (usize j = 0; j * 2 <= rem; ++j) {\n\t\t\t\t\tcount[x - 1 - j] += binom(rem - j, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const auto i : rep(0, n + 1)) {\n\t\t\t\tans += count[i] * binom(n, i);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tstd::vector<mint> count(n + x + 1);\n\t\t\tif (x != 1) {\n\t\t\t\tfor (const auto i : rep(0, x)) {\n\t\t\t\t\tfor (usize j = 0; j * 2 <= i; ++j) {\n\t\t\t\t\t\tcount[i - j] += binom(i - j, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (usize i = x + 1; i < 2 * x - 2; i += 2) {\n\t\t\t\tconst usize rem = 2 * x - i - 2;\n\t\t\t\tfor (usize j = 0; j * 2 <= rem; ++j) {\n\t\t\t\t\tcount[x - 1 - j] += binom(rem - j, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (usize i = 2 * x - 2; i / 2 <= n; i += 2) {\n\t\t\t\tcount[i / 2] += 1;\n\t\t\t}\n\t\t\tfor (const auto i : rep(0, n + 1)) {\n\t\t\t\tans += count[i] * binom(n, i);\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans.value() << std::endl;\n\t}\n\n} // namespace n91\n\nint main() {\n\tn91::main_();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\n\nlong long dp[3010][6010] = {};\nlong long powing(long long a, long long b) {\n\tlong long ans = 1;\n\twhile (b != 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nlong long inv(long long now) {\n\treturn powing(now, MOD - 2);\n}\nlong long omote[20000];\nlong long gyaku[20000];\nlong long combination(long long a, long long b) {\n\tlong long ans = omote[a];\n\tans *= gyaku[b];\n\tans %= MOD;\n\tans *= gyaku[a - b];\n\tans %= MOD;\n\treturn ans;\n}\nlong long hype(long long a, long long b) {\n\treturn combination(a + b - 1, b);\n}\nint main(){\n\tint n, x;\n\tcin >> n >> x;\n\tomote[0] = 1;\n\tgyaku[0] = 1;\n\tfor (long long i = 1; i < 20000; ++i) {\n\t\tomote[i] = omote[i - 1] * i;\n\t\tomote[i] %= MOD;\n\t\tgyaku[i] = inv(omote[i]);\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int q = 0; q < x; ++q) {\n\t\t\tif (dp[i][q] == 0) continue;\n\t\t\tdp[i + 1][q + 1] += dp[i][q];\n\t\t\tdp[i + 1][q + 2] += dp[i][q];\n\t\t\tdp[i + 1][q + 1] %= MOD;\n\t\t\tdp[i + 1][q + 2] %= MOD;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int q = 0; q < x; ++q) {\n\t\t\tif (dp[i][q] == 0) continue;\n\t\t\tans += dp[i][q] * hype(i+1, n - i);\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tif (x % 2 == 1) {\n\t\tfor (int i = (x + 1) / 2; i <= n; ++i) {\n\t\t\tans += hype(i + 1, n - i);\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tfor (int i = 1;i * 2 <= n; ++i) {\n\t\tfor (int two = 0;; ++two) {\n\t\t\tlong long remaining = x - 1 - 2 * two;\n\t\t\tif (remaining < 0) break;\n\t\t\tlong long cnt = i * 2 + two + remaining;\n\t\t\tif (cnt > n) continue;\n \t\t\tlong long tmp_ans = hype(cnt + 1, n - cnt);\n\t\t\tlong long bobo = 0;\n\t\t\tif (remaining >= 1&&two >= 1) {\n\t\t\t\tbobo += 2LL * combination(remaining - 1 + two - 1, two - 1);\n\t\t\t}\n\t\t\tif (remaining >= 2) {\n\t\t\t\tbobo += combination(remaining - 2 + two, two);\n\t\t\t}\n\t\t\ttmp_ans *= bobo;\n\t\t\ttmp_ans %= MOD;\n\t\t\tans += tmp_ans;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <type_traits>\nnamespace loquat {\ntemplate <typename T>\nstatic std::pair<T, T> extended_gcd(T a, T b){\n\tif(b == 0){ return std::pair<T, T>(1, 0); }\n\tconst auto p = extended_gcd(b, a % b);\n\treturn std::pair<T, T>(p.second, p.first - a / b * p.second);\n}\n}\nnamespace loquat {\ntemplate <int MOD>\nclass modulus_integer {\npublic:\n\ttypedef modulus_integer<MOD> self_type;\nprivate:\n\tint m_value;\n\tstatic self_type unsafe_construct(int x) noexcept {\n\t\tself_type y;\n\t\ty.m_value = x;\n\t\treturn y;\n\t}\npublic:\n\tmodulus_integer() noexcept\n\t\t: m_value(0)\n\t{ }\n\tmodulus_integer(int x) noexcept\n\t\t: m_value(x % MOD)\n\t{\n\t\tif(m_value < 0){ m_value += MOD; }\n\t}\n\tint operator*() const noexcept { return m_value; }\n\tself_type& operator=(const self_type& x) noexcept {\n\t\tm_value = x.m_value;\n\t\treturn *this;\n\t}\n\tbool operator==(const self_type& x) const noexcept {\n\t\treturn m_value == x.m_value;\n\t}\n\tself_type operator+(const self_type& x) const noexcept {\n\t\tconst int y = m_value + x.m_value;\n\t\treturn unsafe_construct(y >= MOD ? y - MOD : y);\n\t}\n\tself_type operator*(const self_type& x) const noexcept {\n\t\treturn unsafe_construct(\n\t\t\tstatic_cast<long long>(m_value) * x.m_value % MOD);\n\t}\n\tself_type operator/(const self_type& x) const {\n\t\treturn (*this) * self_type(extended_gcd(x.m_value, MOD).first);\n\t}\n\tself_type& operator+=(const self_type& x) noexcept {\n\t\treturn (*this = *this + x);\n\t}\n\tself_type& operator*=(const self_type& x) noexcept {\n\t\treturn (*this = *this * x);\n\t}\n};\ntemplate <int MOD>\ninline std::ostream& operator<<(\n\tstd::ostream& os, const modulus_integer<MOD>& x)\n{\n\tos << *x;\n\treturn os;\n}\n}\nnamespace loquat {\ntemplate <int MOD>\ninline modulus_integer<MOD> modulus_factorial(int x){\n\tusing mint = modulus_integer<MOD>;\n\tstatic std::vector<mint> table(1, mint(1));\n\tassert(x >= 0);\n\twhile(static_cast<int>(table.size()) <= x){\n\t\tconst int t = static_cast<int>(table.size());\n\t\ttable.push_back(table.back() * mint(t));\n\t}\n\treturn table[x];\n}\ntemplate <int MOD>\ninline modulus_integer<MOD> modulus_inv_factorial(int x){\n\tusing mint = modulus_integer<MOD>;\n\tstatic std::vector<mint> table(1, mint(1));\n\tassert(x >= 0);\n\twhile(static_cast<int>(table.size()) <= x){\n\t\tconst int t = static_cast<int>(table.size());\n\t\ttable.push_back(table.back() / mint(t));\n\t}\n\treturn table[x];\n}\ntemplate <int MOD>\ninline modulus_integer<MOD> modulus_combination(int n, int k){\n\tif(k < 0 || n < k){ return 0; }\n\tconst auto a = modulus_factorial<MOD>(n);\n\tconst auto b = modulus_inv_factorial<MOD>(n - k);\n\tconst auto c = modulus_inv_factorial<MOD>(k);\n\treturn a * b * c;\n}\ntemplate <int MOD>\ninline modulus_integer<MOD> modulus_multichoose(int n, int k){\n\treturn modulus_combination<MOD>(n + k - 1, k);\n}\n}\nusing namespace std;\nstatic const int MOD = 998244353;\nusing mint = loquat::modulus_integer<MOD>;\nstatic mint dp[3001][6001];\nstatic mint dp2[3001][6001][2];\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, x;\n\tcin >> n >> x;\n\tmint answer = 0;\n\tif(x % 2 != 0){\n\t\tanswer = 1;\n\t\tfor(int i = 0; i < n; ++i){ answer *= 2; }\n\t}\n\tfor(int i = 0; i <= n; ++i){\n\t\tfor(int j = 0; j <= x; ++j){ dp[i][j] = 0; }\n\t}\n\tdp[0][0] = dp[1][1] = 1;\n\tfor(int i = 1; i < n; ++i){\n\t\tfor(int j = 0; j <= x; ++j){\n\t\t\tif(dp[i][j] == 0){ continue; }\n\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\tdp[i + 1][j + 2] += dp[i][j];\n\t\t}\n\t}\n\tfor(int k = 0; k * 2 < x; ++k){\n\t\tconst int r = (x - 1) - (k * 2);\n\t\tfor(int i = 1; i + k <= n; ++i){\n\t\t\tif(dp[i][r] == 0){ continue; }\n\t\t\tfor(int j = 0; j <= k && k + i + j <= n; ++j){\n\t\t\t\tconst int m = k + i + j;\n\t\t\t\tanswer += dp[i][r] * loquat::modulus_multichoose<MOD>(m + 1, n - m);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i <= n; ++i){\n\t\tfor(int j = 0; j <= x; ++j){ dp2[i][j][0] = dp2[i][j][1] = 0; }\n\t}\n\tdp2[0][0][0] = 1;\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < x; ++j){\n\t\t\tif(dp2[i][j][0] == 0 && dp2[i][j][1] == 0){ continue; }\n\t\t\tdp2[i + 1][j + 0][0] += dp2[i][j][0];\n\t\t\tdp2[i + 1][j + 0][1] += dp2[i][j][1];\n\t\t\tdp2[i + 1][j + 1][1] += dp2[i][j][0];\n\t\t\tdp2[i + 1][j + 1][1] += dp2[i][j][1];\n\t\t\tdp2[i + 1][j + 2][0] += dp2[i][j][0];\n\t\t\tdp2[i + 1][j + 2][1] += dp2[i][j][1];\n\t\t}\n\t}\n\tfor(int j = 0; j < x - 1; ++j){\n\t\tanswer += dp2[n][j][1];\n\t\tif(x % 2 == 0){ answer += dp2[n][j][0]; }\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <random>\n#include <stack>\n#include <set>\n#include <unordered_set>\n\n#define bug(x) cout<<\"zdongdebug: \"<<x<<endl;\n#define bug2(x, y) cout<<\"zdongdebug: \"<<x<<\" \"<<y<<endl;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3005;\nconst ll mod = 998244353;\nll c[maxn][maxn];\nll f[maxn][maxn+maxn];\nvoid pd(ll&ret,ll val){\n  ret+=val;\n  ret%=mod;\n}\nvoid init() {\n  f[0][0] = 1;\n  for (int i = 0; i < maxn; i++)c[i][0] = c[i][i] = 1;\n  for (int i = 1; i < maxn; i++)\n    for (int j = 1; j < i; j++) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1])%mod;\n    }\n}\n\nint n,m;\nint sq[maxn];\nint ans;\nvoid dfs(int pos) {\n  if(pos == n) {\n    for(int i=0;i<n;i++){\n      int sum = 0;\n      for(int j=i;j<n;j++){\n        sum+=sq[j];\n        if(sum==m)return;\n      }\n    }\n    ans++;\n    if(ans>mod)ans-=mod;\n    return;\n  }\n  for(int i=0;i<3;i++){\n    sq[pos]=i;\n    dfs(pos+1);\n  }\n}\n\nint main() {\n#ifdef suiyuan2009\n  freopen(\"/Users/suiyuan2009/CLionProjects/icpc/input.txt\", \"r\", stdin);\n#endif\n  init();\n  cin>>n>>m;\n // dfs(0);\n // bug(ans)\n  for(int i=1;i<=n;i++) {\n    for (int j = 1; j < m; j++) {\n      if (2 * i < j)break;\n      if(2*i-j<=i)\n      f[i][j] = c[i][2 * i - j];\n    }\n    if((m&1)&&2*i>m)f[i][2*i]=1;\n    for (int j = 1; j + j <i&&(j+j<m-1);j++) {\n      if(m-1+2*j!=2*i)\n      pd(f[i][m-1+2*j],f[i-j-j][m-1-2*j]);\n    }\n  }\n  //bug(f[1][2])\n  ll ret = 1;\n  for(int i=1;i<=n;i++){\n    ll sum = 0;\n    for(int j=1;j<=i+i;j++)pd(sum, f[i][j]);\n    pd(ret, sum*c[n][i]%mod);\n  }\n  cout<<ret%mod<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b>>1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nvector<mint> frac, ifrac;\nvoid finit(ll X) {\n\tfrac.assign(X + 1, 1);\n\tifrac.assign(X + 1, 1);\n\n\trepn(i, X) {\n\t\tfrac[i] = frac[i - 1] * i;\n\t\tifrac[i] = ifrac[i - 1] / i;\n\t}\n\n}\n\nmint com(ll n, ll m) {\n\tif (n < 0 || m < 0 || n < m) { return 0; }\n\treturn frac[n] * ifrac[m] * ifrac[n - m];\n}\n\nint main() {\n\tll N, X;\n\tcin >> N >> X;\n\n\tmint ans = 0;\n\tfinit(N);\n\n\trep(i, N + 1) {\n\t\trep(j, N+1) {\n\t\t\tif (i + j > N) { continue; }\n\n\t\t\tvll c(3);\n\t\t\tc[0] = i;\n\t\t\tc[1] = j;\n\t\t\tc[2] = N - i - j;\n\n\t\t\tll S = c[1] + 2 * c[2];\n\t\t\tmint t = 0;\n\n\t\t\tif (S < X) {\n\t\t\t\tt += com(c[1] + c[2], c[1]) * com(N, c[0]);\n\t\t\t}\n\n\t\t\telse if((S-X)%2==1) {\n\t\t\t\tif (j == 0) { t += com(N, c[0]); }\n\t\t\t\telse {\n\t\t\t\t\tll K = (S - X + 1) / 2;\n\n\t\t\t\t\tt += com(c[1] + c[2] - 2 * K, c[1]) * com(N, c[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans += t;\n\t\t\t//cout << i << \" \" << j << \" \" << c[2] << \" \" << t << endl;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 6000, mod = 998244353;\nint fac[N+10],ifac[N+10];\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tFor(i,1,n) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n]=power(fac[n],mod-2);\n\tDow(i,n-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,f[N][N],g[N][N],cnt[N],s[N];\n\nint main(){\n\tn=read(),m=read(),init(N);\n\tf[0][0]=1;\n\tFor(i,0,m) g[i][0]=1;\n\tFor(i,1,m)\n\t\tFor(j,1,n) f[i][j]=Mod(f[i-1][j-1]+f[i-2][j-1]),g[i][j]=Mod(g[i-1][j]+f[i][j]);\n\tint ans=0;\n\tfor (int i=0,k=2;i<=m-2;i+=2,k++){//强制选 i 和 i+1\n\t\tFor(j,0,m-1-(i+1)) cnt[k+j]=Mod(cnt[k+j]+g[m-1-(i+1)][j]);\n\t\tFor(j,0,m-1-(i+1)) if (f[m-1-(i+1)][j]){\n\t\t\tint l=k+j;\n\t\t\t//For(p,1,k-2) cnt[l+p]=Mod(cnt[l+p]+f[m-1-(i+1)][j]);\n\t\t\ts[l+1]=Mod(s[l+1]+f[m-1-(i+1)][j]);\n\t\t\ts[l+(k-1)]=Mod(s[l+(k-1)]+mod-f[m-1-(i+1)][j]);\n\t\t}\n\t}\n\tFor(i,1,n+1) s[i]=Mod(s[i]+s[i-1]),cnt[i]=Mod(cnt[i]+s[i]);\n\tif (m&1){\n\t\tFor(k,1,n+1) cnt[k]=Mod(cnt[k]+1);\n\t} else {\n\t\tFor(i,1,m/2) cnt[i]=Mod(cnt[i]+1);\n\t}\n\tFor(i,1,n+1) if (cnt[i]) ans=(ans+1ll*cnt[i]*C(n,i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(int x){write(x);putchar('\\n');}\nconst int MAXN=3005;\nconst int mod=998244353;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nint f[MAXN][MAXN*2],C[MAXN][MAXN];\nvoid init()\n{\n\tfor(int i=0;i<MAXN;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<MAXN;i++)\n\t\tfor(int j=0;j<=2*i;j++)\n\t\t{\n\t\t\tif(j-1>=0)ad(f[i][j],f[i-1][j-1]);\n\t\t\tif(j-2>=0)ad(f[i][j],f[i-1][j-2]);\n\t\t}\n}\nint n,X;\nint main()\n{\n\tinit();\n\tn=read();X=read();\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint sum=0;\n\t\tfor(int j=1;j<X;j++)ad(sum,f[i][j]);\n\t\tfor(int j=X+1;j<=2*i;j+=2)if(j>=i)\n\t\t{\n\t\t\tint a=(j-X+1)/2;\n\t\t\tif(2*a<X-1&&i-2*a>=1)ad(sum,f[i-2*a][X-2*a-1]);\n\t\t\telse if(X&1&&2*a>=i&&j==i*2)ad(sum,1);\n\t\t}\n\t\tad(ans,1LL*sum*C[n][i]%mod);\n\t}\n\tpr2(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, vector<vector<int>>& scc, stack<int>& S, vector<int>& inS, vector<int>& low,vector<int>& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(vector<int>());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph& g, vector<vector<int>>& scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tvector<int> num(n), low(n);\n\tstack<int> S;\n\tvector<int> inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n);\n\t\tinv[n - 1] = mod_inv(fact[n - 1]);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\n\nll dp[3030][6060];\nll dp2[3030][6060];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tconstexpr ll mod = 998244353;\n\tll n, x;\n\tcin >> n >> x;\n\tdp[0][0] = 1;\n\tREP(i, n)REP(j, x) {\n\t\tREP(k, 3)(dp[i + 1][j + k] += dp[i][j]) %= mod;\n\t}\n\tdp2[0][0] = 1;\n\tREP(i, n)REP(j, x+1) {\n\t\tREP(k, 2)(dp2[i + 1][j + 1 + k] += dp2[i][j]) %= mod;\n\t}\n\n\tll ans = 0;\n\tREP(i, x)(ans += dp[n][i]) %= mod;\n\tCombination comb(n, mod);\n\tif (x % 2 == 1) {\n\t\trep(i, x - 1, n + 1) {\n\t\t\tif (i == 0)continue;\n\t\t\tll tmp = n - i;\n\t\t\t(ans += comb.nCr(n, tmp)) %= mod;\n\t\t}\n\t}\n\n\tfor (int i = x + 1; i - (x - 1) < x -1; i += 2) {\n\t\tll l = i - (x-1);\n\t\tll d = x - 1 - l;\n\t\tll num = l;\n\t\tREP(j, n + 1) {\n\t\t\tif (j + num > n)continue;\n\t\t\tll tmp = j + num;\n\t\t\t(ans += comb.nCr(n, tmp) * dp2[j][d] % mod) %= mod;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fio ios_base::sync_with_stdio(false)\n#define pdl cout << \"*\" << endl\n#define MOD 1000000007\n#define INF 1000000000\n#define INFLL 1000000000000000000ll\n#define ff first\n#define ss second\n#define long int64_t\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nuniform_int_distribution<> dis(0, INF<<1);\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1> void __f(const char* name, Arg1&& arg1){ cerr << name << \" : \" << arg1 << endl; }\ntemplate <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args)\n{ const char* comma = strchr(names + 1, ','); cerr.write(names, comma - names) << \" : \" << arg1 << \" | \"; __f(comma+1, args...); }\n\nconst int N = 3001;\nconst int mod = 998244353;\n\nint c[N][N], ps[N+1], mul[N][N], dp[2][N][N << 1];\n\nint main()\n{\n\tfio;\n\tfor(int i=0; i<N; i++)\n\t\tc[i][0] = 1;\n\tfor(int i=1; i<N; i++)\n\t\tfor(int j=1; j<N; j++)\n\t\t\tc[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod;\n\tint n, k;\n\tcin >> n >> k;\n\tfor(int i=n; i>=0; i--)\n\t\tps[i] = (ps[i+1] + c[n][i]) % mod;\n\tfor(int l=1; l<=n; l++)\n\t{\n\t\tmul[l][0] = c[n][l];\n\t\tfor(int y=1; l+y<=n; y++)\n\t\t{\n\t\t\tmul[l][y] = (mul[l][y-1] + ps[l+y] + 0ll + ps[l+y]) % mod;\n\t\t\tif(l + (y << 1) < n)\n\t\t\t\tmul[l][y] = ((mul[l][y] - ps[l + (y << 1)] - ps[l + (y << 1) + 1]) % mod + mod) % mod;\n\t\t\telse if(l + (y << 1) == n)\n\t\t\t\tmul[l][y] = (mul[l][y] - c[n][n] + mod) % mod;\n\t\t}\n\t\tfor(int y=n-l+1; y<=n; y++)\n\t\t\tmul[l][y] = mul[l][y-1];\n\t}\n\tdp[0][1][1] = 1;\n\tfor(int l=2; l<=n; l++)\n\t\tfor(int x=2; x<=k; x++)\n\t\t\tfor(int i=0; i<2; i++)\n\t\t\t\tdp[i][l][x] = (dp[0][l-1][x-1-i] + dp[1][l-1][x-1-i]) % mod;\n\tint ans = 1;\n\tfor(int l=1; l<=n; l++)\n\t\tfor(int x=1; x<=k; x++)\n\t\t\tif((x & 1) != (k & 1))\n\t\t\t\tans = (ans + dp[0][l][x] * 1ll * mul[l][k-x-1 >> 1]) % mod;\n\tmemset(dp, 0, sizeof dp);\n\tdp[0][0][0] = dp[0][1][1] = dp[0][1][2] = 1;\n\tfor(int l=2; l<=n; l++)\n\t\tfor(int x=2; x<k; x++)\n\t\t\tdp[0][l][x] = (dp[0][l-1][x-1] + dp[0][l-1][x-2]) % mod;\n\tfor(int l=1; l<=n; l++)\n\t\tfor(int x=1; x<k; x++)\n\t\t\tif((x & 1) == (k & 1))\n\t\t\t\tans = (ans + dp[0][l][x] * 1ll * c[n][l]) % mod;\n\tif(k & 1)\n\t{\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tans = (ans + c[n][i]) % mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;\n\tchar ch;\n\tdo\n\t{\n\t\tch=getchar();\n\t\tif (ch=='-')\n\t\t{\n\t\t\tf=-f;\n\t\t}\n\t}while (ch<'0' || ch>'9');\n\tdo\n\t{\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}while (ch>='0' && ch<='9');\n\treturn x*f;\n}\n#define ll long long\nconst int maxn=6010;\nconst ll Mod=998244353;\nint n,k;\nll f[maxn][maxn],inv[maxn],fac[maxn];\nvoid upd(ll &x,ll v)\n{\n\tx=(x+v)%Mod;\n}\nll c(int n,int m)\n{\n\tif (m<0 || m>n)\n\t{\n\t\treturn 0;\n\t}\n\treturn fac[n]*inv[m]%Mod*inv[n-m]%Mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfac[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfac[i]=fac[i-1]*i%Mod;\n\t}\n\tinv[0]=inv[1]=1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tinv[i]=(Mod-Mod/i)*inv[Mod%i]%Mod;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinv[i]=inv[i]*inv[i-1]%Mod;\n\t}\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=i;j<=i*2;j++)\n\t\t{\n\t\t\tupd(f[i][j],f[i-1][j-1]);\n\t\t\tif (j>1)\n\t\t\t{\n\t\t\t\tupd(f[i][j],f[i-1][j-2]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor (int i=0;i<=n;i++)\n\t{\n\t\tll now=0;\n\t\tfor (int j=0;j<k-1;j++)\n\t\t{\n\t\t\tupd(now,f[i][j]);\n\t\t}\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tif (i-j<=j && k-1-(i-j)*2>=0)\n\t\t\t{\n\t\t\t\tupd(now,f[j-(i-j)][k-1-(i-j)*2]);\n\t\t\t}\n\t\t\telse if (i-j>j && j*2==k-1)\n\t\t\t{\n\t\t\t\tupd(now,1);\n\t\t\t}\n\t\t}\n\t\tupd(ans,now*c(n,i));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n#include <cassert>\n#include <numeric>\nusing namespace std;\nusing lint = long long;\nconst lint mod = 998244353;\n#define all(x) (x).begin(), (x).end()\n#define bitcount(n) __builtin_popcountl((lint)(n))\n#define fcout cout << fixed << setprecision(15)\n#define highest(x) (63 - __builtin_clzl(x))\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T = string, class U = char>int character_count(T text, U character){ int ans = 0; for(U i: text){ ans += (i == character); } return ans; }\nlint power(lint base, lint exponent, lint module){ if(exponent % 2){ return power(base, exponent - 1, module) * base % module; }else if(exponent){ lint root_ans = power(base, exponent / 2, module); return root_ans * root_ans % module; }else{ return 1; }}\nstruct position{ int y, x; }; position mv[4] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // double euclidean(position first, position second){ return sqrt((second.x - first.x) * (second.x - first.x) + (second.y - first.y) * (second.y - first.y)); }\ntemplate<class T, class U> string to_string(pair<T, U> x){ return to_string(x.first) + \",\" + to_string(x.second); } string to_string(string x){ return x; }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++) ans += to_string(*i) + \" \"; if(!ans.empty()) ans.pop_back(); cout << ans << endl; }\ntemplate<class itr> void cins(itr first, itr last){ for(auto i = first; i != last; i++){ cin >> (*i); } }\ntemplate<class T> T gcd(T a, T b){ if(a && b){ return gcd(min(a, b), max(a, b) % min(a, b)); }else{ return a; }} template<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\nstruct combination{ vector<lint> fact, inv; combination(int sz) : fact(sz + 1), inv(sz + 1){ fact[0] = 1; for(int i = 1; i <= sz; i++){ fact[i] = fact[i - 1] * i % mod; } inv[sz] = power(fact[sz], mod - 2, mod); for(int i = sz - 1; i >= 0; i--){ inv[i] = inv[i + 1] * (i + 1) % mod; } } lint C(int p, int q) const{ if(q < 0 || p < q) return 0; return (fact[p] * inv[q] % mod * inv[p - q] % mod); } };\ntemplate<class itr> bool next_sequence(itr first, itr last, int max_bound){ itr now = last; while(now != first){ now--; (*now)++; if((*now) == max_bound){ (*now) = 0; }else{ return true; } } return false; }\n\ncombination table(100000);\n\nlint dp[3030][6060];\n\nlint patterns(int cnt, int sum){\n    if(sum <= 0){\n        return !sum && !cnt;\n    }else if(cnt == 0){\n        return 0;\n    }else if(dp[cnt][sum] != -1){\n        return dp[cnt][sum];\n    }else{\n        return dp[cnt][sum] = (patterns(cnt - 1, sum - 1) + patterns(cnt - 1, sum - 2)) % mod;\n    }\n}\n\nlint dp2[3030][6060];\n\nlint patterns_colorful(int cnt, int sum){\n    if(sum < 0){\n        return 0;\n    }else if(cnt == 0){\n        return !sum;\n    }else if(dp2[cnt][sum] != -1){\n        return dp2[cnt][sum];\n    }else{\n        return dp2[cnt][sum] = (patterns_colorful(cnt - 1, sum) + patterns_colorful(cnt - 1, sum - 1) + patterns_colorful(cnt - 1, sum - 2)) % mod;\n    }\n}\n\nint main(){\n    int N, X;\n    cin >> N >> X;\n    lint ans = 0;\n    memset(dp, -1, sizeof(dp));\n    memset(dp2, -1, sizeof(dp2));\n    for(int i = 0; i < X; i++){\n        ans = (ans + patterns_colorful(N, i)) % mod;\n    }\n    for(int i = X + 1; i < 2 * X - 2; i++){\n        if((i - X + 1) % 2 == 1){\n            continue;\n        }\n        int remaining = N - (i - X + 1);\n        if(remaining < 0){\n            continue;\n        }\n        for(int j = 0; j <= remaining; j++){\n            ans = (ans + patterns(j, 2 * X - 2 - i) * table.C(N, remaining - j) % mod) % mod;\n        }\n    }\n    if(X % 2 == 1){\n        for(int i = max(X + 1, 2 * X - 2); i <= 2 * N; i++){\n            if(i % 2 == 1){\n                continue;\n            }\n            ans = (ans + table.C(N, i / 2)) % mod;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=998244353;\n\nint N;\nint X;\nLL conv[6145];\nLL memo[6145][6145];\nLL num[6145][6145];\nLL num2[6145][6145];\n\nLL Comb(int n, int r) {\n  if (n < 0 || r < 0 || n < r) return 0;\n  if (n == r || r == 0) return 1;\n  if (memo[n][r] != -1) return memo[n][r];\n  return memo[n][r] = (Comb(n-1, r) + Comb(n-1, r-1)) % MOD;\n}\n\nLL f(int s, int t) {\n  return Comb(s+t, t);\n}\n\nLL Conv(int l, int r) {\n  assert(l <= r);\n  LL ret = conv[r];\n  if (l > 0) ret += MOD-conv[l-1];\n  return ret%MOD;\n}\n\nint main() {\n  fill(memo[0], memo[6145], -1);\n  scanf(\"%d%d\", &N, &X);\n\n  rep(i, N+1) {\n    conv[i] = f(N-i, i);\n    if (i > 0) conv[i] = (conv[i-1]+conv[i]) % MOD;\n  }\n\n  num[0][0] = 1;\n  num2[0][0] = 1;\n  reps(k, 1, N+1) {\n    rep(S, X+1) {\n      if (S >= 2) num[k][S] += num[k-1][S-2];\n      if (S >= 1) num[k][S] += num[k-1][S-1];\n      if (S >= 2) num2[k][S] += num2[k-1][S-2];\n      if (S >= 1) num2[k][S] += num2[k-1][S-1];\n      num[k][S] += num[k-1][S];\n      num[k][S] %= MOD;\n      num2[k][S] %= MOD;\n    }\n  }\n\n  LL ans = 0;\n  rep(k, N+1) {\n    if (X%2 == 1 && k*2 > X) {\n      ans += f(k, N-k);\n      ans %= MOD;\n    }\n  }\n\n  rep(S, X) {\n    ans += num[N][S];\n    ans %= MOD;\n  } \n\n  reps(k, 1, N+1) {\n    int d = X-2-2*k;\n    if (d >= 0) {\n      rep(g, N+1) {\n        int r = N-(k+g+2);\n        int l = max(N-(2*k+g+1), 0);\n        if (r < 0) continue;\n\n        ans += num2[g][d] * Conv(l, r);\n        ans %= MOD;\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<ll,ll> P;\n#define M 998244353\n#define F first\n#define S second\n#define PB push_back\n#define INF 100000000000000000\nll ka[10000],in[10000];\nll pw(ll x,ll y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)res=res*x%M;\n\t\ty>>=1;\n\t\tx=x*x%M;\n\t}\n\treturn res;\n}\nll cm(ll x,ll y){\n\treturn ka[x]*in[x-y]%M*in[y]%M;\n}\nll n,x,ans;\nint main(void){\n    cin>>n>>x;\n    ka[0]=1,in[0]=1;\n    for(ll i=1;i<=n;i++){\n\t\tka[i]=ka[i-1]*i%M;\n\t\tin[i]=pw(ka[i],M-2);\n\t}\n    for(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j+i<=n;j++){\n\t\t\tll s=i+j*2,a=(s-x+1)/2;\n\t\t\tif(i==0&&(s<x||x%2))ans=(ans+cm(n,j))%M;\n\t\t\telse if(s<x)ans=(ans+cm(n,i)*cm(n-i,j)%M)%M;\n\t\t\telse if(s%2!=x%2&&j>=a*2)ans=(ans+cm(i+j-a*2,i)*cm(n,i+j)%M)%M;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N, X;\nll con[6010][6010];\nll mod = 998244353;\nll ans;\n\nint main()\n{\n    cin >> N >> X;\n\n    for(int i = 0; i < 6010; i++)for(int j = 0; j <= i; j++)\n    {\n        if(i == j)con[i][j] = 1;\n        else if(j == 0)con[i][j] = 1;\n        else con[i][j] = (con[i - 1][j] + con[i - 1][j - 1]) % mod;\n    }\n\n    for(int i = 0; i <= N; i++)\n    {\n        ll tmp = 0;\n        for(int j = 0; j <= i; j++)\n        {\n            if(2 * j < X - 1)continue;\n            int t = (X - 1) - j;\n            if(j - t != 0 && t < i - j)continue;\n            tmp += con[max(0, j - (i - j))][max(0, t - (i - j))] * con[N][i];\n            tmp %= mod;\n        }\n        ans += tmp;\n        ans %= mod;\n    }\n\n    for(int i = 0; i <= N; i++)\n    {\n        ll tmp = 0;\n        for(int j = 0; j <= i; j++)\n        {\n            if(i - j + j * 2 < X - 1)\n            {\n                tmp += con[N][i] * con[i][j] % mod;\n                tmp %= mod;\n            }\n        }\n        ans += tmp;\n        ans %= mod;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100,mod=998244353;\ninline void Add(int &a,int b){a=a+b>=mod?a+b-mod:a+b;}\ninline int ksm(int a,int b)\n{\n\tint res=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) res=1ll*res*a%mod;\n\treturn res;\n}\nint fac[maxn],invfac[maxn];\ninline int C(int n,int m){return (n<0||n<m)?0:(1ll*fac[n]*invfac[m]%mod*invfac[n-m]%mod);}\nint n,x,ans=0;\nint main()\n{\n\tfor(int i=fac[0]=1;i<maxn;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinvfac[maxn-1]=ksm(fac[maxn-1],mod-2);\n\tfor(int i=maxn-2;i>=0;i--) invfac[i]=1ll*invfac[i+1]*(i+1)%mod;\n\tcin>>n>>x;\n\tfor(int cnt0=0;cnt0<=n;cnt0++)\n\t{\n\t\tint sum=0,N=n-cnt0;\n\t\tif(2*N<x||x%2==1) sum=1;\n\t\tfor(int i=N;i<2*N;i++)\n\t\t{\n\t\t\tif(i<x) {Add(sum,C(N,i-N));continue;}\n\t\t\tif((i-x)%2==0) continue;int cnt=(i-x+1)/2;\n\t\t\tif(2*cnt>=N) continue;int va=N-2*cnt,vb=i-4*cnt;\n\t\t\tif(vb<va||vb>2*va) continue;Add(sum,C(va,vb-va));\n\t\t}\n\t\tAdd(ans,1ll*sum*C(n,cnt0)%mod);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 998244353;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 6e3 + 5;\nmi fact[MAX], ifact[MAX], len[MAX], dp[MAX][MAX], ones[MAX][MAX], twos[MAX][MAX], twos_total[MAX][MAX], rest[MAX][MAX], rest_total[MAX][MAX], po[MAX], prefix[MAX], up_prefix[MAX];\nmi choose(int a, int b){\n    if(b < 0 || a < b) return 0;\n    return fact[a] * ifact[b] * ifact[a - b];\n}\nmi sum_prefix(int l, int r){ return prefix[r] - (l == 0 ? 0 : prefix[l - 1]); }\nmi sum_up_prefix(int l, int r){ return up_prefix[r] - (l == 0 ? 0 : up_prefix[l - 1]); }\nmi progression(int l, int r, int st, int d){ return (sum_up_prefix(l, r) - sum_prefix(l, r) * l) * d + sum_prefix(l, r) * st; }\nint n, x;\nint main(){\n    fact[0] = 1; ifact[0] = 1; po[0] = 1;\n    for(int i = 1; i < MAX; i++) fact[i] = fact[i - 1] * i, ifact[i] = ifact[i - 1] / i, po[i] = po[i - 1] * 2;\n    ios_base :: sync_with_stdio(0); cin.tie(0);\n    cin >> n >> x;\n    prefix[0] = 1;\n    for(int i = 1; i <= n; i++) prefix[i] = prefix[i - 1] + choose(n, i), up_prefix[i] = up_prefix[i - 1] + choose(n, i) * i;\n    mi ans = 0;\n    if(x % 2 == 0) for(int i = 0; i < x / 2; i++) ans += choose(n, i);\n    else ans += po[n];\n    dp[0][0] = 1;\n    for(int i = 0; i <= n; i++) for(int j = 0; j < x; j++) dp[i + 1][j + 2] += dp[i][j], dp[i + 1][j + 1] += dp[i][j];\n    for(int i = 0; i <= n; i++) for(int j = 0; j < x; j++) ones[i + 2][j + 2] = dp[i][j];\n    ones[1][1] += 1;\n    for(int i = 0; i <= n; i++) for(int j = 0; j + i <= n; j++) twos[max(i, j)][i + j] += 1;\n    for(int j = 0; j <= n; j++) for(int i = 1; i <= max(n, x); i++) twos[i][j] += twos[i - 1][j];\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < n; j++){\n            if(j <= i) rest[i][j] = progression(0, j, j + 1, -1);\n            else rest[i][j] = progression(j - i, j, i + 1, -1) + progression(max(0, j - 2 * i), j - (i + 1), max(1, 2 * i + 1 - j), 1);\n        }\n    }\n    for(int j = 0; j < n; j++){\n        rest_total[0][j]  += choose(n, j);\n        for(int i = 1; i <= n; i++){\n            if(i > j) rest_total[i][j] = rest_total[i - 1][j];\n            else rest_total[i][j] = rest_total[i - 1][j] + choose(n, j - i) * (i + 1);\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            if(ones[i][j] == 0) continue;\n            int mx = min((x - j - 1) / 2, n - 1);\n            if(j % 2 == x % 2) ans += ones[i][j] * rest_total[mx][n - i];\n            else ans += ones[i][j] * rest[mx][n - i];\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD_CONST = 998244353;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\ntemplate <int size, long long param = MOD_CONST, bool preserve = false>\nclass CombinationTool {\n  vector<mint<param>> invs;\n\n public:\n  vector<mint<param>> kaijo;\n  vector<vector<mint<param>>> table;\n\n  constexpr CombinationTool() {\n    const int N = size;\n    if (preserve) {\n      table.resize(N + 5);\n      for (int i = 0; i < N + 5; i++) table[i].resize(i + 1);\n      for (int i = 0; i < N; i++) {\n        table[i][0] = 1;\n        table[i][i] = 1;\n      }\n      for (int i = 1; i < N + 5; i++)\n        for (int j = 1; j < i; j++)\n          table[i][j] = table[i - 1][j - 1] + table[i - 1][j];\n\n    } else {\n      kaijo.resize(N + 5);\n      kaijo[0] = 1;\n      for (int i = 1; i < N + 5; i++) {\n        kaijo[i] = kaijo[i - 1] * i;\n        invs[i] = mint<param>(1) / kaijo[i];\n      }\n    }\n  }\n\n  mint<param> get(int n, int m) {\n    if (m < 0 || m > n) return mint<param>(0);\n    if (preserve) return table[n][m];\n    return kaijo[n] * invs[m] * invs[n - m];\n  }\n};\n\nmint<> dp[6005][3005];\nvoid solve(long long N, long long X) {\n  CombinationTool<3050, MOD_CONST, false> comb;\n\n  mint<> zero = 0;\n  // auto dp = exvector(zero, 2 * N + 5, N + 5);\n  for (int j = 0; j <= N + 1; j++) dp[0][j] = 0;\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<MOD_CONST, 1> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb.get(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb.get(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb.get(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(100), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nconst Int MOD = 998244353;\nconst Int MAX = 10000;\nInt fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nInt COM(int n, int k) {\n    if (n < k || n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nInt memo[3010][6010];\nInt f(int n, int sum) {\n    if (sum > 2 * n || sum < 0) return 0;\n    if (n == 0) return sum == 0;\n    if (memo[n][sum] != -1) return memo[n][sum];\n    Int ans = f(n - 1, sum) + f(n - 1, sum - 1) + f(n - 1, sum - 2);\n    ans %= MOD;\n    return memo[n][sum] = ans;\n}\nInt memo2[3010][3010];\nInt g(int k, int n, int m) {\n#if 0\n    if (n <= 0) return 0;\n    if (k == 0) return f(n, m);\n    if (memo2[k][n] != -1) return memo2[k][n];\n    Int ans = g(k - 1, n - 1, m) + g(k, n - 1, m);\n    ans %= MOD;\n    return memo2[k][n] = ans;\n#else\n    Int ans = 0;\n    for (int a = 1; a <= n - k; a++) {\n        ans += COM(n - a - 1, k - 1) * f(a, m);\n        ans %= MOD;\n    }\n    return ans;\n#endif\n}\nint main() {\n    COMinit();\n    memset(memo, -1, sizeof(memo));\n    int N, X; cin >> N >> X;\n    Int ans = 0;\n    for (int t = 0; t <= N * 2; t++) {\n        if (t < X) {\n            ans += f(N, t);\n            ans %= MOD;\n        } else if (t == X) {\n            // zero\n        } else {\n            if (t % 2 == 0 && X % 2 == 1) {\n                int k = (t - X + 1) / 2;\n                int m = t - k * 4;\n                if (m <= 0) {\n                    ans += COM(N, t / 2);\n                } else {\n                    ans += g(k * 2, N, m);\n                }\n                ans %= MOD;\n            }\n            if (t % 2 == 1 && X % 2 == 0) {\n                int k = (t - X + 1) / 2;\n                int m = t - k * 4;\n                if (m > 0) {\n                    ans += g(k * 2, N, m);\n                }\n                ans %= MOD;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x)\n{\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int mod=998244353,N=3010;\nvoid Add(int &x,int y) { x=(x+y)%mod; }\nint Pow(int x,int y) {\n\tint res=1;\n\twhile(y) {\n\t\tif(y&1) res=res*(ll)x%mod;\n\t\tx=x*(ll)x%mod,y>>=1;\n\t}\n\treturn res;\n}\nint fac[N],inv[N];\nint C(int n,int m) {\n\tif(n<m) return 0;\n\treturn fac[n]*(ll)inv[m]%mod*inv[n-m]%mod;\n}\nvoid get_fac(int n) {\n\tfac[0]=1; for(int i=1;i<=n;++i) fac[i]=fac[i-1]*(ll)i%mod;\n\tinv[n]=Pow(fac[n],mod-2); for(int i=n;i>=1;--i) inv[i-1]=inv[i]*(ll)i%mod;\n}\nint cal1(int m,int n) { // m¸öÎ»ÖÃ ÓÃ 1,2 ´Õ n \n\tif(m>n) return 0;\n\treturn C(m,n-m);\n}\nint solve(int n,int X) { // n ¸öÎ»ÖÃ  ²»³öÏÖ x\n\tint ans=0;\n\tfor(int i=0;i<X;++i) Add(ans,cal1(n,i));\n\tif(2*n<X) return ans;\n\t\n\tfor(int i=1;i*2<=X-1;++i) {\n\t\tAdd(ans,cal1(n-i*2,X-1-2*i));\n\t}\n\tif(X%2==1&&X-1<n) Add(ans,1);\n\treturn ans;\n}\nint main() {\n\tint n,X; rd(n),rd(X);\n\tget_fac(n);\n\tint ans=0;\n\tfor(int i=0;i<=n;++i) {\n//\t\tcout<<solve(i,X)<<endl;\n\t\tAdd(ans,C(n,i)*(ll)solve(i,X)%mod);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nconst int MAX = 510000;\nconst int mod = 998244353;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\nll dp[3001][6002];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n    \n\n    int n,x;\n    cin>>n>>x;\n    COMinit();\n    ll ans = 0;\n    ll c[x]={};\n    for(int i=0;i<x;i++){\n        for(int j=0;j*2<=i;j++){\n            c[i] += (COM(n,j) * COM(n-j,i-2*j))%mod;\n            c[i] %= mod;\n        }\n        ans += c[i];\n        ans %= mod;\n    }\n    dp[0][0]=1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<x;j++){\n            for(int k=0;k<3;k++){\n                dp[i+1][j+k] += dp[i][j];\n                dp[i+1][j+k] %= mod;\n            }\n        }\n    }\n    寝る。ここTLEするかも？ミスってるとしたらここか、考察漏れ\n    for(int i=0;i<n;i++){\n        for(int j=1;j+1<=i && j*2+1<x;j++){\n            for(int k=0;k<=i-j-1 && 2*j+1+2*(i-k-j-1)>=x-1;k++){\n                ans += (COM(k+j,j)*dp[i-k-j-1][x-2-2*j])%mod;\n                ans %= mod;\n            }\n        }\n    }\n    if(x%2){\n        ll t = (x+1)/2;\n        for(int i=(x+1)/2;i<=n;i++){\n            ans += COM(n,i);\n            ans %= mod;\n        }\n    }\n    cout << ans << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint n, x;\nllint dp[3005][6005];\nllint cnt[3005];\n\nconst int FACT_MAX = 3005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> x;\n\tmake_fact();\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j <= 2*n; j++){\n\t\t\tfor(int k = 1; k <= 2; k++){\n\t\t\t\tif(j+k <= 2*n){\n\t\t\t\t\tdp[i+1][j+k] += dp[i][j];\n\t\t\t\t\tdp[i+1][j+k] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tcnt[i] += dp[i][j], cnt[i] %= mod;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(2*j-i <= 0) continue;\n\t\t\tif((x-1)-2*(i-j) <= 0) continue;\n\t\t\tif((x-1)-2*(i-j) >= 2*(2*j-i)) continue;\n\t\t\tcnt[i] += dp[2*j-i][(x-1)-2*(i-j)];\n\t\t\tcnt[i] %= mod;\n\t\t}\n\t\tif(x % 2 && 2*i > x) cnt[i]++, cnt[i] %= mod;\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= n; i++){\n\t\tans += cnt[i] * comb(n, i) % mod;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << x.v;\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\n\nvector<vector<LL>> comb_table;\n\n\nLL comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return comb_table[N][K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+6);\n  for(int i=0; i<=N; i++) {\n    comb_table[i].resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<i; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n      comb_table[i][j] %= MOD;\n    }\n  }\n  \n}\n\n\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(0LL, 2*N+5, N+5);\n  \n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n      dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  LL ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1) % MOD;\n\n  }\n  ans %= MOD;\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2) % MOD;\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n\n    }\n  }\n  ans %= MOD;\n\n  cout << ans << endl;\n\n  \n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  // mint(long long);\n  inline mint(long long v)\n      : v(fast == 0 ? (v < 0 ? (v % MODS[kind] + MODS[kind]) % MODS[kind]\n                             : (v >= MODS[kind] ? v % MODS[kind] : v))\n                    : (v)) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n  void take_mod() { v %= MODS[kind]; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  /*\n  if (fast == 1) {\n    a.v += b.v;\n    return a;\n  }\n  */\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n// vector<vector<mint<>>> comb_table;\nmint<> comb_table[3050][3050];\n\nmint<> comb(LL N, LL K) {\n  if (N < K) return 0;\n  if (K < 0) return 0;\n  return comb_table[N][K];\n}\n\nvoid init(int N) {\n  //  comb_table.resize(N + 6);\n  for (int i = 0; i <= N; i++) {\n    //    comb_table[i].resize(i + 1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for (int j = 1; j < i; j++) {\n      comb_table[i][j] = comb_table[i - 1][j - 1] + comb_table[i - 1][j];\n    }\n  }\n}\n\nmint<> dp[6005][3005];\nvoid solve(long long N, long long X) {\n  init(N);\n  mint<> zero = 0;\n  // auto dp = exvector(zero, 2 * N + 5, N + 5);\n  for (int j = 0; j <= N + 1; j++) dp[0][j] = 0;\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<0, 1> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nconst ll MOD = 998244353;\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\n\nvector<ll> fact;\nvector<ll> inv_fact;\n\nvoid comb_init(int n) {\n\tfact.resize(n + 1);\n\tinv_fact.resize(n + 1);\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n}\n\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nll dp[3001][6001];\nll dp2[3001][6001];\nint main() {\n\tint N, X;\n\tcin >> N >> X;\n\tif (N == 1) {\n\t\tcout << 2 << endl;\n\t\treturn 0;\n\t}\n\tif (X == 1) {\n\t\tcout << mod_pow(2, N) << endl;\n\t\treturn 0;\n\t}\n\tif (X == 2) {\n\t\tcout << N + 1 << endl;\n\t\treturn 0;\n\t}\n\tcomb_init(N);\n\tdp[0][0] = 1;\n\tdp2[0][0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= 2 * i; j++) {\n\t\t\t(dp[i + 1][j] += dp[i][j]) %= MOD;\n\t\t\t(dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n\t\t\t(dp[i + 1][j + 2] += dp[i][j]) %= MOD;\n\t\t\t(dp2[i + 1][j + 1] += dp2[i][j]) %= MOD;\n\t\t\t(dp2[i + 1][j + 2] += dp2[i][j]) %= MOD;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= N - 2; i++) {\n\t\tll sum = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (j * 2 + 1 > X - 3) break;\n\t\t\tif (i + 2 + j <= N) (sum += comb(N, i + 2 + j)) %= MOD;\n\t\t\t(ans += dp2[i - j - 1][X - 3 - (j * 2 + 1)] * sum%MOD) %= MOD;\n\t\t}\n\t\tif (i * 2 == X - 3) {\n\t\t\tfor (int j = 0; j <= N - 2 - i; j++) (ans += comb(N, i + 2 + j)) %= MOD;\n\t\t}\n\t}\n\tfor (int i = 0; i < X; i++) (ans += dp[N][i]) %= MOD;\n\tcout << ans << endl;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mod 998244353\n#define mad(a,b) a=(a+b)%mod\n#define N 6010\nll dp[N][N];\nll fac[N],ivf[N],inv[N];\nll C(ll n,ll k){\n    return fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    fac[0]=ivf[0]=inv[1]=1;\n    for(int i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n    ll n,x; cin>>n>>x;\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)dp[i][j]=0;\n    dp[0][0]=1;\n    for(int i=0;i<n;i++)for(int j=0;j<x;j++){\n\tmad(dp[i+1][j+1],dp[i][j]);\n\tmad(dp[i+1][j+2],dp[i][j]);\n    }\n    ll ans=0;\n    for(int i=0;i<=n;i++)for(int j=0;j<x;j++){\n\tmad(ans,dp[i][j]*C(n,n-i));\n    }//cout<<ans<<endl;\n    for(int i=x;i<=n;i++){\n\tif(x%2==1)mad(ans,C(n,n-i));\n    }//cout<<ans<<endl;\n    for(int p=2;x-p-1>=0;p+=2){\n\tfor(int m=0;m+p<=n;m++){\n\t    mad(ans,dp[m][x-p-1]*C(n,m+p));\n\t}\n    }\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int mod = 998244353, N = (int)3e3 + 5, X = 2 * N;\nint n, x, dp[N][X], C[N << 1][N << 1], ans;\n\nint add(int _a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n    return _a;\n}\nint mul(int _a, int _b) { return (int)( (ll)_a * _b % mod); }\n\nint candyDivision(int _n, int _s) { return C[_n - 1][_s + _n - 1]; }\n\nint main() {\n    scanf(\"%d %d\", &n, &x);\n\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= (i << 1); ++j) if (dp[i][j]) {\n            dp[i + 1][j + 1] = add(dp[i + 1][j + 1], dp[i][j]);\n            dp[i + 1][j + 2] = add(dp[i + 1][j + 2], dp[i][j]);\n        }\n    }\n\n    for (int i = 0; i < (N << 1); ++i) C[0][i] = C[i][i] = 1;\n    for (int j = 1; j < (N << 1); ++j) {\n        for (int i = 1; i < j; ++i) C[i][j] = add(C[i - 1][j - 1], C[i][j - 1]);\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j < x; ++j) if (dp[i][j]) {\n            ans = add(ans, mul(dp[i][j], candyDivision(i + 1, n - i) ) );\n        }\n    }\n\n    for (int i = 1; ; ++i) {\n        int rem = x - 1 - 2 * i;\n        if (rem > 0) {\n            int n_2 = i << 1;\n            if (n_2 > n) break ;\n            for (int j = 0; j <= n - n_2; ++j) ans = add(ans, mul(dp[j][rem], candyDivision(n_2 + j + 1, n - n_2 - j) ) );\n        }\n        else {\n            if (!(x & 1) ) break ;\n            int n_2 = (x >> 1) + i;\n            if (n_2 > n) break ;\n            ans = add(ans, candyDivision(n_2 + 1, n - n_2) );\n        }\n    }\n\n    printf(\"%d\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int64_t _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int64_t _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int64_t MAX_N = 3002;\nconst int64_t ROOT = 15311432;\nconst int64_t ROOT_1 = 469870224;\nconst int64_t ROOT_PW = 1<<23;\nconst int64_t MOD = 998244353;\n\nint64_t n, x, rev[MAX_N*4], inv[MAX_N*4];\nint64_t pw2[MAX_N], C[MAX_N][MAX_N], f[MAX_N][MAX_N*2], g[MAX_N][MAX_N];\n\nvoid read_input() {\n    cin >> n >> x;\n}\n\nvoid NTT(vector<int64_t> &a, bool invert) {\n    int64_t n = a.size();\n\n    for (int64_t i=1; i<n; ++i) {\n        if (i<rev[i])\n            swap(a[i], a[rev[i]]);\n    }\n\n    for (int64_t len=2; len<=n; len <<= 1) {\n        int64_t wlen = invert ? ROOT_1 : ROOT;\n\n        for (int64_t i=len; i<ROOT_PW; i <<= 1)\n            wlen = 1LL * wlen * wlen % MOD;\n\n        for (int64_t i=0; i<n; i += len) {\n            int64_t w = 1;\n            for (int64_t j=0; j<len/2; ++j) {\n                int64_t u = a[i+j], v = 1LL * a[i+j+len/2] * w % MOD;\n                a[i+j] = (u + v < MOD ? u + v : u + v - MOD);\n                a[i+j+len/2] = (u - v >=0 ? u - v : u - v + MOD);\n                w = 1LL * w * wlen % MOD;\n            }\n        }\n    }\n\n    if (invert) {\n        for (int64_t i=0; i<n; ++i)\n            a[i] = 1LL * a[i] * inv[n] % MOD;\n    }\n}\n\nvoid square(vector<int64_t> &a) {\n    int64_t n = 1;\n    while (n < 2*a.size())\n        n <<= 1;\n    a.resize(n);\n    // PR0(a, a.size());\n\n    NTT(a, false);\n    // PR0(a, a.size());\n\n    for (int64_t i=0; i<n; ++i)\n        a[i] = 1LL * a[i] * a[i] % MOD;\n\n    NTT(a, true);\n}\n\nvoid init() {\n    int64_t tmp = 1;\n    while (tmp<(n+1)*2)\n        tmp <<= 1;\n\n    inv[1] = 1;\n    for (int64_t i=2; i<=tmp; ++i)\n       inv[i] = MOD - 1LL * inv[MOD%i] * (MOD / i) % MOD;\n\n    for (int64_t i=1, j=0; i<tmp; ++i) {\n        int64_t bit = tmp>>1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n        rev[i] = j;\n    }\n    // PR0(rev, tmp);\n\n    for (int64_t i=0; i<=n; ++i)\n        C[i][0] = C[i][i] = 1;\n\n    for (int64_t i=1; i<=n; ++i) {\n        for (int64_t j=1; j<i; ++j)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;\n    }\n\n    pw2[0] = 1;\n    for (int64_t i=1; i<=n; ++i)\n        pw2[i] = pw2[i-1] * 2 % MOD;\n\n    f[0][0] = 1;\n\n    for (int64_t l=1; l<=n; ++l) {\n        for (int64_t s=0; s<=x; ++s) {\n            f[l][s] = f[l-1][s];\n            if (s>=1)\n                f[l][s] = (f[l][s] + f[l-1][s-1]) % MOD;\n            if (s>=2)\n                f[l][s] = (f[l][s] + f[l-1][s-2]) % MOD;\n        }\n    }\n    // debug(f[n][2]);\n}\n\nint64_t case1() {\n    vector<int64_t> h;\n\n    for (int64_t t=0; t<=x/2; ++t) {\n        h.assign(n+1, 0);\n\n        for (int64_t l=0; l<=n; ++l) {\n            if (l<=t)\n                h[l] = pw2[l];\n            else\n                h[l] = (1LL * h[l-1] * 2 - C[l-1][t] + MOD) % MOD;\n        }\n\n        square(h);\n        // if (t==1)\n        //     PR0(h, n+1);\n\n        for (int64_t l=0; l<=n; ++l)\n            g[l][t] = h[l];\n    }\n    // debug(g[2][1]);\n\n    int64_t res = 0;\n\n    for (int64_t l=0; n-l-2>=0; ++l) {\n        for (int64_t s=(x+1)%2; s+2<=x; s += 2) {\n            // cerr << l << ' ' << s << ' ' << f[l][s] * g[n-l-2][(x-2-s)/2] << '\\n';\n            res = (res + 1LL * f[l][s] * g[n-l-2][(x-2-s)/2]) % MOD;\n        }\n    }\n\n    if (x%2==0)\n        res = (res + g[n-1][(x-1)/2]) % MOD;\n    else\n        res = (res + pw2[n]) % MOD;\n\n    return res;\n}\n\nint64_t case2() {\n    int64_t res = 0;\n\n    for (int64_t s=x%2; s<x; s += 2)\n        res = (res + f[n][s]) % MOD;\n\n    return res;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tread_input();\n\tinit();\n\tcout << (case1() + case2()) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long fact[110000];\nlong long finv[110000];\nlong long inv[110000];\nlong long dp[3100][6100];\nlong long C(int a,int b){\n\tif(b<0||a<b)return 0;\n\treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nint main(){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<110000;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<110000;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tdp[0][0]=1;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(!dp[i][j])continue;\n\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n\t\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n\t\t\tdp[i+1][j+2]=(dp[i+1][j+2]+dp[i][j])%mod;\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<b;i++)ret=(ret+dp[a][i])%mod;\n\tfor(int i=1;i<=a;i++){\n\t\tlong long ks=C(a,i);\n\t\tfor(int j=1;j*2<=a;j++){\n\t\t\tif(i+1>b||i*2-j*2+1<=b)continue;\n\t\t//\tprintf(\"%d %d: %lld\\n\",i,j,C(i-j*2,b-i-1));\n\t\t\tret=(ret+C(i-j*2,b-i-1)*ks)%mod;\n\t\t}\n\t\tif(i*2>b&&b%2==1){\n\t\t\tret=(ret+ks)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 6000\n\nconst LL mod=998244353;\nLL n,m,ans,fac[N],ifac[N];\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nLL C(LL x,LL y){\n\treturn x<y||y<0?0:fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=1; for (LL i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;\n\tifac[n]=inv(fac[n]); for (LL i=n-1;~i;--i) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tfor (LL i=0;i<=n;++i){\n\t\tLL tmp=0;\n\t\tfor (LL j=0;j<=m-1&&j<=i;++j)\n\t\t\tif (j*2>=m-1){\n\t\t\t\tLL k=i-j;\n\t\t\t\tif (i>=k){\n\t\t\t\t\tLL t=j-k,w=m-1-j-k;\n\t\t\t\t\tif (t<0){\n\t\t\t\t\t\tif (j*2==m-1) upd(tmp,1);\n\t\t\t\t\t}\n\t\t\t\t\telse upd(tmp,C(t,w));\n\t\t\t\t}\n\t\t\t}\n\t\tfor (LL j=0;j<m-1;++j) upd(tmp,C(i,j-i));\n\t\tupd(ans,tmp*C(n,i));\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 6555;\nconst int K = 700 ;\nint c[N][N], dp[N][N], a[N];\nint n, x, b[N], res;\nvoid gen(int m){\n    if (m == n + 1){\n        int q = 1;\n        for (int i = 1; q &&  i <= n; i++){\n            int s = 0;\n            for (int j = i;q &&  j <= n; j++){\n                s += b[j];\n                if (s == x) q = 0;\n            }\n        }\n        if (q == 1){\n            for (int i = 1; i <= n; i++) if (b[i] != 0) cout << b[i] << \" \";\n            cout << endl;\n        }\n        res += q;\n        return;\n    }\n    b[m] = 0;\n    gen(m + 1);\n    b[m] = 1;\n    gen(m + 1);\n    b[m] = 2;\n    gen(m + 1);\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> x;\n    gen(1);\n    c[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        c[i][0] = 1;\n        for (int j = 1; j <= i; j++){\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n        }\n    }\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n + n; j++){\n            dp[i][j] = dp[i - 1][j - 1];\n            if (j > 1) dp[i][j] = (dp[i][j] + dp[i - 1][j - 2]) % mod;\n        }\n    }\n    for (int i = 0; i <= n; i++){\n        for (int j = 0; j < x; j++) a[i] = (a[i] + dp[i][j]) % mod;\n        for (int j = 1; j <= i; j++){\n            int l = j + 1;\n            int r = i - j;\n            if (r < l) continue;\n            if (x - 1 - 2 * j >= 0 && (r - l + 1) * 2 != (x - 1 - 2 * j)) a[i] = (a[i] + dp[r - l + 1][x - 1 - 2 * j]) % mod;\n        }\n        if (i != 0 && 2 * i > x && x % 2 == 1) a[i] = (a[i] + 1) % mod;\n    }\n    int ans = 0;\n    for (int i = 0; i <= n; i++){;\n        ans = (ans + c[n][i] * a[i]) % mod;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 3005, P = 998244353;\n\nint n, X, C[N][N], f[N][N << 1];\n\nint main() {\n\tread(n), read(X);\n\tfor (int i = 0; i <= n; ++i) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tC[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n\t\t}\n\t}\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= 2 * i && j < X; ++j) {\n\t\t\tf[i][j] = (f[i - 1][j - 1] + (j > 1 ? f[i - 1][j - 2] : 0)) % P;\n\t\t}\n\t\tfor (int j = X + 1; j <= 2 * i; j += 2) {\n\t\t\tint c = (j - X + 1) / 2;\n\t\t\tif (i >= 2 * c && j >= 4 * c) {\n\t\t\t\tf[i][j] = f[i - 2 * c][j - 4 * c];\n\t\t\t} else if (2 * (i - 2 * c) == j - 4 * c) {\n\t\t\t\tf[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= 2 * i; ++j) {\n\t\t\tans = (ans + 1ll * C[n][i] * f[i][j]) % P;\n\t\t\t// debug(\"%d \", f[i][j]);\n\t\t}\n\t\t// debug(\"\\n\");\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = (a*b) % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = 1;\n    fact[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact[i] = fact[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = 1;\n    seq_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = 1;\n    fact_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint main(){\n    int N, X;\n    cin >> N >> X;\n    create_mod_tables(6010);\n\n    static int64_t dp[3001][3010], sub[3001][3010];\n    dp[0][0] = 1;\n    sub[0][0] = 1;\n    for(int i=0; i<N; i++) for(int j=0; j<=2*N; j++){\n        for(int k=0; k<=2; k++) add(dp[i+1][j+k], dp[i][j]);\n        for(int k=1; k<=2; k++) add(sub[i+1][j+k], sub[i][j]);\n    }\n    int64_t ans = 0;\n    for(int j=0; j<X; j++) add(ans, dp[N][j]);\n\n    for(int t=X+1; t<=2*N; t+=2){\n        int s = t+1-X;\n        if(X%2 == 0 && X <= s) break;\n        if(s <= X-1){\n            for(int d=0; d<=N; d++){\n                int64_t result = 1;\n                mul(result, sub[d][X-1-s]);\n                int stp = s/2 + d + (t - (X-1))/2;\n                if(stp > N) continue;\n                mul(result, comb_mod(N, stp));\n                add(ans, result);\n            }\n        }else{\n            add(ans, comb_mod(N, t/2));\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\n//int mod = 1000000007;\nint mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n\n    int nPr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, X; cin >> N >> X;\n    \n    mat dp(N + 1, vec(2 * N + 1, 0));\n    dp[0][0] = 1;\n    REP(i, N){\n        REP(j, 2 * i + 1){\n            Add(dp[i + 1][j + 1], dp[i][j]);\n            Add(dp[i + 1][j + 2], dp[i][j]);\n        }\n    }\n\n    Combination C(N, mod);\n\n    vec a(N + 1, 0);\n    REP(i, N + 1){\n        REP(j, X) a[i] += dp[i][j];\n        a[i] %= mod;\n    }\n    \n    //sum=X-1+2k\n    for(int k = 1; X - 1 + 2 * k <= 2 * N; k++){\n        REP(i, N + 1){\n            int i0 = i - 2 * k;\n            int X0 = X - 1 - 2 * k;\n            if(i0 >= 0 && X0 >= 0) Add(a[i], dp[i0][X0]);\n            else if(X - 1 + 2 * k == 2 * i) Add(a[i], 1);\n        }\n    }\n\n\n    int ans = 0;\n    REP(i, N + 1) Add(ans, a[i] * C.nCr(N, i));\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=3000,mod=998244353;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m;\n\nvoid into(){\n  scanf(\"%d%d\",&n,&m);\n}\n\nint inv[N*2+9],fac[N*2+9],ifac[N*2+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2;i<=n<<1;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint Get_c(int n,int m){return n<m||m<0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}\n\nint Get_ans(int n){\n  int res=m&1||n<<1<m;\n  for (int i=n;i<n<<1;++i)\n\tif (i<m) sadd(res,Get_c(n,i-n));\n    else if (m-i&1){\n\t  int p=i-m+1>>1;\n\t  sadd(res,Get_c(n-p*2,i-p*2-n));\n\t}\n  return res;\n}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=0;i<=n;++i) sadd(ans,mul(Get_c(n,i),Get_ans(i)));\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int maxn=6005;\nll f[maxn],inv[maxn],nf[maxn],s[maxn][maxn],dp[maxn][maxn],c[maxn],u[maxn*2],v[maxn*2];\nll ans;\nll C(ll x,ll y){\n    return f[x]*nf[y]%M*nf[x-y]%M;\n}\nvoid add(ll &x,ll y){\n    x+=y; if (x>=M) x-=M;\n}\nvoid add1(int l,int r,ll x){\n    add(u[l],x);\n    add(u[r+1],M-x);\n}\nvoid add2(int l,int r,ll x){\n    add(v[l],x);\n    add(v[r+1],M-x);\n}\nint n,k;\n\nint main(){\n    cin >> n >> k;\n    inv[1]=1; for (int i=2;i<maxn;i++) inv[i]=M-(M/i)*inv[M%i]%M;\n    f[0]=nf[0]=1; for (int i=1;i<maxn;i++) f[i]=f[i-1]*i%M,nf[i]=nf[i-1]*inv[i]%M;\n    dp[0][0]=1;\n    for (int i=0;i<n;i++)\n        for (int j=0;j<=min(i*2,k);j++)\n            add(dp[i+1][j+1],dp[i][j]),\n            add(dp[i+1][j+2],dp[i][j]);\n    for (int i=0;i<=n;i++)\n        for (int j=0;j<k;j++)\n            (ans+=dp[i][j]*C(n,i))%=M;\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=1; dp[1][1]=1;\n    for (int i=1;i<n;i++)\n        for (int j=0;j<=min(i*2,k);j++)\n            add(dp[i+1][j+1],dp[i][j]),\n            add(dp[i+1][j+2],dp[i][j]);\n    for (int i=0;i<n;i++)\n        for (int j=0;j<=k;j++)\n            s[i+1][j+1]=dp[i][j];\n    if (k%2==1){\n        for (int i=(k+1)/2;i<=n;i++) (ans+=C(n,i))%=M;\n    }\n    for (int i=1+k%2;i<k;i+=2) for (int p=1;p<=i;p++) if (s[p][i]) {\n\n        int r=(k-i)/2;\n        int L=(k-i+1)/2,R=r*2;\n        if (L<=R) {\n            add1(L+p,R+p,s[p][i]*(2*r+p+1)%M);\n            add2(L+p,R+p,M-s[p][i]);\n        }\n    }\n    for (int i=1;i<=n;i++) add(u[i],u[i-1]),add(v[i],v[i-1]);\n    for (int i=0;i<=n;i++) c[i]=(u[i]+v[i]*i)%M;\n    for (int i=1;i<=n;i++) (ans+=c[i]*C(n,i))%=M;\n    cout << (ans+M)%M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\n#include<random>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 998244353LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n#include <cstdint>\nstruct mint {\n\tusing i64 = std::int_fast64_t;\n\tconst static i64 mod = 998244353;\n\ti64 n;\npublic:\n\tmint(const i64 n = 0) : n((n % mod + mod) % mod) {}\n\tmint pow(int m) const {\n\t\ti64 a = n, r = 1;\n\t\twhile(m > 0) {\n\t\t\tif(m & 1) { r *= a; r %= mod; }\n\t\t\ta = (a * a) % mod; m /= 2;\n\t\t}\n\t\treturn mint(r);\n\t}\n\tmint &operator++() { *this += 1; return *this; }\n\tmint &operator--() { *this -= 1; return *this; }\n\tmint operator++(int) { mint ret = *this; *this += 1; return ret; }\n\tmint operator--(int) { mint ret = *this; *this -= 1; return ret; }\n\tmint operator~() const { return (this -> pow(mod - 2)); } // inverse\n\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n == rhs.n;\n\t}\n\tfriend mint &operator+=(mint& lhs, const mint& rhs) {\n\t\tlhs.n += rhs.n;\n\t\tif (lhs.n >= mod) lhs.n -= mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator-=(mint& lhs, const mint& rhs) {\n\t\tlhs.n -= rhs.n;\n\t\tif (lhs.n < 0) lhs.n += mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator*=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * rhs.n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator/=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * (~rhs).n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n + rhs.n);\n\t}\n\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n - rhs.n);\n\t}\n\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * rhs.n);\n\t}\n\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * (~rhs).n);\n\t}\n};\nistream& operator>>(istream& is, mint& m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, mint& m) { os << m.n; return os; }\n\n#define MAX_N 1000000\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n\tlong long d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nlong long mod_inverse(long long a, long long m) {\n\tlong long x, y;\n\tif(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n\telse return -1;\n}\nvector<long long> fact(MAX_N+1, INF);\nlong long mod_fact(long long n, long long& e) {\n\tif(fact[0] == INF) {\n\t\tfact[0]=1;\n\t\tif(MAX_N != 0) fact[1]=1;\n\t\tfor(lint i = 2; i <= MAX_N; ++i) {\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t}\n\t}\n\te = 0;\n\tif(n == 0) return 1;\n\tlong long res = mod_fact(n / MOD, e);\n\te += n / MOD;\n\tif((n / MOD) % 2 != 0) return (res * (MOD - fact[n % MOD])) % MOD;\n\treturn (res * fact[n % MOD]) % MOD;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n\tif(n < 0 || k < 0 || n < k) return 0;\n\tlong long e1, e2, e3;\n\tlong long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n\tif(e1 > e2 + e3) return 0;\n\treturn (a1 * mod_inverse((a2 * a3) % MOD, MOD)) % MOD;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, x;\n\tcin >> n >> x;\n\tif(x == 2) {\n\t\tcout << 1 + n << endl;\n\t\treturn 0;\n\t}\n\tmint ans = 1;\n\tFOR(m, 1, n + 1) {\n\t\tif(x == 1) {\n\t\t\tans += mod_comb(n, m);\n\t\t\tcontinue;\n\t\t}\n\t\tmint tmp = 0;\n\t\tREP(i, m + 1) {\n\t\t\tif(i * 2 + (m - i) * 1 >= x) break;\n\t\t\ttmp += mod_comb(m, i);\n\t\t}\n\t\tFOR(i, 1, m) {\n\t\t\tif(i < m - i) {\n\t\t\t\tif(2 * i == x - 1) tmp++;\n\t\t\t} else {\n\t\t\t\ttmp += mod_comb(m - 2 * (m - i), x - 1 - 2 * (m - i) - (i - (m - i)));\n\t\t\t}\n\t\t}\n\t\tans += tmp * mod_comb(n, m);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define SZ(x) ((int)x.size())\ntypedef long long LL;\ntypedef pair<int,int> PII;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=3010;\nconst int mod=998244353;\nint n,x,ans,mi2[N],c[N][N],f[N][N*2];\nvoid inc(int&a,int b){ a+=b;if(a>=mod)a-=mod; }\nint mul(int a,int b){return (LL)a*b%mod;}\nint main(){\n\tcin>>n>>x;\n\tf[0][0]=1;\n\tref(i,0,n-1)ref(j,0,n*2)if(f[i][j]){\n\t\tinc(f[i+1][j+1],f[i][j]);\n\t\tinc(f[i+1][j+2],f[i][j]);\n\t}\n\tref(i,0,n)c[i][0]=1;\n\tref(i,1,n)ref(j,1,i)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\tans=1;\n\tref(i,1,n){\n\t\tint s=c[n][i];\n\t\tint r=0;\n\t\tref(j,1,x-1)inc(r,f[i][j]);\n\t\tref(j,1,i)if(j<=x+1&&x+1<=j*2){\n\t\t\tint a=min(j-2,i-j)+2,b=x+1-a*2;\n\t\t\tif(a<=j&&b>=0)inc(r,f[j-a][b]);\n\t\t}\n\t\tinc(ans,mul(s,r));\n\t\t//cout<<i<<\" \"<<r<<endl;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << x.v;\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\nvector<mint<>> table;\nvector<mint<>> kaijo;\n\n\nmint<> comb(LL N, LL K) {\n  if (K < 0) return mint<>(0);\n  if (K > N) return mint<>(0);\n  return kaijo[N] / kaijo[N - K] / kaijo[K];\n}\n\nmint<> comb(LL K) {\n  return table[K];\n\n}\n\n\nvoid init(int N) {\n  kaijo.push_back(mint<>(1));\n  for (int i = 1; i <= 400000; i++) {\n    kaijo.push_back(kaijo.back() * i);\n  }\n  table.resize(100000);\n  for(int i=0; i<100000; i++) table[i] = 0;\n  for(int i=0; i<=N; i++)\n    table[i] = comb(N, i);\n}\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(k-1);\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(k-1 + i*2);\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(nokori);\n\n    }\n  }\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << x.v;\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\nvector<mint<>> table;\nvector<mint<>> kaijo;\n\n\nmint<> comb(LL N, LL K) {\n  if (K < 0) return mint<>(0);\n  if (K > N) return mint<>(0);\n  return kaijo[N] / kaijo[N - K] / kaijo[K];\n}\n\nmint<> comb(LL K) {\n  return table[K];\n\n}\n\n\nvoid init(int N) {\n  kaijo.push_back(mint<>(1));\n  for (int i = 1; i <= 400000; i++) {\n    kaijo.push_back(kaijo.back() * i);\n  }\n  table.resize(100000);\n  for(int i=0; i<=N; i++)\n    table[i] = comb(N, i);\n}\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(k-1);\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(k-1 + i*2);\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(nokori);\n\n    }\n  }\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, S default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\nint _main();\nint main()\n{\n    cout << setprecision(12);\n    return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD    998244353LL\n\nvoid solve_onetwos(ll onetwos[3005][6005])\n{\n    memset(onetwos, 0, sizeof(ll) * 3005LL * 6005LL);\n    onetwos[0][0] = 1LL;\n\n    rep (len, 3002) {\n        rep (sum, 6002) {\n            onetwos[len+1][sum+1] += onetwos[len][sum];\n            onetwos[len+1][sum+1] %= MOD;\n            onetwos[len+1][sum+2] += onetwos[len][sum];\n            onetwos[len+1][sum+2] %= MOD;\n        }\n    }\n\n    rep (i, 13) {\n        debug_printf(\"---- onetwos[5][%lld] = %lld\\n\", i, onetwos[5][i]);\n    }\n}\n\nvoid _solve_zerodiv(ll zerodivs[3002][3002], ll pockets)\n{\n    ll total = zerodivs[pockets-1][0];\n\n    srep (i, 1LL, 3002LL) {\n        total += zerodivs[pockets-1][i];\n        total %= MOD;\n        zerodivs[pockets][i] = total;\n    }\n}\n\nll solve_zerodivs(ll zerodivs[3002][3002])\n{\n    debug_printf(\"--- start solve_zerodivs\\n\");\n\n    rep (i, 3002) rep (j, 3002) zerodivs[i][j] = -1LL;\n    rep (i, 3002) zerodivs[i][0] = 1LL;\n    rep (i, 3002) zerodivs[0][i] = 0LL;\n    rep (i, 3002) zerodivs[1][i] = 1LL;\n\n    srep (i, 2LL, 3002LL) _solve_zerodiv(zerodivs, i);\n\n    srep (i, 1LL, 5LL) srep (j, 1LL, 5LL) {\n        debug_printf(\"zerodivs[%lld][%lld] = %lld\\n\",\n                     i, j, zerodivs[i][j]);\n    }\n}\n\nvoid solve_underx(ll cnts[3005], const ll onetwos[3005][6005], ll n, ll x)\n{\n    rep (len, n+1LL) {\n        rep (sum, x) {\n            cnts[len] += onetwos[len][sum];\n            cnts[len] %= MOD;\n        }\n    }\n\n    debug_printf(\"cnts[3] = %lld\\n\", cnts[3]);\n    debug_printf(\"cnts[4] = %lld\\n\", cnts[4]);\n}\n\nvoid solve_overx(ll cnts[3005], const ll onetwos[3005][6005], ll n, ll x)\n{\n    srep (sum, x + 1LL, 2LL * n + 1LL) {\n        if (!((sum - x) & 1LL)) continue;\n        ll edgetwos = sum - x + 1LL;\n        ll centersum = sum - edgetwos * 2LL;\n        if (centersum > 0LL) {\n            rep (len, 3002LL) {\n                cnts[len+edgetwos] += onetwos[len][centersum];\n                cnts[len+edgetwos] %= MOD;\n            }\n        }\n        else {\n            if (!(x & 1LL)) continue;\n            assert(!(sum & 1LL));\n            cnts[sum/2LL] += 1LL;\n            cnts[sum/2LL] %= MOD;\n        }\n    }\n}\n\nint _main()\n{\n    ll n; llin(n);\n    ll x; llin(x);\n\n    static ll onetwos[3005][6005];\n    solve_onetwos(onetwos);\n\n    static ll cnts[3005];\n    memset(cnts, 0, sizeof(cnts));\n    solve_underx(cnts, onetwos, n, x);\n    debug_printf(\"---- underx cnts[4] = %lld\\n\", cnts[4]);\n    solve_overx(cnts, onetwos, n, x);\n    debug_printf(\"---- underx+overx cnts[4] = %lld\\n\", cnts[4]);\n\n    static ll zerodivs[3002][3002];\n    solve_zerodivs(zerodivs);\n\n    ll ans = 0LL;\n    rep (len, n+1LL) {\n        ll incr = cnts[len];\n        ll zeros = n - len;\n\n        debug_printf(\"---- len=%lld cnts=%lld zeros=%lld\\n\",\n                     len, cnts[len], zerodivs[len+1LL][zeros]);\n\n        incr *= zerodivs[len+1LL][zeros];\n        incr %= MOD;\n        ans += incr;\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n\nconst int MOD = 998244353;\nconst int MAX = 3100;\nusing mint = Fp<MOD>;\n\n\nint main() {\n    int N, K; cin >> N >> K;\n\n    // 二項係数とその累積和\n    vector<vector<mint> > com(MAX, vector<mint>(MAX, 0));\n    vector<vector<mint> > scom(MAX, vector<mint>(MAX+1, 0));\n    com[0][0] = 1;\n    for (int i = 1; i < MAX; ++i) {\n        com[i][0] = 1;\n        for (int j = 1; j < MAX; ++j) com[i][j] = com[i-1][j-1] + com[i-1][j];\n    }\n    for (int i = 0; i < MAX; ++i) {\n        for (int j = 0; j < MAX; ++j) {\n            scom[i][j+1] = scom[i][j] + com[i][j];\n        }\n    }\n\n    // 0\n    mint res =  0;\n\n    // 2 しかやらない場合\n    for (int i = 0; i <= N; ++i) {\n        if (K % 2 == 0 && i*2 >= K) continue;\n        res += com[N][i];\n    }\n    for (int i = 0; 2*i+1 < K; ++i) {\n        int L = (K-1) - (i*2+1);\n        mint tmp1 = 0;\n        for (int m = 0; m <= min(L, N - (i+1)); ++m) {\n            tmp1 += scom[m][L-m] * com[N][m+i+1];\n\n            //cout << i << \"+, \" << m << \": \" << scom[m][L-m] << \", \" << com[N][m+i+1] << endl;\n        }\n        mint tmp2 = 0;\n        for (int m = 0; m <= min(K, N - (i+1)); ++m) {\n            tmp2 += com[m][L-m] * (scom[N][min(N, i*2+1+m)+1] - scom[N][i+1+m]);\n\n            //cout << i << \"-, \" << m << \": \" << com[m][L-m] << \", \" << (scom[N][N+1] - scom[N][i+1+m]) << endl;\n        }\n        res += tmp1 + tmp2;\n\n        //cout << i << \": \" << L << \", \" << tmp1 << \", \" << tmp2 << endl;\n    }\n    cout << res << endl;\n}\n    \n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nconst int N=3e3+5;\nint n,X;\nvoid input()\n{\n\tn=read<int>(),X=read<int>();\n}\nconst int mo=998244353;\nint dp[N][N<<1];\nint mc[N],inv[N];\nint power(int x,int y)\n{\n\tint res=1;\n\tfor(;y;x=1ll*x*x%mo,y>>=1)if(y&1)res=1ll*res*x%mo;\n\treturn res;\n}\nvoid init()\n{\n\tmc[0]=inv[0]=1;\n\tFor(i,1,n)mc[i]=1ll*mc[i-1]*i%mo;\n\tinv[n]=power(mc[n],mo-2);\n\tFordown(i,n,1)inv[i-1]=1ll*inv[i]*i%mo;\n}\nint C(int n,int m)\n{\n\tif(n<0||m<0||n<m)return 0;\t\n\treturn 1ll*mc[n]*inv[m]%mo*inv[n-m]%mo;\n}\nvoid work()\n{\n\tif(X==1){write(power(2,n),'\\n');return;}\n\tdp[0][0]=1;\n\tFor(i,1,n)For(j,1,2)\n\t{\n\t\tFor(k,j,X)dp[i][k]=(dp[i][k]+dp[i-1][k-j])%mo;\n\t}\n\tint ans=0;\n\tFor(i,0,n)For(j,0,X-1)ans=(ans+1ll*dp[i][j]*C(n,i))%mo;\n\t//cout<<ans<<endl;\n\tFor(i,0,n)\n\t{\n\t\tif((i+1)*2>X-1)break;\n\t\tFor(j,0,n)\n\t\t{\n\t\t\tif((i+1)*2+j>n)break;\n\t\t\t\n\t\t\tif(X-1>=(i+1)*2)ans=(ans+1ll*dp[j][X-1-(i+1)*2]*C(n,(i+1)*2+j))%mo;\n/*\t\t\tif(dp[j][X-1-i*2]&&C(n,i*2+1+j))\n\t\t\t{\n\t\t\t\tcout<<i<<' '<<j<<' '<<dp[j][X-1-i*2]<<' '<<C(n,i*2+1+j)<<endl;\n\t\t\t}*/\n\t\t}\n\t}\n\t\n\tif(X&1)\n\t{\n\t\tFor(i,(X-1)/2,n)\n\t\t{\n\t\t\tif((X+1)/2+i>n)break;\n\t\t\tans=(ans+C(n,(X+1)/2+i))%mo;\n\t\t}\n\n\t}\n\twrite(ans,'\\n');\n}\nint main()\n{\n\n\tinput();\n\tinit();\n\twork();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 6006\ntypedef long long ll;\nconst int mod=998244353;\ninline ll read(){\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,x,ans,fac[N],ifac[N];\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t}\n\tifac[n]=qpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i){\n\t\tifac[i]=1LL*ifac[i+1]*(i+1)%mod;\n\t}\n}\ninline int C(int n,int m){\n\tif(n<0||m<0||n-m<0)return 0;\n\treturn 1LL*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint calc(int n){\n\tint tot=(x&1||2*n<x);\n\tfor(int i=n;i<=(n<<1)-1;++i){\n\t\tif(i<x)tot=(tot+C(n,i-n))%mod;\n\t\telse if((x-i)&1){\n\t\t\tint p=(i-x+1)>>1;\n\t\t\ttot=(tot+C(n-(p<<1),(i-(p<<2))-(n-(p<<1))))%mod;\n\t\t}\n\t}\n\treturn tot;\n}\t\nint main(){\n\tn=read(),x=read();\n\tinit(max(n,x));\n\tfor(int k=0;k<=n;++k){\n\t\tans=(ans+1LL*C(n,k)*calc(k))%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int MOD = 998244353;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nconst int N = 3007;\nint f[N], inv[N];\nvoid prec() {\n    f[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = mod(f[i - 1] * i);\n    inv[N - 1] = fp(f[N - 1], MOD - 2);\n    for (int i = N - 2; i >= 0; --i)\n        inv[i] = mod(inv[i + 1] * (i + 1));\n}\nint C(int n, int k) {\n    return mod(f[n] * mod(inv[k] * inv[n - k]));\n}   \nvoid add(int &a, int b) {\n    a = mod(a + b);\n}   \n\nint dp1[N][2 * N], dp2[N][2 * N];\nvoid calc_dp() {\n    dp1[0][0] = 1;\n    for (int i = 0; i + 1 < N; ++i) {\n        for (int j = 0; j <= i * 2; ++j) {\n            for (int x = 1; x <= 2; ++x) {\n                add(dp1[i + 1][j + x], dp1[i][j]);\n            }\n        }   \n    }   \n    dp2[1][2] = 1;\n    for (int i = 1; i + 1 < N; ++i) {\n        for (int j = 0; j <= i * 2; ++j) {\n            for (int x = 1; x <= 2; ++x) {\n                add(dp2[i + 1][j + x], dp2[i][j]);\n            }\n        }   \n    }   \n    dp1[1][2] = 0;\n    for (int i = 1; i + 1 < N; ++i) {\n        for (int j = 0; j <= i * 2; ++j) {\n            add(dp1[i + 1][j + 2], -dp2[i][j]);\n        }   \n    }\n}   \n\nint get(int len, int sum) {\n    //cant be 2 in front and in back\n\n    //cout << \"get \" << len << ' ' << sum << \" : \" << dp1[len][sum] << endl;\n\n    return dp1[len][sum];\n}   \n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    prec();\n    calc_dp();\n\n    int n, x;\n    cin >> n >> x;\n\n    //there is no 1\n    int ans = 0;\n    for (int c1 = 0; c1 <= n; ++c1) {\n        for (int c2 = 0; c1 + c2 <= n; ++c2) {\n            if (c1 + 2 * c2 < x) {\n                add(ans, C(n, c1) * C(n - c1, c2));\n            }   \n        }   \n    }   \n\n    #ifdef HOME\n    cout << ans << endl;\n    #endif\n\n    for (int c2 = 0; c2 <= n; ++c2) {\n        if (x % 2 && c2 * 2 >= x) {\n            add(ans, C(n, c2));\n        }   \n    }   \n\n    #ifdef HOME\n    cout << ans << endl;\n    #endif\n\n    for (int len = 1; len <= n; ++len) {\n        for (int k = 1; k * 2 < len; ++k) {\n            int mid = len - 2 * k;\n            for (int sum = max(1ll, x - 4 * k); sum < x - 2 * k; ++sum) {\n                if ((sum & 1) ^ (x & 1))\n                    add(ans, get(mid, sum) * C(n, len));\n            }   \n        }   \n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nint main()\n{\n    int n, x; cin>>n>>x;\n    if(x==2){\n        cout<<n+1<<endl; return 0;\n    }\n    if(x==1){\n        ll ans=1;\n        for(int i=0; i<n; i++){\n            ans=ans*2%MOD;\n        }\n        cout<<ans<<endl;\n        return 0;\n    }\n    ll dp[3001][6001]={};\n    dp[0][0]=1;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<=2*i; j++){\n            dp[i+1][j]+=dp[i][j];\n            dp[i+1][j]%=MOD;\n            dp[i+1][j+1]+=dp[i][j];\n            dp[i+1][j+1]%=MOD;\n            dp[i+1][j+2]+=dp[i][j];\n            dp[i+1][j+2]%=MOD;\n        }\n    }\n    ll ans=0;\n    for(int i=0; i<x; i++) ans=(ans+dp[n][i])%MOD;\n    ll comb[3001][3001];\n    comb[0][0]=1;\n    for(int i=1; i<=n; i++){\n        comb[i][0]=comb[i][i]=1;\n        for(int j=1; j<i; j++){\n            comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n        }\n    }\n    for(int i=0; i<=n-2; i++){\n        for(int j=(x+1)%2; j<=x-3; j+=2){\n            if(n-1-i>=x-2-j){\n                ans+=dp[i][j]*comb[n-1-i][x-2-j];\n                ans%=MOD;\n            }\n        }\n    }\n    if(x&1){\n        for(int i=x; i<=n; i++){\n            ans+=comb[n][i];\n            ans%=MOD;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, X, f[N][N << 1], fac[N << 1], inv[N << 1];\n\ninline int C(int x, int y) {\n    return x < y ? 0 : 1LL * fac[x] * inv[y] % Mod * inv[x - y] % Mod;\n}\n\nint main() {\n    cin >> n >> X;\n\n    inv[0] = inv[1] = fac[0] = fac[1] = 1;\n    for (int i = 2; i <= n; ++i)\n        fac[i] = 1LL * fac[i - 1] * i % Mod,\n        inv[i] = 1LL * inv[Mod % i] * (Mod - Mod / i) % Mod;\n\n    for (int i = 1; i <= n; ++i)\n        inv[i] = 1LL * inv[i - 1] * inv[i] % Mod;\n\n    f[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 6000; ++j)\n            (f[i + 1][j + 1] += f[i][j]) %= Mod,\n            (f[i + 1][j + 2] += f[i][j]) %= Mod;\n\n    long long ans = 1;\n    for (int i = 1; i <= n; ++i) {\n        long long tmp = 0;\n        for (int j = 0; j < X; ++j)\n            (tmp += f[i][j]) %= Mod;\n        for (int j = X + 1; j <= 2 * i; j += 2) {\n            if (j < i) continue;\n            int p = i - (j - X + 1), q = X - 1 - (j - X + 1);\n            //if (j < 2 * X && p >= 0 && q >= 0) (tmp += f[p][q]) %= Mod;\n            if (j >= X * 2) (tmp += (j == (i << 1) ? (X & 1) : 0)) %= Mod;\n            else (tmp += (p >= 0 && q >= 0 ? f[p][q] : 0)) %= Mod;\n        }\n//        if (i >= X && (X & 1))\n//            ++tmp;\n        (ans += 1LL * tmp * C(n, i) % Mod) %= Mod;\n    }\n    cout << ans % Mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define inline __inline__ __attribute__((always_inline))\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\nusing namespace std;\nconst int N=3005,P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint f[N][N],c[N],inv[N],x,n,res;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&x),res=1;\n\tinv[0]=inv[1]=1;fp(i,2,n)inv[i]=mul(P-P/i,inv[P%i]);\n\tc[0]=1;fp(i,1,n)c[i]=1ll*c[i-1]*inv[i]%P*(n-i+1)%P;\n\tf[0][0]=1;fp(i,0,n-1)fp(j,0,(i<<1))upd(f[i+1][j+2],f[i][j]),upd(f[i+1][j+1],f[i][j]);\n\tfp(i,1,n){\n\t\tint s=0;\n\t\tfp(j,0,x-1)upd(s,f[i][j]);\n\t\tfor(R int j=x+1;j<=(i<<1);j+=2)if(j>=i){\n\t\t\tint p=i-(j-x+1),q=x-1-(j-x+1);\n\t\t\tif(j>=x*2)upd(s,j==(i<<1)?x&1:0);\n\t\t\t\telse upd(s,p>=0&&q>=0?f[p][q]:0);\n\t\t}\n\t\tupd(res,mul(s,c[i]));\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <random>\n#include <stack>\n#include <set>\n#include <unordered_set>\n\n#define bug(x) cout<<\"zdongdebug: \"<<x<<endl;\n#define bug2(x, y) cout<<\"zdongdebug: \"<<x<<\" \"<<y<<endl;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3005;\nconst int mod = 998244353;\nint c[maxn][maxn];\nint f[maxn][maxn];\nvoid pd(int&ret,int val){\n  ret+=val;\n  if(ret>=mod)ret-=mod;\n}\nvoid init(){\n  f[0][0]=1;\n  for(int i=0;i<maxn;i++)c[i][0]=c[i][i]=1;\n  for(int i=1;i<maxn;i++)\n    for(int j=1;j<i;j++){\n      c[i][j]=c[i-1][j]+c[i-1][j-1];\n      if(c[i][j]>=mod)c[i][j]-=mod;\n    }\n}\n\nint main() {\n#ifdef suiyuan2009\n  freopen(\"/Users/suiyuan2009/CLionProjects/icpc/input.txt\", \"r\", stdin);\n#endif\n  init();\n  int n,m;\n  cin>>n>>m;\n  for(int i=1;i<=n;i++) {\n    for (int j = 1; j < m; j++) {\n      if (2 * i < j)continue;\n      f[i][j] = c[i][2 * i - j];\n    }\n    if((m&1)&&2*i>m)f[i][2*i]=1;\n    for (int j = 1; j + j <i&&(j+j<m-1);j++) {\n      if(m-1+2*j!=2*i)\n      pd(f[i][m-1+2*j],f[i-j-j][m-1-2*j]);\n    }\n  }\n  //bug(f[1][2])\n  int ret = 1;\n  for(int i=1;i<=n;i++){\n    int sum = 0;\n    for(int j=1;j<=i+i;j++)pd(sum, f[i][j]);\n    pd(ret, sum*(ll)c[n][i]%mod);\n  }\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 998244353\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define MAX_N 100005\n#define MOD 998244353\n\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = (long long)fac[i-1] * i % MOD;\n\t\tfinv[i] = (long long)finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nint comb(int a,int b)\n{\n\tif(a < b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\nll dp[3010][6020];\nint main(){\n    make();\n    int n;\n    int x;\n    cin >> n >> x;\n    dp[0][0] = 1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=2*i;j++){\n            dp[i+1][j+1] += dp[i][j];\n            dp[i+1][j+1] %= mod;\n            dp[i+1][j+2] += dp[i][j];\n            dp[i+1][j+2] %= mod;\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<x;j++){\n            ans += dp[i][j]*comb(n,i)%mod;\n            ans %= mod;\n        }\n    }\n    cerr << ans << endl;\n    for(int k=1;k<=(n)/2;k++){\n        for(int p = 0;p<=n-2*k;p++){\n            if(x-1-2*k<=0)continue;\n            ans += dp[p][x-1-2*k]*comb(n,p+2*k)%mod;\n            ans %= mod;\n            if(2*p==x-1-2*k){\n                ans += mod-comb(n,p+2*k);\n                ans %= mod;\n            }\n        }\n        \n    }\n    cerr << ans << endl;\n    if(x%2==0){\n        \n    }else{\n        for(int k = (x+1)/2;k<=n;k++){\n            \n            ans += comb(n,k);\n            ans %= mod;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 3005;\nll binom[MAXN][MAXN];\nconst ll MOD = 998244353;\nint main() {\n\tfor (int i = 0; i < MAXN; ++i)\n\t\tfor (int j = 0; j <= i; ++j)\n\t\t\tif (!j || j == i) binom[i][j] = 1;\n\t\t\telse binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;\n\tint n, x;\n\tscanf(\"%d%d\", &n, &x);\n\tll ans = 0;\n\tfor (int a = 0; a <= n; ++a) {\n\t\tfor (int b = 0; b <= a; ++b) {\n\t\t\tint c = min(b, a - b);\n\t\t\tif (b + c > x - 1) continue;\n\t\t\tif (b + b < x - 1) continue;\n\t\t\tint r = b - c;\n\t\t\tint t = x - 1 - b - c;\n\t\t\tassert(0 <= t && t <= r);\n\t\t\tans = (ans + binom[r][t] * binom[n][a]) % MOD;\n\t\t}\n\t\t// Sum to s <= x - 2\n\t\tfor (int s = a; s <= x - 2; ++s) {\n\t\t\tint t = s - a;\n\t\t\tif (t < 0 || t > a) continue;\n\t\t\tans = (ans + binom[a][t] * binom[n][a]) % MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=6005,INF=1<<30;\nll cnt[MAX][MAX];\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    int N,X;cin>>N>>X;\n    ll sum=0;\n    \n    for(int i=0;i<X;i++){\n        for(int j=0;j<=N;j++){\n            if(i<j) continue;\n            \n            int rem=i-j;\n            cnt[i][j]=comb(j,rem);\n            \n            sum+=cnt[i][j]*comb(N,j);\n            sum%=mod;\n        }\n    }\n    \n    for(int i=X+1;i<=2*N;i+=2){\n        if(i<4) continue;\n        int rd=(i-(X-1))*2;\n        if(i-rd<0){\n            if(X%2==1){\n                int c=(i+1)/2;\n                sum+=comb(N,c);\n                sum%=mod;\n            }\n        }else{\n            for(int j=0;j+rd/2<=N;j++){\n                sum+=cnt[i-rd][j]*comb(N,j+rd/2);\n                sum%=mod;\n            }\n        }\n    }\n    \n    cout<<sum<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dp[6100][6100];\nconst ll M = 998244353;\nll ch(int a,int b) {\n\tif(b < 0 || b > a) return 0;\n\tif(b == 0 || b == a) return 1;\n\tif(dp[a][b] != -1) return dp[a][b];\n\tll val = ch(a-1,b-1)+ch(a-1,b);\n\tif(val >= M) val -= M;\n\treturn dp[a][b] = val;\n}\nint main() {\n\tint n,x;\n\tcin >> n >> x;\n\tmemset(dp,-1,sizeof(dp));\n\tll tot = 0;\n\tfor(int i=0;i<x;i++) {\n\t\tfor(int j=0;j<=x-1-i;j++) {\n\t\t\ttot += ch(i,j)*ch(n,i);\n\t\t\ttot %= M;\n\t\t}\n\t}\n\t//cout << tot << '\\n';\n\tif(x%2) {\n\t\tfor(int i=x-1;i<=n;i++) {\n\t\t\ttot += ch(n,i);\n\t\t\ttot %= M;\n\t\t}\n\t\t//cout << tot << '\\n';\n\t}\n\tfor(int i=1;2*i<x-1;i++) {\n\t\tfor(int j=0;x-1-j>=0;j++) {\n\t\t\ttot += ch(x-1-2*i-j,j)*ch(n,x-1-j);\n\t\t\ttot %= M;\n\t\t}\n\t\t//cout << tot << '\\n';\n\t}\n\ttot %= M;\n\tcout << tot << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 3002;\nconst int ROOT = 15311432;\nconst int ROOT_1 = 469870224;\nconst int ROOT_PW = 1<<23;\nconst int MOD = 998244353;\n\nint n, x, rev[MAX_N*4], inv[MAX_N*4];\nint pw2[MAX_N], C[MAX_N][MAX_N], f[MAX_N][MAX_N*2], g[MAX_N][MAX_N];\n\nvoid read_input() {\n    cin >> n >> x;\n}\n\nvoid NTT(vector<int> &a, bool invert) {\n    int n = a.size();\n\n    for (int i=1; i<n; ++i) {\n        if (i<rev[i])\n            swap(a[i], a[rev[i]]);\n    }\n\n    for (int len=2; len<=n; len <<= 1) {\n        int wlen = invert ? ROOT_1 : ROOT;\n\n        for (int i=len; i<ROOT_PW; i <<= 1)\n            wlen = 1LL * wlen * wlen % MOD;\n\n        for (int i=0; i<n; i += len) {\n            int w = 1;\n            for (int j=0; j<len/2; ++j) {\n                int u = a[i+j], v = 1LL * a[i+j+len/2] * w % MOD;\n                a[i+j] = (u + v < MOD ? u + v : u + v - MOD);\n                a[i+j+len/2] = (u - v >=0 ? u - v : u - v + MOD);\n                w = 1LL * w * wlen % MOD;\n            }\n        }\n    }\n\n    if (invert) {\n        for (int i=0; i<n; ++i)\n            a[i] = 1LL * a[i] * inv[n] % MOD;\n    }\n}\n\nvoid square(vector<int> &a) {\n    int n = 1;\n    while (n < 2*a.size())\n        n <<= 1;\n    a.resize(n);\n    // PR0(a, a.size());\n\n    NTT(a, false);\n    // PR0(a, a.size());\n\n    for (int i=0; i<n; ++i)\n        a[i] = 1LL * a[i] * a[i] % MOD;\n\n    NTT(a, true);\n}\n\nvoid init() {\n    int tmp = 1;\n    while (tmp<(n+1)*2)\n        tmp <<= 1;\n\n    inv[1] = 1;\n    for (int i=2; i<=tmp; ++i)\n       inv[i] = MOD - 1LL * inv[MOD%i] * (MOD / i) % MOD;\n\n    for (int i=1, j=0; i<tmp; ++i) {\n        int bit = tmp>>1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n        rev[i] = j;\n    }\n    // PR0(rev, tmp);\n\n    for (int i=0; i<=n; ++i)\n        C[i][0] = C[i][i] = 1;\n\n    for (int i=1; i<=n; ++i) {\n        for (int j=1; j<i; ++j)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;\n    }\n\n    pw2[0] = 1;\n    for (int i=1; i<=n; ++i)\n        pw2[i] = pw2[i-1] * 2 % MOD;\n\n    f[0][0] = 1;\n\n    for (int l=1; l<=n; ++l) {\n        for (int s=0; s<=x; ++s) {\n            f[l][s] = f[l-1][s];\n            if (s>=1)\n                f[l][s] = (f[l][s] + f[l-1][s-1]) % MOD;\n            if (s>=2)\n                f[l][s] = (f[l][s] + f[l-1][s-2]) % MOD;\n        }\n    }\n    // debug(f[n][2]);\n}\n\nint case1() {\n    vector<int> h;\n\n    for (int t=0; t<=x/2; ++t) {\n        h.assign(n+1, 0);\n\n        for (int l=0; l<=n; ++l) {\n            if (l<=t)\n                h[l] = pw2[l];\n            else\n                h[l] = (1LL * h[l-1] * 2 - C[l-1][t] + MOD) % MOD;\n        }\n\n        square(h);\n        // if (t==1)\n        //     PR0(h, n+1);\n\n        for (int l=0; l<=n; ++l)\n            g[l][t] = h[l];\n    }\n    // debug(g[2][1]);\n\n    int res = 0;\n\n    for (int l=0; n-l-2>=0; ++l) {\n        for (int s=(x+1)%2; s+2<=x; s += 2) {\n            // cerr << l << ' ' << s << ' ' << f[l][s] * g[n-l-2][(x-2-s)/2] << '\\n';\n            res = (res + 1LL * f[l][s] * g[n-l-2][(x-2-s)/2]) % MOD;\n        }\n    }\n\n    if (x%2==0)\n        res = (res + g[n-1][(x-1)/2]) % MOD;\n    else\n        res = (res + pw2[n]) % MOD;\n\n    return res;\n}\n\nint case2() {\n    int res = 0;\n\n    for (int s=x%2; s<x; s += 2)\n        res = (res + f[n][s]) % MOD;\n\n    return res;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tread_input();\n\tinit();\n    // vector<int> h = {0, 1, 2, 3};\n    // square(h);\n    // PR0(h, h.size());\n\t// debug(case1());\n    // debug(case2());\n\tcout << (case1() + case2()) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define SZ(x) ((int)x.size())\ntypedef long long LL;\ntypedef pair<int,int> PII;\nint read(){\n\tchar c=getchar();int d=0,f=1;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;\n\tfor(;c>='0'&&c<='9';d=d*10+c-48,c=getchar());\n\treturn d*f;\n}\nconst int N=3010;\nconst int mod=998244353;\nint n,x,ans,mi2[N],c[N][N],f[N][N*2];\nvoid inc(int&a,int b){ a+=b;if(a>=mod)a-=mod; }\nint mul(int a,int b){return (LL)a*b%mod;}\nint main(){\n\tcin>>n>>x;\n\tf[0][0]=1;\n\tref(i,0,n-1)ref(j,0,n*2)if(f[i][j]){\n\t\tinc(f[i+1][j+1],f[i][j]);\n\t\tinc(f[i+1][j+2],f[i][j]);\n\t}\n\tref(i,0,n)c[i][0]=1;\n\tref(i,1,n)ref(j,1,i)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\tmi2[0]=1;\n\tref(i,1,n)mi2[i]=mul(mi2[i-1],2);\n\tans=1;\n\tref(i,1,n){\n\t\tint s=c[n][i];\n\t\tint r=0;\n\t\tref(j,1,x-1)inc(r,f[i][j]);\n\t\tref(j,1,i)if(j<=x+1&&x+1<=j*2){\n\t\t\tint a=min(j-2,i-j)+2,b=x+1-a*2;\n\t\t\tif(a<=j)inc(r,f[j-a][b]);\n\t\t}\n\t\tinc(ans,mul(s,r));\n\t\t//cout<<i<<\" \"<<r<<endl;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n, x;\n  cin >> n >> x;\n  vvi d(3001, vi(3001));\n  vvi bin(3001, vi(3001));\n  for (int n = 0; n < d.size(); ++n) {\n    bin[n][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      bin[n][i] = (bin[n - 1][i] + bin[n - 1][i - 1]) % mod;\n    }\n  }\n  d[0][0] = d[1][0] = d[2][1] = 1;\n  for (int l = 3; l < d.size(); ++l) {\n    for (int i = 1; i < l; ++i) {\n      d[l][i] = (d[l - 1][i - 1] + d[l - 2][i - 1]) % mod;\n    }\n  }\n  ll res = 0;\n  for (int S = 0; S <= 2 * n; ++S) {\n    vi bad(S + 1);\n    for (int i = x; i <= S; ++i) {\n      if (i % 2 == x % 2) {\n        bad[i] = 1;\n      } else {\n        bad[i - x] = 1;\n      }\n    }\n    if (bad.back()) continue;\n//    cerr << \"x: \" << x << \" S: \" << S << endl;\n//    for (int i = 0; i <= S; ++i) cerr << bad[i]; cerr << endl;\n    bool fail = 0;\n    int steps = n;\n    for (int i = 0; i + 1 <= S; ++i) {\n      if (bad[i] && bad[i + 1]) {\n        fail = 1;\n      }\n      if (bad[i] && i > 0 && !bad[i-1] && i + 1 <= S && !bad[i+1]) --steps;\n    }\n    if (fail) break;\n    int L = 0;\n    for (int i = 0; i <= S; ++i) if (!bad[i]) {\n      int l = 1;\n      for (int j = i + 1; j <= S; ++j) {\n        if (bad[j]) break;\n        ++l;\n      }\n      if (l != 1) {\n        assert(L == 0);\n        L = l;\n        i += l - 1;\n      }\n    }\n    for (int i = 0; i <= steps; ++i) {\n      res = (res + d[L][i] * (ll)bin[n][steps - i]) % mod;\n    }\n//    cerr << n << ' ' << steps << ' ' << res << endl;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[10101];\nll B[10101];\n\nbool isprime(ll v) {\n\tfor(ll i=2;i*i<=v;i++) if(v%i==0) return false;\n\treturn (v!=1);\n}\n\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tj=0;\n\tFOR(i,N+1) {\n\t\tcin>>A[i];\n\t\tif(A[i]) j=i+1;\n\t}\n\tN=j;\n\treverse(A,A+N);\n\t\n\tset<int> cand;\n\t\n\tfor(i=1;i*i<=abs(A[0]);i++) {\n\t\tif(abs(A[0])%i==0) {\n\t\t\tif(isprime(i)) cand.insert(i);\n\t\t\tif(isprime(abs(A[0])/i)) cand.insert(abs(A[0])/i);\n\t\t}\n\t}\n\tFOR(i,10001) if(isprime(i)) cand.insert(i);\n\t\n\t\n\tFORR(c,cand) {\n\t\tZERO(B);\n\t\tFOR(i,N) B[i%(c-1)]+=A[i];\n\t\tFOR(i,N) if(B[i%(c-1)]%c) break;\n\t\tif(i==N) cout<<c<<endl;\n\t}\n\t\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int  N = 9005;\nint type_rec[N] = {0};\nint type_rec_old[N] = {0};\n\nint main()\n{\n    int n, x;\n    long long ans = 0;\n    long long oldans = 1;\n    long long over_ans = 1;\n    cin >> n >> x;\n        type_rec[0] = 0;\n        type_rec_old[0]= 0;\n    for(int i = 0; i <n; ++i){\n        // cout << endl;\n        ans = oldans * 3;\n        ans -=  type_rec[x - 1];\n        ans -=  type_rec[x - 2];\n        ans += 998244353 * 2;\n        ans %= 998244353;\n        // cout << ans << endl;\n        oldans = ans;\n        // for (int k = 0; k <= 10; k++)\n        //     cout << type_rec[k] << ' ';\n        for (int j= 0; j <= 9000; ++j){\n            if(j - 1 >= 0){\n                type_rec[j] += type_rec_old[j-1];\n                type_rec[j] %= 998244353;\n            }\n            if(j - 2 >= 0){\n                type_rec[j] += type_rec_old[j-2];\n                type_rec[j] %= 998244353;\n            }\n            if (j <= 2)\n                type_rec[j] += 1;\n            type_rec[j] %= 998244353;\n\n        }\n        for (int j= 0; j <= 9000; ++j)\n            type_rec_old[j] = type_rec[j] % 998244353;\n    }\n    cout << ans  << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 998244353;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 6e3 + 5;\nmi fact[MAX], ifact[MAX], len[MAX], dp[MAX][MAX], ones[MAX][MAX], twos[MAX][MAX], twos_total[MAX][MAX], rest[MAX][MAX], rest_total[MAX][MAX], po[MAX], prefix[MAX], up_prefix[MAX];\nmi choose(int a, int b){\n    if(b < 0 || a < b) return 0;\n    return fact[a] * ifact[b] * ifact[a - b];\n}\nmi sum_prefix(int l, int r){ return prefix[r] - (l == 0 ? 0 : prefix[l - 1]); }\n\nmi sum_up_prefix(int l, int r){ return up_prefix[r] - (l == 0 ? 0 : up_prefix[l - 1]); }\nmi progression(int l, int r, int st, int d){ return (sum_up_prefix(l, r) - sum_prefix(l, r) * l) * d + sum_prefix(l, r) * st; }\nint n, x;\nint main(){\n    fact[0] = 1; ifact[0] = 1; po[0] = 1;\n    for(int i = 1; i < MAX; i++) fact[i] = fact[i - 1] * i, ifact[i] = ifact[i - 1] / i, po[i] = po[i - 1] * 2;\n    ios_base :: sync_with_stdio(0); cin.tie(0);\n    cin >> n >> x;\n    prefix[0] = 1;\n    for(int i = 1; i <= n; i++) prefix[i] = prefix[i - 1] + choose(n, i), up_prefix[i] = up_prefix[i - 1] + choose(n, i) * i;\n    mi ans = 0;\n    if(x % 2 == 0) for(int i = 0; i < x / 2; i++) ans += choose(n, i);\n    else ans += po[n];\n    dp[0][0] = 1;\n    for(int i = 0; i <= n; i++) for(int j = 0; j < x; j++) dp[i + 1][j + 2] += dp[i][j], dp[i + 1][j + 1] += dp[i][j];\n    for(int i = 0; i <= n; i++) for(int j = 0; j < x; j++) ones[i + 2][j + 2] = dp[i][j];\n    ones[1][1] += 1;\n    for(int i = 0; i <= n; i++) for(int j = 0; j + i <= n; j++) twos[max(i, j)][i + j] += 1;\n    for(int j = 0; j <= n; j++) for(int i = 1; i <= max(n, x); i++) twos[i][j] += twos[i - 1][j];\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < n; j++){\n            if(j <= i) rest[i][j] = progression(0, j, j + 1, -1);\n            else rest[i][j] = progression(j - i, j, i + 1, -1) + progression(max(0, j - 2 * i), j - (i + 1), max(1, 2 * i + 1 - j), 1);\n        }\n    }\n    for(int j = 0; j < n; j++){\n        rest_total[0][j]  += choose(n, j);\n        for(int i = 1; i <= n; i++){\n            if(i > j) rest_total[i][j] = rest_total[i - 1][j];\n            else rest_total[i][j] = rest_total[i - 1][j] + choose(n, j - i) * (i + 1);\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            if(ones[i][j] == 0) continue;\n            int mx = min((x - j - 1) / 2, n - 1);\n            if(j % 2 == x % 2) ans += ones[i][j] * rest_total[mx][n - i];\n            else ans += ones[i][j] * rest[mx][n - i];\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  //mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  mint(long long v) : v(v % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << x.v;\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\n\nvector<vector<LL>> comb_table;\n\n\nLL comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return comb_table[N][K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+6);\n  for(int i=0; i<=N; i++) {\n    comb_table[i].resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<i; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n      comb_table[i][j] %= MOD;\n    }\n  }\n  \n}\n\n\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  \n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1);// % MOD ;\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2);// % MOD;\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 1010000000\n#define infll 1010000000000000000ll\n#define vi vector<int>\n#define vll vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define mpr make_pair\n#define fi first\n#define se second\n#define pq priority_queue<int>\n#define pqll priority_queue<ll>\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define ad(x,y) (x=(x+(y))%mod)\n#define ll long long\n#define N 10009\n#define mod 998244353\nusing namespace std;\n\nint n,m,ans,fac[N],ifac[N];\n\nint inv(int x){return x==1?1:(ll)(mod-mod/x)*inv(mod%x)%mod;}\nll C(int x,int y){\n\treturn x<y||y<0?0:(ll)fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=1;\n\tfor (int i=1; i<=n; i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=inv(fac[n]);\n\tfor (int i=n-1; ~i; --i) ifac[i]=(ll)ifac[i+1]*(i+1)%mod;\n\tfor (int i=0; i<=n; i++){\n\t\tint tmp=0;\n\t\tfor (int j=0; j<=m-1 && j<=i; j++)\n\t\t\tif (j*2>=m-1){\n\t\t\t\tint k=i-j;\n\t\t\t\tif (i>=k){\n\t\t\t\t\tll t=j-k,w=m-1-j-k;\n\t\t\t\t\tif (t<0){\n\t\t\t\t\t\tif (j*2==m-1) ad(tmp,1);\n\t\t\t\t\t}\n\t\t\t\t\telse ad(tmp,C(t,w));\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int j=0;j<m-1;++j) ad(tmp,C(i,j-i));\n\t\tad(ans,(ll)tmp*C(n,i));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << x.v;\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\n\nvector<vector<LL>> comb_table;\n\n\nLL comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return comb_table[N][K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+6);\n  for(int i=0; i<=N; i++) {\n    comb_table[i].resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<i; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n      comb_table[i][j] %= MOD;\n    }\n  }\n  \n}\n\n\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  \n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n      //dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1) ;\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2) ;\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n    }\n  }\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <atcoder/all>\n#include <bits/stdc++.h>\nusing namespace std;\n//using namespace atcoder;\n#define int long long\n   template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    const int MAX =3001;\nconst int MOD =998244353;\nint fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nint COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n  \n  \nsigned main(){\n  COMinit();\nint n,x;\ncin>>n>>x;\nint dp[x][n+1];\nfor(int i=0;i<x;i++)for(int j=0;j<=n;j++){\n  if(j==0)dp[i][j]=(i==0);\n  else dp[i][j]=dp[i][j-1];\n  if(i>=1&&j>=1)dp[i][j]=(dp[i][j]+dp[i-1][j-1])%MOD;\n  if(i>=2&&j>=1)dp[i][j]=(dp[i][j]+dp[i-2][j-1])%MOD;\n}\nint ans=0;\nfor(int i=0;i<x;i++)ans=(ans+dp[i][n])%MOD;\nfor(int i=2;i<=x-1;i+=2)for(int j=0;j+i<=n;j++)ans=(ans+COM(j+i-1,j)*dp[x-1-i][n-i-j]%MOD)%MOD;\nif(x%2)for(int i=x;i<=n;i++)ans=(ans+COM(n,i))%MOD;\ncout<<ans<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(),x.end()\n#define all(x) x.begin(),x.end()\n#define fi first\n#define se second\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define erase_duplicates(x) sort(all(x)); (x).resize(distance((x).begin(), unique(all(x))));\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set = tree<\nT,\nnull_type,\nless<T>,\nrb_tree_tag,\ntree_order_statistics_node_update>;\n\n//X.find_by_order(k); - zwraca iterator na k-ty element (numeracja od zerowego)\n//X.order_of_key(k); - zwraca liczbę elementów ostro mniejszych niż k\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<char> VC;\ntypedef long double LD;\ntypedef pair<LD,LD> PLD;\ntypedef vector<LD> VLD;\ntypedef vector<PLD> VPLD;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\" = \"<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<\" = \"<<h<<\", \"; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#define cerr if(0)cout\n#endif\n\nconst int maxn = (3e3)+7;\nconst int maxk = 20;\nconst int inf = (1e9)+7;\nconst LL LLinf = ((LL)1e18)+7LL;\nconst LD eps = 1e-9;\nconst LL mod = 998244353LL;\n\n// ***************************** CODE ***************************** //\n\nLL dp[maxn];\nLL poch[maxn];\nLL stala[maxn];\nLL net[maxn][maxn];\n\nint main()\n{\n\t_upgrade\n  int n, x;\n  cin>>n>>x;\n  net[0][0] = 1;\n  dp[0] = 1;\n  for(int i = 1;i <= n;i++)\n    for(int j = 0;j <= i;j++)\n      net[i][j] = ((j == 0 ? 0 : net[i - 1][j - 1]) + net[i - 1][j]) % mod;\n  if(x & 1)\n  {\n    for(int i = 1;i <= n;i++)\n      dp[i]++;\n    for(int i = 0;i <= n;i++)\n      for(int j = 0;j <= n;j++)\n        if(i + j + 1 <= n && (2 * i + 2 * j + 1 < x))\n          dp[i + j + 1]++;\n  }\n  else\n  {\n    for(int i = 1;i * 2 < x;i++)\n      dp[i]++;\n    for(int i = 0;i <= n;i++)\n      for(int j = 0;j <= n;j++)\n        if(i + j + 1 <= n && 2 * i < x && 2 * j < x)\n          dp[i + j + 1]++;\n  }\n   LL res = 0LL;\n    // for(int i = 0;i <= n;i++)\n    // {\n    //   res = (res + net[n][i] * dp[n - i]) % mod;\n    // }\n    // res %= mod;\n    // res += mod;\n    // res %= mod;\n    // cout<<res<<endl;\n  for(int dl = 0;dl <= n - 2;dl++)\n    for(int dwa = 0;dwa <= dl;dwa++)\n    {\n      int jed = dl - dwa;\n      int suma = jed + dwa * 2 + 2;\n      if(suma >= x) continue;\n      if(suma % 2 == x % 2)\n      {\n        int dodaj = (x - suma - 1) / 2;\n        assert(dodaj >= 0);\n\n        poch[dl + 2] += net[dl][dwa];\n        poch[dl + 2] %= mod;\n        if(dl + 2 + dodaj + 1 <= n)\n        {\n          poch[dl + 2 + dodaj + 1] -= net[dl][dwa];\n          stala[dl + 2 + dodaj + 1] -= (dodaj + 1) * net[dl][dwa] % mod;\n          stala[dl + 2 + dodaj + 1] %= mod;\n          poch[dl + 2 + dodaj + 1] %= mod;\n        }\n        // dbg(dl + 2, dodaj, net[dl][dwa]);\n      }\n      else\n      {\n        int dodaj = (x - suma - 1) / 2;\n        assert(dodaj >= 0);\n        // dbg(dl + 2, net[dl][dwa], dodaj);\n        poch[dl + 2] += net[dl][dwa];\n        poch[dl + 2] %= mod;\n        if(dl + 2 + dodaj + 1 <= n)\n        {\n          poch[dl + 2 + dodaj + 1] -= 2 * net[dl][dwa];\n          poch[dl + 2 + dodaj + 1] %= mod;\n        }\n        if(dl + 2 + 2 * dodaj + 1 <= n)\n        {\n          poch[dl + 2 + 2 * dodaj + 1] += net[dl][dwa];\n          stala[dl + 2 + 2 * dodaj + 1] -= net[dl][dwa];\n          poch[dl + 2 + 2 * dodaj + 1] %= mod;\n          stala[dl + 2 + 2 * dodaj + 1] %= mod;\n        }\n      }\n    }\n  LL curpoch = 0;\n  LL cursuma = 0;\n  for(int i = 0;i <= n;i++)\n  {\n    curpoch += poch[i];\n    cursuma += stala[i] + curpoch;\n    curpoch %= mod;\n    cursuma %= mod;\n    // dbg(poch[i], stala[i], i, cursuma, curpoch);\n    dp[i] += cursuma;\n    dp[i] %= mod;\n  }\n  res = 0LL;\n  for(int i = 0;i <= n;i++)\n  {\n    res = (res + net[n][i] * dp[n - i]) % mod;\n  }\n  res %= mod;\n  res += mod;\n  res %= mod;\n  cout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define rep(i, a, b) for (register int i=(a); i<=(b); ++i)\n#define per(i, a, b) for (register int i=(a); i>=(b); --i)\nusing namespace std;\nconst int N=3005, P=998244353;\ninline void Add(int &x, int y){x=x+y>=P?x+y-P:x+y;}\ninline void sub(int &x, int y){x=x-y<0?x-y+P:x-y;}\ninline int add(int x, int y){return x+y>=P?x+y-P:x+y;}\ninline int mul(int x, int y){return 1ll*x*y-1ll*x*y/P*P;}\nint C[N][N];\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n    return x*f;\n}\n\nint calc(int n, int x)\n{\n\tint ans=0;\n\tif (n<<1<x || (x&1)) ans=1;\n\trep(i, n, 2*n-1)\n\t{\n\t\tif (i<x) Add(ans, C[n][i-n]);\n\t\telse \n\t\t{\n\t\t\tif (!((i-x)%2)) continue;\n\t\t\tint cnt=(i-x+1)>>1;\n\t\t\tif (cnt<<1>=n) continue;\n\t\t\tint a=n-(cnt<<1), b=i-(cnt<<2);\n\t\t\tif (a<=b && a<<1>=b) Add(ans, C[a][b-a]);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n=read(), x=read();\n\trep(i, 0, n)\n\t{\n\t\tC[i][0]=1;\n\t\trep(j, 1, i) C[i][j]=add(C[i-1][j], C[i-1][j-1]);\n\t}\n\tint ans=0;\n\trep(i, 0, n) Add(ans, mul(C[n][i], calc(n-i, x)));\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define inline __inline__ __attribute__((always_inline))\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\nusing namespace std;\nconst int N=3005,P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint f[N][N],C[N][N],x,n,res;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&x),res=1;\n\tC[0][0]=1;\n\tfp(i,1,n){\n\t\tC[i][0]=1;\n\t\tfp(j,1,i)C[i][j]=add(C[i-1][j],C[i-1][j-1]);\n\t}\n\tf[0][0]=1;fp(i,0,n-1)fp(j,0,(i<<1))upd(f[i+1][j+2],f[i][j]),upd(f[i+1][j+1],f[i][j]);\n\tfp(i,1,n){\n\t\tint s=0;\n\t\tfp(j,0,x-1)upd(s,f[i][j]);\n\t\tfor(R int j=x+1;j<=(i<<1);j+=2)if(j>=i){\n\t\t\tint p=i-(j-x+1),q=x-1-(j-x+1);\n\t\t\tif(j>=x*2)upd(s,j==(i<<1)?x&1:0);\n\t\t\t\telse upd(s,p>=0&&q>=0?f[p][q]:0);\n\t\t}\n\t\tupd(res,mul(s,C[n][i]));\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const long long MOD = 998244353;\nconst int N = 3004;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nint n, x;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n >> x;\n    vector<ll> calc(n + 1);\n    calc[0] = 1;\n    for (int len = 1; len <= n; len++)\n    {\n        for (int summ = len; summ <= 2 * len; summ++)\n        {\n            if (summ < x)\n            {\n                calc[len] = (calc[len] + cnk(len, summ - len)) % MOD;\n            }\n            else\n            {\n                if (summ <= x || (summ - x + 1) % 2 == 1)\n                {\n                    continue;\n                }\n                int L = (summ - x + 1) / 2;\n                int R = len - L;\n                int summa = summ - 4 * L;\n                if (summa + 2 * L != x - 1) cout << \"My bad\\n\", exit(0);\n                int dlina = len - 2 * L;\n                //cout << len << \" \" << summ << \" \" << L << \" \" << dlina << endl;\n                if (summa != 2 * dlina) calc[len] = (calc[len] + cnk(dlina, summa - dlina)) % MOD;\n            }\n        }\n        if (2 * len >= x && x % 2 == 1) calc[len] = (calc[len] + 1) % MOD;\n        //cout << len << \" \" << calc[len] << endl << endl;\n    }\n    ll ans = 0;\n    for (int i = 0; i <= n; i++)\n    {\n        ans = (ans + calc[i] * cnk(n, i)) % MOD;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 100010;\nll inv[MAX],fact[MAX],fi[MAX],mod = 998244353;\nvoid inverse(){\n\tint i;\n\tinv[1] = 1;\n\tfor(i=2;i<MAX;i++){\n\t\tinv[i] = mod - (mod/i)*inv[mod%i]%mod;\n\t}\n\tfact[0] = fi[0] = 1;\n\tfor(i=1;i<MAX;i++){\n\t\tfact[i] = fact[i-1]*i%mod;\n\t\tfi[i] = (fi[i-1]*inv[i])%mod;\n\t}\n}\n\nll comb(int n,int k){\n\tif(n<0 || k<0 || n<k){\n\t\treturn 0;\n\t}else{\n\t\treturn fact[n]%mod*fi[k]%mod*fi[n-k]%mod;\n\t}\n}\n\nll solve(int x,int s,int t){\n\tint k = s + 2*t;\n\tif(k<x) return comb(s + t,t);\n\tif((k - (x - 1))&1) return 0;\n\tif(s==0) return (x&1);\n\tif(k>=2*(x - 1)) return 0;\n\tint l = k - (x - 1);\n\treturn comb(s + t - l,s);\n}\n\nint main(){\n\tint i,j,n,x;\n\tcin >> n >> x;\n\tinverse();\n\tll ans = 0;\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=n;j++){\n\t\t\t(ans += solve(x,i,j)*comb(n,(i + j))%mod) %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int Maxn=3010;\nconst int inf=2147483647;\nconst int mod=998244353;\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n    return x*f;\n}\nvoid upd(int&x,int y){x+=y;if(x>=mod)x-=mod;}\nint n,k;\nint f[Maxn][Maxn<<1],C[Maxn][Maxn];\nint main()\n{\n\tn=read(),k=read();\n\tC[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n//\tpw[0]=1;for(int i=1;i<=n;i++)pw[i]=pw[i-1]*2%mod;\n\tf[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<=min(i<<1,k-1);j++)\n\tfor(int l=0;l<3;l++)\n\tupd(f[i+1][j+l],f[i][j]);\n\tint ans=0;\n\tfor(int i=0;i<k;i++)upd(ans,f[n][i]);\n\tif(k&1)\n\t{\n\t\tfor(int i=n;i;i--)\n\t\t{\n\t\t\tif(2*i<=k)break;\n\t\t\tupd(ans,C[n][i]);\n\t\t}\n\t}\n//\tprintf(\"%d\\n\",ans);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tif((n-i)*2<k)break;\n\t\tint t=0;\n\t\tfor(int j=1;k+j<=n*2;j+=2)//S-k\n\t\t{\n\t\t\tint S=k+j,c=(j+1)/2;\n\t\t\tint t1=(n-i-c*2),t2=S-c*4-t1;\n\t\t\tif(t1<=0||t2<0||t1==t2)continue;\n//\t\t\tprintf(\"%d %d %d\\n\",t1,t2,C[t1][t2]);\n\t\t\tupd(t,C[t1][t2]);\n\t\t}\n//\t\tprintf(\"%d %d\\n\",i,t);\n\t\tupd(ans,(LL)t*C[n][i]%mod);\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 998244353\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n \n \nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 3002\n#define MAX_X 6002\n\nint n;\nint x;\n\nint dp[MAX_X][MAX_X];\nint dp2[MAX_X][MAX_X];\n\nint main(){\n\tcin>>n>>x;\n\tif(x==1){\n\t\tprintf(\"%d\\n\",(int)ppow(2,n));\n\t\treturn 0;\n\t}\n\tC.resize(100000);\n\t//x+1を超える 必ず1が含まれる場合\n\tlong long int ans=0;\n\tfor(int i=1;i<=n;i++){  //連続する2の個数\n\t\tint sum=2*i;\n\t\tint ret=x+1-sum-2;\n\t\tif(ret<0)break;\n\t\tfor(int j=0;j<=ret;j++){\n\t\t\tlong long int tmp=ans;\n\t\t\tif(ret==0&&j)continue;\n\t\t\tif(ret&&j==0)continue;\n\t\t\tif(ret==0&&false){\n\t\t\t\tint gap=i*2+1;\n\t\t\t\tint want=n-i*2;\n\t\t\t\tif(want<0)continue;\n\t\t\t\taddto(ans,C.C(gap+want-1,want));\n\t\t\t\tlong long int tt=ans;\n\t\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<tt-tmp<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint w=ret-j;\n\t\t\tif(w>j)continue;\n\t\t\tint len=j+i*2;\n\t\t\tint gap=len+1;\n\t\t\tlen=n-len;\n\t\t\tif(len<0)continue;\n\t\t\tif(j==w)continue;\n\t\t\taddto(ans,mul(C.C(j,w),C.C(len+gap-1,len)));\n\t\t\tlong long int tt=ans;\n\t\t\t//cerr<<i<<\" \"<<j<<\" \"<<tt-tmp<<endl;\n\t\t}\n\t}\n\tif(x%2){  //0と2で構成される\n\t\tdp2[0][0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<MAX_X;j++){\n\t\t\t\tif(dp2[i][j]==0)continue;\n\t\t\t\taddto(dp2[i+1][j+2],dp2[i][j]);\n\t\t\t\taddto(dp2[i+1][j],dp2[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=MAX_X-1;i>=x;i--){\n\t\t\taddto(ans,dp2[n][i]);\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<MAX_X;j++){\n\t\t\tif(dp[i][j]==0)continue;\n\t\t\taddto(dp[i+1][j+1],dp[i][j]);\n\t\t\taddto(dp[i+1][j+2],dp[i][j]);\n\t\t\taddto(dp[i+1][j],dp[i][j]);\n\t\t}\n\t}\n\tfor(int i=x-1;i>=0;i--){\n\t\taddto(ans,dp[n][i]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3e3 + 5;\nconst int P = 998244353;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); }\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint binom[MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint getans(int n, int x) {\n\tint ans = 0;\n\tif (2 * n < x || x % 2 == 1) ans = 1;\n\tfor (int i = n; i <= 2 * n - 1; i++) {\n\t\tif (i < x) update(ans, binom[n][i - n]);\n\t\telse {\n\t\t\tif ((i - x) % 2 == 0) continue;\n\t\t\tint cnt = (i - x + 1) / 2;\n\t\t\tif (2 * cnt >= n) continue;\n\t\t\tint rp = n - 2 * cnt, rs = i - 4 * cnt;\n\t\t\tif (rs >= rp && rs <= 2 * rp) update(ans, binom[rp][rs - rp]);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tint n, x; read(n), read(x);\n\tfor (int i = 0; i <= n; i++) {\n\t\tbinom[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tbinom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % P;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\t\tupdate(ans, 1ll * binom[n][i] * getans(n - i, x) % P);\n\twriteln(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing ui64 = uint_fast64_t;\nusing db = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)1024;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028841971;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 998244353LL\n#define stdout_precision 10\n#define stderr_precision 5\n#define itr(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritr(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nstruct setupper {\n    setupper() {\n        if(iostream_untie) {\n            ios::sync_with_stdio(false);\n            std::cin.tie(nullptr);\n            std::cout.tie(nullptr);\n            std::cerr.tie(nullptr);\n        }\n        std::cout << fixed << setprecision(stdout_precision);\n        std::cerr << fixed << setprecision(stderr_precision);\n#ifdef LOCAL\n        if(!freopen(\"input.txt\",\"rt\",stdin)) {\n            cerr << \"Failed to open the input file.\\n\"; exit(EXIT_FAILURE);\n        }\n        // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n        //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n        // }\n        // std::cerr << \"\\n---stderr---\\n\";\n        // auto print_atexit = []() {\n        //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n        //     std::cerr << \"------------\\n\";\n        // };\n        // atexit((void(*)())print_atexit);\n        // atexit((void(*)())fclose(stdin));\n#endif\n    }\n} __setupper;\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T, class U> static bool chmax(T &x, const U &y) { return x < y ? x = y,true : false; }\n    template <class T, class U> static bool chmin(T &x, const U &y) { return x > y ? x = y,true : false; }\n};\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> T maxf(const T &x, const T &y) { return max(x,y); }\nbool bit(i64 n, uint8_t e) { return (n >> e) & 1; }\ni64 mask(i64 n, uint8_t e) { return n & ((1 << e) - 1); }\nint ilog(uint64_t x, uint64_t b = 2) { return x ? 1 + ilog(x / b,b) : -1; }\ntemplate <class F> i64 binry(i64 ok, i64 ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        i64 mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class A> void cmprs(A ary[], size_t n) {\n    vector<A> tmp(ary,ary + n);\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(A *i = ary; i != ary + n; ++i) *i = l_bnd(all(tmp),*i) - begin(tmp);\n}\ntemplate <class T> void cmprs(vector<T> &v) {\n    vector<T> tmp = v; sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(auto i = begin(v); i != end(v); ++i) *i = l_bnd(all(tmp),*i) - begin(tmp);\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n/* The main code follows. */\n\n\n/* The snippet starts here. */\nnamespace Calcfn {\n    #ifndef mod\n        #define mod 1000000007LL\n    #endif\n    struct modint {\n        int x;\n        constexpr modint() : x(0) {}\n        constexpr modint(int_fast64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n        constexpr modint &operator+=(const modint &p) {\n            if((x += p.x) >= mod) x -= mod;\n            return *this;\n        }\n\n        constexpr modint &operator-=(const modint &p) {\n            if((x += mod - p.x) >= mod) x -= mod;\n            return *this;\n        }\n\n        constexpr modint &operator*=(const modint &p) {\n            x = (int) (1LL * x * p.x % mod);\n            return *this;\n        }\n\n        constexpr modint &operator/=(const modint &p) {\n            *this *= inverse(p);\n            return *this;\n        }\n\n        constexpr modint operator-() { return modint(-x); }\n\n        constexpr modint operator+(const modint &p) { return modint(*this) += p; }\n\n        constexpr modint operator-(const modint &p) { return modint(*this) -= p; }\n\n        constexpr modint operator*(const modint &p) { return modint(*this) *= p; }\n\n        constexpr modint operator/(const modint &p) { return modint(*this) /= p; }\n\n        constexpr bool operator==(const modint &p) { return x == p.x; }\n\n        constexpr bool operator!=(const modint &p) { return x != p.x; }\n\n        constexpr bool operator!() { return !x; }\n\n        constexpr bool operator>(const modint &p) { return x > p.x; }\n\n        constexpr bool operator<(const modint &p) { return x <  p.x; }\n\n        constexpr bool operator>=(const modint &p) { return x >= p.x; }\n\n        constexpr bool operator<=(const modint &p) { return x <= p.x; }\n\n        constexpr static modint inverse(const modint &p) {\n            int a = p.x, b = mod, u = 1, v = 0;\n            while(b > 0) {\n                int t = a / b;\n                a -= t * b;\n                a ^= b ^= a ^= b;\n                u -= t * v;\n                u ^= v ^= u ^= v;\n            }\n            return modint(u);\n        }\n\n        constexpr static modint pow(modint p, uint_fast64_t e) {\n            if(!e) return 1;\n            if(!p) return 0;\n            return pow(p * p, e >> 1) * (e & 1 ? p : 1);\n        }\n\n        friend ostream &operator<<(ostream &s, const modint &p) { return s << p.x; }\n\n        friend istream &operator>>(istream &s, modint &p) {\n            uint_fast64_t x;\n            p = modint((s >> x,x));\n            return s;\n        }\n    };\n\n    constexpr static int N = 2e5 + 2e4, N_max = 2e6 + 2e5;\n\n    struct impl {\n        int_fast64_t fact_[N + 1],invfact_[N + 1],inv_[N + 1];\n\n        constexpr impl() : fact_(),invfact_(),inv_() {\n            fact_[0] = 1;\n            for(int i = 1; i <= N; ++i) fact_[i] = fact_[i - 1] * i % mod;\n            inv_[1] = 1;\n            for(int i = 2; i <= N; ++i) inv_[i] = mod - inv_[mod % i] * (mod / i) % mod;\n            invfact_[0] = 1;\n            for(int i = 1; i <= N; ++i) invfact_[i] = invfact_[i - 1] * inv_[i] % mod;\n        }\n    };\n    constexpr static impl impl_exe;\n\n    int_fast64_t _dyn_fact[N_max + 1];\n    int_fast64_t _dyn_inv[N_max + 1];\n    int_fast64_t _dyn_invfact[N_max + 1];\n\n    static int_fast64_t dyn_fact(int x) {\n        assert(x <= N_max);\n        if(x < 0) return 0;\n        static size_t _size = 1;\n        for(size_t &i = _size; i <= x; ++i) {\n            if(i <= N) _dyn_fact[i] = impl_exe.fact_[i];\n            else _dyn_fact[i] = _dyn_fact[i - 1] * i % mod;\n        }   \n        return _dyn_fact[x];\n    }\n\n    static int_fast64_t dyn_invfact(int x) {\n        assert(x <= N_max);\n        if(x < 0)  return 0;\n        static size_t _size = 1;\n        for(size_t &i = _size; i <= x; ++i) {\n            if(i <= N) {\n                _dyn_inv[i] = impl_exe.inv_[i];\n                _dyn_invfact[i] = impl_exe.invfact_[i];\n            } else {\n                _dyn_inv[i] = mod - _dyn_inv[mod % i] * (mod / i) % mod;\n                _dyn_invfact[i] = _dyn_invfact[i - 1] * _dyn_inv[i] % mod;\n            }\n        }\n        return _dyn_invfact[x];\n    }\n\n    static modint fact(int x) {\n        if(x > N) return dyn_fact(x);\n        return x >= 0 ? impl_exe.fact_[x] : 0;\n    }\n\n    static modint invfact(int x) {\n        if(x > N) return dyn_invfact(x);\n        return x >= 0 ? impl_exe.invfact_[x] : 0;\n    }\n\n    static modint comb(int x, int y) {\n        return fact(x) * invfact(y) * invfact(x - y);\n    }\n\n    static modint perm(int x, int y) {\n        return comb(x,y) * fact(y);\n    }\n\n    constexpr static int_fast64_t gcd(int_fast64_t a, int_fast64_t b) {\n        if(!b) return a > 0 ? a : -a; return gcd(b, a % b);\n    }\n\n    constexpr static int_fast64_t lcm(int_fast64_t a, int_fast64_t b) {\n        if(a | b) return a / gcd(a, b) * b; return 0;\n    }\n\n    constexpr static int_fast64_t ext_gcd(int_fast64_t a, int_fast64_t b, int_fast64_t &x, int_fast64_t &y) {\n        int_fast64_t d = a;\n        if (b) d = ext_gcd(b, a % b, y, x), y -= (a / b) * x;\n        else x = 1, y = 0;\n        return d;\n    }\n}\nusing Calcfn::modint;\nusing Calcfn::fact;\nusing Calcfn::perm;\nusing Calcfn::comb;\n/* The snippet ends here. */\n\n\nint n,x;\nmodint dp[3010][6010];\nmodint f[3010][3010];\nmodint ans;\n\nsigned main() {\n    cin>>n>>x;\n\n    {\n        dp[0][0]=1;\n        rep(i,n) {\n            rep(j,x) {\n                if(dp[i][j] == 0) continue;\n                rep(k,3) {\n                    dp[i+1][j+k]+=dp[i][j];\n                }\n            }\n        }\n        rep(j,x) {\n            ans+=dp[n][j];\n        }\n        //dump(ans);\n    }\n\n    for(int i=1; i<=n; i++) {\n        int num2=x+1-i;\n        int num1=i-num2;\n        if(num1<=0 || num2<=0) continue;\n\n        for(int j=i-1; j>=2; --j) {\n            f[i][j]=comb(i-j-1,num1-1);\n        }\n\n        for(int j=i-1; j>0; --j) {\n            f[i][j]+=f[i][j+1];\n        }\n    }\n\n    for(int i=1; i<=n; ++i) {\n        modint tmp;\n        for(int k=i; k; --k) {\n            if(k<=i-k+1) break;\n            tmp+=f[k][i-k+2];\n        }\n        if(i*2>x && x%2==1) tmp+=1;\n        //dump(i,tmp);\n        ans+=tmp*comb(n,i);\n    }\n\n    esc(ans);    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void update(int &x,ll y) {\n  x=(x+y)%MOD;\n}\n\nint C[6005][6005],f[2][2][6005][6005];\n\nvoid pre(int n) {\n  for(int i=0;i<=n;i++) C[i][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n  for(int t1=0;t1<2;t1++) {\n  \tf[t1][t1][0][0]=1;\n  \tfor(int i=0;i<n;i++)\n  \t  for(int j=0;j<=i;j++) {\n  \t  \t  update(f[t1][1][i+1][j+1],f[t1][0][i][j]);\n  \t  \t  update(f[t1][0][i+1][j],f[t1][1][i][j]);\n  \t  \t  update(f[t1][1][i+1][j+1],f[t1][1][i][j]);\n\t\t}\n  }\n}\n\nbool in[6005];\n\nint dp(int n,int m,int k) {\n  if (n<m) {\n  \tint ans=0;\n  \tfor(int j=0;j<n;j++) {\n  \t  update(ans,(ll)f[1][0][n-1][j]*C[k][j+1]);\n  \t  update(ans,(ll)f[1][1][n-1][j]*C[k][j+1]);\n    }\n    return ans;\n  }\n  else if (2*m>n) {\n    memset(in,0,sizeof(in));\n    in[m]=0;in[0]=1;\n    for(int j=m+1;j<=n;j++) {\n  \t  in[j]=(in[j-1]^1);\n  \t  in[j-m]=(in[j]^1);\n    }\n    if (!in[n]) return 0;\n    int s=0;\n    for(int i=1;i<=n;i++) s+=in[i];\n    int len=m-(n-m)-1,ans=0;\n    for(int j=0;j<=len;j++) {\n  \t  if (in[m]) update(ans,(ll)f[in[n-m]][0][len][j]*C[k][j+s]);\n  \t  update(ans,(ll)f[in[n-m]][1][len][j]*C[k][j+s]);\n    }\n    return ans;\n  }\n  else return ((m&1)&&!(n&1))?C[k][n>>1]:0;\n}\n\nint main() {\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  pre(2*n);\n  int ans=0;\n  for(int i=1;i<=2*n;i++)\n    update(ans,dp(i,m,n));\n  printf(\"%d\\n\",(ans+1)%MOD);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int mod = 998244353;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nconst int maxN = 3005;\nint c[2 * maxN][2 * maxN];\nint x, n;\nint f[2 * maxN];\nint dp[2 * maxN][2 * maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> x;\n    c[0][0] = 1;\n    for (int i = 1; i < maxN; i++) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; j++) {\n            c[i][j] = sum(c[i - 1][j], c[i - 1][j - 1]);\n        }\n    }\n    dp[0][0] = 1;\n    for (int i = 0; i + 1 <= n; i++) {\n        for (int j = 0; j <= 2 * i + 2; j++) {\n            dp[i + 1][j + 1] = sum(dp[i + 1][j + 1], dp[i][j]);\n            dp[i + 1][j + 2] = sum(dp[i + 1][j + 2], dp[i][j]);\n        }\n    }\n    for (int t = x + 1; t <= 2 * n; t++) {\n        int k1 = (t - x + 1) / 2;\n        if (t % 2 == x % 2) continue;\n        if (x % 2 == 0 && 2 * k1 >= x) continue;\n        if (2 * k1 + 2 * k1 >= t) {\n            if (x % 2 == 0) continue;\n            if (t % 2 != 0) continue;\n            f[t / 2] += 1;\n            if (f[t / 2] >= mod) f[t / 2] -= mod;\n            continue;\n        }\n        int le = t - 4 * k1;\n        for (int j = 0; j <= le; j++) {\n            f[j + 2 * k1] = f[j + 2 * k1] + dp[j][le];\n            if (f[j + 2 * k1] >= mod) f[j + 2 * k1] -= mod;\n        }\n    }\n    /*if (x % 2 == 1) {\n        for (int i = (x / 2 + 1); i <= n; i++) {\n            f[i]++;\n        }\n    }\n    else {\n        for (int sum = x + 1; sum <= 2 * x - 1; sum += 2) {\n            f[sum / 2 + 1]++;\n        }\n    }*/\n    int ans = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j < x; j++) {\n            f[i] = sum(f[i], dp[i][j]);\n        }\n        ans = sum(ans, mult(f[i], c[n][i]));\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return a = std::min(a, b), a == b; }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return a = std::max(a, b), a == b; }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse((ll)x.v, (ll)mod)}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % (ll)mod + (ll)mod))} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt<mod>& operator=(const ModInt<mod>& n) { return v = n(), (*this); }\n    ModInt<mod>& operator=(const ll val) { return v = norm(uint(val % (ll)mod + (ll)mod)), (*this); }\n    ModInt<mod> operator+() const { return *this; }\n    ModInt<mod> operator-() const { return make(norm(mod - v)); }\n    ModInt<mod> operator+(const ModInt<mod>& val) const { return make(norm(v + val())); }\n    ModInt<mod> operator-(const ModInt<mod>& val) const { return make(norm(v + mod - val())); }\n    ModInt<mod> operator*(const ModInt<mod>& val) const { return make((uint)((ll)v * val() % (ll)mod)); }\n    ModInt<mod> operator/(const ModInt<mod>& val) const { return *this * inv(val()); }\n    ModInt<mod>& operator+=(const ModInt<mod>& val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ModInt<mod>& val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ModInt<mod>& val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ModInt<mod>& val) { return *this = *this / val; }\n    ModInt<mod> operator+(const ll val) const { return ModInt{v + val}; }\n    ModInt<mod> operator-(const ll val) const { return ModInt{v - val}; }\n    ModInt<mod> operator*(const ll val) const { return ModInt{(ll)v * (val % mod)}; }\n    ModInt<mod> operator/(const ll val) const { return ModInt{(ll)v * inv(val)}; }\n    template <typename I>\n    ModInt<mod> operator^(const I n) const { return power(v, n); }\n    ModInt<mod>& operator+=(const ll val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ll val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ll val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ll val) { return *this = *this / val; }\n    template <typename I>\n    ModInt<mod>& operator^=(const I n) { return (*this) = ((*this) ^ n); }\n    bool operator==(const ModInt<mod>& val) const { return v == val.v; }\n    bool operator!=(const ModInt<mod>& val) const { return not(*this == val); }\n    bool operator==(const ll val) const { return v == norm(uint((ll)mod + val % (ll)mod)); }\n    bool operator!=(const ll val) const { return not(*this == val); }\n    uint operator()() const { return v; }\n};\ntemplate <uint mod>\ninline ModInt<mod> operator+(const ll val, const ModInt<mod>& n) { return n + val; }\ntemplate <uint mod>\ninline ModInt<mod> operator-(const ll val, const ModInt<mod>& n) { return ModInt<mod>{val - (ll)n()}; }\ntemplate <uint mod>\ninline ModInt<mod> operator*(const ll val, const ModInt<mod>& n) { return n * val; }\ntemplate <uint mod>\ninline ModInt<mod> operator/(const ll val, const ModInt<mod>& n) { return ModInt<mod>(val) / n; }\ntemplate <uint mod>\ninline bool operator==(const ll val, const ModInt<mod>& n) { return n == val; }\ntemplate <uint mod>\ninline bool operator!=(const ll val, const ModInt<mod>& n) { return not(val == n); }\ntemplate <uint mod>\ninline std::istream& operator>>(std::istream& is, ModInt<mod>& n)\n{\n    uint v;\n    return is >> v, n = v, is;\n}\ntemplate <uint mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<mod>& n) { return (os << n()); }\n//!============================================================================!//\n//!  8888ba.88ba                 dP     a88888b.                     dP        !//\n//!  88  '8b  '8b                88    d8'   '88                     88        !//\n//!  88   88   88 .d8888b. .d888b88    88        .d8888b. 88d8b.d8b. 88d888b.  !//\n//!  88   88   88 88'  '88 88'  '88    88        88'  '88 88''88''88 88'  '88  !//\n//!  88   88   88 88.  .88 88.  .88    Y8.   .88 88.  .88 88  88  88 88.  .88  !//\n//!  dP   dP   dP '88888P' '88888P8     Y88888P' '88888P' dP  dP  dP 88Y8888'  !//\n//!============================================================================!//\ntemplate <uint mod>\nclass ModComb\n{\npublic:\n    ModComb(const std::size_t N) : f(N + 1, ModInt<mod>(1)), in(N + 1, ModInt<mod>(1)), invf(N + 1, ModInt<mod>(1))\n    {\n        for (uint i = 2; i <= N; i++) { f[i] = f[i - 1] * i, in[i] = (mod - (mod / i)) * in[mod % i], invf[i] = invf[i - 1] * in[i]; }\n    }\n    ModInt<mod> fact(const std::size_t N) const { return f[N]; }\n    ModInt<mod> inv(const std::size_t N) const { return in[N]; }\n    ModInt<mod> invFact(const std::size_t N) const { return invf[N]; }\n    ModInt<mod> perm(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[N - K]; }\n    ModInt<mod> comb(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[K] * invf[N - K]; }\n\nprivate:\n    std::vector<ModInt<mod>> f, in, invf;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    constexpr uint MOD = 998244353;\n    using mint = ModInt<MOD>;\n    int N, X;\n    std::cin >> N >> X;\n    ModComb<MOD> mod(N);\n    mint ans = 0;\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= N; j++) {\n            if (i + j <= N and i + 2 * j < X) { ans += mod.fact(N) * mod.invFact(i) * mod.invFact(j) * mod.invFact(N - i - j); }\n        }\n    }\n    SHOW(ans);\n    if (X % 2 == 1) {\n        for (int i = 0; i <= N; i++) {\n            if (i * 2 > X) { ans += mod.comb(N, i); }\n        }\n    }\n    SHOW(ans);\n    for (int i = 1; 2 * i < N; i++) {\n        const int mid = X - 2 * i - 1;\n        SHOW(i, mid);\n        if (mid <= 0) { break; }\n        for (int l = 1; l + 2 * i <= N and l <= mid; l++) {\n            const int t = mid - l;\n            if (t >= l) { continue; }\n            ans += mod.comb(N, 2 * i + l) * mod.comb(l, t);\n        }\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long mod = 998244353;\nlong long dp[3009][6009];\nlong long nr[3009][3009];\n\nvoid init() {\n\tfor (int i = 0; i <= 3000; i++) {\n\t\tfor (int j = 0; j <= 3000; j++) {\n\t\t\tif (i == 0 || j == 0) nr[i][j] = 1;\n\t\t\telse nr[i][j] = (nr[i - 1][j] + nr[i][j - 1]) % mod;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= 3000; i++) {\n\t\tfor (int j = 0; j <= 6000; j++) {\n\t\t\tdp[i + 1][j + 0] += dp[i][j]; dp[i + 1][j + 0] %= mod;\n\t\t\tdp[i + 1][j + 1] += dp[i][j]; dp[i + 1][j + 1] %= mod;\n\t\t\tdp[i + 1][j + 2] += dp[i][j]; dp[i + 1][j + 2] %= mod;\n\t\t}\n\t}\n}\n\nlong long ncr(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn nr[a - b][b];\n}\n\nlong long solve(int N, int X) {\n\t// パターン A : 合計が X 以下の場合\n\tlong long sum1 = 0;\n\tfor (int i = 0; i < X; i++) { sum1 += dp[N][i]; sum1 %= mod; }\n\n\t// パターン B : 合計が X 以上の場合\n\tlong long sum2 = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 1; j <= N - i; j++) {\n\t\t\t// i : 2 の個数, j : 1 の個数\n\t\t\tif (j >= X || i * 2 + j < X) continue;\n\t\t\tif ((i * 2 + j) % 2 == X % 2) continue;\n\t\t\tlong long d = i - (1LL * ((X - 1) - j) / 2); // 左右に入るべき最小の数\n\t\t\tlong long val = ncr(j + i - 2 * d, j);\n\t\t\tlong long cost = ncr(N, i + j);\n\t\t\t//cout << \"(i, j) = (\" << i << \", \" << j << \") -> val = \" << val << \", cost = \" << cost << \", mul = \" << val * cost << endl;\n\t\t\tsum2 += val * cost;\n\t\t\tsum2 %= mod;\n\t\t}\n\t}\n\n\t// パターン C : 合計が X 以上の場合（全て 0 か 2）\n\tlong long sum3 = 0;\n\tif (X % 2 == 1) {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\t// i : 2 の個数\n\t\t\tif (i * 2 < X) continue;\n\t\t\tlong long cost = ncr(N, i);\n\t\t\tsum3 += cost;\n\t\t\tsum3 %= mod;\n\t\t}\n\t}\n\treturn (sum1 + sum2 + sum3) % mod;\n}\n\nint main() {\n\tinit();\n\tlong long N, X; cin >> N >> X;\n\tcout << solve(N, X) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int MAXN=3011, MAXX=MAXN<<1;\nconst int MOD=998244353;\n\ninline int sum(const int &a, const int &b){\n\treturn (a+b>=MOD)?(a+b-MOD):(a+b);\n}\n\ninline int mul(const int &a, const int &b){\n\treturn (int)((1LL*a*b)%(long long)(MOD));\n}\n\ninline void add(int &a, const int &v){\n\ta+=v;if(a>=MOD)\ta-=MOD;\n}\n\nint N, X;\n\nint Ans=0;\n\nint F[MAXN][MAXX];\n\nint C[MAXN][MAXN];\n\ninline int D(const int &a){\n\treturn C[N][a];\n}\n\nint main(){\n\t\n\tscanf(\"%d%d\", &N, &X);\n\t\n\tfor(int i=0;i<=N;++i){\n\t\tC[i][i]=C[i][0]=1;\n\t\tfor(int j=1;j<i;++j)\n\t\t\tC[i][j]=sum(C[i-1][j-1], C[i-1][j]);\n\t}\n\t\n\tF[0][0]=1;\n\tfor(int i=0;i<N;++i){\n\t\tfor(int j=0;j<X;++j){\n\t\t\tadd(F[i+1][j+1], F[i][j]);\n\t\t\tadd(F[i+1][j+2], F[i][j]);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<=N;++i)\n\t\tfor(int j=0;j<X;++j)\n\t\t\tadd(Ans, mul(F[i][j], D(i)));\n\t\n\tfor(int k=1;(k<<1)<X;++k){\n\t\tfor(int i=0;i<N;++i){\n\t\t\tif(i+(k<<1)<=N){\n\t\t\t\tadd(Ans, mul(F[i][X-(k<<1)-1], D(i+(k<<1))));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(X&1){\n\t\tfor(int k=X;k<=N;++k){\n\t\t\t//printf(\"%d %d\\n\", k, D(k));\n\t\t\tadd(Ans, D(k));\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", Ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nconst int MOD = 998244353;\nconst int N = 3004;\n\nint n, x;\nint calc[N];\nint cnk[N][N];\n\nsigned main()\n{\n    std::cin >> n >> x;\n    calc[0] = 1;\n    for (int i = 0; i <= n; i++)\n    {\n        cnk[i][0] = 1, cnk[i][i] = 1;\n        for (int j = 1; j < i; j++)\n        {\n            cnk[i][j] = (cnk[i - 1][j - 1] + cnk[i - 1][j] >= MOD) ? cnk[i - 1][j - 1] + cnk[i - 1][j] - MOD : cnk[i - 1][j - 1] + cnk[i - 1][j];\n        }\n    }\n    for (int len = 1; len <= n; len++)\n    {\n        for (int summ = len; summ <= 2 * len; summ++)\n        {\n            if (summ < x)\n            {\n                if (summ - len >= 0) calc[len] = calc[len] + cnk[len][summ - len];\n                if (calc[len] >= MOD) calc[len] -= MOD;\n            }\n            else\n            {\n                if (summ <= x || (summ - x + 1) % 2 == 1)\n                {\n                    continue;\n                }\n                int L = (summ - x + 1) / 2;\n                int summa = summ - 4 * L;\n                int dlina = len - 2 * L;\n                if (summa != 2 * dlina)\n                {\n                    if (summa - dlina >= 0) calc[len] = calc[len] + cnk[dlina][summa - dlina];\n                    if (calc[len] >= MOD) calc[len] -= MOD;\n                }\n            }\n        }\n        if (2 * len >= x && x % 2 == 1) calc[len]++;\n    }\n    int ans = 0;\n    for (int i = 0; i <= n; i++)\n    {\n        ans = (ans + 1ll * calc[i] * cnk[n][i]) % MOD;\n    }\n    std::cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\n    N is set to 4e5 but be careful in problems with large constant factor.\n    Setting N in every problem is more effective.\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int mod = 998244353;\n\nconst int N = 10005;\nint fact[N], invfact[N];\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (((ll) x) * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\nvoid pre(){\n\tfact[0] = invfact[0] = 1;\n\tfor(int i = 1;i < N; i++) fact[i] = mul(i, fact[i - 1]);\n\tinvfact[N - 1] = inv(fact[N - 1]);\n\tfor(int i = N - 2; i >= 1; i--) invfact[i] = mul(invfact[i + 1], i + 1);\n\tassert(invfact[1] == 1);\n}\n\ninline int C(int n, int k){\n\tif(n < k || k < 0) return 0;\n\treturn mul(fact[n], mul(invfact[k], invfact[n - k]));\n}\n\nint f[3005][2 * 3005];\nint g[N];\n\ninline int getSum(int m, int i, int j){\n\treturn sub(f[m][j], i <= 1 ? 0 : f[m][i - 2]);\n}\n\nint main(){\n\tpre();\n\tint n, x;\n\tcin >> n >> x;\n\tint ans = 0;\n\tf[0][0] = 1;\n\tg[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 2 * i; j >= 0; j--)\n\t\t\tfor(int k = 1; k <= 2; k++) if(j - k >= 0){\n\t\t\t\tf[i][j] = add(f[i][j], f[i - 1][j - k]);\n\t\t\t\tg[j] = add(g[j], g[j - k]);\n\t\t\t}\n\t}\n\n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = 2; j <= 2 * n; j++) f[i][j] = add(f[i][j - 2], f[i][j]);\n\n\t// total sum < x\n\tfor(int i = 0; i < x; i++) ans = add(ans, g[i]);\n\tfor(int t = 2; t + 1 <= n; t++){\n\t\tfor(int m = 0; m + t + 1 <= n; m++){\n\t\t\tint mn = (t + 1) >> 1;\n\t\t\tint mx = t - 1;\n\t\t\tif(x - 2 * mn - 2 >= 0)\n\t\t\t\tans = add(ans, mul(C(n, m + t + 1), getSum(m, max(0, x - 2 * (mx + 1)), x - 2 * (mn + 1))));\n\t\t}\n\t}\n\tif((x & 1)){\n\t\t// all 2's\n\t\tfor(int t = (x + 1) / 2; t <= n; t++) ans = add(ans, C(n, t));\n\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x)\n{\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int mod=998244353,N=3010;\nvoid Add(int &x,int y) { x=(x+y)%mod; }\nint Pow(int x,int y) {\n\tint res=1;\n\twhile(y) {\n\t\tif(y&1) res=res*(ll)x%mod;\n\t\tx=x*(ll)x%mod,y>>=1;\n\t}\n\treturn res;\n}\nint fac[N],inv[N];\nint C(int n,int m) {\n\tif(n<m) return 0;\n\treturn fac[n]*(ll)inv[m]%mod*inv[n-m]%mod;\n}\nvoid get_fac(int n) {\n\tfac[0]=1; for(int i=1;i<=n;++i) fac[i]=fac[i-1]*(ll)i%mod;\n\tinv[n]=Pow(fac[n],mod-2); for(int i=n;i>=1;--i) inv[i-1]=inv[i]*(ll)i%mod;\n}\nint cal1(int m,int n) { // m¸öÎ»ÖÃ ÓÃ 1,2 ´Õ n \n\treturn C(m,n-m);\n}\nint solve(int n,int X) { // n ¸öÎ»ÖÃ  ²»³öÏÖ x\n\tint ans=0;\n\tfor(int i=0;i<X;++i) Add(ans,cal1(n,i));\n\tif(2*n<X) return ans;\n\t\n\tfor(int i=1;i*2<=X-1;++i) {\n\t\tAdd(ans,cal1(n-i*2,X-1-2*i));\n\t}\n\tif(X%2==1&&X-1<n) Add(ans,1);\n\treturn ans;\n}\nint main() {\n\tint n,X; rd(n),rd(X);\n\tget_fac(n);\n\tint ans=0;\n\tfor(int i=0;i<=n;++i) {\n//\t\tcout<<solve(i,X)<<endl;\n\t\tAdd(ans,C(n,i)*(ll)solve(i,X)%mod);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n#define PI  (3.1415926535)\n\n#define rep(i,n) for(ll i=0LL; i<n; ++i)\n#define srep(i,s,n) for(ll i=s; i<n; ++i)\n#define rrep(i,n) for(ll i=n-1LL; i>=0LL; --i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n        assert(!cin.eof()); \\\n        cin >> x; \\\n        assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T> >;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n         << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n\n\n\n\n\n\n\n// #define MOD   (1000000007LL)\n#define MOD   (998244353LL)\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n    }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n#if !DEBUG\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n    _main();\n    return 0;\n}\n\nvoid solve(ll cnts[3005], const ll dp[3005][6005], ll n, ll x, ll total)\n{\n    if (total < x) {\n        rep (len, n+1) {\n            cnts[len] += dp[len][total];\n            cnts[len] %= MOD;\n        }\n        return;\n    }\n\n    if ((x & 1LL) == (total & 1LL)) return;\n    // if (!(total & 1LL) && (x & 1LL)) cnts[total/2LL]++;\n\n    ll edge_sum = total - (x - 1LL);\n    edge_sum *= 2LL;\n    ll center_sum = total - edge_sum;\n    ll edge_len = edge_sum / 2LL;\n\n    if (center_sum < 0) return;\n\n    rep (center_len, n+1) {\n        ll len = edge_len + center_len;\n        if (len > n) break;\n        assert(center_sum >= 0LL);\n        assert(center_sum <= 6000LL);\n        assert(center_len >= 0LL);\n        assert(center_len <= 3000LL);\n        debug_printf(\"==== len=%lld center_len=%lld center_sum=%lld \"\n                     \"dp[len][center_sum]=%lld\\n\",\n                     len, center_len, center_sum, dp[center_len][center_sum]);\n        cnts[len] += dp[center_len][center_sum];\n        cnts[len] %= MOD;\n        if (center_len && center_len * 2LL == center_sum) cnts[len]--;\n        if (cnts[len] < 0) cnts[len] += MOD;\n    }\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    ll x; llin(x);\n\n    S ll dp[3005][6005];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    srep (len, 1, n+1) {\n        srep (sum, 1, n * 2LL + 1LL) {\n            dp[len][sum] += dp[len-1][sum-1];\n            dp[len][sum] %= MOD;\n            if (sum >= 2LL) dp[len][sum] += dp[len-1][sum-2];\n            dp[len][sum] %= MOD;\n        }\n    }\n    dp[0][0] = 0;\n\n    rep (i, 6) {\n        debug_printf(\"---- dp[%lld]\\n\", i);\n        debug_print(dp[i], 12);\n    }\n\n    S ll cnts[3005] = {};\n    srep (total, 1, 6001) solve(cnts, dp, n, x, total);\n\n    if (x & 1LL) {\n        srep (len, x / 2LL + 1LL, n+1LL) {\n            cnts[len]++;\n            cnts[len] %= MOD;\n        }\n    }\n\n    debug_printf(\"---- cnts\\n\");\n    debug_print(cnts, 16);\n\n    S ll perms[6020];\n    S ll perm_invs[6020];\n    make_perms(perms, perm_invs, 6020, MOD);\n\n    ll ans = 1;\n    rep (len, n+1) {\n        ll cnt = cnts[len];\n        cnt *= perms[n];\n        cnt %= MOD;\n        cnt *= perm_invs[len];\n        cnt %= MOD;\n        cnt *= perm_invs[n-len];\n        cnt %= MOD;\n        ans += cnt;\n        ans %= MOD;\n    }\n\n    debug_printf(\"---- ans\\n\");\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\n#define int long long\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, X, f[N][N << 1], fac[N << 1], inv[N << 1];\n\ninline int C(int x, int y) {\n    return x < y ? 0 : 1LL * fac[x] * inv[y] % Mod * inv[x - y] % Mod;\n}\n\nsigned main() {\n    cin >> n >> X;\n\n    inv[0] = inv[1] = fac[0] = fac[1] = 1;\n    for (int i = 2; i <= n; ++i)\n        fac[i] = 1LL * fac[i - 1] * i % Mod,\n        inv[i] = 1LL * inv[Mod % i] * (Mod - Mod / i) % Mod;\n\n    for (int i = 1; i <= n; ++i)\n        inv[i] = 1LL * inv[i - 1] * inv[i] % Mod;\n\n    f[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < X * 2; ++j)\n            (f[i + 1][j + 1] += f[i][j]) %= Mod,\n            (f[i + 1][j + 2] += f[i][j]) %= Mod;\n\n    long long ans = 1;\n    for (int i = 1; i <= n; ++i) {\n        long long tmp = 0;\n        for (int j = 0; j < X; ++j)\n            (tmp += f[i][j]) %= Mod;\n        for (int j = X + 1; j <= 2 * i; j += 2) {\n            if (j < i) continue;\n            int p = i - (j - X + 1), q = X - 1 - (j - X + 1);\n            if (j >= X * 2) (tmp += (j == (i << 1) ? X & 1 : 0)) %= Mod;\n            else (tmp += (p >= 0 && q >= 0 ? f[p][q] : 0)) %= Mod;\n        }\n        (ans += 1LL * tmp * C(n, i) % Mod) %= Mod;\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<deque>\nusing namespace std;\nnamespace mine\n{\n\ttypedef long long ll;\n\t#define double long double\n\tconst int INF=0x3f3f3f3f;\n\tconst ll LLINF=0x3f3f3f3f3f3f3f3fll;\n\tll qread()\n\t{\n\t\tll ans=0;char c=getchar();int f=1;\n\t\twhile(c<'0' or c>'9') {if(c=='-') f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num)\n\t{\n\t\tif(num<0) {num=-num;putchar('-');}\n\t\tif(num>9) write(num/10);\n\t\tputchar('0'+num%10);\n\t}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);puts(\"\");}\n\t#define FR first\n\t#define SE second\n\t#define MP make_pair\n\t#define pr pair<ll,int>\n\t#define PB push_back\n\t#define vc vector\n\tvoid chmax(int &x,const int y) {x=x>y?x:y;}\n\tvoid chmin(int &x,const int y) {x=x<y?x:y;}\n\tconst int MOD=998244353;\n\tvoid add(int &x,int y){x+=y;if(x>=MOD) x-=MOD;if(x<=-MOD) x+=MOD;}\n\tll qpower(ll x,ll e)\n\t{\n\t\tll ans=1;\n\t\twhile(e)\n\t\t{\n\t\t\tif(e&1) ans=ans*x%MOD;\n\t\t\tx=x*x%MOD;e>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tll inv(ll x){return qpower(x,MOD-2);}\n\tconst int MAX_N=6e3+10;\n\n\tint C[MAX_N][MAX_N];\n\tvoid main()\n\t{\n\t\tC[0][0]=1;for(int i=1;i<MAX_N;i++){C[i][0]=1;for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;}\n\t\t\n\t\tint n=qread(),X=qread();int ans=1;\n\t\tfor(int ln=1;ln<=n;ln++)\n\t\t{\n\t\t\tint now=(X&1 or X>2*ln);\n\t\t\tfor(int sum=ln;sum<=2*ln-1;sum++)\n\t\t\t{\n\t\t\t\tif(sum<X) add(now,C[ln][sum-ln]);\n\t\t\t\telse if((sum-X)&1)\n\t\t\t\t{\n\t\t\t\t\tint cnt=(sum-X+1)/2;if(cnt*2>=ln) continue;\n\t\t\t\t\tadd(now,C[ln-2*cnt][2*ln-sum]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(ans,(ll)now*C[n][ln]%MOD);\n\t\t\t//printf(\"ln=%d now=%d\\n\",ln,now);\n\t\t}\n\t\twrite(ans);\n\t}\n};\nsigned main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\tsrand(time(0));\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type mod_min = 1;\n  static constexpr value_type mod_max = 2147483647;\n  static_assert(mod >= mod_min, \"invalid mod :: too small\");\n  static_assert(mod <= mod_max, \"invalid mod :: too big\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type operator () () const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\ntemplate <class T, std::size_t N>\nclass factorials {\npublic:\n  using value_type = T;\n  static constexpr std::size_t size = N;\n\npublic:\n  std::array<value_type, size + 1> fact{};\n  std::array<value_type, size + 1> fact_inv{};\n\n  factorials() {\n    fact.front() = value_type(1);\n    for (std::size_t i = 1; i <= size; ++i) {\n      fact[i] = fact[i - 1] * value_type(i);\n    }\n    fact_inv.back() = ~fact.back();\n    for (std::size_t i = size; i > 0; --i) {\n      fact_inv[i - 1] = fact_inv[i] * value_type(i);\n    }\n  }\n\n  value_type operator () (std::size_t n, std::size_t r) const {\n    return fact[n] * fact_inv[n - r] * fact_inv[r];\n  }\n\n};\n\nusing modint = modular<998244353>;\nfactorials<modint, 3000> fact;\n\nint main() {\n  int N, X;\n  std::cin >> N >> X;\n  modint ans;\n  for (int one = 0; one <= N; ++one) {\n    for (int two = 0; one + two <= N; ++two) {\n      int sum = one + 2 * two;\n      if (sum < X) {\n        ans += fact(N, one) * fact(N - one, two);\n      }\n      if (sum > X) {\n        if ((sum - (X - 1)) % 2 == 0) {\n          if (sum >= 2 * (X - 1)) {\n            if (one == 0) {\n              ans += fact(N, two);\n            }\n          }\n          else {\n            int mid = 2 * (X - 1) - sum;\n            if (one <= mid) {\n              ans += fact(one + (mid - one) / 2, one) * fact(N, N - one - two);\n            }\n          }\n        }\n      }\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#include <tuple>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\n\nint mod = 998244353;\nint N, X;\nint comb[3001][6001];\nint f[3001][6001];\nint tate[3002][6002];\nint yoko[3002][6002];\n\nint F(int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\treturn f[a][b];\n}\n\nint Tate(int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\treturn tate[a][b];\n}\n\nint Yoko(int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\treturn yoko[a][b];\n}\n\nint calc(int n, int i) {\n\tint j;\n\tint res = 0;\n\t\n\tint a = Tate(n - i, X - 2 - 2 * i);\n\tint b = Tate(n - 2 * i - 1, X - 2 - 2 * i);\n\tint c = Yoko(n - i - 1, X - 2 - 2 * i);\n\tres = (a - b + mod + c) % mod;\n\t\n\t//cout << \"calc(\" << n << \", \" << i << \") = \" << res << endl;\n\treturn res;\n}\n\nint solve(int n) {\n\tint i;\n\tint ret = 0;\n\t\n\tfor (i = 0; i < n; i++) {\t//22…2, i個 + 1 + 何か\n\t\tret += calc(n, i);\n\t\tret %= mod;\n\t}\n\t\n\t//全部2の場合は個別に計算\n\tif (X % 2 == 0) ret += (n * 2 < X);\n\telse ret++;\n\t\n\tret %= mod;\n\treturn ret;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcomb[0][0] = 1;\n\tfor (i = 1; i < 3001; i++) {\n\t\tcomb[i][0] = 1;\n\t\tfor (j = 1; j < 6001; j++) {\n\t\t\tcomb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n\t\t\tcomb[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 3001; i++) {\n\t\tfor (j = i; j <= 2 * i; j++) {\n\t\t\tf[i][j] = comb[i][j - i];\n\t\t}\n\t}\n\t\n\tfor (j = 0; j < 6001; j++) {\n\t\ttate[0][j] = 0;\n\t\tfor (i = 1; i < 3002; i++) {\n\t\t\ttate[i][j] = tate[i - 1][j] + f[i - 1][j];\n\t\t\ttate[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 3001; i++) {\n\t\tyoko[i][0] = 0;\n\t\tfor (j = 1; j < 6002; j++) {\n\t\t\tyoko[i][j] = yoko[i][j - 1] + f[i][j - 1];\n\t\t\tyoko[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tcin >> N >> X;\n\t\n\tint ans = 0;\n\tfor (i = 0; i <= N; i++) {\t//zero\n\t\tint res = comb[N][i] * solve(N - i);\n\t\tres %= mod;\n\t\tans += res;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y){ \n  T d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1, y = 0;\n  }\n  return d;\n}\n\ntemplate <typename T>\nT modinv(T a, T m){\n  long long x = 0, y = 0;\n  extgcd<long long>(a, m, x, y);\n  x %= m;\n  if(x < 0)x += m;\n  return x;\n}\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)(res * curr % mod);\n    }\n    curr = (T)(curr * curr % mod);\n    tmp >>= 1;\n  }\n\n  return res;\n}\n\nstruct Mint{\n  const static ll default_mod = (ll)(mod);\n  ll MOD = default_mod;\n  ll x = 0;\n  ll get_mod(){\n    return MOD;\n  }\n  Mint(){}\n  Mint(ll x_, ll MOD=default_mod): MOD(MOD){\n    x = x_;\n    x %= MOD;\n    if(x < 0)x += MOD;\n  }\n  Mint(const Mint &m){\n    x = m.x;\n    MOD = m.MOD;\n  }\n  Mint &operator+=(const Mint &y){\n    x = (x + y.x) % MOD;\n    if(x < 0)x += MOD;\n    return *this;\n  }\n  Mint &operator-=(const Mint &y){\n    x = (x - y.x) % MOD;\n    if(x < 0)x += MOD;\n    return *this;\n  }\n  Mint &operator*=(const Mint &y){\n    x = (x * y.x) % MOD;\n    if(x < 0)x += MOD;\n    return *this;\n  }\n  Mint inverse() const{\n    return Mint(modinv<ll>(x, MOD), MOD);\n  }\n  Mint &operator/=(const Mint &y){\n    x = (x * y.inverse().x) % MOD;\n    if(x < 0)x += MOD;\n    return *this;\n  }\n  Mint operator-() const{\n    return Mint(-x, MOD);\n  }\n  Mint operator+(const Mint &y) const{\n    return Mint(*this) += y;\n  }\n  Mint operator-(const Mint &y) const{\n    return Mint(*this) -= y;\n  }\n  Mint operator*(const Mint &y) const{\n    return Mint(*this) *= y;\n  }\n  Mint operator/(const Mint &y) const{\n    return Mint(*this) /= y;\n  }\n  bool operator==(const Mint &y) const{\n    return x == y.x;\n  }\n  bool operator!=(const Mint &y) const{\n    return x != y.x;\n  }\n  Mint pow(long long k) const{\n    long long ret = power<long long>(x, k, MOD);\n    return Mint(ret, MOD);\n  }\n  friend ostream& operator<<(ostream &os, const Mint &m){\n    return os << m.x;\n  }\n  friend istream& operator>>(istream &is, Mint &m){\n    ll t;\n    is >> t;\n    m = Mint(t);\n    return is;\n  }\n  explicit operator long long() const{\n    return x;\n  }\n};\n\nstruct Factorial{\n  int n = 0;\n  static const long long mod_default = 998244353;\n  long long MOD = mod_default;\n  vector<long long> fac;\n  vector<long long> inv_;\n  explicit Factorial(){}\n  explicit Factorial(int n, long long mod_=mod_default): n(n), MOD(mod_){\n    assert(MOD > 0 && n < MOD);\n    fac.resize(n + 1);\n    inv_.resize(n + 1);\n    calc_factorial();\n    calc_inv();\n  }\n  void calc_factorial(){\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++){\n      fac[i] = i * fac[i-1] % MOD;\n    }\n  }\n  void calc_inv(){\n    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--){\n      inv_[i] = (i + 1) * inv_[i+1] % MOD;\n    }\n  }\n  long long& operator[](size_t i){\n    if((int)i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return fac[i];\n  }\n  long long inv(size_t i){\n    if((int)i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return inv_[i];\n  }\n  long long comb(int n, int k){\n    if(n < 0 || k < 0 || n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    res = res * inv_[k] % MOD;\n    return res;\n  }\n  long long perm(int n, int k){\n    if(n < 0 || k < 0 || n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    return res;\n  }\n  long long h(int n, int k){\n    if(n == 0 && k == 0)return 1;\n    return comb(n + k - 1, k);\n  }\n};\n\n\n\nint main(int argc, char const* argv[])\n{\n  ll n, x; cin >> n >> x;\n  Factorial fac(10000);\n  if(x == 1){\n    cout << power<ll>(2LL, n, mod) << endl;\n    return 0;\n  }else if(x == 2){\n    cout << (n + 1) << endl;\n    return 0;\n  }\n  if(x % 2 == 0){\n    Mint res = 0;\n    for(ll i = 0; i <= x - 1; i++){\n      for(ll z = 0; 2 * z <= i; z++){\n        ll y = i - 2 * z;\n        if(y + z <= n){\n          res += Mint(fac.comb(n, y)) * Mint(fac.comb(n - y, z));\n        }\n      }\n    }\n    for(ll i = 1; i < x - 1; i += 2){\n      for(ll z = 0; z <= x - 1 - i - 1; z++){\n        ll y = x - 2 - i - 2 * z;\n        if(((i+1)/2) * 2 + y + z <= n){\n          res += Mint(fac.comb(n, ((i+1)/2) * 2 + y + z)) * Mint(fac.comb(y + z, y));\n        }\n      }\n    }\n    cout << res << endl;\n  }else{\n    Mint res = 0;\n    for(ll i = 0; i <= x - 1; i++){\n      for(ll z = 0; 2 * z <= i; z++){\n        ll y = i - 2 * z;\n        if(y + z <= n){\n          res += Mint(fac.comb(n, y)) * Mint(fac.comb(n - y, z));\n        }\n      }\n    }\n    for(ll i = 1; i < x - 1; i += 2){\n      for(ll z = 0; z <= x - 1 - i - 1; z++){\n        ll y = x - 2 - i - 2 * z;\n        if(((i+1)/2) * 2 + y + z <= n){\n          res += Mint(fac.comb(n, ((i+1)/2) * 2 + y + z)) * Mint(fac.comb(y + z, y));\n        }\n      }\n    }\n    for(ll M = 2 * x; M <= 2 * n; M += 2){\n      (res += Mint(fac.comb(n, M / 2)));\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=3005;\nconst int MOD=998244353;\nint n,X;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac[N],inv[N];\nvoid init(int n=3000)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\treturn fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nlong long f(int n)\n{\n\tlong long res=0;\n\tif(2*n<X||(2*n-X)%2==1) res++;\n\tfor(int S=0;S<2*n;S++)\n\t{\n\t\tif(S<X)\n\t\t{\n\t\t\tif(S>=n) res=(res+C(n,S-n))%MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif((S-X)%2==0) continue;\n\t\t\tint num=(S-X+1)/2;\n\t\t\tint reb=n-2*num,ret=S-2*num*2;\n\t\t\tif(reb<=0||ret<=0) continue;\n\t\t\tif(ret>=reb&&ret<=2*reb) res=(res+C(reb,ret-reb))%MOD;\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&X);\n\tlong long ans=0;\n\tfor(int i=0;i<=n;i++)\n\t\tans=(ans+C(n,i)*f(n-i)%MOD)%MOD;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,X;\nll mo=998244353;\nll comb(ll N_, ll C_) {\n\tconst int NUM_=400001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>X;\n\tint n1,n2;\n\tll ret=0;\n\t\n\t// S<X\n\tfor(n1=0;n1<=N;n1++) for(n2=0;n1+n2<=N&&n1+n2*2<X;n2++) {\n\t\t(ret+=comb(N,n1)*comb(N-n1,n2))%=mo;\n\t}\n\t// all 2\n\tif(X%2) {\n\t\tfor(n2=0;n2<=N;n2++) if(2*n2>X) (ret+=comb(N,n2))%=mo;\n\t}\n\tfor(n2=1;n2<=N&&n2*2<X-1;n2++) {\n\t\tint lef=X-1-2*n2;\n\t\tfor(n1=1;n1<=lef;n1++) {\n\t\t\tif((lef-n1)%2) continue;\n\t\t\tint n22=(lef-n1)/2;\n\t\t\tif(n1+n22+2*n2>N) continue;\n\t\t\t(ret+=comb(n1+n22,n22)*comb(N,n1+n22+2*n2))%=mo;\n\t\t}\n\t}\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(a) int(a.size())\nconst int N=3e3+10;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,x,C[N][N];\n\nint getC(int n,int m) {\n\tif(m<0||n<m) return 0;\n\treturn C[n][m];\n}\n\nint cal(int n) {\n\tint ret=0;\n\tif(2*n<x||x%2==1) ret=1;\n\tfor(int i=n;i<2*n;i++) {\n\t\tif(i<x) ret=(ret+getC(n,i-n))%mod;\n\t\telse {\n\t\t\tif(i%2==x%2) continue;\n\t\t\tint cnt=(i-x+1)/2;\n\t\t\tint rp=n-2*cnt,rs=i-4*cnt;\n\t\t\tret=(ret+getC(rp,rs-rp))%mod;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tfor(int i=0;i<N;i++) {\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tcin>>n>>x;\n\tint ans=0;\n\tfor(int i=0;i<=n;i++) {\n\t\tans=(ans+1ll*getC(n,i)*cal(n-i))%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\n\n\nint dp[3100][3100]={};\n\n\nint yaru(int len,int val){\n\tif(len==0){\n\t\tif(val==0)return 1;\n\t\treturn 0;\n\t}\n\tif(val<len) return 0;\n\tif(val>2*len) return 0;\n\tval-=len;\n\t\n\treturn comb(len,val);\n}\n\nint a[3010]={};\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nmod=998244353;\n \t\n \tint n,x;\n \tcin>>n>>x;\n\t\n \tgya(10000);\n \t\n \tif(x==1){\n \t\tcout<<beki(2,n,mod)<<endl;\n \t\treturn 0;\n \t}\n \t\n \tfor(int i=0;i<3100 && 2*i<=x-1;i++)for(int j=0;j<3100;j++){\n \t\tif(j<i)continue;\n \t\tif(i==j){\n \t\t//\tcout<<\" \"<<i<<\" \"<<j<<endl;\n \t\t\tif(i*2!=x-1) continue;\n \t\t\tdp[i][j]=1;\n \t\t\ta[j+1]+=dp[i][j];\n \t\t\twhile(a[j+1]>=mod)a[j+1]-=mod;\n \t\t//\tcout<<\" \"<<i<<endl;\n \t\t}\n \t\telse{\n \t\t\tint nokori=x-2-2*i;\n \t\t\tif(nokori<0)continue;\n \t\t\tif(2*(j-i-1)<nokori) continue;\n \t\t\tif(j-i-1>nokori)continue;\n \t\t\tdp[i][j]=yaru(j-i-1,nokori);\n \t\t\n// \t\t\tcout<<i<<\" \"<<j<<\" \"<<\" \"<<j-i-1<<\" \"<<nokori<<\" \"<<dp[i][j]<<endl;\n \t\t\n \t\t\ta[j+1]+=dp[i][j];\n \t\t\twhile(a[j+1]>=mod)a[j+1]-=mod;\n \t\t\ta[j+i+1]+=mod-dp[i][j];\n \t\t\twhile(a[j+i+1]>=mod)a[j+i+1]-=mod;\n \t\t}\n //\t\t\tcout<<j+1<<\" \"<<j+1+i<<endl;\n \t//\tfor(int k=0;k<=n;k++)cout<<a[k]<<\" \";\n \t//\tcout<<endl;\n \t}\n \t\n \tfor(int i=1;i<=n;i++){\n \t\ta[i]+=a[i-1];\n \t\twhile(a[i]>=mod)a[i]-=mod;\n \t}\n \t\n \t\n \t\n \tfor(int i=0;i<=n;i++){\n \t\tfor(int j=0;j<x;j++){\n \t\t\ta[i]+=yaru(i,j);\n \t\t\tif(a[i]>=mod)a[i]-=mod;\n \t\t}\n \t}\n \t\n \t\n \tint ans=0;\n \t\n \tfor(int i=0;i<=n;i++){\n \t\tans+=comb(n,i)*a[i]%mod;\n \t}\n \tcout<<ans%mod<<endl;\n \treturn 0;\n  }\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 998244353;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 3e3 + 5;\n\nmi fact[MAX];\nmi ifact[MAX];\nmi len[MAX];\nmi dp[MAX][MAX]; // length, sum\nmi ones[MAX][MAX]; // length, sum\nmi twos[MAX][MAX];// mx 2's, num used\nmi twos_total[MAX][MAX]; //mx 2's used at most in total, num used\nmi rest[MAX][MAX];// mx 2's, num total\nmi rest_total[MAX][MAX];\nmi po[MAX];\nmi choose(int a, int b){\n    if(b < 0) return 0;\n    if(a < b) return 0;\n    return fact[a] * ifact[b] * ifact[a - b];\n}\nint n, x;\n\nint main(){\n    fact[0] = 1; ifact[0] = 1; po[0] = 1;\n    for(int i = 1; i < MAX; i++) fact[i] = fact[i - 1] * i, ifact[i] = ifact[i - 1] / i, po[i] = po[i - 1] * 2;\n    ios_base :: sync_with_stdio(0); cin.tie(0);\n    cin >> n >> x;\n    mi ans = 0;\n    if(x % 2 == 0){\n        for(int i = 0; i < x / 2; i++){\n            ans += choose(n, i);\n        }\n    }\n    else ans += po[n];\n    dp[0][0] = 1;\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            dp[i + 1][j + 2] += dp[i][j];\n            dp[i + 1][j + 1] += dp[i][j];\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            ones[i + 2][j + 2] = dp[i][j];\n        }\n    }\n    ones[1][1] += 1;\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            if(i + j > n) continue;\n            twos[max(i, j)][i + j] += 1;\n\n        }\n    }\n    for(int j = 0; j <= n; j++){\n        for(int i = 1; i <= max(n, x); i++){\n            twos[i][j] += twos[i - 1][j];\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k <= j; k++){\n                rest[i][j] += choose(n, j - k) * twos[i][k];\n            }\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k <= min(i, j); k++){\n                rest_total[i][j] += choose(n, j - k) * (k + 1);\n            }\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            if(ones[i][j] == 0) continue;\n            int mx = min((x - j - 1) / 2, n - 1);\n            if(j % 2 == x % 2){\n                ans += ones[i][j] * rest_total[mx][n - i];\n            }\n            else{\n                ans += ones[i][j] * rest[mx][n - i];\n            }\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  //mint(long long);\n  mint(long long v) : v( (fast == 0 && v < 0) ? (v % MODS[kind] + MODS[kind]) % MODS[kind]  : v % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  if(kind==1) {\n    a.v += b.v;\n    return a;\n\n  }\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  if(kind==1) {\n    a.v += b;\n    return a;\n\n  }\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\nvector<vector<mint<>>> comb_table;\n\n\nmint<> comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return comb_table[N][K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+6);\n  for(int i=0; i<=N; i++) {\n    comb_table[i].resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<i; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n    }\n  }\n  \n}\n\n\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  \n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<0,1> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1);// % MOD ;\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2);// % MOD;\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353; //1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return modInt<mod>(n%mod)/m;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tvector<mint> fib(112345);\n\tfib[0]=1;\n\trep(i,102345){\n\t\tfib[i+1]+=fib[i];\n\t\tfib[i+2]+=fib[i];\n\t}\n\tint n,x;\n\tcin>>n>>x;\n\tmint re=0;\n\trep(s,2*n+1){\n\t\tif(s<x){\n\t\t\trep(one,s+1){\n\t\t\t\tint two=s-one;\n\t\t\t\tif(two<0) continue;\n\t\t\t\tif(two%2) continue;\n\t\t\t\ttwo/=2;\n\t\t\t\tre+=comb(n,one+two)*comb(one+two,one);\n\t\t\t\t//fact[n]*finv[n-one-two]*finv[one]*finv[two];\n\t\t\t}\n\t\t}else{\n\t\t\tif(s==x) continue;\n\t\t\tint r=x-1,l=s-x+1;\n\t\t\tif(l%2) ++l;\n\t\t\tif(r%2!=s%2) --r;\n\t\t\tif(l<r){\n\t\t\t\trep(one,r-l+1){\n\t\t\t\t\tint two=r-l-one;\n\t\t\t\t\tif(two<0) continue;\n\t\t\t\t\tif(two%2) continue;\n\t\t\t\t\ttwo/=2;\n\t\t\t\t\tmint p=comb(one+two,one);\n\t\t\t\t\tre+=p*comb(n,one+two+l/2+(s-r)/2);\n\t\t\t\t}\n\t\t\t\tout(l,r,1);\n\t\t\t}else{\n\t\t\t\tif(x%2==0) continue;\n\t\t\t\tif(s%2) continue;\n\t\t\t\tre+=comb(n,s/2);\n\t\t\t}\n\t\t}\n\t\tout(s,re,1);\n\t}\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << x.v;\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\nvector<mint<>> table;\nvector<vector<mint<>>> comb_table;\n\n\nmint<> comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return table[K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+1);\n  \n  for(int i=0; i<=N; i++) {\n    comb_table.resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<N; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n    }\n  }\n  \n}\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1);\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2);\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n\n    }\n  }\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, fac[N], inv[N], ifac[N];\n\nvoid prework() {\n    fac[0] = inv[1] = ifac[0] = 1;\n    for (int i = 1; i <= n; ++i)\n        fac[i] = 1ll * fac[i - 1] * i % Mod;\n    for (int i = 2; i <= n; ++i)\n        inv[i] = 1ll * inv[Mod % i] * (Mod - Mod / i) % Mod;\n    for (int i = 1; i <= n; ++i)\n        ifac[i] = 1ll * ifac[i - 1] * inv[i] % Mod;\n}\n\ninline int C(int x, int y) {\n    return x < y ? 0 : 1ll * fac[x] * ifac[y] % Mod * ifac[x - y] % Mod;\n}\n\nint x, f[N][N << 1];\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n    cin >> n >> x;\n    prework();\n    f[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < (n << 1); ++j)\n            (f[i + 1][j + 1] += f[i][j]) %= Mod,\n            (f[i + 1][j + 2] += f[i][j]) %= Mod;\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        int tmp = 0;\n        for (int j = 0; j < x; ++j)\n            (tmp += f[i][j]) %= Mod;\n        for (int j = x + 1; j <= (i << 1); j += 2) {\n            if (j < i) continue;\n            int a = i - (j - (x - 1)), b = j - 2 * (j - (x - 1));\n            if (2 * (x - 1) > j) (tmp += (a >= 0 && b >= 0 ? f[a][b] : 0)) %= Mod;\n            else (tmp += ((j == (i << 1)) && (x & 1))) %= Mod;\n        }\n        (ans += 1ll * tmp * C(n, i) % Mod) %= Mod;\n    }\n    cout << ans + 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int mygetchar()\n{\n#ifdef WIN32\n\treturn _getchar_nolock();\n#else\n\treturn getchar_unlocked();\n#endif\n}\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = mygetchar();\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == '-') f = -1;\n\t\tc = mygetchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tx = x * 10 + c - '0';\n\t\tc = mygetchar();\n\t}\n\treturn x * f;\n}\n\nconst int MOD = 998244353;\ninline void add(int &x, int y) {x += y; if (x >= MOD) x -= MOD;}\ninline int inc(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int mul(int x, int y) {return (ll)x * y % MOD;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nconst int MAXN = 2005;\nint n, X, c[MAXN][MAXN], ans = 0;\n\ninline int Solve(int len)\n{\n\tint res = 0;\n\tif (len * 2 > X || X & 1) res = 1;\n\tfor (int i = 0; i < len; i ++)\n\t{\n\t\tif (len + i < X)\n\t\t\tadd(res, c[len][i]);\n\t\telse if ((len + i - X) & 1)\n\t\t{\n\t\t\tint S = len + i, l = (S - X + 1 + 1) / 2;\n\t\t\tif (len > l + l && i >= l + l) add(res, c[len - l - l][i - l - l]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tn = read(), X = read();\n\tfor (int i = 0; i <= n; i ++) c[i][0] = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= i; j ++)\n\t\t\tc[i][j] = inc(c[i - 1][j], c[i - 1][j - 1]);\n\tfor (int i = 0; i <= n; i ++) add(ans, mul(c[n][i], Solve(n - i)));\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst int MAX = 1010000;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main (void){\n\tCOMinit();\n\tlong long int n,x,i,j,k,dp[6005][3005],sans,ans=1,sp,pow[10000];\n\tcin >> n >> x;\n\tdp[1][1]=1;\n\tdp[2][1]=1;\n\tfor(i=2;i<=n;i++){\n\t\tfor(j=2;j<x;j++){\n\t\t\tdp[j][i]=(dp[j-1][i-1]+dp[j-2][i-1])%MOD;\n\t\t}\n\t}\n\tpow[0]=1;\n\tfor(i=1;i<=2*n;i++) pow[i]=(2*pow[i-1])%MOD;\n\tif(x==1){\n\t\tcout << pow[n] << endl;\n\t\treturn 0;\n\t}\n\tfor(i=1;i<=x-1;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tans=(ans+dp[i][j]*COM(n,n-j))%MOD;\n\t\t}\n\t}\n\tsp=((x-1)-(x-1)%2)/2;\n\tfor(i=1;i<=sp;i++){\n\t\tif(2*i==x-1){\n\t\t\tfor(j=i+1;j<=n;j++){\n\t\t\t\tans=(ans+COM(n,j))%MOD;\n\t\t\t}\n\t\t} else if(2*i==x-2){\n\t\t\tfor(k=1;k<=i;k++){\n\t\t\t\tans=(ans+COM(n,i+k+1))%MOD;\n\t\t\t}\n\t\t} else {\n\t\t\tfor(j=1;j<=(x-1);j++){\n\t\t\t\tfor(k=1;k<=i;k++){\n\t\t\t\t\tans=(ans+dp[x-2*i-2][j]*COM(n,i+k+1+j))%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=3025,p=998244353,inf=0x3f3f3f3f;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint ans,n,k,C[N][N];\nvoid check(int &x,int y){x=(x+y<p) ? (x+y) : (x+y-p);}\nint calc(int n,int k){\n\tint res=(k&1)|(n*2<k);\n\tfor (int i=n;i<n*2;i++)\n\tif (i<k) check(res,C[n][i-n]);\n\telse if ((i-k)&1){\n\t\tint cnt=(i-k+1)/2;\n\t\tif (cnt*2>=n) break;\n\t\tint len=n-cnt*2,s=i-cnt*4;\n\t\tif (s>=len) check(res,C[len][s-len]);\n\t}\n\treturn res;\n}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tn=read();k=read();\n\tfor (int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++)\n\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tfor (int i=0;i<=n;i++)\n\tans=(ans+(ll)C[n][i]*calc(i,k))%p;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 3005\n#define Md 998244353\nint Fix(int x){return x<0?x+Md:(x>=Md?x-Md:x);}\nint dp[MN][MN*2];\nint C[MN][MN];\nint n,x;\nint main(){\n\tread(n);read(x);\n\tC[0][0]=1;\n\tlg res=0;\n\tfor(int i=1;i<MN;++i){\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(int j=1;j<i;++j){\n\t\t\tC[i][j]=Fix(C[i-1][j-1]+C[i-1][j]);\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<x;++i){\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tres=Fix(res+1ll*C[n][j]*dp[j][i]%Md);\n\t\t\tdp[j+1][i+2]=Fix(dp[j+1][i+2]+dp[j][i]);\n\t\t\tdp[j+1][i+1]=Fix(dp[j+1][i+1]+dp[j][i]);\n\t\t}\n\t\tres%=Md;\n\t}\n\tif(x&1){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(j*2>x){\n\t\t\t\tres=Fix(res+C[n][j]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp,0,sizeof dp);\n\tdp[1][1]=1;\n\tfor(int i=1;i<=n;++i)C[n][i]=Fix(C[n][i]+C[n][i-1]);\n\tfor(int i=1;i<x;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(((x-i)&1)&&(x-i>2)){\n\t\t\t\tint h=(x-i)/2+j;\n\t\t\t\tres=Fix(res+1ll*Fix(C[n][min(n,h+(x-i)/2)]-C[n][min(n,h)])*dp[j][i]%Md);\n\t\t\t}\n\t\t\tdp[j+1][i+2]=Fix(dp[j+1][i+2]+dp[j][i]);\n\t\t\tdp[j+1][i+1]=Fix(dp[j+1][i+1]+dp[j][i]);\n\t\t}\n\t\tres%=Md;\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n\tusing value_type = ::std::uint_fast64_t;\n\tvalue_type n;\npublic:\n\tModInt() : n(0) {}\n\tModInt(value_type n_) : n(n_ % mod) {}\n\tModInt(const ModInt& m) : n(m.n) {}\n\n\ttemplate<typename T>\n\texplicit operator T() const { return static_cast<T>(n); }\n\tvalue_type get() const { return n; }\n\n\tfriend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n\t\treturn os << a.n;\n\t}\n\n\tfriend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n\t\tvalue_type x;\n\t\tis >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn is;\n\t}\n\n\tbool operator==(const ModInt& m) const { return n == m.n; }\n\tbool operator!=(const ModInt& m) const { return n != m.n; }\n\tModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n\tModInt pow(value_type b) const{\n\t\tModInt ans = 1, m = ModInt(*this);\n\t\twhile(b){\n\t\t\tif(b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tModInt inv() const { return (*this).pow(mod-2); }\n\tModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n\tModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n\tModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n\tModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n\tModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n\tModInt& operator++(){ n += 1; return *this; }\n\tModInt& operator--(){ n -= 1; return *this; }\n\tModInt operator++(int){\n\t\tModInt old(n);\n\t\tn += 1;\n\t\treturn old;\n\t}\n\tModInt operator--(int){\n\t\tModInt old(n);\n\t\tn -= 1;\n\t\treturn old;\n\t}\n\tModInt operator-() const { return ModInt(mod-n); }\n};\n\ntemplate<::std::size_t size, ::std::uint_fast64_t mod=1000000007>\nclass Factorial{\nprivate:\n\tusing value_type = ModInt<mod>;\n\t::std::vector<value_type> fact, inv;\npublic:\n\tFactorial() : fact(size+1, 1), inv(size+1, 1){\n\t\tfor(::std::size_t i = 1; i <= size; ++i){\n\t\t\tfact[i] = fact[i-1] * value_type(i);\n\t\t\tinv[i] = fact[i].inv();\n\t\t}\n\t}\n\n\tvalue_type comb(::std::int64_t a, ::std::int64_t b){\n\t\tif (a < b) return 0;\n\t\tif (a < 0 || b < 0) return 0;\n\t\treturn fact[a]*inv[b]*inv[a-b];\n\t}\n\n\tvalue_type& operator[](::std::size_t k){ return fact[k]; }\n};\n\nconst int64 mod = 998244353;\nusing Mint = ModInt<mod>;\nFactorial<6010, mod> f;\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint64 N, X;\n\tcin >> N >> X;\n\n\tMint res = 0;\n\tREP(i, X) {\n\t\tREP(j, N+1) {\n\t\t\tif (i < j) continue;\n\t\t\tres += f.comb(j, i-j) * f.comb(N, j);\n\t\t}\n\t}\n\tFOR(i, X+1, 2*X) {\n\t\tif ((i-X+1) % 2) continue;\n\t\tint64 use = i-X+1;\n\t\tint64 rest = 2*X-i-2;\n\t\tif (rest < 0 || use > N) continue;\n\t\tREP(j, N-use+1) {\n\t\t\tres += f.comb(j, rest-j) * f.comb(N, use+j);\n\t\t}\n\t}\n\tFOR(i, 2*X, 2*N+1) {\n\t\tif (X % 2 && i % 2 == 0) {\n\t\t\tres += f.comb(N, i/2);\n\t\t}\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 6010;\nll inv[MAX],fact[MAX],fi[MAX],mod = 998244353;\nvoid inverse(){\n\tint i;\n\tinv[1] = 1;\n\tfor(i=2;i<MAX;i++){\n\t\tinv[i] = mod - (mod/i)*inv[mod%i]%mod;\n\t}\n\tfact[0] = fi[0] = 1;\n\tfor(i=1;i<MAX;i++){\n\t\tfact[i] = fact[i-1]*i%mod;\n\t\tfi[i] = (fi[i-1]*inv[i])%mod;\n\t}\n}\n\nll comb(int n,int k){\n\tif(n<0 || k<0 || n<k){\n\t\treturn 0;\n\t}else{\n\t\treturn fact[n]%mod*fi[k]%mod*fi[n-k]%mod;\n\t}\n}\n\nll solve(int x,int s,int t){\n\tint k = s + 2*t;\n\tif(k<x) return comb(s + t,t);\n\tif((k - (x - 1))&1) return 0;\n\tif(s==0) return (x&1);\n\tif(k>=2*(x - 1)) return 0;\n\tint l = k - (x - 1);\n\treturn comb(s + t - l,s);\n}\n\nint main(){\n\tint i,j,n,x;\n\tcin >> n >> x;\n\tinverse();\n\tll ans = 0;\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=n;j++){\n\t\t\tif(i + j>n) continue;\n\t\t\t(ans += solve(x,i,j)*comb(n,(i + j))%mod) %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<int,ii>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 1000000005\n#define MOD 998244353 \n#define N 3005\n#define M 1000003\n#define LOG 20\n#define KOK 250\n#define EPS 0.0000001\nusing namespace std;\n\nint n,x,ans;\nint dp[N][N*2],dp2[N],f[N],inv[N];\n\nint mul(int x,int y) {\n\t\n\treturn (ll)x*y%MOD;\n\n}\n\nint add(int x,int y) {\n\n\tx+=y;\n\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n\n\treturn x;\n\n}\n\nint fe(int x,int y) {\n\n\tif(y==0) return 1;\n\tif(y&1) return mul(x,fe(x,y-1));\n\n\tint res=fe(x,y/2);\n\n\treturn mul(res,res);\n\n}\n\nint fill(int has,int pos) {\n\n\treturn mul(f[has+pos-1],mul(inv[has],inv[pos-1]));\n\n}\n\nint main() {\n\n\tscanf(\"%d %d\",&n,&x);\n\n\tdp[0][0]=1;\n\n\tfor(int i=1;i<=n;i++) {\n\n\t\tfor(int tot=0;tot<=i*2;tot++) {\n\n\t\t\tif(tot>=1) dp[i][tot]=add(dp[i][tot],dp[i-1][tot-1]);\n\t\t\tif(tot>=2) dp[i][tot]=add(dp[i][tot],dp[i-1][tot-2]);\n\n\t\t}\n\n\t}\n\n\tf[0]=inv[0]=1;\n\n\tfor(int i=1;i<=n;i++) {\n\n\t\tf[i]=mul(f[i-1],i);\n\t\tinv[i]=fe(f[i],MOD-2);\n\n\t}\n\n\tfor(int i=0;i<=n;i++) {\n\n\t\tfor(int j=0;j<=x-2;j++) {\n\n\t\t\tans=add(ans,mul(dp[i][j],fill(n-i,i+1)));\n\n\t\t}\n\n\t}\n\t\n\tfor(int i=0;i*2+2<=x;i++) {\n\n\t\tint ws=x-i*2-2;\n\n\t\tfor(int len=0;len+i+1<=n;len++) {\n\n\t\t\tdp2[i+len+1]=add(dp2[i+len+1],dp[len][ws]);\t\n\t\t\tdp2[min(n+1,i*2+len+2)]=add(dp2[min(n+1,i*2+len+2)],-dp[len][ws]);\n\n\t\t}\n\n\t}\n\n\tif(x%2) dp2[(x-1)/2]=add(dp2[(x-1)/2],1);\n\n\tfor(int i=0;i<=n;i++) {\n\n\t\tif(i) dp2[i]=add(dp2[i],dp2[i-1]);\n\n\t\tans=add(ans,mul(dp2[i],fill(n-i,i+1)));\n\n\t}\n\n\tprintf(\"%d\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  // mint(long long);\n  mint(long long v)\n      : v(fast == 0 ? (v < 0 ? (v % MODS[kind] + MODS[kind]) % MODS[kind]\n                             : v % MODS[kind])\n                    : (v)) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  if (kind == 1) {\n    a.v += b.v;\n    return a;\n  }\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  if (kind == 1) {\n    a.v += b;\n    return a;\n  }\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\nvector<vector<mint<>>> comb_table;\n\nmint<> comb(LL N, LL K) {\n  if (N < K) return 0;\n  if (K < 0) return 0;\n  return comb_table[N][K];\n}\n\nvoid init(int N) {\n  comb_table.resize(N + 6);\n  for (int i = 0; i <= N; i++) {\n    comb_table[i].resize(i + 1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for (int j = 1; j < i; j++) {\n      comb_table[i][j] = comb_table[i - 1][j - 1] + comb_table[i - 1][j];\n    }\n  }\n}\n\nvoid solve(long long N, long long X) {\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2 * N + 5, N + 5);\n\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<0, 1> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(100), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nconst Int MOD = 998244353;\nconst Int MAX = 10000;\nInt fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nInt COM(int n, int k) {\n    if (n < k || n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nInt memo[3010][6010];\nInt f(int n, int sum) {\n    if (sum > 2 * n || sum < 0) return 0;\n    if (n == 0) return sum == 0;\n    if (memo[n][sum] != -1) return memo[n][sum];\n    Int ans = f(n - 1, sum) + f(n - 1, sum - 1) + f(n - 1, sum - 2);\n    ans %= MOD;\n    return memo[n][sum] = ans;\n}\nInt g(int k, int n, int m) {\n    Int ans = 0;\n    for (int a = 1; a <= n - k; a++) {\n        ans += COM(n - a - 1, k - 1) * f(a, m);\n        ans %= MOD;\n    }\n    return ans;\n}\nint main() {\n    COMinit();\n    memset(memo, -1, sizeof(memo));\n    int N, X; cin >> N >> X;\n    Int ans = 0;\n    for (int t = 0; t <= N * 2; t++) {\n        if (t < X) {\n            ans += f(N, t);\n            ans %= MOD;\n        } else if (t == X) {\n            // zero\n        } else if (t % 2 != X % 2) {\n            int k = (t - X + 1) / 2;\n            int m = t - k * 4;\n            if (m <= 0 && t % 2 == 0) {\n                ans += COM(N, t / 2);\n            }\n            if (m > 0) {\n                ans += g(k * 2, N, m);\n            }\n            ans %= MOD;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=998244353;\n\nclass comb{\nprivate:\n    ll mod;\n    ll mx;\n    vector<ll> F;\n    vector<ll> FR;\n    \npublic:\n    comb(ll mod=1000000007,ll mx=100000):mod(mod),mx(mx),F(mx+1,1),FR(mx+1,1){\n        mk_F();\n    }\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    void mk_F(){\n        for(ll i=1;i<=mx;i++){F[i]=F[i-1]*i%mod; FR[i]=R(F[i]);}\n    }\n    \n    ll c(ll n,ll k){\n        if(n<0 || k<0){return 0;}\n        if(n<k){return 0;}\n        if(n==k || k==0){return 1;}\n        return F[n]*FR[n-k]%mod*FR[k]%mod;\n    }\n};\n\ncomb C(MOD,1000000);\n\n\nint main(){\n    ll n,x;\n    cin>>n>>x;\n    ll ans=0;\n    for(ll i=0;i<=n;i++){\n        ll cnt=0;\n        for(ll t=i;t<x && t<=2*i;t++){\n            cnt+=C.c(i,t-i);\n        }\n        cnt%=MOD;\n        for(ll t=1;t*2<i && t*2<x-1;t++){\n            cnt+=C.c(i-2*t,x-1-i);\n            if(i-2*t==x-1-i){cnt--;}\n        }\n        if(2*i>=x && (x&1)){cnt++;}\n        cnt%=MOD;\n        ans+=cnt*C.c(n,i)%MOD;\n    }\n    ans%=MOD;\n    ans+=MOD; ans%=MOD;\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair<int, int>\n#define PLL pair<LL, LL>\n#define VI vector<int>\n#define VPII vector<PII>\n#define LL long long\n#define LD long double\n#define f first\n#define s second\n#define MP make_pair\n#define PB push_back\n#define pb pop_back\n#define ALL(c) (c).begin(), (c).end()\n#define SIZ(c) (int)(c).size()\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, b, e) for(int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for(int i = (b); i >= (int)(e); --i)\n\n#define Sim template<class n\nSim, class s> ostream & operator << (ostream &p, pair<n, s> x)\n{return p << \"<\" << x.f << \", \" << x.s << \">\";}\nSim> auto operator << (ostream &p, n y) -> \ntypename enable_if<!is_same<n, string>::value, decltype(y.begin(), p)>::type \n{int o = 0; p << \"{\"; for(auto c: y) {if(o++) p << \", \"; p << c;} return p << \"}\";}\nvoid dor() {cerr << endl;}\nSim, class...s> void dor(n p, s...y) {cerr << p << \" \"; dor(y...);}\nSim, class s> void mini(n &p, s y) {if(p>y) p = y;}\nSim, class s> void maxi(n &p, s y) {if(p<y) p = y;}\n#ifdef DEB\n#define debug(...) dor(__FUNCTION__, \":\", __LINE__, \": \", __VA_ARGS__)\n#else\n#define debug(...)\n#endif \n\n#define I(x) #x \" = \", (x), \" \"\n#define A(a, i) #a \"[\" #i \" = \", i, \"] = \", a[i], \" \"\nconst LL mod = 998244353;\nconst int M = 3003;\n\nint n, x;\nLL dp[M][2 * M], dp2[M][2 * M];\nLL newt[M][M];\n\nint main()\n{\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(NULL);\n\tFOR(i, 0, M - 1)\n\t{\n\t\tnewt[i][0] = 1;\n\t\tFOR(j, 1, i)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j > 0)\n\t\t\t{\n\t\t\t\tnewt[i][j] += newt[i - 1][j - 1];\n\t\t\t}\n\t\t\tnewt[i][j] += newt[i - 1][j];\n\t\t\tnewt[i][j] %= mod;\n\t\t}\n\t}\n\tscanf(\"%d%d\", &n, &x);\n\tLL res = 0;\n\tdp[0][0] = 1;\n\tdp2[0][0] = 1;\n\tFOR(i, 1, n)\n\t{\n\t\tFOR(j, 0, 2 * i)\n\t\t{\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j >= 1)\n\t\t\t\tdp[i][j] += dp[i - 1][j - 1];\n\t\t\tif (j >= 2)\n\t\t\t\tdp[i][j] += dp[i - 1][j - 2];\n\t\t\tdp[i][j] %= mod;\n\t\t\tif (j >= 1)\n\t\t\t\tdp2[i][j] += dp2[i - 1][j - 1];\n\t\t\tif (j >= 2)\n\t\t\t\tdp2[i][j] += dp2[i - 1][j - 2];\n\t\t\tdp2[i][j] %= mod;\n\t\t}\n\t}\n\tFOR(i, 0, 2 * n)\n\t{\n\t\tdebug(i, i - 1, res);\n\t\tif (i < x)\n\t\t{\n\t\t\tres = (res + dp[n][i]) % mod;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == x)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint diff = i - x;\n\t\tif (diff % 2 == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint boki = i - (x - 1);\n\t\tboki *= 2;\n\t\tif (boki >= i)\n\t\t{\n\t\t\tif (x % 2 == 1)\n\t\t\t{\n\t\t\t\t//res = (res + 1) % mod;\n\t\t\t\tres = (res + newt[n][i / 2]) % mod;\n\t\t\t\tdebug(\"ololol\", i, res, n, i / 2, newt[3][2]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint l = n - boki / 2;\n\t\tFOR(j, 0, l)\n\t\t{\n\t\t\tres = (res + dp2[j][i - boki] * newt[n][boki / 2 + j]) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nlong long MOD = 998244353;\n\nvector<long long> fact(3000,0);\nvector<long long> inv_fact(3000,0);\n\nvoid factorial(int a){\n    fact[0]=1;\n    for(int i=1; i<a; i++){\n        fact[i]=i*fact[i-1];\n        fact[i]%=MOD;\n    }\n}\n\nvoid inv_factorial(int a){\n    inv_fact[0]=1;\n    inv_fact[1]=1;\n    for(int i=2; i<a; i++){\n        inv_fact[i]=(MOD*MOD-((MOD/i)%MOD)*(inv_fact[MOD%i]%MOD))%MOD;\n    }\n}\n\nlong long comb(int a, int b){\n    long long ret=fact[a]*inv_fact[fact[b]]%MOD;\n    ret=ret*inv_fact[fact[a-b]]%MOD;\n    //cout << ret << endl;\n    return ret;\n}\n\nvoid cout_vec(vector<long long> &vec){\n    for(int i=0; i<vec.size(); i++){\n        if (i!=0){\n            cout << ' ';\n        }\n        cout << vec[i];\n    }\n    cout << endl;\n}\n\nvoid cout_mat(vector<vector<long long>> &mat){\n    for(int i=0; i<mat.size(); i++){\n        vector<long long> vec = mat[i];\n        cout_vec(mat[i]);\n    }\n}\n\nint main(){\n    int N,X;\n    cin >> N >> X;\n    vector<vector<long long> > dp(N+1, vector<long long>(X,0));\n    dp[0][0]=1;\n    for(int i=0; i<N; i++){\n        for(int j=0; j<X; j++){\n            for(int k=0; k<=2; k++){\n                if(j+k>=X)continue;\n                dp[i+1][j+k]+=(long long) dp[i][j];\n                dp[i+1][j+k]%=MOD;\n            }\n        }\n    }\n    factorial(3000);\n    inv_factorial(3000);\n    //cout_vec(inv_fact);\n    long long ans=0;\n    int h=0;\n    for(int i=0; i<=N; i++){\n        if(h<X){\n            h+=2;\n            continue;\n        }\n        ans+=comb(N,i);\n        ans%=MOD;\n        //cout << ans << endl;\n    }\n\n    int k=2;\n    for(int i=0; i<X; i++){\n        ans+=dp[N][i];\n        ans%=MOD;\n    }\n\n    //cout_mat(dp);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 6555;\nconst int K = 700 ;\nint c[N][N], dp[N][N], a[N];\nint n, x, b[N], res;\nvoid gen(int m){\n    if (m == n + 1){\n        int q = 1;\n        for (int i = 1; q &&  i <= n; i++){\n            int s = 0;\n            for (int j = i;q &&  j <= n; j++){\n                s += b[j];\n                if (s == x) q = 0;\n            }\n        }\n        if (q == 1){\n            for (int i = 1; i <= n; i++) if (b[i] != 0) cout << b[i] << \" \";\n            cout << endl;\n        }\n        res += q;\n        return;\n    }\n    b[m] = 0;\n    gen(m + 1);\n    b[m] = 1;\n    gen(m + 1);\n    b[m] = 2;\n    gen(m + 1);\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> x;\n    //gen(1);\n    c[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        c[i][0] = 1;\n        for (int j = 1; j <= i; j++){\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n        }\n    }\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n + n; j++){\n            dp[i][j] = dp[i - 1][j - 1];\n            if (j > 1) dp[i][j] = (dp[i][j] + dp[i - 1][j - 2]) % mod;\n        }\n    }\n    for (int i = 0; i <= n; i++){\n        for (int j = 0; j < x; j++) a[i] = (a[i] + dp[i][j]) % mod;\n        for (int j = 1; j <= i; j++){\n            int l = j + 1;\n            int r = i - j;\n            if (r < l) continue;\n            if (x - 1 - 2 * j >= 0 && (r - l + 1) * 2 != (x - 1 - 2 * j)) a[i] = (a[i] + dp[r - l + 1][x - 1 - 2 * j]) % mod;\n        }\n        if (i != 0 && 2 * i > x && x % 2 == 1) a[i] = (a[i] + 1) % mod;\n    }\n    int ans = 0;\n    for (int i = 0; i <= n; i++){;\n        ans = (ans + c[n][i] * a[i]) % mod;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mems(a,x) memset(a,x,sizeof(a))\n#define first fi\n#define second se\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353,N=3005;\nint n,x,c[N][N];\nll dp[N][N<<1];\nll C(ll n,ll m)\n{\n    if(m==0||n==m) return 1;\n    if(m==1) return n;\n    if(c[n][m]) return c[n][m];\n    return c[n][m]=(C(n-1,m-1)+C(n-1,m))%mod;\n}\nll solve(int m)\n{\n    ll ans=0;\n    for(int i=0;i<x;i++) (ans+=dp[m][i])%=mod;\n    for(int i=x+1;i<=2*m;i+=2)\n    {\n        int t=max(0,m-(i-(x-1))),s=i-2*(m-t);\n        if(t>=0&&s>=0)\n            (ans+=dp[t][s])%=mod;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&x);\n    dp[0][0]=1;\n    for(int i=0;i<n;i++)\n        for(int j=i;j<=i*2;j++)\n    {\n        (dp[i+1][j+1]+=dp[i][j])%=mod;\n        (dp[i+1][j+2]+=dp[i][j])%=mod;\n    }\n    ll ans=0;\n    for(int i=0;i<=n;i++)\n        ans=(ans+C(n,i)*solve(i))%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, X, f[N][N << 1], fac[N << 1], inv[N << 1];\n\ninline int C(int x, int y) {\n    return x < y ? 0 : 1LL * fac[x] * inv[y] % Mod * inv[x - y] % Mod;\n}\n\nint main() {\n    cin >> n >> X;\n\n    inv[0] = inv[1] = fac[0] = fac[1] = 1;\n    for (int i = 2; i <= n; ++i)\n        fac[i] = 1LL * fac[i - 1] * i % Mod,\n        inv[i] = 1LL * inv[Mod % i] * (Mod - Mod / i) % Mod;\n\n    for (int i = 1; i <= n; ++i)\n        inv[i] = 1LL * inv[i - 1] * inv[i] % Mod;\n\n    f[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < X * 2; ++j)\n            (f[i + 1][j + 1] += f[i][j]) %= Mod,\n            (f[i + 1][j + 2] += f[i][j]) %= Mod;\n\n    long long ans = 1;\n    for (int i = 1; i <= n; ++i) {\n        long long tmp = 0;\n        for (int j = 0; j < X; ++j)\n            (tmp += f[i][j]) %= Mod;\n        for (int j = X + 1; j <= 2 * i; j += 2) {\n            if (j < i) continue;\n            int p = i - (j - X + 1), q = X - 1 - (j - X + 1);\n            if (j < 2 * X && p >= 0 && q >= 0) (tmp += f[p][q]) %= Mod;\n        }\n        if (i >= X && (X & 1))\n            ++tmp;\n        (ans += 1LL * tmp * C(n, i) % Mod) %= Mod;\n    }\n  \n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\n#define int long long\n\nconst int N=6005,mod=998244353;\nint fac[N],inv[N],n,m,ans;\n\nint C(int n,int m){\n\tif(n<m||m<0) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint fpow(int x,int y){\n\tint res=1;\n\tfor(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;\n\treturn res;\n}\n\nvoid init(int n){\n\tfac[0]=1;for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[n]=fpow(fac[n],mod-2);for(int i=n-1;~i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\n\nint calc(int n){\n\tint res=2*n<m||m&1;\n\tfor(int i=n;i<n*2;i++){\n\t\tif(i<m) res=(res+C(n,i-n))%mod;\n\t\telse if(i-m&1){\n\t\t\tint p=i-m+1;\n\t\t\tres=(res+C(n-p,(i-p*2)-(n-p)))%mod;\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tread(n,m);\n\tinit(6e3);\n\tfor(int i=0;i<=n;i++) ans=(ans+C(n,i)*calc(n-i))%mod;\n\twrite(ans);\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\nconst int mod = 998244353;\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<mod>;\n\nint n, x;\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconst int N = 3000;\nFactorial< N * 2, mod > fact;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> x;\n  modint ans = 0;\n  for(int i = 0; i <= n; i++) {\n    for(int c = 1; c <= i - 1; c++) {\n      int k = i - 2 * c;\n      int y = 2 * k - x + 1 + 2 * c;\n      if(k >= 0 && 1 <= y && y <= k) {\n        ans += modint(fact.C(k, y)) * fact.C(n, i);\n      }\n    }\n    dump(ans);\n    if(2 * i < x || (x % 2) == 1) {\n      ans += modint(fact.C(n, i));\n    }\n    dump(ans);\n    for(int t = 0; t <= x - 1; t++) {\n      if(t == 2 * i) continue;\n      int y = 2 * i - t;\n      if(0 <= y && y <= i) {\n        ans += modint(fact.C(i, y)) * fact.C(n, i);\n      }\n    }\n    dump(i, ans);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\nostream &operator<<(ostream &os, pair<ll, ll>&p){\n  return os << p.first << \" \" << p.second;\n}  \ntemplate< int mod >\nstruct ModInt {\n  ll x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD9 >;\nmodint pow2(int64_t n, int64_t x){\n    return modint(n).pow(x);\n}\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing Comb=Combination<modint>;\n\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,x;cin>>n>>x;\n  modint ret=0;\n  Comb comb(10000);\n  rep(i,0,n+1){\n    modint now=0;\n    rep(j,0,i+1){\n      ll k=i-j;//1がj個、2がk個\n      ll s=j+2*k;//総和\n      if(s<x){\n        now+=comb.C(i,j);\n      }\n      else if((s-x)&1){\n        ll need=(s-x+1)/2;//左端、右端から2が連続する必要がある個数\n        ll need2=min(need*2,i);\n        ll len=i-need2;\n        ll p=k-need2;//2の残り数\n        if(len<0||p<0)continue;\n        now+=comb.C(len,p);\n      }\n    }\n    //cout<<i spa now<<endl;\n    ret+=now*comb.C(n,i);\n  }\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 998244353LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n#define MAX_N 1000000\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n\tlong long d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nlong long mod_inverse(long long a, long long m) {\n\tlong long x, y;\n\tif(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n\telse return -1;\n}\nvector<long long> fact(MAX_N+1, INF);\nlong long mod_fact(long long n, long long& e) {\n\tif(fact[0] == INF) {\n\t\tfact[0]=1;\n\t\tif(MAX_N != 0) fact[1]=1;\n\t\tfor(lint i = 2; i <= MAX_N; ++i) {\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t}\n\t}\n\te = 0;\n\tif(n == 0) return 1;\n\tlong long res = mod_fact(n / MOD, e);\n\te += n / MOD;\n\tif((n / MOD) % 2 != 0) return (res * (MOD - fact[n % MOD])) % MOD;\n\treturn (res * fact[n % MOD]) % MOD;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n\tif(n < 0 || k < 0 || n < k) return 0;\n\tlong long e1, e2, e3;\n\tlong long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n\tif(e1 > e2 + e3) return 0;\n\treturn (a1 * mod_inverse((a2 * a3) % MOD, MOD)) % MOD;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, x;\n\tcin >> n >> x;\n\tif(x == 2) {\n\t\tcout << 1 + n << endl;\n\t\treturn 0;\n\t}\n\tlint ans = 1;\n\tFOR(m, 1, n + 1) {\n\t\tif(x == 1) {\n\t\t\tans += mod_comb(n, m); ans %= MOD;\n\t\t\tcontinue;\n\t\t}\n\t\tlint tmp = 0;\n\t\tREP(i, m + 1) {\n\t\t\tif(i * 2 + (m - i) * 1 >= x) break;\n\t\t\ttmp += mod_comb(m, i); tmp %= MOD;\n\t\t}\n\t\tFOR(i, 1, m) {\n\t\t\tif(i < m - i) {\n\t\t\t\tif(2 * i == x - 1) tmp++;\n\t\t\t} else {\n\t\t\t\ttmp += mod_comb(m - 2 * (m - i), x - 1 - 2 * (m - i) - (i - (m - i)));\n\t\t\t\ttmp %= MOD;\n\t\t\t}\n\t\t}\n\t\t// cerr << tmp << endl;\n\t\tans += tmp * mod_comb(n, m); ans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\nusing namespace std;\nconst int mod = 998244353;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return w*s;}\nint n,X,fac[101100],Ifac[101011];\ninline ll ksm (ll x,ll y){ll res=1;while(y){if(y&1) res=res*x%mod;x=x*x%mod;y>>=1;}return res;}\ninline void Init(){\n\tIfac[0]=fac[0]=1;\n\tfor(rint i=1;i<=10000;++i) fac[i]=1ll*fac[i-1]*i%mod;\n\tIfac[10000]=ksm(fac[10000],mod-2);\n\tfor(rint i=9999;i;--i) Ifac[i]=1ll*(i+1)*Ifac[i+1]%mod;\n}\ninline int C(int a,int b){/*debug(a);debug(b);*/if(a<b) return 0;return 1ll*fac[a]*Ifac[b]%mod*Ifac[a-b]%mod;}\ninline int pls(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int get(int len){\n\tint Ans=0;\n\tif(2*len<X||(X%2==1)) Ans=1;\n\tfor(rint i=len;i<=2*len-1;++i){\n\t\tif(i<X) Ans=pls(Ans,C(len,i-len));\n\t\telse {\n\t\t\tif((i-X)%2==0) continue;\n//\t\t\tdebug(i);\n\t\t\tint o=(i-X+1)/2;\n\t\t\tif(2*o>=len) continue;\n\t\t\tint p=len-2*o,q=i-4*o;\n\t\t\tif(q>=p)Ans=pls(Ans,C(p,q-p));\n\t\t}\n\t}\n\treturn Ans;\n}\nint main()\n{\t\n\tn=read(),X=read();\n\tInit();\n\tll Ans=0;\n\tfor(rint i=0;i<=n;++i){\n\t\tAns=pls(Ans,1ll*C(n,i)*get(i)%mod);\n\t}cout<<Ans;\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n\tusing value_type = ::std::uint_fast64_t;\n\tvalue_type n;\npublic:\n\tModInt() : n(0) {}\n\tModInt(value_type n_) : n(n_ % mod) {}\n\tModInt(const ModInt& m) : n(m.n) {}\n\n\ttemplate<typename T>\n\texplicit operator T() const { return static_cast<T>(n); }\n\tvalue_type get() const { return n; }\n\n\tfriend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n\t\treturn os << a.n;\n\t}\n\n\tfriend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n\t\tvalue_type x;\n\t\tis >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn is;\n\t}\n\n\tbool operator==(const ModInt& m) const { return n == m.n; }\n\tbool operator!=(const ModInt& m) const { return n != m.n; }\n\tModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n\tModInt pow(value_type b) const{\n\t\tModInt ans = 1, m = ModInt(*this);\n\t\twhile(b){\n\t\t\tif(b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tModInt inv() const { return (*this).pow(mod-2); }\n\tModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n\tModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n\tModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n\tModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n\tModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n\tModInt& operator++(){ n += 1; return *this; }\n\tModInt& operator--(){ n -= 1; return *this; }\n\tModInt operator++(int){\n\t\tModInt old(n);\n\t\tn += 1;\n\t\treturn old;\n\t}\n\tModInt operator--(int){\n\t\tModInt old(n);\n\t\tn -= 1;\n\t\treturn old;\n\t}\n\tModInt operator-() const { return ModInt(mod-n); }\n};\n\ntemplate<::std::size_t size, ::std::uint_fast64_t mod=1000000007>\nclass Factorial{\nprivate:\n\tusing value_type = ModInt<mod>;\n\t::std::vector<value_type> fact, inv;\npublic:\n\tFactorial() : fact(size+1, 1), inv(size+1, 1){\n\t\tfor(::std::size_t i = 1; i <= size; ++i){\n\t\t\tfact[i] = fact[i-1] * value_type(i);\n\t\t\tinv[i] = fact[i].inv();\n\t\t}\n\t}\n\n\tvalue_type comb(::std::int64_t a, ::std::int64_t b){\n\t\tif (a < b) return 0;\n\t\tif (a < 0 || b < 0) return 0;\n\t\treturn fact[a]*inv[b]*inv[a-b];\n\t}\n\n\tvalue_type& operator[](::std::size_t k){ return fact[k]; }\n};\n\nconst int64 mod = 998244353;\nusing Mint = ModInt<mod>;\nFactorial<6010, mod> f;\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint64 N, X;\n\tcin >> N >> X;\n\n\tMint res = 0;\n\tMint now = 1;\n\tREP(j, N+1) {\n\t\tres += now * f.comb(N, j);\n\t\tnow = now * 2 - f.comb(j, X-1-j) - f.comb(j + 1, X-1-j);\n\t}\n\tFOR(i, X+1, 2*X) {\n\t\tif ((i-X+1) % 2) continue;\n\t\tint64 use = i-X+1;\n\t\tint64 rest = 2*X-i-2;\n\t\tif (rest < 0 || use > N) continue;\n\t\tREP(j, N-use+1) {\n\t\t\tres += f.comb(j, rest-j) * f.comb(N, use+j);\n\t\t}\n\t}\n\tFOR(i, 2*X, 2*N+1) {\n\t\tif (X % 2 && i % 2 == 0) {\n\t\t\tres += f.comb(N, i/2);\n\t\t}\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 3002;\nconst int root = 15311432;\nconst int root_1 = 469870224;\nconst int root_pw = 1<<23;\nconst int mod = 998244353;\n\nint n, x, rev[MAX_N*2], inv[MAX_N*2];\nint pw2[MAX_N], C[MAX_N][MAX_N], f[MAX_N][MAX_N*2], g[MAX_N][MAX_N];\n\nvoid read_input() {\n    cin >> n >> x;\n}\n\nint64_t pw(int n, int k) {\n    if (k==0)\n        return 1;\n    int64_t tmp = pw(n, k/2);\n    if (k%2)\n        return tmp * tmp % mod * n % mod;\n    return tmp * tmp % mod;\n}\n\nvoid NTT(vector<int> &a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n        debug(j);\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        int wlen = invert ? root_1 : root;\n        for (int i = len; i < root_pw; i <<= 1)\n            wlen = (int)(1LL * wlen * wlen % mod);\n\n        for (int i = 0; i < n; i += len) {\n            int w = 1;\n            for (int j = 0; j < len / 2; j++) {\n                int u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);\n                a[i+j] = u + v < mod ? u + v : u + v - mod;\n                a[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;\n                w = (int)(1LL * w * wlen % mod);\n            }\n        }\n    }\n\n    if (invert) {\n        //int n_1 = pw(n, mod-2);\n        int n_1 = inv[n];\n        for (int & x : a)\n            x = (int)(1LL * x * n_1 % mod);\n    }\n}\n\nvoid square(vector<int> &a) {\n    int n = 1;\n    while (n < 2*a.size())\n        n <<= 1;\n    a.resize(n);\n    // PR0(a, a.size());\n\n    NTT(a, false);\n    PR0(a, a.size());\n\n    for (int i=0; i<n; ++i)\n        a[i] = 1LL * a[i] * a[i] % mod;\n\n    NTT(a, true);\n}\n\nvoid init() {\n    int tmp = 1;\n    while (tmp<(n+1)*2)\n        tmp <<= 1;\n\n    inv[1] = 1;\n    for (int i=2; i<=tmp; ++i)\n       inv[i] = mod - 1LL * inv[mod%i] * (mod / i) % mod;\n\n    for (int i=1, j=0; i<tmp; ++i) {\n        int bit = tmp>>1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n        rev[i] = j;\n    }\n    // PR0(rev, tmp);\n\n    for (int i=0; i<=n; ++i)\n        C[i][0] = C[i][i] = 1;\n\n    for (int i=1; i<=n; ++i) {\n        for (int j=1; j<i; ++j)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;\n    }\n\n    pw2[0] = 1;\n    for (int i=1; i<=n; ++i)\n        pw2[i] = pw2[i-1] * 2 % mod;\n\n    f[0][0] = 1;\n\n    for (int l=1; l<=n; ++l) {\n        for (int s=0; s<=x; ++s) {\n            f[l][s] = f[l-1][s];\n            if (s>=1)\n                f[l][s] = (f[l][s] + f[l-1][s-1]) % mod;\n            if (s>=2)\n                f[l][s] = (f[l][s] + f[l-1][s-2]) % mod;\n        }\n    }\n    // debug(f[n][2]);\n}\n\nint case1() {\n    vector<int> h;\n\n    for (int t=0; t<=x/2; ++t) {\n        h.assign(n+1, 0);\n\n        for (int l=0; l<=n; ++l) {\n            if (l<=t)\n                h[l] = pw2[l];\n            else\n                h[l] = (1LL * h[l-1] * 2 - C[l-1][t] + mod) % mod;\n        }\n\n        square(h);\n        // if (t==1)\n        //     PR0(h, n+1);\n\n        for (int l=0; l<=n; ++l)\n            g[l][t] = h[l];\n    }\n    // debug(g[2][1]);\n\n    int res = 0;\n\n    for (int l=0; n-l-2>=0; ++l) {\n        for (int s=(x+1)%2; s+2<=x; s += 2) {\n            // cerr << l << ' ' << s << ' ' << f[l][s] * g[n-l-2][(x-2-s)/2] << '\\n';\n            res = (res + 1LL * f[l][s] * g[n-l-2][(x-2-s)/2]) % mod;\n        }\n    }\n\n    if (x%2==0)\n        res = (res + g[n-1][(x-1)/2]) % mod;\n    else\n        res = (res + pw2[n]) % mod;\n\n    return res;\n}\n\nint case2() {\n    int res = 0;\n\n    for (int s=x%2; s<x; s += 2)\n        res = (res + f[n][s]) % mod;\n\n    return res;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tread_input();\n\tinit();\n\t// debug(case1());\n    // debug(case2());\n\tcout << (case1() + case2()) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nconst ll MOD = 998244353;\nll dp[3001][6001];\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\n\nvector<ll> fact;\nvector<ll> inv_fact;\n\nvoid comb_init(int n) {\n\tfact.resize(n + 1);\n\tinv_fact.resize(n + 1);\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n}\n\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nint main() {\n\tint N, X;\n\tcin >> N >> X;\n\tcomb_init(N);\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < N; i++) for (int j = 0; j <= 2 * i; j++) {\n\t\t(dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n\t\t(dp[i + 1][j + 2] += dp[i][j]) %= MOD;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tll sum = 0;\n\t\tfor (int j = i; j < X; j++) (sum += dp[i][j]) %= MOD;\n\t\tfor (int j = 1; 2 * j <= i; j++) {\n\t\t\tif (X - 1 < 2 * j) break;\n\t\t\t(sum += dp[i - 2 * j][X - 1 - 2 * j]) %= MOD;\n\t\t}\n\t\t(ans += sum * comb(N, i) % MOD) %= MOD;\n\t}\n\tif (X % 2 == 1) {\n\t\tfor (int i = X; i <= N; i++) (ans += comb(N, i)) %= MOD;\n\t}\n\tcout << ans << endl;\n }"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <random>\n#include <stack>\n#include <set>\n#include <unordered_set>\n\n#define bug(x) cout<<\"zdongdebug: \"<<x<<endl;\n#define bug2(x, y) cout<<\"zdongdebug: \"<<x<<\" \"<<y<<endl;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3005;\nconst ll mod = 998244353;\nll c[maxn][maxn];\nll f[maxn][maxn+maxn];\nvoid pd(ll&ret,ll val){\n  ret+=val;\n  ret%=mod;\n}\nvoid init() {\n  f[0][0] = 1;\n  for (int i = 0; i < maxn; i++)c[i][0] = c[i][i] = 1;\n  for (int i = 1; i < maxn; i++)\n    for (int j = 1; j < i; j++) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1])%mod;\n    }\n}\n\nint n,m;\nint sq[maxn];\nint ans;\nvoid dfs(int pos) {\n  if(pos == n) {\n    for(int i=0;i<n;i++){\n      int sum = 0;\n      for(int j=i;j<n;j++){\n        sum+=sq[j];\n        if(sum==m)return;\n      }\n    }\n    ans++;\n    if(ans>mod)ans-=mod;\n    return;\n  }\n  for(int i=0;i<3;i++){\n    sq[pos]=i;\n    dfs(pos+1);\n  }\n}\n\nint main() {\n#ifdef suiyuan2009\n  freopen(\"/Users/suiyuan2009/CLionProjects/icpc/input.txt\", \"r\", stdin);\n#endif\n  init();\n  cin>>n>>m;\n // dfs(0);\n // bug(ans)\n  for(int i=1;i<=n;i++) {\n    for (int j = 1; j < m; j++) {\n      if (2 * i < j)break;\n      f[i][j] = c[i][2 * i - j];\n    }\n    if((m&1)&&2*i>m)f[i][2*i]=1;\n    for (int j = 1; j + j <i&&(j+j<m-1);j++) {\n      if(m-1+2*j!=2*i)\n      pd(f[i][m-1+2*j],f[i-j-j][m-1-2*j]);\n    }\n  }\n  //bug(f[1][2])\n  ll ret = 1;\n  for(int i=1;i<=n;i++){\n    ll sum = 0;\n    for(int j=1;j<=i+i;j++)pd(sum, f[i][j]);\n    pd(ret, sum*c[n][i]%mod);\n  }\n  cout<<ret%mod<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nlong long *fact, *inv;\n\ntemplate <class T>\nT pow(T x, T n, T mod) {\n    T ret = 1;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <class T>\nT inverse(T x, T p) { return pow(x, p - 2, p); }\n\nvoid init_factorial(int n, long long mod) {\n    fact = new long long[n + 1];\n    inv = new long long[n + 1];\n    fact[0] = 1;\n    for (long long i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    inv[n] = inverse(fact[n], mod);\n    for (long long i = n; i > 0; i--) inv[i - 1] = inv[i] * i % mod;\n}\n\nint main() {\n    i64 n, x;\n    constexpr i64 mod = 998244353;\n    std::cin >> n >> x;\n    init_factorial(n, mod);\n    std::vector<std::vector<i64>> dp(n + 1, std::vector<i64>(2 * n + 10));\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) for (int j = 0; j <= 2 * n; j++) {\n        dp[i][j + 1] = (dp[i][j + 1] + dp[i - 1][j]) % mod;\n        dp[i][j + 2] = (dp[i][j + 2] + dp[i - 1][j]) % mod;\n    }\n    i64 ret = 0;\n    for (int i = 0; i <= n; i++) for (int j = 0; j < x; j++) {\n        ret = (ret + dp[i][j] * fact[n] % mod * inv[i] % mod * inv[n - i] % mod) % mod;\n    }\n    for (int i = 1; i * 2 <= x - 1; i++) for (int j = i; j + i <= n; j++) {\n        ret = (ret + dp[j - i][x - i * 2 - 1] * fact[n] % mod * inv[j + i] % mod * inv[n - j - i] % mod) % mod;\n    }\n    if (x % 2) {\n        for (int i = x; i <= n; i++) {\n            ret = (ret + fact[n] * inv[i] % mod * inv[n - i] % mod) % mod;\n        }\n    }\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=998244353;\n\nint N;\nint X;\nLL conv[6145];\nLL memo[6145][6145];\nLL num[6145][6145];\n\nLL Comb(int n, int r) {\n  if (n < 0 || r < 0 || n < r) return 0;\n  if (n == r || r == 0) return 1;\n  if (memo[n][r] != -1) return memo[n][r];\n  return memo[n][r] = (Comb(n-1, r) + Comb(n-1, r-1)) % MOD;\n}\n\nLL f(int s, int t) {\n  return Comb(s+t, t);\n}\n\nLL Conv(int l, int r) {\n  LL ret = conv[r];\n  if (l > 0) ret += MOD-conv[l-1];\n  return ret%MOD;\n}\n\nint main() {\n  fill(memo[0], memo[6145], -1);\n\n  scanf(\"%d%d\", &N, &X);\n\n  rep(i, N) {\n    conv[i] = f(N-i, i);\n    if (i > 0) conv[i] = (conv[i-1]+conv[i]) % MOD;\n  }\n\n  num[0][0] = 1;\n  reps(k, 1, N+1) {\n    rep(S, X+1) {\n      if (S >= 2) num[k][S] += num[k-1][S-2];\n      if (S >= 1) num[k][S] += num[k-1][S-1];\n      num[k][S] += num[k-1][S];\n      num[k][S] %= MOD;\n    }\n  }\n\n  LL ans = 0;\n  rep(S, X) {\n    ans += num[N][S];\n    ans %= MOD;\n  } \n\n  rep(k, N+1) {\n    if (X-3-2*k-1 >= 0) {\n      int d = X-3-2*k-1;\n      rep(g, N+1) {\n        if (k+g+3 > N) break;\n        int r = max(N-(k+g+3), 0);\n        int l = max(N-(2*k+g+2), 0);\n        ans += num[g][d] * Conv(l, r);\n        ans %= MOD;\n      }\n    }\n\n    if (X-2-2*k-1 >= 0) {\n      int d = X-2-2*k-1;\n      rep(g, N+1) {\n        if (k+g+3 > N) break;\n        int r = max(N-(k+g+3), 0);\n        int l = max(N-(2*k+g+2), 0);\n        ans += num[g][d] * Conv(l, r);\n        ans %= MOD;\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 10005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nint N,X;\nint dp[3005][6005],fac[6005],invfac[6005];\nint f[3005];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\n    }\n    return res;\n}\nint C(int n,int m) {\n    if(n < m) return 0;\n    return mul(fac[n],mul(invfac[m],invfac[n - m]));\n}\nvoid Solve() {\n    read(N);read(X);\n    dp[0][0] = 1;\n    fac[0] = 1;\n    for(int i = 1 ; i <= 2 * N ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[2 * N] = fpow(fac[2 * N],MOD - 2);\n    for(int i = 2 * N - 1 ; i >= 0 ; --i) {\n\tinvfac[i] = mul(invfac[i + 1],i + 1);\n    }\n    int ans = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n\tfor(int j = 2 * i ; j >= 1 ; --j) {\n\t    if(j >= 2) update(dp[i][j],dp[i - 1][j - 2]);\n\t    if(j >= 1) update(dp[i][j],dp[i - 1][j - 1]);\n\t}\n    }\n    for(int i = 0 ; i <= N ; ++i) {\n\tfor(int j = 0 ; j <= 2 * i ; ++j) {\n\t    if(j < X) update(ans,mul(dp[i][j],C(N,i)));\n\t}\n    }\n    for(int i = 1 ; i < N ; ++i) {\n\tint t = i * 2 + 1;\n\tif(t >= X) break;\n\tfor(int j = 0 ; j <= N ; ++j) {\n\t    if(i + j + 2 <= N) {\n\t\tupdate(f[i + j + 2],dp[j][X - 1 - t]);\n\t\tif(i + j + i + 2 <= N) update(f[i + j + i + 2],MOD - dp[j][X - 1 - t]);\n\t    }\n\t}\n    }\n    for(int i = 1 ; i <= N ; ++i) f[i] = inc(f[i],f[i - 1]);\n    for(int i = 1 ; i <= N ; ++i) {\n\tupdate(ans,mul(f[i],C(N,i)));\n    }\n    if(X & 1) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    if(i * 2 > X) update(ans,C(N,i));\n\t}\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 3002;\nconst int root = 15311432;\nconst int root_1 = 469870224;\nconst int root_pw = 1<<23;\nconst int mod = 998244353;\n\nint n, x, rev[MAX_N*4], inv[MAX_N*4];\nint pw2[MAX_N], C[MAX_N][MAX_N], f[MAX_N][MAX_N*2], g[MAX_N][MAX_N];\n\nvoid read_input() {\n    cin >> n >> x;\n}\n\nint64_t pw(int n, int k) {\n    if (k==0)\n        return 1;\n    int64_t tmp = pw(n, k/2);\n    if (k%2)\n        return tmp * tmp % mod * n % mod;\n    return tmp * tmp % mod;\n}\n\nvoid NTT(vector<int> &a, bool invert) {\n    int n = a.size();\n\n    for (int i = 1, j = 0; i < n; i++) {\n        int bit = n >> 1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n        debug(j);\n\n        if (i < j)\n            swap(a[i], a[j]);\n    }\n\n    for (int len = 2; len <= n; len <<= 1) {\n        int wlen = invert ? root_1 : root;\n        for (int i = len; i < root_pw; i <<= 1)\n            wlen = (int)(1LL * wlen * wlen % mod);\n\n        for (int i = 0; i < n; i += len) {\n            int w = 1;\n            for (int j = 0; j < len / 2; j++) {\n                int u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);\n                a[i+j] = u + v < mod ? u + v : u + v - mod;\n                a[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;\n                w = (int)(1LL * w * wlen % mod);\n            }\n        }\n    }\n\n    if (invert) {\n        //int n_1 = pw(n, mod-2);\n        int n_1 = inv[n];\n        for (int & x : a)\n            x = (int)(1LL * x * n_1 % mod);\n    }\n}\n\nvoid square(vector<int> &a) {\n    int n = 1;\n    while (n < 2*a.size())\n        n <<= 1;\n    a.resize(n);\n    // PR0(a, a.size());\n\n    NTT(a, false);\n    PR0(a, a.size());\n\n    for (int i=0; i<n; ++i)\n        a[i] = 1LL * a[i] * a[i] % mod;\n\n    NTT(a, true);\n}\n\nvoid init() {\n    int tmp = 1;\n    while (tmp<(n+1)*2)\n        tmp <<= 1;\n\n    inv[1] = 1;\n    for (int i=2; i<=tmp; ++i)\n       inv[i] = mod - 1LL * inv[mod%i] * (mod / i) % mod;\n\n    for (int i=1, j=0; i<tmp; ++i) {\n        int bit = tmp>>1;\n        for (; j & bit; bit >>= 1)\n            j ^= bit;\n        j ^= bit;\n        rev[i] = j;\n    }\n    // PR0(rev, tmp);\n\n    for (int i=0; i<=n; ++i)\n        C[i][0] = C[i][i] = 1;\n\n    for (int i=1; i<=n; ++i) {\n        for (int j=1; j<i; ++j)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;\n    }\n\n    pw2[0] = 1;\n    for (int i=1; i<=n; ++i)\n        pw2[i] = pw2[i-1] * 2 % mod;\n\n    f[0][0] = 1;\n\n    for (int l=1; l<=n; ++l) {\n        for (int s=0; s<=x; ++s) {\n            f[l][s] = f[l-1][s];\n            if (s>=1)\n                f[l][s] = (f[l][s] + f[l-1][s-1]) % mod;\n            if (s>=2)\n                f[l][s] = (f[l][s] + f[l-1][s-2]) % mod;\n        }\n    }\n    // debug(f[n][2]);\n}\n\nint case1() {\n    vector<int> h;\n\n    for (int t=0; t<=x/2; ++t) {\n        h.assign(n+1, 0);\n\n        for (int l=0; l<=n; ++l) {\n            if (l<=t)\n                h[l] = pw2[l];\n            else\n                h[l] = (1LL * h[l-1] * 2 - C[l-1][t] + mod) % mod;\n        }\n\n        square(h);\n        // if (t==1)\n        //     PR0(h, n+1);\n\n        for (int l=0; l<=n; ++l)\n            g[l][t] = h[l];\n    }\n    // debug(g[2][1]);\n\n    int res = 0;\n\n    for (int l=0; n-l-2>=0; ++l) {\n        for (int s=(x+1)%2; s+2<=x; s += 2) {\n            // cerr << l << ' ' << s << ' ' << f[l][s] * g[n-l-2][(x-2-s)/2] << '\\n';\n            res = (res + 1LL * f[l][s] * g[n-l-2][(x-2-s)/2]) % mod;\n        }\n    }\n\n    if (x%2==0)\n        res = (res + g[n-1][(x-1)/2]) % mod;\n    else\n        res = (res + pw2[n]) % mod;\n\n    return res;\n}\n\nint case2() {\n    int res = 0;\n\n    for (int s=x%2; s<x; s += 2)\n        res = (res + f[n][s]) % mod;\n\n    return res;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tread_input();\n\tinit();\n\t// debug(case1());\n    // debug(case2());\n\t// cout << (case1() + case2()) % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  // mint(long long);\n  mint(long long v)\n      : v(fast == 0 ? (v < 0 ? (v % MODS[kind] + MODS[kind]) % MODS[kind]\n                             : v % MODS[kind])\n                    : (v)) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n  void take_mod() { v %= MODS[kind]; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\nvector<vector<mint<>>> comb_table;\n\nmint<> comb(LL N, LL K) {\n  if (N < K) return 0;\n  if (K < 0) return 0;\n  return comb_table[N][K];\n}\n\nvoid init(int N) {\n  comb_table.resize(N + 6);\n  for (int i = 0; i <= N; i++) {\n    comb_table[i].resize(i + 1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for (int j = 1; j < i; j++) {\n      comb_table[i][j] = comb_table[i - 1][j - 1] + comb_table[i - 1][j];\n    }\n  }\n}\n\nvoid solve(long long N, long long X) {\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2 * N + 5, N + 5);\n\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<0, 1> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353, N = 6030;\n\nlong long dp[N][N], C[N][N];\n\nvoid add(long long & var, long long val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nint main() {\n  for (int i = 0; i < N; ++i) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = 1; j < i; ++j)\n      C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;\n  }\n  int n, x;\n  scanf(\"%d %d\", &n, &x);\n  if (x == 1) {\n    long long ans = 1;\n    for (int i = 0; i < n; ++i)\n      ans = (ans * 2) % mod;\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n  if (x == 2) {\n    printf(\"%d\\n\", n + 1);\n    return 0;\n  }\n  dp[0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < x; ++j) {\n      for (int k = 0; k <= 2; ++k) {\n        if (j + k >= x) continue;\n        add(dp[i+1][j+k], dp[i][j]);\n      }\n    }\n  }\n  long long ans = 0;\n  for (int i = 0; i < x; ++i)\n    add(ans, dp[n][i]);\n  for (int len = 3; len <= n; ++len) {\n    for (int i = 1; i * 2 < len; ++i) {\n      int tengah = len - 2 * i;\n      int sisa = x-1 - 2 * i;\n      if (sisa < tengah || sisa > 2 * tengah) continue;\n      ans = (ans + 1LL * C[tengah][sisa-tengah] * C[n][len]) % mod;\n    }\n  }\n  if (x & 1) {\n    for (int len = (x - 1); len <= n; ++len) {\n      ans = (ans + C[n][len]) % mod;\n    }\n  }\n  ans %= mod;\n  if (ans < 0) ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst ll M=3005,mod=998244353;\nll n,m,res=0,C[M][M];\n\nint main(){\n\tcin>>n>>m;\n\tC[0][0]++;\n\tfor(int i=0;i<M-1;i++) for(int j=0;j<=i;j++){\n\t\t(C[i+1][j]+=C[i][j])%=mod;\n\t\t(C[i+1][j+1]+=C[i][j])%=mod;\n\t}\n\tfor(int i=0;i<m;i++) for(int j=0;j<=i/2;j++) if(i-j<=n) (res+=C[n][j]*C[n-j][i-2*j])%=mod;\n\tfor(int i=m+1;i<=2*m-2;i+=2){\n\t\tint t=(i-m+1)/2*2,x=i-2*t;\n\t\tfor(int j=0;j<=x/2;j++) if(t+x-j<=n) (res+=C[x-j][j]*C[n][t+x-j])%=mod;\n\t}\n\tif(m%2==1) for(int i=m;i<=n;i++) (res+=C[n][i])%=mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 6005\n#define ll long long\nusing namespace std ;\n\nIL int gi(){\n\tint data=0,fu=1; char ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar(); if(ch=='-')fu=-1,ch=getchar();\n\twhile('0'<=ch&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar();return data*fu;\n}\n\nint n,X,Fac[_],IFac[_],Ans;\n#define mod 998244353\nIL int Pow(int ts,int js){int al=1;while(js){if(js&1)al=1ll*al*ts%mod;ts=1ll*ts*ts%mod;js>>=1;}return al; }\n\nIL int Comb(int N,int M){if(M>N||N<0||M<0)return 0; return 1ll*Fac[N]*IFac[M]%mod*IFac[N-M]%mod; }\nIL int S(int a,int b){if(a<b||a<0||b<0)return 0; return Comb(b,a-b); }\nIL int Calc(int K){\n\tint ret=0;\n\tfor(int i=0;i<=X-1;++i)ret=(ret+S(i,K))%mod;\n\tbool flag=false;\n\tfor(int i=1;i<=(K-1)/2;++i){\n\t\tint s=X-1-2*i,l=K-2*i; if(l*2==s)continue; \n\t\tret=(ret+S(s,l))%mod;\n\t}\n\treturn ret+((X&1)&&(2*K>X));\n}\nint main(){\n\tn=gi(); X=gi();\n\tFac[0]=1; for(int i=1;i<=n;++i)Fac[i]=1ll*Fac[i-1]*i%mod;\n\tIFac[n]=Pow(Fac[n],mod-2);\n\tfor(int i=n;i>=1;--i)IFac[i-1]=1ll*i*IFac[i]%mod; \n\tfor(int K=0;K<=n;++K){\n\t\t//cout<<K<<\": \"<<Calc(K)<<\" ; \"<<Comb(n,K)<<endl;\n\t\tAns=(Ans+1ll*Comb(n,K)*Calc(K)%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",Ans%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define MOD 998244353\n/* <rab:include(base.hpp)> */\n#pragma GCC optimize (\"O3\")\n#ifdef GCJ_CASE\n  void solve(long long case_id);\n#else\n  void solve(); /* この関数に問題ごとの処理を書く */\n#endif\n\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n  #define debug true\n#else\n  #define NDEBUG /* <cassert>のincludeより前に定義する必要がある */\n  #define debug false\n#endif\n#include<algorithm>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#ifdef __cpp_lib_execution\n  #include<execution>\n#endif\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\n#define int LL /* 標準ライブラリのincludeが終わってから書き換える */\n#define CS const\n#define CX constexpr\n#define IL inline\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(int rab_base_loop##i=(t),i=(f);i<=rab_base_loop##i;i++)\n#define uptil(f, t, i)   for(int rab_base_loop##i=(t),i=(f);i< rab_base_loop##i;i++)\n#define downto(f, t, i)  for(int rab_base_loop##i=(t),i=(f);i>=rab_base_loop##i;i--)\n#define downtil(f, t, i) for(int rab_base_loop##i=(t),i=(f);i> rab_base_loop##i;i--)\n#define iter(v) begin(v), end(v)\n#define citer(v) cbegin(v), cend(v)\n#if debug\n  #define _GLIBCXX_DEBUG\n  #define _LIBCPP_DEBUG 2\n  #define _LIBCPP_DEBUG2 2\n  #define ln << endl\n#else\n  #define ln << '\\n'\n#endif\n#define tb << '\\t'\n#define sp << ' '\n#ifdef __cpp_lib_execution\n  #if debug\n    #define PARABLE execution::par_unseq,\n  #else\n    #define PARABLE execution::seq,\n  #endif\n#else\n  #define PARABLE /* none */\n#endif\n/* <rab:include(mod.hpp)> */\n#ifdef MOD\n  #if !defined(FORCE_MOD) && MOD != 1000000007 && MOD != 1000000009 && MOD != 998244353\n    #error unknown mod MOD; if you really want to use (MOD) as mod, define FORCE_MOD.\n  #endif\n#else\n  #define MOD 1000000007\n#endif\n/* <rab:include(power.hpp)> */\nusing int128=__int128;\nTL<class T> T power(T x,int n){T rt(1);for(;n;n/=2){if(n%2)rt*=x;x*=x;}RT rt;}\nint pow_mod(int x,int n,int m){int rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\nint pow_mod_64(int128 x,int n,int m){int128 rt=1;for(;n;n/=2){if(n%2)rt=rt*x%m;x=x*x%m;}RT rt;}\n/* </rab:include(power.hpp)> */\nIL CX int modulo(int a,int m){RT(a%=m,a>=0?a:a+m);}\nTL<ULL mod=MOD>class MInt{\n  /*\n    int with modulo.\n    // `mod` must be a prime for `log`.\n    `mod` must be coprime to `val` for `inv` and to `m.val` for `operator/` and `operator/=`.\n  */\n  /*! https://ei1333.github.io/luzhiled/snippets/other/mod-int.html */\npublic:\n  int val;\n  CX MInt():val(0){}\n  explicit CX MInt(int v):val(modulo(v,mod)){}\n  MInt&operator+=(CS MInt&m){val+=m.val;if(val>=mod)val-=mod;RT*this;}\n  MInt&operator-=(CS MInt&m){val-=m.val;if(val<0)val+=mod;RT*this;}\n  MInt&operator*=(CS MInt&m){val=val*m.val%mod;RT*this;}\n  MInt&operator/=(CS MInt&m){val=val*m.inv().val%mod;RT*this;}\n  MInt operator+(CS MInt&m)CS{RT MInt(*this)+=m;}\n  MInt operator-(CS MInt&m)CS{RT MInt(*this)-=m;}\n  MInt operator*(CS MInt&m)CS{RT MInt(*this)*=m;}\n  MInt operator/(CS MInt&m)CS{RT MInt(*this)/=m;}\n  MInt operator-()CS{MInt m;m.val=val?mod-val:0;RT m;}\n  bool operator==(CS MInt&m)CS{RT val==m.val;}\n  bool operator!=(CS MInt&m)CS{RT val!=m.val;}\n  //MInt pow(int n)CS{MInt x(*this),rt(1);while(n){if(n%2)rt*=x;x*=x;n/=2;}RT rt;}\n  MInt pow(int n)CS{RT power(*this,n);}\n  MInt inv()CS{int a=val,b=mod,x=1,y=0,t;while(b){t=a/b;swap(b,a-=t*b);swap(y,x-=t*y);}RT(MInt)x;}\n  friend ostream&operator<<(ostream&o,CS MInt<mod>&m){RT o<<m.val;}\n  friend istream&operator>>(istream&i,MInt<mod>&m){int v;i>>v;m=MInt<mod>(v);RT i;}\n};\nusing mint=MInt<>;\n\nconstexpr mint operator\"\" _m(ULL n){RT mint(n);}\nconstexpr MInt<998244353>operator\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nconstexpr MInt<1000000007>operator\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nconstexpr MInt<1000000009>operator\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n\n//#pragma rab:gsub \\b(\\d+)m\\b mint(\\1)\n/* </rab:include(mod.hpp)> */\n/* <rab:include(typedefs.hpp)> */\nstruct unit{};\n\nusing int128=__int128;\nusing LD=long double;\nTL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;\nTL<TN T>using vvvec=vec<vvec<T>>;\nTL<TN T>using vvvvec=vec<vvvec<T>>;\n\n//#pragma rab typedefs.dynamic\nusing WI = vvec<int>; using VI = vec<int>; using VM = vec<mint>; \n/* </rab:include(typedefs.hpp)> */\n/* <rab:include(alias.hpp)> */\n#define MP make_pair\n#define MU make_unique\n#define PB push_back\n#define UP unique_ptr\n#define foldl accumulate\n#define scanl partial_sum\n/* </rab:include(alias.hpp)> */\n\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,true);}\nTL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,true);}\n\nnamespace kpl {\n  TL<TN V, TN W>\n  static IL void append(V& v, const W& w) { copy(PARABLE citer(w), back_inserter(v)); }\n\n  TL<TN V>\n  static IL auto flatten(const V& xss, int reserve_size = 0) -> TN V::value_type {\n    decltype(flatten(xss)) ret;\n    ret.reserve(reserve_size);\n    for(const auto& xs : xss) append(ret, xs);\n    ret.shrink_to_fit();\n    return move(ret);\n  }\n\n  TL<TN I>\n  static IL bool is_in(I x, I l, I r) {\n    return l <= x && x < r;\n  }\n}\n/* <rab:include(util.hpp)> */\n#ifndef __cpp_lib_exchange_function\n  // #define __cpp_lib_exchange_function 201304L\n  #define exchange exchange_RAB\n  TL<TN T,TN U=T>IL T exchange(T& t, U&& u){T x=move(t);t=forward<U>(u);RT x;}\n#endif\n#ifndef __cpp_lib_clamp\n  // #define __cpp_lib_clamp 201603L\n  #define clamp clamp_RAB\n  TL<TN T>IL CX CS T&clamp(CS T&a,CS T&mn,CS T&mx){RT a<mn?mn:a>mx?mx:a;}\n#endif\nTL<TN T>int size_RAB(T t){RT t.size();}\n#define size size_RAB\n\nTL<TN V>IL void uniq_after_sort(V&v){v.erase(unique(iter(v)),v.end());}\nTL<TN V>IL void sort_and_uniq(V&v){sort(iter(v));v.erase(unique(iter(v)),v.end());}\nTL<TN V,TN K>IL auto leftmost_ge(CS V&v,CS K&k){RT v.lower_bound(k);}\nTL<TN V,TN K>IL auto leftmost_gt(CS V&v,CS K&k){RT v.upper_bound(k);}\nnamespace rab{\n  /**\n    verified:\n      - T=int https://atcoder.jp/contests/colopl2018-final-open/submissions/4889360\n  */\n  TL<TN T>struct Compressed{int size;map<T,int>zip;vec<T>unzip;};\n  TL<TN T>IL Compressed<T>compressed(vec<T>v){\n    sort_and_uniq(v);map<T,int>zip;times(size(v),i)zip[v[i]]=i;RT{size(v),zip,move(v)};\n  }\n  /**\n    not verified\n  */\n  TL<TN T>struct CompressedSrc{int size;map<T,int>zip;vec<T>unzip;WI src;};\n  TL<TN T>IL CompressedSrc<T>compressed_src(CS vec<T>&v){\n    auto c=compressed(v);VI src(c.size);times(size(v),i)src[c.zip[v[i]]].PB(i);RT{c.size,c.zip,c.unzip,src};\n  }\n}\n/* </rab:include(util.hpp)> */\n/* <rab:include(debug.hpp)> */\nTL<class T>\nIL istream&operator>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nTL<class T>\nIL ostream&operator<<(ostream&,CS vec<T>&);\nTL<class T,class S>\nIL ostream&operator<<(ostream&,CS map<T,S>&);\n#define DEFINE_ITER_OUTPUT(s,x,sep){int i=0;for(CS auto&x##0_elem:x){if(i++)s<<sep;s<<x##0_elem;}RT s;}\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<T>&v)DEFINE_ITER_OUTPUT(s,v,' ')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS map<T,S>&m)DEFINE_ITER_OUTPUT(s,m,' ')\nTL<class T>\nIL ostream&operator<<(ostream&s,CS vec<vec<T>>&w)DEFINE_ITER_OUTPUT(s,w,'\\n')\nTL<class T,class S>\nIL ostream&operator<<(ostream&s,CS vec<map<T,S>>&v)DEFINE_ITER_OUTPUT(s,v,'\\n')\n/* </rab:include(debug.hpp)> */\n\nsigned main() {\n  if(debug) cerr << \"MOD: \" << (MOD) ln;\n  if(!debug) {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n  cout << fixed << setprecision(20);\n  cerr << fixed << setprecision(20);\n\n  #ifdef GCJ_CASE\n    int T; cin >> T;\n    times(T, t) {\n      cout << \"Case #\" << t + 1 << \": \";\n      solve(t);\n    }\n  #else\n    solve();\n  #endif\n\n  return 0;\n}\n/* </rab:include(base.hpp)> */\n/* <rab:include(nck.hpp)> */\n/* <rab:include(fact.hpp)> */\n\n/*! https://twitter.com/meguru_comp/status/694207919517077504 */\nVM fact, fact_inv;\ninline void fact_init(int n) {\n  int a = size(fact);\n  if(a > n) return;\n  fact.resize(n+1);\n  fact_inv.resize(n+1);\n  if(a == 0) {\n    fact[a] = fact_inv[a] = mint(1);\n    ++a;\n  }\n  upto(a, n, i) fact[i] = fact[i-1] * mint(i);\n  fact_inv[n] = fact[n].inv();\n  downto(n-1, a, i) fact_inv[i] = fact_inv[i+1] * mint(i+1);\n}\n/* </rab:include(fact.hpp)> */\n\n/*! https://twitter.com/meguru_comp/status/694547019885449216 */\ninline mint nCk(int n, int k, bool check_init = true) {\n  /*-\n    verification: ok\n    https://atcoder.jp/contests/keyence2019/submissions/4015435\n    https://atcoder.jp/contests/arc004/submissions/4016291\n  */\n  if(check_init && size(fact) <= n) fact_init(n);\n  if(0 <= k && k <= n) return fact[n] * fact_inv[k] * fact_inv[n-k];\n  else return mint(0);\n}\ninline mint nPk(int n, int k, bool check_init = true) {\n  /*-\n    verification: 1 fix not verified\n    https://atcoder.jp/contests/keyence2019/submissions/4015435\n  */\n  if(check_init && size(fact) <= n) fact_init(n);\n  if(0 <= k && k <= n) return fact[n] * fact_inv[n-k];\n  else return mint(0);\n}\n/* </rab:include(nck.hpp)> */\n//#include \"consts.hpp\"\n\nmint dp[6001][3001];\n\nvoid solve() {\n// N X\n/* <foxy.memo-area> */\nint N;int X;cin>>N;cin>>X;\n/* </foxy.memo-area> */\n\n  dp[0][0] = mint(1);\n\n  VM anss(N + 1);\n\n  times(N, i) {\n    times(X, j) {\n      dp[j + 1][i + 1] += dp[j][i];\n\n      if(j + 2 <= X) dp[j + 2][i + 1] += dp[j][i];\n    }\n  }\n\n  // dd dp;\n\n  // mint ans1 = 0_m, ans2 = 0_m;\n  upto(0, N, i) {\n    times(X, j) {\n      anss[i] += dp[j][i];\n    }\n  }\n  if(debug) cerr << '#' << __LINE__ ln\n    << \"  anss: \" << (anss) ln\n    << \"  '?':  \" << ('?') ln;\n  upto(1, min(N / 2, (X - 1) / 2), a) {\n    // dd a;\n    upto(0, N - 2 * a, k) {\n      // dd k; X - 1 - 2 * a; (N - 2 * a) - k; dp[X - 1 - 2 * a][(N - 2 * a) - k];\n      anss[N - k] += dp[X - 1 - 2 * a][(N - 2 * a) - k];\n    }\n  }\n\n  if(debug) cerr << '#' << __LINE__ ln\n\n    << \"  anss: \" << (anss) ln\n\n    << \"  '*':  \" << ('*') ln;\n  if(X % 2 == 1 && N > (X - 1)) {\n    upto(1, N - (X - 1), t) {\n      anss[X - 1 + t] += 1_m; // 22...22\n    }\n  }\n\n  if(debug) cerr << '#' << __LINE__ ln\n\n    << \"  anss: \" << (anss) ln\n\n    << \"  '!':  \" << ('!') ln;\n  mint ans = 0_m;\n  fact_init(N);\n  times(N + 1, k) ans += anss[k] * nCk(N, k);\n\n  cout << ans ln;\n}\n\n/* <rab:gen/> */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type alias\ntypedef long long LL;\ntypedef pair<int,int> II;\ntypedef tuple<int,int,int> III;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef unordered_map<int,int> MAPII;\ntypedef unordered_set<int> SETI;\ntemplate<class T> using VV=vector<vector<T>>;\n// minmax\ntemplate<class T> inline T SMIN(T& a, const T b) { return a=(a>b)?b:a; }\ntemplate<class T> inline T SMAX(T& a, const T b) { return a=(a<b)?b:a; }\n// repetition\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define REPE(i,n)  for(int i=0;i<=(n);++i)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  for(int i=0;i<(n);++i)\n#define FORR(x,arr) for(auto& x:arr)\n#define SZ(a) int((a).size())\n// collection\n#define ALL(c) (c).begin(),(c).end()\n// DP\n#define MINUS(dp) memset(dp, -1, sizeof(dp))\n#define ZERO(dp) memset(dp, 0, sizeof(dp))\n// stdout\n#define println(args...) fprintf(stdout, ##args),putchar('\\n');\n// debug cerr\ntemplate<class Iter> void __kumaerrc(Iter begin, Iter end) { for(; begin!=end; ++begin) { cerr<<*begin<<','; } cerr<<endl; }\nvoid __kumaerr(istream_iterator<string> it) { (void)it; cerr<<endl; }\ntemplate<typename T, typename... Args> void __kumaerr(istream_iterator<string> it, T a, Args... args) { cerr<<*it<<\"=\"<<a<<\", \",__kumaerr(++it, args...); }\ntemplate<typename S, typename T> std::ostream& operator<<(std::ostream& _os, const std::pair<S,T>& _p) { return _os<<\"{\"<<_p.first<<','<<_p.second<<\"}\"; }\n#define __KUMATRACE__ true\n#ifdef __KUMATRACE__\n#define dump(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); __kumaerr(_it, args); }\n#define dumpc(ar) { cerr<<#ar<<\": \"; FORR(x,(ar)) { cerr << x << ','; } cerr << endl; }\n#define dumpC(beg,end) { cerr<<\"~\"<<#end<<\": \"; __kumaerrc(beg,end); }\n#else\n#define dump(args...)\n#define dumpc(ar)\n#define dumpC(beg,end)\n#endif\n\nconst int MOD=998244353;\nstruct ModInt {\n  unsigned int val;\n  ModInt(): val(0) {}\n  ModInt(int v) { norm(v%MOD); }\n  ModInt(long long v) { norm(v%MOD); }\n  ModInt& norm(long long v) {\n    v=v<0?v%MOD+MOD:v; // negative\n    v=v>=MOD?v-MOD:v; // mod\n    val=(unsigned int)v;\n    return *this;\n  }\n  explicit operator bool() const { return val!=0; }\n  ModInt operator-() const { return ModInt(0)-*this; }\n  ModInt &operator+=(ModInt that) { return norm((long long)val+that.val); }\n  ModInt &operator-=(ModInt that) { return norm((long long)val-that.val); }\n  ModInt &operator*=(ModInt that) { val=(unsigned long long)val*that.val%MOD; return *this; }\n  ModInt &operator/=(ModInt that) { return *this*=that.inv(); }\n  ModInt operator+(ModInt that) const { return ModInt(*this)+=that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this)-=that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this)*=that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this)/=that; }\n  ModInt pow(long long n) const {\n    ModInt x=*this, res=1;\n    while(n>0) {\n      if(n&1) res*=x;\n      x*=x,n>>=1;\n    }\n    return res;\n  }\n  ModInt inv() const { return (*this).pow(MOD-2); }\n  bool operator==(ModInt that) const { return val==that.val; }\n  bool operator!=(ModInt that) const { return val!=that.val; }\n  friend ostream& operator<<(ostream& os, const ModInt& that) { return os<<that.val; }\n};\nLL choose(LL n, LL k) {\n  if(n<k) return 0;\n  const int MAX_N = 1e6+1;\n  assert(0<=k&&k<=MAX_N);\n  static LL fact[MAX_N+1],revfact[MAX_N+1],rev[MAX_N+1];\n  \n  if(rev[1]==0) {\n    rev[1]=1;\n    for(int i=2;i<=MAX_N;i++) rev[i]=rev[MOD%i]*(MOD-MOD/i)%MOD;\n    fact[0]=1,revfact[0]=1;\n    for(int i=1;i<=MAX_N;i++) {\n      fact[i]=fact[i-1]*i%MOD;\n      revfact[i]=revfact[i-1]*rev[i]%MOD;\n    }\n  }\n  return fact[n]*revfact[n-k]%MOD*revfact[k]%MOD;\n}\n\n// $ cp-batch BannedX | diff BannedX.out -\n// $ g++ -std=c++14 -Wall -O2 -D_GLIBCXX_DEBUG -fsanitize=address BannedX.cpp && ./a.out\n\n/*\n \n 4/20/2019\n \n 6:12-6:18 give up\n \n 4/22/2019\n \n 21:00-22:00 read editorials\n \n 4/23/2019\n \n 9:15- read editorials\n \n http://drken1215.hatenablog.com/entry/2019/04/21/190800\n  - combinatorics\n https://betrue12.hateblo.jp/entry/2019/04/21/170538\n  - dp\n https://img.atcoder.jp/tenka1-2019/editorial.pdf\n https://youtu.be/uQvc7k2xamY?t=3616\n  - combinatorics\n \n It took tons of time to understand sum>X analysis...😞\n\n Summary:\n  - Pay more attention to hand-made examples. It's just a waste of time if wrong 😡\n \n */\n\nconst int MAX_N=3000+1;\nint N,X;\nModInt dp[MAX_N][2*MAX_N];\nvoid solve() {\n  ModInt res(0);\n  dp[0][0]=1;\n  REP(i,N)REPE(sum,X) {\n    // 1\n    if(sum+1<2*MAX_N)dp[i+1][sum+1]+=dp[i][sum];\n    // 2\n    if(sum+2<2*MAX_N)dp[i+1][sum+2]+=dp[i][sum];\n  }\n  // less than X (n1>0)\n  REPE(cnt,N)REPE(sum,X-1) if(N-cnt>=0) res+=dp[cnt][sum]*choose(N,N-cnt);\n  for(int y=1; X+y<=2*N; y+=2) {\n    if(y+1<X-1) {\n      for(int n=1; n+y+1<=N; ++n) {\n        res+=dp[n][X-y-2]*choose(N,n+y+1);\n      }\n    } else if(X%2==1) {\n      res+=choose(N,(X+y)/2);\n    }\n  }\n  cout<<res<<endl;\n}\n\nvoid solve_wrong() {\n  ModInt dp[MAX_N][2*MAX_N][2];\n\n  ModInt res(0);\n  int N2=X%2==0?X/2-1:N;\n  REPE(i,N2) res+=ModInt(choose(N,i)); // all 2\n  dump(res);\n  dp[0][0][0]=1;\n  REP(i,N)REPE(sum,X)REP(j,2) {\n    // 1\n    if(sum+1<2*MAX_N)dp[i+1][sum+1][1]+=dp[i][sum][j];\n    // 2\n    if(sum+2<2*MAX_N)dp[i+1][sum+2][j]+=dp[i][sum][j];\n  }\n  dump(res);\n  // less than X (n1>0)\n  REPE(cnt,N)REPE(sum,X-1) if(N-cnt>=0) res+=dp[cnt][sum][1]*choose(N,N-cnt);\n  dump(res);\n  \n  // more than X (n1>0)\n  FORE(i,1,N) REPE(cnt,N) {\n    if(2*i+1>=X) continue;\n    if(2*i+1+cnt>N) continue;\n    int sum=X-2*i-2;\n    if(sum<0) continue;\n    ModInt a=dp[cnt][sum][0]+dp[cnt][sum][1];\n    ModInt b=choose(N,2*i+1+cnt);\n    dump(i,cnt,sum,a,b,a*b);\n    res+=a*b;\n  }\n  cout<<res<<endl;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout<<setprecision(12)<<fixed;\n  \n  cin>>N>>X;\n  solve();\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst long long mod = 998244353;\nlong long f[6005], invf[6005];\n\nlong long power(long long a,long long b){\n    long long res = 1;\n    while(b){\n        if(b&1) res = res*a%mod;\n        a = a*a%mod;\n        b /= 2;\n    }\n    return res;\n}\n\nlong long inv(long long u){ return power(u,mod-2); } \n\nvoid preWork(int n){\n    f[0] = invf[0] = 1;\n    for(int i = 1; i <= n; i++){\n        f[i] = f[i-1]*(long long)i%mod;\n        invf[i] = inv(f[i]);\n    }\n}\n\nlong long getC(long long n,long long m){\n    if(m>n || m<0) return 0;\n    else{\n        long long res = f[n];\n        res = res*invf[m]%mod;\n        res = res*invf[n-m]%mod;\n        return res;\n    }\n}\n\nint min(int a,int b){ return a>b?b:a; }\n\nint main(){\n    preWork(6000);\n    int n,x;\n    scanf(\"%d%d\",&n,&x);\n    long long ans = 0;\n    for(int cnt0 = 0; cnt0 <= n; cnt0++){\n        int m = n-cnt0;\n        long long res = 0;\n        if(x<=m) res = x%2;\n        else{\n            for(int i = 0; i < x-m; i++){\n                res += getC(m,i);\n                if(res>=mod) res -= mod;\n            }\n            for(int i = x/2; i <= min(x-1,m-1); i++){\n                int cnt2 = x-1-i, left2 = m-i;\n                if(left2<=cnt2){\n                    res += getC(i-left2,cnt2-left2);\n                    if(res>=mod) res -= mod;\n                }\n            }\n            //printf(\"n = %d, x = %d: %lld\\n\",m,x,res);\n        } \n        ans = ans + getC(n,cnt0)*res%mod;\n        if(ans>=mod) ans -= mod;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst ll Mod = 998244353;\nconst int Maxn = 3e3 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 21;\n\nll mul(ll a, ll b){\n\treturn (a * b) % Mod;\n}\nll bin_pow(ll b, ll p){\n\tll res = 1;\n\tfor(ll j = 1, pw = b; j <= p; j <<= 1, pw = mul(pw, pw))\n\t\tif(p & j) res = mul(res, pw);\n\treturn res;\n}\nll f[Maxn], iv[Maxn];\nll nCr(ll n, ll r){\n\tif((r < 0) || (n < r) || (n < 0)) return 0;\n\treturn mul(f[n], mul(iv[r], iv[n - r]));\n}\n\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tf[0] = iv[0] = 1;\n\tfor(int i = 1; i < Maxn; i++) f[i] = mul(f[i - 1], i), iv[i] = bin_pow(f[i], Mod - 2);\n\t\n\tll n, x;\n\tcin >> n >> x;\n\tll ans = 0;\n\tint c1, c2;\n\tfor(int s = 0; s <= n + n; s++){\n\t\tfor(int l = 0; l <= n; l++){\n\t\t\tc2 = s - l;\n\t\t\tc1 = s - (c2 + c2);\n\t\t\tif(min(c1, c2) < 0) continue;\n\t\t\tif(x == s) continue;\n\t\t\tif(x > s){\n\t\t\t\tans += mul(nCr(n, n - l), nCr(l, c1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif((x % 2) == (c1 % 2)) continue;\n\t\t\tif(x < c1) continue;\n\t\t\t\n\t\t\tint l2 = c1 + ((x - c1) / 2);\n\t\t\tint l3 = l - l2;\n\t\t\tif(l3 >= l2){\n\t\t\t\tif(c1) continue;\n\t\t\t\tans += nCr(n, n - l);\n\t\t\t\tcontinue;\t\t\t\n\t\t\t}\n\t\t\tans += mul(nCr(n, n - l), nCr(l2 - l3, c1));\n\t\t}\n\t\t//cerr << s << \" : \" << ans << '\\n';\n\t}\n\t\n\tcout << ans % Mod;\n\treturn 0;\n}\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mems(a,x) memset(a,x,sizeof(a))\n#define first fi\n#define second se\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353,MS=105,N=3005;\nll inv(ll x){return x==1?x:(mod-mod/x)*inv(mod%x)%mod;}\nll inv(ll x,ll mod){return x==1?x:(mod-mod/x)*inv(mod%x,mod)%mod;}\nll qpow(ll a,ll n){ll ans=1;while(n){if(n&1) ans=ans*a%mod;a=a*a%mod;n>>=1;}return ans;}\nll mul(ll a,ll b){ll ans=0;while(b){if(b&1) ans=(ans+a)%mod;a=(a+a)%mod;b>>=1;};return ans;}\nll qpow(ll a,ll n,ll mod){ll ans=1;while(n){if(n&1) ans=ans*a%mod;a=a*a%mod;n>>=1;}return ans;}\nll mul(ll a,ll b,ll mod){ll ans=0;while(b){if(b&1) ans=(ans+a)%mod;a=(a+a)%mod;b>>=1;};return ans;}\nstruct vec\n{\n    double x,y;\n    vec(double x=0,double y=0):x(x),y(y){}\n    vec operator+(const vec&o)const{ return vec(x+o.x,y+o.y);}\n    vec operator-(const vec&o)const{ return vec(x-o.x,y-o.y);}\n    double operator*(const vec&o)const{ return x*o.x+y*o.y;}\n    double operator^(const vec&o)const{ return x*o.y-y*o.x;}\n    vec operator/(const double&o)const{ return vec(x/o,y/o);}\n    vec operator*(const double&o)const{ return vec(x*o,y*o);}\n    void sc(){scanf(\"%lf%lf\",&x,&y);}\n    double len(){return sqrt(x*x+y*y);}\n};\nstruct Mat\n{\n    ll a[MS][MS];\n    int n,m;\n    Mat(int n=0,int m=0):n(n),m(m) { mems(a,0);}\n    Mat operator*(const Mat&B)const\n    {\n        Mat C(n,B.m);\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=B.m;j++)\n                for(int k=1;k<=m;k++)\n                C.a[i][j]=(C.a[i][j]+a[i][k]*B.a[k][j])%mod;\n        return C;\n    }\n};\nint n,x,c[N][N];\nll dp[N][N<<1];\nll C(ll n,ll m)\n{\n    if(m==0||n==m) return 1;\n    if(m==1) return n;\n    if(c[n][m]) return c[n][m];\n    return c[n][m]=(C(n-1,m-1)+C(n-1,m))%mod;\n}\nll solve(int m)\n{\n    ll ans=0;\n    for(int i=0;i<x;i++) (ans+=dp[m][i])%=mod;\n    if((x&1)&&2*m>x) ans++;\n    for(int i=x+1;i<2*m;i+=2)\n    {\n        int t=m-(i-(x-1)),s=i-(i-(x-1))*2;\n        if(t>=0&&s>=0)\n            (ans+=dp[t][s])%=mod;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&x);\n    dp[0][0]=1;\n    for(int i=0;i<n;i++)\n        for(int j=i;j<=i*2;j++)\n    {\n        (dp[i+1][j+1]+=dp[i][j])%=mod;\n        (dp[i+1][j+2]+=dp[i][j])%=mod;\n    }\n    ll ans=0;\n    for(int i=0;i<=n;i++)\n        ans=(ans+C(n,i)*solve(i))%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353, N = 3030;\n\nint dp[N][N], C[N][N];\n\nvoid add(int & var, int val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nint main() {\n  for (int i = 0; i < N; ++i) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = 1; j < i; ++j)\n      C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;\n  }\n  int n, x;\n  scanf(\"%d %d\", &n, &x);\n  if (x == 1) {\n    int ans = 1;\n    for (int i = 0; i < n; ++i)\n      ans = (ans * 2) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n  }\n  if (x == 2) {\n    printf(\"%d\\n\", n + 1);\n    return 0;\n  }\n  dp[0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < x; ++j) {\n      for (int k = 0; k <= 2; ++k) {\n        if (j + k >= x) continue;\n        add(dp[i+1][j+k], dp[i][j]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < x; ++i)\n    add(ans, dp[n][i]);\n  for (int len = 3; len <= n; ++len) {\n    for (int i = 1; i * 2 < len; ++i) {\n      int tengah = len - 2 * i;\n      int sisa = x-1 - 2 * i;\n      if (sisa < tengah || sisa > 2 * tengah) continue;\n      ans = (ans + 1LL * C[tengah][sisa-tengah] * C[n][len]) % mod;\n    }\n  }\n  if (x & 1) {\n    for (int len = (x - 1); len <= n; ++len) {\n      ans = (ans + C[n][len]) % mod;\n    }\n  }\n  ans %= mod;\n  if (ans < 0) ans += mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 998244353\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll fac[100010],finv[100010];\nll comb(ll n,ll r){\n  if(n<0||r<0||n<r)return 0;\n  else return (fac[n]*finv[r]%mod)*finv[n-r]%mod;\n}\n\nll calc(ll l,ll s){\n  return comb(l,s-l);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  fac[0]=1;\n  rep(i,100000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,100001)finv[i]=mod_pow(fac[i],mod-2);\n\n  ll N,X;\n  cin>>N>>X;\n\n  ll res=1;\n  repl(len,1,N+1){\n    ll add=0;\n\n    rep(s,X){\n      add+=calc(len,s);\n      add%=mod;\n    }\n\n    repl(i,1,(len/2)+1){\n      if(i*2<X-1){\n        add+=calc(len-2*i,X-1-2*i);\n        add%=mod;\n        if((X-1-2*i)==2*(len-2*i)){\n          add=(add-1+mod)%mod;\n          add%=mod;\n        }\n      }\n    }\n\n    if(len*2>=X&&X%2==1){\n      add++;\n      add%=mod;\n    }\n\n    res+=add*comb(N,len)%mod;\n    res%=mod;\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint gcd (int a, int b) {\n  if (a < 0) a = -a;\n  if (b < 0) b = -b;\n  if (a < b) swap(a, b);\n  while (b) {\n    a %= b;\n    swap(a, b);\n  }\n  return a;\n}\nstruct sieve_of_eratosthenes {\n  vector<bool> is_prime;\n  vector<int> prime_numbers;\n  sieve_of_eratosthenes(int n)\n    : is_prime(vector<bool>(n, true))\n    , prime_numbers(vector<int>(0))\n  {\n    is_prime[1] = false;\n    for (int i = 2; i < n; i++) if (is_prime[i]) {\n      prime_numbers.push_back(i);\n      for (int j = 2 * i; j < n; j += i) {\n        if (is_prime[i]) is_prime[j] = false;\n      }\n    }\n  }\n};\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a(n + 1);\n  for (int i = n; i >= 0; i--) cin >> a[i];\n  sieve_of_eratosthenes sieve(n + 1);\n  set<int> ret;\n  for (auto const&p : sieve.prime_numbers) {\n    if (a[0] % p) continue;\n    bool flg = false;\n    for (int i = 0; i < p - 1; i++) {\n      int tmp = 0;\n      for (int j = i; j <= n; j += p - 1) {\n        tmp += a[j];\n      }\n      if (tmp % p) {\n        flg = true;\n        break;\n      }\n    }\n    if (!flg) ret.insert(p);\n  }\n  int g = a[0];\n  for (int i = 1; i <= n; i++) g = gcd(g, a[i]);\n  for (int p = 2; p * p <= g; p++) {\n    while (!(g % p)) {\n      g /= p;\n      ret.insert(p);\n    }\n  }\n  if (g != 1) ret.insert(g);\n  for (auto it = ret.begin(); it != ret.end(); it++) {\n    cout << *it << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<1>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\nvec fact,inv;\nvoid init(int n){\n  fact.assign(n+1,1);\n  inv.assign(n+1,1);\n  REP(i,n) fact[i+1] = fact[i]*(i+1), inv[i+1] /= fact[i+1];\n}\n\nmint cmb(int n, int r){\n  if(n < r) return 0;\n  return fact[n]*inv[r]*inv[n-r];\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,k;\n  cin >> n >> k;\n\n  init(10000);\n\n  mint ans = 0;\n  mat s(k+1,vec(k+1,0));\n  vec t(k+1,0);\n  REP(i,k+1) REP(j,k+1) if(j>=i-j && i-j >= 0) s[i][j] = cmb(j,i-j);\n  REP(i,k) REP(j,k+1) s[i+1][j] += s[i][j];\n  REP(i,k+1){\n    t[i] = cmb(n,i);\n    if(i) t[i] += t[i-1];\n  }\n\n  REP(i,n+1){\n    if(k%2==0 && i*2 >= k) break;\n    ans += cmb(n,i);\n  }\n\n  REP(i,n){\n    if(i*2+1 >= k) break;\n    int l = k-(i*2+1)-1;\n    REP(j,l){\n      if(i+1+j > n) break;\n      ans += s[l-1][j]*cmb(n,i+1+j);\n    }\n    REP(j,l+1){\n      ans += (t[j+i*2+1]-t[j+i])*cmb(j,l-j); \n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 6000, mod = 998244353;\nint fac[N+10],ifac[N+10];\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tFor(i,1,n) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n]=power(fac[n],mod-2);\n\tDow(i,n-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint n,m,f[N][N],g[N][N],cnt[N];\n\nint main(){\n\tn=read(),m=read(),init(N);\n\tf[0][0]=1;\n\tFor(i,0,m) g[i][0]=1;\n\tFor(i,1,m)\n\t\tFor(j,1,n) f[i][j]=Mod(f[i-1][j-1]+f[i-2][j-1]),g[i][j]=Mod(g[i-1][j]+f[i][j]);\n\tint ans=0;\n\tfor (int i=0,k=2;i<=m-2;i+=2,k++){//强制选 i 和 i+1\n\t\tFor(j,0,m-1-(i+1)) cnt[k+j]=Mod(cnt[k+j]+g[m-1-(i+1)][j]);\n\t\tFor(j,0,m-1-(i+1)) if (f[m-1-(i+1)][j]){\n\t\t\tint l=k+j;\n\t\t\tFor(p,1,k-2) cnt[l+p]=Mod(cnt[l+p]+f[m-1-(i+1)][j]);\n\t\t\t//cnt[l+1]=Mod(cnt[l+1]+f[m-1-(i+1)][j]);\n\t\t\t//cnt[l+(k-1)]=Mod(cnt[l+(k-1)]+mod-f[m-1-(i+1)][j]);\n\t\t}\n\t}\n\t//For(i,1,n+1) cnt[i]=Mod(cnt[i]+cnt[i-1]);\n\tif (m&1){\n\t\tFor(k,1,n+1) cnt[k]=Mod(cnt[k]+1);\n\t} else {\n\t\tFor(i,1,m/2) cnt[i]=Mod(cnt[i]+1);\n\t}\n\tFor(i,1,n+1) if (cnt[i]) ans=(ans+1ll*cnt[i]*C(n,i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//第8回シンデレラガール総選挙は是非本田未央ちゃんに投票をお願いします！\n//ファンのことも他のアイドルの子たちのことも本当に大事にしてて、今まで周りに色んなものを与えてくれました。\n//今度は私たちが未央ちゃんにお返しをする番です。みんなでガラスの靴を履かせてあげましょう！\n// #本田未央を一番星に #本田未央を令和のシンデレラガールに #第8回シンデレラガール総選挙\n#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nlint d2[3010][6010];\nlint co[3010][3010];\nlint dp[3010][6010][2][2];\nlint mo=998244353;\nint main()\n{\n\tint n,x;cin>>n>>x;\n\t/*memset(dp,0,sizeof(dp));\n\tdp[0][0][0][0]=1;\n\trep(i,n) rep(j,x+5) rep(k,2){\n\t\trep(l,2) dp[i][j][k][l]%=mo;\n\t\t//0\n\t\tdp[i+1][j][k][0]+=dp[i][j][k][0];\n\t\tdp[i+1][j][k][1]+=dp[i][j][k][1];\n\t\t//1\n\t\tdp[i+1][j][k][0]+=dp[i][j][k][0]+dp[i][j][k][1];\n\t\t//2\n\t\tif(j<1){\n\t\t\tdp[i+1][j][1][1]+=dp[i][j][k][0];\n\t\t}\n\t\telse{\n\t\t\tdp[i+1][j][k][1]+=dp[i][j][k][0]+dp[i][j][k][1];\n\t\t}\n\t}\n\tlint out=0;\n\trep(i,x) rep(j,2) rep(k,2){\n\t\tout+=dp[n][i][j][k];out%=mo;\n\t}\n\tout+=dp[n][x+1][1][1];out%=mo;*/\n\t\n\tmemset(d2,0,sizeof(d2));\n\td2[0][0]=1;\n\trep(i,n) rep(j,6005){\n\t\td2[i][j]%=mo;\n\t\trep(k,3) d2[i+1][j+k]+=d2[i][j];\n\t}\n\tmemset(co,0,sizeof(co));\n\trep(i,3005){\n\t\tco[i][0]=co[i][i]=1;\n\t\tREP(j,1,i) co[i][j]=(co[i-1][j]+co[i-1][j-1])%mo;\n\t}\n\tlint out=0;\n\trep(i,x){\n\t\tout+=d2[n][i];out%=mo;\n\t}\n\t//cout<<out<<endl;\n\tfor(int i=1;i<3010;i++){\n\t\tint re=x+i*2-1-i*4;\n\t\tif(re<0){\n\t\t\tint sum=x+i*2-1;\n\t\t\t//cout<<sum<<endl;\n\t\t\tif(sum%2==0 && sum/2<=n){\n\t\t\t\tout+=co[n][sum/2];out%=mo;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,n+1){\n\t\t\tif(n-2*i-j<0) continue;\n\t\t\tout+=d2[j][re]*co[n-j-1][2*i-1];\n\t\t\tout%=mo;\n\t\t}\n\t}\n\tcout<<out%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e3+5,mo=998244353;\nint n,x,f[N][N*2],C[N][N],i,j,ans=1;\ninline void add(int&x,const int&y){x+=y;x>=mo?x-=mo:0;}\nint main(){\n\tscanf(\"%d%d\",&n,&x);\n\tfor(i=**C=1;i<=n;++i)for(j=*C[i]=1;j<=n;++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\tfor(i=0,f[0][0]=1;i<n;++i)for(j=0;j<=i*2;++j)add(f[i+1][j+2],f[i][j]),add(f[i+1][j+1],f[i][j]);\n\tfor(i=1;i<=n;++i){\n\t\tint s=0;\n\t\tfor(j=0;j<x;++j)add(s,f[i][j]);\n\t\t\tfor(j=x+1;j<=i*2;j+=2)if(j>=i){\n\t\t\t\tint p=i-(j-x+1),q=x-1-(j-x+1);\n\t\t\t\tif(j>=x*2){if(j==i*2)add(s,x&1);}\n\t\t\t\t\telse if(p>=0 && q>=0)add(s,f[p][q]);\n\t\t\t}\n\t\tans=(ans+1ll*C[n][i]*s)%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 3002;\nconst int MOD = 998244353;\n\nint n, x;\nint pw2[MAX_N], C[MAX_N][MAX_N], f[MAX_N][MAX_N*2], g[MAX_N][MAX_N];\n\nvoid read_input() {\n    cin >> n >> x;\n}\n\n//void NTT(vector<int> &a, bool invert) {\n//    for (int i=0; i<n; ++i) {\n//        if (rev_bit[i] > i)\n//            swap(a[i], a[rev_bit[i]]);\n//    }\n//\n//    int n = a.size();\n//\n//    for (int len=2; len<=n; len <<= 1) {\n//        int wlen = invert ? ROOT : ROOT_1;\n//        for (int i=len; i<=ROOT_PW; i <<= 1)\n//            wlen = 1LL * wlen * wlen % MOD;\n//\n//        for (int i=0; i<n; i += len) {\n//            int w = 1;\n//            for (int j=0; j<len/2; ++j) {\n//                int u = a[i+j], v = 1LL * a[i+j+len/2] * w % MOD;\n//                a[i+j] = (u+v<MOD ? u + v : u + v - MOD);\n//                a[i+j+len/2] = (u-v>=0 ? u - v : u - v + MOD);\n//                w = 1LL * w * wlen % MOD;\n//            }\n//        }\n//    }\n//\n//    if (invert) {\n//        for (int i=0; i<n; ++i)\n//            a[i] = 1LL * a[i] * inv[n] % MOD;\n//    }\n//}\n\nvoid square(vector<int> &a) {\n//    vector<int> fa(a.begin(), a.end());\n//\n//    int n = 1;\n//\n//    while (n<a.size())\n//        n <<= 1;\n//\n//    fa.resize(n);\n//    NTT(a, false);\n//\n//    for (int i=0; i<n; ++i)\n//        fa[i] = 1LL * fa[i] * fa[i] % MOD;\n//    NTT(fa, true);\n\n    vector<int> res(a.size());\n\n    for (int i=0; i<a.size(); ++i) {\n        for (int j=0; i+j<a.size(); ++j) {\n            res[i+j] = (res[i+j] + 1LL * a[i] * a[j]) % MOD;\n        }\n    }\n\n    a = res;\n}\n\nvoid init() {\n//    for (int i=0; i<=n*2; ++i)\n//        inv[i] = pw(i, MOD-2);\n\n    for (int i=0; i<=n; ++i)\n        C[i][0] = C[i][i] = 1;\n\n    for (int i=1; i<=n; ++i) {\n        for (int j=1; j<i; ++j)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;\n    }\n\n    pw2[0] = 1;\n    for (int i=1; i<=n; ++i)\n        pw2[i] = pw2[i-1] * 2 % MOD;\n\n    f[0][0] = 1;\n\n    for (int l=1; l<=n; ++l) {\n        for (int s=0; s<=x; ++s) {\n            f[l][s] = f[l-1][s];\n            if (s>=1)\n                f[l][s] = (f[l][s] + f[l-1][s-1]) % MOD;\n            if (s>=2)\n                f[l][s] = (f[l][s] + f[l-1][s-2]) % MOD;\n        }\n    }\n    // debug(f[n][2]);\n}\n\nint case1() {\n    vector<int> h;\n\n    for (int t=0; t<=x/2; ++t) {\n        h.assign(n+1, 0);\n\n        for (int l=0; l<=n; ++l) {\n            if (l<=t)\n                h[l] = pw2[l];\n            else\n                h[l] = (h[l-1] * 2 - C[l-1][t] + MOD) % MOD;\n        }\n\n        square(h);\n        // if (t==1)\n        //     PR0(h, n+1);\n\n        for (int l=0; l<=n; ++l)\n            g[l][t] = h[l];\n    }\n    // debug(g[2][1]);\n\n    int res = 0;\n\n    for (int l=0; n-l-2>=0; ++l) {\n        for (int s=(x+1)%2; s+2<=x; s += 2) {\n            // cerr << l << ' ' << s << ' ' << f[l][s] * g[n-l-2][(x-2-s)/2] << '\\n';\n            res = (res + 1LL * f[l][s] * g[n-l-2][(x-2-s)/2]) % MOD;\n        }\n    }\n\n    if (x%2==0)\n        res = (res + g[n-1][(x-1)/2]) % MOD;\n    else\n        res = (res + pw2[n]) % MOD;\n\n    return res;\n}\n\nint case2() {\n    int res = 0;\n\n    for (int s=x%2; s<x; s += 2)\n        res = (res + f[n][s]) % MOD;\n\n    return res;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tread_input();\n\tinit();\n\t// debug(case1());\n    // debug(case2());\n\tcout << (case1() + case2()) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nll Co[3050][3050];\nint main() {\n\tint i, j, k;\n\tfor (i = 0; i <= 3020; i++) {\n\t\tCo[i][0] = Co[i][i] = 1;\n\t\tfor (j = 1; j < i; j++) Co[i][j] = (Co[i - 1][j - 1] + Co[i - 1][j]) % MOD;\n\t}\n\n\tll ans = 0;\n\tint N, X;\n\tscanf(\"%d %d\", &N, &X);\n\tfor (i = 0; i <= N; i++) {\n\t\tfor (j = 0; j <= N-i; j++) {\n\t\t\tll s = i + 2 * j;\n\n\t\t\tll cnt = 0;\n\t\t\tif (s < X) cnt = Co[i + j][i];\n\t\t\telse if (s < 2 * X) {\n\t\t\t\tll K = s - X;\n\t\t\t\tif (K % 2 && K != X-1) {\n\t\t\t\t\tint c2 = K + 1;\n\t\t\t\t\tif (j >= c2) cnt = Co[i + j - c2][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i == 0 && X % 2 == 1) cnt = 1;\n\t\t\t}\n\n\t\t\tans = (ans + cnt * Co[N][i + j]) % MOD;\n\t\t}\n\t}\n\treturn !printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nconst int maxn=3005;\nll f[maxn],inv[maxn],nf[maxn],s[maxn][maxn],dp[maxn][maxn],c[maxn],u[maxn*2],v[maxn*2];\nll ans;\nll C(ll x,ll y){\n    return f[x]*nf[y]%M*nf[x-y]%M;\n}\nvoid add(ll &x,ll y){\n    x+=y; if (x>=M) x-=M;\n}\nvoid add1(int l,int r,ll x){\n    add(u[l],x);\n    add(u[r+1],M-x);\n}\nvoid add2(int l,int r,ll x){\n    add(v[l],x);\n    add(v[r+1],M-x);\n}\nint n,k;\n\nint main(){\n    cin >> n >> k;\n    inv[1]=1; for (int i=2;i<maxn;i++) inv[i]=M-(M/i)*inv[M%i]%M;\n    f[0]=nf[0]=1; for (int i=1;i<maxn;i++) f[i]=f[i-1]*i%M,nf[i]=nf[i-1]*inv[i]%M;\n    dp[0][0]=1;\n    for (int i=0;i<n;i++)\n        for (int j=0;j<=min(i*2,k);j++)\n            add(dp[i+1][j+1],dp[i][j]),\n            add(dp[i+1][j+2],dp[i][j]);\n    for (int i=0;i<=n;i++)\n        for (int j=0;j<k;j++)\n            (ans+=dp[i][j]*C(n,i))%=M;\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=1; dp[1][1]=1;\n    for (int i=1;i<n;i++)\n        for (int j=0;j<=min(i*2,k);j++)\n            add(dp[i+1][j+1],dp[i][j]),\n            add(dp[i+1][j+2],dp[i][j]);\n    for (int i=0;i<n;i++)\n        for (int j=0;j<=k;j++)\n            s[i+1][j+1]=dp[i][j];\n    if (k%2==1){\n        for (int i=(k+1)/2;i<=n;i++) (ans+=C(n,i))%=M;\n    }\n    for (int i=1+k%2;i<k;i+=2) for (int p=1;p<=i;p++) if (s[p][i]) {\n\n        int r=(k-i)/2;\n        int L=(k-i+1)/2,R=r*2;\n        if (L<=R) {\n            add1(L+p,R+p,s[p][i]*(2*r+p+1)%M);\n            add2(L+p,R+p,M-s[p][i]);\n        }\n    }\n    for (int i=1;i<=n;i++) add(u[i],u[i-1]),add(v[i],v[i-1]);\n    for (int i=0;i<=n;i++) c[i]=(u[i]+v[i]*i)%M;\n    for (int i=1;i<=n;i++) (ans+=c[i]*C(n,i))%=M;\n    cout << (ans+M)%M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing ll = long long;\nconst int MOD = 998244353;\nconst int MX = 100005;\nint n, x;\nll ans;\nll exp(ll b, ll n){\n\tll res = 1;\n\tfor(; n; n/=2,(b*=b)%=MOD) if(n%2) (res *= b) %= MOD;\n\treturn res;\n}\nll fact[MX] = {1}, invf[MX];\nvoid setcomb(int n){\n\tfor(int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % MOD;\n\tinvf[n] =  exp(fact[n] ,MOD-2);\n\tfor(int i = n; i > 0; i--) invf[i-1] = (invf[i] * i) % MOD;\n}\ninline ll comb(int a, int b){return fact[a] * invf[a-b] % MOD * invf[b] % MOD;}\n\nint main(){\n\tscanf(\"%d%d\", &n, &x);\n\tsetcomb(n);\n\trep(i,n+1) rep(j,n+1-i){\n\t\tint s = i + j*2, k = s - x;\n\t\tif(k < 0) ans += comb(n,i+j) * comb(i+j,i) % MOD;\n\t\telse if(k&1 && (k+1 <= j || !i)){\n\t\t\tans += comb(n,i+j) * comb(i+j-min(k+1,j),i) % MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans % MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  // mint(long long);\n  inline mint(long long v)\n      : v(fast == 0 ? (v < 0 ? (v % MODS[kind] + MODS[kind]) % MODS[kind]\n                             : (v >= MODS[kind] ? v % MODS[kind] : v))\n                    : (v)) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n  void take_mod() { v %= MODS[kind]; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\nvector<vector<mint<>>> comb_table;\n\nmint<> comb(LL N, LL K) {\n  if (N < K) return 0;\n  if (K < 0) return 0;\n  return comb_table[N][K];\n}\n\nvoid init(int N) {\n  comb_table.resize(N + 6);\n  for (int i = 0; i <= N; i++) {\n    comb_table[i].resize(i + 1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for (int j = 1; j < i; j++) {\n      comb_table[i][j] = comb_table[i - 1][j - 1] + comb_table[i - 1][j];\n    }\n  }\n}\n\nvoid solve(long long N, long long X) {\n  init(N);\n  mint<> zero = 0;\n  // auto dp = exvector(zero, 2 * N + 5, N + 5);\n  mint<> dp[6005][3005];\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nint mul(int a, int b) {\n  return (int)((long long)a * b % mod);\n}\n\nint pw(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b /= 2;\n  }\n  return res;\n}\n\nint inv(int a) {\n  return pw(a, mod - 2);\n}\n\nconst int N = 3'009;\n\nint f[N];\nint rf[N];\nint c[N][N];\n\nint main() {\n  f[0] = 1;\n  rf[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    f[i] = mul(f[i - 1], i);\n    rf[i] = inv(f[i]);\n  }\n  memset(c, 0, sizeof c);\n  for (int i = 0; i < N; ++i) {\n    c[i][0] = 1;\n    c[i][i] = 1;\n    for (int j = 1; j < i; ++j) {\n      c[i][j] = c[i - 1][j - 1];\n      add(c[i][j], c[i - 1][j]);\n    }\n  }\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  int ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; i + j <= n; ++j) {\n      if (i + j * 2 < m - 1) {\n        add(ans, mul(mul(f[i + j], mul(rf[i], rf[j])), c[n][i + j]));\n      }\n    }\n  }\n  for (int i = 0; i <= n; ++i) {\n    int rem = (m - 1) - i * 2;\n    if (rem < 0) {\n      break;\n    }\n    for (int j = 0; j <= n; ++j) {\n      int k = rem - j * 2;\n      if (k < 0) {\n        break;\n      }\n      if (i * 2 + j + k <= n) {\n        add(ans, mul(mul(f[j + k], mul(rf[j], rf[k])), c[n][i * 2 + j + k]));\n      }\n    }\n  }\n  if ((m - 1) % 2 == 0) {\n    int q = (m - 1) / 2;\n    for (int i = 1; 2 * q + i <= n; ++i) {\n      add(ans, c[n][2 * q + i]);\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = 1000000007, int fast = 0>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = Z>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast == 0 ? (v < 0 ? (v % mod() + mod()) % mod()\n                             : (v >= mod() ? v % mod() : v))\n                    : (v)) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, int fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, int fast, int fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, int fast, int fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, int fast, int fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, int fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, int fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n// vector<vector<mint<>>> comb_table;\nconst long long MOD = 998244353;\n\nmint<MOD> comb_table[3050][3050];\n\nmint<MOD> comb(LL N, LL K) {\n  if (N < K) return 0;\n  if (K < 0) return 0;\n  return comb_table[N][K];\n}\n\nvoid init(int N) {\n  //  comb_table.resize(N + 6);\n  for (int i = 0; i <= N; i++) {\n    //    comb_table[i].resize(i + 1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for (int j = 1; j < i; j++) {\n      comb_table[i][j] = comb_table[i - 1][j - 1] + comb_table[i - 1][j];\n    }\n  }\n}\nmint<MOD> dp[6005][3005];\nvoid solve(long long N, long long X) {\n  init(N);\n\n  mint<MOD> zero = 0;\n  // auto dp = exvector(zero, 2 * N + 5, N + 5);\n  for (int j = 0; j <= N + 1; j++) dp[0][j] = 0;\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<MOD, 1> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nオーダー\n10**6\t余裕を持って間に合う\t\n10**7\tおそらく間に合う\t余裕を持って間に合う\n10**8\t非常にシンプルな処理でない限り厳しい\tおそらく間に合う\n10**9\t\t非常にシンプルな処理でない限り厳しい\nlogn\t:OK\nn\t\t:10^7\nnlogn\t:10^6\nn**2\t:10^4\nn**3\t:300\n2**n\t:20\nn!\t\t:10\n\n\n\n// 各桁の和を計算する関数\nint findSumOfDigits(int n) {\n  int sum = 0;\n  while (n > 0) { // n が 0 になるまで\n    sum += n % 10;\n    n /= 10;\n  }\n  return sum;\n}\n\nsort(a, a + N, greater<int>());  // a[0:N] を大きい順にソート\n\nint num[110] = {0};  // バケット\nfor (int i = 0; i < N; ++i) {\n    num[d[i]]++;  // d[i] が 1 個増える\n}\n\nmap<string, int> mp; // 連想配列 map<キー型, 値型> オブジェクト名\nfor (int i = 0; i < N; ++i) {\n    auto itr = mp.find(s[i]);        // s[i] が設定されているか？\n    if(itr != mp.end() ) {\n         mp[s[i]] += 1;\n    }\n    else {\n         mp[s[i]] += 1 ;\n    }\n}\nstack<int> s;\t//intをデータとするスタックを用意\ns.push(1);\t\t//{} -> {1}\nprintf(\"%d\\n\", s.top());\t// 3\ns.pop();\n\nqueue<int> que;\t//intをデータとするキューを用意\nque.push(1);\t\t//{} -> {1}\nprintf(\"%d\\n\", que.front());\t// 1\nque.pop();\n*/\n\n#include <iostream>\n#include <set>\n#include <map>\n#include <string>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <string.h>\n\nusing namespace std;\n\n// #define for(i,a,b) for (int i=(a);i<(b);++i)\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define REP(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define pb push_back // vectorに要素追加\n#define INF (ll)1e18\n// int \n// // 各桁の和を計算する関数\n// int findSumOfDigits(int n) {\n//   int amari = 0;\n//   int keta = 0;\n//   while (n > 0) { // n が 0 になるまで\n//     amari += n % 2;\n//     if (keta%2==0)\n//     n /= 10;\n//   }\n//   return sum;\n// }\n \nll gcd(ll a, ll b) {\n\tif(b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\n// const ll MAX_N = 1e5;\n// ll N;\n// ll h[MAX_N];\n// ll dp[MAX_N+1]; // メモ化テーブル\n \n// // i番目以降の品物から重さの総和がj以下になるように選ぶ\n// void rec(ll i){\n// \tif (i==0) dp[i] = 0;\n// \telse if (i==1) dp[i] = abs(h[1]-h[0]);\n// \telse dp[i] = min(dp[i-1]+abs(h[i]-h[i-1]), dp[i-2]+abs(h[i]-h[i-2]));\n// \treturn;\n// }\nll comb(ll n, ll r){\n\tll ans = 1;\n\tfor (ll i = 0; i < r; ++i){\n\t\tans *= n - i;\n\t}\n\tfor (ll i = 0; i < r; ++i){\n\t\tans /= r - i;\n\t}\n\treturn ans;\n}\n\n \nint main() {\n\t// 入力\n\tll N,X;\n\tcin >> N>>X;\n\t\n\t\n\tll ans = 0;\n\tif (X%2==0){\n\t\tREP(a,N+1){\n\t\t\tREP(b,N+1){\n\t\t\t\tif (a*2+b>=X) continue;\n\t\t\t\tif (a+b>N) continue;\n\t\t\t\t\n\t\t\t\tll tmp =  comb(N,a) * comb(N-a, b);\n\t\t\t\t// printf(\"a: %lld ,b: %lld, tmp: %lld\\n\",a,b,tmp);\n\t\t\t\tans += tmp;\n\t\t\t\tans %= 998244353;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tREP(a,N+1){\n\t\t\tREP(b,N+1){\n\t\t\t\tif (a*2+b>=X) continue;\n\t\t\t\tif (a+b>N) continue;\n\t\t\t\tif (b==0) continue;\n\t\t\t\t\n\t\t\t\tll tmp =  comb(N,a) * comb(N-a, b);\n\t\t\t\t// printf(\"a: %lld ,b: %lld, tmp: %lld\\n\",a,b,tmp);\n\t\t\t\tans += tmp;\n\t\t\t\tans %= 998244353;\n\t\t\t}\n\t\t}\n\t\tREP(a,N+1){\n\t\t\tll tmp =  comb(N,a);\n\t\t\t// printf(\"a: %lld ,b: 0, tmp: %lld\\n\",a,tmp);\n\t\t\tans += comb(N,a);\n\t\t\tans %= 998244353;\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,x;\nll dp[3005][6005][1];\nll C[3005][3005];\nint main(){\n\tcin>>n>>x;\n\tdp[0][0][0] = 1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<6005;j++){\n\t\t\trep(k,1){\n\t\t\t\tif(dp[i][j][k] == 0) continue;\n\t\t\t\tdp[i+1][j][k] += dp[i][j][k];\n\t\t\t\tdp[i+1][j+1][k] += dp[i][j][k];\n\t\t\t\tdp[i+1][j+2][k] += dp[i][j][k];\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<6005;j++){\n\t\t\trep(k,1) dp[i+1][j][k] %= mod;\n\t\t}\n\t}\n\trep(i,3003)rep(j,i+1){\n\t\tif(j==0||j==i)C[i][j]=1;\n\t\telse C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tll ans = 0;\n\tfor(int j=0;j<x;j++) ans += dp[n][j][0];\n\n\tif(x%2 == 1){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(2*i <= x) continue;\n\t\t\tans += C[n][i];\n\t\t}\n\t}\n\tfor(int a=1;a<=n;a++){\n\t\tif(2*a >= x-1) break;\n\t\tint zan = x-1-2*a;\n\t\tfor(int b=1;b<=n;b++){\n\t\t\tif(zan < b) break;\n\t\t\tif((zan-b)%2 != 0) continue;\n\t\t\tint all = 2*a+b+(zan-b)/2;\n\t\t\tif(n>=all){\n\t\t\t    ans += C[n][all]*C[(zan-b)/2+b][b]%mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans%mod+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 998244353LL\n#define maxn 100005\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 1000000000\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii;\n\n\nclass numberTheory{\n\npublic:\n    numberTheory(){}\n\n    pii extendedEuclid(i64 a, i64 b) { // returns x, y | ax + by = gcd(a,b)\n\n        if(b == 0) return pii( a >= 0 ? 1 : -1 , 0LL);\n        else {\n            pii d = extendedEuclid(b, a % b);\n            return pii(d.yy, d.xx - d.yy * (a / b));\n        }\n\n    }\n\n    i64 modularInverse(i64 a, i64 n) {\n        pair<i64,i64> ret = extendedEuclid(a, n);\n        return ((ret.xx % n) + n) % n;\n    }\n\n\n    i64 bigMod(i64 a, i64 n , i64 m)\n    {\n        if(n==0) return 1 ;\n        i64 ret = bigMod(a,n/2,m) ;\n        ret = (ret*ret)%m ;\n        if(n%2) ret = (ret*a)%m ;\n        return ret ;\n    }\n};\n\nconst i64 N = 100000 ;\n\ni64 fact[N+5] , invFact[N+5] ;\n\ni64 C(i64 n, i64 r)\n{\n    if( n<0 || r<0 || r>n ) return 0 ;\n    i64 ret = (fact[n]*invFact[r])%mod ;\n    return (ret*invFact[n-r])%mod ;\n}\n\nvoid preprocess()\n{\n    numberTheory nt ;\n\n    fact[0] = 1 ;\n    for(i64 x=1 ; x<=N ; x++) fact[x] = (fact[x-1]*x)%mod ;\n\n    invFact[N] = nt.modularInverse(fact[N],mod) ;\n\n    for(i64 x=N-1 ; x>=0 ; x--) invFact[x] = (invFact[x+1]*(x+1) )%mod ;\n}\n\ni64 used[3005] ;\ni64 dp[3005][3005] ;\n\nint main()\n{\n    preprocess() ;\n\n    int n , x ;\n    scanf(\"%d %d\",&n,&x) ;\n\n    for(int i=0 ; i<=n ; i++)\n    {\n        used[i] = C(n,i) ;\n    }\n\n    i64 ans = 1 ; //all zeroes\n\n    for(int var=1 ; var<=n ; var++)\n    {\n        for(int sum=var ; sum<x ; sum++)\n        {\n            ans += (C(var , sum-var )*used[var]) ;\n            ans%= mod ;\n        }\n    }\n\n    if( x%2==1 )\n    {\n        for(int i=x+1 ; i<=2*n ; i+=2) ans = ( ans + used[i/2] )%mod ;\n    }\n\n    for(int i=1 ; i<=n ; i++) used[i] = ( used[i] + used[i-1] )%mod ;\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        int sum = ( (x-1) - ( 2*(i-1) + 1 ) ) ;\n\n        if( sum < 0  ) continue ;\n\n        for(int j=0 ; j<=sum && i+j<=n ; j++ )\n        {\n            dp[i][j+i] = ( dp[i][j+i] + C( j , sum-j ) )%mod ;\n        }\n    }\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        for(int j=1 ; j<=n ; j++)\n        {\n            if( dp[i][j]==0 ) continue ;\n            int lim = min( i-1 , n-j ) ;\n            ans = ( ans + dp[i][j]*( used[j+lim] - used[j] ) )%mod ;\n        }\n    }\n\n    ans = ( ans%mod + mod )%mod ;\n\n    printf(\"%lld\\n\",ans) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <unordered_map>\n\nlong long pow_mod(long long x, long long n, long long mod_num) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) { res = (res * x) % mod_num; }\n        x = (x * x) % mod_num;\n        n = (n >> 1);\n    }\n    return res;\n}\n\nclass Combi_Num {\n    public:\n    long long mod_num;\n    std::vector<long long> factorial, factorial_inv, inv;\n    Combi_Num() {}\n    Combi_Num(const int n, const long long mod_num_in) {\n        mod_num = mod_num_in;\n        factorial.resize(n+1, 0);\n        factorial_inv.resize(n+1, 0);\n        inv.resize(n+1, 0);\n        factorial[0] = 1;\n        factorial_inv[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = (factorial[i-1] * i) % mod_num;\n            inv[i] = pow_mod(i, mod_num - 2, mod_num);\n            factorial_inv[i] = (factorial_inv[i-1] * inv[i]) % mod_num;\n\n            //std::cout << factorial[i] << \" \" << factorial_inv[i] << \" \" << inv[i] << std::endl;\n\n        }\n    }\n\n    long long combi(const int n, const int r) {\n        return (factorial[n] * ((factorial_inv[r] * factorial_inv[n-r]) % mod_num)) % mod_num;\n    }\n\n    long long perm(const int n, const int r) {\n        return (factorial[n] * factorial_inv[n-r]) % mod_num;\n    }\n};\n\nclass BIT {\n    // Binary Indexed Tree : 数列要素1つへの加算、数列のある地点までの累積和を高速に計算\n    public:\n    std::vector<long long> data;\n    BIT() {}\n    BIT(const int size) {\n        // 想定されるサイズの2倍の値を入れた方がいいかもしれない。数列は1から数えることを想定している。\n        data.resize(size, 0);\n    }\n    long long sum(int i) const {\n        long long s = 0;\n        while (i > 0) {\n            s += data[i];\n            i = i & (i-1); // iの最後のビットを引く。\n        }\n        return s;\n    }\n\n    void add(int i, long long x) {\n        while (i < data.size()) {\n            data[i] += x;\n            i += i - (i & (i-1)); // iの最後のビットを加算する。\n        }\n    }\n};\n\nclass BIT2 {\n    // Binary Indexed Tree 2つ : 数列区間への加算、数列のある地点までの累積和を高速に計算。\n    public:\n    BIT bit[2];\n    BIT2() {}\n    BIT2(const int size) {\n        bit[0] = BIT(size);\n        bit[1] = BIT(size);\n    }\n    long long sum(int i) const {\n        return bit[1].sum(i) * i + bit[0].sum(i);\n    }\n    void add(int l, int r, long long x) {\n        // [l,r]にxを加算。閉区間であり、rを含む点に注意。l=rの時、一つの値のみを操作できることになる。\n        bit[0].add(l, -x * (l - 1));\n        bit[1].add(l, x);\n        bit[0].add(r + 1, x * r);\n        bit[1].add(r + 1, -x);\n    }\n};\n\nconst long long MOD = 998244353;\nconst int MAX_N = 3050;\nint N, X;\n\nCombi_Num combi_num = Combi_Num(MAX_N, MOD);\nBIT2 bit2 = BIT2(MAX_N*2);\n\nlong long func12_free(int L, int sum) {\n    // 長さL、総和sumの1,2配列個数。\n    if (L < 0) { return 0; }\n\n    if (L <= sum && sum <= L * 2) {\n        int num2 = sum - L;\n        return combi_num.combi(L, sum - L);\n    } else {\n        return 0;\n    }\n}\n\nlong long solve() {\n    if (X == 1) {\n        return pow_mod(2, N, MOD);\n    }\n\n    long long ret = 0;\n    // 合計がX-2以下\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j + i <= N; j++) {\n            if (i * 2 + j <= X - 2) {\n                ret += (combi_num.combi(N, i) * combi_num.combi(N - i, j)) % MOD;\n                ret = ret % MOD;\n            }\n        }\n    }\n\n    // X-1を作ることができるが、Xを作ることができない。\n    // この条件の長さLの1,2配列の数を各Lに関して計算。\n    if ((X - 1) % 2 == 0) {\n        // X-1が偶数のときは、全て2にする手法が(X - 1)/2以上のLについて存在。\n        bit2.add((X - 1)/2, (X - 1)/2 + N, 1);\n    }\n    for (int p1 = 1; p1 <= N; p1++) {\n        if (p1 * 2 - 1 <= X - 1) {\n            for (int p2 = p1; p2 <= N; p2++) {\n                // はじめて1が出てくる位置がp1、はじめて和がX-1になる位置がp2となる長さp2の数列の数をRとすると、\n                // 長さp2～p2+p1-1の数列それぞれに関して、Rだけ条件を満たす数列が存在することになる。\n                bit2.add(p2, p2 + p1 - 1, func12_free(p2 - p1, (X - 1) - (p1 * 2 - 1)));\n                // long long の範囲を超えることは無いので、MODはとらないでおく。\n            }\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        long long tmp = (bit2.sum(i) - bit2.sum(i-1)) % MOD; // 長さi、総和X-1以上、Xを作れない1,2配列の数\n        ret = (ret + tmp * combi_num.combi(N, i)) % MOD;\n    }\n    return ret;\n}\n\n\nint main(int argc, char **argv) {\n    std::cin >> N >> X;\n\n    std::cout << solve() << std::endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n1 \n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=6005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=998244353;\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll C[maxn][maxn];\n\nint main()\n{\n\tIOS;\n\tll n,x;\n\tcin>>n>>x;\n\n\tREP(i,maxn-1) for(int j=0;j<=i;j++){\n\t\tif(j==0||j==i) C[i][j]=1;\n\t\telse{\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t\tif(C[i][j]>=MOD) C[i][j]-=MOD;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int len=0;len<=n;len++){\n\t\tll sum=0;\n\n\t\tfor(int a=1;a+a<=len;a++){\n\t\t\tif(x-1-len>=0&&len-a-a>=x-1-len){\n\t\t\t\tsum+=C[len-a-a][x-1-len];\n\t\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int t=len;t<x;t++){\n\t\t\tsum+=C[len][t-len];\n\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t}\n\t\tif(x%2==1&&2*len>=x&&len>=x) sum++;\n\t\t// cout<<len<<' '<<sum<<' '<<C[n][n-len]<<'\\n';\n\t\tans+=sum*C[n][n-len]%MOD;\n\t\tif(ans>=MOD) ans-=MOD;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef UTIL_INCLUDED\n#define UTIL_INCLUDED\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n#define DEBUGGING\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\n\nnamespace __init {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(0);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifndef DEBUG_FILE\n#ifdef DEBUGGING\n#include \"../debug.cpp\"\n#else\n#define DEBUG(...) 0\n#endif\n#endif\n\n#endif\n\nconst ll MOD = 998244353;\n\nclass Combination {\nprivate:\n    template <typename T> using V = vector<ll>;\n    ll N;\n    ll MOD;\n    V<ll> factv, rfactv;\n\npublic:\n    /*\n     * MOD must be a prime number.\n     */\n    Combination(ll N, ll MOD)\n        : N(N), \n          MOD(MOD),\n          factv(N + 1, 1),\n          rfactv(N + 1)\n    {\n        for(ll i = 1; i <= N; i++) {\n            factv[i] = factv[i - 1] * i % MOD;\n        }\n        for(ll i = 0; i <= N; i++) {\n            rfactv[i] = pow(factv[i], MOD - 2);\n        }\n    }\n\n    ll fact(ll n) {\n        return factv[n];\n    }\n\n    ll rfact(ll n) {\n        return rfactv[n];\n    }\n\n    ll pow(ll a, ll b) {\n        return b ? (b & 1 ? a : 1) * pow(a * a % MOD, b / 2) % MOD : 1;\n    }\n\n    ll comb(ll n, ll k) {\n        return factv[n] * rfactv[n - k] % MOD * rfactv[k] % MOD;\n    }\n};\n\nint main() {\n    ll N, X;\n    cin >> N >> X;\n\n    Combination comb(1e5, MOD);\n    ll ans = 0;\n    for(ll one = 0; one <= N; one++) {\n        for(ll two = 0; one + two <= N; two++) {\n            ll cells = one + two;\n            ll sum = one + 2 * two;\n            if(sum == X) continue;\n            if(sum < X) {\n                ll tmp = comb.comb(N, cells) * comb.comb(cells, two) % MOD;\n                (ans += tmp) %= MOD;\n            }\n            if(sum > X) {\n                ll rest = sum - X;\n                if(rest % 2 == 0) continue;\n                ll tmp;\n                if(one == 0) {\n                    tmp = comb.comb(N, cells) % MOD;\n                } else { \n                    ll cnt = rest / 2 + 1;\n                    if(cnt * 2 > two) continue;\n                    tmp = comb.comb(N, cells) * comb.comb(cells - 2 * cnt, two - 2 * cnt) % MOD;\n                }\n                (ans += tmp) %= MOD;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 3005\n\nint dp[N][N*2], ap[N][N][2];\n\nint n, X, f[N]={1,1}, rf[N]={1,1}, iv[N]={1,1};\n\nconst int mod = 998244353;\n\nint add(int &a, int b) {\n\ta += b;\n    if (a >= mod) a -= mod;\n}\nint sub(int &a, int b) {\n    a -= b;\n    if (a < 0) a += mod;\n}\nint C(int n, int k) {\n\treturn 1ll * f[n] * rf[k] % mod * rf[n-k] % mod;\n}\n\nint main() {\n    for (int i = 2; i < N; i ++) {\n        f[i] = 1ll * f[i-1] * i % mod;\n        iv[i] = 1ll * (mod/i) * (mod-iv[mod%i]) % mod;\n        rf[i] = 1ll * rf[i-1] * iv[i] % mod;\n    }\n    ap[0][0][0] = 1;\n    scanf(\"%d %d\", &n, &X);\n    if (X == 1) {\n\t\tint res = 1;\n        for (int i = 1; i <= n; i ++) {\n\t\t\tres <<= 1;\n\t\t\tif (res >= mod) res -= mod;\n        }\n        printf(\"%d\\n\", res);\n        return 0;\n    }\n    int up = X>>1;\n    for (int d = 1; d <= n; d ++) {\n        ap[d][0][0] = d+1;\n        for (int e = 1; e <= up; e ++) {\n            add(ap[d][e][0], ap[d-1][e][0]);\n            add(ap[d][e][0], ap[d-1][e][1]);\n            add(ap[d][e][1], ap[d-1][e-1][0]);\n            add(ap[d][e][1], ap[d-1][e][1]);\n        }\n    }\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i ++) {\n        for (int j = 0; j <= X; j ++) if (dp[i-1][j]) {\n\t\t\tadd(dp[i][j+2], dp[i-1][j]);\n            add(dp[i][j+1], dp[i-1][j]);\n            add(dp[i][j], dp[i-1][j]);\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < X; i ++) add(ans, dp[n][i]);\n    if (X&1) {\n        int K = X;\n        for (int i = K; i <= n; i ++) add(ans, C(n, i));\n    }\n    for (int l = 0; l <= n-2; l ++) {\n        for (int s = 0; s <= X-3; s ++) {\n            int sum = X-3-s;\n            if (sum&1) continue;\n            int d = sum>>1;\n            add(ans, 1ll * dp[l][s] * ap[n-l-2][d][0] % mod);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\n\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  //mint(long long v) : v((v % MODS[kind] + MODS[kind]) % MODS[kind]) {}\n  mint(long long v) : v(v % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind>\nostream& operator<<(ostream& os, const mint<kind>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind>\nbool operator==(mint<kind>& a, mint<kind> b) {\n  return a.v == b.v;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, mint<kind> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, mint<kind> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind>\nmint<kind>& operator+=(mint<kind>& a, long long b) {\n  a.v += b;\n  return a;\n  //return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind>\nmint<kind> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\n\nvector<vector<mint<>>> comb_table;\n\n\nmint<> comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return comb_table[N][K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+6);\n  for(int i=0; i<=N; i++) {\n    comb_table[i].resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<i; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n    }\n  }\n  \n}\n\n\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  \n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1);// % MOD ;\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2);// % MOD;\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long LL;\nconst int _=1e2;\nconst int maxn=3e3+_;\nconst LL mod=998244353;\ninline LL ad(LL x,LL y){return (x>=mod-y)?x-mod+y:x+y;}\ninline LL re(LL x,LL y){return (x<y)?x-y+mod:x-y;}\nint n,x;\nLL C[maxn][maxn],f[maxn][2*maxn];//只放1、2长度为i和为j的序列方案数 \nvoid yu()\n{\n\tC[0][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=ad(C[i-1][j-1],C[i-1][j]);\n\t}\n\tf[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<x;j++)\n\t\t\tif(f[i][j])\n\t\t\t{\n\t\t\t\tf[i+1][j+1]=ad(f[i+1][j+1],f[i][j]);\n\t\t\t\tf[i+1][j+2]=ad(f[i+1][j+2],f[i][j]);\n\t\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&x); yu();\n\tLL ans=1;\n\tfor(int L=1;L<=n;L++)\n\t{\n\t\tLL sum=0;\n\t\tfor(int S=1;S<=2*L;S++)\n\t\t{\n\t\t\tif(S<x)sum=ad(sum,f[L][S]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif((x%2==0)^(S%2==0))\n\t\t\t\t{\n\t\t\t\t\tif(L*2==S)sum=ad(sum,1);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint lp=(S-x+2)/2+1,rp=(x+2*L-S)/2;//最左/右的1的位置 \n\t\t\t\t\t\tif(1<=lp&&lp<=L&&1<=rp&&rp<=L&&lp<=rp)\n\t\t\t\t\t\t\tsum=ad(sum,f[rp-lp+1][S-2*(L-(rp-lp+1))]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=ad(ans,C[n][L]*sum%mod);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = 998244353;\nconst int maxn = 3010;\n\nint X;\nll way[maxn][maxn * 2];\nll comb[maxn][maxn];\n\nll f(int num, int sum) {\n\t//if (sum == X || sum == X * 2) return 0;\n\tif (sum == X) return 0;\n\n\tll res = 0;\n\tif (sum < X) {\n\t\tres = way[num][sum];\n\t} else { //sum >= X\n\t\tif (X <= sum - X) {\n\t\t\tif (sum % 2 == 0 && X % 2 != 0 && num == sum / 2) {\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((sum - X - 1) % 2 == 0) {\n\t\t\t\tint zan = num - (sum - X + 1);\n\t\t\t\tif (zan >= 0 && X * 2 - sum - 2 >= 0) {\n\t\t\t\t\tres = way[zan][X * 2 - sum - 2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\trep(i, maxn) {\n\t\tcomb[i][0] = comb[i][i] = 1;\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tcomb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n\t\t}\n\t}\n\n\tway[0][0] = 1;\n\tfor (int i = 0; i < maxn - 1; ++i) {\n\t\trep(j, maxn * 2) {\n\t\t\tif (way[i][j] == 0) continue;\n\t\t\tway[i+1][j+1] = (way[i+1][j+1] + way[i][j]) % MOD;\n\t\t\tway[i+1][j+2] = (way[i+1][j+2] + way[i][j]) % MOD;\n\t\t}\n\t}\n\n\tint N; cin >> N >> X;\n\n\tll ans = 0;\n\n\tfor (int num = 0; num <= N; ++num) { //1 or 2\n\t\tfor (int S = num; S <= 2 * num; ++S) {\n\t\t\t//cout << num << \" \" << S << \" \" << f(num, S) << endl;\n\t\t\tans = (ans + f(num, S) * comb[N][num]) % MOD;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int mygetchar()\n{\n#ifdef WIN32\n\treturn _getchar_nolock();\n#else\n\treturn getchar_unlocked();\n#endif\n}\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = mygetchar();\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == '-') f = -1;\n\t\tc = mygetchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tx = x * 10 + c - '0';\n\t\tc = mygetchar();\n\t}\n\treturn x * f;\n}\n\nconst int MOD = 998244353;\ninline void add(int &x, int y) {x += y; if (x >= MOD) x -= MOD;}\ninline int inc(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int mul(int x, int y) {return (ll)x * y % MOD;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nconst int MAXN = 6005;\nint n, X, c[MAXN][MAXN], ans = 0;\n\ninline int Solve(int len)\n{\n\tint res = 0;\n\tif (len * 2 < X || X & 1) res = 1;\n\tfor (int i = 0; i < len; i ++)\n\t{\n\t\tif (len + i < X)\n\t\t\tadd(res, c[len][i]);\n\t\telse if ((len + i - X) & 1)\n\t\t{\n\t\t\tint S = len + i, l = (S - X + 1) / 2;\n\t\t\tif (len > l + l && i >= l + l) add(res, c[len - l - l][i - l - l]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tn = read(), X = read();\n\tfor (int i = 0; i <= n * 2; i ++) c[i][0] = 1;\n\tfor (int i = 1; i <= n * 2; i ++)\n\t\tfor (int j = 1; j <= i; j ++)\n\t\t\tc[i][j] = inc(c[i - 1][j], c[i - 1][j - 1]);\n\tfor (int i = 0; i <= n; i ++)\n\t\tadd(ans, mul(c[n][i], Solve(n - i)));\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    int m=fact.size();\n    if(n<m) return;\n    \n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n    \n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    if(n==0) return Mint(1);\n    k=min(k,n);\n    init(k);    \n    vector<Mint> dp(k+1);\n    dp[0]=Mint(1);\n    for(int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);    \n    Mint res;\n    for(int i=1;i<=k;i++)\n      res+=Mint(i).pow(n)*finv[i]*dp[k-i];    \n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nusing M = Mint<int, 998244353>;\nsigned main(){\n  M::init(1e5);\n\n  auto calc=[&](int a,int b){return M::C(b,a-b);};\n  \n  int n,x;\n  cin>>n>>x;\n\n  M ans(1);\n  for(int s=0;s<x;s++)\n    for(int p=1;p<=n;p++)\n      ans+=calc(s,p)*M::C(n,p);\n\n  for(int s=x+1;s<=n*2;s+=2){\n    int i=(s-x+1)/2;\n    if(s-4*i<0){\n      if(~s&1) ans+=M::C(n,s/2);\n    }else{    \n      for(int p=1;p<=n;p++)\n        ans+=calc(s-4*i,p-2*i)*M::C(n,p);\n    }\n  }\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353; //1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return modInt<mod>(n%mod)/m;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tvector<mint> fib(112345);\n\tfib[0]=1;\n\trep(i,102345){\n\t\tfib[i+1]+=fib[i];\n\t\tfib[i+2]+=fib[i];\n\t}\n\tint n,x;\n\tcin>>n>>x;\n\tmint re=0;\n\trep(s,2*n+1){\n\t\tif(s<x){\n\t\t\trep(one,s+1){\n\t\t\t\tint two=s-one;\n\t\t\t\tif(two<0) continue;\n\t\t\t\tif(two%2) continue;\n\t\t\t\ttwo/=2;\n\t\t\t\tre+=comb(n,one+two)*comb(one+two,one);\n\t\t\t\t//fact[n]*finv[n-one-two]*finv[one]*finv[two];\n\t\t\t}\n\t\t}else{\n\t\t\tif(s==x) continue;\n\t\t\tint r=x-1,l=s-x+1;\n\t\t\tif(l%2) ++l;\n\t\t\tif(r%2!=s%2) --r;\n\t\t\tif(l<r){\n\t\t\t\trep(one,r-l+1){\n\t\t\t\t\tint two=r-l-one;\n\t\t\t\t\tif(two%2) continue;\n\t\t\t\t\ttwo/=2;\n\t\t\t\t\tmint p=comb(one+two,one);\n\t\t\t\t\tre+=p*comb(n,one+two+l/2+(s-r)/2);\n\t\t\t\t}\n\t\t\t\tout(l,r,1);\n\t\t\t}else{\n\t\t\t\tif(x%2==0) continue;\n\t\t\t\tif(s%2) continue;\n\t\t\t\tre+=comb(n,s/2);\n\t\t\t}\n\t\t}\n\t\tout(s,re,1);\n\t}\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(),x.end()\n#define all(x) x.begin(),x.end()\n#define fi first\n#define se second\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define erase_duplicates(x) sort(all(x)); (x).resize(distance((x).begin(), unique(all(x))));\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set = tree<\nT,\nnull_type,\nless<T>,\nrb_tree_tag,\ntree_order_statistics_node_update>;\n\n//X.find_by_order(k); - zwraca iterator na k-ty element (numeracja od zerowego)\n//X.order_of_key(k); - zwraca liczbę elementów ostro mniejszych niż k\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<char> VC;\ntypedef long double LD;\ntypedef pair<LD,LD> PLD;\ntypedef vector<LD> VLD;\ntypedef vector<PLD> VPLD;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\" = \"<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<\" = \"<<h<<\", \"; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#define cerr if(0)cout\n#endif\n\nconst int maxn = (3e3)+7;\nconst int maxk = 20;\nconst int inf = (1e9)+7;\nconst LL LLinf = ((LL)1e18)+7LL;\nconst LD eps = 1e-9;\nconst LL mod = 998244353LL;\n\n// ***************************** CODE ***************************** //\n\nLL dp[maxn];\nLL poch[maxn];\nLL stala[maxn];\nLL net[maxn][maxn];\n\nint main()\n{\n\t_upgrade\n  int n, x;\n  cin>>n>>x;\n  net[0][0] = 1;\n  dp[0] = 1;\n  for(int i = 1;i <= n;i++)\n    for(int j = 0;j <= i;j++)\n      net[i][j] = ((j == 0 ? 0 : net[i - 1][j - 1]) + net[i - 1][j]) % mod;\n  if(x & 1)\n  {\n    for(int i = 1;i <= n;i++)\n      dp[i]++;\n    for(int i = 0;i <= n;i++)\n      for(int j = 0;j <= n;j++)\n        if(i + j + 1 <= n && (2 * i + 2 * j + 1 < x))\n          dp[i + j + 1]++;\n  }\n  else\n  {\n    for(int i = 1;i * 2 < x;i++)\n      dp[i]++;\n    for(int i = 0;i <= n;i++)\n      for(int j = 0;j <= n;j++)\n        if(i + j + 1 <= n && 2 * i < x && 2 * j < x)\n          dp[i + j + 1]++;\n  }\n   LL res = 0LL;\n    // for(int i = 0;i <= n;i++)\n    // {\n    //   res = (res + net[n][i] * dp[n - i]) % mod;\n    // }\n    // res %= mod;\n    // res += mod;\n    // res %= mod;\n    // cout<<res<<endl;\n  for(int dl = 0;dl <= n - 2;dl++)\n    for(int dwa = 0;dwa <= dl;dwa++)\n    {\n      int jed = dl - dwa;\n      int suma = jed + dwa * 2 + 2;\n      if(suma >= x) continue;\n      if(suma % 2 == x % 2)\n      {\n        int dodaj = (x - suma - 1) / 2;\n        assert(dodaj >= 0);\n        poch[dl + 2] += net[dl][dwa];\n        poch[dl + 2 + dodaj + 1] -= net[dl][dwa];\n        stala[dl + 2 + dodaj + 1] -= (dodaj + 1) * net[dl][dwa] % mod;\n        // dbg(dl + 2, dodaj, net[dl][dwa]);\n      }\n      else\n      {\n        int dodaj = (x - suma - 1) / 2;\n        assert(dodaj >= 0);\n        // dbg(dl + 2, net[dl][dwa], dodaj);\n        poch[dl + 2] += net[dl][dwa];\n        poch[dl + 2 + dodaj + 1] -= 2 * net[dl][dwa];\n        poch[dl + 2 + 2 * dodaj + 1] += net[dl][dwa];\n        stala[dl + 2 + 2 * dodaj + 1] -= net[dl][dwa];\n      }\n    }\n  LL curpoch = 0;\n  LL cursuma = 0;\n  for(int i = 0;i <= n;i++)\n  {\n    curpoch += poch[i];\n    cursuma += stala[i] + curpoch;\n    curpoch %= mod;\n    cursuma %= mod;\n    // dbg(poch[i], stala[i], i, cursuma, curpoch);\n    dp[i] += cursuma;\n    dp[i] %= mod;\n  }\n  res = 0LL;\n  for(int i = 0;i <= n;i++)\n  {\n    res = (res + net[n][i] * dp[n - i]) % mod;\n  }\n  res %= mod;\n  res += mod;\n  res %= mod;\n  cout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#include <iostream>\n#include <bitset>\n#define PII pair <int, int>\n#define PPI pair <PII, int>\n#define x first\n#define y second\n#define P 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N, X;\n\nint F[2][6010][2][3], G[3010][6010], C[6010][6010];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\nint main() {\n    scanf(\"%d%d\", &N, &X);\n    G[0][0] = 1;\n    int ans = 0;\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < X; j++) {\n            add(G[i + 1][j], G[i][j]);\n            add(G[i + 1][j + 1], G[i][j]);\n            add(G[i + 1][j + 2], G[i][j]);\n        }\n    if(X % 2 == 1) {\n        for(int i = 0; i <= N; i++)\n            for(int j = 0; j <= i; j++)\n                C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n        for(int i = X; i <= N; i++)\n            add(ans, C[N][i]);\n    }\n    for(int i = 0; i < X; i++) add(ans, G[N][i]);\n    int a = 0, b = 1;\n    memset(F, 0, sizeof F);\n    F[a][0][0][1] = 1;\n    for(int i = 0; i < N - 1; i++, swap(a, b)) {\n        memset(F[b], 0, sizeof F[b]);\n        for(int o = 0; o < X; o++)\n            for(int s = 0; s < 2; s++)\n                for(int k = 1; k < 3; k++)\n                    for(int l = 0; l + k < 3; l++) {\n                        add(F[b][o + l][s][k + l], F[a][o][s][k]);\n                        if(l) add(F[b][o + l][!s][l], F[a][o][s][k]);\n                    }\n        for(int o = 1; o < X; o++)\n            for(int k = 1; k < 3; k++)\n                for(int l = 1; l + k < 3; l++)\n                    add(ans, 1LL * F[b][o][1][k] * G[N - i - 2][X - 1 - o - l] % P);\n    }\n    printf(\"%d\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N, X;\nll con[3010][3010];\nll mod = 998244353;\nll ans;\n\nint main()\n{\n    cin >> N >> X;\n\n    for(int i = 0; i <= N; i++)for(int j = 0; j <= N; j++)\n    {\n        if(i == j)con[i][j] = 1;\n        else if(j == 0)con[i][j] = 1;\n        else con[i][j] = (con[i - 1][j] + con[i - 1][j - 1]) % mod;\n    }\n\n    for(int i = 0; i <= N; i++)\n    {\n        ll tmp = 0;\n        for(int j = 0; j <= i; j++)\n        {\n            if(2 * j < X - 1)continue;\n            int t = (X - 1) - j;\n            if(j - t != 0 && t < i - j)continue;\n            tmp += con[max(0, j - (i - j))][max(0, t - (i - j))] * con[N][i];\n            tmp %= mod;\n        }\n        ans += tmp;\n        ans %= mod;\n    }\n\n    for(int i = 0; i <= N; i++)\n    {\n        ll tmp = 0;\n        for(int j = 0; j <= i; j++)\n        {\n            if(i - j + j * 2 < X - 1)\n            {\n                tmp += con[N][i] * con[i][j] % mod;\n                tmp %= mod;\n            }\n        }\n        ans += tmp;\n        ans %= mod;\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void update(int &x,ll y) {\n  x=(x+y)%MOD;\n}\n\nint C[6005][6005],f[2][2][6005][6005];\n\nvoid pre(int n) {\n  for(int i=0;i<=n;i++) C[i][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n  for(int t1=0;t1<2;t1++) {\n  \tf[t1][t1][0][0]=1;\n  \tfor(int i=0;i<n;i++)\n  \t  for(int j=0;j<=i;j++) {\n  \t  \t  update(f[t1][1][i+1][j+1],f[t1][0][i][j]);\n  \t  \t  update(f[t1][0][i+1][j],f[t1][1][i][j]);\n  \t  \t  update(f[t1][1][i+1][j+1],f[t1][1][i][j]);\n\t\t}\n  }\n}\n\nbool in[6005];\n\nint dp(int n,int m,int k) {\n  if (n<m) {\n  \tint ans=0;\n  \tfor(int j=0;j<n;j++) {\n  \t  update(ans,(ll)f[1][0][n-1][j]*C[k][j+1]);\n  \t  update(ans,(ll)f[1][1][n-1][j]*C[k][j+1]);\n    }\n    return ans;\n  }\n  memset(in,0,sizeof(in));\n  in[m-1]=1;\n  for(int j=m;j<=n;j++) {\n  \tin[j]=(in[j-1]^1);\n  \tin[j-m]=(in[j]^1);\n  }\n  if (!in[n]) return 0;\n  in[m-1]=0;\n  int s=0;\n  for(int i=1;i<=n;i++) s+=in[i];\n  int len=m-(n-m)-1,ans=0;\n  for(int j=0;j<=len;j++) {\n  \tif (in[m]) update(ans,(ll)f[in[n-m]][0][len][j]*C[k][j+s]);\n  \tupdate(ans,(ll)f[in[n-m]][1][len][j]*C[k][j+s]);\n  }\n  return ans;\n}\n\nint main() {\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  pre(n);\n  int ans=0;\n  for(int i=1;i<=2*m;i++)\n    update(ans,dp(i,m,n));\n  printf(\"%d\\n\",(ans+1)%MOD);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nconst int N = 6001;\nint d[N][N], bin[N][N];\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n, x;\n  cin >> n >> x;\n  for (int n = 0; n < N; ++n) {\n    bin[n][0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      bin[n][i] = (bin[n - 1][i] + bin[n - 1][i - 1]) % mod;\n    }\n  }\n  d[0][0] = d[1][0] = d[2][1] = 1;\n  for (int l = 3; l < N; ++l) {\n    for (int i = 1; i < l; ++i) {\n      d[l][i] = (d[l - 1][i - 1] + d[l - 2][i - 1]) % mod;\n    }\n  }\n  ll res = 0;\n  for (int S = 0; S <= 2 * n; ++S) {\n    vi bad(S + 1);\n    for (int i = x; i <= S; ++i) {\n      if (i % 2 == x % 2) {\n        bad[i] = 1;\n      } else {\n        bad[i - x] = 1;\n      }\n    }\n    if (bad.back()) continue;\n//    cerr << \"x: \" << x << \" S: \" << S << endl;\n//    for (int i = 0; i <= S; ++i) cerr << bad[i]; cerr << endl;\n    bool fail = 0;\n    int steps = n;\n    for (int i = 0; i + 1 <= S; ++i) {\n      if (bad[i] && bad[i + 1]) {\n        fail = 1;\n      }\n      if (bad[i] && i > 0 && !bad[i-1] && i + 1 <= S && !bad[i+1]) --steps;\n    }\n    if (fail) break;\n    int L = 0;\n    for (int i = 0; i <= S; ++i) if (!bad[i]) {\n      int l = 1;\n      for (int j = i + 1; j <= S; ++j) {\n        if (bad[j]) break;\n        ++l;\n      }\n      if (l != 1) {\n        assert(L == 0);\n        L = l;\n        i += l - 1;\n      }\n    }\n    for (int i = 0; i <= steps; ++i) {\n      res = (res + d[L][i] * (ll)bin[n][steps - i]) % mod;\n    }\n//    cerr << n << ' ' << steps << ' ' << res << endl;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 998244353LL\n#define maxn 100005\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 1000000000\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii;\n\n\nclass numberTheory{\n\npublic:\n    numberTheory(){}\n\n    pii extendedEuclid(i64 a, i64 b) { // returns x, y | ax + by = gcd(a,b)\n\n        if(b == 0) return pii( a >= 0 ? 1 : -1 , 0LL);\n        else {\n            pii d = extendedEuclid(b, a % b);\n            return pii(d.yy, d.xx - d.yy * (a / b));\n        }\n\n    }\n\n    i64 modularInverse(i64 a, i64 n) {\n        pair<i64,i64> ret = extendedEuclid(a, n);\n        return ((ret.xx % n) + n) % n;\n    }\n\n\n    i64 bigMod(i64 a, i64 n , i64 m)\n    {\n        if(n==0) return 1 ;\n        i64 ret = bigMod(a,n/2,m) ;\n        ret = (ret*ret)%m ;\n        if(n%2) ret = (ret*a)%m ;\n        return ret ;\n    }\n};\n\nconst i64 N = 100000 ;\n\ni64 fact[N+5] , invFact[N+5] ;\n\ni64 C(i64 n, i64 r)\n{\n    if( n<0 || r<0 || r>n ) return 0 ;\n    i64 ret = (fact[n]*invFact[r])%mod ;\n    return (ret*invFact[n-r])%mod ;\n}\n\nvoid preprocess()\n{\n    numberTheory nt ;\n\n    fact[0] = 1 ;\n    for(i64 x=1 ; x<=N ; x++) fact[x] = (fact[x-1]*x)%mod ;\n\n    invFact[N] = nt.modularInverse(fact[N],mod) ;\n\n    for(i64 x=N-1 ; x>=0 ; x--) invFact[x] = (invFact[x+1]*(x+1) )%mod ;\n}\n\ni64 used[3005] ;\ni64 dp[3005][3005] ;\n\nint main()\n{\n    preprocess() ;\n\n    int n , x ;\n    scanf(\"%d %d\",&n,&x) ;\n\n    for(int i=0 ; i<=n ; i++)\n    {\n        used[i] = C(n,i) ;\n    }\n\n    i64 ans = 1 ; //all zeroes\n\n    for(int var=1 ; var<=n ; var++)\n    {\n        for(int sum=var ; sum<x ; sum++)\n        {\n            ans += (C(var , sum-var )*used[var]) ;\n            ans%= mod ;\n        }\n    }\n\n    if( x%2==1 )\n    {\n        for(int i=x+1 ; i<=2*n ; i+=2) ans = ( ans + used[i/2] )%mod ;\n    }\n\n    for(int i=1 ; i<=n ; i++) used[i] = ( used[i] + used[i-1] )%mod ;\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        int sum = ( (x-1) - ( 2*(i-1) + 1 ) ) ;\n\n        if( sum < 0  ) continue ;\n\n        for(int j=0 ; j<=sum ; j++ )\n        {\n            dp[i][j+i] = ( dp[i][j+i] + C( j , sum-j ) )%mod ;\n        }\n    }\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        for(int j=1 ; j<=n ; j++)\n        {\n            if( dp[i][j]==0 ) continue ;\n            int lim = min( i-1 , n-j ) ;\n            ans = ( ans + dp[i][j]*( used[j+lim] - used[j] ) )%mod ;\n        }\n    }\n\n    ans = ( ans%mod + mod )%mod ;\n\n    printf(\"%lld\\n\",ans) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n\nusing namespace std;\n\nlong long MOD = 998244353;\n\nvector<long long> fact(3001,0);\nvector<long long> inv_fact(3001,0);\n\nvoid factorial(int a){\n    fact[0]=1;\n    for(int i=1; i<a; i++){\n        fact[i]=i*fact[i-1];\n        fact[i]%=MOD;\n    }\n}\n\nvoid inv_factorial(int a){\n    inv_fact[0]=1;\n    inv_fact[1]=1;\n    for(int i=2; i<a; i++){\n        inv_fact[i]=(MOD*MOD-((MOD/i)%MOD)*(inv_fact[MOD%i]%MOD))%MOD;\n    }\n}\n\nlong long comb(int a, int b){\n    long long ret=fact[a]*inv_fact[fact[b]]%MOD;\n    ret=ret*inv_fact[fact[a-b]]%MOD;\n    //cout << ret << endl;\n    return ret;\n}\n\nvoid cout_vec(vector<long long> &vec){\n    for(int i=0; i<vec.size(); i++){\n        if (i!=0){\n            cout << ' ';\n        }\n        cout << vec[i];\n    }\n    cout << endl;\n}\n\nvoid cout_mat(vector<vector<long long>> &mat){\n    for(int i=0; i<mat.size(); i++){\n        vector<long long> vec = mat[i];\n        cout_vec(mat[i]);\n    }\n}\n\nint main(){\n    int N,X;\n    cin >> N >> X;\n    vector<vector<long long> > dp(N+1, vector<long long>(X,0));\n    dp[0][0]=1;\n    for(int i=0; i<N; i++){\n        for(int j=0; j<X; j++){\n            for(int k=0; k<=2; k++){\n                if(j+k>=X)continue;\n                dp[i+1][j+k]+=(long long) dp[i][j];\n                dp[i+1][j+k]%=MOD;\n            }\n        }\n    }\n    factorial(3001);\n    inv_factorial(3001);\n    //cout_vec(inv_fact);\n    long long ans=0;\n    int h=0;\n    for(int i=0; i<=N; i++){\n        if(h<X){\n            h+=2;\n            continue;\n        }\n        ans+=comb(N,i);\n        ans%=MOD;\n        //cout << ans << endl;\n    }\n\n    int k=2;\n    for(int i=0; i<X; i++){\n        ans+=dp[N][i];\n        ans%=MOD;\n    }\n\n    //cout_mat(dp);\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <float.h>\n#include <random>\n\n#define repeat(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge] << '\\n'\n#define debugArrayP(x,n) for(long long hoge = 0; (hoge) < (n); ++ (hoge)) cerr << #x << \"[\" << hoge << \"]: \" << x[hoge].first<< \" \" << x[hoge].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst int INF = INT_MAX;\nconst ll MOD = 998244353;\n\ntemplate <ll mod>\nstruct ModCombination{\n    ll N;\n    vector<ll> fact,inv,finv;\n\n    ModCombination(ll n):N(n){\n        fact.assign(n+1, 1);\n        inv.assign(n+1, 1);\n        finv.assign(n+1,1);\n        for(int i=1;i<n;i++){\n            fact[i+1] = fact[i]*(i+1)%mod;\n            inv[i+1] = inv[mod%(i+1)]*(mod-mod/(i+1))%mod;\n            finv[i+1] = finv[i]*inv[i+1]%mod;\n        }\n    }\n\n    ll Comb(ll n,ll k){\n        if(k<0||n<k)return 0;\n        return (fact[n]*finv[k]%mod)*finv[n-k]%mod;\n    }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N,X;cin>>N>>X;\n  ModCombination<MOD> C(2*N);\n  ll ans=0;\n  repeat(K,N+1){\n    //debug(K);\n    ll tmp=0;\n    for(int S=K;S<min(X,2*K+1);S++){\n      tmp = (tmp+C.Comb(K,S-K))%MOD;\n    }\n    //debug(tmp);\n    for(int S=X+1;S<=2*K;S+=2){\n      if(S<2*(X-1)&&K+X-1-S>0&&K+X-1-S!=X-1-K)tmp = (tmp+C.Comb(K+X-1-S,X-1-K))%MOD;\n    }\n    if(2*K>=X)tmp = (tmp+(X&1))%MOD;\n    //debug(tmp);\n    //cerr<<C.Comb(N,K)<<endl;\n    ans = (ans+tmp*C.Comb(N,K)%MOD)%MOD;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <vector>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\ntemplate <class T>\nstruct Combination {\n    int max_n;\n    std::vector<T> f, invf;\n\n    explicit Combination(int n)\n        : max_n(n), f(n + 1), invf(n + 1) {\n        f[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            f[i] = f[i - 1] * i;\n        }\n\n        invf[max_n] = f[max_n].inv();\n        for (int i = max_n - 1; i >= 0; --i) {\n            invf[i] = invf[i + 1] * (i + 1);\n        }\n    }\n\n    T fact(int n) const { return f[n]; }\n    T invfact(int n) const { return invf[n]; }\n    T perm(int a, int b) const {\n        return a < b || b < 0 ? T(0) : f[a] * invf[a - b];\n    }\n    T comb(int a, int b) const {\n        return a < b || b < 0 ? T(0) : f[a] * invf[a - b] * invf[b];\n    }\n};\n\nconstexpr int MOD = 998244353;\nusing mint = ModInt<MOD>;\n\nCombination<mint> C(10000);\n\nvoid solve() {\n    int n, x;\n    std::cin >> n >> x;\n\n    auto dp = vec(n + 1, vec(n * 2 + 1, mint(0)));\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n * 2; ++j) {\n            dp[i + 1][j + 1] += dp[i][j];\n            if (j + 2 <= n * 2) {\n                dp[i + 1][j + 2] += dp[i][j];\n            }\n        }\n    }\n\n    mint ans = 0;\n    for (int m = 0; m <= n; ++m) {\n        mint pat = std::accumulate(dp[m].begin(), dp[m].begin() + x, mint(0));\n        for (int l = m - 2; l >= 0; l -= 2) {\n            if (x - 1 - (m - l) < 0) continue;\n            pat += dp[l][x - 1 - (m - l)];\n        }\n\n        // all 2\n        if (x % 2 != 0 && m >= x) pat += 1;\n\n        ans += pat * C.comb(n, m);\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353, N = 3030;\n\nint dp[N][N + N], C[N][N];\n\nvoid add(int & var, int val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nint main() {\n  for (int i = 0; i < N; ++i) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = 1; j < i; ++j)\n      C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;\n  }\n  int n, x;\n  scanf(\"%d %d\", &n, &x);\n  if (x == 1) {\n    int ans = 1;\n    for (int i = 0; i < n; ++i)\n      ans = (ans * 2) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n  }\n  if (x == 2) {\n    printf(\"%d\\n\", n + 1);\n    return 0;\n  }\n  dp[0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < x; ++j) {\n      for (int k = 0; k <= 2; ++k) {\n        if (j + k >= x) continue;\n        add(dp[i+1][j+k], dp[i][j]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < x; ++i)\n    add(ans, dp[n][i]);\n  for (int len = 3; len <= n; ++len) {\n    for (int i = 1; i * 2 < len; ++i) {\n      int tengah = len - 2 * i;\n      int sisa = x-1 - 2 * i;\n      if (sisa < tengah || sisa > 2 * tengah) continue;\n      ans = (ans + 1LL * C[tengah][sisa-tengah] * C[n][len]) % mod;\n    }\n  }\n  if (x & 1) {\n    for (int len = (x - 1); len <= n; ++len) {\n      ans = (ans + C[n][len]) % mod;\n    }\n  }\n  ans %= mod;\n  if (ans < 0) ans += mod;\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 10200;\nint n,a[N],b[N];set<int>Set;\nint gcd(int a, int b){return !b?a:gcd(b,a%b);}\nbool isprime(int x){\n\tfor(int i=2;i*i<=x;i++)if(x%i==0)return 0;\n\treturn 1;\n}\ninline bool ck(int p){\n\trep(i,0,n)b[i]=a[i]%p;\n\tper(i,n,p)if(b[i]){\n\t\tb[i-p+1]=(b[i-p+1]+b[i])%p;b[i]=0;\n\t}\n\trep(i,0,p-1)if(b[i])return 0;\n\treturn 1;\n}\nint main() {\n\tread(n);per(i,n,0)read(a[i]);\n\tint g=0;rep(i,0,n)g=gcd(g,a[i]);g=g>0?g:-g;\n\tfor(int i=2;i*i<=g;i++)if(g%i==0){\n\t\tSet.insert(i);while(g%i==0)g/=i;\n\t}\n\tif(g>1)Set.insert(g);\n\trep(i,2,n)if(isprime(i)&&ck(i))Set.insert(i);\n\twhile(!Set.empty())\n\t\tprintf(\"%d\\n\",*Set.begin()),Set.erase(Set.begin());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 6006\ntypedef long long ll;\nconst int mod=998244353;\ninline ll read(){\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,x,ans,fac[N],ifac[N];\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t}\n\tifac[n]=qpow(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i){\n\t\tifac[i]=1LL*ifac[i+1]*(i+1)%mod;\n\t}\n}\ninline int C(int n,int m){\n\tif(n<0||m<0||n-m<0)return 0;\n\treturn 1LL*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint main(){\n\tn=read(),x=read();\n\tif(x==1){\n\t\treturn !printf(\"%d\\n\",qpow(2,n));\n\t}\n\tinit(max(n,x));\n\tfor(int k=1;k<=n;++k){\n\t\tint tmp=0;\n\t\tfor(int i=k;i<x;++i){\n\t\t\ttmp=(tmp+C(k,i-k))%mod;\n\t\t}\n\t\tfor(int i=1;i<=k-1;++i){\n\t\t\tif(i<=k-i){\n\t\t\t\ttmp+=(x-1==2*i);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint p=x-1-2*(k-i);\n\t\t\t\ttmp=(tmp+C(2*i-k,p-(2*i-k)))%mod;\n\t\t\t}\n\t\t}\n\t\tans=(ans+1LL*C(n,k)*tmp)%mod;\n\t}\n\tprintf(\"%d\\n\",(ans+1)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 3010\n#define P 998244353\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,m,C[N][N],ans;\nvoid inc(int &x,int y){x+=y;if (x>=P) x-=P;}\nsigned main()\n{\n\tC[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++)\n\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%P;\n\t}\n\tfor (int i=0;i<=n;i++)\n\t{\n\t\tint s=0;\n\t\tfor (int j=0;j<=m-1-i;j++) inc(s,C[i][j]);\n\t\tfor (int j=1;j<=i;j++) //j是第一个前缀和>m的位置 j~i均为2 1~i-j+1均为2 \n\t\tif (j*2>m&&(i-j+1<j?(i-j+1)*2+(j-(i-j+1)+1):j*2)<=m+1)\n\t\t\tif (i-j+1<j) inc(s,C[j-(i-j+1)-1][m+1-((i-j+1)*2+(j-(i-j+1)+1))]);\n\t\t\telse if (j*2==m+1) inc(s,1);\n\t\tinc(ans,1ll*s*C[n][n-i]%P);\n\t}\n\tcout<<ans;\n\treturn 0;\n\t//NOTICE LONG LONG!!!!!\n}\n//先把0去掉 则要考虑求长度为0~n的满足条件的序列数量\n//找到第一个前缀和>x的位置 然后若当前不是后缀 下一位必须是2 首位也必须是2 \n//即第一个前缀和>x的位置及之后全都是2 "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, ll> P;\ntypedef complex<double> com;\nconst int mod = 998244353; //1e9 + 7\nconst int inf = 2e9;\nll mpow(ll a, ll b){ll r=1;a%=mod;while(b){r=r*((b%2)?a:1)%mod,a=a*a%mod,b>>=1;}return r;}\n\n//template\n\nclass UnionFind {\npublic:\n    vector<int> par;\n    UnionFind(int n) {\n        par = vector<int>(n, -1);\n    }\n    int root(int a) {\n        if (par[a] < 0) {\n            return a;\n        }\n        else {\n            return par[a] = root(par[a]);\n        }\n    }\n    int size(int a) {\n        return -par[root(a)];\n    }\n    bool connect(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if (a == b) {\n            return false;\n        }\n        if (size(a) < size(b)) {\n            swap(a, b);\n        }\n        par[a] += par[b];\n        par[b] = a;\n        return true;\n    }\n};\nstruct edge { int cost, u, v; };\nbool comp(edge& e1, edge& e2) {\n    return e1.cost < e2.cost;\n}\n#define MAX_E 200010\nedge es[MAX_E]; int V,E;\nint kruskal(){\n    sort(es, es + MAX_E, comp);\n    UnionFind uni(V);\n    int res = 0;\n    rep(i, 0, E) {\n        edge e = es[i];\n        if (uni.root(e.u) != uni.root(e.v)) {\n            uni.connect(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\nvector<int> fac, finv;\nvoid factor(int N){\n    fac.resize(N); finv.resize(N);\n    fac[0] = finv[0] = 1;\n    rep(i, 1, N)fac[i] = 1LL * fac[i - 1] * i % mod;\n    finv[N - 1] = mpow(fac[N - 1], mod - 2);\n    for (int i = N - 2; i; --i) finv[i] = 1LL * finv[i + 1] * (i + 1) % mod;\n}\nint nCr(int n, int m){\n    if (m < 0 || n < m) return 0;\n    return 1LL * (1LL * fac[n] * finv[m] % mod) * finv[n - m] % mod;\n}\nll merge_cnt(vector<int>& a){\n    int n = a.size();\n    if (n <= 1) return 0;\n    ll cnt = 0;\n    vector<int> b(a.begin(), a.begin() + n / 2);\n    vector<int> c(a.begin() + n / 2, a.end());\n    cnt += merge_cnt(b);\n    cnt += merge_cnt(c);\n    int ai = 0, bi = 0, ci = 0;\n    while (ai < n) {\n        if (bi < b.size() && (ci == c.size() || b[bi] <= c[ci])) {\n            a[ai++] = b[bi++];\n        }\n        else {\n            cnt += n / 2 - bi;\n            a[ai++] = c[ci++];\n        }\n    }\n    return cnt;\n}\nvoid fft(vector<com>& x, bool inv){\n    int s = x.size();\n    if (s == 1) return;\n    else {\n        vector<com> even(s / 2), odd(s / 2);\n        rep(i, 0, s / 2) {\n            even[i] = x[i * 2];\n            odd[i] = x[i * 2 + 1];\n        }\n        fft(even, inv);\n        fft(odd, inv);\n        com w = 1, w_0 = polar(1.0, (inv ? -1 : 1) * 2LL * M_PI / s);\n        int t = s / 2 - 1;\n        rep(i, 0, s) {\n            x[i] = even[i & t] + w * odd[i & t];\n            w *= w_0;\n        }\n    }\n}\n#define MAX_V 100010\nvector<edge> G[MAX_V]; ll d[MAX_V];\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(d, d + MAX_V, 1LL*inf*inf);\n    d[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if (d[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); ++i) {\n            edge e = G[v][i];\n            if (d[e.v] > d[v] + e.cost) {\n                d[e.v] = d[v] + e.cost;\n                que.push(P(d[e.v], e.v));\n            }\n        }\n    }\n}\nbool cross(ll ax, ll ay, ll bx, ll by, ll cx, ll cy, ll dx, ll dy){\n    ll ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n    ll tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n    ll tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n    ll td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n    return tc * td <= 0LL && ta * tb <= 0LL;\n}\nvector<edge> graph[MAX_V];\nP DFS(int prev, int v){\n    P r(0, v);\n    rep(i, 0, graph[v].size()){\n        edge e = graph[v][i];\n        if (e.v == prev) continue;\n        P tmp = DFS(v, e.v);\n        tmp.first += e.cost;\n        if (r.first < tmp.first) r = tmp;\n    }\n    return r;\n}\nint diameter(){\n    P r = DFS(-1, 0);\n    P t = DFS(-1, r.second);\n    return t.first;\n}\nint bipartite(const vector<vector<int>>& g){\n    int n = g.size();\n    vector<int> color(n, -1);\n    int white_cnt = 0;\n    function<bool(int, int, int)> dfs = [&](int u, int prev, int c) {\n        color[u] = c;\n        if (c == 1) white_cnt++;\n        for (auto v : g[u]) if (v != prev) {\n            if (color[v] == -1) {\n                if (!dfs(v, u, 1 - c)) return false;\n            }\n            else if (color[v] != 1 - c) {\n                return false;\n            }\n        }\n        return true;\n    };\n    if (!dfs(0, -1, 0)) return -1;\n    return white_cnt;\n}\n\n//template end\n\n\n\nint main() {\n\tint n,x; cin>>n>>x;\n\tfactor(400010);\n\tll ans=0;\n\trep(i,0,n+1)rep(j,0,n+1-i){\n\t\tif(i+2*j>=x) break;\n\t\tans=(ans+(1LL*nCr(n,i)*nCr(n-i,j))%mod)%mod;\n\t}\n\tif(x%2){\n\t\trep(i,0,n+1) if(2*i>x) ans=(ans+nCr(n,i))%mod;\n\t}\n\trep(i,1,n+1){\n\t\tif(2*i>=x) break;\n\t\tint l=x-1-2*i;\n\t\trep(j,1,l+1){\n\t\t\tif((l-j)%2) continue;\n\t\t\tint r=(l-j)/2;\n\t\t\tif(j+r+2*i>n) continue;\n\t\t\tans=(ans+(1LL*nCr(j+r,r)*nCr(n,j+r+2*i))%mod)%mod;\n \t\t}\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <random>\n#include <stack>\n#include <set>\n#include <unordered_set>\n\n#define bug(x) cout<<\"zdongdebug: \"<<x<<endl;\n#define bug2(x, y) cout<<\"zdongdebug: \"<<x<<\" \"<<y<<endl;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3005;\nconst int mod = 998244353;\nll c[maxn][maxn];\nll f[maxn][maxn];\nvoid pd(ll&ret,ll val){\n  ret+=val;\n  ret%=mod;\n}\nvoid init() {\n  f[0][0] = 1;\n  for (int i = 0; i < maxn; i++)c[i][0] = c[i][i] = 1;\n  for (int i = 1; i < maxn; i++)\n    for (int j = 1; j < i; j++) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1])%mod;\n    }\n}\n\nint n,m;\nint sq[maxn];\nint ans;\nvoid dfs(int pos) {\n  if(pos == n) {\n    for(int i=0;i<n;i++){\n      int sum = 0;\n      for(int j=i;j<n;j++){\n        sum+=sq[j];\n        if(sum==m)return;\n      }\n    }\n    ans++;\n    if(ans>mod)ans-=mod;\n    return;\n  }\n  for(int i=0;i<3;i++){\n    sq[pos]=i;\n    dfs(pos+1);\n  }\n}\n\nint main() {\n#ifdef suiyuan2009\n  freopen(\"/Users/suiyuan2009/CLionProjects/icpc/input.txt\", \"r\", stdin);\n#endif\n  init();\n  cin>>n>>m;\n // dfs(0);\n // bug(ans)\n  for(int i=1;i<=n;i++) {\n    for (int j = 1; j < m; j++) {\n      if (2 * i < j)break;\n      f[i][j] = c[i][2 * i - j];\n    }\n    if((m&1)&&2*i>m)f[i][2*i]=1;\n    for (int j = 1; j + j <i&&(j+j<m-1);j++) {\n      if(m-1+2*j!=2*i)\n      pd(f[i][m-1+2*j],f[i-j-j][m-1-2*j]);\n    }\n  }\n  //bug(f[1][2])\n  ll ret = 1;\n  for(int i=1;i<=n;i++){\n    ll sum = 0;\n    for(int j=1;j<=i+i;j++)pd(sum, f[i][j]);\n    pd(ret, sum*c[n][i]%mod);\n  }\n  cout<<ret%mod<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nconst int MAXN = 6010;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  ll ret = fact[n];\n  ret = (ret*rfact[r]) % M;\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\n\n\nint main() {\n  int n, x;\n  cin >> n >> x;\n  set_fact(max(x, 2*n) + 5);\n  \n  vl ans(n + 1);\n  for (int k = 0; k <= n; k++) {\n    for (int i = 0; i <= min(x - 1 - k, k); i++) {\n      (ans[k] += nCr(k, i)) %= MOD;\n    }\n  }\n\n\n  // 長さi, 合計j, 全部2以外\n  vll dp(n + 1, vl(2*n + 1));\n  dp[0][0] = 1;\n  rep (i, n) {\n    rep (j, 2*n + 1) {\n      for (int k = 1; k <= 2; k++) {\n        if (j + k <= 2*n) {\n          (dp[i + 1][j + k] += dp[i][j]) %= MOD;\n        }\n      }\n    }\n  }\n  rep (i, n + 1) {\n    dp[i][2*i]--;\n  }\n\n  for (int s = x + 1; s < 2*x; s++) {\n    if ((s - x + 1) % 2 == 1) continue;\n    int num_i = (s - x + 1) / 2;\n    int len = 2*num_i, sum = 2*2*num_i;\n    for (int k = 0; k <= n; k++) {\n      if (k < len || s < sum) continue;\n      (ans[k] += dp[k - len][s - sum]) %= MOD;\n    }\n  }\n\n  if (x % 2 == 1) {\n    for (int s = x + 1; s <= 2 * n; s += 2) {\n      (ans[s / 2] += 1) %= MOD;\n    }\n  }\n  \n  ll res = 0;\n  rep (i, n + 1) {\n    int nn = i + 1, rr = n - i;\n    ans[i] *= nCr(nn + rr - 1, rr);\n    ans[i] %= MOD;\n    (res += ans[i]) %= MOD;\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint mod_inv( long n, long mod )\n{\n    long b = mod, u = 1, v = 0;\n\n    while ( b > 0 )\n    {\n        long t = n / b;\n\n        n -= t * b, u -= t * v;\n\n        swap( n, b ), swap( u, v );\n    }\n\n    return ( u + mod ) % mod;\n}\n\nint ceil( int a, int b )\n{\n    if ( ( a / b ) * b == a ) return a / b;\n    return a / b + 1;\n}\n\n#define MAX_K 3000\n#define MOD 998244353\n\nlong __fact[MAX_K + 1];\nlong __inv[MAX_K + 1];\n\nvoid init_comb()\n{\n    __fact[0] = __inv[0] = 1;\n    for ( int n = 0; n <= MAX_K; n++ )\n    {\n        __fact[n + 1] = ( ( n + 1 ) * __fact[n] ) % MOD;\n        __inv[n + 1] = mod_inv( ( n + 1 ) * __fact[n], MOD );\n    }\n    return;\n}\n\nint comb( int n, int r )\n{\n    long res = __fact[n];\n    res = ( res * __inv[n - r] ) % MOD;\n    res = ( res * __inv[r] ) % MOD;\n    return res;\n}\n\nint banned_x( int N, int X )\n{\n    long res = 1;\n\n    /* S は数列の和 */\n    for ( int S = 1; S <= 2 * N; S++ )\n    {\n        if ( S < X )\n        {\n            /**\n             * 1, 2 を合計で k 個利用するとする。1 を p 個、2 を q 個とすると\n             * p+q=K; p+2q=S;\n             * より\n             * p=2K-S; q=S-K\n             * となる。このとき、0, 1, 2 の並べ方は\n             * comb(N,p) * comb(N-p,q)\n             * である。また、\n             * 0<=p; 0<=q\n             * より\n             * S/2<=k<=S\n             * が成り立つ。\n             */\n            for ( int k = ceil( S, 2 ); k <= min( S, N ); k++ )\n            {\n                int p = 2 * k - S, q = S - k;\n                res += 1L * comb( N, p ) * comb( N - p, q );\n                res %= MOD;\n            }\n        }\n        else if ( S == X )\n        {\n            continue;\n        }\n        else if ( ( S - X ) & 1 )\n        {\n            /* 2 を置かなければいけない場所 */\n            int only2 = ( S - ( X - 1 ) ) / 2;\n\n            /* 1 が含まれる場合 */\n            if ( 2 * only2 < X - 1 )\n            {\n                /* SS は 1/2 どちらを置いてもいい区間 */\n                int SS = X - 1 - 2 * only2;\n\n                int start = ceil( SS, 2 );\n                int end = min( N - 2 * only2, SS );\n\n                /**\n                 * k,p,q の意味は S < X の時と同じ。\n                 * 全体的に 2 のために確保されている 2*only2\n                 * の領域があることに注意する。\n                 */\n                for ( int k = start; k <= end; k++ )\n                {\n                    int p = 2 * k - SS, q = SS - k;\n                    res += 1L * comb( N, k + 2 * only2 ) * comb( k, p );\n                    res %= MOD;\n                }\n            }\n            /* 1 が含まれない場合 */\n            else if ( X & 1 )\n            {\n                res += comb( N, ceil( S, 2 ) );\n                res %= MOD;\n            }\n        }\n    }\n\n    return res;\n}\n\nint main( int argc, char **argv )\n{\n    int N, X;\n    cin >> N >> X;\n\n    init_comb();\n\n    cout << banned_x( N, X ) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n\tModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\tbool operator<(const ModInt &x)const{return a<x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{return facts[n]*finvs[k]*finvs[n-k];}\n\tinline Mint perm(int n,int k)const{return facts[n]*finvs[n-k];} \n};\nModIntTable<mint,18>mtable;\nint N,X;\n\nmint res[3333];\n\nmint dp[2][6666];\n\nmint num[3333][3333];\nvoid calc(){\n\tdp[0][0]=1;\n\n\tres[0]=1;\n\tif(X&1){\n\t\tfor(int i=1;i<=N;i++)res[i]+=1;\n\t}\n\telse{\n\t\tnum[1][(X-1)/2]+=1;\n\t}\n\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=0;j<X;j++){\n\t\t\tif((X-j)%2==0&&j){\n\t\t\t\tres[i]+=dp[i&1][j];\n\t\t\t}\n\t\t\tint sum=2+j;\n\t\t\tif(sum>=X)continue;\n\t\t\tif(i+2>N)continue;\n\t\t\tif((X-sum)&1){\n\t\t\t\tint lim=(X-sum)/2;\n\t\t\t\tnum[i+2][lim]+=dp[i&1][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int j=0;j<X;j++){\n\t\t\tfor(int k=1;k<=2;k++)if(j+k<X)dp[(i+1)&1][j+k]+=dp[i&1][j];\n\t\t\tdp[i&1][j]=0;\n\t\t}\n\t}\n\n\n\tfor(int j=N;j>0;j--){\n\t\tfor(int i=0;i<=N;i++)num[i+2][j-1]+=num[i][j];\n\t}\n\t\n\n\n\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=0;j<=N;j++)res[i]-=num[i][j];\n\t}\n\tfor(int j=N;j>=0;j--){\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tres[i]+=num[i][j]*2;\n\t\t\tif(j)num[i+1][j-1]+=num[i][j];\n\t\t}\n\t}\n}\n\nsigned main(){\n\tcin>>N>>X;\n\n\tcalc();\n\tmint ans;\n\n\tfor(int i=0;i<=N;i++){\n\t\tans+=mtable.binom(N,i)*res[i];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each1(i,a) for(auto&& i:a)\n#define each2(x,y,a) for(auto&& [x,y]:a)\n#define each3(x,y,z,a) for(auto&& [x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define Msum(...) accumulate(all(__VA_ARGS__),0_M)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T> a){ Uniq(a); unordered_map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T> a){ Uniq(a); map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const complex<T>& a){ if(a.real() >= 0) print('+'); print(a.real()); if(a.imag() >= 0) print('+'); print(a.imag()); print('i'); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\nconstexpr uint mod = MODD;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint() noexcept {}\n    constexpr Modint(const Modint &x) noexcept : num(x.num){}\n    inline constexpr operator ll() const noexcept { return num; }\n    inline constexpr Modint& operator+=(Modint x) noexcept { num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++() noexcept { if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator-() const noexcept { return Modint(0) -= *this; }\n    inline constexpr Modint operator-(Modint x) const noexcept { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x) noexcept { if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--() noexcept { if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x) noexcept { num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x) noexcept { return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x) noexcept {\n        using U = typename conditional<sizeof(T) >= 4, T, int>::type;\n        U y = x; y %= U(mod); if(y < 0) y += mod; num = uint(y);\n    }\n    template<class T> inline constexpr Modint operator+(T x) const noexcept { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x) noexcept { return operator+=(Modint(x)); }\n    template<class T> inline constexpr Modint operator-(T x) const noexcept { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x) noexcept { return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator*(T x) const noexcept { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x) noexcept { return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/(T x) const noexcept { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x) noexcept { return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    static inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x){ ll a; in(a); x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){\n    if(r < 0 || n < r) return 0;\n    if(n >> 24){ Modint ans = 1; for(ll i = 0; i < r; i++) ans *= n--; return ans; }\n    reserve(n + 1); return fac[n] * inv[n - r];\n}\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nsigned main(){\n    LL(n,x);\n    vv(Modint,dp,x,x*2-1);\n    dp[0][0]=1;\n    rep(x-1)rep(j,i+1){\n        dp[i+1][i+j+1]+=dp[i][i+j];\n        dp[i+1][i+j+2]+=dp[i][i+j];\n    }\n    rep(x-1)rep(j,i/2+1)dp[x-1-j][x*2-2-i]=dp[i-j][i];\n    rep(j,x,x*2-1,2)rep(x)dp[i][j]=0;\n    Modint ans=0;\n    rep(i,x&&i<=n)ans+=Msum(dp[i])*Mcomb(i+1,n-i);\n    if(x&1)rep(i,x,n+1)ans+=Mcomb(i+1,n-i);\n    out(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, X, f[N][N << 1], fac[N << 1], inv[N << 1];\n\ninline int C(int x, int y) {\n    return x < y ? 0 : 1LL * fac[x] * inv[y] % Mod * inv[x - y] % Mod;\n}\n\nint main() {\n    cin >> n >> X;\n\n    inv[0] = inv[1] = fac[0] = fac[1] = 1;\n    for (int i = 2; i <= n; ++i)\n        fac[i] = 1LL * fac[i - 1] * i % Mod,\n        inv[i] = 1LL * inv[Mod % i] * (Mod - Mod / i) % Mod;\n\n    for (int i = 1; i <= n; ++i)\n        inv[i] = 1LL * inv[i - 1] * inv[i] % Mod;\n\n    f[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < 6000; ++j)\n            (f[i + 1][j + 1] += f[i][j]) %= Mod,\n            (f[i + 1][j + 2] += f[i][j]) %= Mod;\n\n    long long ans = 1;\n    for (int i = 1; i <= n; ++i) {\n        long long tmp = 0;\n        for (int j = 0; j < X; ++j)\n            (tmp += f[i][j]) %= Mod;\n        for (int j = X + 1; j <= 2 * i; j += 2) {\n            if (j < i) continue;\n            int p = i - (j - X + 1), q = X - 1 - (j - X + 1);\n            if (j < 2 * X && p >= 0 && q >= 0) (tmp += f[p][q]) %= Mod;\n        }\n        if (i >= X && (X & 1))\n            ++tmp;\n        (ans += 1LL * tmp * C(n, i) % Mod) %= Mod;\n    }\n    cout << ans % Mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e3+5,mo=998244353;\nint n,x,f[N][N*2],C[N][N],i,j,ans=1;\ninline void add(int&x,const int&y){x+=y;x>=mo?x-=mo:0;}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&x);\n\tfor(i=**C=1;i<=n;++i)for(j=*C[i]=1;j<=n;++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\tfor(i=0,f[0][0]=1;i<n;++i)for(j=0;j<=i*2;++j)add(f[i+1][j+2],f[i][j]),add(f[i+1][j+1],f[i][j]);\n\tfor(i=1;i<=n;++i){\n\t\tint s=0;\n\t\tfor(j=0;j<x;++j)add(s,f[i][j]);\n\t\t\tfor(j=x+1;j<=i*2;j+=2)if(j>=i){\n\t\t\t\tint p=i-(j-x+1),q=x-1-(j-x+1);\n\t\t\t\tif(j>=x*2){if(j==i*2)add(s,x&1);}\n\t\t\t\t\telse if(p>=0 && q>=0)add(s,f[p][q]);\n\t\t\t}\n\t\tans=(ans+1ll*C[n][i]*s)%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\n//const long long int MOD=1000000007;\nconst long long int MOD=998244353;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main(){\n\t\n\tcin>>N>>M;\n\tvector<vector<long long int>>dp(N+1,vector<long long int>(2*N+1));\n\tdp[0][0]=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i;j<=i*2;j++){\n\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\tdp[i+1][j+1]%=MOD;\n\t\t\tdp[i+1][j+2]+=dp[i][j];\n\t\t\tdp[i+1][j+2]%=MOD;\n\t\t}\n\t}\n\tvector<long long int>num(N+1);\n\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tnum[i]+=dp[i][j];\n\t\t\tnum[i]%=MOD;\n\t\t}\n\t}\n\tif(M&1){\n\t\tfor(int i=M+1;i<=2*N;i+=2){\n\t\t\tnum[i/2]++;\n\t\t}\n\t}\n\t//cout<<\"hoge\"<<endl;\n\tvector<long long int>by(N+1,1);\n\tvector<long long int>rev(N+1,1);\n\tfor(int i=2;i<=N;i++){\n\t\tby[i]=by[i-1]*i;\n\t\tby[i]%=MOD;\n\t\trev[i]=power(by[i],MOD-2,MOD);\n\t}\n\tfor(int i=0;i<=N;i++){\n\t//\tcout<<i<<\" \"<<num[i]<<endl;\n\t}\n\tfor(int i=2;i<M-1;i+=2){\n\t\tif(M-1-i<0)break;\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(j+i>N)break;\n\t\t\tnum[j+i]+=dp[j][M-1-i];\n\t\t\tnum[j+i]%=MOD;\n\t\t}\n\t}\n\tlong long int ans=0;\n\tfor(int i=0;i<=N;i++){\n\t//\tcout<<i<<\" \"<<num[i]<<endl;\n\t\tlong long int add=by[N];\n\t\tadd*=rev[i];\n\t\tadd%=MOD;\n\t\tadd*=rev[N-i];\n\t\tadd%=MOD;\n\t\tadd*=num[i];\n\t\tadd%=MOD;\n\t\tans+=add;\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\nconst int mod = 998244353;\nconst int N = 3001;\nint read() {\n\tint s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\nvoid put(int x) {\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint C[N][N];\n\nint add(int x, int y) {\n\tx += y;\n\treturn x >= mod ? x - mod : x;\n}\n\nint F(int n, int X) {\n\tint ans = 0;\n\tif((X & 1) || 2 * n < X) ans = 1;\n\tfor(int i = n; i < 2 * n; i++) {\n\t\tif(i < X) ans = add(ans, C[n][i - n]);\n\t\telse {\n\t\t\tif(!((i - X) & 1)) continue;\n\t\t\tint c = (i - X + 1) / 2;\n\t\t\tif(4 * c > i) continue;\n\t\t\tint m = n - 2 * c;\n\t\t\tans = add(ans, C[m][i - 4 * c - m]);\n\t\t}\n\t} return ans;\n}\n\nint main() {\n\tint n = read(), X = read();\n\tC[0][0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1; j <= i; j++) {\n\t\t\tC[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);\n\t\t}\n\t} int ans = 0;\n\tfor(int i = 0; i <= n; i++) ans = add(ans, (LL)F(n - i, X) * C[n][i] % mod);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  // mint(long long);\n  mint(long long v)\n      : v(fast == 0 ? (v < 0 ? (v % MODS[kind] + MODS[kind]) % MODS[kind]\n                             : v % MODS[kind])\n                    : (v)) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  if (fast == 1) {\n    a.v += b.v;\n    return a;\n  }\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  if (fast == 1) {\n    a.v += b;\n    return a;\n  }\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\nvector<vector<mint<>>> comb_table;\n\nmint<> comb(LL N, LL K) {\n  if (N < K) return 0;\n  if (K < 0) return 0;\n  return comb_table[N][K];\n}\n\nvoid init(int N) {\n  comb_table.resize(N + 6);\n  for (int i = 0; i <= N; i++) {\n    comb_table[i].resize(i + 1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for (int j = 1; j < i; j++) {\n      comb_table[i][j] = comb_table[i - 1][j - 1] + comb_table[i - 1][j];\n    }\n  }\n}\n\nvoid solve(long long N, long long X) {\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2 * N + 5, N + 5);\n\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<0, 1> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nconst int MOD=998244353;\nvi fac,finv,inv;\nvoid init(ll n){\n    n*=3;\n    fac=vi(n+5);finv=vi(n+5);inv=vi(n+5);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    REP(i,2,n+5){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}\nlong long modcom(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main(){\n    ll n,k;cin>>n>>k;\n    vvi dp(n+1,vi(n*2+1));\n    dp[0][0]=1;\n    rep(i,n)rep(j,n*2+1){\n        if(dp[i][j])rep(t,3)dp[i+1][j+t]=(dp[i+1][j+t]+dp[i][j])%MOD;\n    }\n    init(n);\n    ll ans=0;\n    rep(i,k)ans=(ans+dp[n][i])%MOD;\n    ll i=1;\n    while(true){\n        ll t=k-2-i;\n        if(t<0)break;\n        rep(j,n-i){\n            ans=(ans+dp[j][t]*modcom(n-j-1,i))%MOD;\n        }\n        i+=2;\n    }\n    REP(i,k,n+1){\n        if(k&1)ans+=modcom(n,i);\n        ans%=MOD;\n    }\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  //mint(long long);\n  mint(long long v) : v( fast == 0 ? (v % MODS[kind] + MODS[kind]) % MODS[kind]  : v % MODS[kind]) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  if(kind==1) {\n    a.v += b.v;\n    return a;\n\n  }\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  if(kind==1) {\n    a.v += b;\n    return a;\n\n  }\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\n\nvector<vector<mint<>>> comb_table;\n\n\nmint<> comb(LL N, LL K) {\n  if(N<K) return 0;\n  if(K<0) return 0;\n  return comb_table[N][K];\n}\n\n\nvoid init(int N) {\n  comb_table.resize(N+6);\n  for(int i=0; i<=N; i++) {\n    comb_table[i].resize(i+1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for(int j=1; j<i; j++) {\n      comb_table[i][j] = comb_table[i-1][j-1] + comb_table[i-1][j];\n    }\n  }\n  \n}\n\n\n\n\n\nvoid solve(long long N, long long X){\n  init(N);\n  mint<> zero = 0;\n  auto dp = exvector(zero, 2*N+5, N+5);\n  \n  dp[0][1] = 1;\n\n  for(int i=1; i<=2*N; i++) {\n    for(int j=0; j<=N+1; j++) {\n      dp[i][j] = 0;\n      if(j>0) dp[i][j] += dp[i-1][j-1];\n      if(i>1 && j>0) dp[i][j] += dp[i-2][j-1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<0,1> ans = 0;\n  for(int i=0; i<X-1; i++) {\n    for(int k=0; k<=N+1; k++)\n      ans += dp[i][k] * comb(N, k-1);// % MOD ;\n\n  }\n  for(int i=0; i<=N; i++) {\n    for(int k=0; k<=N+1; k++) {\n      if(X-1-i*2 >= 0) \n        ans += dp[X-1-i*2][k] * comb(N, k-1 + i*2);// % MOD;\n    }\n  }\n  if(X%2==1) {\n    for(int i=X; i<=N; i++) {\n      int hako = i+1;\n      int nokori = N-i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n\n\n\n}\n\nint main(){ \n    cout << setprecision(10);\n    long long N;\n    scanf(\"%lld\",&N);\n    long long X;\n    scanf(\"%lld\",&X);\n    solve(N, X);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\nconst int MAX = 3e3 + 41;\nconst int MOD = 998244353;\n\nint n, x;\nint p2[MAX];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint sub(int a, int b) {\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn (ll) a * b % MOD;\n}\n\nint C[MAX][MAX];\n\nvoid init() {\n\tfi(0, MAX - 1) {\n\t\tC[i][0] = 1;\n\t\tfj(1, i) {\n\t\t\tC[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);\n\t\t}\t\t\n\t}\n\tp2[0] = 1;\n\tfi(1, MAX - 1) p2[i] = mul(p2[i - 1], 2);\n}\n\nint calcless() {\n\tint res = 0;\t\n\tfi(0, n) {\n\t\tif (i >= x) break;\n\t\tfj(0, n) {\n\t\t\tif (i + j * 2 >= x) break;\n\t\t\tif (i + j > n) break;\t\t\t\n\t\t\tint v1 = C[n][i + j];\n\t\t\tint v2 = C[i + j][i];\n\t\t\tint v = mul(v1, v2);\n\t\t\tres = add(res, v);\n\t\t}\n\t}\n\treturn res;\n}\n\nint getways(int l) {\t\n\t\n\tint res = 0;\n\tbool flag = 0;\t\n\tfor (int l0 = 2; l0 <= l; l0++) {\n\t\tif (l0 * 2 < x + 1) continue;\n\t\tint pref = l - l0 + 1;\n\t\tif (pref >= l0 - 1) {\n\t\t\tflag = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tint q2 = pref + 1;\n\t\tint rem = l0 - q2;\t\t\n\t\tint rem2 = x + 1 - q2 * 2 - rem;\n\t\tif (rem2 < 0) continue;\n\t\tif (rem2 > rem) continue;\n\t\tif (rem2 == rem) {\n\t\t\tflag = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tint ways = C[rem][rem2];\t\t\n\t\tres = add(res, ways);\n\t}\n//\tres = add(res, flag);\n\tint want = x + 1;\n\tif (want % 2 == 0) {\n\t\tif (want / 2 <= l) {\n\t\t\tres = add(res, 1);\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve () {\n\tif (x == 1) {\n\t\tprintf(\"%d\\n\", p2[n]);\n\t\treturn;\n\t}\n\tint ans = 0;\n\tans = add(ans, calcless());\n\terr(\"less = %d\\n\", ans);\n\tfo(0, n) {\n\t\tint v1 = getways(o);\n\t\tint v2 = C[n][o];\n\t\tint v = mul(v1, v2);\n\t\terr(\"l = %d ways = %d\\n\", o, v);\n\t\tans = add(ans, v);\n\t}\t\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\n\tinit();\n\t\t\n\tscanf(\"%d %d\", &n, &x);\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long mod = 998244353;\nlong long dp[3009][6009];\nlong long nr[3009][3009];\n\nvoid init() {\n\tfor (int i = 0; i <= 3000; i++) {\n\t\tfor (int j = 0; j <= 3000; j++) {\n\t\t\tif (i == 0 || j == 0) nr[i][j] = 1;\n\t\t\telse nr[i][j] = (nr[i - 1][j] + nr[i][j - 1]) % mod;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= 3000; i++) {\n\t\tfor (int j = 0; j <= 6000; j++) {\n\t\t\tdp[i + 1][j + 0] += dp[i][j]; dp[i + 1][j + 0] %= mod;\n\t\t\tdp[i + 1][j + 1] += dp[i][j]; dp[i + 1][j + 1] %= mod;\n\t\t\tdp[i + 1][j + 2] += dp[i][j]; dp[i + 1][j + 2] %= mod;\n\t\t}\n\t}\n}\n\nlong long ncr(int a, int b) {\n\tif (a < b || b < 0) return 0;\n\treturn nr[a - b][b];\n}\n\nlong long solve(int N, int X) {\n\t// パターン A : 合計が X 以下の場合\n\tlong long sum1 = 0;\n\tfor (int i = 0; i < X; i++) { sum1 += dp[N][i]; sum1 %= mod; }\n\n\t// パターン B : 合計が X 以上の場合\n\tlong long sum2 = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 1; j <= N - i; j++) {\n\t\t\t// i : 2 の個数, j : 1 の個数\n\t\t\tif (j >= X || i * 2 + j < X) continue;\n\t\t\tif ((i * 2 + j) % 2 == X % 2) continue;\n\t\t\tlong long cr = min(1LL * i, 1LL * ((X - 1) - j) / 2);\n\t\t\tlong long cl = i - cr;\n\t\t\tif (cl > cr) continue;\n\n\t\t\tlong long val = (cr - cl) + 1;\n\t\t\tlong long cost = ncr(N, i + j);\n\t\t\t// cout << \"(i, j) = (\" << i << \", \" << j << \") -> val = \" << val << \", cost = \" << cost << \", mul = \" << val * cost << endl;\n\t\t\tsum2 += val * cost;\n\t\t\tsum2 %= mod;\n\t\t}\n\t}\n\n\t// パターン C : 合計が X 以上の場合（全て 0 か 2）\n\tlong long sum3 = 0;\n\tif (X % 2 == 1) {\n\t\tfor (int i = 0; i <= N; i++) {\n\t\t\t// i : 2 の個数\n\t\t\tif (i * 2 < X) continue;\n\t\t\tlong long cost = ncr(N, i);\n\t\t\tsum3 += cost;\n\t\t\tsum3 %= mod;\n\t\t}\n\t}\n\treturn (sum1 + sum2 + sum3) % mod;\n}\n\nint main() {\n\tinit();\n\tlong long N, X; cin >> N >> X;\n\tcout << solve(N, X) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 3e3 + 10,mod = 998244353;\n\nint fac[N],inv[N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline int fpm(int a,int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod,b /= 2;\n\t}\n\treturn res;\n}\n\ninline void init(int n) {\n\tfac[0] = 1;\n\tFor(i,1,n) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[n] = fpm(fac[n],mod - 2);\n\tFordown(i,n,1) inv[i - 1] = 1ll * inv[i] * i % mod;\n}\n\ninline int C(int n,int m) {\n\tif(n < 0 || m < 0 || n < m) return 0;\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main() {\n\n\tint n = read(),v = read();\n\tinit(n);\n\tif(v & 1) {\n\t\tint ans = fpm(2,n);\n\t\tFor(i,0,n) {\n\t\t\tint sum = 0;\n\t\t\tFor(j,i,min(i + i,v - 1)) if(j & 1) sum = (sum + C(i,j - i)) % mod;\n\t\t\tFor(j,i,i + i - 1) if(!(j & 1)) {\n\t\t\t\tint cnt = max(0,(j - v + 2) / 2);\n\t\t\t\tsum = (sum + C(i - cnt * 2,j - i - cnt * 2)) % mod;\n\t\t\t}\n\t\t\tans = (ans + 1ll * C(n,i) * sum) % mod;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t} else {\n\t\tint ans = 0;\n\t\tFor(i,0,n) {\n\t\t\tint sum = 0;\n\t\t\tFor(j,i,min(i + i,v - 1)) if(!(j & 1)) sum = (sum + C(i,j - i)) % mod;\n\t\t\tFor(j,i,i + i - 1) if(j & 1) {\n\t\t\t\tint cnt = max(0,(j - v + 1) / 2);\n\t\t\t\tsum = (sum + C(i - cnt * 2,j - i - cnt * 2)) % mod;\n\t\t\t}\n\t\t\tans = (ans + 1ll * C(n,i) * sum) % mod;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint N,M,K,L,R,H,W;\n\n//const long long int MOD=1000000007;\nconst long long int MOD=998244353;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main(){\n\t\n\tcin>>N>>M;\n\tvector<vector<long long int>>dp(N+1,vector<long long int>(2*N+1));\n\tdp[0][0]=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i;j<=i*2;j++){\n\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\tdp[i+1][j+1]%=MOD;\n\t\t\tdp[i+1][j+2]+=dp[i][j];\n\t\t\tdp[i+1][j+2]%=MOD;\n\t\t}\n\t}\n\tvector<long long int>num(N+1);\n\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tnum[i]+=dp[i][j];\n\t\t\tnum[i]%=MOD;\n\t\t}\n\t}\n\tif(M&1){\n\t\tfor(int i=M+1;i<=2*N;i+=2){\n\t\t\tnum[i/2]++;\n\t\t}\n\t}\n\t//cout<<\"hoge\"<<endl;\n\tvector<long long int>by(N+1,1);\n\tvector<long long int>rev(N+1,1);\n\tfor(int i=2;i<=N;i++){\n\t\tby[i]=by[i-1]*i;\n\t\tby[i]%=MOD;\n\t\trev[i]=power(by[i],MOD-2,MOD);\n\t}\n\tfor(int i=0;i<=N;i++){\n\t//\tcout<<i<<\" \"<<num[i]<<endl;\n\t}\n\tfor(int i=2;i<M-1;i+=2){\n\t\tif(M-1-i<0)break;\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(j+i>N)break;\n\t\t\t//cout<<i<<\" \"<<j<<\" \"<<M-1-i<<endl;\n\t\t\tif(j*2==M-1-i)continue;\n\t\t\tnum[j+i]+=dp[j][M-1-i];\n\t\t\tnum[j+i]%=MOD;\n\t\t}\n\t}\n\tlong long int ans=0;\n\tfor(int i=0;i<=N;i++){\n\t//\tcout<<i<<\" \"<<num[i]<<endl;\n\t\tlong long int add=by[N];\n\t\tadd*=rev[i];\n\t\tadd%=MOD;\n\t\tadd*=rev[N-i];\n\t\tadd%=MOD;\n\t\tadd*=num[i];\n\t\tadd%=MOD;\n\t\tans+=add;\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#include <iostream>\n#include <bitset>\n#define PII pair <int, int>\n#define PPI pair <PII, int>\n#define x first\n#define y second\n#define P 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N, X;\n\nll F[2][6010][2][3][2], G[3010][6010];\n\nvoid add(ll &x, ll y) {\n    x = (x + y) % P;\n}\nint main() {\n    scanf(\"%d%d\", &N, &X);\n    G[0][0] = 1;\n    ll ans = 0;\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < X; j++) {\n            add(G[i + 1][j], G[i][j]);\n            add(G[i + 1][j + 1], G[i][j]);\n            add(G[i + 1][j + 2], G[i][j]);\n        }\n    for(int i = 0; i < X; i++) add(ans, G[N][i]);\n    for(int T = 0; T <= 1; T++) {\n        int a = 0, b = 1;\n        F[a][0][0][T][0] = 1;\n        for(int i = 0; i < N; i++, swap(a, b)) {\n            memset(F[b], 0, sizeof F[b]);\n            for(int o = 0; o < X; o++)\n                for(int k = 0; k < 3; k++)\n                    for(int l = 0; l + k < 3; l++) {\n                        // ==\n                        add(F[b][o + l][0][k + l][0], F[a][o + l][0][k][0]);\n                        add(F[b][o + l][1][k + l][0], F[a][o + l][1][k][0]);\n                        add(F[b][o + l][1][k + l][1], F[a][o + l][1][k][0]);\n                        add(F[b][o + l][0][k][1], F[a][o + l][0][k][1]);\n                        // !=\n                        if(l == 0) continue;\n                        add(F[b][o + l][0][l][0], F[a][o + l][1][k][0]);\n                        add(F[b][o + l][1][l][0], F[a][o + l][0][k][0]);\n                        add(F[b][o + l][0][l][1], F[a][o + l][1][k][1]);\n                    }\n        }\n        if(X - T >= 0) {\n            for(int j = 0; j < 2; j++)\n                for(int k = 0; k < 3; k++)\n                    add(ans, F[a][X - T][j][k][1]);\n        }\n    }\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  template<class Z> ModInt(Z x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t) v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  template<class Z> M pow(Z n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  template<class Z> friend M operator*(Z l, M r) { return M(l) *= r; }\n  template<class Z> friend M operator/(Z l, M r) { return M(l) /= r; }\n  template<class Z> friend M operator+(Z l, M r) { return M(l) += r; }\n  template<class Z> friend M operator-(Z l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  template<class Z> friend bool operator==(Z l, M r) { return M(l) == r; }\n  template<class Z> friend bool operator!=(Z l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<998244353>;\n\nV<Mint> fact, ifact, inv, powB;\nvoid init(int n, int B = 2) {\n  fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = i * fact[i - 1];\n  }\n  ifact.resize(n + 1);\n  ifact[n] = fact[n].inv();\n  for (int i = n; i > 0; --i) {\n    ifact[i - 1] = i * ifact[i];\n  }\n  inv.resize(n + 1);\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    int q = Mint::p() / i;\n    inv[i] = -q * inv[Mint::p() - i * q];\n  }\n  powB.resize(n + 1);\n  powB[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    powB[i + 1] = powB[i] * B;\n  }\n}\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] * ifact[n - r];\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, x; cin >> n >> x;\n  VV<Mint> dp(n + 1, V<Mint>(2 * n + 1));\n  dp[0][0] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int s = 0; s <= 2 * n; ++s) {\n      for (int j = 1; j < 3; ++j) if (s + j <= 2 * n) {\n        dp[i + 1][s + j] += dp[i][s];\n      }\n    }\n  }\n  init(n);\n  Mint res;\n  for (int k = 0; k <= n; ++k) {\n    res += comb(n, k) * accumulate(begin(dp[k]), begin(dp[k]) + x, Mint(0));\n  }\n  for (int s = x + 1; s <= 2 * n; s += 2) {\n    int t = s - x + 1 >> 1;\n    int r = s - 4 * t;\n    if (2 * t <= n and r >= 0) {\n      for (int l = 0; l <= n - 2 * t; ++l) {\n        res += comb(n, l + 2 * t) * dp[l][r];\n      }\n    } else {\n      if (x & 1) res += comb(n, s >> 1);\n    }\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#define SIZE 3005\n#define MX 6005\n#define MOD 998244353\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[SIZE],fac[SIZE],finv[SIZE];\nvoid make()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nll dp[SIZE][MX];\nll dp2[SIZE][SIZE];\nll dp3[SIZE][SIZE];\nll rdp[SIZE][SIZE];\n\nint main()\n{\n\tmake();\n\tint n,X;\n\tscanf(\"%d %d\",&n,&X);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<X;j++)\n\t\t{\n\t\t\tif(i==0)\n\t\t\t{\n\t\t\t\tif(j==0) dp[i][j]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=0;\n\t\t\t\t//dp[i][j]=dp[i-1][j];\n\t\t\t\tif(j>0) dp[i][j]+=dp[i-1][j-1];\n\t\t\t\tif(j>1) dp[i][j]+=dp[i-1][j-2];\n\t\t\t\tif(dp[i][j]>=MOD) dp[i][j]-=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ret=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<X;j++)\n\t\t{\n\t\t\tint sum=j,len=i;\n\t\t\tlen+=2;\n\t\t\tsum+=2;\n\t\t\tif(len<=n&&sum<X)\n\t\t\t{\n\t\t\t\tif(sum%2!=X%2)\n\t\t\t\t{\n\t\t\t\t\tint lim=(X-sum)/2;\n\t\t\t\t\tdp2[len][lim]+=dp[i][j];\n\t\t\t\t\tif(dp2[len][lim]>MOD) dp2[len][lim]-=MOD;\n\t\t\t\t\t//if(dp[i][j]>0) printf(\"%d %d : %d\\n\",len,lim,dp[i][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint lim=(X-sum)/2-1;\n\t\t\t\t\tdp3[len][lim]+=dp[i][j];\n\t\t\t\t\tif(dp3[len][lim]>MOD) dp3[len][lim]-=MOD;\n\t\t\t\t\t//if(dp[i][j]>0) printf(\"%d %d : %d\\n\",len,lim,dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==0)\n\t\t\t{\n\t\t\t\tlen=1,sum=1;\n\t\t\t\tif(len<=n&&sum<X)\n\t\t\t\t{\n\t\t\t\t\tif(sum%2!=X%2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint lim=(X-sum)/2;\n\t\t\t\t\t\tdp2[len][lim]+=dp[i][j];\n\t\t\t\t\t\tif(dp2[len][lim]>MOD) dp2[len][lim]-=MOD;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint lim=(X-sum)/2-1;\n\t\t\t\t\t\tdp3[len][lim]+=dp[i][j];\n\t\t\t\t\t\tif(dp3[len][lim]>MOD) dp3[len][lim]-=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\trdp[i][j]=dp2[i][j];\n\t\t\tif(i>0&&j+1<=n)\n\t\t\t{\n\t\t\t\trdp[i][j]+=rdp[i-1][j+1];\n\t\t\t\tif(rdp[i][j]>=MOD) rdp[i][j]-=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tdp2[i][j]=rdp[i][j]*2%MOD-dp2[i][j];\n\t\t\tif(dp2[i][j]<0) dp2[i][j]+=MOD;\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tfor(int j=0;j+1<=n;j++)\n\t\t{\n\t\t\tdp2[i][j]+=dp2[i-2][j+1];\n\t\t\tif(dp2[i][j]>=MOD) dp2[i][j]-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tll sum=0;\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tsum+=dp2[i][j];\n\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t}\n\t\tret+=C(n,i)*sum%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t}\n\t//printf(\"* %lld\\n\",ret);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\trdp[i][j]=dp3[i][j];\n\t\t\tif(i>0&&j+1<=n)\n\t\t\t{\n\t\t\t\trdp[i][j]+=rdp[i-1][j+1];\n\t\t\t\tif(rdp[i][j]>=MOD) rdp[i][j]-=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tdp3[i][j]=rdp[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j+1<=n;j++)\n\t\t{\n\t\t\tdp3[i][j]+=dp3[i-1][j+1];\n\t\t\tif(dp3[i][j]>=MOD) dp3[i][j]-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tll sum=0;\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tsum+=dp3[i][j];\n\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t}\n\t\tret+=C(n,i)*sum%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t}\n\t//printf(\"* %lld\\n\",ret);\n\tif(X%2==1)\n\t{\n\t\tll all=1;\n\t\tfor(int i=0;i<n;i++) all=all*2LL%MOD;\n\t\tret+=all;\n\t\tif(ret>=MOD) ret-=MOD;\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tif(i*2>=X) break;\n\t\t\tret+=C(n,i);\n\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=998244353;\nconst int N=3005;\nint n,x,f[N][2*N],dp[N][2*N];\nint fac[N],infac[N],inv[N];\n\nnamespace MATHEMATICS\n{\n\tint add(int x,int y)\n\t{\n\t\tint ret=x+y;\n\t\tif(ret>=mod) ret-=mod;\n\t\treturn ret;\n\t}\n\tint mi(int x,int y)\n\t{\n\t\tint ret=x-y;\n\t\tif(x<0) x+=mod;\n\t\treturn ret;\n\t}\n\t\n\tvoid inc(int &x,int y)\n\t{\n\t\tx+=y;\n\t\tif(x>=mod) x-=mod;\n\t}\n\tvoid dec(int &x,int y)\n\t{\n\t\tx-=y;\n\t\tif(x<0) x+=mod;\n\t}\n\t\n\tint mul(int x,int y)\n\t{\n\t\treturn 1LL*x*y%mod;\n\t}\n\tint F_p(int x,int y)\n\t{\n\t\tint bas=x,ret=1;\n\t\twhile(y)\n\t\t{\n\t\t\tif(y&1) ret=mul(ret,bas);\n\t\t\tbas=mul(bas,bas);\n\t\t\ty>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n}\nusing namespace MATHEMATICS;\n\nint C(int x,int y)\n{\n\treturn mul(fac[x],mul(infac[y],infac[x-y]));\n}\nvoid prework()\n{\n\tint i,j;f[0][0]=1;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i;j<=2*i;++j)\n\t\t\tf[i][j]=add(f[i-1][j-1],f[i-1][j-2]);\n\t\n\tfac[0]=1;for(i=1;i<=n;++i) fac[i]=mul(fac[i-1],i);\n\tinv[1]=1;for(i=2;i<=n;++i) inv[i]=mul(inv[mod%i],mod-mod/i);\n\tinfac[0]=1;for(i=1;i<=n;++i) infac[i]=mul(infac[i-1],inv[i]);\n}\n\nvoid DP()\n{\n\tint i,j,k;dp[0][0]=1;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i;j<=2*i;++j)\n\t\t{\n\t\t\tif(j<x-1) dp[i][j]=f[i][j];\n\t\t\telse\n\t\t\t{\n\t\t\t\tif((j&1)==(x&1)) dp[i][j]=0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint len=(j-(x-1))>>1;\n\t\t\t\t\tif(2*len>i||4*len>j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((x&1)&&(i<<1)==j) dp[i][j]=1;\n\t\t\t\t\t\telse dp[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse dp[i][j]=f[i-2*len][j-4*len];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\nvoid work()\n{\n\tint i,j,ans=0;\n\tfor(i=0;i<=n;++i)\n\t\tfor(j=i;j<=2*i;++j)\n\t\t\tinc(ans,mul(dp[i][j],C(n,i)));\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&x);\n\tprework();DP();work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\n#define lowbit(x) (x)&(-x)\n#define rep(i,a,b) for (int i=a;i<=b;i++)\n#define per(i,a,b) for (int i=a;i>=b;i--)\n#define maxd 998244353\ntypedef long long ll;\nconst int N=3000;\nconst double pi=acos(-1.0);\nint n,x;\nll c[3030][3030];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n\twhile ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n\treturn x*f;\n}\n\nvoid init()\n{\n\trep(i,0,N)\n\t{\n\t\tc[i][0]=1;\n\t\trep(j,1,i) c[i][j]=(c[i-1][j-1]+c[i-1][j])%maxd;\n\t}\n}\n\nll solve(int n,int x)\n{\n\tll ans=0;\n\tif ((x%2==1) || (2*n<x)) ans=1;\n\trep(s,n,2*n-1)\n\t{\n\t\tif (s<x) ans=(ans+c[n][s-n])%maxd;\n\t\telse\n\t\t{\n\t\t\tif ((s-x)%2==0) continue;\n\t\t\tint lft=(s-x+1)/2;\n\t\t\tif (lft*2<n)\n\t\t\t{\n\t\t\t\tll restn=n-2*lft,rests=s-4*lft;\n\t\t\t\tif ((restn<=rests) && (rests<=2*restn)) ans=(ans+c[restn][rests-restn])%maxd;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tinit();ll ans=0;\n\tn=read();x=read();\n\trep(i,0,n) ans=(ans+c[n][i]*solve(n-i,x))%maxd;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#define N_MAX 6002\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nll inv[N_MAX],fac[N_MAX],finv[N_MAX];\n\nvoid init(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<N_MAX;i++){\n        inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n        fac[i]=fac[i-1]*(ll) i%MOD;\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}\n\nll comb(ll n, ll r){\n  ll ans;\n  if(n < r){\n      ans = 0;\n  }else{\n      ans = (fac[n]*finv[r])%MOD;\n      ans = (ans*finv[n-r])%MOD;\n      ans = (ans+MOD)%MOD;\n  }\n  return ans;\n}\n\nint N, X;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    init();\n    cin >> N >> X;\n    ll ans = 0;\n    for(int i = 0; i <= 2*N; i++){\n        if(i < X){\n            for(int j = 0; j <= i; j++){\n                int r = i-j;\n                if(r%2 != 0) continue;\n                int cnt = j+r/2;\n                ll cb = comb(j+r/2, j);\n                ll hcb = comb(N, cnt);\n                ans += (cb*hcb)%MOD;\n                ans %= MOD;\n            }\n        }\n        else if(i%2 == X%2){\n            continue;\n        }else{\n            int m = 2*max((i-(X-1))/2, 0);\n            int rem = i-(m*2);\n            // cout << i << ' ' << rem << ' ' << m << endl;\n            if(rem < 0){\n                if(i%2 == 0){\n                    ll cb = comb(N, i/2);\n                    ans += cb;\n                    ans %= MOD;\n                }\n            }\n            for(int j = 0; j <= rem; j++){\n                int r = rem-j;\n                if(r%2 == 1 || r < 0) continue;\n                int cnt = m+j+r/2;\n                if(cnt > N) continue;\n                // cout << j << ' ' << cnt << endl;\n                ll cb = comb(j+r/2, j);\n                ll hcb = comb(N, cnt);\n                ans += (cb*hcb)%MOD;\n                ans %= MOD;\n            }\n        }\n        // cout << i << \"->\" << ans << endl;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef unsigned long long ll;\nconst ll N=12e4,mo=998244353;\n\nll jc[N],ny[N];\n\ninline ll ksm(ll o,ll t)\n{\n\tll y=1;\n\tfor(;t;t>>=1,o=o*o%mo)\n\tif(t&1)y=y*o%mo;\n\treturn y;\n}\n\ninline ll C(int a,int b)\n{return (a<b||b<0)?0:(jc[a]*ny[b]%mo*ny[a-b]%mo);} \n\nint n,x;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&x);\n\tjc[0]=ny[0]=1;\n\tfo(i,1,n)jc[i]=jc[i-1]*i%mo;\n\tny[n]=ksm(jc[n],mo-2);\n\tfd(i,n-1,1)ny[i]=ny[i+1]*(i+1)%mo;\n\tll ans=1;\n\tfo(i,1,x-1){\n\t\tint ha=i>>1;\n\t\tfo(l,0,ha){\n\t\t\tint lef=i-2*l;\n\t\t\tans=(ans+C(n,l)*C(n-l,lef))%mo;\n\t\t}\n\t}\n\tfo(i,1,n){\n\t\tif(2*i>=x-1){\n\t\t\tif(x%2==1)\n\t\t\tfo(l,i,n)\n\t\t\tif(2*l-(x-1)>=x-1)ans=(ans+C(n,l))%mo;\n\t\t\tbreak;\n\t\t}\n\t\tint hh=(x-1)-2*i,ha=hh>>1;\n\t\tfo(l,0,ha)ans=(ans+C(hh-l,l)*C(n,2*i+hh-l))%mo;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst int MO=998244353;\nint n,x;\nLL ans,fac[100010],inv[100010];\nLL pw(LL x,LL y){\n\tLL t=1;\n\tfor (;y;y>>=1){\n\t\tif (y&1) t=t*x%MO;\n\t\tx=x*x%MO;\n\t}\n\treturn t;\n}\nLL C(int x,int y){\n\treturn fac[x]*inv[y]%MO*inv[x-y]%MO;\n}\nLL cal(int x,int y){\n\tif (y<x || y>x*2) return 0ll;\n\treturn C(x,y-x);\n}\nint main(){\n\tfac[0]=1;\n\tFOR(i,1,100000) fac[i]=fac[i-1]*i%MO;\n\tinv[100000]=pw(fac[100000],MO-2);\n\tFORD(i,99999,0) inv[i]=inv[i+1]*(i+1)%MO;\n\tcin>>n>>x;\n\tans=1;\n\tFOR(m,1,n){\n\t\tLL t=0;\n\t\tFOR(j,0,x-1) (t+=cal(m,j))%=MO;\n\t\tFOR(i,0,m-1){\n\t\t//\t<=i >=m-i+1\n\t\t\tif (m-i+1<=i) (t+=cal(i+i-m,x-1-(m-i)*2))%=MO;\n\t\t\telse if (i*2==x-1) (++t)%=MO;\n\t\t}\n\t\t(ans+=t*C(n,m))%=MO;\n\t}\n\tans=(ans%MO+MO)%MO;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=3000,mod=998244353;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m;\n\nvoid into(){\n  scanf(\"%d%d\",&n,&m);\n}\n\nint c[N+9][N+9];\n\nvoid Get_c(){\n  c[0][0]=1;\n  for (int i=1;i<=n||i<=m;++i){\n\tc[i][0]=c[i][i]=1;\n\tfor (int j=1;j<i;++j) c[i][j]=add(c[i-1][j],c[i-1][j-1]);\n  }\n}\n\nint Get_c(int n,int m){return n<m||m<0?0:c[n][m];}\n\nint Get_ans(int n){\n  int res=m&1||n<<1<m;\n  for (int i=n;i<n<<1;++i)\n\tif (i<m) sadd(res,Get_c(n,i-n));\n    else if (m-i&1){\n\t  int p=i-m+1>>1;\n\t  sadd(res,Get_c(n-p*2,i-p*2-n));\n\t}\n  return res;\n}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=0;i<=n;++i) sadd(ans,mul(Get_c(n,i),Get_ans(i)));\n}\n\nvoid work(){\n  Get_c();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD_CONST = 998244353;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\ntemplate <int size, long long param = MOD_CONST, bool preserve = false>\nclass CombinationTool {\n  vector<mint<param>> invs;\n\n public:\n  vector<mint<param>> kaijo;\n  vector<vector<mint<param>>> table;\n\n  constexpr CombinationTool() {\n    const int N = size;\n    if (preserve) {\n      table.resize(N + 5);\n      for (int i = 0; i < N + 5; i++) table[i].resize(i + 1);\n      for (int i = 0; i < N; i++) {\n        table[i][0] = 1;\n        table[i][i] = 1;\n      }\n      for (int i = 1; i < N + 5; i++)\n        for (int j = 1; j < i; j++)\n          table[i][j] = table[i - 1][j - 1] + table[i - 1][j];\n\n    } else {\n      kaijo.resize(N + 5);\n      invs.resize(N + 5);\n      kaijo[0] = 1;\n      invs[0] = 1;\n      for (int i = 1; i < N + 5; i++) {\n        kaijo[i] = kaijo[i - 1] * i;\n        invs[i] = mint<param>(1) / kaijo[i];\n      }\n    }\n  }\n\n  mint<param> get(int n, int m) {\n    if (m < 0 || m > n) return mint<param>(0);\n    if (preserve) return table[n][m];\n    return kaijo[n] * invs[m] * invs[n - m];\n  }\n};\n\nmint<> dp[6005][3005];\nvoid solve(long long N, long long X) {\n  CombinationTool<3050, MOD_CONST, false> comb;\n\n  mint<> zero = 0;\n  // auto dp = exvector(zero, 2 * N + 5, N + 5);\n  for (int j = 0; j <= N + 1; j++) dp[0][j] = 0;\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<MOD_CONST, 1> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb.get(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb.get(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb.get(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#include <iostream>\n#include <bitset>\n#define PII pair <int, int>\n#define PPI pair <PII, int>\n#define x first\n#define y second\n#define P 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N, X;\n\nint F[2][6010][2][2], G[3010][6010], C[6010][6010];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\nint main() {\n    scanf(\"%d%d\", &N, &X);\n    G[0][0] = 1;\n    int ans = 0;\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < X; j++) {\n            add(G[i + 1][j], G[i][j]);\n            add(G[i + 1][j + 1], G[i][j]);\n            add(G[i + 1][j + 2], G[i][j]);\n        }\n    if(X % 2 == 1) {\n        for(int i = 0; i <= N; i++)\n            for(int j = 0; j <= i; j++)\n                C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n        for(int i = X; i <= N; i++)\n            add(ans, C[N][i]);\n    }\n    for(int i = 0; i < X; i++) add(ans, G[N][i]);\n    int a = 0, b = 1;\n    memset(F, 0, sizeof F);\n    F[a][0][0][1 - 1] = 1;\n    for(int i = 0; i < N - 1; i++, swap(a, b)) {\n        memset(F[b], 0, sizeof F[b]);\n        for(int o = 0; o < X; o++)\n            for(int s = 0; s < 2; s++)\n                for(int k = 1; k < 3; k++) if(F[a][o][s][k - 1])\n                    for(int l = 0; l + k < 3; l++) {\n                        add(F[b][o + l][s][k + l - 1], F[a][o][s][k - 1]);\n                        if(l) add(F[b][o + l][!s][l - 1], F[a][o][s][k - 1]);\n                    }\n        for(int o = 1; o < X; o++)\n            for(int k = 1; k < 3; k++)\n                for(int l = 1; l + k < 3; l++)\n                    add(ans, 1LL * F[b][o][1][k - 1] * G[N - i - 2][X - 1 - o - l] % P);\n    }\n    printf(\"%d\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 998244353;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 3e3 + 5;\n\nmi fact[MAX];\nmi ifact[MAX];\nmi len[MAX];\nmi dp[MAX][MAX]; // length, sum\nmi ones[MAX][MAX]; // length, sum\nmi twos[MAX][MAX];// mx 2's, num used\nmi twos_total[MAX][MAX]; //mx 2's used at most in total, num used\nmi rest[MAX][MAX];// mx 2's, num total\nmi rest_total[MAX][MAX];\nmi po[MAX];\nmi prefix[MAX];\nmi up_prefix[MAX];\nmi choose(int a, int b){\n    if(b < 0) return 0;\n    if(a < b) return 0;\n    return fact[a] * ifact[b] * ifact[a - b];\n}\nmi sum_prefix(int l, int r){\n    return prefix[r] - (l == 0 ? 0 : prefix[l - 1]);\n}\nmi sum_up_prefix(int l, int r){\n    return up_prefix[r] - (l == 0 ? 0 : up_prefix[l - 1]);\n}\nmi progression(int l, int r, int st, int d){\n    return (sum_up_prefix(l, r) - sum_prefix(l, r) * l) * d + sum_prefix(l, r) * st;\n}\nint n, x;\n\nint main(){\n    fact[0] = 1; ifact[0] = 1; po[0] = 1;\n    for(int i = 1; i < MAX; i++) fact[i] = fact[i - 1] * i, ifact[i] = ifact[i - 1] / i, po[i] = po[i - 1] * 2;\n    ios_base :: sync_with_stdio(0); cin.tie(0);\n    cin >> n >> x;\n    prefix[0] = 1;\n    for(int i = 1; i <= n; i++){\n        prefix[i] = prefix[i - 1] + choose(n, i);\n        up_prefix[i] = up_prefix[i - 1] + choose(n, i) * i;\n    }\n    mi ans = 0;\n    if(x % 2 == 0){\n        for(int i = 0; i < x / 2; i++){\n            ans += choose(n, i);\n        }\n    }\n    else ans += po[n];\n    dp[0][0] = 1;\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            dp[i + 1][j + 2] += dp[i][j];\n            dp[i + 1][j + 1] += dp[i][j];\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            ones[i + 2][j + 2] = dp[i][j];\n        }\n    }\n    ones[1][1] += 1;\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            if(i + j > n) continue;\n            twos[max(i, j)][i + j] += 1;\n\n        }\n    }\n    for(int j = 0; j <= n; j++){\n        for(int i = 1; i <= max(n, x); i++){\n            twos[i][j] += twos[i - 1][j];\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < n; j++){\n            if(j <= i){\n                rest[i][j] = progression(0, j, j + 1, -1);\n            }\n            else{\n                rest[i][j] = progression(j - i, j, i + 1, -1) + progression(max(0, j - 2 * i), j - (i + 1), 1, 1);\n            }\n        }\n    }\n    for(int j = 0; j < n; j++){\n        rest_total[0][j]  += choose(n, j);\n        for(int i = 1; i <= n; i++){\n            if(i > j) rest_total[i][j] = rest_total[i - 1][j];\n            else rest_total[i][j] = rest_total[i - 1][j] + choose(n, j - i) * (i + 1);\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            if(ones[i][j] == 0) continue;\n            int mx = min((x - j - 1) / 2, n - 1);\n            if(j % 2 == x % 2){\n                ans += ones[i][j] * rest_total[mx][n - i];\n            }\n            else{\n                ans += ones[i][j] * rest[mx][n - i];\n            }\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N, X;\nconst int MOD = 998244353;\nint C[3030][3030];\nint main(){\n  scanf(\"%d%d\", &N, &X);\n  C[0][0] = 1;\n  for(int i=1; i<=N; ++i)\n  {\n    C[i][0] = C[i][i] = 1;\n    for(int j=1; j<i; ++j)\n      C[i][j] = (C[i-1][j-1]+C[i-1][j])%MOD;\n  }\n  long long ans = 0;\n  \n  //case1 sum(a)<=X-1\n  for(int c12=0; c12<=N; ++c12)\n  {\n    for(int s12=c12; s12<=min(c12*2, X-1); ++s12)\n    {\n      //        -#c12, sum s12   interleave 0\n      ans += 1LL*C[c12][s12-c12]*C[N][c12];\n      ans %= MOD;\n    }\n  }\n  \n  //case 2 sum(a) == X-1+2k\n  \n  int cc[3030]; memset(cc, 0, sizeof cc);  \n  \n  for(int k=1; k<=N; ++k)\n  {\n    int qq = X-1-2*k;\n    if(qq>=0)\n    {\n      for(int c=(qq+1)/2; c<=qq; ++c)\n      {\n        if(c+2*k > N) break;\n        //printf(\"%d %d %d\\n\", k, c, qq);\n        cc[c+2*k] += C[c][qq-c];\n        cc[c+2*k] %= MOD;\n      }\n    }\n    else\n    {\n      //everything should be 2\n      if( ((X-1)+2*k) %2 != 0) break;\n      if( (X-1)+2*k > 2*N) break;\n        ans += C[N][ ((X-1)+2*k)/2];\n        ans %= MOD;\n    }\n  }\n  \n  for(int i=0; i<=N; ++i)\n  {\n    ans += 1LL*cc[i]*C[N][i];\n    ans %= MOD;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\n\n\nlong long dp[3010][6010] = {};\nlong long powing(long long a, long long b) {\n\tlong long ans = 1;\n\twhile (b != 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nlong long inv(long long now) {\n\treturn powing(now, MOD - 2);\n}\nlong long omote[20000];\nlong long gyaku[20000];\nlong long combination(long long a, long long b) {\n\tlong long ans = omote[a];\n\tans *= gyaku[b];\n\tans %= MOD;\n\tans *= gyaku[a - b];\n\tans %= MOD;\n\treturn ans;\n}\nlong long hype(long long a, long long b) {\n\treturn combination(a + b - 1, b);\n}\nint main(){\n\tint n, x;\n\tcin >> n >> x;\n\tomote[0] = 1;\n\tgyaku[0] = 1;\n\tfor (long long i = 1; i < 20000; ++i) {\n\t\tomote[i] = omote[i - 1] * i;\n\t\tomote[i] %= MOD;\n\t\tgyaku[i] = inv(omote[i]);\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int q = 0; q < x; ++q) {\n\t\t\tif (dp[i][q] == 0) continue;\n\t\t\tdp[i + 1][q + 1] += dp[i][q];\n\t\t\tdp[i + 1][q + 2] += dp[i][q];\n\t\t\tdp[i + 1][q + 1] %= MOD;\n\t\t\tdp[i + 1][q + 2] %= MOD;\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int q = 0; q < x; ++q) {\n\t\t\tif (dp[i][q] == 0) continue;\n\t\t\tans += dp[i][q] * hype(i+1, n - i);\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tif (x % 2 == 1) {\n\t\tfor (int i = (x + 1) / 2; i <= n; ++i) {\n\t\t\tans += hype(i + 1, n - i);\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tfor (int i = 1;; ++i) {\n\t\tlong long target = x - 1 - 2 * i;\n\t\tif (target <= 0) break;\n\t\tfor (int two = 0;; ++two) {\n\t\t\tlong long remaining = target - 2 * two;\n\t\t\tif (remaining <= 0) break;\n\t\t\tlong long cnt = i * 2 + two + remaining;\n\t\t\tif (cnt > n) continue;\n\t\t\tlong long hoge = hype(cnt + 1, n - cnt) * combination(two + remaining, two);\n\t\t\tans += hoge;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define mp make_pair\n\nvoid print(auto &a)\n{\n    for (auto s: a) cout<<s<<' ';\n    cout<<endl;\n}\n\nvoid get(vector<auto> &a)\n{\n    for (int i = 0; i<a.size(); i++) cin>>a[i];\n}\n\nconst int p = 998244353;\n\n\nint mul(int a, int b) {\n    return (1LL * a%p * b%p) % p;\n}\n\nint add(int a, int b) {\n    ll s = (a+b);\n    s = s%p;\n    if (s<0) s+=p; \n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\nvector<int> Z(string s)\n{\nint n = s.length();\nvector<int> z(n);\nint L = 0, R = 0;\nfor (int i = 1; i < n; i++) {\n  if (i > R) {\n    L = R = i;\n    while (R < n && s[R-L] == s[R]) R++;\n    z[i] = R-L; R--;\n  } else {\n    int k = i-L;\n    if (z[k] < R-i+1) z[i] = z[k];\n    else {\n      L = i;\n      while (R < n && s[R-L] == s[R]) R++;\n      z[i] = R-L; R--;\n    }\n  }\n}\nreturn z;\n}\n\nset<int> answer;\n\nbool check(vector<int> a, int q)\n{\n    int n = a.size();\n    //print(a);\n    //cout<<q<<' '<<n<<endl;\n    for (int i = 0; i+q<n; i++) {a[i+q-1] = (a[i+q-1]+a[i])%q; a[i]=0;}\n    //print(a);\n    for (int i = 0; i<n; i++) if (a[i]%q!=0) return 0;\n    return 1;\n    \n}\n\nvector<int> facs(3001);\nvector<int> invfacs(3001);\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<=3000; i++) facs[i] = mul(facs[i-1], i);\n    for (int i = 0; i<=3000; i++) invfacs[i] = inv(facs[i]);\n}\n\nint C(int n, int k)\n{\n    if (k>n||n<0||k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\nvector<vector<int>> dp(3001, vector<int>(3001));\n\nvoid init2()\n{\n    for (int i = 0; i<=3000; i++)\n    {\n        dp[i][0] = 1;\n        for (int j = 1; j<=i; j++) dp[i][j] = add(dp[i][j-1], C(i, j));\n    }\n}\n\n\n\nint n, x;\n\nint solve(int k)\n{\n    if (k*2<x) return po(2, k);\n    \n    int answer = 0;\n    for (int j = 0; j<=k; j++) if (k+j<x) answer+=C(k, j);\n    for (int t = x/2; t<k; t++)\n    {\n        if (2*t+1==x) {answer+=1; continue;}\n        int n1 = 2*t-k;\n        int s = x - 2*(k-t)-n1-1;\n        answer+=C(n1, s);\n        //cout<<k<<' '<<t<<' '<<n1<<' '<<s<<endl;\n    }\n    return answer;\n}\n\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    cin>>n>>x;\n    init();\n    init2();\n    \n    if (x==1) {cout<<po(2, n); return 0;}\n    if (x==2) {cout<<n+1; return 0;}\n    \n    int total = 0;\n    for (int i = 0; i<=n; i++)\n    {\n        //cout<<i<<endl;\n        //cout<<solve(i)<<endl;\n        total=add(total, mul(solve(i), C(n, i)));\n    }\n    cout<<total;\n\n\n\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 998244353;\nstruct mi {\n    int val;\n    explicit operator int() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator<<(ostream& os, const mi& a) { return os << a.val; }\n    friend bool operator==(const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator!=(const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator<(const mi& a, const mi& b) { return a.val < b.val; }\n    mi operator-() const { return mi(-val); }\n    mi& operator+=(const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator-=(const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator*=(const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    friend mi operator+(mi a, const mi& b) { return a += b; }\n    friend mi operator-(mi a, const mi& b) { return a -= b; }\n    friend mi operator*(mi a, const mi& b) { return a *= b; }\n    friend mi operator/(mi a, const mi& b) { return a /= b; }\n};\nconst int MAX = 3e3 + 5;\n\nmi fact[MAX];\nmi ifact[MAX];\nmi len[MAX];\nmi dp[MAX][MAX]; // length, sum\nmi ones[MAX][MAX]; // length, sum\nmi twos[MAX][MAX];// mx 2's, num used\nmi twos_total[MAX][MAX]; //mx 2's used at most in total, num used\nmi rest[MAX][MAX];// mx 2's, num total\nmi rest_total[MAX][MAX];\nmi po[MAX];\nmi prefix[MAX];\nmi up_prefix[MAX];\nmi choose(int a, int b){\n    if(b < 0) return 0;\n    if(a < b) return 0;\n    return fact[a] * ifact[b] * ifact[a - b];\n}\nmi sum_prefix(int l, int r){\n    return prefix[r] - (l == 0 ? 0 : prefix[l - 1]);\n}\nmi sum_up_prefix(int l, int r){\n    return up_prefix[r] - (l == 0 ? 0 : up_prefix[l - 1]);\n}\nmi progression(int l, int r, int st, int d){\n    return (sum_up_prefix(l, r) - sum_prefix(l, r) * l) * d + sum_prefix(l, r) * st;\n}\nint n, x;\nint main(){\n    fact[0] = 1; ifact[0] = 1; po[0] = 1;\n    for(int i = 1; i < MAX; i++) fact[i] = fact[i - 1] * i, ifact[i] = ifact[i - 1] / i, po[i] = po[i - 1] * 2;\n    ios_base :: sync_with_stdio(0); cin.tie(0);\n    cin >> n >> x;\n    prefix[0] = 1;\n    for(int i = 1; i <= n; i++){\n        prefix[i] = prefix[i - 1] + choose(n, i);\n        up_prefix[i] = up_prefix[i - 1] + choose(n, i) * i;\n    }\n    mi ans = 0;\n    if(x % 2 == 0){\n        for(int i = 0; i < x / 2; i++){\n            ans += choose(n, i);\n        }\n    }\n    else ans += po[n];\n    dp[0][0] = 1;\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            dp[i + 1][j + 2] += dp[i][j];\n            dp[i + 1][j + 1] += dp[i][j];\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            ones[i + 2][j + 2] = dp[i][j];\n        }\n    }\n    ones[1][1] += 1;\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= n; j++){\n            if(i + j > n) continue;\n            twos[max(i, j)][i + j] += 1;\n\n        }\n    }\n    for(int j = 0; j <= n; j++){\n        for(int i = 1; i <= max(n, x); i++){\n            twos[i][j] += twos[i - 1][j];\n        }\n    }\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j < n; j++){\n            if(j <= i){\n                rest[i][j] = progression(0, j, j + 1, -1);\n            }\n            else{\n                rest[i][j] = progression(j - i, j, i + 1, -1) + progression(max(0, j - 2 * i), j - (i + 1), max(1, 2 * i + 1 - j), 1);\n            }\n        }\n    }\n    for(int j = 0; j < n; j++){\n        rest_total[0][j]  += choose(n, j);\n        for(int i = 1; i <= n; i++){\n            if(i > j) rest_total[i][j] = rest_total[i - 1][j];\n            else rest_total[i][j] = rest_total[i - 1][j] + choose(n, j - i) * (i + 1);\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        for(int j = 0; j < x; j++){\n            if(ones[i][j] == 0) continue;\n            int mx = min((x - j - 1) / 2, n - 1);\n            if(j % 2 == x % 2){\n                ans += ones[i][j] * rest_total[mx][n - i];\n            }\n            else{\n                ans += ones[i][j] * rest[mx][n - i];\n            }\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD_CONST = 998244353;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\ntemplate <int size, long long param = MOD_CONST, bool preserve = false>\nclass CombinationTool {\n  vector<mint<param>> invs;\n\n public:\n  vector<mint<param>> kaijo;\n  vector<vector<mint<param>>> table;\n\n  constexpr CombinationTool() {\n    const int N = size;\n    if (preserve) {\n      table.resize(N + 5);\n      for (int i = 0; i < N + 5; i++) table[i].resize(i + 1);\n      for (int i = 0; i < N; i++) {\n        table[i][0] = 1;\n        table[i][i] = 1;\n      }\n      for (int i = 1; i < N + 5; i++)\n        for (int j = 1; j < i; j++)\n          table[i][j] = table[i - 1][j - 1] + table[i - 1][j];\n\n    } else {\n      // int N = size;\n      kaijo.resize(N + 5);\n      kaijo[0] = 1;\n      for (int i = 1; i < N + 5; i++) {\n        kaijo[i] = kaijo[i - 1] * i;\n        invs[i] = mint<param>(1) / kaijo[i];\n      }\n    }\n  }\n\n  // template <long long param, bool preserve>\n  mint<param> get(int n, int m) {\n    if (m < 0 || m > n) return mint<param>(0);\n    if (preserve) return table[n][m];\n    return kaijo[n] * invs[m] * invs[n - m];\n  }\n};\n\nmint<> dp[6005][3005];\nvoid solve(long long N, long long X) {\n  CombinationTool<3050, MOD_CONST, true> comb;\n\n  mint<> zero = 0;\n  // auto dp = exvector(zero, 2 * N + 5, N + 5);\n  for (int j = 0; j <= N + 1; j++) dp[0][j] = 0;\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<MOD_CONST, 1> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb.get(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb.get(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb.get(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#define rint register int\n#define LL long long\n#define P 998244353\n#define MAXN 3005\nusing namespace std;\n\nint n, x, ans, c[MAXN][MAXN];\n\ninline int add(int x, int y) {return x+y<P?x+y:x+y-P;}\ninline int sub(int x, int y) {return x<y?x-y+P:x-y;}\n\nint solve(int tot)\n{\n\tint ans=0;\n\tif(x&1 || 2*tot<x) ans=1;\n\tfor(rint i=tot; i<tot*2; ++i)\n\t{\n\t\tif(i>=x && (i-x)%2==0) continue;\n\t\tif(i<x) {ans=add(ans, c[tot][i-tot]); continue;}\n\t\tint temp=(i-x+1)/2;\n\t\tint resnum=i-temp*4, respos=tot-temp*2;\n\t\tif(temp*2<tot && resnum>=respos && resnum<=respos*2) ans=add(ans, c[respos][resnum-respos]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &x);\n\tc[0][0]=1;\n\tfor(rint i=1; i<=n; ++i)\n\t{\n\t\tc[i][0]=1;\n\t\tfor(rint j=1; j<=i; ++j) c[i][j]=add(c[i-1][j], c[i-1][j-1]);\n\t}\n\tfor(rint i=0; i<=n; ++i) ans=(ans+1LL*c[n][i]*solve(n-i))%P;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3e3 + 5;\nconst int P = 998244353;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint binom[MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint getans(int n, int x) {\n\tint ans = 0;\n\tif (2 * n < x || x % 2 == 1) ans = 1;\n\tfor (int i = n; i <= 2 * n - 1; i++) {\n\t\tif (i < x) update(ans, binom[n][i - n]);\n\t\telse {\n\t\t\tif ((i - x) % 2 == 0) continue;\n\t\t\tint cnt = (i - x + 1) / 2;\n\t\t\tif (2 * cnt >= n) continue;\n\t\t\tint rp = n - 2 * cnt, rs = i - 4 * cnt;\n\t\t\tif (rs >= rp && rs <= 2 * rp) update(ans, binom[rp][rs - rp]);\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tint n, x; read(n), read(x);\n\tfor (int i = 0; i <= n; i++) {\n\t\tbinom[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tbinom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % P;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\t\tupdate(ans, 1ll * binom[n][i] * getans(n - i, x) % P);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nll pas[6001][6001];\nll rpas[6002][6001];\nll dp[3001][6001];\nvoid init(int sz) {\n\trep(i, 2*sz+1) {\n\t\trep(j, 2*sz+1) {\n\t\t\tif (i == 0 || j == 0)pas[i][j] = 1;\n\t\t\telse pas[i][j] = (pas[i - 1][j] + pas[i][j - 1]) % mod;\n\t\t}\n\t}\n\trep(j, 2*sz+1) {\n\t\trep(i, 2*sz+1) {\n\t\t\trpas[i + 1][j] = (rpas[i][j] + pas[i][j]) % mod;\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\trep(i, sz) {\n\t\trep(j, 2 * i + 1) {\n\t\t\trep(k, 3) {\n\t\t\t\tdp[i + 1][j + k] += dp[i][j];\n\t\t\t\tif (dp[i + 1][j + k] >= mod)dp[i + 1][j + k] %= mod;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve() {\n\tint n, x; cin >> n >> x;\n\tinit(n);\n\tll ans = 0;\n\trep(i, x) {\n\t\tans += dp[n][i];\n\t\tif (ans >= mod)ans -= mod;\n\t}\n\t//cout << ans << endl;\n\t/*if (x % 2) {\n\t\tfor (int i = (x + 1) / 2; i <= n; i++) {\n\t\t\tans += pas[n - i][i];\n\t\t\tif (ans >= mod)ans -= mod;\n\t\t}\n\t}*/\n\t//cout << ans << endl;\n\trep1(k, n) {\n\t\tll csum = 0;\n\t\tif (x % 2 && 2 * k > x) {\n\t\t\tcsum++;\n\t\t}\n\t\trep1(j, n - 1) {\n\t\t\tif (x-k < 0)continue;\n\t\t\tif (2 * k - x - 2 * j < 0)continue;\n\t\t\tcsum += rpas[x-k][2 * k - x - 2 * j];\n\t\t\tif (csum >= mod)csum -= mod;\n\t\t}\n\t\tcsum = csum * pas[n-k][k] % mod;\n\t\tans += csum; if (ans >= mod)ans -= mod;\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=3e3+5;\nconst int MD=998244353;\nint fac[N],inv[N];\nint f[N][N<<1];\nvoid init() {\n\tfac[0]=inv[0]=fac[1]=inv[1]=1;\n\tfor(int i=2;i<N;i++) fac[i]=1LL*fac[i-1]*i%MD,inv[i]=1LL*(MD-MD/i)*inv[MD%i]%MD;\n\tfor(int i=2;i<N;i++) inv[i]=1LL*inv[i]*inv[i-1]%MD;\n}\nint C(int n,int m) {return 1LL*fac[n]*inv[m]%MD*inv[n-m]%MD;}\nint add(int &x,int y) {\n\tx+=y;\n\tif(x>=MD) x-=MD;\n}\nint main() {\n\tinit();\n\tint n,x;\n\tscanf(\"%d%d\",&n,&x);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=x;j++) {\n\t\t\tadd(f[i][j],f[i-1][j-1]);\n\t\t\tif(j>1) add(f[i][j],f[i-1][j-2]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=n;i++) {\n\t\tint s=0;\n\t\tfor(int j=0;j<x-1;j++) add(s,f[i][j]);\n\t\tfor(int j=0;j<=i;j++) {\n\t\t\tif(i-j<=j&&x-1-2*(i-j)>=0) add(s,f[j-(i-j)][x-1-2*(i-j)]);\n\t\t\telse if(i-j>j&&j*2==x-1) add(s,1);\n\t\t}\n\t\tadd(ans,1LL*C(n,i)*s%MD);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=3005,INF=1<<30;\nll cnt[MAX][MAX];\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    int N,X;cin>>N>>X;\n    ll sum=0;\n    \n    for(int i=0;i<X;i++){\n        for(int j=0;j<=N;j++){\n            if(i<j) continue;\n            \n            int rem=i-j;\n            cnt[i][j]=comb(j,rem);\n            \n            sum+=cnt[i][j]*comb(N,j);\n            sum%=mod;\n        }\n    }\n    \n    for(int i=X+1;i<=2*N;i+=2){\n        if(i<4) continue;\n        int rd=(i-(X-1))*2;\n        if(i-rd<0){\n            if(X%2==1){\n                int c=(i+1)/2;\n                sum+=comb(N,c);\n                sum%=mod;\n            }\n        }else{\n            for(int j=0;j+rd/2<=N;j++){\n                sum+=cnt[i-rd][j]*comb(N,j+rd/2);\n                sum%=mod;\n            }\n        }\n    }\n    \n    cout<<sum<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n\tModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\tbool operator<(const ModInt &x)const{return a<x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{\n\t\tif(n<0||k<0||k>n)return 0;\n\t\treturn facts[n]*finvs[k]*finvs[n-k];\n\t}\n\tinline Mint perm(int n,int k)const{\n\t\tif(n<0||k<0||k>n)return 0;\n\t\treturn facts[n]*finvs[n-k];\n\t} \n};\nModIntTable<mint,19>mt;\n\nint N,X;\nmint res[3333];\nvoid calc(){\n\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=0;j<X;j++){\n\t\t\tres[i]+=mt.binom(i,j-i);\n\t\t}\n\t}\n\n\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=1;j*2<=i;j++){\n\t\t\tint m=X-1-2*j;\n\t\t\tint num=i-2*j;\n\t\t\tif(m<0)continue;\n\t\t\tres[i]+=mt.binom(num,m-num);\n\t\t}\n\t}\n\n\tif(X&1){\n\t\tfor(int i=X;i<=N;i++){\n\t\t\tres[i]+=1;\n\t\t}\n\t}\n}\n\nsigned main(){\n\tcin>>N>>X;\n\n\tcalc();\n\n\tmint ans;\n\tfor(int i=0;i<=N;i++)ans+=res[i]*mt.binom(N,i);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 998244353;\nlong long mul(long long a, long long b, const long long MOD) {\n  return b ? (mul(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow(long long a, long long b, const long long MOD) {\n  return (b ? bpow(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv(long long a, const long long MOD) {\n  return bpow(a, MOD - 2, MOD);\n}\nvector<long long> MODS = {998244353};\ntemplate <int kind = 0, int fast = 0>\nclass mint {\n public:\n  long long v;\n\n  mint() : v(0) {}\n  // mint(long long);\n  inline mint(long long v)\n      : v(fast == 0 ? (v < 0 ? (v % MODS[kind] + MODS[kind]) % MODS[kind]\n                             : (v >= MODS[kind] ? v % MODS[kind] : v))\n                    : (v)) {}\n  long long get_mod() { return MODS[kind]; }\n  long long get_val() { return v; }\n  void take_mod() { v %= MODS[kind]; }\n};\n\ntemplate <int kind, int fast>\nostream& operator<<(ostream& os, const mint<kind, fast>& x) {\n  return os << (x.v % MODS[kind] + MODS[kind]) % MODS[kind];\n}\n\ntemplate <int kind, int fast, int fast2>\nbool operator==(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, mint<kind, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, mint<kind> b) {\n  return a = a.v - b.v;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * b.v;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, mint<kind> b) {\n  return a = a.v * inv(b.v, a.get_mod());\n}\ntemplate <int kind, int fast, int fast2>\nmint<kind, fast> operator+(mint<kind, fast> a, mint<kind, fast2> b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, mint<kind> b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, mint<kind> b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, mint<kind> b) {\n  return a /= b;\n}\ntemplate <int kind, int fast>\nmint<kind, fast>& operator+=(mint<kind, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <int kind>\nmint<kind>& operator-=(mint<kind>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <int kind>\nmint<kind>& operator*=(mint<kind>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <int kind>\nmint<kind>& operator/=(mint<kind>& a, long long b) {\n  return a = a.v * inv(b, a.get_mod());\n}\ntemplate <int kind, int fast>\nmint<kind, fast> operator+(mint<kind> a, long long b) {\n  return a += b;\n}\ntemplate <int kind>\nmint<kind> operator-(mint<kind> a, long long b) {\n  return a -= b;\n}\ntemplate <int kind>\nmint<kind> operator*(mint<kind> a, long long b) {\n  return a *= b;\n}\ntemplate <int kind>\nmint<kind> operator/(mint<kind> a, long long b) {\n  return a /= b;\n};\n\nvector<vector<mint<>>> comb_table;\n\nmint<> comb(LL N, LL K) {\n  if (N < K) return 0;\n  if (K < 0) return 0;\n  return comb_table[N][K];\n}\n\nvoid init(int N) {\n  comb_table.resize(N + 6);\n  for (int i = 0; i <= N; i++) {\n    comb_table[i].resize(i + 1);\n    comb_table[i][0] = 1;\n    comb_table[i][i] = 1;\n\n    for (int j = 1; j < i; j++) {\n      comb_table[i][j] = comb_table[i - 1][j - 1] + comb_table[i - 1][j];\n    }\n  }\n}\n\nvoid solve(long long N, long long X) {\n  init(N);\n  mint<> zero = 0;\n  // auto dp = exvector(zero, 2 * N + 5, N + 5);\n  mint<> dp[6005][3005];\n  dp[0][1] = 1;\n\n  for (int i = 1; i <= 2 * N; i++) {\n    for (int j = 0; j <= N + 1; j++) {\n      dp[i][j] = 0;\n      if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n      if (i > 1 && j > 0) dp[i][j] += dp[i - 2][j - 1];\n      // dp[i][j] %= MOD;\n    }\n  }\n  // in_1.txt\n\n  mint<0, 1> ans = 0;\n  for (int i = 0; i < X - 1; i++) {\n    for (int k = 0; k <= N + 1; k++)\n      ans += dp[i][k] * comb(N, k - 1);  // % MOD ;\n  }\n  for (int i = 0; i <= N; i++) {\n    for (int k = 0; k <= N + 1; k++) {\n      if (X - 1 - i * 2 >= 0)\n        ans += dp[X - 1 - i * 2][k] * comb(N, k - 1 + i * 2);  // % MOD;\n    }\n  }\n  if (X % 2 == 1) {\n    for (int i = X; i <= N; i++) {\n      int hako = i + 1;\n      int nokori = N - i;\n      ans += comb(N, nokori);\n    }\n  }\n  // ans %= MOD;\n\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long X;\n  scanf(\"%lld\", &X);\n  solve(N, X);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\nbool f (ull p) {\n\tfor (sll i = 0; i <= n; i++) {\n\t\tif (sdiff(a[i], 0) % p) return false;\n\t}\n\treturn true;\n}\n\null dq[2][10000];\n\null dp[4][10000];\n\null frac[N_MAX], invf[N_MAX];\n\null ncr (ull n, ull r) {\n\treturn frac[n] * (invf[r] * invf[n - r] % FOD) % FOD;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfrac[0] = invf[0] = 1;\n\tfor (i = 1; i <= n * 2; i++) {\n\t\tfrac[i] = (frac[i - 1] * i) % FOD;\n\t\tinvf[i] = divide(invf[i - 1], i, FOD);\n\t}\n\n\tif (k == 1) {\n\t\tprintf(\"%llu\\n\", bitpow(2, n, FOD));\n\t\treturn 0;\n\t}\n\n\tdq[0][0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tull curr = (i % 2);\n\t\tull prev = (1 - curr);\n\n\t\tfor (j = 0; j < k; j++) {\n\t\t\tdq[curr][j] = 0;\n\t\t\tfor (ki = 0; ki < 3; ki++) {\n\t\t\t\tif (ki <= j) dq[curr][j] += dq[prev][j - ki];\n\t\t\t}\n\t\t\tdq[curr][j] %= FOD;\n\t\t}\n\t}\n\tfor (i = 0; i < k - 1; i++) {\n\t\tresult += dq[n % 2][i];\n\t\tresult %= FOD;\n\t}\n\t// printf(\"%llu\\n\", result);\n\n\tfor (i = 1; i <= n; i++) {\n\t\titem = 0;\n\t\tfor (j = 0; j * 2 <= i; j++) {\n\t\t\tif (j * 2 > k - 1) break;\n\n\t\t\tull rN = (k - 1) - j * 2, rR = i - j * 2;\n\n\t\t\tif (rN >= rR && rN <= rR * 2) item += ncr(rR, rN - rR);\n\t\t}\n\t\titem %= FOD;\n\t\tresult += item * ncr(n, i) % FOD;\n\t\tresult %= FOD;\n\t}\n\t// printf(\"%llu\\n\", result);\n\n\tif (k % 2) {\n\t\tfor (i = k; i <= n; i++) {\n\t\t\tresult += ncr(n, i);\n\t\t}\n\t\tresult %= FOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\tputs(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\tputs(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\t// for (i = n; i >= 0; i--) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \t// scanf(\"%lld\", &c[i]);\n\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < k; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &d[i]);\n\t// \td[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p 998244353\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a * power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\nint *fact, *fact_inv;\n\nint comb(int N, int k){\n\tif(k < 0 || N < k){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn MOD(fact[N] * MOD(fact_inv[k] * fact_inv[N - k]));\n\t}\n}\n\nsigned main(){\n\tint N, X, i, j, K, x;\n\tscanf(\"%lld%lld\", &N, &X);\n\tint *pow2 = (int *)malloc(sizeof(int) * (N + 1));\n\tpow2[0] = 1;\n\tfor(i = 1; i <= N; i++){\n\t\tpow2[i] = MOD(2 * pow2[i - 1]);\n\t}\n\tfact = (int *)malloc(sizeof(int) * (N + 1));\n\tfact[0] = 1;\n\tfor(i = 1; i <= N; i++){\n\t\tfact[i] = MOD(fact[i - 1] * i);\n\t}\n\tfact_inv = (int *)malloc(sizeof(int) * (N + 1));\n\tfor(i = 0; i <= N; i++){\n\t\tfact_inv[i] = inverse(fact[i]);\n\t}\n\tint ans = 0, now;\n\tfor(K = 0; K <= N; K++){\n//\t\tprintf(\"K = %lld\\n\", K);\n\t\tnow = 0;\n\t\tfor(x = K; x < X && x <= 2 * K; x++){\n\t\t\tnow = MOD(now + comb(K, x - K));\n\t\t}\n//\t\tprintf(\"now1 = %lld\\n\", now);\n\t\tif(X % 2 == 1 && K >= X - 1 && 2 * K > X){\n\t\t\tnow++;\n\t\t}\n\t\tfor(j = 1; 2 * j < K; j++){\n\t\t\tnow = MOD(now + comb(K - 2 * j, X - 1 - K));\n\t\t}\n//\t\tprintf(\"now = %lld\\n\", now);\n\t\tans = MOD(ans + comb(N, K) * now);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n//#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nll n,x;\nll dp1[3010][6010];//dp[n][s]=0,1,2をn個でs\nll dp2[3010][6010];//dp[n][s]=1,2をn個でs\nll choose[3010][3010];\nint main(){\n\tscanf(\"%lld %lld\",&n,&x);\n\tdp1[0][0]=1;\n\tdp2[0][0]=1;\n\tfor(int i=0;i<n;i++)for(int j=0;j<=2*i;j++){\n\t\tfor(int k=0;k<3;k++)dp1[i+1][j+k]=(dp1[i+1][j+k]+dp1[i][j])%MOD;\n\t\tfor(int k=1;k<3;k++)dp2[i+1][j+k]=(dp2[i+1][j+k]+dp2[i][j])%MOD;\n\t}\n\t\n\tchoose[0][0]=1;\n\tfor(int i=1;i<3005;i++){\n\t\tchoose[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)choose[i][j]=(choose[i-1][j-1]+choose[i-1][j])%MOD;\n\t}\n\t\n\tll ans=0;\n\tfor(int i=0;i<x;i++)ans=(ans+dp1[n][i])%MOD;\n//\tprintf(\"%lld\\n\",ans);\n\t\n\t//x-1-iをn-i個以下の1,2で埋める\n\tfor(int i=2;;i+=2){\n\t\tif(x-i-1<0||n-i<0)break;\n\t\tfor(int j=0;j<=n-i;j++)ans=(ans+dp2[j][x-i-1]*choose[n][n-i-j])%MOD;\n\t}\n\t\n\tif(x%2==1){\n\t\tfor(int i=x;i<=n;i++)ans=(ans+choose[n][i])%MOD;\n\t}\n\t\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190820\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#include<assert.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 998244353\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\nvoid getperm(int a[],int n){\n  int i,p;\n  for(i=0;i<n;i++){\n    a[i]=i;\n  }\n  for(i=n-1;i>=1;i--){\n    p=rand()%(i+1);\n    swap(&a[p],&a[i]);\n  }\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(int a[],int n){\n  int i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[1048576];\nlong long invfact[1048576];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<1048576;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[1048575]=modular_inverse(factorial[1048575]);\n  for(i=1048574;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  if(k<0 || n<k){return 0;}\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\nint main(void){\n  cfact();\n  long long n,x,i,j,r=0,k,w;\n  scanf(\"%lld%lld\",&n,&x);\n  for(i=0;i<=n;i++){//1\n    for(j=0;i+j<=n;j++){//2\n      //printf(\"%lld %lld : %lld\\n\",i,j,r);\n      k=calcnCr(n,i+j);\n      if((i+2*j)<x){\n        k*=calcnCr(i+j,i);\n        r+=k;r%=mod;\n        continue;\n      }\n      if((i+2*j)%2 == x%2){continue;}\n      w=(i+2*j)-x;\n      w++;\n      if(w>=i+j){\n        if(i==0){r+=k;r%=mod;}\n        continue;\n      }\n      k*=calcnCr(i+j-w,j-w);\n      r+=k;r%=mod;\n    }\n  }\n  printf(\"%lld\\n\",r);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nconst i32 mod = 998244353;\n\ni32 inv (i32 a) {\n  i32 t = 1;\n  while (a > 1) {\n    t = (i64) t * (mod - mod / a) % mod;\n    a = mod % a;\n  }\n  return t;\n}\n\ni32 *fact = NULL;\ni32 *iFact = NULL;\nvoid init_fact (const i32 n) {\n  fact = (i32 *) calloc (n + 1, sizeof (i32));\n  fact[0] = 1;\n  for (i32 i = 1; i <= n; ++i) {\n    fact[i] = (i64) i * fact[i - 1] % mod;\n  }\n  iFact = (i32 *) calloc (n + 1, sizeof (i32));\n  iFact[n] = inv (fact[n]);\n  for (i32 i = n - 1; i >= 0; --i) {\n    iFact[i] = (i64) (i + 1) * iFact[i + 1] % mod;\n  }\n}\n\ni32 comb (i32 n, i32 k) {\n  if (!(0 <= k && k <= n)) return 0;\n  return (i64) fact[n] * iFact[k] % mod * iFact[n - k] % mod;\n}\n\nvoid run (void) {\n  i32 n, x;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &x);\n  init_fact (n);\n  i64 ans = 0;\n  for (i32 i = 0; i < x; ++i) {\n    for (i32 j = 0; 2 * j <= i; ++j) {\n      i32 k = i - 2 * j;\n      if (j + k > n) continue;\n      i64 way = (i64) comb (n, j) * comb (n - j, k) % mod;\n      ans += way;\n    }\n  }\n  for (i32 i = x + 1; i < 2 * x; i += 2) {\n    for (i32 j = i / 2; j >= 0; --j) {\n      i32 k = i - 2 * j;\n      if (j + k > n) break;\n      i32 y = (i - x) / 2;\n      i64 way = (i64) comb (n, j + k) * comb (j + k - 2 * y - 2, k) % mod;\n      ans += way;\n    }\n  }\n  if (x % 2 == 1) {\n    for (i32 i = 2 * x; i <= 2 * n; i += 2) {\n      ans += comb (n, i / 2);\n    }\n  }\n  printf (\"%\" PRIi64 \"\\n\", ans % mod);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\n     \n    import java.util.*;\n    import java.lang.*;\n    import java.io.*;\n     \n   \n   public class Main\n    {\n    \tpublic static void main (String[] args) throws java.lang.Exception\n    \t{\n    \t Scanner s = new Scanner(System.in);\n       int len = s.nextInt();\n       int target = s.nextInt();\n       List<Integer> l = new ArrayList<Integer>();\n       List<List<Integer>> result = new ArrayList<>();\n       getSeq(l,result,len,target,0,0);\n       System.out.print(result.size());\n     }\n      static void getSeq(List<Integer> l, List<List<Integer>> result, int len, int target, int sum, int srtlen){\n     \n     int revsum =0;\n        if(srtlen > len){\n        \treturn;\n        }\n     \n        if(sum==target){\n         return; \n        }\n     \n     for(int j=l.size()-1; j>=0; j--){\n     \trevsum = revsum + l.get(j);\n     \tif(revsum == target){\n     \t\treturn;\n     \t}\n     }\n        if(srtlen ==len){\n         \n          result.add(new ArrayList<>(l));\n          return;\n          \n        }\n     \n        for(int i=0; i<=2; i++){\n          l.add(i);\n          getSeq(l,result,len,target, i+sum,srtlen + 1);\n          l.remove(l.size()-1);\n        }\n     \n      }\n    }"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Random;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic long f(int x, int[] a)\n\t{\n\t\tlong v = 0;\n\t\tfor(int w : a){\n\t\t\tv = v * x + w;\n\t\t}\n\t\treturn v;\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n+1);\n\t\t\n\t\tlong v = 0;\n\t\tfor(int i = 0;;i++){\n\t\t\tv = f(i, a);\n\t\t\tif(v != 0)break;\n\t\t}\n\t\tlong x = Math.abs(v);\n\t\tList<Long> list = new ArrayList<>();\n\t\tfor(long i = 1;i*i <= x;i++){\n\t\t\tif(x % i == 0){\n\t\t\t\tif(ok(i, a)){\n\t\t\t\t\tlist.add(i);\n\t\t\t\t}\n\t\t\t\tif((long)i*i < x){\n\t\t\t\t\tif(ok(x/i, a)){\n\t\t\t\t\t\tlist.add(x/i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(list);\n\t\tfor(long w : list){\n\t\t\tout.println(w);\n\t\t}\n\t}\n\t\n\tstatic boolean ok(long mod, int[] a)\n\t{\n\t\tif(!BigInteger.valueOf(mod).isProbablePrime(20)){\n\t\t\treturn false;\n\t\t}\n\t\tRandom gen = new Random();\n\t\tfor(int oo = 1;oo < 1000;oo++){\n\t\t\tint x = gen.nextInt((int)mod);\n\t\t\tlong t = 0;\n\t\t\tfor(int v : a){\n\t\t\t\tt = t * x + v;\n\t\t\t\tt %= mod;\n\t\t\t}\n\t\t\tif(t != 0)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "    /* package whatever; // don't place package name! */\n     \n    import java.util.*;\n    import java.lang.*;\n    import java.io.*;\n     \n    /* Name of the class has to be \"Main\" only if the class is public. */\n   public class Main\n    {\n    \tpublic static void main (String[] args) throws java.lang.Exception\n    \t{\n    \t Scanner s = new Scanner(System.in);\n       int len = s.nextInt();\n       int target = s.nextInt();\n       List<Integer> l = new ArrayList<Integer>();\n       List<List<Integer>> result = new ArrayList<>();\n       getSeq(l,result,len,target,0,0);\n       System.out.print(result.size());\n     }\n      static void getSeq(List<Integer> l, List<List<Integer>> result, int len, int target, int sum, int srtlen){\n     \n     int revsum =0;\n       \n     \n        if(sum==target){\n         return; \n        }\n     \n     for(int j=l.size()-1; j>=0; j--){\n     \trevsum = revsum + l.get(j);\n     \tif(revsum == target){\n     \t\treturn;\n     \t}\n     }\n        if(srtlen ==len){\n         \n         \n          result.add(new ArrayList<>(l));\n          return;\n          \n        }\n     \n        for(int i=0; i<=2 && srtlen<=len; i++){\n          l.add(i);\n          getSeq(l,result,len,target, i+sum,srtlen + 1);\n          l.remove(l.size()-1);\n        }\n     \n      }\n    }"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 998244353;\n\t\tint n = ni(), K = ni();\n\t\tlong ans = 0;\n\t\t{\n\t\t\tlong[] dp = new long[K];\n\t\t\tdp[0] = 1;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlong[] ndp = new long[K];\n\t\t\t\tfor(int j = 0;j < K;j++){\n\t\t\t\t\tfor(int k = 0;k < 3 && j+k < K;k++){\n\t\t\t\t\t\tndp[j+k] += dp[j];\n\t\t\t\t\t\tndp[j+k] %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp = ndp;\n\t\t\t}\n\t\t\tfor(long v : dp)ans += v;\n\t\t}\n//\t\ttr(ans);\n\t\t// 2   2\n\t\tint[][] fif = enumFIF(10000, mod);\n\t\tfor(int s = K+1;s < 2*K-1;s+=2){\n\t\t\tint u = s-K;\n\t\t\tif(u % 2 == 1)u++;\n\t\t\tint two = u/2 + (s-(K-1)) / 2;\n\t\t\t// s-two*2\n\t\t\tfor(int i = (s-two*2+1)/2;i <= s-two*2;i++){\n//\t\t\t\ttr(i, s-two*2, two, s, C(i, s-two*2-i, mod, fif) * C(n, i+two, mod, fif));\n\t\t\t\tans += C(i, s-two*2-i, mod, fif) * C(n, i+two, mod, fif);\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t}\n\t\tif(K % 2 == 1){\n\t\t\tans += pow(2, n, mod);\n\t\t\t{\n\t\t\t\tlong[] dp = new long[K];\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tlong[] ndp = new long[K];\n\t\t\t\t\tfor(int j = 0;j < K;j++){\n\t\t\t\t\t\tfor(int k = 0;k < 2 && j+k < K;k++){\n\t\t\t\t\t\t\tndp[j+k] += dp[j];\n\t\t\t\t\t\t\tndp[j+k] %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp = ndp;\n\t\t\t\t}\n\t\t\t\tfor(long v : dp)ans -= v;\n\t\t\t}\n\t\t}\n\t\tans %= mod;\n\t\tif(ans < 0)ans += mod;\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DBannedX solver = new DBannedX();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DBannedX {\n        Debug debug = new Debug(false);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int x = in.readInt();\n\n            Modular mod = new Modular(998244353);\n            Power pow = new Power(mod);\n            Combination comb = new Combination(n, pow);\n            int[] occupy = new int[n + 1];\n            //S < x\n            for (int i = 0; i <= n; i++) {\n                int two = x - 1 - i;\n                for (int j = 0; j < two; j++) {\n                    occupy[i] = mod.plus(occupy[i], comb.combination(i, j));\n                }\n            }\n            //S >= x\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= i; j++) {\n                    int k = i - j;\n                    int two = x - 1 - j;\n                    if (two < 0) {\n                        continue;\n                    }\n                    if (k >= j) {\n                        //all two\n                        if (j == two) {\n                            occupy[i] = mod.plus(occupy[i], 1);\n                        }\n                    } else {\n                        if (two >= k) {\n                            occupy[i] = mod.plus(occupy[i], comb.combination(j - k, two - k));\n                        }\n                    }\n                }\n            }\n            debug.debug(\"occupy\", occupy);\n\n            int ans = 0;\n            for (int i = 0; i <= n; i++) {\n                int contrib = occupy[i];\n                contrib = mod.mul(contrib, comb.combination(n, i));\n                ans = mod.plus(ans, contrib);\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static interface IntCombination {\n    }\n\n    static class ExtGCD {\n        public static int extGCD(int a, int b, int[] xy) {\n            if (a >= b) {\n                return extGCD0(a, b, xy);\n            }\n            int ans = extGCD0(b, a, xy);\n            SequenceUtils.swap(xy, 0, 1);\n            return ans;\n        }\n\n        private static int extGCD0(int a, int b, int[] xy) {\n            if (b == 0) {\n                xy[0] = 1;\n                xy[1] = 0;\n                return a;\n            }\n            int ans = extGCD0(b, a % b, xy);\n            int x = xy[0];\n            int y = xy[1];\n            xy[0] = y;\n            xy[1] = x - a / b * y;\n            return ans;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        static IntExtGCDObject extGCD = new IntExtGCDObject();\n        final Modular modular;\n\n        public Modular getModular() {\n            return modular;\n        }\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int inverse(int x) {\n            int ans = inverseExtGCD(x);\n//        if(modular.mul(ans, x) != 1){\n//            throw new IllegalStateException();\n//        }\n            return ans;\n        }\n\n        public int inverseExtGCD(int x) {\n            if (extGCD.extgcd(x, modular.getMod()) != 1) {\n                throw new IllegalArgumentException();\n            }\n            return modular.valueOf(extGCD.getX());\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class IntExtGCDObject {\n        private int[] xy = new int[2];\n\n        public int extgcd(int a, int b) {\n            return ExtGCD.extGCD(a, b, xy);\n        }\n\n        public int getX() {\n            return xy[0];\n        }\n\n    }\n\n    static class Combination implements IntCombination {\n        final Factorial factorial;\n        final Modular modular;\n\n        public Combination(Factorial factorial) {\n            this.factorial = factorial;\n            this.modular = factorial.getMod();\n        }\n\n        public Combination(int limit, Power pow) {\n            this(new Factorial(limit, pow));\n        }\n\n        public int combination(int m, int n) {\n            if (n > m || n < 0) {\n                return 0;\n            }\n            return modular.mul(modular.mul(factorial.fact(m), factorial.invFact(n)), factorial.invFact(m - n));\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        Modular mod;\n\n        public Modular getMod() {\n            return mod;\n        }\n\n        public Factorial(int[] fact, int[] inv, Power pow) {\n            this.mod = pow.getModular();\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            for (int i = 1; i < fact.length; i++) {\n                fact[i] = i;\n                fact[i] = mod.mul(fact[i], fact[i - 1]);\n            }\n            inv[inv.length - 1] = pow.inverse(fact[inv.length - 1]);\n            for (int i = inv.length - 2; i >= 1; i--) {\n                inv[i] = mod.mul(inv[i + 1], i + 1);\n            }\n        }\n\n        public Factorial(int limit, Power pow) {\n            this(new int[limit + 1], new int[limit + 1], pow);\n        }\n\n        public int fact(int n) {\n            return fact[n];\n        }\n\n        public int invFact(int n) {\n            return inv[n];\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static class SequenceUtils {\n        public static void swap(int[] data, int i, int j) {\n            int tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Sc_out;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        //const int MOD = 1000000007;\n        const int MOD = 998244353;\n\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 2;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            int N, X;\n            Cin.Input(out N, out X);\n            if (X == 1) { OutL(Modpow(2, N).value);return; }\n            if (N == 1) { OutL(X <= 2 ? 2 : 3);return; }\n            var dp = new long[N][,];\n            for(var i = 0; i < N; i++)\n            {\n                dp[i] = new long[X, 2];\n            }\n            dp[0][1, 0] = 1;\n            if (X - 1 >= 2) dp[0][2, 1] = 1;\n            for(var i = 1; i < N; i++)\n            {\n                for(var j = 0; j <= 2 * i; j++)\n                {\n                    if (j + 1 < X)\n                    {\n                        dp[i][j + 1, 1] += dp[i - 1][j, 1];\n                        dp[i][j + 1, 1] %= MOD;\n\n                        dp[i][j + 1, 0] += dp[i - 1][j, 0];\n                        dp[i][j + 1, 0] %= MOD;\n                    }\n                    if (j + 2 < X)\n                    {\n                        dp[i][j + 2, 1] += dp[i - 1][j, 1];\n                        dp[i][j + 2, 1] %= MOD;\n\n                        dp[i][j + 2, 0] += dp[i - 1][j, 0];\n                        dp[i][j + 2, 0] %= MOD;\n                    }\n                }\n            }\n            var num = new long[N + 2];\n            for(var i = 0; i < N; i++)\n            {\n                for(var j = 0; j < X; j++)\n                {\n                    num[i + 1] += dp[i][j, 0] + dp[i][j, 1];\n                    num[i + 1] %= MOD;\n\n                    num[i + 2] = (num[i + 2] - dp[i][j, 0] - dp[i][j, 1] + MOD + MOD) % MOD;\n\n                    if ((X - 1 - j) % 2 == 0)\n                    {\n                        int k = (X - 1 - j) / 2;\n                        if (i + 1 + k >= N) continue;\n\n                        int res = Min(k, N - (i + 1 + k));\n                        num[i + 1 + k + 1] += dp[i][j, 0];\n                        num[i + 1 + k + 1] %= MOD;\n\n                        if (i + 1 + k + res + 1 <= N)\n                        {\n                            num[i + 1 + k + res + 1] = (num[i + 1 + k + res + 1] - dp[i][j, 0] + MOD) % MOD;\n                        }\n                    }\n                }\n            }\n            for (var i = 1; i <= N; i++) { num[i] += num[i - 1]; num[i] %= MOD; }\n            num[0]++;\n            if (X % 2 == 1) { for (var i = (X + 1) / 2; i <= N; i++) num[i]++; }\n            //Out_Sep(num);\n            ModInt ans = 0;\n            for (var i = 0; i <= N; i++) ans += num[i] * nCr(N, i);\n            OutL(ans.value);\n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n    }\n    struct ModInt\n    {\n        public long value;\n        //private const int MOD = 1000000007;\n        private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Sc_out\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Sc_out;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        //const int MOD = 1000000007;\n        const int MOD = 998244353;\n\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 2;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            int N, X;\n            Cin.Input(out N, out X);\n            if (X == 1) { OutL(Modpow(2, N).value);return; }\n            if (N == 1) { OutL(X <= 2 ? 2 : 3);return; }\n            var dp = new long[N][,];\n            for(var i = 0; i < N; i++)\n            {\n                dp[i] = new long[X, 2];\n            }\n            dp[0][1, 0] = 1;\n            dp[0][2, 1] = 1;\n            for(var i = 1; i < N; i++)\n            {\n                for(var j = 0; j <= 2 * i; j++)\n                {\n                    if (j + 1 < X)\n                    {\n                        dp[i][j + 1, 1] += dp[i - 1][j, 1];\n                        dp[i][j + 1, 1] %= MOD;\n\n                        dp[i][j + 1, 0] += dp[i - 1][j, 0];\n                        dp[i][j + 1, 0] %= MOD;\n                    }\n                    if (j + 2 < X)\n                    {\n                        dp[i][j + 2, 1] += dp[i - 1][j, 1];\n                        dp[i][j + 2, 1] %= MOD;\n\n                        dp[i][j + 2, 0] += dp[i - 1][j, 0];\n                        dp[i][j + 2, 0] %= MOD;\n                    }\n                }\n            }\n            var num = new long[N + 2];\n            for(var i = 0; i < N; i++)\n            {\n                for(var j = 0; j < X; j++)\n                {\n                    num[i + 1] += dp[i][j, 0] + dp[i][j, 1];\n                    num[i + 1] %= MOD;\n\n                    num[i + 2] = (num[i + 2] - dp[i][j, 0] - dp[i][j, 1] + MOD + MOD) % MOD;\n\n                    if ((X - 1 - j) % 2 == 0)\n                    {\n                        int k = (X - 1 - j) / 2;\n                        if (i + 1 + k >= N) continue;\n\n                        int res = Min(k, N - (i + 1 + k));\n                        num[i + 1 + k + 1] += dp[i][j, 0];\n                        num[i + 1 + k + 1] %= MOD;\n\n                        if (i + 1 + k + res + 1 <= N)\n                        {\n                            num[i + 1 + k + res + 1] = (num[i + 1 + k + res + 1] - dp[i][j, 0] + MOD) % MOD;\n                        }\n                    }\n                }\n            }\n            for (var i = 1; i <= N; i++) { num[i] += num[i - 1]; num[i] %= MOD; }\n            num[0]++;\n            if (X % 2 == 1) { for (var i = (X + 1) / 2; i <= N; i++) num[i]++; }\n            //Out_Sep(num);\n            ModInt ans = 0;\n            for (var i = 0; i <= N; i++) ans += num[i] * nCr(N, i);\n            OutL(ans.value);\n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n    }\n    struct ModInt\n    {\n        public long value;\n        //private const int MOD = 1000000007;\n        private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Sc_out\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing Number = System.Int32;\nusing System.Numerics;\nusing static System.Numerics.BigInteger;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random(0);\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar X = ri;\n\t\t\tModInt ans = 0;\n\t\t\tvar val = new ModInt[n + 1];\n\t\t\tvar binom = new BinomialCoefficient(n + 5);\n\n\t\t\t//総和が X 未満\n\t\t\t{\n\t\t\t\tvar dp = new ModInt[X + 5];\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tfor (int j = X; j >= 0; j--) {\n\t\t\t\t\t\tdp[j + 2] += dp[j];\n\t\t\t\t\t\tdp[j + 1] += dp[j];\n\t\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < X; j++) ans += dp[j];\n\n\t\t\t}\n\t\t\t//総和が X 以上で 全部偶数かつ X が奇数\n\t\t\tif (X % 2 == 1) {\n\t\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\t\tif (i * 2 > X) val[i] += 1;\n\t\t\t}\n\t\t\t//3. 以下の 3 つを満たすやつ\n\t\t\t//  - 一番左の 1 から一番右の 1 までの parity が X と異なる\n\t\t\t//  - 一番左の 2 から一番右の 2 までが X-1 以下\n\t\t\t//  - 一番右の 2 から一番左の 1 までが X-1 以下\n\t\t\t{\n\n\t\t\t\t//dp[i][j] = i 個まで 2 を端に追加でき、合計 j 個\n\t\t\t\tvar dp = Enumerate(n + 1, x => new ModInt[n + 2]);\n\t\t\t\tif (X % 2 != 1) dp[(X - 2) / 2][1] += 1;\n\t\t\t\tfor (int i = 2; i <= n; i++)\n\t\t\t\t\tfor (int j = i; j <= X; j++)\n\t\t\t\t\t\tif (j % 2 != X % 2) dp[(X - 1 - j) / 2][i] += binom[i - 2, j - i];\n\t\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tvar ndp = new ModInt[n + 2];\n\t\t\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\t\t\tndp[j] += dp[i][j];\n\t\t\t\t\t\t\tndp[Min(n + 1, j + i + 1)] -= dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\t\t\tndp[j + 1] += ndp[j];\n\t\t\t\t\t\tdp[i] = ndp;\n\t\t\t\t\t}\n\t\t\t\t\t// Debug.WriteLine(dp[i].AsJoinedString());\n\t\t\t\t\tfor (int j = 0; j <= n; j++) val[j] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//一番左の 1 から一番右の 1 までの parity が X と異なる\n\t\t\t//総和が X 未満\n\t\t\t{\n\t\t\t\tvar dp = new ModInt[X + 5];\n\t\t\t\tvar ep = new ModInt[X + 5];\n\t\t\t\tvar fp = new ModInt[X + 5];\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = X; j >= 0; j--) {\n\t\t\t\t\t\tdp[j + 2] += dp[j];\n\t\t\t\t\t\tep[j + 1] += dp[j];\n\t\t\t\t\t\tep[j + 2] += ep[j];\n\t\t\t\t\t\tep[j + 1] += ep[j];\n\t\t\t\t\t\tif ((j + 1) % 2 != X % 2) fp[j + 1] += ep[j] + dp[j];\n\t\t\t\t\t\tfp[j + 2] += fp[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < X; j++) ans -= fp[j];\n\t\t\t}\n\n\t\t\tfor (int i = 0; i <= n; i++) ans += binom[n, i] * val[i];\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t\tconst long INF = 1L << 60; static int[] dx = { -1, 0, 1, 0 }; static int[] dy = { 0, 1, 0, -1 }; int ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput()); static T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n]; for (int i = 0; i < a.Length; ++i) a[i] = f(i); return a;\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n\t\tvar solver = new Program.Solver();\n\t\t//* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 200000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t// solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n\t/// <summary>\n\t/// 剰余を取る値．\n\t/// </summary>\n\tpublic const long Mod = 998244353;\n\n\t/// <summary>\n\t/// 実際の数値．\n\t/// </summary>\n\tpublic long num;\n\t/// <summary>\n\t/// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n\t/// </summary>\n\t/// <param name=\"n\">インスタンスが持つ値</param>\n\t/// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n\tpublic ModInt(long n) { num = n; }\n\t/// <summary>\n\t/// このインスタンスの数値を文字列に変換します．\n\t/// </summary>\n\t/// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n\tpublic override string ToString() { return num.ToString(); }\n\tpublic static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n\tpublic static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n\tpublic static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n\tpublic static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(long v, long k) {\n\t\tlong ret = 1;\n\t\tfor (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n\t\t\tif ((k & 1) == 1) ret = ret * v % Mod;\n\t\treturn new ModInt(ret);\n\t}\n\t/// <summary>\n\t/// 与えられた数の逆元を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">逆元を取る対象となる数</param>\n\t/// <returns>逆元となるような値</returns>\n\t/// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n\tpublic static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n#region Binomial Coefficient\npublic class BinomialCoefficient {\n\tpublic ModInt[] fact, ifact;\n\tpublic BinomialCoefficient(int n) {\n\t\tfact = new ModInt[n + 1];\n\t\tifact = new ModInt[n + 1];\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfact[i] = fact[i - 1] * i;\n\t\tifact[n] = ModInt.Inverse(fact[n]);\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tifact[i] = ifact[i + 1] * (i + 1);\n\t\tifact[0] = ifact[1];\n\t}\n\tpublic ModInt this[int n, int r] {\n\t\tget {\n\t\t\tif (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n\t\t\treturn fact[n] * ifact[n - r] * ifact[r];\n\t\t}\n\t}\n\tpublic ModInt RepeatedCombination(int n, int k) {\n\t\tif (k == 0) return 1;\n\t\treturn this[n + k - 1, k];\n\t}\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    const string dstring = \"RDLU\";\n    static void Main(string[] args)\n    {\n        int n, x;\n        sc.Multi(out n, out x);\n        var dp = new long[n + 1][];\n        for (int i = 0; i < n + 1; i++)\n        {\n            dp[i] = new long[n * 2 + 1];\n        }\n        dp[0][0] = 1;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < n * 2; j++)\n            {\n                if (j + 1 <= n * 2)\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % M2;\n                if (j + 2 <= n * 2)\n                    dp[i + 1][j + 2] = (dp[i + 1][j + 2] + dp[i][j]) % M2;\n            }\n        }\n        var vals = new long[n + 1];\n        for (int i = 0; i <= n; i++)\n        {\n            for (int j = 0; j < x; j++)\n            {\n                vals[i] = (vals[i] + dp[i][j]) % M2;\n            }\n            int maxsum = 0;\n            for (int j = 1; j * 2 + 1 <= x && j * 2 <= i; j++)\n            {\n                vals[i] = (vals[i] + dp[i - j * 2][x - 1 - j * 2]) % M2;\n                maxsum = x - 1 + j * 2;\n            }\n            if (x % 2 == 1 && i * 2 > x && i * 2 > maxsum) {\n                vals[i] = (vals[i] + 1) % M2;\n            }\n        }\n        long ans = 0;\n        MyMath.Mod = M2;\n        MyMath.setfacts(n);\n        for (int i = 0; i <= n; i++)\n        {\n            ans = (ans + vals[i] * MyMath.comb(n, i)) % M2;\n        }\n        Prt(ans);\n        sw.Flush();\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n\nstatic class MyMath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long pow(long a, long b) {\n        a %= Mod;\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n\n    // 中国剰余定理\n    // リターン値を (r, m) とすると解は x ≡ r (mod. m)\n    // 解なしの場合は (0, -1) をリターン\n    public static pair<long, long> chineserem(IList<long> b, IList<long> m) {\n        long r = 0, M = 1;\n        for (int i = 0; i < b.Count; ++i) {\n            long p, q;\n            long d = extgcd(M, m[i], out p, out q); // p is inv of M/d (mod. m[i]/d)\n            if ((b[i] - r) % d != 0) return new pair<long, long>(0, -1);\n            long tmp = (b[i] - r) / d * p % (m[i]/d);\n            r += M * tmp;\n            M *= m[i]/d;\n        }\n        return new pair<long, long>((r % M + M) % M, M);\n    }\n\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts, invs;\n    public static void setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 1; i <= n; i++) facts[i] = facts[i - 1] * i % Mod;\n        invs = new long[n + 1];\n        invs[n] = inv(facts[n]);\n        for (int i = n; i > 0 ; i--) invs[i - 1] = invs[i] * i % Mod;\n    }\n    public static long comb(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[r] % Mod * invs[n - r] % Mod;\n        if (n - r < r) r = n - r;\n        long numer = 1, denom = 1;\n        for (long i = 0; i < r; i++) {\n            numer = numer * ((n - i) % Mod) % Mod;\n            denom = denom * ((i + 1) % Mod) % Mod;\n        }\n        return numer * inv(denom) % Mod;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n    public static bool nextPermutation<T>(IList<T> p) where T : struct, IComparable<T> {\n        for (int i = p.Count - 2; i >= 0; --i) {\n            if (p[i].CompareTo(p[i + 1]) < 0) {\n                for (int j = p.Count - 1; ; --j) {\n                    if (p[j].CompareTo(p[i]) > 0) {\n                        p.swap(i, j);\n                        for(++i, j = p.Count - 1; i < j; ++i, --j)\n                            p.swap(i, j);\n\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    public static bool nextPermutation<T>(IList<T> p, Comparison<T> compare) where T : struct {\n        for (int i = p.Count - 2; i >= 0; --i) {\n            if (compare(p[i], p[i + 1]) < 0) {\n                for (int j = p.Count - 1; ; --j) {\n                    if (compare(p[j], p[i]) > 0) {\n                        p.swap(i, j);\n                        for (++i, j = p.Count - 1; i < j; ++i, --j)\n                            p.swap(i, j);\n\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing Number = System.Int32;\nusing System.Numerics;\nusing static System.Numerics.BigInteger;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random(0);\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar X = ri;\n\t\t\tModInt ans = 0;\n\t\t\tvar val = new long[n + 1];\n\t\t\tvar binom = new BinomialCoefficient(n + 5);\n\n\t\t\tconst long M = ModInt.Mod;\n\t\t\t//総和が X 未満\n\t\t\t{\n\t\t\t\tvar dp = new long[X + 5];\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tfor (int j = X; j >= 0; j--) {\n\t\t\t\t\t\tdp[j + 2] += dp[j];\n\t\t\t\t\t\tif (dp[j + 2] >= M) dp[j + 2] -= M;\n\t\t\t\t\t\tdp[j + 1] += dp[j];\n\t\t\t\t\t\tif (dp[j + 1] >= M) dp[j + 1] -= M;\n\t\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < X; j++) ans += dp[j];\n\n\t\t\t}\n\t\t\t//総和が X 以上で 全部偶数かつ X が奇数\n\t\t\tif (X % 2 == 1) {\n\t\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\t\tif (i * 2 > X) val[i] += 1;\n\t\t\t}\n\t\t\t//3. 以下の 3 つを満たすやつ\n\t\t\t//  - 一番左の 1 から一番右の 1 までの parity が X と異なる\n\t\t\t//  - 一番左の 2 から一番右の 2 までが X-1 以下\n\t\t\t//  - 一番右の 2 から一番左の 1 までが X-1 以下\n\t\t\t{\n\n\t\t\t\t//dp[i][j] = i 個まで 2 を端に追加でき、合計 j 個\n\t\t\t\tvar dp = Enumerate(n + 1, x => new long[n + 2]);\n\t\t\t\tif (X % 2 != 1) dp[(X - 2) / 2][1] += 1;\n\t\t\t\tfor (int i = 2; i <= n; i++)\n\t\t\t\t\tfor (int j = i; j <= X; j++)\n\t\t\t\t\t\tif (j % 2 != X % 2) dp[(X - 1 - j) / 2][i] = binom[i - 2, j - i].num;\n\t\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tvar ndp = new long[n + 2];\n\t\t\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\t\t\tndp[j] += dp[i][j];\n\t\t\t\t\t\t\tif (ndp[j] >= M) ndp[j] -= M;\n\t\t\t\t\t\t\tndp[Min(n + 1, j + i + 1)] += M - dp[i][j];\n\t\t\t\t\t\t\tif (ndp[Min(n + 1, j + i + 1)] >= M) ndp[Min(n + 1, j + i + 1)] -= M;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\t\t\tndp[j + 1] += ndp[j];\n\t\t\t\t\t\t\tif (ndp[j + 1] >= M) ndp[j + 1] -= M;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i] = ndp;\n\t\t\t\t\t}\n\t\t\t\t\t// Debug.WriteLine(dp[i].AsJoinedString());\n\t\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\t\tval[j] += dp[i][j];\n\t\t\t\t\t\tif (val[j] >= M) val[j] -= M;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//一番左の 1 から一番右の 1 までの parity が X と異なる\n\t\t\t//総和が X 未満\n\t\t\t{\n\t\t\t\tvar dp = new long[X + 5];\n\t\t\t\tvar ep = new long[X + 5];\n\t\t\t\tvar fp = new long[X + 5];\n\t\t\t\tdp[0] = 1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = X; j >= 0; j--) {\n\t\t\t\t\t\tdp[j + 2] += dp[j];\n\t\t\t\t\t\tif (dp[j + 2] >= M) dp[j + 2] -= M;\n\t\t\t\t\t\tep[j + 1] += dp[j];\n\t\t\t\t\t\tif (ep[j + 1] >= M) ep[j + 1] -= M;\n\t\t\t\t\t\tep[j + 2] += ep[j];\n\t\t\t\t\t\tif (ep[j + 2] >= M) ep[j + 2] -= M;\n\t\t\t\t\t\tep[j + 1] += ep[j];\n\t\t\t\t\t\tif (ep[j + 1] >= M) ep[j + 1] -= M;\n\t\t\t\t\t\tif ((j + 1) % 2 != X % 2) {\n\t\t\t\t\t\t\tfp[j + 1] += ep[j];\n\t\t\t\t\t\t\tif (fp[j + 1] >= M) fp[j + 1] -= M;\n\t\t\t\t\t\t\tfp[j + 1] += dp[j];\n\t\t\t\t\t\t\tif (fp[j + 1] >= M) fp[j + 1] -= M;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfp[j + 2] += fp[j];\n\t\t\t\t\t\tif (fp[j + 2] >= M) fp[j + 2] -= M;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < X; j++) ans -= fp[j];\n\t\t\t}\n\n\t\t\tfor (int i = 0; i <= n; i++) ans += binom[n, i] * val[i];\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t\tconst long INF = 1L << 60; static int[] dx = { -1, 0, 1, 0 }; static int[] dy = { 0, 1, 0, -1 }; int ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput()); static T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n]; for (int i = 0; i < a.Length; ++i) a[i] = f(i); return a;\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n\t\tvar solver = new Program.Solver();\n\t\t//* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 200000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t// solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n\t/// <summary>\n\t/// 剰余を取る値．\n\t/// </summary>\n\tpublic const long Mod = 998244353;\n\n\t/// <summary>\n\t/// 実際の数値．\n\t/// </summary>\n\tpublic long num;\n\t/// <summary>\n\t/// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n\t/// </summary>\n\t/// <param name=\"n\">インスタンスが持つ値</param>\n\t/// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n\tpublic ModInt(long n) { num = n; }\n\t/// <summary>\n\t/// このインスタンスの数値を文字列に変換します．\n\t/// </summary>\n\t/// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n\tpublic override string ToString() { return num.ToString(); }\n\tpublic static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n\tpublic static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n\tpublic static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n\tpublic static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(long v, long k) {\n\t\tlong ret = 1;\n\t\tfor (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n\t\t\tif ((k & 1) == 1) ret = ret * v % Mod;\n\t\treturn new ModInt(ret);\n\t}\n\t/// <summary>\n\t/// 与えられた数の逆元を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">逆元を取る対象となる数</param>\n\t/// <returns>逆元となるような値</returns>\n\t/// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n\tpublic static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n#region Binomial Coefficient\npublic class BinomialCoefficient {\n\tpublic ModInt[] fact, ifact;\n\tpublic BinomialCoefficient(int n) {\n\t\tfact = new ModInt[n + 1];\n\t\tifact = new ModInt[n + 1];\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfact[i] = fact[i - 1] * i;\n\t\tifact[n] = ModInt.Inverse(fact[n]);\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tifact[i] = ifact[i + 1] * (i + 1);\n\t\tifact[0] = ifact[1];\n\t}\n\tpublic ModInt this[int n, int r] {\n\t\tget {\n\t\t\tif (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n\t\t\treturn fact[n] * ifact[n - r] * ifact[r];\n\t\t}\n\t}\n\tpublic ModInt RepeatedCombination(int n, int k) {\n\t\tif (k == 0) return 1;\n\t\treturn this[n + k - 1, k];\n\t}\n}\n#endregion\n"
  },
  {
    "language": "JavaScript",
    "code": "var GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nfunction xArray(v){var a=arguments,l=a.length,r=\"Array(a[\"+--l+\"]).fill(0).map(x=>{return \"+v+\";})\";while(--l)r=\"Array(a[\"+l+\"]).fill(0).map(x=>\"+r+\")\";return eval(r);}\nvar n, x, ncr, p2n, mod = 998244353;\nfunction abmod(){for(var a=arguments,r=a[0],i=1;i<a.length;)r=((r>>16)*a[i]%mod*65536+(r&65535)*a[i++])%mod;return r;}\n\nconsole.log(main());\nfunction main(){\n  n = o.a();\n  x = o.a();\n  ncr = Array(n+1);\n  p2n = Array(n+1);\n  ncr[0] = [1];\n  p2n[0] = 1;\n  for(var i = 1; i <= n; i++){\n    ncr[i] = Array(i+1).fill(1);\n    p2n[i] = p2n[i-1] * 2 % mod;\n    for(var j = 1; j < i; j++){\n      ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j]) % mod;\n    }\n  }\n  var t = 0, ans = 1;\n  if(x & 1)t = 1, ans = p2n[n];\n  for(var i = 1; i <= n && i < x; i++){\n    if(i * 2 < x)ans += abmod(ncr[n][i], p2n[i]-t);\n    else ans += solve(i);\n  }\n  return ans % mod;\n}\nfunction solve(i){\n  var ans = 0;\n  for(var j = 0; j < x-i; j++){\n    ans += abmod(ncr[n][i], ncr[i][j]);\n  }\n  for(var j = x-i+1; j < i; j += 2){\n    ans += abmod(ncr[n][i], ncr[x-j-1][i-j]);\n  }\n  return ans % mod;\n}"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum long MO = 998244353;\nenum LIM = 10^^5;\n\nlong[] inv, fac, invFac;\nvoid prepare() {\n  inv = new long[LIM];\n  fac = new long[LIM];\n  invFac = new long[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = MO - ((MO / i) * inv[cast(size_t)(MO % i)]) % MO;\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = (fac[i - 1] * i) % MO;\n    invFac[i] = (invFac[i - 1] * inv[i]) % MO;\n  }\n}\nlong binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] % MO * invFac[cast(size_t)(n - k)] % MO;\n  } else {\n    return 0;\n  }\n}\n\n\nint N, X;\n\nvoid main() {\n  prepare();\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      X = readInt();\n      \n      long ans;\n      \n      if (X == 1) {\n        // 0, 2\n        ans = 1;\n        foreach (i; 0 .. N) {\n          ans *= 2;\n          ans %= MO;\n        }\n      } else {\n        auto dp = new long[][](X + 1, X + 1);\n        dp[0][1] = 1;\n        foreach (i; 0 .. X) {\n          foreach (a; 0 .. X + 1) {\n            foreach (j; [i + 1, i + 2]) {\n              if (j <= X && a + 1 <= X) {\n                dp[j][a + 1] += dp[i][a];\n                dp[j][a + 1] %= MO;\n              }\n            }\n          }\n        }\n        debug {\n          if (X <= 10) {\n            writeln(\"dp = \", dp);\n          }\n        }\n        foreach (s; 0 .. X) {\n          /*\n            o ... o\n          */\n          long tmp;\n          foreach (a; 1 .. X + 1) {\n            if (a <= N + 1) {\n              // a multi-choose (N + 1) - a\n              tmp += (dp[s][a] * binom(a + ((N + 1) - a) - 1, (N + 1) - a)) % MO;\n              tmp %= MO;\n            }\n          }\n          debug {\n            if (X <= 13) {\n              writefln(\"s = %s: %s\", s, tmp);\n            }\n          }\n          ans += tmp;\n          ans %= MO;\n        }\n        foreach (s; X .. 2 * X - 1) {\n          if ((s - X) % 2 != 0) {\n            long tmp;\n            foreach (a; 1 .. X + 1) {\n              const b = (s - X + 1) + a;\n              if (b <= N + 1) {\n                tmp += (dp[X - 1 - (s - X + 1)][a] * binom(b + ((N + 1) - b) - 1, (N + 1) - b)) % MO;\n                tmp %= MO;\n              }\n            }\n            debug {\n              if (X <= 13) {\n                writefln(\"s = %s: %s\", s, tmp);\n              }\n            }\n            ans += tmp;\n            ans %= MO;\n          }\n        }\n        if (X % 2 != 0) {\n          int cnt = X;\n          foreach (s; 2 * X .. 2 * N + 1) {\n            const q = s / X, r = s % X;\n            if ((q + r) % 2 == 0) {\n              ++cnt;\n              if (cnt <= N + 1) {\n                const tmp = binom(cnt + ((N + 1) - cnt) - 1, (N + 1) - cnt);\n                debug {\n                  if (X <= 13) {\n                    writefln(\"s = %s: %s\", s, tmp);\n                    writefln(\"  cnt = %s\", cnt);\n                  }\n                }\n                ans += tmp;\n                ans %= MO;\n              }\n            }\n          }\n        }\n      }\n      ans = (ans % MO + MO) % MO;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Nim",
    "code": "# header {{{\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils, strformat, sugar\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\n\nmacro `:=`(x, y: untyped): untyped =\n  var strBody = \"\"\n  if x.kind == nnkPar:\n    for i,xi in x:\n      strBody &= fmt\"\"\"\n{xi.repr} := {y[i].repr}\n\"\"\"\n  else:\n    strBody &= fmt\"\"\"\nwhen declaredInScope({x.repr}):\n  {x.repr} = {y.repr}\nelse:\n  var {x.repr} = {y.repr}\n\"\"\"\n  strBody &= fmt\"discardableId({x.repr})\"\n  parseStmt(strBody)\n\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\ntemplate makeSeq(x:int; init):auto =\n  when init is typedesc: newSeq[init](x)\n  else: newSeqWith(x, init)\n\nmacro Seq(lens: varargs[int]; init):untyped =\n  var a = fmt\"{init.repr}\"\n  for i in countdown(lens.len - 1, 0): a = fmt\"makeSeq({lens[i].repr}, {a})\"\n  parseStmt(fmt\"\"\"\nblock:\n  {a}\"\"\")\n\ntemplate makeArray(x:int; init):auto =\n  var v:array[x, init.type]\n  when init isnot typedesc:\n    for a in v.mitems: a = init\n  v\n\nmacro Array(lens: varargs[typed], init):untyped =\n  var a = fmt\"{init.repr}\"\n  for i in countdown(lens.len - 1, 0):\n    a = fmt\"makeArray({lens[i].repr}, {a})\"\n  parseStmt(fmt\"\"\"\nblock:\n  {a}\"\"\")\n#}}}\n\nconst MOD = 998244353\nvar N:int\nvar X:int\n\n# input part {{{\nproc main()\nblock:\n  N = nextInt()\n  X = nextInt()\n#}}}\n\n# ModInt {{{\n# ModInt[Mod] {{{\ntype ModInt[Mod: static[int]] = object\n  v:int32\n\nproc initModInt(a:SomeInteger, Mod:static[int]):ModInt[Mod] =\n  var a = a.int\n  a = a mod Mod\n  if a < 0: a += Mod\n  result.v = a.int32\n\nproc getMod[Mod:static[int]](self: ModInt[Mod]):static int32 = self.Mod\nproc getMod[Mod:static[int]](self: typedesc[ModInt[Mod]]):static int32 = self.Mod\n\nmacro declareModInt(Mod:static[int], t: untyped):untyped =\n  var strBody = \"\"\n  strBody &= fmt\"\"\"\ntype {t.repr} = ModInt[{Mod.repr}]\nconverter to{t.repr}(a:SomeInteger):{t.repr} = initModInt(a, {Mod.repr})\nproc init{t.repr}(a:SomeInteger):{t.repr} = initModInt(a, {Mod.repr})\nproc `$`(a:{t.repr}):string = $(a.v)\n\"\"\"\n  parseStmt(strBody)\n\nwhen declared(Mod): declareModInt(Mod, Mint)\n##}}}\n\n# DynamicModInt {{{\ntype DMint = object\n  v:int32\n\nproc setModSub(self:typedesc[not ModInt], m:int = -1, update = false):int32 =\n  {.noSideEffect.}:\n    var DMOD {.global.}:int32\n    if update: DMOD = m.int32\n    return DMOD\n\nproc fastMod(a:int,m:uint32):uint32{.inline.} =\n  var\n    minus = false\n    a = a\n  if a < 0:\n    minus = true\n    a = -a\n  elif a < m.int:\n    return a.uint32\n  var\n    xh = (a shr 32).uint32\n    xl = a.uint32\n    d:uint32\n  asm \"\"\"\n    \"divl %4; \\n\\t\"\n    : \"=a\" (`d`), \"=d\" (`result`)\n    : \"d\" (`xh`), \"a\" (`xl`), \"r\" (`m`)\n  \"\"\"\n  if minus and result > 0'u32: result = m - result\nproc initDMint(a:SomeInteger, Mod:int):DMint = result.v = fastMod(a.int, Mod.uint32).int32\n\nproc getMod[T:not ModInt](self: T):int32 = T.type.setModSub()\nproc getMod(self: typedesc[not ModInt]):int32 = self.setModSub()\nproc setMod(self: typedesc[not ModInt], m:int) = discard self.setModSub(m, update = true)\n#}}}\n\n# Operations {{{\ntype ModIntC = concept x, type T\n  x.v\n#  x.v is int32\n#  x.getMod() is int32\n#  when T isnot ModInt: setMod(T, int)\ntype SomeIntC = concept x\n  x is SomeInteger or x is ModIntC\n\nproc Identity(self:ModIntC):auto = result = self;result.v = 1\nproc init[Mod:static[int]](self:ModInt[Mod], a:SomeIntC):ModInt[Mod] =\n  when a is SomeInteger: initModInt(a, Mod)\n  else: a\nproc init(self:ModIntC and not ModInt, a:SomeIntC):auto =\n  when a is SomeInteger:\n    var r = self.type.default\n    r.v = fastMod(a.int, self.getMod().uint32).int32\n    r\n  else: a\n\nmacro declareDMintConverter(t:untyped) =\n  parseStmt(fmt\"\"\"\nconverter to{t.repr}(a:SomeInteger):{t.repr} =\n  let Mod = {t.repr}.getMod()\n  if Mod > 0:\n    result.v = fastMod(a.int, Mod.uint32).int32\n  else:\n    result.v = a.int32\n  return result\n\"\"\")\n\ndeclareDMintConverter(DMint)\n\nmacro declareDMint(t:untyped) =\n  parseStmt(fmt\"\"\"\ntype {t.repr} {{.borrow: `.`.}} = distinct DMint\ndeclareDMintConverter({t.repr})\n\"\"\")\n\nproc `*=`(self:var ModIntC, a:SomeIntC) =\n  when self is ModInt:\n    self.v = (self.v.int * self.init(a).v.int mod self.getMod().int).int32\n  else:\n    self.v = fastMod(self.v.int * self.init(a).v.int, self.getMod().uint32).int32\nproc `==`(a:ModIntC, b:SomeIntC):bool = a.v == a.init(b).v\nproc `!=`(a:ModIntC, b:SomeIntC):bool = a.v != a.init(b).v\nproc `-`(self:ModIntC):auto =\n  if self.v == 0: return self\n  else: return self.init(self.getMod() - self.v)\nproc `$`(a:ModIntC):string = return $(a.v)\n\nproc `+=`(self:var ModIntC; a:SomeIntC) =\n  self.v += self.init(a).v\n  if self.v >= self.getMod(): self.v -= self.getMod()\nproc `-=`(self:var ModIntC, a:SomeIntC) =\n  self.v -= self.init(a).v\n  if self.v < 0: self.v += self.getMod()\nproc `^=`(self:var ModIntC, n:SomeInteger) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(self: ModIntC):auto =\n  var\n    a = self.v.int\n    b = self.getMod().int\n    u = 1\n    v = 0\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a, b)\n    u -= t * v;swap(u, v)\n  return self.init(u)\nproc `/=`(a:var ModIntC,b:SomeIntC) = a *= a.init(b).inverse()\nproc `+`(a:ModIntC,b:SomeIntC):auto = result = a;result += b\nproc `-`(a:ModIntC,b:SomeIntC):auto = result = a;result -= b\nproc `*`(a:ModIntC,b:SomeIntC):auto = result = a;result *= b\nproc `/`(a:ModIntC,b:SomeIntC):auto = result = a;result /= b\nproc `^`(a:ModIntC,b:SomeInteger):auto = result = a;result ^= b\n# }}}\n# }}}\n\n# combination {{{\nimport sequtils\n\n#proc `/`(a, b:int):int = a div b\n\ntype IntC = concept x\n  x + x\n  x - x\n  x * x\n  x / x\n\ntype Combination[T] = object\n  fact_a, rfact_a: seq[T]\n\ntype CombinationC = concept x\n  x is typedesc[IntC] or x is var Combination\n\nproc getVal[T:IntC](cmb: var Combination[T], t:static[int], k:int):auto {.discardable.} =\n  if k >= cmb.fact_a.len:\n    if cmb.fact_a.len == 0:\n      cmb.fact_a = @[T(1)]\n      cmb.rfact_a = @[T(1)]\n    let sz_old = cmb.fact_a.len - 1\n    let sz = max(sz_old * 2, k)\n    cmb.fact_a.setlen(sz + 1)\n    cmb.rfact_a.setlen(sz + 1)\n    for i in sz_old + 1..sz: cmb.fact_a[i] = cmb.fact_a[i-1] * T(i)\n    cmb.rfact_a[sz] = T(1) / cmb.fact_a[sz]\n    for i in countdown(sz - 1, sz_old + 1): cmb.rfact_a[i] = cmb.rfact_a[i + 1] * T(i + 1)\n  when t == 0: return cmb.fact_a[k]\n  elif t == 1: return cmb.rfact_a[k]\n  elif t == 2: # reset\n    cmb.fact_a.setLen(0)\n    cmb.rfact_a.setLen(0)\n    return T(0)\ntemplate resetCombination(T:typedesc[IntC] or var Combination) = T.getVal(2, 0)\n\nproc getVal(T:typedesc[IntC], t:static[int], k:int):auto {.discardable.} =\n  var cmb{.global.} = Combination[T]()\n  return cmb.getVal(t, k)\n\ntemplate zero(T:typedesc[IntC]):T = T(0)\ntemplate zero[T](cmb:Combination[T]):T = T(0)\n\ntemplate fact(T:CombinationC, k:int):auto = T.getVal(0, k)\ntemplate rfact(T:CombinationC, k:int):auto = T.getVal(1, k)\ntemplate inv(T:CombinationC, k:int):auto = T.fact_a(k - 1) * T.rfact(k)\n\ntemplate P(T:CombinationC, n,r:int):auto =\n  if r < 0 or n < r: T.zero()\n  else: T.fact(n) * T.rfact(n - r)\ntemplate C(T:CombinationC, n,r:int):auto =\n  if r < 0 or n < r: T(0)\n  else: T.fact(n) * T.rfact(r) * T.rfact(n - r)\ntemplate H(T:CombinationC, n,r:int):auto =\n  if n < 0 or r < 0: T(0)\n  elif r == 0: T(1)\n  else: T.C(n + r - 1, r)\n# }}}\n\nimport options\n\nproc calc(n, s:int):Mint =\n  if n * 2 < s or s < n: return 0\n  return Mint.C(n, s - n)\n\nproc calc12(n, s:int):Mint =\n  if s <= X - 1:\n    return calc(n, s)\n  elif s <= (X - 1) * 2:\n    let k = s - (X - 1)\n    if k mod 2 != 0: return 0\n    return calc(n - k, s - k * 2)\n  else:\n    # all 2\n    if n * 2 != s or X mod 2 == 0: return 0\n    else: return 1\n\nproc main() =\n  var ans:Mint = 0\n  for n in 0..N:\n    for s in 0..n*2:\n      let t = calc12(n, s)\n      ans += t * Mint.C(N, n)\n  print ans\n  return\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nN, X = map(int, input().split())\nP = 998244353\n\nA = [[0] * (2*i+1) for i in range(N+1)] # A[i][j] is the number of permutations of 1's and 2's whose length is i and whose sum is j\nA[0][0] = 1\nB = [0] * (N + 1) # B[i] is the number of permutations of 1's and 2's with length i none of whose consecutive subsequenses is equal to X\nfor i in range(N):\n    for j in range(i, 2*i+1):\n        A[i+1][j+1] += A[i][j]\n        A[i+1][j+2] += A[i][j]\n        if A[i+1][j+1] >= P: A[i+1][j+1] -= P\n        if A[i+1][j+2] >= P: A[i+1][j+2] -= P\n\n# Type 1: Sum is below X\nfor i in range(N+1):\n    for j in range(i, min(2*i+1, X)):\n        B[i] += A[i][j]\n\n# Type 2: Sum is 2X or more\nif X % 2:\n    for i in range(X, N+1):\n        B[i] += 1\n\n# Type 3: X <= Sum < 2X\nfor i in range(1, X):\n    a = X - 1 - 2 * i\n    if a < 0: continue\n    for j in range((a+1) // 2, a + 1):\n        k = j + 2 * i\n        if k > N: break\n        B[k] += A[j][a]\n        if B[k] >= P: B[k] -= P\n\nans = 0\nfor i, b in enumerate(B):\n    ans = (ans + b * A[-1][-1-i]) % P\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "MOD = 998244353\nMAX_K = 3000\n\n\ndef ceil(a: int, b: int)->int:\n    '''a/b の切り上げを計算する。\n    '''\n    if (a // b) * b == a:\n        return a//b\n    return a//b + 1\n\n\n# __fact[n] = n!\n__fact = [0] * (MAX_K+1)\n\n\ndef init_comb():\n    # initialize __fact\n    __fact[0] = 1\n    for n in range(MAX_K):\n        __fact[n+1] = ((n+1) * __fact[n]) % MOD\n\n\ndef mod_inv(n: int, mod: int)->int:\n    b, u, v = mod, 1, 0\n    while b > 0:\n        t = n // b\n\n        n -= t * b\n        u -= t * v\n\n        n, b = b, n\n        u, v = v, u\n\n    return (u+mod) % mod\n\n\ndef comb(n: int, r: int)->int:\n    '''nCr を計算する\n    '''\n    res = __fact[n]\n    res = (res * mod_inv(__fact[n-r], MOD)) % MOD\n    res = (res * mod_inv(__fact[r], MOD)) % MOD\n    return res\n\n\ndef banned_x(N: int, X: int)->int:\n    # 数列の全体の和を固定して調べる。\n    # 数列の和の最大値は全て 2 でできている数列の 2*N\n    res = 1  # 0 だけでできている分\n    for S in range(1, 2*N+1):\n        tmp = res\n        if S < X:\n            # 1, 2 を合計で k 個利用するとする。\n            # 1 を p 個、2 を q 個とすると\n            # p+q=K; p+2q=S;\n            # より\n            # p=2K-S; q=S-K\n            # となる。\n            # このとき、0, 1, 2 の並べ方は\n            # comb(N,p) * comb(N-p,q)\n            # である。\n            # また、0<=p; 0<=q より S/2<=k<=S が成り立つ。\n            for k in range(ceil(S, 2), min(S, N)+1):\n                p, q = 2*k - S, S-k\n                res += comb(N, p) * comb(N-p, q)\n                res %= MOD\n        elif S == X:\n            # nothing\n            continue\n        elif (S-X) & 1:\n            # 2 を置かなければならない場所が [0, only2)\n            # と (only2, N]\n            only2 = (S-(X-1))//2\n\n            # 1 が含まれない場合\n            if 2*only2 >= X-1:\n                if X & 1:\n                    # 2 の置き方は N 個の位置から S//2 個\n                    # 選ぶ組み合わせ。残りは 0 を置く\n                    res += comb(N, S//2)\n                    res %= MOD\n            # 1 が含まれる場合\n            else:\n                # SS は 1,2 なんでも置いていいゾーンの幅\n                SS = X-1-2*only2\n\n                # k,p,q の変数の意味は S<X の時と同じ\n                # ただし、2 は 2*only2 の領域にも置くので\n                # 2 の個数は SS-k+2*only2 になり、\n                # (N 個の位置から k+2*only2 個の位置を 1,2 用に確保)\n                # x (k 個の位置から p 個の 1 を置く位置を確保)\n                for k in range(ceil(SS, 2), min(N-2*only2, SS)+1):\n                    p, q = 2*k-SS, SS-k\n                    res += comb(N, k+2*only2) * comb(k, p)\n                    res %= MOD\n        # print('S={}, res={}'.format(S, res-tmp))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    N, X = map(int, input().split())\n\n    init_comb()\n\n    ans = banned_x(N, X)\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "a"
  },
  {
    "language": "Python",
    "code": "MOD = 998244353\nMAX_K = 3000\n\n\ndef ceil(a: int, b: int)->int:\n    '''a/b の切り上げを計算する。\n    '''\n    if (a // b) * b == a:\n        return a//b\n    return a//b + 1\n\n\n# __fact[n] = n!\n__fact = [0] * (MAX_K+1)\n# __inv[n] = (n! の mod MOD に関する逆数)\n__inv = [0] * (MAX_K+1)\n\n\ndef init_comb():\n    # initialize __fact\n    __fact[0] = 1\n    __inv[0] = 1\n    for n in range(MAX_K):\n        __fact[n+1] = ((n+1) * __fact[n]) % MOD\n        __inv[n+1] = mod_inv((n+1) * __fact[n], MOD)\n\n\ndef mod_inv(n: int, mod: int)->int:\n    b, u, v = mod, 1, 0\n    while b > 0:\n        t = n // b\n\n        n -= t * b\n        u -= t * v\n\n        n, b = b, n\n        u, v = v, u\n\n    return (u+mod) % mod\n\n\ndef comb(n: int, r: int)->int:\n    '''nCr を計算する\n    '''\n    res = __fact[n]\n    res = (res * __inv[n-r]) % MOD\n    res = (res * __inv[r]) % MOD\n    return res\n\n\ndef banned_x(N: int, X: int)->int:\n    # 数列の全体の和を固定して調べる。\n    # 数列の和の最大値は全て 2 でできている数列の 2*N\n    res = 1  # 0 だけでできている分\n    for S in range(1, 2*N+1):\n        if S < X:\n            # 1, 2 を合計で k 個利用するとする。\n            # 1 を p 個、2 を q 個とすると\n            # p+q=K; p+2q=S;\n            # より\n            # p=2K-S; q=S-K\n            # となる。\n            # このとき、0, 1, 2 の並べ方は\n            # comb(N,p) * comb(N-p,q)\n            # である。\n            # また、0<=p; 0<=q より S/2<=k<=S が成り立つ。\n            for k in range(ceil(S, 2), min(S, N)+1):\n                p, q = 2*k - S, S-k\n                res += comb(N, p) * comb(N-p, q)\n                res %= MOD\n        elif S == X:\n            # nothing\n            continue\n        elif (S-X) & 1:\n            # 2 を置かなければならない場所が [0, only2)\n            # と (only2, N]\n            only2 = (S-(X-1))//2\n\n            # 1 が含まれない場合\n            if 2*only2 >= X-1:\n                if X & 1:\n                    # 2 の置き方は N 個の位置から S//2 個\n                    # 選ぶ組み合わせ。残りは 0 を置く\n                    res += comb(N, S//2)\n                    res %= MOD\n            # 1 が含まれる場合\n            else:\n                # SS は 1,2 なんでも置いていいゾーンの幅\n                SS = X-1-2*only2\n\n                # k,p,q の変数の意味は S<X の時と同じ\n                # ただし、2 は 2*only2 の領域にも置くので\n                # 2 の個数は SS-k+2*only2 になり、\n                # (N 個の位置から k+2*only2 個の位置を 1,2 用に確保)\n                # x (k 個の位置から p 個の 1 を置く位置を確保)\n                for k in range(ceil(SS, 2), min(N-2*only2, SS)+1):\n                    p, q = 2*k-SS, SS-k\n                    res += comb(N, k+2*only2) * comb(k, p)\n                    res %= MOD\n        # print('S={}, res={}'.format(S, res-tmp))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    N, X = map(int, input().split())\n\n    init_comb()\n\n    ans = banned_x(N, X)\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/tenka1-2019/tasks/tenka1_2019_f\nXが偶数か奇数かは重要な気がする\n長さL(<=N)の1,2で構成された文字列の問題、に変換できる\nO(L)で求められばおｋ\ndpか？\n\nX == 1なら、0,2のみで構成されてればおｋ\nX == 2なら、1が2つ以上入っていたら不可能 0 & 1が1つまで\nX == 3なら、2を入れる場合→1は入れられないが、2を好きなだけ入れていい\n            入れない場合→1を2個まで入れられる\nX == 4なら、\n\n→やはり偶奇が重要か？\n\nとどく場合は X-1　→ X+1の移動は強制\nすなわち 座標1に行ってはいけない\n初手は2に行くしかない\n同様にX+2には行けない\nX+3に行くしかない\n3には行けないから4に行くしかない\nつまり2以外不可？？ \n\n無限に移動を続ける場合は少なくともX=奇数 2のみ以外無理\n偶数の場合はX以前に奇数回1をはさむ必要あり\na→a+1と移動すると、X+a-1から先は移動できなくなる\n\nよって2Xは絶対超えられない\nあとは数え上げにどうやって落とすか\nLは固定でいいと思うんだよな\nO(L)で解ければ勝ち\n\ndp ?\n総和で場合分け or Lで場合分け\n総和で場合分けする場合、当然Lは異なるのでまとめる必要がある\nLの長さの移動の寄与にはNCLを掛ける必要がある\n移動するときにLは1増えるんだよな…\nnC(l+1) = nCl * (n-l)/(l+1)\n移動処理を一気に行えばlは統一できるからおｋ？\n\n総和SはX以上の場合 X+1+2kしかありえない\nS-X以前は2のみ進軍可能、以降は自由\n\n対称性？\n1と2の数を全探索？ ならばO(N**2)でいける\n1がA個,2がB個の時、最初と最後に2をいくつか置く必要がある\n→後は残りの位置から1を置く場所を選べばよい\n\n→解けたっぽい？\n\n場合分け頑張ろう\n\n合計がX以下の場合→完全に自由\n合計が2X以上の場合→Xが奇数の場合のみ all2が可能。それ以外は死\nX以上2X以下の場合\n→\n    S-Xが奇数である必要あり\n    まず2を(S-X+1)こ消費する（前後に置く分）\n    あとは自由に順列を作ってどうぞ\n    \n\"\"\"\n\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv): #上で求めたfacとinvsを引数に入れるべし(上の関数で与えたnが計算できる最大のnになる)\n\n    return fac[n] * inv[n-r] * inv[r] % mod\n\n\nN,X = map(int,input().split())\n\nmod = 998244353\nfac,inv = modfac(N+10,mod)\nans = 0\n\nfor two in range(N+1):\n\n    for one in range(N+1):\n\n        if one + two > N:\n            break\n        \n        dist = one + two*2\n        zero = modnCr(N,one+two,mod,fac,inv)\n        now = 0\n\n        if dist < X:\n            now = modnCr(one+two,one,mod,fac,inv) * zero\n        elif dist == X:\n            continue\n        elif dist < 2*X:\n            if (dist-X) % 2 == 0:\n                continue\n            dtwo = two - (dist-X+1)\n            if dtwo >= 0:\n                now = modnCr(one+dtwo,one,mod,fac,inv) * zero\n        elif X % 2 == 1 and one == 0:\n            now = zero\n\n        #print (one,two,now)\n        \n        ans += now\n        ans %= mod\n\nprint (ans)\n            \n"
  },
  {
    "language": "Python",
    "code": "a"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\n\"\"\"\n・累積和の到達地点集合ごとに見る\n・type1：X未満で終わる\n・type2：X+1以上2X未満\n・type3：2X以上、これはXが奇数の場合のみ\n\"\"\"\n\nMOD = 998244353\n\nN,X = map(int,read().split())\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = N+100\nfact,fact_inv = make_fact(U,MOD)\ncombN = fact[N] * fact_inv[:N+1] % MOD * fact_inv[N::-1] % MOD\n\ndef F1(N,X):\n    # X未満で終わる場合\n    def mult(P,Q):\n        # 多項式の積\n        dP = len(P) - 1\n        dQ = len(Q) - 1\n        if dP < dQ:\n            dP,dQ = dQ,dP\n            P,Q = Q,P\n        R = np.zeros(dP+dQ+1,np.int64)\n        for n in range(dQ+1):\n            R[n:n+dP+1] += Q[n] * P % MOD\n        R %= MOD\n        return R[:X]\n    def power(P,n):\n        if n == 0:\n            return np.array([1],dtype=np.int64)\n        Q = power(P,n//2)\n        Q = mult(Q,Q)\n        return mult(P,Q) if n&1 else Q\n    P = np.array([1,1,1],np.int64)\n    Q = power(P,N)\n    return Q.sum() % MOD\n\ndef F2(N,X):\n    U = N+100\n    fact,fact_inv = make_fact(U,MOD)\n    combN = fact[N] * fact_inv[:N+1] % MOD * fact_inv[N::-1] % MOD\n    x = np.zeros(N+1,np.int64)\n    # X+1+2nで終わる場合\n    for n in range(X):\n        m = (X-1) - (2+2*n)\n        if m < 0:\n            break\n        # 2+2n -> X-1に含まれる2の回数ごとに\n        two = np.arange(m//2+1,dtype=np.int64)\n        one = m - 2*two\n        coef = fact[one+two] * fact_inv[one] % MOD * fact_inv[two] % MOD\n        rest = N-one-two-(2*n+2)\n        ind = rest>=0\n        rest = rest[ind]; coef = coef[ind]\n        x[rest] += coef\n    x %= MOD\n    return (x * combN % MOD).sum() % MOD\n\ndef F3(N,X):\n    U = N+100\n    fact,fact_inv = make_fact(U,MOD)\n    combN = fact[N] * fact_inv[:N+1] % MOD * fact_inv[N::-1] % MOD\n    # 2X以上の偶数。Xは奇数で、+2を連打している場合\n    if X%2 == 0:\n        return 0\n    if X > N:\n        return 0\n    n = N-X+1\n    return combN[:n].sum() % MOD\n\nanswer = (F1(N,X) + F2(N,X) + F3(N,X)) % MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "//Pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 3002;\nconst int MOD = 998244353;\n\nint n, x;\nint pw2[MAX_N], C[MAX_N][MAX_N], f[MAX_N][MAX_N*2], g[MAX_N][MAX_N];\n\nvoid read_input() {\n    cin >> n >> x;\n}\n\n//void NTT(vector<int> &a, bool invert) {\n//    for (int i=0; i<n; ++i) {\n//        if (rev_bit[i] > i)\n//            swap(a[i], a[rev_bit[i]]);\n//    }\n//\n//    int n = a.size();\n//\n//    for (int len=2; len<=n; len <<= 1) {\n//        int wlen = invert ? ROOT : ROOT_1;\n//        for (int i=len; i<=ROOT_PW; i <<= 1)\n//            wlen = 1LL * wlen * wlen % MOD;\n//\n//        for (int i=0; i<n; i += len) {\n//            int w = 1;\n//            for (int j=0; j<len/2; ++j) {\n//                int u = a[i+j], v = 1LL * a[i+j+len/2] * w % MOD;\n//                a[i+j] = (u+v<MOD ? u + v : u + v - MOD);\n//                a[i+j+len/2] = (u-v>=0 ? u - v : u - v + MOD);\n//                w = 1LL * w * wlen % MOD;\n//            }\n//        }\n//    }\n//\n//    if (invert) {\n//        for (int i=0; i<n; ++i)\n//            a[i] = 1LL * a[i] * inv[n] % MOD;\n//    }\n//}\n\nvoid square(vector<int> &a) {\n//    vector<int> fa(a.begin(), a.end());\n//\n//    int n = 1;\n//\n//    while (n<a.size())\n//        n <<= 1;\n//\n//    fa.resize(n);\n//    NTT(a, false);\n//\n//    for (int i=0; i<n; ++i)\n//        fa[i] = 1LL * fa[i] * fa[i] % MOD;\n//    NTT(fa, true);\n\n    vector<int> res(a.size());\n\n    for (int i=0; i<a.size(); ++i) {\n        for (int j=0; i+j<a.size(); ++j) {\n            res[i+j] = (res[i+j] + 1LL * a[i] * a[j]) % MOD;\n        }\n    }\n\n    a = res;\n}\n\nvoid init() {\n//    for (int i=0; i<=n*2; ++i)\n//        inv[i] = pw(i, MOD-2);\n\n    for (int i=0; i<=n; ++i)\n        C[i][0] = C[i][i] = 1;\n\n    for (int i=1; i<=n; ++i) {\n        for (int j=1; j<i; ++j)\n            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;\n    }\n\n    pw2[0] = 1;\n    for (int i=1; i<=n; ++i)\n        pw2[i] = pw2[i-1] * 2 % MOD;\n\n    f[0][0] = 1;\n\n    for (int l=1; l<=n; ++l) {\n        for (int s=0; s<=x; ++s) {\n            f[l][s] = f[l-1][s];\n            if (s>=1)\n                f[l][s] = (f[l][s] + f[l-1][s-1]) % MOD;\n            if (s>=2)\n                f[l][s] = (f[l][s] + f[l-1][s-2]) % MOD;\n        }\n    }\n    // debug(f[n][2]);\n}\n\nint case1() {\n    vector<int> h;\n\n    for (int t=0; t<=x/2; ++t) {\n        h.assign(n+1, 0);\n\n        for (int l=0; l<=n; ++l) {\n            if (l<=t)\n                h[l] = pw2[l];\n            else\n                h[l] = (h[l-1] * 2 - C[l-1][t] + MOD) % MOD;\n        }\n\n        square(h);\n        // if (t==1)\n        //     PR0(h, n+1);\n\n        for (int l=0; l<=n; ++l)\n            g[l][t] = h[l];\n    }\n    // debug(g[2][1]);\n\n    int res = 0;\n\n    for (int l=0; n-l-2>=0; ++l) {\n        for (int s=(x+1)%2; s+2<=x; s += 2) {\n            // cerr << l << ' ' << s << ' ' << f[l][s] * g[n-l-2][(x-2-s)/2] << '\\n';\n            res = (res + 1LL * f[l][s] * g[n-l-2][(x-2-s)/2]) % MOD;\n        }\n    }\n\n    if (x%2==0)\n        res = (res + g[n-1][(x-1)/2]) % MOD;\n    else\n        res = (res + pw2[n]) % MOD;\n\n    return res;\n}\n\nint case2() {\n    int res = 0;\n\n    for (int s=x%2; s<x; s += 2)\n        res = (res + f[n][s]) % MOD;\n\n    return res;\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".in\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tread_input();\n\tinit();\n\t// debug(case1());\n    // debug(case2());\n\tcout << (case1() + case2()) % MOD;\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\n\"\"\"\n・累積和の到達地点集合ごとに見る\n・type1：X未満で終わる\n・type2：X+1以上2X未満\n・type3：2X以上、これはXが奇数の場合のみ\n\"\"\"\n\nMOD = 998244353\n\nN,X = map(int,read().split())\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = N+N+100\nfact,fact_inv = make_fact(U,MOD)\ncombN = fact[N] * fact_inv[:N+1] % MOD * fact_inv[N::-1] % MOD\n\ndef F1(N,X):\n    # X未満で終わる場合\n    def mult(P,Q):\n        # 多項式の積\n        dP = len(P) - 1\n        dQ = len(Q) - 1\n        if dP < dQ:\n            dP,dQ = dQ,dP\n            P,Q = Q,P\n        R = np.zeros(dP+dQ+1,np.int64)\n        for n in range(dQ+1):\n            R[n:n+dP+1] += Q[n] * P % MOD\n        R %= MOD\n        return R[:X]\n    def power(P,n):\n        if n == 0:\n            return np.array([1],dtype=np.int64)\n        Q = power(P,n//2)\n        Q = mult(Q,Q)\n        return mult(P,Q) if n&1 else Q\n    P = np.array([1,1,1],np.int64)\n    Q = power(P,N)\n    return Q.sum() % MOD\n\ndef F2(N,X):\n    x = np.zeros(N+1,np.int64)\n    # X+1+2nで終わる場合\n    for n in range(X):\n        m = (X-1) - (2+2*n)\n        if m < 0:\n            break\n        # 2+2n -> X-1に含まれる2の回数ごとに\n        two = np.arange(m//2+1,dtype=np.int64)\n        one = m - 2*two\n        coef = fact[one+two] * fact_inv[one] % MOD * fact_inv[two] % MOD\n        rest = N-one-two-(2*n+2)\n        ind = rest>=0\n        rest = rest[ind]; coef = coef[ind]\n        x[rest] += coef\n    x %= MOD\n    return (x * combN % MOD).sum() % MOD\n\ndef F3(N,X):\n    # 2X以上の偶数。Xは奇数で、+2を連打している場合\n    if X%2 == 0:\n        return 0\n    if X > N:\n        return 0\n    n = N-X+1\n    return combN[:n].sum() % MOD\n\nanswer = (F1(N,X) + F2(N,X) + F3(N,X)) % MOD\nprint(answer)"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input!{\n        n: usize,\n        x: usize\n    }\n    let d = 998244353;\n    let mut stairs: Vec<usize> = vec![1; n + 1];\n    for i in 1..n + 1 {\n        stairs[i] = (stairs[i - 1] * i) % d;\n    }\n    let stairs_i: Vec<usize> = stairs.iter().map(|&s| inv_m(s, d)).collect();\n    let mut ans = 0;\n    for i in 0..n + 1 {\n        for j in 0..n - i + 1 {\n            let t = i + 2 * j;\n            if t < x {\n                ans += stairs[n] * stairs_i[n - i - j] % d * stairs_i[i] % d * stairs_i[j] % d;\n                ans %= d;\n            } else {\n                let k = (t - x + 1) / 2;\n                if (t - x + 1) % 2 == 1 || i > 0 && 2 * k > j {\n                    continue;\n                } else if 2 * k < x - 1 {\n                    let jj = j - 2 * k;\n                    ans += stairs[n] * stairs_i[n - i - j] % d * stairs_i[i + j] % d * stairs[i + jj] % d * stairs_i[i] % d * stairs_i[jj] % d;\n                    ans %= d;\n                } else if x % 2 == 1 {\n                    ans += stairs[n] * stairs_i[n - i - j] % d * stairs_i[i + j] % d;\n                    ans %= d;\n                }\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn pow_m(n: usize, mut p: usize, d: usize) -> usize {\n    let mut r = n;\n    let mut ret = 1;\n    while p > 0 {\n        if p % 2 == 0 {\n            r = r * r % d;\n            p /= 2;\n        } else {\n            ret = ret * r % d;\n            p -= 1;\n        }\n    }\n    ret\n}\n\nfn inv_m(n: usize, d: usize) -> usize {\n    pow_m(n, d - 2, d)\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/tenka1-2019/tasks/tenka1_2019_f\n//\n#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::*;\nuse std::io::*;\nuse std::str::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: u64 = 998244353;\n\nfn main() {\n    input! {\n        n: usize, x: usize\n    };\n\n    let mut comb = vec![vec![0; 2010]; 2010];\n    for i in 0..comb.len() {\n        comb[i][0] = 1;\n        comb[i][i] = 1;\n        for j in 1..i {\n            let u = comb[i - 1][j - 1];\n            let v = comb[i - 1][j];\n            comb[i][j] = (u + v) % MOD;\n        }\n    }\n\n    let mut ans = 0;\n    for sum in 0..x {\n        for one in 0..sum + 1 {\n            let left = sum - one;\n            if left % 2 == 1 {\n                continue;\n            }\n            let two = left / 2;\n            if one + two > n {\n                continue;\n            }\n            ans += comb[n][one] * comb[n - one][two] % MOD;\n            ans %= MOD;\n        }\n    }\n\n    for sum in x + 1..2 * n + 1 {\n        for one in 1..n + 1 {\n            if sum < one {\n                continue;\n            }\n            let two = (sum - one) / 2;\n            if one + two * 2 != sum {\n                continue;\n            }\n            if one + two > n {\n                continue;\n            }\n            let prefix = (sum - x) / 2 + 1;\n            if (sum - x) % 2 == 0 {\n                continue;\n            }\n            if prefix * 2 > two {\n                continue;\n            }\n            let total = two + one - prefix * 2;\n            ans += comb[n][one + two] * comb[total][one] % MOD;\n            ans %= MOD;\n        }\n        if sum % 2 == 0 && x % 2 != 0 {\n            ans += comb[n][sum / 2];\n            ans %= MOD;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/tenka1-2019/tasks/tenka1_2019_f\n//\n#![allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::*;\nuse std::io::*;\nuse std::str::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: u64 = 998244353;\n\nfn main() {\n    input! {\n        n: usize, x: usize\n    };\n\n    let mut comb = vec![vec![0; 3010]; 3010];\n    for i in 0..comb.len() {\n        comb[i][0] = 1;\n        comb[i][i] = 1;\n        for j in 1..i {\n            let u = comb[i - 1][j - 1];\n            let v = comb[i - 1][j];\n            comb[i][j] = (u + v) % MOD;\n        }\n    }\n\n    let mut ans = 0;\n    for sum in 0..x {\n        for one in 0..sum + 1 {\n            let left = sum - one;\n            if left % 2 == 1 {\n                continue;\n            }\n            let two = left / 2;\n            if one + two > n {\n                continue;\n            }\n            ans += comb[n][one] * comb[n - one][two] % MOD;\n            ans %= MOD;\n        }\n    }\n\n    for sum in x + 1..2 * n + 1 {\n        for one in 1..n + 1 {\n            if sum < one {\n                continue;\n            }\n            let two = (sum - one) / 2;\n            if one + two * 2 != sum {\n                continue;\n            }\n            if one + two > n {\n                continue;\n            }\n            let prefix = (sum - x) / 2 + 1;\n            if (sum - x) % 2 == 0 {\n                continue;\n            }\n            if prefix * 2 > two {\n                continue;\n            }\n            let total = two + one - prefix * 2;\n            ans += comb[n][one + two] * comb[total][one] % MOD;\n            ans %= MOD;\n        }\n        if sum % 2 == 0 && x % 2 != 0 {\n            ans += comb[n][sum / 2];\n            ans %= MOD;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998244353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n// Depends on ModInt.rs\nfn fact_init(w: usize) -> (Vec<ModInt>, Vec<ModInt>) {\n    let mut fac = vec![ModInt::new(1); w];\n    let mut invfac = vec![0.into(); w];\n    for i in 1 .. w {\n        fac[i] = fac[i - 1] * i as i64;\n    }\n    invfac[w - 1] = fac[w - 1].inv();\n    for i in (0 .. w - 1).rev() {\n        invfac[i] = invfac[i + 1] * (i as i64 + 1);\n    }\n    (fac, invfac)\n}\n\n// For backup. This solution won't pass.\n// Challenge: 7 14 -> 2184 (expected: 2186)\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input!(n:usize, x: usize);\n    let (fac, invfac) = fact_init(2 * n + 1);\n    // 12\n    let mut ep = vec![vec![ModInt::new(0); 2 * n + 1]; n + 1];\n    ep[0][0] = ModInt::new(1);\n    for i in 0..n {\n        for j in 0..2 * n + 1 {\n            for k in 1..3 {\n                if j + k <= 2 * n {\n                    ep[i + 1][j + k] += ep[i][j];\n                }\n            }\n        }\n    }\n    let mut epacc = vec![vec![ModInt::new(0); 2 * n + 1]; n + 1];\n    for i in 0..n + 1 {\n        epacc[i][0] = ep[i][0];\n        epacc[i][1] = ep[i][1];\n        for j in 2..2 * n + 1 {\n            epacc[i][j] = epacc[i][j - 2] + ep[i][j];\n        }\n    }\n    let mut gp = vec![vec![ModInt::new(0); 2 * n + 1]; n + 1];\n    gp[1][1] = ModInt::new(1);\n    for i in 0..n - 1 {\n        for j in 0..2 * n - 1 {\n            gp[i + 2][j + 2] = ep[i][j];\n        }\n    }\n    // x |-> 2x2\n    for i in 0..n - 1 {\n        for j in 0..2 * n - 1 {\n            gp[i + 2][j + 2] += gp[i][j];\n        }\n    }\n    let oldgp = gp.clone();\n    // x |-> x2\n    for i in 0..n {\n        for j in 0..2 * n - 1 {\n            gp[i + 1][j + 2] += gp[i][j];\n        }\n    }\n    //eprintln!(\"gp = {:?}\", gp);\n    let mut fp = vec![ModInt::new(0); n + 1];\n    for i in 0..n + 1 {\n        // (0|2)*\n        if x % 2 == 1 || i < x / 2 {\n            fp[i] += 1;\n        }\n        // (0|2)*1(0|2)*\n        // (0|2)*1.*1(0|2)*\n        for j in 0..x {\n            if j % 2 != x % 2 {\n                fp[i] += gp[i][j] * 2 - oldgp[i][j];\n            }\n        }\n        // (0|2)*1(0|2)*\n        if i >= 1 && x % 2 == 1 && 2 * (i - 1) + 1 < x {\n            fp[i] += i as i64;\n        }\n        // (0|2)*1.*1(0|2)*\n        if i >= 2 {\n            for j in 0..i - 1 {\n                if x >= 2 * j + 4 {\n                    fp[i] += epacc[i - j - 2][x - 4 - 2 * j] * (j as i64 + 1);\n                }\n            }\n        }\n    }\n    //eprintln!(\"fp = {:?}\", fp);\n    let mut tot = ModInt::new(0);\n    for i in 0..n + 1 {\n        tot += fp[i] * fac[n] * invfac[n - i] * invfac[i];\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998244353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n// Depends on ModInt.rs\nfn fact_init(w: usize) -> (Vec<ModInt>, Vec<ModInt>) {\n    let mut fac = vec![ModInt::new(1); w];\n    let mut invfac = vec![0.into(); w];\n    for i in 1 .. w {\n        fac[i] = fac[i - 1] * i as i64;\n    }\n    invfac[w - 1] = fac[w - 1].inv();\n    for i in (0 .. w - 1).rev() {\n        invfac[i] = invfac[i + 1] * (i as i64 + 1);\n    }\n    (fac, invfac)\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input!(n:usize, x: usize);\n    let (fac, invfac) = fact_init(2 * n + 1);\n    // 12\n    let mut ep = vec![vec![ModInt::new(0); 2 * n + 1]; n + 1];\n    ep[0][0] = ModInt::new(1);\n    for i in 0..n {\n        for j in 0..2 * n + 1 {\n            for k in 1..3 {\n                if j + k <= 2 * n {\n                    ep[i + 1][j + k] += ep[i][j];\n                }\n            }\n        }\n    }\n    let mut epacc = vec![vec![ModInt::new(0); 2 * n + 1]; n + 1];\n    for i in 0..n + 1 {\n        epacc[i][0] = ep[i][0];\n        epacc[i][1] = ep[i][1];\n        for j in 2..2 * n + 1 {\n            epacc[i][j] = epacc[i][j - 2] + ep[i][j];\n        }\n    }\n    let mut gp = vec![vec![ModInt::new(0); 2 * n + 1]; n + 1];\n    gp[1][1] = ModInt::new(1);\n    for i in 0..n - 1 {\n        for j in 0..2 * n - 1 {\n            gp[i + 2][j + 2] = ep[i][j];\n        }\n    }\n    // x |-> 2x2\n    for i in 0..n - 1 {\n        for j in 0..2 * n - 1 {\n            gp[i + 2][j + 2] += gp[i][j];\n        }\n    }\n    let oldgp = gp.clone();\n    // x |-> x2\n    for i in 0..n {\n        for j in 0..2 * n - 1 {\n            gp[i + 1][j + 2] += gp[i][j];\n        }\n    }\n    //eprintln!(\"gp = {:?}\", gp);\n    let mut fp = vec![ModInt::new(0); n + 1];\n    for i in 0..n + 1 {\n        // (0|2)*\n        if x % 2 == 1 || i < x / 2 {\n            fp[i] += 1;\n        }\n        // (0|2)*1(0|2)*\n        // (0|2)*1.*1(0|2)*\n        for j in 0..x {\n            if j % 2 != x % 2 {\n                fp[i] += gp[i][j] * 2 - oldgp[i][j];\n            }\n        }\n        // (0|2)*1(0|2)*\n        if i >= 1 && x % 2 == 1 && 2 * (i - 1) + 1 < x {\n            fp[i] += i as i64;\n        }\n        // (0|2)*1.*1(0|2)*\n        if i >= 2 {\n            for j in 0..i - 1 {\n                if x >= 2 * j + 4 {\n                    fp[i] += epacc[i - j - 2][x - 4 - 2 * j] * (j as i64 + 1);\n                }\n            }\n        }\n    }\n    //eprintln!(\"fp = {:?}\", fp);\n    let mut tot = ModInt::new(0);\n    for i in 0..n + 1 {\n        tot += fp[i] * fac[n] * invfac[n - i] * invfac[i];\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998244353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n// Depends on ModInt.rs\nfn fact_init(w: usize) -> (Vec<ModInt>, Vec<ModInt>) {\n    let mut fac = vec![ModInt::new(1); w];\n    let mut invfac = vec![0.into(); w];\n    for i in 1 .. w {\n        fac[i] = fac[i - 1] * i as i64;\n    }\n    invfac[w - 1] = fac[w - 1].inv();\n    for i in (0 .. w - 1).rev() {\n        invfac[i] = invfac[i + 1] * (i as i64 + 1);\n    }\n    (fac, invfac)\n}\n\n// For backup. This solution won't pass.\n// Challenge: 7 14 -> 2184 (expected: 2186)\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input!(n:usize, x: usize);\n    let (fac, invfac) = fact_init(2 * n + 1);\n    // 12\n    let mut ep = vec![vec![ModInt::new(0); 2 * n + 1]; n + 1];\n    ep[0][0] = ModInt::new(1);\n    for i in 0..n {\n        for j in 0..n + 1 {\n            for k in 1..3 {\n                if j + k <= 2 * n {\n                    ep[i + 1][j + k] += ep[i][j];\n                }\n            }\n        }\n    }\n    let mut epacc = vec![vec![ModInt::new(0); 2 * n + 1]; n + 1];\n    for i in 0..n + 1 {\n        epacc[i][0] = ep[i][0];\n        epacc[i][1] = ep[i][1];\n        for j in 2..2 * n + 1 {\n            epacc[i][j] = epacc[i][j - 2] + ep[i][j];\n        }\n    }\n    let mut gp = vec![vec![ModInt::new(0); 2 * n + 1]; n + 1];\n    gp[1][1] = ModInt::new(1);\n    for i in 0..n - 1 {\n        for j in 0..2 * n - 1 {\n            gp[i + 2][j + 2] = ep[i][j];\n        }\n    }\n    // x |-> 2x2\n    for i in 0..n - 1 {\n        for j in 0..2 * n - 1 {\n            gp[i + 2][j + 2] += gp[i][j];\n        }\n    }\n    let oldgp = gp.clone();\n    // x |-> x2\n    for i in 0..n {\n        for j in 0..2 * n - 1 {\n            gp[i + 1][j + 2] += gp[i][j];\n        }\n    }\n    //eprintln!(\"gp = {:?}\", gp);\n    let mut fp = vec![ModInt::new(0); n + 1];\n    for i in 0..n + 1 {\n        // (0|2)*\n        if x % 2 == 1 || i < x / 2 {\n            fp[i] += 1;\n        }\n        // (0|2)*1(0|2)*\n        // (0|2)*1.*1(0|2)*\n        for j in 0..x {\n            if j % 2 != x % 2 {\n                fp[i] += gp[i][j] * 2 - oldgp[i][j];\n            }\n        }\n        // (0|2)*1(0|2)*\n        if i >= 1 && x % 2 == 1 && 2 * (i - 1) + 1 < x {\n            fp[i] += i as i64;\n        }\n        // (0|2)*1.*1(0|2)*\n        if i >= 2 {\n            for j in 0..i - 1 {\n                if x >= 2 * j + 4 {\n                    fp[i] += epacc[i - j - 2][x - 4 - 2 * j] * (j as i64 + 1);\n                }\n            }\n        }\n    }\n    //eprintln!(\"fp = {:?}\", fp);\n    let mut tot = ModInt::new(0);\n    for i in 0..n + 1 {\n        tot += fp[i] * fac[n] * invfac[n - i] * invfac[i];\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]