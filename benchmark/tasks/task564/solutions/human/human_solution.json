[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#include <unordered_map>\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, char> pic;\n#define bit(x,v) ((ll)x << v)\n\nconst ll INF = 1000000007;\nconst int MAX = 210000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[100010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (px < py) {\n\t\tpr[py] = px;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int, char> *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF, ' ');\n\tR[n2] = make_pair(INF, ' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char> *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int, char> *a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char> *a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\n\nint n;\nvector<pii> es[100010];\nint ci = 0;\nll P[1000010];\nstruct Node {\n\tint key;\n\tint priority;\n\tNode *parent, *left, *right;\n\tNode(int key, int priority);\n\tNode() {}\n};\nNode NIL;\nNode::Node(int key, int priority) : key(key), priority(priority) {\n\tleft = &NIL;\n\tright = &NIL;\n}\nNode* root = new Node();\nvoid cenrec(Node* k) {\n\tif (k->key == NIL.key) return;\n\tcenrec(k->left);\n\tcout << \" \" << k->key;\n\tcenrec(k->right);\n}\nvoid fastrec(Node* k)\n{\n\tif (k->key == NIL.key) return;\n\tcout << \" \" << k->key;\n\tfastrec(k->left);\n\tfastrec(k->right);\n}\nvoid insert(Node* v) {\n\tNode* y = &NIL;\n\tNode* x = root;\n\twhile (x->key != NIL.key)\n\t{\n\t\ty = x;\n\t\tif (v->key < x->key) {\n\t\t\tx = x->left;\n\t\t}\n\t\telse {\n\t\t\tx = x->right;\n\t\t}\n\t}\n\tv->parent = y;\n\tif (y->key == NIL.key) {\n\t\troot = v;\n\t}\n\telse if (v->key < y->key) {\n\t\ty->left = v;\n\t}\n\telse {\n\t\ty->right = v;\n\t}\n\n}\n\nNode* find(Node* k, ll v)\n{\n\tif (k->key == NIL.key) return &NIL;\n\tif (k->key == v) return k;\n\tif (v < k->key) return find(k->left, v);\n\treturn find(k->right, v);\n}\nvoid delp12(Node* x) {\n\tif (x->key == NIL.key)  return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key == NIL.key\n\t\t&& r->key == NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = &NIL;\n\t\t}\n\t\telse pr->right = &NIL;\n\t}\n\telse if (l->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = l;\n\t\t}\n\t\telse pr->right = l;\n\t\tl->parent = pr;\n\t}\n\telse if (r->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = r;\n\t\t}\n\t\telse pr->right = r;\n\t\tr->parent = pr;\n\t}\n}\nNode* get_next(Node* k) {\n\tif (k->key == NIL.key) return &NIL;\n\tNode* res = get_next(k->left);\n\tif (res->key != NIL.key) return res;\n\treturn k;\n}\nvoid del(Node* x) {\n\n\tif (x->key == NIL.key) return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key != NIL.key && r->key != NIL.key) {\n\t\tNode* nex = get_next(r);\n\t\tx->key = nex->key;\n\t\tdelp12(nex);\n\t}\n\telse {\n\t\tdelp12(x);\n\t}\n}\nNode* rightRotate(Node *t) {\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\nNode* leftRotate(Node *t) {\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\nNode* _insert(Node *t, int key, int priority) {\n\tif (t->key == NIL.key) {\n\t\treturn new Node(key, priority);\n\t}\n\tif (key == t->key) {\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tt->left = _insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse {\n\t\tt->right = _insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\nNode* delete1(Node* t, int key);\nNode* _delete(Node *t, int key) {\n\tif (t->left->key == NIL.key && t->right->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\telse if (t->left->key == NIL.key) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right->key == NIL.key) {\n\t\tt = rightRotate(t);\n\t}\n\telse\n\t{\n\t\tif (t->left->priority > t->right->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn delete1(t, key);\n}\nNode* delete1(Node* t, int key) {\n\tif (t->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\tif (key < t->key) {\n\t\tt->left = delete1(t->left, key);\n\t}\n\telse if (key > t->key) {\n\t\tt->right = delete1(t->right, key);\n\t}\n\telse return _delete(t, key);\n\treturn t;\n}\nint H;\nint left(int i) {\n\treturn i * 2 + 1;\n}\nint right(int i) {\n\treturn i * 2 + 2;\n}\n\nll heap[2000010];\nvoid maxHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint largest = 0;\n\tif (l < H && heap[l] > heap[i])\n\t\tlargest = l;\n\telse\n\t\tlargest = i;\n\tif (r < H && heap[r] > heap[largest])\n\t\tlargest = r;\n\n\tif (largest != i) {\n\t\tswap(heap[i], heap[largest]);\n\t\tmaxHeapify(largest);\n\t}\n}\nint pare(int i) {\n\treturn (i - 1) / 2;\n}\nvoid raise(int i) {\n\tint l = pare(i);\n\tif (l < 0) return;\n\n\tif (heap[l] < heap[i]){\n\t\tswap(heap[i], heap[l]);\n\t\traise(l);\n\t}\n}\nvoid minHeapify(int i) {\n\tint l = left(i);\n\tint r = right(i);\n\tint minimam = 0;\n\tif (l < H && heap[l] < heap[i])\n\t\tminimam = l;\n\telse\n\t\tminimam = i;\n\tif (r < H && heap[r] < heap[minimam])\n\t\tminimam = r;\n\n\tif (minimam != i) {\n\t\tswap(heap[i], heap[minimam]);\n\t\tminHeapify(minimam);\n\t}\n}\nvoid buildMaxHeap() {\n\tfor (int i = H/2; i >= 0; i--)\n\t{\n\t\tmaxHeapify(i);\n\t}\n}\nll lcs(string s1, string s2) {\n\tll dp[1010][1010];\n\tmemset(dp, 0, sizeof(dp));\n\tint s1l = s1.size();\n\tint s2l = s2.size();\n\tfor (size_t i = 1; i <= s1l; i++)\n\t{\n\t\tfor (size_t j = 1; j <= s2l; j++)\n\t\t{\n\t\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[s1l][s2l];\n}\nstruct edge {\n\tll to, cap, rev;\n\tedge(int to,int cap,int rev) : to(to),cap(cap),rev(rev){}\n};\nvector<edge> ed[100010];\nvoid addedge(int f, int t, int c) {\n\ted[f].push_back(edge(t, c, ed[t].size()));\n\ted[t].push_back(edge(f, 0, ed[f].size() - 1));\n}\n\n\n\n\nvoid solv() {\n\tll n;\n\tcin >> n;\n\tdouble p[510],q[510];\n\tfor (size_t i = 1; i <= n; i++)\n\t\tcin >> p[i];\n\tfor (size_t i = 0; i <= n; i++)\n\t\tcin >> q[i];\n\tdouble e[510][510], w[510][510];\n\tint root[510][510];\n\tfor (size_t i = 1; i <= n+1; i++)\n\t{\n\t\te[i][ i - 1] = q[i - 1];\n\t\tw[i][i - 1] = q[i - 1];\n\t}\n\n\tdouble res = 0;\n\tfor (size_t l = 1; l <= n; l++)\n\t{\n\t\tfor (size_t i = 1; i <= n - l + 1; i++)\n\t\t{\n\t\t\tint j = i + l - 1;\n\t\t\te[i][j] = INF;\n\t\t\tw[i][j] = w[i][j - 1] + p[j] + q[j];\n\t\t\tfor (size_t r = i; r <= j; r++)\n\t\t\t{\n\t\t\t\tdouble t = e[i][r - 1] + e[r + 1][j] + w[i][j];\n\t\t\t\tif (t < e[i][j]) {\n\t\t\t\t\te[i][j] = t;\n\t\t\t\t\troot[i][j] = r;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, e[i][j]);\n\n\t\t}\n\t}\n\tcout <<fixed<< res << endl;\n}\n\nint main() {\n\t//\tCOMinit();\n\tsolv();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\n\n\nint main(){\n    ll n;\n    cin>>n;\n    vector<D> ps(n),qs(n+1);\n    cin>>ps>>qs;\n    ll N=2*n+1;\n    vector<D> A(N);\n    for(int i=0;i<n;i++){A[i*2+1]=ps[i];}\n    for(int i=0;i<=n;i++){A[i*2]=qs[i];}\n    for(int i=1;i<N;i++){A[i]+=A[i-1];}\n    auto sum=[&](ll l,ll r){return A[r]-(l==0?0:A[l-1]);};\n    vector<vector<D>> dp(N,vector<D>(N,E));\n    vector<vector<ll>> K(N,vector<ll>(N,0));\n    for(int i=0;i<N;i+=2){dp[i][i]=sum(i,i); K[i][i]=i;}\n    for(int i=2;i<N;i+=2){\n        for(int j=0;j+i<N;j+=2){\n            ll l=K[j][i+j-2],r=K[j+2][i+j];\n            for(ll k=l;k<=r;k++){\n                if(k&1 && j<k && k<i+j && dp[j][i+j]>dp[j][k-1]+dp[k+1][i+j]){\n                    dp[j][i+j]=dp[j][k-1]+dp[k+1][i+j];\n                    K[j][i+j]=k;\n                }\n            }\n            dp[j][i+j]+=sum(j,i+j);\n        }\n    }\n    cout<<fixed<<setprecision(12)<<dp[0].back()<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    double p[n];\n    double q[n + 1];\n    double dp[n + 1][n + 1];\n    for (int i = 0; i < n; i++)\n        cin >> p[i];\n    for (int i = 0; i <= n; i++)\n    {\n        cin >> q[i];\n        dp[i][i] = q[i];\n    }\n    double pSum[n][n];\n    for (int i = 0; i < n; i++)\n    {\n        pSum[i][i] = p[i];\n        for (int j = i + 1; j < n; j++)\n            pSum[i][j] = pSum[i][j - 1] + p[j];\n    }\n    double qSum[n + 1][n + 1];\n    for (int i = 0; i < n + 1; i++)\n    {\n        qSum[i][i] = q[i];\n        for (int j = i + 1; j < n + 1; j++)\n            qSum[i][j] = qSum[i][j - 1] + q[j];\n    }\n    for (int i = 1; i < n + 1; i++)\n    {\n        for (int j = 0; j < n + 1 - i; j++)\n        {\n            dp[j][j + i] = 1145141919;\n            for (int k = 0; k < i; k++)\n            {\n                double tmp = dp[j][j + k] + dp[j + k + 1][j + i] + pSum[j][j + i - 1] + qSum[j][j + i];\n                dp[j][j + i] = min(dp[j][j + i], tmp);\n            }\n        }\n    }\n    printf(\"%.8f\\n\", dp[0][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define MAX 501\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    int n;\n    scanf(\"%d\", &n);\n    double p[MAX], q[MAX];\n    p[0] = -1;\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%lf\", &p[i]);\n    }\n    for (int i = 0; i < n + 1; i++)\n    {\n        scanf(\"%lf\", &q[i]);\n    }\n\n//    const int n = 5;\n//      double p[n + 1] = {-1,0.15,0.1,0.05,0.1,0.2};\n//     double q[n + 1] = {0.05,0.1,0.05,0.05,0.05,0.1};\n\n    double e[MAX][MAX] = {0};\n    double w[MAX][MAX] = {0};\n    for (int i = 1; i <= n + 1; i++)\n    {\n        e[i][i - 1] = q[i - 1];\n        w[i][i - 1] = q[i - 1];\n    }\n\n    int j = 0;\n    for (int l = 1; l <= n; l++)\n    {\n        for (int i = 1; i <= n - l + 1; i++)\n        {\n            j = i + l - 1;\n            e[i][j] = (1 << 21);\n            w[i][j] = w[i][j - 1] + p[j] + q[j];\n            for (int r = i; r <= j; r++)\n            {\n                double t = e[i][r - 1] + e[r + 1][j] + w[i][j];\n                if (t < e[i][j])\n                {\n                    e[i][j] = t;\n                }\n            }\n        }\n    }\n    printf(\"%lf\", e[1][n]);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "import java.io.PrintWriter\nimport java.util.*\n\ndata class PE(var p: Double, var e: Double)\ndata class Node(var center: PE, var left: PE, var right: PE, var lNode: Node?, var rNode: Node?) : Comparable<Node> {\n    override fun compareTo(other: Node): Int {\n        val a = center.e + center.p\n        val o = other.center.e + other.center.p\n        return if (a == o) 0\n        else if( a < o ) -1\n        else 1\n    }\n}\n\nfun main(args: Array<String>) = with(PrintWriter(System.out)) {\n    val n = readLine()!!.toInt()\n    val p = readLine()!!.trim().split(' ').map { it.toDouble() }\n    val q = readLine()!!.trim().split(' ').map { it.toDouble() }\n\n    val list = mutableListOf<Node>()\n    for (i in 0 until n) {\n        val c = p[i]\n        val l = q[i]\n        val r = q[i+1]\n        list.add(Node(PE(c+l+r, c+(l+r)*2), PE(l, l), PE(r, r), null, null))\n    }\n\n    if ( n == 1 ) {\n        print(list[0].center.e)\n        flush()\n        return\n    }\n\n    list[0].rNode = list[1]\n    list[n-1].lNode = list[n-2]\n    for (i in 1 until n-1) {\n        list[i].lNode = list[i-1]\n        list[i].rNode = list[i+1]\n    }\n\n    // pop min e+p\n    val queue = PriorityQueue<Node>(n)\n    queue.addAll(list)\n\n    while (queue.size != 1) {\n        val minNode = queue.poll()\n\n        if (minNode.rNode != null) {\n            val rNode = minNode.rNode!!\n            queue.remove(rNode)\n            rNode.center.p = rNode.center.p - rNode.left.p + minNode.center.p\n            rNode.center.e = rNode.center.e - rNode.left.e - rNode.left.p + minNode.center.e + minNode.center.p\n            rNode.left = minNode.center\n            rNode.lNode = minNode.lNode\n            queue.add(rNode)\n        }\n\n        if (minNode.lNode != null) {\n            val lNode = minNode.lNode!!\n            queue.remove(lNode)\n            lNode.center.p = lNode.center.p - lNode.right.p + minNode.center.p\n            lNode.center.e = lNode.center.e - lNode.right.e - lNode.right.p + minNode.center.e + minNode.center.p\n            lNode.right = minNode.center\n            lNode.rNode = minNode.rNode\n            queue.add(lNode)\n        }\n    }\n\n    val minNode = queue.poll()\n    println(minNode.center.e)\n    flush()\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n\n#define N 501\n\nusing namespace std;\n\nint main() {\n    int n;\n    double p[N], q[N];\n    double pSum[N][N], qSum[N][N];\n    double d[N][N];\n    double t;\n    \n    //標準入力から要素数を取得\n    cin >> n;\n    \n    for(int i = 0; i < n; ++i) {\n        //p[0]には代入しない\n        //標準入力から探索確率を取得\n        cin >> p[i];\n    }\n    \n    for(int i = 0; i < n + 1; ++i) {\n        //標準入力からダミーキーで探索終了する確率を取得\n        cin >> q[i];\n        \n        //行列dの対角成分としてq[i]を格納\n        d[i][i] = q[i];\n    }\n    \n    //\n    for(int i = 0; i < n; ++i) {\n        pSum[i][i] = p[i];\n        \n        for(int j = i + 1; j < n; ++j) {\n            pSum[i][j] = pSum[i][j - 1] + p[j];\n        }\n    }\n    for(int i = 0; i < n + 1; ++i) {\n        qSum[i][i] = q[i];\n        for(int j = i + 1; j < n + 1; ++j) {\n            qSum[i][j] = qSum[i][j - 1] + q[j];\n        }\n    }\n    \n    for(int i = 1; i < n + 1; ++i) {\n        for(int j = 0; j < (n + 1) - i; ++j) {\n            d[j][j + i] = __DBL_MAX__;\n            \n            for(int k = 0; k < i; ++k) {\n                t = d[j][j + k] + d[j + k + 1][j + i] + pSum[j][j + i - 1] + qSum[j][j + i];\n                d[j][j + i] = min(d[j][j + i], t);\n            }\n        }\n    }\n    \n    printf(\"%.8lf\\n\", d[0][n]);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 分からなかったので他の人の回答を見た\n#include<iostream>\n#include<iomanip>\n#include<vector>\nusing namespace std;\n\ndouble OptimalBSTree(const vector<double>& p, const vector<double>& q, const int n){\n    vector<vector<double>> psum(n, vector<double>(n));\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n - i; j++){\n\t\t\tif(i == 0){\n\t\t\t\tpsum[j][j] = p[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpsum[j][j + i] = psum[j][j + i - 1] + p[j + i];\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<double>> qsum(n + 1, vector<double>(n + 1));\n\tfor(int i = 0; i < n + 1; i++){\n\t\tfor(int j = 0; j < n + 1 - i; j++){\n\t\t\tif(i == 0){\n\t\t\t\tqsum[j][j] = q[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tqsum[j][j + i] = qsum[j][j + i - 1] + q[j + i];\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble et = 0.0;\n\tvector<vector<double>> dp(n + 1, vector<double>(n + 1, 0));\n\tfor(int i = 0; i < n + 1; i++){\n\t\tfor(int j = 0; j < n + 1 - i; j++){\n\t\t\tif(i == 0){\n\t\t\t\tdp[j][j] = q[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble min;\n\t\t\t\tfor (int k = 0; k < i; k++){\n\t\t\t\t\tet = dp[j][j + k] + dp[j + k + 1][j + i] + psum[j][i + j - 1] + qsum[j][i + j];\n\t\t\t\t\tif (k == 0 || et < min) min = et;\n\t\t\t\t}\n\t\t\t\tdp[j][j + i] = min;\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n];\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n    // n 個の各キーに対して探索が起きる確率 p\n    // n+1 個の各ダミーキーで探索が終わる確率 q\n\tvector<double> p(n), q(n + 1);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> p[i];\n\t}\n\tfor(int i = 0; i < n + 1; i++){\n        cin >> q[i];\n\t}\n\n    cout << fixed << setprecision(4) << OptimalBSTree(p, q, n) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nint N;\nint P[600];\nint Q[600];\nint S[600][2];\nint dp[600][600];\n\nint input10000(){\n double x; scanf(\"%lf\",&x);\n return floor(x*10000+0.5);\n}\n\nint main() {\n scanf(\"%d\",&N);\n rep(i,N) P[i]=input10000(); P[N]=-1;\n rep(i,N+1) Q[i]=input10000(); Q[N+1]=-1;\n\n S[0][0]=S[0][1]=0;\n for(int i=1; i<=N; i++){\n  S[i][0]=S[i-1][1]+Q[i-1];\n  S[i][1]=S[i][0]+P[i-1];\n }\n S[N+1][0]=S[N][1]+Q[N];\n\n rep(i,N+2) rep(j,N+2) dp[i][j]=1000000000;\n rep(i,N+1) dp[i][i+1]=0;\n\n rep(d,N+2) rep(p,N+2-d){\n  if(d<2) continue;\n  for(int s=p+1; s<p+d; s++){\n   int tmp=0;\n   tmp += dp[p][s] + S[s][0]-S[p][1];\n   tmp += dp[s][p+d] + S[p+d][0]-S[s][1];\n   dp[p][p+d] = min(dp[p][p+d],tmp);\n  }\n }\n\n double ans=dp[0][N+1];\n ans = (ans/10000.0)+1.0;\n printf(\"%.10f\\n\",ans);\n \n return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <list>\n#include <bitset>\n#include <vector>\nusing namespace std;\n\n#define I64d_OJ\n\n//#ifdef I64d_OJ\n//#define LL __int64\n//#endif // I64d_OJ\n#ifdef I64d_OJ\n#define LL long long\n#endif // I64d_OJ\n\ntypedef unsigned LL ULL;\ntypedef unsigned uint;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vi;\n\ninline LL read(){\n    LL x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-') f=-f; ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n    return x*f;\n}\n\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define ls rt<<1\n#define rs rt<<1|1\n#define MID(a,b) (((LL)(a)+(LL)(b))>>1)\n#define absx(a) ((a)<0?-(a):(a))\n#define MK(a,b) make_pair(a,b)\n#define PB(a) push_back(a)\n#define lowbit(x) ((x)&-(x))\n\ntemplate< typename T >\ninline void Max(T &a,T &b){if(a<b) a=b;}\ntemplate< typename T>\ninline void Min(T &a,T &b){if(a>b) a=b;}\n\nconst double pi=(double)acos(-1.0);\nconst double eps=(double)1e-10;\nconst int INF = (int) 0x3f3f3f3f;\nconst int MOD = (int) 1e9+7;\nconst int MAXN =(int) 5e2+10;\nconst int MAXM = (int) 2e5+10;\nconst int sigma_size = (int) 26;\n\n///--------------------START-------------------------\nint n;\ndouble p[MAXN],q[MAXN];\ndouble f[MAXN][MAXN];\ndouble sump[MAXN],sumq[MAXN];\n\nvoid work(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%lf\",&p[i]);\n    for(int i=0;i<=n;i++) scanf(\"%lf\",&q[i]);\n    sumq[0]=q[0];\n    for(int i=1;i<=n;i++) sump[i]=sump[i-1]+p[i],sumq[i]=sumq[i-1]+q[i];\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            f[i][j]=1.0*INF;\n            if(j<i) f[i][j]=0.0;\n        }\n    }\n    for(int len=1;len<=n;len++){\n        for(int i=1;i+len-1<=n;i++){\n            int j=i+len-1;\n            for(int k=i;k<=j;k++){\n                double tsum=sump[j]-sump[i-1];\n                if(i==1) tsum+=sumq[j];\n                else tsum+=sumq[j]-sumq[i-2];\n                f[i][j]=min(f[i][j],tsum-p[k]+f[i][k-1]+f[k+1][j]);\n            }\n        }\n    }\n    printf(\"%.8lf\\n\",f[1][n]+sump[n]+sumq[n]);\n}\n/*\n5\n0.1500 0.1000 0.0500 0.1000 0.2000\n0.0500 0.1000 0.0500 0.0500 0.0500 0.1000\n\n7\n0.0400 0.0600 0.0800 0.0200 0.1000 0.1200 0.1400\n0.0600 0.0600 0.0600 0.0600 0.0500 0.0500 0.0500 0.0500\n*/\n///--------------------END-------------------------\nint main(){\n#ifdef NNever\n//freopen(\"data.in\",\"r\",stdin);\n///freopen(\"out.txt\",\"w\",stdout);\n#endif // NNever\n    work();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <map>\n#include <climits>\n#include <stack>\n#include <string>\n#include <random>\n#include<set>\n#include <iomanip>\n#include <climits>\n\nclass Probability {\n\tstd::vector<double> key_probabilities, dummy_probabilities;\npublic:\n\tProbability(const std::vector<double> &keys, const std::vector<double> &dummies) {\n\t\tkey_probabilities.push_back(0); dummy_probabilities.push_back(0);\n\t\tfor (const auto k : keys) {\n\t\t\tkey_probabilities.push_back(key_probabilities.back() + k);\n\t\t}\n\t\tfor (const auto d : dummies) {\n\t\t\tdummy_probabilities.push_back(dummy_probabilities.back() + d);\n\t\t}\n\t}\n\tdouble sum_key(const int from, const int until) const {\n\t\treturn key_probabilities[until] - key_probabilities[from];\n\t}\n\tdouble sum_dummy(const int from, const int until) const {\n\t\treturn dummy_probabilities[until] - dummy_probabilities[from];\n\t}\n\tdouble key(const int position) const {\n\t\treturn key_probabilities[position + 1] - key_probabilities[position];\n\t}\n\tdouble dummy(const int position) const {\n\t\treturn dummy_probabilities[position + 1] - dummy_probabilities[position];\n\t}\n};\nconstexpr double NA = -1;\ndouble sub_sequence(const int from, const int until, std::vector<std::vector<double>> &memo, const Probability &prob) {\n\tif (from == until) return prob.dummy(from);\n\tif (memo[from][until - from - 1] != NA) return memo[from][until - from - 1];\n\tdouble min = 500 * 500;\n\tfor (auto mid = from; mid < until; ++mid) {\n\t\tauto seq = sub_sequence(from, mid, memo, prob) + sub_sequence(mid + 1, until, memo, prob) + prob.sum_key(from, until) + prob.sum_dummy(from, until + 1);\n\t\tif (min > seq) min = seq;\n\t}\n\treturn memo[from][until - from - 1] = min;\n}\nint main() {\n\tint n; std::cin >> n;\n\tstd::vector<double> key(n); for (auto &k : key) std::cin >> k;\n\tstd::vector<double> dummy(n + 1); for (auto &d : dummy) std::cin >> d;\n\tProbability sum(key, dummy);\n\tstd::vector<std::vector<double>> memo;\n\tfor (auto i = 0; i < n; ++i) {\n\t\tmemo.push_back(std::vector<double>(n - i, NA));\n\t}\n\tstd::cout << sub_sequence(0, n, memo, sum) << std::endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INFTY (1<<30)\n\nint n;\ndouble p[550], q[550], M[550][550], P[550][550];\n\nvoid setP( void ) {\n  for ( int i = 0; i < n + 1; i++ ) P[i][i] = q[i];\n  for ( int i = 0; i < n; i++ ) {\n    for ( int j = i + 1; j < n + 1; j++ ) P[i][j] = P[i][j - 1] + p[j] + q[j];\n  }\n}\n\nvoid setM( void ) {\n  for ( int i = 0; i < n + 1; i++ ) M[i][i] = q[i];\n  for ( int l = 1; l < n + 1; l++ ) {\n    for ( int i = 0; i < n - l + 1; i++ ) {\n      int j = i + l;\n      M[i][j] = INFTY;\n      for ( int k = i + 1; k < j + 1; k++ ) {\n        M[i][j] = min(M[i][j], M[i][k - 1] + M[k][j] + P[i][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n;\n  for ( int i = 1; i < n + 1; i++ ) cin >> p[i];\n  for ( int i = 0; i < n + 1; i++ ) cin >> q[i];\n  \n  setP();\n  setM();\n\n  cout << M[0][n] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n\n#define FOR(i, n, m) for(ll (i)=(m);(i)<(n);++(i))\n#define REP(i, n) FOR(i,n,0)\n#define OF64 std::setprecision(40)\n\nconst ll MOD = 1000000007;\nconst ll INF = (ll) 1e15;\n\nlong double P[505], Q[505];\nlong double dp[505][505];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    REP(i, N) {\n        cin >> P[i];\n    }\n    REP(i, N + 1) {\n        cin >> Q[i];\n    }\n\n    REP(i, N + 1) {\n        REP(j, N + 1) {\n            dp[i][j] = INF;\n        }\n    }\n\n    REP(len, N) {\n        REP(left, N) {\n            if (left + len >= N)\n                break;\n\n            long double sum = Q[left + len + 1];\n            REP(i, len + 1) {\n                sum += P[left + i] + Q[left + i];\n            }\n            REP(i, len + 1) {\n                //! 頂点iをroot\n                long double p = sum;\n                if (i == 0)\n                    p += Q[left + i];\n                else\n                    p += dp[left][left + i - 1];\n\n                if (i == len)\n                    p += Q[left + i + 1];\n                else\n                    p += dp[left + i + 1][left + len];\n\n                dp[left][left + len] = std::min(dp[left][left + len], p);\n            }\n        }\n    }\n\n    cout << OF64 << dp[0][N - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    /*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\nusing P = pair<ll, ll>;\nconst int MOD = (int)1e9 + 7;\nconst ll INF = 1LL << 60;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n\n    }\n    os << \"\\n\";\n    return os;\n}\n\nld solve(vector<ld>& P, int N){\n    /*\n        区間[s,t]をiで分割する\n        　　　i\n        　子    子\n        ・・・　・・・\n        にする(今回はダミーは関節点に来ないことに注意)\n    \n        すると、dp[s][t] = min(dp[s][i-1] + dp[i+1][t]) + (s~tのコストの和)で表せる  (s<i<t かつ　実際の(ダミーでない)ノード)\n    */\n   vector<vector<ld>> dp(N,vector<ld>(N,1<<30)); \n    for(int i=0;i<N;i++) dp[i][i] = P[i]; \n    \n    vector<ld> cumsum(N+1,0);\n    REP(i,N) {cumsum[i+1]=cumsum[i]+P[i];}  //累積和(s~tのコストの和をO(1)で使うために)\n    for(int i=2 ;i<N;i+=2){ \n        for(int left=1;left < N-i;left+=2){ // ダミー,...,ダミーを単位としてやる\n            int right = left + i; //区間右端(閉)\n            for(int mid = left+1; mid<right; mid+=2){ //ダミーは関節点に来ない\n                chmin(dp[left][right], dp[left][mid-1] + dp[mid+1][right]); //上記の分割\n            }\n            dp[left][right] += cumsum[right+1]-cumsum[left];\n        }\n    }\n    ld res = dp[1][N-1]; //1-indexに注意\n    return res;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    int L = 2*(N+1);  \n    vector<ld> P(L,0);//1-index   DVDVDVDVDVDVDVDVD (D:ダミー,V:実際の)\n    REP(i,N) cin >> P[2*(i+1)];\n    REP(i,N+1) cin >> P[2*i+1];\n\n    ld ans=solve(P,L);\n    cout << fixed<<setprecision(10)<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cfloat>\nusing namespace std;\nint main(){\n        int n;\n        cin>>n;\n        double p[n], q[n+1];\n        for(int i=0;i<n;i++) cin>>p[i];\n        for(int i=0;i<n+1;i++) cin>>q[i];\n\n        double dp[n+1][n+1];\n        double psum[n][n];\n        double qsum[n+1][n+1];\n        for(int i=0;i<n+1;i++) dp[i][i] = q[i];\n        for(int i=0;i<n;i++) {\n                psum[i][i] = p[i];\n                for(int j=i+1;j<n;j++){\n                        psum[i][j] = psum[i][j-1]+p[j];\n                }\n        }\n        for(int i=0;i<n+1;i++) {\n                qsum[i][i] = q[i];\n                for(int j=i+1;j<n+1;j++){\n                        qsum[i][j] = qsum[i][j-1]+q[j];\n                }\n        }\n\n        for(int i=1;i<n+1;i++){\n                for(int j=0;j+i<n+1;j++){\n                        dp[j][j+i] = DBL_MAX;\n                        for(int k=0;k<i;k++){\n                                double tmp = dp[j][j+k]+dp[j+k+1][j+i]+psum[j][j+i-1]+qsum[j][j+i];\n                                dp[j][j+i] = min(dp[j][j+i], tmp);\n                        }\n                }\n        }\n        cout<<dp[0][n]<<endl;\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <float.h>\n\nint main() {\n\tint n;\n\tstd::cin >> n;\n\tstd::vector<double> p(n, 0);\n\tstd::vector<double> q(n + 1, 0);\n\tstd::vector<std::vector<double>> CostMat(n, std::vector<double>(n, 0));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tstd::cin >> p[i];\n\t}\n\tfor (int i = 0; i < n + 1; i++) {\n\t\tstd::cin >> q[i];\n\t}\n\n\t// 対角成分\n\tfor (int i = 0; i < n; i++) {\n\t\tCostMat[i][i] = p[i] + 2.0 * q[i] + 2.0 * q[i + 1];\n\t}\n\n\t// 動的計画法により最小コストを求める\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\tdouble min = DBL_MAX;\n\t\t\tfor (int l = 0; l <= i; l++) {\n\t\t\t\tdouble tmp = 0;\n\t\t\t\tif (l != i) {\n\t\t\t\t\ttmp += CostMat[j + l + 1][i + j];\n\t\t\t\t}\n\t\t\t\tif (l != 0) {\n\t\t\t\t\ttmp += CostMat[j][j + l - 1];\n\t\t\t\t}\n\t\t\t\tif (l == 0) {\n\t\t\t\t\ttmp += q[j];\n\t\t\t\t}\n\t\t\t\tif (l == i) {\n\t\t\t\t\ttmp += q[j + i + 1];\n\t\t\t\t}\n\t\t\t\tif (tmp < min) {\n\t\t\t\t\tmin = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//std::cout << min << std::endl;\n\t\t\tCostMat[j][i + j] = min;\n\t\t\tfor (int k = j; k <= j + i; k++) {\n\t\t\t\tCostMat[j][i + j] += p[k] + q[k];\n\t\t\t}\n\t\t\tCostMat[j][i + j] += q[j + i + 1];\n\t\t}\n\t}\n\n\tstd::cout << CostMat[0][n - 1] << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stdio.h>\nusing namespace std;\n\nstatic const int INFTY = 20001;\n\ndouble w[510][510];\ndouble e[510][510];\nint root[510][510];\n\nint main(){\n\n    int n;\n    double P, Q, t; //グローバル変数にする必要がある\n    vector<double> p, q;\n    \n    //入力処理\n    cin >> n;\n    p.push_back(0);\n    for(int i=0; i<n; i++){\n        cin >> P;\n        p.push_back(P); \n    }\n    for(int i=0; i<n+1; i++){\n        cin >> Q;\n        q.push_back(Q);\n    }\n\n    for(int i=1; i<=n+1; i++){\n        e[i][i-1] = q[i-1];\n        w[i][i-1] = q[i-1];\n    }\n    for(int l=1; l<=n; l++){\n        for(int i=1; i<=n-l+1; i++){\n            int j = i + l - 1;\n            e[i][j] = 20001;\n            w[i][j] = w[i][j-1] + p[j] + q[j];\n            for(int k=i; k<=j; k++){\n                t = e[i][k-1] + e[k+1][j] + w[i][j];    //期待値\n                if(t < e[i][j]){    //最小値を探す\n                    e[i][j] = t;\n                    root[i][j] = k;\n                }\n            }\n        }\n    }\n    printf(\"%.8lf\\n\", e[1][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<double> p(n),q(n+1);\n  for(Int i=0;i<n;i++) cin>>p[i];\n  for(Int i=0;i<=n;i++) cin>>q[i];\n\n  static double dp[555][555];\n  for(Int i=0;i<555;i++)\n    for(Int j=0;j<555;j++) dp[i][j]=-1;\n\n  function<double(Int, Int)> dfs=\n    [&](Int l,Int r)->double{\n      double &res=dp[l][r];\n      if(res>=0) return res;\n      res=1e18;\n      \n      double s=0;\n      for(Int i=l;i<r;i++) s+=p[i];\n      for(Int i=l;i<=r;i++) s+=q[i];\n\n      for(Int i=l;i<r;i++){\n\tdouble tmp=s;\n\ttmp+=i==l?q[l]:dfs(l,i);\n\ttmp+=i+1==r?q[r]:dfs(i+1,r);\n\tchmin(res,tmp);\n      }\n      \n      return res;\n    };\n  \n  cout<<dfs(0,n)<<endl;  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define floot10 cout<<fixed<<setprecision(10);\n#define int long long\n\ndouble p[5000],q[5000],sump[5000],sumq[5000];\ndouble memo[5000][5000];\n\nsigned main(){\n\tfloot10;\n\tint n;\n\tcin>>n;\n\tlp(i,n) cin>>p[i+1];\n\tlp(i,n+1) cin>>q[i];\n\tsumq[0]=q[0];\n\tlp(i,n){\n\t\tsump[i+1]=sump[i]+p[i+1];\n\t\tsumq[i+1]=sumq[i]+q[i+1];\n\t}\n\tlps(i,1,n+1){\n\t\tlps(j,1,n+1){\n\t\t\tif(j>=i)memo[i][j]=INF;\n\t\t\telse memo[i][j]=0;\n\t\t}\n\t}\n\tlps(l,1,n+1){\n\t\tlps(i,1,n+2-l){\n\t\t\tint j=i+l-1;\n\t\t\tlps(k,i,j+1){\n\t\t\t\tdouble sum=sump[j]-sump[i-1];\n\t\t\t\tif(i==1) sum+=sumq[j];\n\t\t\t\telse{\n\t\t\t\t\tsum+=sumq[j]-sumq[i-2];\n\t\t\t\t}\n\t\t\t\tmemo[i][j]=min(memo[i][j],sum-p[k]+memo[i][k-1]+memo[k+1][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<memo[1][n]+sump[n]+sumq[n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define NIL NULL\n#define INF 1000000001\n\nusing namespace std;\n\nint main(){\n    // ---- iput ---- //\n    int n;\n    float temp;\n    scanf(\"%d\",&n);\n    vector<float> p(n,0);\n    vector<float> q(n+1,0);\n    vector<vector<float> > cost(n+1,vector<float>(n+1,INF));\n    for(int i = 0;i < n;i++){\n        scanf(\"%f\",&temp);\n        p[i] = temp;\n    } \n    for(int i = 0;i < n+1;i++){\n        scanf(\"%f\",&temp);\n        q[i] = temp;\n    } \n\n    for(int k = 0;k < n+1;k++){\n        for(int i = 0;i < n-k+1;i++){\n            int j = i + k;\n            float w = q[i];\n            if(j == i) cost[i][j] = w;\n            else{\n                for(int l =i+1;l <= j;l++) w += q[l]+p[l-1];\n                for(int l =i;l < j;l++){\n                    cost[i][j] = min(cost[i][j],cost[i][l]+cost[l+1][j] + w);\n                }\n            } \n        }\n    }\n    printf(\"%.5f\\n\",cost[0][n]);\n    return 0;   \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long    ll;\ntypedef pair<ll, ll> l_l;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n// const ll mod = 1000000007;5\ndouble dp[505][505];\nint    n;\ndouble p[505];\ndouble q[505];\ndouble psum[505];\ndouble qsum[505];\n\ndouble search(int l, int r) {\n    if (dp[l][r] != 0) return dp[l][r];\n    if (l == r) {\n        return dp[l][r] = 0;\n    }\n    dp[l][r]     = 1e9;\n    double total = qsum[r] - qsum[l - 1] + psum[r] - psum[l];\n    for (int x = l + 1; x <= r; x++) {\n        double left  = qsum[x - 1] - qsum[l - 1] + psum[x - 1] - psum[l];\n        double right = total - left - p[x];\n        double now   = (search(l, x - 1) + 1) * (left / total) +\n                     (search(x, r) + 1) * (right / total);\n        dp[l][r] = min(dp[l][r], now);\n    }\n    return dp[l][r];\n}\n\nint main() {\n    cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 2; i <= n + 1; i++) cin >> p[i];\n    for (int i = 1; i <= n + 1; i++) cin >> q[i];\n    for (int i = 1; i <= n + 1; i++) psum[i] = psum[i - 1] + p[i];\n    for (int i = i; i <= n + 1; i++) qsum[i] = qsum[i - 1] + q[i];\n    cout << 1.0 + search(1, n + 1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing ld = long double;\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\nint N;\nvector<ld> psum;\n\nld rec(int l, int r) {\n    if (l == r) return psum[r] - psum[l - 1];\n    static auto dp = Vec<ld>((N + 1) * 2, (N + 1) * 2, -1.L);\n    if (dp[l][r] >= 0) return dp[l][r];\n\n    dp[l][r] = 1e30;\n    for (int p = l + 1; p < r; p += 2) {\n        dp[l][r] = min(dp[l][r], rec(l, p - 1) + rec(p + 1, r));\n    }\n    return dp[l][r] += psum[r] - psum[l - 1];\n}\n\nint main() {\n    cin >> N;\n    psum.resize((N + 1) * 2);\n    psum[0] = 0;\n    for (int i = 1; i <= N; ++i) cin >> psum[i * 2];\n    for (int i = 0; i <= N; ++i) cin >> psum[i * 2 + 1];\n    for (int i = 1; i < (N + 1) * 2; ++i) psum[i] += psum[i - 1];\n\n    cout << fixed << setprecision(10) << rec(1, N * 2 + 1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define EPS (1e-7)\n#define INF (1e9)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\nconst double PI = acos(-1);\nconst ll MOD = 1000000007;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n  int N; cin >> N;\n  vector<double> p(N),q(N+1);\n  rep(i,N) cin >> p[i];\n  rep(i,N+1) cin >> q[i];\n\n  vector<vector<double>> dp(N+1, vector<double>(N+1,INF)); \n  vector<vector<int>> key(N+1, vector<int>(N+1));\n  rep(i,N+1) {\n    dp[i][i] = q[i];\n    key[i][i] = i;\n  }\n  vector<double> sumw(N+2),sump(N+1);\n  rep(i,N+1) {\n    if (i == 0) {\n      sumw[1] = q[0];\n      sump[1] = p[0];\n    } else {\n      sumw[i+1] = sumw[i] + q[i];\n      if (i != N)sump[i+1] = sump[i] + p[i];\n    }\n  }\n\n  for (int k = 1; k < N+1; k++) {\n    for (int i = 0; i < N+1-k; i++) {\n      for (int j = key[i][i+k-1]; j <= min(key[i+1][i+k],N-1); j++) {\n        if (chmin(dp[i][i+k],dp[i][j] + dp[j+1][i+k])) key[i][i+k] = j;\n      }\n      dp[i][i+k] += (sumw[i+k+1] - sumw[i] + sump[i+k] - sump[i]);\n    }\n  }\n  \n  cout << fixed << setprecision(10) << dp[0][N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nfloat OptimalBSTree(vector<float> p, vector<float> q){\n\tint n = p.size();\n\n\tvector< vector<float> > psum(n, vector<float>(n, 0));\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n - i; j++){\n\t\t\tif (i == 0){\n\t\t\t\tpsum[j][j] = p[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpsum[j][j + i] = psum[j][j + i - 1] + p[j + i];\n\t\t\t}\n\t\t}\n\t}\n\tvector< vector<float> > qsum(n + 1, vector<float>(n + 1, 0));\n\tfor (int i = 0; i < n + 1; i++){\n\t\tfor (int j = 0; j < n + 1 - i; j++){\n\t\t\tif (i == 0){\n\t\t\t\tqsum[j][j] = q[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tqsum[j][j + i] = qsum[j][j + i - 1] + q[j + i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat et;\n\tvector< vector<float> > table(n + 1, vector<float>(n + 1, 0));\n\tfor (int i = 0; i < n + 1; i++){\n\t\tfor (int j = 0; j < n + 1 - i; j++){\n\t\t\tif (i == 0){\n\t\t\t\ttable[j][j] = q[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfloat min;\n\t\t\t\tfor (int k = 0; k < i; k++){\n\t\t\t\t\tet = table[j][j + k] + table[j + k + 1][j + i] + psum[j][i + j - 1] + qsum[j][i + j];\n\t\t\t\t\tif (k == 0 || et < min) min = et;\n\t\t\t\t}\n\t\t\t\ttable[j][j + i] = min;\n\t\t\t}\n\t\t}\n\t}\n\treturn table[0][n];\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<float> p(n), q(n + 1);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%f\", &p[i]);\n\t}\n\tfor (int i = 0; i < n + 1; i++){\n\t\tscanf(\"%f\", &q[i]);\n\t}\n\tprintf(\"%f\\n\", OptimalBSTree(p, q));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX 100005\n#define INF INT_MAX\n\nvector<double> p, q;\nvector< vector<double> > memo1; // 部分木の値(深さで重みづけ済み)\nvector< vector<double> > memo2; // 部分木の値(深さで重みづけなし)\n\ndouble obst(int l, int r)\n{\n    if (memo1[l][r]) return memo1[l][r];\n    if (l == r) {\n        memo1[l][r] = memo2[l][r] = q[l];\n        return q[l];\n    }\n\n    double res = DBL_MAX;\n\n    rep(i,r-l) {\n        double lt = obst(l,l+i);\n        double rt = obst(l+i+1,r);\n        double rowt = p[l+i+1] + memo2[l][l+i] + memo2[l+i+1][r];\n        double mg = rowt + rt + lt;\n        if (mg < res) {\n            res = mg;\n            memo2[l][r] = rowt;\n        }\n    }\n\n    memo1[l][r] = res;\n    return res;\n}\n\nint main(int, char**)\n{\n    int n;\n    cin >> n;\n    p.assign(n+1, 0);\n    q.assign(n+1, 0);\n    memo1.assign(n+1, vector<double>(n+1, 0));\n    memo2.assign(n+1, vector<double>(n+1, 0));\n\n    rep(i,n) cin >> p[i+1];\n    rep(i,n+1) cin >> q[i];\n\n    printf(\"%.10f\",obst(0, n));  \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n//#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\nconst double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 10;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n\nbool contain(set<char> &s, int a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\ntypedef pair<double, double> P;\n\nvoid print_line(vector<int> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\nconst int mod = 1000000007;\n\nint main() {\n    int n;\n\n\n    cin >> n;\n    vector<P> ks(n + 1, P(0, 0));\n    vector<vector<double>> p_sum(n + 1, vector<double>(n + 1, 0));\n    vector<vector<double>> q_sum(n + 1, vector<double>(n + 1, 0));\n    vector<vector<double>> dp(n + 1, vector<double>(n + 1, 0));;\n\n    for (int i = 0; i < n; ++i) cin >> ks[i].first;\n    for (int i = 0; i < n + 1; ++i) cin >> ks[i].second;\n    for (int i = 0; i < n + 1; ++i) dp[i][i] = ks[i].second;\n\n    for (int i = 0; i < n; ++i) {\n        p_sum[i][i] = ks[i].first;\n        for (int j = i + 1; j < n; ++j) {\n            p_sum[i][j] = p_sum[i][j - 1] + ks[j].first;\n        }\n    }\n\n    for (int i = 0; i < n + 1; ++i) {\n        q_sum[i][i] = ks[i].second;\n        for (int j = i + 1; j < n + 1; ++j) {\n            q_sum[i][j] = q_sum[i][j - 1] + ks[j].second;\n        }\n    }\n\n    for (int i = 1; i < n + 1; ++i) {\n        for (int j = 0; j < (n + 1) - i; ++j) {\n            dp[j][j + i] = INF;\n            for (int k = 0; k < i; ++k) {\n                double t = dp[j][j + k] + dp[j + k + 1][j + i] + p_sum[j][j + i - 1] + q_sum[j][j + i];\n                dp[j][j + i] = min(dp[j][j + i], t);\n            }\n        }\n    }\n\n    printf(\"%.20f\\n\", dp[0][n]);\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\nvector<double> p, q;\n\ndouble memo[504][504];\ndouble psum[504];\ndouble qsum[504];\n\n// [l,r)の木を構成した時に含まれる p,qの和\ndouble sum(int l, int r) {\n  assert(r > l);\n  return psum[r] - psum[l] + qsum[r] - qsum[l - 1];\n}\n\n// [l, r)の区間について木にした時のコスト期待値\ndouble dfs(int l, int r) {\n  // 1個の時\n  if (l + 1 == r) {\n    // 今の深さ × p, 次の深さ x q (ダミーノード分)\n    return p[l] + 2 * (q[l - 1] + q[l]);\n  }\n  if (memo[l][r] != -1) return memo[l][r];\n\n  double ret = INF;\n  // m を根にする分け方\n  for (int m = l; m < r; m++) {\n    double root, left, right;\n    // 根の分\n    root  = p[m];\n    // 左部分木\n    if (l == m) left  = 2 * q[l - 1];          // 端なのでダミー\n    else        left  = dfs(l, m) + sum(l, m); // [l,m)の木の解 + l~mまでの和([l,m)の木の深さを1つ増やす)\n\n    // 右部分木\n    if (r - 1 == m) right = 2 * q[r - 1];      // 端なのでダミー\n    else            right = dfs(m + 1, r) + sum(m + 1, r);\n    \n    ret = min(ret, root + left + right);\n  }\n  return memo[l][r] = ret;\n}\n\nint main(void) {\n  int n;\n  cin >> n;\n  p = vector<double>(n + 1);\n  q = vector<double>(n + 1);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i + 1];\n    psum[i + 2] += psum[i + 1] + p[i + 1];\n  }\n  for (int i = 0; i < n + 1; i++) {\n    cin >> q[i];\n    qsum[i + 1] += qsum[i] + q[i];\n  }\n\n  for (int i = 0; i < 502; i++) for (int j = 0; j < 502; j++) {\n    memo[i][j] = -1;\n  }\n\n  cout << fixed << setprecision(10) << dfs(1, n + 1) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cfloat>\n#include <vector>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint c, n = 0;\n\tbool minus = false;\n\tif ((c = gcu()) == '-') minus = true; else ungetc(c, stdin);\n\twhile ((c = gcu()) >= '0' && c <= '9') n = 10 * n + (c - '0');\n\t//return n; }\n\treturn minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\ntemplate <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\nsvo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\n#define v vector\n\nstruct OBST {\n\ttypedef vector<double> vd;\n\tvd p, q;\n\tv<vd> e, w;\n\n\tvoid read(int n) {\n\t\tp.resize(n + 1);\n\t\tq.resize(n + 1);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tscanf(\"%lf\", &p[i]);\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tscanf(\"%lf\", &q[i]);\n\t}\n\n\tdouble cost(int n) {\n\t\te = v<vd>(n + 2, vd(n + 1));\n\t\tw = v<vd>(n + 2, vd(n + 1));\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\te[i + 1][i] = q[i];\n\t\t\tw[i + 1][i] = q[i];\n\t\t}\n\t\tfor (int l = 1; l <= n; l++)\n\t\t\tfor (int i = 1; i <= n - l + 1; i++) {\n\t\t\t\tint j = i + l - 1;\n\t\t\t\te[i][j] = DBL_MAX;\n\t\t\t\tw[i][j] = w[i][j - 1] + p[j] + q[j];\n\t\t\t\tfor (int r = i; r <= j; r++)\n\t\t\t\t\te[i][j] = min(e[i][j], e[i][r - 1] + e[r + 1][j] + w[i][j]);\n\t\t\t}\n\t\treturn e[1][n];\n\t}\n};\n\nint main() {\n\tint n = in();\n\tOBST obst;\n\tobst.read(n);\n\tprintf(\"%.8lf\\n\", obst.cost(n));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tusing vd = std::vector<double>;\n\tusing vvd = std::vector<vd>;\n\tvd percentage(2 * n + 2);\n\tfor (int i{2}; i < 2 * n + 2; i += 2)\n\t\tscanf(\"%lf\", &percentage[i]);\n\tfor (int i{1}; i < 2 * n + 2; i += 2)\n\t\tscanf(\"%lf\", &percentage[i]);\n\n\tvvd dp(n + 1, vd(n + 1, 9));\n\tfor (int i{}; i <= n; i++)\n\t\tdp[i][i] = 0;\n\n\tfor (int i{1}; i < 2 * n + 2; i++)\n\t\tpercentage[i] += percentage[i - 1];\n\n\tfor (int width{1}; width <= n; width++)\n\t\tfor (int left{}; left + width <= n; left++)\n\t\t{\n\t\t\tint right{left + width};\n\t\t\tfor (int root{right}; root > left; root--)\n\t\t\t\tdp[left][right] = std::min(dp[left][right],\n\t\t\t\tdp[left][root - 1] + percentage[2 * root - 1] - percentage[2 * left]\n\t\t\t\t+ dp[root][right] + percentage[2 * right + 1] - percentage[2 * root]\n\t\t\t\t);\n\t\t}\n\n\tstd::cout << std::fixed << std::setprecision(6) << dp[0][n] + 1 << std::endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX = 500;\ndouble p[MAX + 1];\ndouble q[MAX + 1];\ndouble w[MAX + 2][MAX + 2];\ndouble e[MAX + 2][MAX + 2];\ndouble r[MAX + 1][MAX + 1];\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> p[i];\n    }\n    for (int i = 0; i <= n; ++i)\n    {\n        cin >> q[i];\n    }\n    for (int i = 1; i != n + 2; ++i)\n    {\n        e[i][i-1] = q[i-1];\n        w[i][i-1] = q[i-1];\n    }\n\n    for (int l = 1; l <= n; ++l)\n    {\n        for (int i = 1; i <= n - l + 1; ++i)\n        {\n            int j = i + l - 1;\n            e[i][j] = (1 << 21);\n            w[i][j] = w[i][j-1] + p[j] + q[j];\n            for (int k = i; k <= j; ++k)\n            {\n                double t = e[i][k-1] + e[k+1][j] + w[i][j];\n                if (t < e[i][j])\n                {\n                    e[i][j] = t;\n                    r[i][j] = k;\n                }\n            }\n        }\n    }\n    cout << fixed << setprecision(8) << e[1][n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 1010\n#define INF (1<<30)\n\ndouble costSum[MAX][MAX],optCost[MAX][MAX];\n\n//{{{ Functions\nvoid ComputeOptCost(int i, int j){\n\toptCost[i][j]=INF;\n\tfor(int k=i; k<=j; k++){\n\t\toptCost[i][j]=min(optCost[i][k-1]+optCost[k+1][j], optCost[i][j]);\n\t}\n\toptCost[i][j]+=costSum[i][j];\n}\n//}}}\n\nint main(){\n\tint n;\tcin>>n;\n\tvector<double> P(n+1),Q(n+1);\n\tfor(int i=1;i<=n;i++)cin>>P[i];\n\tfor(int i=0;i<=n;i++)cin>>Q[i];\n\n\t/*\n\t\tcostSum[i][j]:\n\t\t\t(i: 1,2,~,n)\n\n\t\t(j==i-1) Q[i-1]\n\t\t(else) costSum[i][j-1]+ P[j]+Q[j]\n\t*/\n\n\t//costSum の初期化\n\tfor(int i=1; i<=n; i++){\n\t\tcostSum[i][i-1]=Q[i-1];\n\t\tfor(int j=i; j<=n; j++){\n\t\t\tcostSum[i][j]=costSum[i][j-1] + P[j]+Q[j];\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n+1;i++)optCost[i][i-1]=Q[i-1];\n\tfor(int d=0; d<=n-1; d++){\n\t\tfor(int i=1;i<=n-d;i++){\n\t\t\tComputeOptCost(i,i+d);\n\t\t}\n\t}\n\t//cout<<optCost[1][1]<<endl;\n\t//cout<<optCost[1][n]<<endl;\n\tprintf(\"%.8lf\\n\",optCost[1][n]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#pragma GCC optimize (\"O0\")\n#else\n#pragma GCC optimize (\"O3\")\n#endif\n\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nusing ll = long long;\nconst int INF = 1e9 + 7;\nconst int MOD = INF;\nconst ll INF_LL = 1e18 + 7;\n\n#define __overload3(_1, _2, _3, name,...) name\n#define rep(...) __overload3(__VA_ARGS__, repFromUntil, repUntil, repeat)(__VA_ARGS__)\n#define repeat(times) repFromUntil(__name, 0, times)\n#define repUntil(name, times) repFromUntil(name, 0, times)\n#define repFromUntil(name, from, until) for (int name = from, name##__until = (until); name < name##__until; name++)\n#define repFromTo(name, from, to) repFromUntil(name, from, to + 1)\n#define repr(...) __overload3(__VA_ARGS__, reprFromUntil, reprUntil, repeat)(__VA_ARGS__)\n#define reprUntil(name, times) reprFromUntil(name, 0, times)\n#define reprFromUntil(name, from, until) for (int name = until - 1, name##__from = (from); name >= name##__from; name--)\n#define reprFromTo(name, from, to) reprFromUntil(name, from, to + 1)\n\n#define debugos OUT\n#ifdef LOCAL\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<newl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<newl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<newl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<newl;}}\n#else\n#define debug(v) {}\n#define debugv(v) {}\n#define debuga(m,w) {}\n#define debugaa(m,h,w) {}\n#endif\n\n#define newl \"\\n\"\n\n#define all(iter) begin(iter), end(iter)\n\n\ntemplate <class T> bool chmin(T& var, T x) {\n  if (var > x) {\n    var = x;\n    return true;\n  } else return false;\n}\ntemplate <class T> bool chmax(T& var, T x) {\n  if (var < x) {\n    var = x;\n    return true;\n  } else return false;\n}\n\nclass MyScanner {\n  public:\n    template<typename T> void input_integer(T& var) {\n        var = 0; T sign = 1;\n        int cc = getchar();\n        for (; cc<'0' || '9'<cc; cc = getchar())\n            if (cc == '-') sign = -1;\n        for (; '0' <= cc && cc <= '9'; cc = getchar())\n            var = (var << 3) + (var << 1) + cc - '0';\n        var = var * sign;\n    }\n    int c() { char c; while (c = getchar(), c == ' ' or c == '\\n'); return c; }\n    MyScanner& operator>>(char& var) { var = c(); return *this; }\n    MyScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n    MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this; }\n    MyScanner& operator>>(string& var) {\n        int cc = getchar();\n        for (; !isvisiblechar(cc); cc = getchar());\n        for (; isvisiblechar(cc); cc = getchar())\n            var.push_back(cc);\n        return *this;\n    }\n    operator int() {\n      int n;\n      *this >> n;\n      return n;\n    }\n    operator ll() {\n      ll n;\n      *this >> n;\n      return n;\n    }\n    private:\n      int isvisiblechar(int c) {\n        return 0x21 <= c && c <= 0x7E;\n      }\n};\nclass MyPrinter {\n  public:\n    template<typename T>\n    void output_integer(T var) {\n        if (var == 0) { putchar('0'); return; }\n        if (var < 0)\n            putchar('-'),\n            var = -var;\n        char stack[32]; int stack_p = 0;\n        while (var)\n            stack[stack_p++] = '0' + (var % 10),\n            var /= 10;\n        while (stack_p)\n            putchar(stack[--stack_p]);\n    }\n    MyPrinter& operator<<(char c) { putchar(c); return *this; }\n    template <typename T>\n    MyPrinter& operator<<(T var) { output_integer<T>(var); return *this; }\n    MyPrinter& operator<<(char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const string& str) {\n        const char* p = str.c_str();\n        const char* l = p + str.size();\n        while (p < l) putchar(*p++);\n        return *this;\n    }\n    // MyPrinter& operator<<(const modint& var) { output_integer<ll>(var.value); return *this; }\n    template <typename T>\n    void operator()(T x) {\n        *this << x << newl;\n    }\n};\nMyScanner IN;\nMyPrinter OUT;\n\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<double> p(n), q(n+1);\n  rep(i, n) scanf(\"%lf\", p.begin()+i);\n  rep(i, n+1) scanf(\"%lf\", q.begin()+i);\n\n  vector<double> p_s(n+1, 0), q_s(n+2, 0), w(n+2, 0);\n  rep(i, n) p_s[i+1] = p_s[i] + p[i];   // p[r] - p[l] : [l, r)\n  rep(i, n+1) q_s[i+1] = q_s[i] + q[i];\n  auto s = [&](int l, int r){ return (p_s[r] - p_s[l]) + (q_s[r+1] - q_s[l]); };  // w(l, r) : key [l, r)\n\n  double dp[n+1][n+1];  // dp[l][r] : [l, r)\n  fill(dp[0], dp[n+1], INF);\n  rep(i, n+1) dp[i][i] = q[i];\n\n  rep(w, 1, n+1) {\n    rep(i, n-w+1) {\n      int j = i + w;\n      rep(r, i, j) chmin(dp[i][j], dp[i][r] + dp[r+1][j] + s(i, j));\n      // printf(\"dp[%d][%d] = %.5lf\\n\", i, j, dp[i][j]);\n    }\n  }\n  printf(\"%.7lf\", dp[0][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define N 500\nint main(){\n    int n;\n    std::scanf(\"%d\", &n);\n\n    float p[N + 1];\n    float q[N + 1];\n    p[0] = 0.f;\n    for(int i = 1; i <= n; ++i){\n        std::scanf(\"%f\", &p[i]);\n    }\n    for(int i = 0; i <= n; ++i){\n        std::scanf(\"%f\", &q[i]);\n    }\n    float a[N + 2][N + 2];\n    float c[N + 2][N + 2];\n    a[1][0] = q[0];\n    c[1][0] = q[0];\n    for(int i = 1; i <= n; ++i){\n        a[i+1][i] = q[i];\n        c[i+1][i] = q[i];\n        a[i][i] = p[i] + q[i-1] + q[i];\n        c[i][i] = p[i] + 2 * (q[i-1] + q[i]);\n    }\n\n    for(int l = 2; l <= n; ++l){\n        for(int i = 1; i <= n - l + 1; ++i){\n            int j = i + l - 1;\n            a[i][j] = a[i][j-1] + a[i+1][j] - a[i+1][j-1];\n            c[i][j] = 1000.f;\n            for(int k = i; k <= j; ++k){\n                c[i][j] = std::min(c[i][j], c[i][k-1] + a[i][k-1] + c[k+1][j] + a[k+1][j] + p[k]);\n            }\n        }\n    }\n\n    std::printf(\"%f\\n\", c[1][n]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define ZERO(x) memset(x, 0, sizeof(x))\n#define FILL(x, y) memset(x, y, sizeof(x))\n#define PB push_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\nint main() {\n    PRE_COMMAND\n    int n;\n    INPUT(n);\n    vector<double> p(n), q(n + 1);\n    vector<vector<double>> dp(n + 1, vector<double>(n + 1, 1000));\n    vector<double> ac(2 * n + 2, 0);\n    INPUT(p, q);\n    REP(i, n + 1) { dp[i][i] = q[i]; }\n    ac[1] = q[0];\n    REP(i, 2 * n + 1) {\n        if (i % 2 != 0) {\n            ac[i + 1] = ac[i] + p[i / 2];\n        } else {\n            ac[i + 1] = ac[i] + q[i / 2];\n        }\n    }\n    FOR(width, 1, n + 1) {\n        REP(i, n + 1 - width) {\n            int j = i + width;\n            REP(temp, width) {\n                int k = i + temp;\n                CHMIN(dp[i][j], dp[i][k] + dp[k + 1][j]);\n            }\n            dp[i][j] += ac[2 * j + 1] - ac[2 * i];\n        }\n    }\n    PRINT(dp[0][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;5\ndouble dp[505][505];\nint n;\ndouble p[505];\ndouble q[505];\ndouble psum[505];\ndouble qsum[505];\n\ndouble search(int l, int r) {\n    if(dp[l][r] != 0) return dp[l][r];\n    if(l == r) {\n        return dp[l][r] = 0;\n    }\n    dp[l][r] = 1e9;\n    double total = qsum[r] - qsum[l-1] + psum[r] - psum[l];\n    for(int x = l + 1; x <= r; x++) {\n        double left = qsum[x-1] - qsum[l-1] + psum[x-1] - psum[l];\n        double right = total - left - p[x];\n        double now = (search(l, x - 1) + 1) * (left / total) + (search(x, r) + 1) * (right / total);\n        dp[l][r] = min(dp[l][r], now);\n    }\n    return dp[l][r];\n}\n\nint main() {\n    cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for(int i = 2; i <= n + 1; i++) cin >> p[i];\n    for(int i = 1; i <= n + 1; i++) cin >> q[i];\n    for(int i = 1; i <= n + 1; i++) psum[i] = psum[i-1] + p[i];\n    for(int i = i; i <= n + 1; i++) qsum[i] = qsum[i-1] + q[i];\n    cout << 1.0 + search(1, n+1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nconst int NIL = -1;\nconst int MAX = 20001;\nint root[510][510];\ndouble w[510][510];\ndouble e[510][510];\n\nint main(void)\n{\n\tint n;\n\tdouble P, Q, t;\n\tvector<double>p, q;\n\tcin >> n;\n\tp.push_back(0);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> P;\n\t\tp.push_back(P);\n\t}\n\tfor (int i = 0; i < n + 1; i++) {\n\t\tcin >> Q;\n\t\tq.push_back(Q);\n\t}\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\te[i][i - 1] = q[i - 1];\n\t\tw[i][i - 1] = q[i - 1];\n\t}\n\tfor (int l = 1; l <= n; l++) {\n\t\tfor (int i = 1; i <= n - l + 1; i++) {\n\t\t\tint j = i + l - 1;\n\t\t\te[i][j] = MAX;\n\t\t\tw[i][j] = w[i][j - 1] + p[j] + q[j];\n\t\t\tfor (int r = i; r <= j; r++) {\n\t\t\t\tt = e[i][r - 1] + e[r + 1][j] + w[i][j];\n\t\t\t\tif (t < e[i][j]) {\n\t\t\t\t\te[i][j] = t;\n\t\t\t\t\troot[i][j] = r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.8lf\\n\", e[1][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;5\ndouble dp[505][505];\nint n;\ndouble p[505];\ndouble q[505];\ndouble psum[505];\ndouble qsum[505];\n\ndouble search(int l, int r) {\n    if(dp[l][r] != 0) return dp[l][r];\n    if(l == r) {\n        return dp[l][r] = 0;\n    }\n    dp[l][r] = 1e9;\n    double total = qsum[r] - qsum[l-1] + psum[r] - psum[l];\n    for(int x = l + 1; x <= r; x++) {\n        double left = qsum[x-1] - qsum[l-1] + psum[x-1] - psum[l];\n        double right = total - left - p[x];\n        double now = (search(l, x - 1) + 1) * (left / total) + (search(x, r) + 1) * (right / total);\n        dp[l][r] = min(dp[l][r], now);\n    }\n    return dp[l][r];\n}\n\nint main() {\n    cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for(int i = 2; i <= n + 1; i++) cin >> p[i];\n    for(int i = 1; i <= n + 1; i++) cin >> q[i];\n    for(int i = 1; i <= n + 1; i++) psum[i] = psum[i-1] + p[i];\n    for(int i = i; i <= n + 1; i++) qsum[i] = qsum[i-1] + q[i];\n    cout << 1.0 + search(1, n+1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n#define N 501\n\nint main(){\n    int n;\n    double p[N],q[N];\n    double pSum[N][N],qSum[N][N];\n    double d[N][N];\n    double t;\n    \n    cin >> n;\n    \n    for(int i = 0;i < n;++i){\n        cin >> p[i];\n    }\n    \n    for(int i = 0;i < n + 1;++i){\n        cin >> q[i];\n        d[i][i] = q[i];\n    }\n    \n     // p\n    for(int i = 0;i < n;++i){\n        pSum[i][i] = p[i];\n        for(int j = i + 1;j < n;++j){\n            pSum[i][j] = pSum[i][j - 1] + p[j];\n        }\n    }\n    \n    // q\n    for(int i = 0;i < n + 1;++i){\n        qSum[i][i] = q[i];\n        for(int j = i + 1;j < n + 1;++j){\n            qSum[i][j] = qSum[i][j - 1] + q[j];\n        }\n    }\n    \n    for(int i = 1;i < n + 1;++i){\n        for(int j = 0;j < (n + 1) - i;++j){\n            d[j][j + i] = __DBL_MAX__;\n            for(int k = 0;k < i;++k){\n                t = d[j][j + k] + d[j + k + 1][j + i] + pSum[j][j + i - 1] + qSum[j][j + i];\n                d[j][j + i] = min(d[j][j + i], t);\n            }\n        }\n    }\n    \n    printf(\"%.8lf\\n\",d[0][n]);\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n#define MAX 550\n#define INF (1e100)\n\nint n;\ndouble p[MAX], q[MAX];\nint temp[MAX][MAX];\ndouble temp2[MAX][MAX], temp3[MAX][MAX];\n\n// double fuga(int a, int b, int count){\n\t// if(a>b)return 0;\n\t// double ans = count*p[temp[a][b]];\n\t// ans += fuga(a,temp[a][b]-1,count+1);\n\t// ans += fuga(temp[a][b]+1,b,count+1);\n\t// if(a == temp[a][b]) ans += q[a-1]*(count+1);\n\t// if(b == temp[a][b]) ans += q[b]*(count+1);\n\t\n\t// return ans;\n// }\ndouble fuga(int a, int b, int count){\n\tif(a>b)return 0;\n\tdouble ans = p[temp[a][b]];\n\ttemp3[a][b] = 0;\n\tif(a <= temp[a][b]-1)ans += temp2[a][temp[a][b]-1]+temp3[a][temp[a][b]-1];\n\tif(temp[a][b]+1 <= b)ans += temp2[temp[a][b]+1][b]+temp3[temp[a][b]+1][b];\n\ttemp3[a][b] = temp3[a][temp[a][b]-1] + temp3[temp[a][b]+1][b] + p[temp[a][b]];\n\tif(a==temp[a][b]) {temp3[a][b] += q[a-1]; ans += q[a-1]*2;}\n\tif(b==temp[a][b]) {temp3[a][b] += q[b];   ans += q[b]*2;}\n\treturn ans;\n}\n\nvoid hoge(int a, int b){\n\tdouble t, mi = INF;\n\tint ti = a;\n\n\tfor(int i = a; i <= b; i++){\n\t\ttemp[a][b] = i;\n\t\tif((t = fuga(a,b,1)) < mi){\n\t\t\tmi = t;\n\t\t\tti = i;\n\t\t}\n\t}\n\ttemp[a][b] = ti;\n\ttemp2[a][b] = fuga(a,b,1);\n\t// temp2[a][b] = mi;\n}\n\ndouble solve(){\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 1; j+i <= n; j++){\n\t\t\thoge(j,j+i);\n\t\t}\n\t}\n}\n\nvoid print(){\n\tfor(int i = 1; i <= n; i++){\n\t\t// for(int j = 1; j < i; j++){\n\t\t\t// cout<<\"\\t\\t\";\n\t\t// }\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\t// cout<<fuga(i,j,1)<<\"\\t\\t\";\n\t\t\t// cout<<temp[i][j]<<\" \"<<fuga(i,j,1)<<\"\\t\\t\";\n\t\t\tcout<<temp[i][j]<<\" \"<<temp2[i][j]<<\"\\t\\t\";\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\nint main(){\n\tcout<<fixed<<setprecision(5);\n\tcin>>n;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tcin>>p[i];\n\t\ttemp[i][i] = i;\n\t\ttemp3[i][i] = p[i];\n\t\ttemp2[i][i] = p[i];\n\t}\n\tfor(int i = 0; i <= n; i++){\n\t\tcin>>q[i];\n\t\ttemp2[i][i] += q[i]*2;\n\t\ttemp2[i+1][i+1] += q[i]*2;\n\t\ttemp3[i][i] += q[i];\n\t\ttemp3[i+1][i+1] += q[i];\n\t}\n\tsolve();\n\t// print();\n\tcout<<fuga(1,n,1)<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\nint n;\nV<double>p,q;\ndouble e[510][510],w[510][510];int root[510][510];\n\nvoid Optimal_BST(){\n    for(int i=1;i<=n+1;i++){\n        e[i][i-1]=q[i-1];\n        w[i][i-1]=q[i-1];\n    }\n    for(int l=1;l<=n;l++){\n        for(int i=1;i<=n-l+1;i++){\n            int j=i+l-1;\n            e[i][j]=INF;\n            w[i][j]=w[i][j-1]+p[j]+q[j];\n            for(int r=i;r<=j;r++){\n                double t=e[i][r-1]+e[r+1][j]+w[i][j];\n                if(t<e[i][j]){\n                    e[i][j]=t;\n                    root[i][j]=r;\n                }\n            }\n        }\n    }\n}\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //-------------------------------\n    cin>>n;\n    p.resize(n+1);q.resize(n+1);\n    for(int i=1;i<=n;i++)cin>>p[i];\n    for(int i=0;i<=n;i++)cin>>q[i];\n    Optimal_BST();\n    printf(\"%.12lf\\n\",e[1][n]);\n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<algorithm>\n\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfloat* p = new float[n];\n\tfloat* q = new float[n + 1];\n\tfloat sum, mini;\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 0;i <= n;i++) {\n\t\tcin >> q[i];\n\t}\n\tfloat** cost = new float* [n];\n\tfloat** coefficient = new float* [n];\n\tfor (int i = 0;i < n;i++) {\n\t\tcost[i] = new float[n - i];\n\t\tcoefficient[i] = new float[n - i];\n\t}\n\tfor (int i = 0;i < n ;i++) {\n\t\tfor (int j = 0;j < n - i;j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = i;k <= i + j;k++) {\n\t\t\t\tsum += p[k] + q[k];\n\t\t\t}\n\t\t\tsum += q[i + j + 1];\n\t\t\tcoefficient[i][j] = sum;\n\t\t}\n\t\tcost[i][0] = p[i]+2*q[i]+2*q[i+1];\n\t}\n\tfor (int j = 1;j <n;j++) {\n\t\tfor (int i = 0;i < n - j;i++) {\n\t\t\tmini = p[i] + cost[i + 1][j - 1] + coefficient[i + 1][j - 1]+2*q[i];\n\t\t\tfor (int k = 1;k < j;k++) {\n\t\t\t\tmini = min(mini, p[i + k] + cost[i][k - 1] + coefficient[i][k - 1] + cost[i + k + 1][j - k - 1] + coefficient[i + k + 1][j - k - 1]);\n\t\t\t}\n\t\t\tcost[i][j] = min(mini, p[i + j] + cost[i][j - 1] + coefficient[i][j - 1] + 2 * q[i + j + 1]);\n\t\t}\n\t}\n\tcout << cost[0][n-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < n; ++i)\nll dx[4] = { 0, 1, 0, -1 };\nll dy[4] = { 1, 0, -1, 0 };\nconst ll INF = 1 << 21;\nconst ll MOD = 1e9 + 7;\n\nconst int N = 500;\n\ndouble p[5000], q[5000], sump[5000], sumq[5000];\ndouble memo[5000][5000];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    rep(i, n) { cin >> p[i + 1]; }\n    rep(i, n + 1) { cin >> q[i]; }\n    sumq[0] = q[0];\n\n    rep(i, n)\n    {\n        sump[i + 1] = sump[i] + p[i + 1];\n        sumq[i + 1] = sumq[i] + q[i + 1];\n    }\n\n    for (int i = 1; i < n + 1; ++i) {\n        for (int j = 1; j < n + 1; ++j) {\n            if (j >= i) {\n                memo[i][j] = INF;\n            } else {\n                memo[i][j] = 0;\n            }\n        }\n    }\n\n    for (int l = 1; l < n + 1; ++l) {\n        for (int i = 1; i < n + 2 - l; ++i) {\n            int j = i + l - 1;\n            for (int k = i; k < j + 1; ++k) {\n                double sum = sump[j] - sump[i - 1];\n                if (i == 1) {\n                    sum += sumq[j];\n                } else {\n                    sum += sumq[j] - sumq[i - 2];\n                }\n                memo[i][j] = min(memo[i][j], sum - p[k] + memo[i][k - 1] + memo[k + 1][j]);\n            }\n        }\n    }\n    cout << memo[1][n] + sump[n] + sumq[n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<double> p;\nvector<double> q;\nvector<double> psum;\nvector<double> qsum;\ndouble memo[502][502];\n\ndouble dfs( int l, int r )\n{\n\tif( memo[l][r] >= 0 ) return memo[l][r];\n\tif( l == r ) return memo[l][r] = 0;\n\tdouble res = DBL_MAX;\n\tdouble total = psum[r] - psum[l] + qsum[r] - qsum[l - 1];\n\tfor( int x = l + 1; x <= r; x++ ) {\n\t\tdouble left = psum[x - 1] - psum[l] + qsum[x - 1] - qsum[l - 1];\n\t\tdouble right = total - left - p[x - 2];\n\t\tdouble w = (dfs( l, x - 1 ) + 1) * left / total + (dfs( x, r ) + 1) * right / total;\n\t\tres = min( res, w );\n\t}\n\tmemo[l][r] = res;\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tp = vector<double>( n );\n\tfor( int i = 0; i < n; i++ ) cin >> p[i];\n\tq = vector<double>( n + 1 );\n\tfor( int i = 0; i < n + 1; i++ ) cin >> q[i];\n\n\tmemset( memo, -1, sizeof( memo ) );\n\tpsum = vector<double>( n + 2 );\n\tfor( int i = 2; i < n + 2; i++ ) psum[i] = psum[i - 1] + p[i - 2];\n\tqsum = vector<double>( n + 2 );\n\tfor( int i = 1; i < n + 2; i++ ) qsum[i] = qsum[i - 1] + q[i - 1];\n\tdouble ans = dfs( 1, n + 1 ) + 1;\n\n\tcout << fixed << setprecision(8) << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble P[505],Q[505],dp[505][505],S[505][505];\nint main()\n{\n\tint n; cin>>n;\n\tfor(int i=1;i<=n;i++) scanf(\"%lf\",&P[i]);\n\tfor(int i=0;i<=n;i++) scanf(\"%lf\",&Q[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][i] = P[i]+2*(Q[i-1]+Q[i]);\n\t\tS[i][i] = P[i]+Q[i-1]+Q[i];\n\t}\n\tdouble a1,a2;\n\tfor(int k=1;k<n;k++)\n\t\tfor(int i=1;i<=n-k;i++){\n\t\t\tint j = i+k;\n\t\t\tS[i][j] = S[i][j-1]+P[j]+Q[j];\n\t\t\ta1 = S[i][j]+Q[i-1]+dp[i+1][j];\n\t\t\ta2 = S[i][j]+Q[j]+dp[i][j-1];\n\t\t\tdp[i][j] = min(a1,a2);\n\t\t\tfor(int m=i+1;m<j;m++)\n\t\t\t\tdp[i][j] = min(dp[i][j],S[i][j]+dp[i][m-1]+dp[m+1][j]);\n\t\t}\n\tprintf(\"%.8lf\\n\",dp[1][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n#define N 501\n\nint main(){\n    int n;\n    double p[N],q[N];\n    double pSum[N][N],qSum[N][N];\n    double d[N][N];\n    double t;\n    \n    cin >> n;\n    \n    for(int i = 0;i < n;++i){\n        cin >> p[i];\n    }\n    \n    for(int i = 0;i < n + 1;++i){\n        cin >> q[i];\n        d[i][i] = q[i];\n    }\n    \n     // p\n    for(int i = 0;i < n;++i){\n        pSum[i][i] = p[i];\n        for(int j = i + 1;j < n;++j){\n            pSum[i][j] = pSum[i][j - 1] + p[j];\n        }\n    }\n    \n    // q\n    for(int i = 0;i < n + 1;++i){\n        qSum[i][i] = q[i];\n        for(int j = i + 1;j < n + 1;++j){\n            qSum[i][j] = qSum[i][j - 1] + q[j];\n        }\n    }\n    \n    for(int i = 1;i < n + 1;++i){\n        for(int j = 0;j < (n + 1) - i;++j){\n            d[j][j + i] = __DBL_MAX__;\n            for(int k = 0;k < i;++k){\n                t = d[j][j + k] + d[j + k + 1][j + i] + pSum[j][j + i - 1] + qSum[j][j + i];\n                d[j][j + i] = min(d[j][j + i], t);\n            }\n        }\n    }\n    \n    printf(\"%.8lf\\n\",d[0][n]);\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i) \n#define PI acos(-1)\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing LP = pair<ll, ll>;\n\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) { a = b; return true; } return false; }\n\n#define INF 1001001\n\ndouble dpRec(int l, int r, vector<vector<double>>& dp, vector<vector<int>>& key, vector<double> sump, vector<double> sumq) {\n    if (dp[l][r] != INF) return dp[l][r];\n    if (l > r) {\n        dp[l][r] = sumq[r + 1] - sumq[l - 1];\n        return dp[l][r];\n    }\n\n    double s = sump[r] - sump[l - 1] + sumq[r + 1] - sumq[l - 1];\n\n    if (chmin(dp[l][r], dpRec(l, l - 1, dp, key, sump, sumq) + dpRec(l + 1, r, dp, key, sump, sumq) + s)) {\n        key[l][r] = l;\n    }\n    if (l == r) return dp[l][r];\n    \n    if (chmin(dp[l][r], dpRec(l, r - 1, dp, key, sump, sumq) + dpRec(r + 1, r, dp, key, sump, sumq) + s)) {\n        key[l][r] = r;\n    }\n\n    for (int i = key[l][r - 1]; i <= key[l + 1][r]; ++i) {\n        if (chmin(dp[l][r], dpRec(l, i - 1, dp, key, sump, sumq) + dpRec(i + 1, r, dp, key, sump, sumq) + s)) {\n            key[l][r] = i;\n        }\n    }\n    return dp[l][r];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin>>n;\n    vector<double> ps(n), sump(n + 1), qs(n + 1), sumq(n + 2);\n    rep(i, n) {\n        cin>>ps[i];\n        sump[i + 1] = sump[i] + ps[i];\n    }\n    rep(i, n + 1) {\n        cin>>qs[i];\n        sumq[i + 1] = sumq[i] + qs[i];\n    }\n\n    vector<vector<double>> dp(n + 2, vector<double>(n + 2, INF));\n    vector<vector<int>> key(n + 2, vector<int>(n + 2, INF));\n    double ans = dpRec(1, n, dp, key, sump, sumq);\n    printf(\"%.10f\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\nusing namespace std;\ndouble e[1001][51001];\ndouble optimalBST(double p[],double q[],int n){\n    double w[1001][1001];\n    for(int i=1;i<=n+1;i++){\n        e[i][i-1]=q[i-1];\n        w[i][i-1]=q[i-1];\n    }\n    for(int l=1;l<=n;l++){\n        for(int i=1;i<=n-l+1;i++){\n            int j=i+l-1;\n            e[i][j]=1000.0;\n            w[i][j]=w[i][j-1]+p[j]+q[j];\n            for(int r=i;r<=j;r++){\n                double t=e[i][r-1]+e[r+1][j]+w[i][j];\n                if(t<e[i][j]){\n                    e[i][j]=t;\n                }\n            }\n        }\n    }\n    return e[1][n];\n}\nint main(){\n    int n;\n    double p[1001],q[1001];\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>p[i];\n    }\n    for(int i=0;i<=n;i++){\n        cin>>q[i];\n    }\n    \n\n    printf(\"%.8lf\\n\", optimalBST(p,q,n)); \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble P[505],Q[505],dp[505][505],S[505][505],a1,a2;\nint n,i,j,k,m;\nint main(){\n\tcin>>n;\n\tfor(i=1;i<=n;i++)scanf(\"%lf\",&P[i]);\n\tfor(i=0;i<=n;i++)scanf(\"%lf\",&Q[i]);\n\tfor(i=1;i<=n;i++){\n\t\tdp[i][i]=P[i]+2*(Q[i-1]+Q[i]);\n\t\tS[i][i]=P[i]+Q[i-1]+Q[i];\n\t}\n\tfor(k=1;k<n;k++)\n\t\tfor(i=1;i<=n-k;i++){\n\t\t\tj=i+k;\n\t\t\tS[i][j]=S[i][j-1]+P[j]+Q[j];\n\t\t\ta1=S[i][j]+Q[i-1]+dp[i+1][j];\n\t\t\ta2=S[i][j]+Q[j]+dp[i][j-1];\n\t\t\tdp[i][j]=min(a1,a2);\n\t\t\tfor(m=i+1;m<j;m++)dp[i][j]=min(dp[i][j],S[i][j]+dp[i][m-1]+dp[m+1][j]);\n\t\t}\n\tprintf(\"%.8lf\\n\",dp[1][n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cfloat>\n\ndouble min(double x, double y)\n{\n\treturn x>y ? y : x;\n}\n\nint main()\n{\n\tstd::string strn; getline(std::cin, strn);\n\tint n = std::stoi(strn);\n\t\n\tdouble *p = new double[n];\n\tdouble *q = new double[n+1];\n\t\n\tfor (int i=0; i<n; i++) std::cin >> p[i];  // p[0], p[1], ... , p[n-1]\n\tfor (int i=0; i<=n; i++) std::cin >> q[i]; // q[0], q[1], ... , q[n-1], q[n]\n\t\n\tdouble *cost_sum = new double[n+1];\n\tcost_sum[0] = q[0];\n\tfor (int i=1; i<n+1; i++) cost_sum[i] = cost_sum[i-1] + p[i-1] + q[i]; \n\t\n\tdouble** DP = new double*[n+1];\n\tfor (int i=0; i<n+1; i++) DP[i] = new double[n];\n\t\n\tfor (int j=0; j<n; j++) DP[j+1][j] = 0.0;\n\t\n\tfor (int d=0; d<n; d++) {\n\t\tfor (int i=0; i<n-d; i++) {\n\t\t\tif (d==0) DP[i][i] = q[i] + q[i+1];\n\t\t\telse {\n\t\t\t\tDP[i][i+d] = DBL_MAX;\n\t\t\t\tfor (int j=0; j<=d; j++) {\n\t\t\t\t\tdouble left_cost_sum  = cost_sum[i+j] - cost_sum[i] + q[i];\n\t\t\t\t\tdouble right_cost_sum = cost_sum[i+d+1] - cost_sum[i+j+1] + q[i+j+1];\n\t\t\t\t\tDP[i][i+d] = min(DP[i][i+d], DP[i][i+j-1] + left_cost_sum + DP[i+j+1][i+d] + right_cost_sum);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// std::cout << \"DP[\" << i << \"][\" << i+d << \"] = \" << DP[i][i+d] << std::endl;\n\t\t}\n\t}\n\t\n\tstd::cout << std::fixed << DP[0][n-1] + 1 << std::endl;\n\t\n\tfor (int i=0; i<n; i++) delete[] DP[i];\n\tdelete[] DP;\n\tdelete[] cost_sum;\n\tdelete[] p;\n\tdelete[] q;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<double> vd;\nconst double INF=1e10;\n\nclass OBST\n{\npublic:\n    int n;\n    vd p,q;\n    vector<vd> e,w;\n\n    OBST(int _n=1)\n    {\n        n=_n;\n        p.resize(n+1);\n        q.resize(n+1);\n        e.resize(n+2,vd(n+1));\n        w.resize(n+2,vd(n+1));\n    }\n\n    void get()\n    {\n        for(int i=1;i<=n;i++)\n        {\n            cin>>p[i];\n        }\n        for(int i=0;i<=n;i++)\n        {\n            cin>>q[i];\n        }\n    }\n\n    double go()\n    {\n        for(int i=1;i<=n+1;i++){\n            e[i][i-1]=w[i][i-1]=q[i-1];\n        }\n\n        for(int len=1;len<=n;len++)\n        {\n            for(int i=1;i<=n-len+1;i++)\n            {\n\n                int j=i+len-1;\n                e[i][j]=INF;\n                w[i][j]=w[i][j-1]+p[j]+q[j];\n                for(int k=i;k<=j;k++)\n                {\n                    e[i][j]=min(e[i][j],e[i][k-1]+e[k+1][j]+w[i][j]);\n                }\n            }\n        }\n        return e[1][n];\n    }\n};\n\nint main()\n{\n    int n;\n    cin>>n;\n\n    OBST obst(n);\n\n    obst.get();\n\n    cout<<obst.go()<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nconst ll MOD = (ll)1e9+7;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\nll modpow(ll x, ll b){\n\tll res = 1;\n\twhile(b){\n\t\tif(b&1)res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll modinv(ll x){\n\treturn modpow(x, MOD-2);\n}\n\nint n;\nvector<double> p;\nvector<double> sump;\nvector<double> q;\nvector<double> sumq;\nvvector<double> dp;\n\ndouble func(int l, int r){\n\tif(r<l)return 0;\n\tif(l==r){\n\t\treturn p[l] + 2 * q[l-1] + 2 * q[l];\n\t}\n\tif(dp[l][r] >= 0)return dp[l][r];\n\tdouble res = INFLL;\n\tchmin(res, q[l-1]*2+p[l]+func(l+1, r)+sump[r]-sump[l]+sumq[r]-sumq[l-1]);\n\tchmin(res, q[r]*2+p[r]+func(l, r-1)+sump[r-1]-sump[l-1]+sumq[r-1]-sumq[l-2]);\n\tfor(int mid=l+1;mid<r;++mid){\n\t\tdouble midsum = p[mid];\n\t\tdouble leftsum = func(l, mid-1) + sump[mid-1] - sump[l-1] + sumq[mid-1] - sumq[l-2];\n\t\tdouble rightsum = func(mid+1, r) + sump[r] - sump[mid] + sumq[r] - sumq[mid-1];\n\t\tchmin(res, midsum+leftsum+rightsum);\n\t}\n\treturn dp[l][r] = res;\n}\n\nint main(){\n\tcin >> n;\n\tp.resize(n+2);\n\tq.resize(n+3);\n\tsump.resize(n+3, 0);\n\tsumq.resize(n+4, 0);\n\tfor(int i=2;i<n+2;++i){\n\t\tcin >> p[i];\n\t\tsump[i] = sump[i-1] + p[i];\n\t}\n\tfor(int i=1;i<n+2;++i){\n\t\tcin >> q[i];\n\t\tsumq[i] = sumq[i-1] + q[i];\n\t}\n\tdp.resize(n+2, vector<double>(n+2, -1));\n\tprintf(\"%.8lf\\n\", func(2, n+1));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 1<<20\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  double p[510], q[510];\n  for (int i = 1; i <= n; ++i) cin >> p[i];\n  for (int i = 0; i < n + 1; ++i) cin >> q[i];\n  double sump[501] = {}, sumq[501] = {}, dp[510][510] = {};\n  for (int i = 1; i <= n; ++i) sump[i] = sump[i - 1] + p[i];\n  sumq[0] = q[0];\n  for (int i = 1; i <= n; ++i) sumq[i] = sumq[i - 1] + q[i];\n  for (int i = 1; i <= n; ++i)\n    for (int j = i; j <= n; ++j) dp[i][j] = INF;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n - i + 1; ++j) {\n      int x = i + j - 1;\n      for (int k = j; k <= x; ++k) {\n\tdouble sum = sump[x] - sump[j - 1]+sumq[x];\n\tif (j >= 2) sum -= sumq[j - 2];\n\tif (dp[j][x] > sum + dp[j][k - 1] - p[k] + dp[k + 1][x]) dp[j][x] = sum + dp[j][k - 1] - p[k] + dp[k + 1][x];\n      }\n    }\n  }\n  cout << dp[1][n] + 1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std; \n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tvector<double> p(n+1);\n\tp[0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> p[i+1];\n\t}\n\tvector<double> q(n+1);\n\tvector< vector<double> > sum(n+1,vector<double>(n+1));\n\tvector< vector<double> > dp(n+1,vector<double>(n+1,(1 << 28)));\n\tfor (int i = 0; i < n+1; ++i) {\n\t\tcin >> q[i];\n\t\tif (i > 0) {\n\t\t\tdp[i][i] = p[i]+(2*(q[i-1]+q[i]));\n\t\t\tsum[i][i] = dp[i][i] - (q[i-1]+q[i]); \n\t\t}\n\t}\n\tfor (int i = 1; i < n+1; ++i) {\n\t\tfor (int j = i+1; j < n+1; ++j) {\n\t\t\tsum[i][j] = sum[i][j-1] + sum[j][j] - q[j-1];\n\t\t}\n\t}\n\tdouble rc,left,right;\n\tfor (int k = 2; k < n+1; ++k) {\n\t\tfor (int i = 1; i < n-k+2; ++i) {\n\t\t\tfor (int j = 0; j < k; ++j) {\n\t\t\t\trc = dp[i+j][i+j];\n\t\t\t\tleft = right = 0;\n\t\t\t\tif (j != 0) {\n\t\t\t\t\trc -= 2*q[i+j-1];\n\t\t\t\t\tleft += dp[i][i+j-1] + sum[i][i+j-1];\n\t\t\t\t}\n\t\t\t\tif (j != k-1) {\n\t\t\t\t\trc -= 2*q[i+j];\n\t\t\t\t\tright += dp[i+j+1][i+k-1] + sum[i+j+1][i+k-1];\n\t\t\t\t}\n\t\t\t\tdp[i][i+k-1] = min(rc+left+right,dp[i][i+k-1]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << setprecision(20) << fixed << dp[1][n] << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n#define N 501\n\nint main(){\n    int n;\n    double p[N],q[N];\n    double pSum[N][N],qSum[N][N];\n    double d[N][N];\n    double t;\n    \n    cin >> n;\n    \n    for(int i = 0;i < n;++i){\n        cin >> p[i];\n    }\n    \n    for(int i = 0;i < n + 1;++i){\n        cin >> q[i];\n        d[i][i] = q[i];\n    }\n    \n     // p\n    for(int i = 0;i < n;++i){\n        pSum[i][i] = p[i];\n        for(int j = i + 1;j < n;++j){\n            pSum[i][j] = pSum[i][j - 1] + p[j];\n        }\n    }\n    \n    // q\n    for(int i = 0;i < n + 1;++i){\n        qSum[i][i] = q[i];\n        for(int j = i + 1;j < n + 1;++j){\n            qSum[i][j] = qSum[i][j - 1] + q[j];\n        }\n    }\n    \n    for(int i = 1;i < n + 1;++i){\n        for(int j = 0;j < (n + 1) - i;++j){\n            d[j][j + i] = __DBL_MAX__;\n            for(int k = 0;k < i;++k){\n                t = d[j][j + k] + d[j + k + 1][j + i] + pSum[j][j + i - 1] + qSum[j][j + i];\n                d[j][j + i] = min(d[j][j + i], t);\n            }\n        }\n    }\n    \n    printf(\"%.8lf \\n\",d[0][n]);\n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\n\ntemplate<class T>\nbool chmax(T &a, const T &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T>\nbool chmin(T &a, const T &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\n\nint main(){\n    int n; cin >> n;\n    VD p(n+1), q(n+1), sump(n+1), sumq(n+2);\n    FORS(i, 1, n){\n        cin >> p[i]; sump[i] = sump[i-1] + p[i];\n    }\n    REPS(i, n){\n        cin >> q[i]; sumq[i+1] = sumq[i] + q[i];//attention\n    }\n    vector<VD> dp(n+1, VD(n+1, 0.0));\n    FORS(i, 1, n) dp[i][i] = p[i] + 2*q[i-1] + 2*q[i];\n\n    FORS(l, 2, n){\n        FORS(i, 1, n - l + 1){\n            int j = i + l - 1;\n            dp[i][j] = INF;\n            FORS(k, i, j){\n                if(k == i) chmin(dp[i][j],\n                                 p[i] + 2*q[i-1] + dp[i+1][j] + sump[j] - sump[i] + sumq[j+1] - sumq[i]);\n                else if(k == j) chmin(dp[i][j],\n                                 p[j] + 2*q[j] + dp[i][j-1] + sump[j-1] - sump[i-1] + sumq[j] - sumq[i-1]);\n                else chmin(dp[i][j],\n                     dp[i][k-1] + dp[k+1][j] + sump[j] - sump[i-1] + sumq[j+1] - sumq[i-1]);\n            }\n        }\n    }\n    cout << fixed << setprecision(10) << dp[1][n] << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Lint=long long;\nconst double INF=1e9;\n\nint main()\n{\n   int N; cin>>N;\n   N++;\n   vector<double> p(N-1),q(N);\n   for(int i=0;i<N-1;i++) cin>>p[i];\n   for(int i=0;i<N;i++) cin>>q[i];\n\n   vector<double> sumP(N),sumQ(N+1);\n   for(int i=0;i<N-1;i++) sumP[i+1]=sumP[i]+p[i];\n   for(int i=0;i<N;i++) sumQ[i+1]=sumQ[i]+q[i];\n\n   vector<vector<double>> dp(N+1,vector<double>(N+1,INF));\n   for(int i=0;i<N;i++) dp[i][i+1]=0;\n   for(int len=2;len<=N;len++){\n      for(int l=0;l+len<=N;l++){\n         int r=l+len;\n         for(int m=l+1;m<r;m++){\n            double cost=(sumQ[r]-sumQ[l])+(sumP[m-1]-sumP[l])+(sumP[r-1]-sumP[m]);\n            dp[l][r]=min(dp[l][r],dp[l][m]+dp[m][r]+cost);\n         }\n      }\n   }\n   double ans=dp[0][N];\n   ans+=accumulate(p.begin(),p.end(),0.0);\n   ans+=accumulate(q.begin(),q.end(),0.0);\n   cout<<fixed<<setprecision(10)<<ans<<endl;\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cfloat>\n#include <vector>\nusing namespace std;\n\n#define v vector\n\nstruct OBST {\n\ttypedef vector<double> vd;\n\tvd p, q;\n\tv<vd> e, w;\n\n\tvoid read(int n) {\n\t\tp.resize(n + 1);\n\t\tq.resize(n + 1);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tscanf(\"%lf\", &p[i]);\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tscanf(\"%lf\", &q[i]);\n\t}\n\n\tdouble cost(int n) {\n\t\te = v<vd>(n + 2, vd(n + 1));\n\t\tw = v<vd>(n + 2, vd(n + 1));\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\te[i + 1][i] = q[i];\n\t\t\tw[i + 1][i] = q[i];\n\t\t}\n\t\tfor (int l = 1; l <= n; l++)\n\t\t\tfor (int i = 1; i <= n - l + 1; i++) {\n\t\t\t\tint j = i + l - 1;\n\t\t\t\te[i][j] = DBL_MAX;\n\t\t\t\tw[i][j] = w[i][j - 1] + p[j] + q[j];\n\t\t\t\tfor (int r = i; r <= j; r++)\n\t\t\t\t\te[i][j] = min(e[i][j], e[i][r - 1] + e[r + 1][j] + w[i][j]);\n\t\t\t}\n\t\treturn e[1][n];\n\t}\n};\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tOBST obst;\n\tobst.read(n);\n\tprintf(\"%.8lf\\n\", obst.cost(n));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include<iostream>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<iomanip>\n#include<set>\n#include<map>\n#include<utility>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\n#define LL long long\n\nint n;\ndouble cost[1002],sum[1005]={},memo[1005][1005];\n\ndouble exp(int l,int r){\n\tif(memo[l][r]!=-1.0)return memo[l][r];\n\tdouble ret=1000000000.0;\n\tif(l==r)ret=cost[l];\n\telse{\n\t\tfor(int k=l+1;k<r;k+=2)\n\t\t\tret=min(ret,exp(l,k-1)+exp(k+1,r)+sum[r]-(l==0?0.0:sum[l-1]));\n\t}\n\treturn memo[l][r]=ret;\n}\n\n\nint main() {\n\tcin>>n;\n\tfor(int i=0;i<=2*n+2;i++)for(int j=0;j<=2*n+2;j++)memo[i][j]=-1.0;\n\tfor(int i=1;i<=n;i++)cin>>cost[2*i];\n\tfor(int i=0;i<=n;i++)cin>>cost[2*i+1];\n\tfor(int i=1;i<=2*n+2;i++)sum[i]=cost[i]+sum[i-1];\n\tcout<<fixed<<exp(1,2*n+1)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 1000\n\nint main(void)\n{\n\tint i , n;\n\tscanf(\"%d\",&n);\n\tdouble a[n];\n\t\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lf\",&a[i]);\n\t}\n\tdouble b[n+1];\n\tfor(i = 0; i <= n; i++)\n\t{\n\t\tscanf(\"%lf\",&b[i]);\n\t}\n\tdouble c[n+1][n+1];\n\tdouble d[n+1];\n\tc[0][0]=b[0];\n\td[0]=a[0]+b[0];\n\t\n\tfor(i = 1; i <= n; i++)\n\t{\n\t\tc[i][i] = b[i];\n\t\tc[i-1][i] = a[i-1]+(b[i-1]+b[i])*2;\n\t\td[i] = d[i-1]+a[i]+b[i];\n\t}\n\tint j , k;\n\tdouble s , t;\n\tfor(i = 1;i < n; i++)\n\t{\n\t\tfor(j = 0; j < n-i; j++)\n\t\t{\n\t\t\ts = c[j][j] + c[j+1][i+j+1];\n\t\t\tfor(k = j; k <i+j; k++)\n\t\t\t{\n\t\t\t\tt = c[j][k+1]+c[k+2][i+j+1];\n\t\t\t\tif(s>t) s = t;\n\t\t\t}\n\t\t\tc[j][i+j+1] = s + d[i+j] - d[j-1] + b[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\",c[0][n]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_10_D Optimal Binary Search Tree\n// 2019.3.29 bal4u\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\n#define INF  1e20\n#define MAX  503\nint N;\ndouble p[MAX], q[MAX];\ndouble sp[MAX][MAX], sq[MAX][MAX];\ndouble dp[MAX][MAX];\n\nint main()\n{\n\tint i, j, k;\n\tdouble t;\n\t\n\tscanf(\"%d\", &N);\n\tfor (i = 0; i < N; i++) scanf(\"%lf\", p + i);\n\tfor (i = 0; i <= N; i++) scanf(\"%lf\", q + i);\n\n\tfor (i = 0; i < N; i++) {\n\t\tsp[i][i] = p[i];\n\t\tfor (j = i + 1; j < N; j++) sp[i][j] = sp[i][j - 1] + p[j];\n\t}\n\n\tfor (i = 0; i <= N; i++) {\n\t\tdp[i][i] = sq[i][i] = q[i];\n\t\tfor (j = i + 1; j <= N; j++) sq[i][j] = sq[i][j - 1] + q[j];\n\t}\n\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j + i <= N; j++) {\n\t\t\tdp[j][j + i] = INF;\n\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\tt = dp[j][j + k] + dp[j + k + 1][j + i] + sp[j][j + i - 1] + sq[j][j + i];\n\t\t\t\tif (t < dp[j][j + i]) dp[j][j + i] = t;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.12lf\\n\", dp[0][N]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define N 501\n#define MAX 1e308\nint main(void){\n  int n;\n  double p[N],q[N];\n  double psum[N][N],qsum[N][N]; // e.g. psum[0][2]=p[0]+p[1]+p[2], used for making tree deeper\n  double et[N][N];\n  int i,j,k,h;\n  double tmp;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;++i) scanf(\"%lf\",&p[i]);\n  for(i=0;i<n+1;++i) scanf(\"%lf\",&q[i]);\n  // calc psum,qsum\n  for(i=0;i<n;++i){\n    psum[i][i]=p[i];\n    qsum[i][i]=q[i];\n    for(j=i+1;j<n;++j){\n      psum[i][j]=psum[i][j-1]+p[j];\n      qsum[i][j]=qsum[i][j-1]+q[j];\n    }\n    qsum[i][n]=qsum[i][n-1]+q[n];\n  }\n  qsum[n][n]=q[n];\n  // calc et\n  for(h=0;h<n+1;++h){\n    for(i=0;i<n+1-h;++i){\n      if(h==0) et[i][i]=q[i];\n      else{\n        et[i][i+h]=MAX;\n        for(k=0;k<h;++k){\n          tmp=et[i][i+k]+et[i+k+1][i+h]+psum[i][i+h-1]+qsum[i][i+h]; // combine 2 tree and make it deeper once\n          if(tmp<et[i][i+h]) et[i][i+h]=tmp;\n        }\n      }\n      //printf(\"et[%d][%d]=%f\\n\",i,i+h,et[i][i+h]);\n    }\n  }\n  printf(\"%lf\\n\",et[0][n]);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n // (double*) malloc(sizeof(double)*(n+1))\n\n\ndouble abso(double a)\n{\n\treturn a > 0 ? a : -a;\n}\n\n\nint main() \n{\n\t// 先输入n，再输入有序的 \n\tint n;\n\tscanf(\"%d\", &n);\n\tdouble b[n+1]; // 关键字, 下标从1到n \n\tdouble a[n+1]; // 虚节点，下标从0到n \n\tdouble cost[n+2][n+2];\n\tdouble w[n+2][n+2];\n\tint root[n+2][n+2];\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lf\", &b[i]);\n\t}\n//\tprintf(\"ok\\n\");\n\tdouble sum = 0;\n\tfor (int i=0;i<=n;i++)\n\t{\n\t\tscanf(\"%lf\", &a[i]);\n\t\tsum += a[i];\n\t}\n\t\n\t\n\tfor (int i=0;i<n+2;i++)\n\t{\n\t\tfor (int j=0;j<n+2;j++)\n\t\t{\n\t\t\troot[i][j] = 0;\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\t\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tcost[i+1][i] = 0.0; // 为虚结点的开销赋初始值\n\t\tw[i+1][i] = a[i]; // 为虚结点查找概率赋初始值\t\n\t}\n\tint l;\n\tfor(int j=1;j<=n;j++) // 关键字的规模\n\t{\n\t\tfor (int k=1;k<=n-j+1;k++) // 对于下标从k开始的树 \n\t\t{\n\t\t\tl = k + j - 1; // 最右边的结点序号 \n\t\t\tw[k][l] = w[k][l-1] + b[l] + a[l];\n\t\t\tcost[k][l] = cost[k][k-1] + cost[k+1][l]; // 初始化为根节点在最左边的情况,先不加上w[k][l] \n\t\t\troot[k][l] = k; // 初始化为根节点在最左边的情况\n\t\t\tfor (int m=k+1;m<=l;m++) // 根节点为m时的情况 \n\t\t\t{\n\t\t\t\tdouble temp = cost[k][m-1] + cost[m+1][l];\n//\t\t\t\tprintf(\"compare %lf and cost[%d][%d] + cost[%d][%d] = %lf\\n\", cost[k][l], k, m-1, m+1, l, temp);\n\t\t\t\tif (temp < cost[k][l] && abso(temp - cost[k][l]) > 1e-6 ) // 小于不等于 \n\t\t\t\t{\n\t\t\t\t\tcost[k][l] = temp;\n\t\t\t\t\troot[k][l] = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcost[k][l] += w[k][l];\n\t\t}\n\t}\n\tprintf(\"%lf\", cost[1][n]+sum);\n//\t\n//\tfor (int i=0;i<n+2;i++)\n//\t{\n//\t\tfor (int j=0;j<n+2;j++)\n//\t\t{\n//\t\t\tprintf(\"%lf \", cost[i][j]);\n//\t\t\t\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n//\tfor (int i=0;i<n+2;i++)\n//\t{\n//\t\tfor (int j=0;j<n+2;j++)\n//\t\t{\n//\t\t\tprintf(\"%d \", root[i][j]);\n//\t\t\t\n//\t\t}\n//\t\tprintf(\"\\n\");\n//\t}\n\t\n\tgetchar(); \n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 1000\n\nint main(void)\n{\n\tint i , n;\n\tscanf(\"%d\",&n);\n\tdouble a[n];\n\t\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lf\",&a[i]);\n\t}\n\tdouble b[n+1];\n\tfor(i = 0; i <= n; i++)\n\t{\n\t\tscanf(\"%lf\",&b[i]);\n\t}\n\tdouble c[n+1][n+1];\n\tdouble d[n+1];\n\tc[0][0]=b[0];\n\td[0]=a[0]+b[0];\n\t\n\tfor(i = 1; i <= n; i++)\n\t{\n\t\tc[i][i] = b[i];\n\t\tc[i-1][i] = a[i-1]+(b[i-1]+b[i])*2;\n\t\td[i] = d[i-1]+a[i]+b[i];\n\t}\n\tint j , k;\n\tdouble s , t;\n\tfor(i = 1;i < n; i++)\n\t{\n\t\tfor(j = 0; j < n-i; j++)\n\t\t{\n\t\t\ts = c[j][j] + c[j+1][i+j+1];\n\t\t\tfor(k = j; k <i+j; k++)\n\t\t\t{\n\t\t\t\tt = c[j][k+1]+c[k+2][i+j+1];\n\t\t\t\tif(s>t) s = t;\n\t\t\t}\n\t\t\tc[j][i+j+1] = s + d[i+j] - d[j-1] + b[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\",c[0][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 1000\n\n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tdouble p[n];\n\tdouble q[n+1];\n    double c[n+1][n+1];\n\tdouble d[n+1];\n\tfor(int i=0 ; i<n ; i++)    scanf(\"%lf\",&p[i]);\n\tfor(int i=0 ; i<n+1 ; i++)   scanf(\"%lf\",&q[i]);\n\n\tc[0][0]=q[0];\n\td[0]=p[0]+q[0];\n\t\n\tfor(int i=1 ; i<n+1 ; i++){\n\t\tc[i][i]=q[i];\n\t\tc[i-1][i]=p[i-1]+(q[i-1]+q[i])*2;\n\t\td[i]=d[i-1]+p[i]+q[i];\n\t}\n\n\tdouble s,t;\n\tfor(int i=1 ; i<n ; i++){\n\t\tfor(int j=0 ; j<n-i ; j++) {\n\t\t\ts = c[j][j] + c[j+1][i+j+1];\n\t\t\tfor (int k=j ; k<i+j ; k++) {\n\t\t\t\tt = c[j][k+1] + c[k+2][i+j+1];\n\t\t\t\tif (s>t)    s=t;\n\t\t\t}\n\t\t\tc[j][i+j+1] = s + d[i+j] - d[j-1] + q[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\", c[0][n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define min(p,q)((p)<(q)?(p):(q))\n\ndouble p[510],q[510];\ndouble ps[510],qs[510];\ndouble dp[510][510];\n\ndouble f(int l,int r){\n\t//d[l-1],k[l],d[l+1],...,k[r],d[r]の最適配置\n\tif(dp[l][r])return dp[l][r];\n\t//pは[l,r]、qは[l-1,r]\n\tdouble s=ps[r+1]-ps[l]+qs[r+1]-qs[l-1];\n\tif(s==0)return 0;\n\tif(l>r)return 1;\n\tdouble ans=1e9;\n\tfor(int i=l;i<=r;i++){\n\t\tdouble left =(ps[i  ]-ps[l  ]+qs[i  ]-qs[l-1])/s;\n\t\tdouble right=(ps[r+1]-ps[i+1]+qs[r+1]-qs[i  ])/s;\n\t\tans=min(ans,left*f(l,i-1)+right*f(i+1,r)+1);\n\t}\n\treturn dp[l][r]=ans;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lf\",p+i);\n\t\tps[i+1]=ps[i]+p[i];\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tscanf(\"%lf\",q+i);\n\t\tqs[i+1]=qs[i]+q[i];\n\t}\n\tprintf(\"%f\\n\",f(1,n));\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 1000\n\nint main(void)\n{\n\tint i , n;\n\tscanf(\"%d\",&n);\n\tdouble a[n];\n\t\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lf\",&a[i]);\n\t}\n\tdouble b[n+1];\n\tfor(i = 0; i <= n; i++)\n\t{\n\t\tscanf(\"%lf\",&b[i]);\n\t}\n\tdouble c[n+1][n+1];\n\tdouble d[n+1];\n\tc[0][0]=b[0];\n\td[0]=a[0]+b[0];\n\t\n\tfor(i = 1; i <= n; i++)\n\t{\n\t\tc[i][i] = b[i];\n\t\tc[i-1][i] = a[i-1]+(b[i-1]+b[i])*2;\n\t\td[i] = d[i-1]+a[i]+b[i];\n\t}\n\tint j , k;\n\tdouble s , t;\n\tfor(i = 1;i < n; i++)\n\t{\n\t\tfor(j = 0; j < n-i; j++)\n\t\t{\n\t\t\ts = c[j][j] + c[j+1][i+j+1];\n\t\t\tfor(k = j; k <i+j; k++)\n\t\t\t{\n\t\t\t\tt = c[j][k+1]+c[k+2][i+j+1];\n\t\t\t\tif(s>t) s = t;\n\t\t\t}\n\t\t\tc[j][i+j+1] = s + d[i+j] - d[j-1] + b[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\",c[0][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000\n\nint main(void){\n\tint n;\n\tscanf(\"%d\", &n);\n\tdouble a[n];\n\tdouble b[n+1];\n\tdouble c[n+1][n+1];\n\tdouble d[n+1];\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%lf\", &a[i]);\n\t}\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tscanf(\"%lf\", &b[i]);\n\t}\n\t\n\tc[0][0] = b[0];\n\td[0] = a[0] + b[0];\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tc[i][i] = b[i];\n\t\tc[i-1][i] = a[i-1] + (b[i-1] + b[i]) * 2;\n\t\td[i] = d[i-1] + a[i] + b[i];\n\t}\n\t\n\tdouble x, y;\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < n-i; j++){\n\t\t\tx = c[j][j] + c[j+1][i+j+1];\n\t\t\tfor(int k = j; k < i+j; k++){\n\t\t\t\ty = c[j][k+1] + c[k+2][i+j+1];\n\t\t\t\tif(x > y){\n\t\t\t\t\tx = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc[j][i+j+1] = x + d[i+j] - d[j-1] + b[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\", c[0][n]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n  int i, j, k, n;\n  double v, t;\n  scanf(\"%d\", &n);\n  double a[n], b[n+1], c[n+1][n+1], ww[n+1];\n  for (i=0; i<n; i++)    fscanf(stdin, \"%lf\", a+i);\n  fscanf(stdin, \"%lf\", b);\n  c[0][0] = b[0];\n  ww[0] = a[0]+b[0];\n  for (i=1; i<=n; i++) {\n    fscanf(stdin, \"%lf\", b+i);\n    c[i][i] = b[i];    \n    c[i-1][i] = a[i-1]+(b[i-1]+b[i])*2;\n    ww[i] = ww[i-1]+a[i]+b[i];\n  }\n\n  for (k=1; k<n; k++) {\n    for (i=0; i<n-k; i++) {\n      v = c[i][i] + c[i+1][i+k+1];\n      for (j=i; j<i+k; j++) {\n        t = c[i][j+1] + c[j+2][i+1+k];\n        if (v>t) v=t;\n      }\n      c[i][i+k+1] = v + ww[i+k] - ww[i-1] + b[i+k+1];\n    }\n  }\n  printf(\"%lf\\n\", c[0][n]);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<float.h>\n#define N 1000\n\ndouble min( double a , double b ){\n\t\n\tif( a < b ){\n\t\treturn a;\n\t}else{\n\t\treturn b;\n\t}\n}\n\nint main( void ){\n\t\n\tint n;\n\t\n\tscanf( \"%d\" , &n );\n\tdouble p[n] , q[n+1];\n\t\n\tfor( int i = 0; i < n; i++ ){\n\t\tscanf( \"%lf\" , &p[i]);\n\t}\n\tfor( int i = 0; i < n+1; i++ ){\n\t\tscanf( \"%lf\" , &q[i]);\n\t}\n\t\n\tdouble dp[n+1][n+1];\n\tdouble psum[n][n];\n\tdouble qsum[n+1][n+1];\n\t\n\tfor( int i = 0; i < n+1; i++ ){\n\t\tdp[i][i] = q[i];\n\t}\n\tfor( int i = 0; i < n; i++ ){\n\t\tpsum[i][i] = p[i];\n\t\tfor( int j = i+1; j < n; j++ ){\n\t\t\tpsum[i][j] = psum[i][j-1]+p[j];\n\t\t}\n\t}\n\tfor( int i = 0; i < n+1; i++ ){\n\t\tqsum[i][i] = q[i];\n\t\tfor( int j = i+1; j < n+1; j++ ){\n\t\t\tqsum[i][j] = qsum[i][j-1]+q[j];\n\t\t}\n\t}\n\tfor( int i = 1; i < n+1; i++ ){\n\t\tfor( int j = 0; i+j < n+1; j++ ){\n\t\t\tdp[j][i+j] = DBL_MAX;\n\t\t\tfor( int k = 0; k < i; k++ ){\n\t\t\t\tdouble tmp = dp[j][j+k]+dp[j+k+1][i+j]+psum[j][i+j-1]+qsum[j][i+j];\n\t\t\t\tdp[j][i+j] = min( dp[j][i+j] , tmp );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf( \"%f\\n\" , dp[0][n] );\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main ( )\n{\n  int VAR00 , VAR01 , VAR02 , VAR03 ;\n  double VAR04 , VAR05 ;\n  scanf ( \"%d\" , & VAR03 ) ;\n  double VAR06 [ VAR03 ] , VAR07 [ VAR03 + 1 ] , VAR08 [ VAR03 + 1 ] [ VAR03 + 1 ] , VAR09 [ VAR03 + 1 ] ;\n  for ( VAR00 = 0 ; VAR00 < VAR03 ; VAR00 ++ ) fscanf ( stdin , \"%lf\" , VAR06 + VAR00 ) ;\n  fscanf ( stdin , \"%lf\" , VAR07 ) ;\n  VAR08 [ 0 ] [ 0 ] = VAR07 [ 0 ] ;\n  VAR09 [ 0 ] = VAR06 [ 0 ] + VAR07 [ 0 ] ;\n  for ( VAR00 = 1 ; VAR00 <= VAR03 ; VAR00 ++ ) {\n    fscanf ( stdin , \"%lf\" , VAR07 + VAR00 ) ;\n    VAR08 [ VAR00 ] [ VAR00 ] = VAR07 [ VAR00 ] ;\n    VAR08 [ VAR00 - 1 ] [ VAR00 ] = VAR06 [ VAR00 - 1 ] + ( VAR07 [ VAR00 - 1 ] + VAR07 [ VAR00 ] ) * 2 ;\n    VAR09 [ VAR00 ] = VAR09 [ VAR00 - 1 ] + VAR06 [ VAR00 ] + VAR07 [ VAR00 ] ;\n  }\n\n  for ( VAR02 = 1 ; VAR02 < VAR03 ; VAR02 ++ ) {\n    for ( VAR00 = 0 ; VAR00 < VAR03 - VAR02 ; VAR00 ++ ) {\n      VAR04 = VAR08 [ VAR00 ] [ VAR00 ] + VAR08 [ VAR00 + 1 ] [ VAR00 + VAR02 + 1 ] ;\n      for ( VAR01 = VAR00 ; VAR01 < VAR00 + VAR02 ; VAR01 ++ ) {\n        VAR05 = VAR08 [ VAR00 ] [ VAR01 + 1 ] + VAR08 [ VAR01 + 2 ] [ VAR00 + 1 + VAR02 ] ;\n        if ( VAR04 > VAR05 ) VAR04 = VAR05 ;\n      }\n      VAR08 [ VAR00 ] [ VAR00 + VAR02 + 1 ] = VAR04 + VAR09 [ VAR00 + VAR02 ] - VAR09 [ VAR00 - 1 ] + VAR07 [ VAR00 + VAR02 + 1 ] ;\n    }\n  }\n  printf ( \"%lf\\n\" , VAR08 [ 0 ] [ VAR03 ] ) ;\n\n  return 0 ;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 1000\n\nint main(void)\n{\n\tint i , n;\n\tscanf(\"%d\",&n);\n\tdouble a[n];\n\t\n\tfor(i = 0; i < n; i++){\n\t\t\n\t\tscanf(\"%lf\",&a[i]);\n\t}\n\tdouble b[n+1];\n\t\n\tfor(i = 0; i <= n; i++){\n\t\t\n\t\tscanf(\"%lf\",&b[i]);\n\t}\n\t\n\t\n\tdouble c[n+1][n+1];\n\tdouble d[n+1];\n\tc[0][0]=b[0];\n\td[0]=a[0]+b[0];\n\t\n\tfor(i = 1; i <= n; i++){\n\t\t\n\t\tc[i][i] = b[i];\n\t\tc[i-1][i] = a[i-1]+(b[i-1]+b[i])*2;\n\t\td[i] = d[i-1]+a[i]+b[i];\n\t}\n\tint j , k;\n\tdouble s , t;\n\tfor(i = 1;i < n; i++){\n\t\t\n\t\tfor(j = 0; j < n-i; j++){\n\t\t\t\n\t\t\ts = c[j][j] + c[j+1][i+j+1];\n\t\t\t\n\t\t\tfor(k = j; k <i+j; k++){\n\t\t\t\t\n\t\t\t\tt = c[j][k+1]+c[k+2][i+j+1];\n\t\t\t\tif(s>t) s = t;\n\t\t\t}\n\t\t\tc[j][i+j+1] = s + d[i+j] - d[j-1] + b[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\",c[0][n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 600\n\nint main(){\n  int i, j, k;\n  int n;\n  double v, t;\n  double data1[MAX], data2[MAX+1], data3[MAX+1][MAX+1], ans_data[MAX+1];\n\n  scanf(\"%d\", &n);\n  for (i = 0 ; i < n ; i++) fscanf(stdin, \"%lf\", data1+i);\n  fscanf(stdin, \"%lf\", data2);\n  data3[0][0] = data2[0];\n  ans_data[0] = data1[0]+data2[0];\n  for (i = 1 ; i <= n ; i++) {\n    fscanf(stdin, \"%lf\", data2+i);\n    data3[i][i] = data2[i];\n    data3[i-1][i] = data1[i-1]+(data2[i-1]+data2[i])*2;\n    ans_data[i] = ans_data[i-1]+data1[i]+data2[i];\n  }\n\n  for (k = 1 ;   k < n ; k++) {\n    for (i = 0 ; i < n - k ; i++) {\n      v = data3[i][i] + data3[i+1][i+k+1];\n      for (j = i ; j < i + k ; j++) {\n        t = data3[i][j+1] + data3[j+2][i+1+k];\n        if (v > t) v = t;\n      }\n      data3[i][i + k + 1] = v + ans_data[i + k] - ans_data[i - 1] + data2[i + k + 1];\n    }\n  }\n  printf(\"%lf\\n\", data3[0][n]);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 1000000\n\nint main(void)\n{\n\tint i, n;\n\tscanf(\"%d\",&n);\n\tdouble a[n];\n\t\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lf\",&a[i]);\n\t}\n\tdouble b[n+1];\n\tfor(i = 0; i <= n; i++)\n\t{\n\t\tscanf(\"%lf\",&b[i]);\n\t}\n\tdouble c[n+1][n+1];\n\tdouble d[n+1];\n\tc[0][0]=b[0];\n\td[0]=a[0]+b[0];\n\t\n\tfor(i = 1; i <= n; i++)\n\t{\n\t\tc[i][i] = b[i];\n\t\tc[i-1][i] = a[i-1]+(b[i-1]+b[i])*2;\n\t\td[i] = d[i-1]+a[i]+b[i];\n\t}\n\tint j , k;\n\tdouble e, f;\n\tfor(i = 1;i < n; i++)\n\t{\n\t\tfor(j = 0; j < n-i; j++)\n\t\t{\n\t\t\te = c[j][j] + c[j+1][i+j+1];\n\t\t\tfor(k = j; k <i+j; k++)\n\t\t\t{\n\t\t\t\tf = c[j][k+1]+c[k+2][i+j+1];\n\t\t\t\tif(e>f) \n\t\t\t\t{\n\t\t\t\t\te = f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc[j][i+j+1] = e + d[i+j] - d[j-1] + b[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\",c[0][n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 1000\n\nint main(void)\n{\n\tint i , n;\n\tscanf(\"%d\",&n);\n\tdouble a[n];\n\t\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lf\",&a[i]);\n\t}\n\tdouble b[n+1];\n\tfor(i = 0; i <= n; i++)\n\t{\n\t\tscanf(\"%lf\",&b[i]);\n\t}\n\tdouble c[n+1][n+1];\n\tdouble d[n+1];\n\tc[0][0]=b[0];\n\td[0]=a[0]+b[0];\n\t\n\tfor(i = 1; i <= n; i++)\n\t{\n\t\tc[i][i] = b[i];\n\t\tc[i-1][i] = a[i-1]+(b[i-1]+b[i])*2;\n\t\td[i] = d[i-1]+a[i]+b[i];\n\t}\n\tint j , k;\n\tdouble s , t;\n\tfor(i = 1;i < n; i++)\n\t{\n\t\tfor(j = 0; j < n-i; j++)\n\t\t{\n\t\t\ts = c[j][j] + c[j+1][i+j+1];\n\t\t\tfor(k = j; k <i+j; k++)\n\t\t\t{\n\t\t\t\tt = c[j][k+1]+c[k+2][i+j+1];\n\t\t\t\tif(s>t) s = t;\n\t\t\t}\n\t\t\tc[j][i+j+1] = s + d[i+j] - d[j-1] + b[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\",c[0][n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 1000\n\nint main(void){\n\tint i , n;\n\tscanf(\"%d\",&n);\n\tdouble a[n];\n\t\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf\",&a[i]);\n\t}\n\t\n\tdouble b[n+1];\n\tfor(i = 0; i<= n; i++){\n\t\tscanf(\"%lf\",&b[i]);\n\t}\n\t\n\tdouble c[n+1][n+1];\n\tdouble d[n+1];\n\tc[0][0]=b[0];\n\td[0]=a[0]+b[0];\n\t\n\tfor(i = 1; i <= n; i++){\n\t\tc[i][i] = b[i];\n\t\tc[i-1][i] = a[i-1]+(b[i-1]+b[i])*2;\n\t\td[i] = d[i-1]+a[i]+b[i];\n\t}\n\t\n\tint j , k;\n\tdouble x,y;\n\tfor(i = 1;i < n; i++){\n\t\tfor(j = 0; j < n-i; j++){\n\t\t\tx = c[j][j] + c[j+1][i+j+1];\n\t\t\tfor(k = j; k <i+j; k++){\n\t\t\t\ty = c[j][k+1]+c[k+2][i+j+1];\n\t\t\t\tif(x>y) x = y;\n\t\t\t}\n\t\t\tc[j][i+j+1] = x + d[i+j] - d[j-1] + b[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\",c[0][n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define N 500\n\ndouble p[N+1], q[N+1];\ndouble r[N+2][N+2], s[N+2][N+2];\ndouble t[N+1][N+1];\n\nint main(void){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1; i<=n; ++i){\n        scanf(\"%lf\", &p[i]);\n    }\n    for(int i=0; i<=n; ++i){\n        scanf(\"%lf\", &q[i]);\n    }\n    for(int i=1; i!=n+2; ++i){\n        s[i][i-1]=q[i-1];\n        r[i][i-1]=q[i-1];\n    }\n    for(int l=1; l<=n; ++l){\n        for(int i=1; i<=n-l+1; ++i){\n            int j=i+l-1;\n            s[i][j]=(1<<21);\n            r[i][j]=r[i][j-1]+p[j]+q[j];\n            for(int k=i; k<=j; ++k){\n                double u = s[i][k-1]+s[k+1][j]+r[i][j];\n                if(u < s[i][j]){\n                    s[i][j]=u;\n                    t[i][j]=k;\n                }\n            }\n\n        }\n    }\n    printf(\"%f\\n\", s[1][n]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 1000\n\n\nint main(void){\n\tint i,n;\n\tscanf(\"%d\",&n);\n\tdouble p[n];\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%lf\",&p[i]);\n\t}\n\tdouble q[n+1];\n\tfor(i=0;i<=n;i++){\n\t\tscanf(\"%lf\",&q[i]);\n\t}\n\t\n\tdouble c[n+1][n+1];\n\tdouble d[n+1];\n\tc[0][0]=q[0];\n\td[0]=p[0]+q[0];\n\t\n\tfor(i=1;i<=n;i++){\n\t\tc[i][i]=q[i];\n\t\tc[i-1][i]=p[i-1]+(q[i-1]+q[i])*2;\n\t\td[i]=d[i-1]+p[i]+q[i];\n\t}\n\tint j,k;\n\tdouble s,t;\n\tfor (i=1; i<n; i++){\n\t\tfor (j=0; j<n-i; j++) {\n\t\t\ts = c[j][j] + c[j+1][i+j+1];\n\t\t\t\tfor (k=j; k<i+j; k++) {\n\t\t\t\t\tt = c[j][k+1] + c[k+2][i+j+1];\n\t\t\t\t\tif (s>t){\n\t\t\t\t\t\ts=t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[j][i+j+1] = s + d[i+j] - d[j-1] + q[i+j+1];\n\t\t\t}\n\t}\n\tprintf(\"%lf\\n\", c[0][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 1000\n\nint main(void){\n\tint i, n;\n\tscanf(\"%d\", &n);\n\tdouble p[n];\n\t\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf\",&p[i]);\n\t}\n\t\n\tdouble q[n+1];\n\tfor(i = 0; i<= n; i++){\n\t\tscanf(\"%lf\",&q[i]);\n\t}\n\t\n\tdouble Et[n+1][n+1];\n\tdouble d[n+1];\n\tEt[0][0]=q[0];\n\td[0]=p[0]+q[0];\n\t\n\tfor(i = 1; i <= n; i++){\n\t\tEt[i][i] = q[i];\n\t\tEt[i-1][i] = p[i-1]+(q[i-1]+q[i])*2;\n\t\td[i] = d[i-1]+p[i]+q[i];\n\t}\n\t\n\tint j, k;\n\tdouble x,y;\n\tfor(i = 1; i < n; i++){\n\t\tfor(j = 0; j < n-i; j++){\n\t\t\tx = Et[j][j] + Et[j+1][i+j+1];\n\t\t\tfor(k = j; k < i+j; k++){\n\t\t\t\ty = Et[j][k+1]+Et[k+2][i+j+1];\n\t\t\t\tif(x>y) x = y;\n\t\t\t}\n\t\t\tEt[j][i+j+1] = x + d[i+j] - d[j-1] + q[i+j+1];\n\t\t}\n\t}\n\tprintf(\"%lf\\n\",Et[0][n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.PrintWriter\nimport java.util.*\nimport kotlin.math.absoluteValue\n\ndata class PE(var p: Double, var e: Double)\ndata class Node(var center: PE, var left: PE, var right: PE, var lNode: Node?, var rNode: Node?) : Comparable<Node> {\n    override fun compareTo(other: Node): Int {\n        val a = center.e + center.p\n        val o = other.center.e + other.center.p\n        return if (a == o) 0\n        else if( a < o ) -1\n        else 1\n    }\n}\n\nfun main(args: Array<String>) = with(PrintWriter(System.out)) {\n    val n = readLine()!!.toInt()\n    val p = readLine()!!.trim().split(' ').map { it.toDouble() }\n    val q = readLine()!!.trim().split(' ').map { it.toDouble() }\n\n    val list = mutableListOf<Node>()\n    for (i in 0 until n) {\n        val c = p[i]\n        val l = q[i]\n        val r = q[i+1]\n        list.add(Node(PE(c+l+r, c+(l+r)*2), PE(l, l), PE(r, r), null, null))\n    }\n\n    list[0].rNode = list[1]\n    list[n-1].lNode = list[n-2]\n    for (i in 1 until n-1) {\n        list[i].lNode = list[i-1]\n        list[i].rNode = list[i+1]\n    }\n\n    // pop min e+p\n    val queue = PriorityQueue<Node>(n)\n    queue.addAll(list)\n\n    while (queue.size != 1) {\n        val minNode = queue.poll()\n\n        if (minNode.rNode != null) {\n            val rNode = minNode.rNode!!\n            queue.remove(rNode)\n            rNode.center.p = rNode.center.p - rNode.left.p + minNode.center.p\n            rNode.center.e = rNode.center.e - rNode.left.e - rNode.left.p + minNode.center.e + minNode.center.p\n            rNode.left = minNode.center\n            rNode.lNode = minNode.lNode\n            queue.add(rNode)\n        }\n\n        if (minNode.lNode != null) {\n            val lNode = minNode.lNode!!\n            queue.remove(lNode)\n            lNode.center.p = lNode.center.p - lNode.right.p + minNode.center.p\n            lNode.center.e = lNode.center.e - lNode.right.e - lNode.right.p + minNode.center.e + minNode.center.p\n            lNode.right = minNode.center\n            lNode.rNode = minNode.rNode\n            queue.add(lNode)\n        }\n    }\n\n    assert(queue.size == 1)\n    val minNode = queue.poll()\n    assert( (minNode.center.p - 1.0).absoluteValue < 1e-5 )\n    println(minNode.center.e)\n    flush()\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.PrintWriter\nimport java.util.*\n\ndata class PE(var p: Double, var e: Double)\ndata class Node(var center: PE, var left: PE, var right: PE, var lNode: Node?, var rNode: Node?) : Comparable<Node> {\n    override fun compareTo(other: Node): Int {\n        val a = center.e + center.p\n        val o = other.center.e + other.center.p\n        return if (a == o) 0\n        else if( a < o ) -1\n        else 1\n    }\n}\n\nfun main(args: Array<String>) = with(PrintWriter(System.out)) {\n    val n = readLine()!!.toInt()\n    val p = readLine()!!.trim().split(' ').map { it.toDouble() }\n    val q = readLine()!!.trim().split(' ').map { it.toDouble() }\n\n    val list = mutableListOf<Node>()\n    for (i in 0 until n) {\n        val c = p[i]\n        val l = q[i]\n        val r = q[i+1]\n        list.add(Node(PE(c+l+r, c+(l+r)*2), PE(l, l), PE(r, r), null, null))\n    }\n\n    if ( n == 1 ) {\n        print(list[0].center.e)\n        flush()\n        return\n    }\n\n    list[0].rNode = list[1]\n    list[n-1].lNode = list[n-2]\n    for (i in 1 until n-1) {\n        list[i].lNode = list[i-1]\n        list[i].rNode = list[i+1]\n    }\n\n    // pop min e+p\n    val queue = PriorityQueue<Node>(n)\n    queue.addAll(list)\n\n    while (queue.size != 1) {\n        val minNode = queue.poll()\n\n        if (minNode.rNode != null) {\n            val rNode = minNode.rNode!!\n            queue.remove(rNode)\n            rNode.center.p = rNode.center.p - rNode.left.p + minNode.center.p\n            rNode.center.e = rNode.center.e - rNode.left.e - rNode.left.p + minNode.center.e + minNode.center.p\n            rNode.left = minNode.center\n            rNode.lNode = minNode.lNode\n            queue.add(rNode)\n        }\n\n        if (minNode.lNode != null) {\n            val lNode = minNode.lNode!!\n            queue.remove(lNode)\n            lNode.center.p = lNode.center.p - lNode.right.p + minNode.center.p\n            lNode.center.e = lNode.center.e - lNode.right.e - lNode.right.p + minNode.center.e + minNode.center.p\n            lNode.right = minNode.center\n            lNode.rNode = minNode.rNode\n            queue.add(lNode)\n        }\n    }\n\n    val minNode = queue.poll()\n    println(minNode.center.e)\n    flush()\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.PrintWriter\nimport java.util.*\nimport kotlin.math.absoluteValue\n\ndata class PE(var p: Double, var e: Double)\ndata class Node(var center: PE, var left: PE, var right: PE, var lNode: Node?, var rNode: Node?) : Comparable<Node> {\n    override fun compareTo(other: Node): Int {\n        val a = center.e + center.p\n        val o = other.center.e + other.center.p\n        return if (a == o) 0\n        else if( a < o ) -1\n        else 1\n    }\n}\n\nfun main(args: Array<String>) = with(PrintWriter(System.out)) {\n    val n = readLine()!!.toInt()\n    val p = readLine()!!.trim().split(' ').map { it.toDouble() }\n    val q = readLine()!!.trim().split(' ').map { it.toDouble() }\n\n    val list = mutableListOf<Node>()\n    for (i in 0 until n) {\n        val c = p[i]\n        val l = q[i]\n        val r = q[i+1]\n        list.add(Node(PE(c+l+r, c+(l+r)*2), PE(l, l), PE(r, r), null, null))\n    }\n\n    list[0].rNode = list[1]\n    list[n-1].lNode = list[n-2]\n    for (i in 1 until n-1) {\n        list[i].lNode = list[i-1]\n        list[i].rNode = list[i+1]\n    }\n\n    // pop min e+p\n    val queue = PriorityQueue<Node>(n)\n    queue.addAll(list)\n\n    while (queue.size != 1) {\n        val minNode = queue.poll()\n\n        if (minNode.rNode != null) {\n            val rNode = minNode.rNode!!\n            queue.remove(rNode)\n            rNode.center.p = rNode.center.p - rNode.left.p + minNode.center.p\n            rNode.center.e = rNode.center.e - rNode.left.e - rNode.left.p + minNode.center.e + minNode.center.p\n            rNode.left = minNode.center\n            rNode.lNode = minNode.lNode\n            queue.add(rNode)\n        }\n\n        if (minNode.lNode != null) {\n            val lNode = minNode.lNode!!\n            queue.remove(lNode)\n            lNode.center.p = lNode.center.p - lNode.right.p + minNode.center.p\n            lNode.center.e = lNode.center.e - lNode.right.e - lNode.right.p + minNode.center.e + minNode.center.p\n            lNode.right = minNode.center\n            lNode.rNode = minNode.rNode\n            queue.add(lNode)\n        }\n    }\n\n    val minNode = queue.poll()\n    println(minNode.center.e)\n    flush()\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.PrintWriter\nimport java.util.*\n\ndata class PE(var p: Double, var e: Double)\ndata class Node(var center: PE, var left: PE, var right: PE, var lNode: Node?, var rNode: Node?) : Comparable<Node> {\n    override fun compareTo(other: Node): Int {\n        val a = center.e + center.p\n        val o = other.center.e + other.center.p\n        return if (a == o) 0\n        else if( a < o ) -1\n        else 1\n    }\n}\n\nfun main(args: Array<String>) = with(PrintWriter(System.out)) {\n    val n = readLine()!!.toInt()\n    val p = readLine()!!.trim().split(' ').map { it.toDouble() }\n    val q = readLine()!!.trim().split(' ').map { it.toDouble() }\n\n    val list = mutableListOf<Node>()\n    for (i in 0 until n) {\n        val c = p[i]\n        val l = q[i]\n        val r = q[i+1]\n        list.add(Node(PE(c+l+r, c+(l+r)*2), PE(l, l), PE(r, r), null, null))\n    }\n\n    list[0].rNode = list[1]\n    list[n-1].lNode = list[n-2]\n    for (i in 1 until n-1) {\n        list[i].lNode = list[i-1]\n        list[i].rNode = list[i+1]\n    }\n\n    // pop min e+p\n    val queue = PriorityQueue<Node>(n)\n    queue.addAll(list)\n\n    while (queue.size != 1) {\n        val minNode = queue.poll()\n\n        if (minNode.rNode != null) {\n            val rNode = minNode.rNode!!\n            queue.remove(rNode)\n            rNode.center.p = rNode.center.p - rNode.left.p + minNode.center.p\n            rNode.center.e = rNode.center.e - rNode.left.e - rNode.left.p + minNode.center.e + minNode.center.p\n            rNode.left = minNode.center\n            rNode.lNode = minNode.lNode\n            queue.add(rNode)\n        }\n\n        if (minNode.lNode != null) {\n            val lNode = minNode.lNode!!\n            queue.remove(lNode)\n            lNode.center.p = lNode.center.p - lNode.right.p + minNode.center.p\n            lNode.center.e = lNode.center.e - lNode.right.e - lNode.right.p + minNode.center.e + minNode.center.p\n            lNode.right = minNode.center\n            lNode.rNode = minNode.rNode\n            queue.add(lNode)\n        }\n    }\n\n    val minNode = queue.poll()\n    println(minNode.center.e)\n    flush()\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.PrintWriter\nimport java.util.*\n\ndata class PE(var p: Double, var e: Double)\ndata class Node(var center: PE, var left: PE, var right: PE, var lNode: Node?, var rNode: Node?) : Comparable<Node> {\n    override fun compareTo(other: Node): Int {\n        val a = center.e + center.p\n        val o = other.center.e + other.center.p\n        return if (a == o) 0\n        else if( a < o ) -1\n        else 1\n    }\n}\n\nfun main(args: Array<String>) = with(PrintWriter(System.out)) {\n    val n = readLine()!!.toInt()\n    val p = readLine()!!.trim().split(' ').map { it.toDouble() }\n    val q = readLine()!!.trim().split(' ').map { it.toDouble() }\n\n    val list = mutableListOf<Node>()\n    for (i in 0 until n) {\n        val c = p[i]\n        val l = q[i]\n        val r = q[i+1]\n        list.add(Node(PE(c+l+r, c+(l+r)*2), PE(l, l), PE(r, r), null, null))\n    }\n\n    if ( n == 1 ) {\n        print(list[0].center.e)\n        flush()\n        return\n    }\n\n    list[0].rNode = list[1]\n    list[n-1].lNode = list[n-2]\n    for (i in 1 until n-1) {\n        list[i].lNode = list[i-1]\n        list[i].rNode = list[i+1]\n    }\n\n    // pop min e+p\n    val queue = PriorityQueue<Node>(n)\n    queue.addAll(list)\n\n    while (queue.size != 1) {\n        val minNode = queue.poll()\n\n        if (minNode.rNode != null) {\n            val rNode = minNode.rNode!!\n            queue.remove(rNode)\n            rNode.center.p = rNode.center.p - rNode.left.p + minNode.center.p\n            rNode.center.e = rNode.center.e - rNode.left.e - rNode.left.p + minNode.center.e + minNode.center.p\n            rNode.left = minNode.center\n            rNode.lNode = minNode.lNode\n            queue.add(rNode)\n        }\n\n        if (minNode.lNode != null) {\n            val lNode = minNode.lNode!!\n            queue.remove(lNode)\n            lNode.center.p = lNode.center.p - lNode.right.p + minNode.center.p\n            lNode.center.e = lNode.center.e - lNode.right.e - lNode.right.p + minNode.center.e + minNode.center.p\n            lNode.right = minNode.center\n            lNode.rNode = minNode.rNode\n            queue.add(lNode)\n        }\n    }\n\n    val minNode = queue.poll()\n    println(minNode.center.e)\n    flush()\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    private static double[] p;\n    private static double[] q;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        p = new double[n+1];\n        q = new double[n+1];\n        for (int i = 1; i <= n; i++) {\n            p[i] = in.nextDouble();\n        }\n        for (int i = 0; i <= n; i++) {\n            q[i] = in.nextDouble();\n        }\n        System.out.println(minimumCost());\n    }\n\n    private static double minimumCost() {\n        int n = p.length - 1;\n        double[][] weight = new double[n+2][n+1];\n        double[][] cost = new double[n+2][n+1];\n\n        for (int i = 1; i <= n + 1; i++) {\n            weight[i][i-1] = q[i-1];\n            cost[i][i-1] = q[i-1];\n        }\n\n        for (int size = 1; size <= n; size++) {\n            for (int i = 1; i <= n - size + 1; i++) {\n                int j = i + size - 1;\n                cost[i][j] = Double.MAX_VALUE;\n                weight[i][j] = weight[i][j-1] + p[j] + q[j];\n                for (int r = i; r <= j; r++) {\n                    double testCost = cost[i][r-1] + cost[r + 1][j] + weight[i][j];\n                    if (testCost < cost[i][j]) {\n                        cost[i][j] = testCost;\n                    }\n                }\n            }\n        }\n        return cost[1][n];\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        double[] p = new double[n+1];\n        double[] q = new double[n+1];\n        for(int i = 1; i <= n; i++) {\n            p[i] = input.nextDouble();\n        }\n        for(int i = 0; i <= n; i++) {\n            q[i] = input.nextDouble();\n        }\n        System.out.println(getMinCost(n, p, q));\n    }\n    private static double getMinCost(int n, double[] p, double[] q) {\n        double[][] e = new double[n+2][n+1];\n        double[][] w = new double[n+2][n+1];\n        for(int i = 0; i <=n; i++) {\n            e[i+1][i] = q[i];\n            w[i+1][i] = q[i];\n        }\n        for(int l = 1; l <= n; l++) {\n            for(int i = 1; i <= n-l+1; i++) {\n                int j = i + l - 1;\n                e[i][j] = Double.MAX_VALUE;\n                w[i][j] = w[i][j-1] + p[j] + q[j];\n                for (int k = i; k <= j; k++) {\n                    e[i][j] = Math.min(e[i][j], e[i][k-1] + e[k+1][j] + w[i][j]);\n                }\n            }\n        }\n        return e[1][n];\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    private static double[] p;\n    private static double[] q;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        p = new double[n+1];\n        q = new double[n+1];\n        for (int i = 1; i <= n; i++) {\n            p[i] = in.nextDouble();\n        }\n        for (int i = 0; i <= n; i++) {\n            q[i] = in.nextDouble();\n        }\n        System.out.println(minimumCost());\n    }\n\n    private static double minimumCost() {\n        int n = p.length - 1;\n        double[][] weight = new double[n+2][n+1];\n        double[][] cost = new double[n+2][n+1];\n\n        for (int i = 1; i <= n + 1; i++) {\n            weight[i][i-1] = q[i-1];\n            cost[i][i-1] = q[i-1];\n        }\n\n        for (int size = 1; size <= n; size++) {\n            for (int i = 1; i <= n - size + 1; i++) {\n                int j = i + size - 1;\n                cost[i][j] = Double.MAX_VALUE;\n                weight[i][j] = weight[i][j-1] + p[j] + q[j];\n                for (int r = i; r <= j; r++) {\n                    double testCost = cost[i][r-1] + cost[r + 1][j] + weight[i][j];\n                    if (testCost < cost[i][j]) {\n                        cost[i][j] = testCost;\n                    }\n                }\n            }\n        }\n        return cost[1][n];\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tdouble[] p = new double[n+1];\n\t\tdouble[] q = new double[n+1];\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tp[i] = Double.parseDouble(st.nextToken());\n\t\t}\n\t\tst = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tq[i] = Double.parseDouble(st.nextToken());\n\t\t}\n\t\treader.close();\n\t\tSystem.out.println(getMinCost(n, p, q));\n\t}\n\n\tprivate double getMinCost(int n, double[] p, double[] q) {\n\t\tdouble[][] e = new double[n+2][n+1];\n\t\tdouble[][] w = new double[n+2][n+1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\te[i+1][i] = q[i];\n\t\t\tw[i+1][i] = q[i];\n\t\t}\n\t\tfor (int l = 1; l <= n; l++) {\n\t\t\tfor (int i = 1; i <= n - l + 1; i++) {\n\t\t\t\tint j = i + l - 1;\n\t\t\t\te[i][j] = Double.MAX_VALUE;\n\t\t\t\tw[i][j] = w[i][j - 1] + p[j] + q[j];\n\t\t\t\tfor (int r = i; r <= j; r++) {\n\t\t\t\t\te[i][j] = Math.min(e[i][j], e[i][r-1] + e[r+1][j] + w[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn e[1][n];\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tint n = Integer.parseInt(br.readLine());\n\t\t\n\t\tdouble p[] = new double[n + 1];\n\t\tdouble q[] = new double[n + 1];\n\t\t\n\t\tString tmpArray[] = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tp[i + 1] = Double.parseDouble(tmpArray[i]);\n\t\t}\n\t\t\n\t\ttmpArray = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n + 1; i++){\n\t\t\tq[i] = Double.parseDouble(tmpArray[i]);\n\t\t}\n\t\t\n\t\tdouble e[][] = new double[n + 2][n + 1];\n\t\tint root[][] =  new int[n + 1][n + 1];\n\t\t\n\t\toptimalBST(p, q, e, root);\n\t\t\n\t\tSystem.out.printf(\"%.5f\\n\",e[1][n]);\n\t}\n\t\n\tstatic void optimalBST(double p[], double q[], double e[][], int root[][]){\n\t\tint n = p.length - 1;\n\t\t\n\t\tdouble[][] w = new double[n + 2][n + 1];\n\n\t\tfor(int i = 1; i <= n + 1; i++){\n\t\t\te[i][i - 1] = q[i - 1];\n\t\t\tw[i][i - 1] = q[i - 1];\n\t\t}\n\t\t\n\t\tfor(int l = 1; l <= n; l++){\n\t\t\tfor(int i = 1; i <= n - l + 1; i++){\n\t\t\t\tint j = i + l - 1;\n\t\t\t\te[i][j] = Double.MAX_VALUE;\n\t\t\t\t\n\t\t\t\tw[i][j] = w[i][j - 1] + p[j] + q[j];\n\t\t\t\t\n\t\t\t\tfor(int r = i; r <= j; r++){\n\t\t\t\t\tdouble t = e[i][r - 1] + e[r + 1][j] + w[i][j];\n\t\t\t\t\t\n\t\t\t\t\tif(t < e[i][j]){\n\t\t\t\t\t\te[i][j] = t;\n\t\t\t\t\t\troot[i][j] = r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tdouble[] d = new double[2*n+1];\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0, j = 1; i < n; i++, j+=2) {\n\t\t\td[j] = Double.parseDouble(st.nextToken());\n\t\t}\n\t\tst = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0, j = 0; i <= n; i++, j+=2) {\n\t\t\td[j] = Double.parseDouble(st.nextToken());\n\t\t}\n\t\treader.close();\n\t\tSystem.out.println(getMinCost(d));\n\t}\n\n\tprivate double getMinCost(double[] d) {\n\t\tint n = d.length;\n\t\tdouble[][] dp = new double[n+2][n+2];\n\t\tfor (int s = 0; s < n; s++) {\n\t\t\tfor (int i = 1, j = s + 2; j <= n+1; i++, j++) {\n\t\t\t\tdp[i][j] = Double.MAX_VALUE;\n\t\t\t\tdouble w = 0.0;\n\t\t\t\tfor (int l = i-1; l < j-1; l++) {\n\t\t\t\t\tw += d[l];\n\t\t\t\t}\n\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j] + w);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintDPTable(dp);\n\t\t}\n\t\treturn dp[1][n+1];\n\t}\n\n/*\n\tprivate void printDPTable(double[][] dp) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tfor (int j = 0; j < dp[0].length; j++) {\n\t\t\t\tsb.append(String.format(\"%.5f\", dp[i][j]));\n\t\t\t\tif (j != dp[0].length - 1) {\n\t\t\t\t\tsb.append(\"\\t\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\t\t\n\t\tSystem.out.println(sb.toString());\n\t}\n\t*/\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace ConsoleApp1\n{\n\n    class Program\n    {\n        static void Main()\n        {\n            int n = int.Parse(Console.ReadLine());\n            double[] p = new double[n], q = new double[n + 1];\n\t\t\tdouble[,] sp = new double[n, n], sq = new double[n + 1, n + 1], dp = new double[n + 1, n + 1];\n\n\t\t\tstring[][] pq = new string[2][]; pq[0] = Console.ReadLine().Split(' '); pq[1] = Console.ReadLine().Split(' ');\n            for (int i = 0; i < n; i++) {\n                p[i] = double.Parse(pq[0][i]);\n                q[i] = double.Parse(pq[1][i]);\n            } q[n] = double.Parse(pq[1][n]);\n\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tsp[i, i] = p[i];\n\t\t\t\tfor (int j = i + 1; j < n; j++) sp[i, j] = sp[i, j - 1] + p[j];\n\t\t\t}\n\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t{\n\t\t\t\tdp[i, i] = sq[i, i] = q[i];\n\t\t\t\tdp[i, i] = sq[i, i];\n\t\t\t\tfor (int j = i + 1; j <= n; j++) sq[i, j] = sq[i, j - 1] + q[j];\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j + i <= n; j++)\n\t\t\t\t{\n\t\t\t\t\tdp[j, j + i] = double.MaxValue;\n\t\t\t\t\tfor (int k = 0; k < i; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble v = dp[j, j + k] + dp[j + k + 1, j + i] + sp[j, j + i - 1] + sq[j, j + i];\n\t\t\t\t\t\tif (v < dp[j, j + i]) dp[j, j + i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tConsole.WriteLine(String.Format(\"{0:F8}\", dp[0, n]));\n\t\t}\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20190118_AOJ\n{\n    class ALDS1_10D\n    {\n        static double[,] sumTable;\n\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                int n = int.Parse(line);\n\n                double[] arrP = Console.ReadLine().Split(' ').Select(x => double.Parse(x)).ToArray();\n                double[] arrQ = Console.ReadLine().Split(' ').Select(x => double.Parse(x)).ToArray();\n\n                double[] arr = new double[2 * n + 1];\n                for (int i = 0; i < n; i++)\n                {\n                    arr[2 * i] = arrQ[i];\n                    arr[2 * i + 1] = arrP[i];\n                }\n                arr[2 * n] = arrQ[n];\n\n                CreateSumTable(arr);\n                //double ans = OptCost(arr, 0, 2 * n);\n                double ans = OptimalSearchTree(arr, 2 * n + 1);\n                Console.WriteLine(ans);\n            }\n        }\n\n        static double OptCost(double[] freq, int i, int j)\n        {\n            if (j < i)\n                return 0;\n\n            if (j == i)\n                return freq[i];\n\n            //double fsum = Sum(freq, i, j);\n            double fsum = sumTable[i, j];\n\n            double min = double.MaxValue;\n\n            for (int r = i; r <= j; ++r)\n            {\n                if (r % 2 == 0)\n                {\n                    continue;\n                }\n\n                double cost = OptCost(freq, i, r - 1)\n                    + OptCost(freq, r + 1, j);\n                if (cost < min)\n                {\n                    min = cost;\n                }\n            }\n\n            return min + fsum;\n        }\n\n        static double Sum(double[] freq, int i, int j)\n        {\n            double s = 0;\n            for (int k = i; k <= j; k++)\n                s += freq[k];\n            return s;\n        }\n\n        static void CreateSumTable(double[] freq)\n        {\n            int len = freq.Length;\n            sumTable = new double[len, len];\n\n            for (int i = 0; i < len; i++)\n            {\n                sumTable[i, i] = freq[i];\n            }\n\n            for (int i = 0; i < len - 1; i++)\n            {\n                for (int j = i + 1; j < len; j++)\n                {\n                    sumTable[i, j] = sumTable[i, j - 1] + freq[j];\n                }\n            }\n        }\n\n        static double OptimalSearchTree(double[] freq, int n)\n        {\n            double[,] cost = new double[n, n];\n\n            for (int i = 0; i < n; i++)\n            {\n                cost[i, i] = freq[i];\n            }\n\n            for (int L = 2; L <= n; L++)\n            {\n                for (int i = 0; i < n - L + 1; i++)\n                {\n                    int j = i + L - 1;\n                    cost[i, j] = double.MaxValue;\n\n                    for (int r = i; r <= j; r++)\n                    {\n                        if (r % 2 == 0)\n                        {\n                            continue;\n                        }\n\n                        double c =\n                            ((r > i) ? cost[i, r - 1] : 0) +\n                            ((r < j) ? cost[r + 1, j] : 0) +\n                            sumTable[i, j];\n                        if (c < cost[i, j])\n                        {\n                            cost[i, j] = c;\n                        }\n                    }\n                }\n            }\n\n            return cost[0, n - 1];\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        var P = cin.scandouble;\n        var Q = cin.scandouble;\n        var dp = new double[N + 1][];\n        var S = new int[N + 1][];\n        var D = new double[N + 2];\n        var K = new double[N + 1];\n        for (int i = 0; i <= N; i++)\n        {\n            dp[i] = new double[N + 1];\n            dp[i][i] = Q[i];\n            S[i] = new int[N + 1];\n            S[i][i] = i;\n            D[i + 1] = D[i] + Q[i];\n            if (i < N) K[i + 1] = K[i] + P[i];\n        }\n\n        for (int len = 1; len <= N; len++)\n        {\n            for (int i = 0; i + len <= N; i++)\n            {\n                var ret = double.MaxValue;\n                for (int mid = S[i][i + len - 1]; mid <= Min(S[i + 1][i + len], i + len - 1); mid++)\n                {\n                    if (chmin(ref ret, dp[i][mid] + dp[mid + 1][i + len]))\n                    {\n                        S[i][i + len] = mid;\n                    }\n                }\n                dp[i][i + len] = ret + D[i + len + 1] - D[i] + K[i + len] - K[i];\n            }\n        }\n        WriteLine(dp[0][N].ToString(\"F5\"));\n    }\n\n}\n\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace Dynamic_Programming\n{\n    class Optimal_Binary_Search_Tree\n    {\n        public static void Main()\n        {\n            var n = int.Parse(Console.ReadLine());\n            var p = Console.ReadLine().Split(' ').Select(s => double.Parse(s)).ToArray();\n            var q = Console.ReadLine().Split(' ').Select(s => double.Parse(s)).ToArray();\n\n            var cost = new double[n + 1, n];\n\n            for (int i = 0; i < n; i++)\n            {\n                cost[i, i] = 2 * q[i] + p[i] + 2 * q[i + 1];\n                if (0 <= i - 1) cost[i, i - 1] = q[i];\n                cost[i + 1, i] = q[i + 1];\n            }\n\n            for (int j = 1; j < n; j++)\n            {\n                for (int i = j - 1; 0 <= i; i--)\n                {\n                    var f = p.Skip(i).Take(j - i + 1).Sum() + q.Skip(i).Take(j + 1 - i + 1).Sum();\n\n                    var res = double.MaxValue;\n                    for (int r = i; r <= j; r++)\n                    {\n                        var tmp = (r > 0 ? cost[i, r - 1] : q[0]) + cost[r + 1, j];\n                        res = Math.Min(res, tmp);\n                    }\n\n                    cost[i, j] = res + f;\n                }\n            }\n\n            Console.WriteLine(cost[0, n - 1]);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace lec10D\n{\n\n    class Program\n    {\n      \n       public static  double[,] c ;\n        public static double[] a ;\n        public static double[] b ;\n        public static int[,] k_arr;\n\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            c = new double[n+2,n+2];\n            a = new double[n+1];\n             b = new double[n+1];\n            k_arr =  new int[n + 2, n + 2];\n            string[] input_a = Console.ReadLine().Split(' ');\n            string[] input_b = Console.ReadLine().Split(' ');\n            double all = 0.0;\n\n            for (int i = 0; i < n; i++)\n            {\n                a[i + 1] = double.Parse(input_a[i]);\n                b[i] = double.Parse(input_b[i]);\n                c[i + 1, i] = 0;\n                all += b[i];\n            }\n            b[n] = double.Parse(input_b[n]);\n            c[n + 1, n] = 0;\n            all += b[n];\n\n\n            for (int h = 0; h < n; h++)\n            {\n                for (int i = 1; i <= n - h; i++)\n                {\n                    int j = i + h;\n                    int s;\n                    int e;\n                    if (h != 0) {\n                        s = k_arr[i, j - 1];\n                        e = k_arr[i + 1, j];\n                    }\n                    else\n                    {\n                        s = i;\n                        e = j;\n                    }\n                    for (int k = s; k <= e; k++)\n                    {\n                        c[i, j] = Min( i ,j ) ;\n                    }\n\n                }\n            }\n\n            Console.WriteLine(\"{0:F9}\",(c[1,n]+all));\n\n            Console.ReadLine();\n\n        }\n        static double Min(int  i, int j )\n        {\n            double t;\n            double min  = c[i, i - 1] + c[i + 1, j];\n            int k;\n            for ( k = i; k <= j; k++)\n            {\n\n                t = c[i, k - 1] + c[k + 1, j];\n                if (t < min)\n                {\n                    min = t;\n                }\n            }\n\n            k_arr[i, j] = k;\n\n            double re_all =  0.0;\n            re_all += b[i-1];\n\n            for (int index_a = i ; index_a <= j; index_a++)\n            {\n                re_all += a[index_a]+ b[index_a];\n\n            }\n            return (min+re_all);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ALDS1_10_D\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            int n = ReadInt();\n            double[] p = ReadDoubleAr();\n            double[] q = ReadDoubleAr();\n            double[,] dp = new double[n + 2, n + 1];\n            double[,] wt = new double[n + 2, n + 1];\n\n            for (int i = 1 ; i <= n + 1 ; i++)\n            {\n                for (int j = i - 1 ; j <= n ; j++)\n                {\n                    if (j == i - 1)\n                    {\n                        wt[i, j] = q[j];\n                        dp[i, j] = q[j];\n                    }\n                    else\n                    {\n                        dp[i, j] = long.MaxValue;\n                        wt[i, j] = wt[i, j - 1] + p[j - 1] + q[j];\n                    }\n                }\n            }\n\n            for (int k = 0 ; k <= n ; k++)\n            {\n                for (int i = 1 ; i + k <= n ; i++)\n                {\n                    int j = i + k;\n                    for (int m = i ; m <= j ; m++)\n                    {\n                        double tmp = dp[i, m - 1] + dp[m + 1, j] + wt[i, j];\n                        dp[i, j] = Math.Min(dp[i, j], tmp);\n                    }\n                }\n            }\n\n            Console.WriteLine(dp[1, n].ToString());\n\n        }\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n\n    }\n\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t// \"github.com/pkg/profile\"\n)\n\nfunc mkTbl(n int, ds []float64) [][]float64 {\n\ttbl := make([][]float64, n+1)\n\tfor i := range tbl {\n\t\ttbl[i] = make([]float64, n+1)\n\t}\n\tfor i := 0; i <= n; i++ {\n\t\ttbl[i][i] = ds[i]\n\t}\n\treturn tbl\n}\n\nfunc mkWeights(n int, ps, ds []float64) [][]float64 {\n\ttbl := mkTbl(n, ds)\n\tfor i := 0; i < n; i++ {\n\t\tw := ds[i]\n\t\tfor j := i + 1; j <= n; j++ {\n\t\t\tw += ps[j] + ds[j]\n\t\t\ttbl[i][j] = w\n\t\t}\n\t}\n\treturn tbl\n}\n\nfunc minCost(i, j int, tbl [][]float64) float64 {\n\tm := math.MaxFloat64\n\tfor k := i + 1; k <= j; k++ {\n\t\tm = math.Min(m, tbl[i][k-1]+tbl[k][j])\n\t}\n\treturn m\n}\n\nfunc solve(n int, ps, ds []float64) float64 {\n\tcosts := mkTbl(n, ds)\n\tweights := mkWeights(n, ps, ds)\n\tfor l := 1; l <= n; l++ {\n\t\tfor i := 0; i <= n-l; i++ {\n\t\t\tj := i + l\n\t\t\tcosts[i][j] = weights[i][j] + minCost(i, j, costs)\n\t\t}\n\t}\n\treturn costs[0][n]\n}\n\nfunc main() {\n\t// defer profile.Start(profile.ProfilePath(\".\")).Stop()\n\n\tw := bufio.NewWriter(os.Stdout)\n\ts := bufio.NewScanner(os.Stdin)\n\ts.Split(bufio.ScanWords)\n\n\ts.Scan()\n\tn, _ := strconv.Atoi(s.Text())\n\tps := make([]float64, n+1)\n\tds := make([]float64, n+1)\n\n\tfor i := 1; i <= n; i++ {\n\t\ts.Scan()\n\t\tps[i], _ = strconv.ParseFloat(s.Text(), 64)\n\t}\n\n\tfor i := 0; i < n+1; i++ {\n\t\ts.Scan()\n\t\tds[i], _ = strconv.ParseFloat(s.Text(), 64)\n\t}\n\n\tif s.Err() != nil {\n\t\tlog.Fatal(\"scan error\")\n\t}\n\n\tfmt.Fprintf(w, \"%.4f\\n\", solve(n, ps, ds))\n\t_ = w.Flush()\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tvar n int\n\tfmt.Scan(&n)\n\n\tp := make([]float64, n+1)\n\tq := make([]float64, n+1)\n\tpsum := make([]float64, n+2) // i番目はi-1までの和とする\n\tqsum := make([]float64, n+2) // i番目はi-1までの和とする\n\tfor i := 1; i <= n; i++ {\n\t\tfmt.Scan(&p[i])\n\t\tpsum[i+1] = psum[i] + p[i]\n\t}\n\tfor i := 0; i <= n; i++ {\n\t\tfmt.Scan(&q[i])\n\t\tqsum[i+1] = qsum[i] + q[i]\n\t}\n\n\tdp := make([][]float64, n+1)\n\tfor i := 0; i <= n; i++ {\n\t\tdp[i] = make([]float64, n+1)\n\t}\n\n\t// calc\n\tfor d := 0; d <= n; d++ {\n\t\tfor l := 0; l+d <= n; l++ {\n\t\t\tr := l+d\n\t\t\tif l == r {\n\t\t\t\tdp[l][r] = q[l]\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdp[l][r] = 1 << 30\n\t\t\t// iは中心となるnode\n\t\t\tfor i := l+1; i <= r; i++ {\n\t\t\t\tleft := dp[l][i-1] + psum[i] - psum[l+1] + qsum[i] - qsum[l]\n\t\t\t\tright := dp[i][r] + psum[r+1] - psum[i+1] + qsum[r+1] - qsum[i]\n\t\t\t\tdp[l][r] = math.Min(dp[l][r], p[i] + left + right)\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Printf(\"%.8f\\n\", dp[0][n])\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\nfunc nextFloat64() (float64, error) {\n\treturn strconv.ParseFloat(nextString(), 64)\n}\n\nvar infty = math.MaxFloat64\n\nfunc optimalBst(p []float64, q []float64, n int) ([][]float64, [][]int) {\n\te := make([][]float64, n+2)\n\tfor i := 0; i <= n+1; i++ {\n\t\te[i] = make([]float64, n+1)\n\t}\n\tw := make([][]float64, n+2)\n\tfor i := 0; i <= n+1; i++ {\n\t\tw[i] = make([]float64, n+1)\n\t}\n\troot := make([][]int, n+1)\n\tfor i := 0; i <= n; i++ {\n\t\troot[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n+1; i++ {\n\t\te[i][i-1] = q[i-1]\n\t\tw[i][i-1] = q[i-1]\n\t}\n\tfor l := 1; l <= n; l++ {\n\t\tfor i := 1; i <= n-l+1; i++ {\n\t\t\tj := i + l - 1\n\t\t\te[i][j] = infty\n\t\t\tw[i][j] = w[i][j-1] + p[j] + q[j]\n\t\t\tfor r := i; r <= j; r++ {\n\t\t\t\tt := e[i][r-1] + e[r+1][j] + w[i][j]\n\t\t\t\tif t < e[i][j] {\n\t\t\t\t\te[i][j] = t\n\t\t\t\t\troot[i][j] = r\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn e, root\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tn := nextInt()\n\tp := make([]float64, n+1)\n\tq := make([]float64, n+1)\n\tfor i := 1; i <= n; i++ {\n\t\tp[i], _ = nextFloat64()\n\t}\n\tfor i := 0; i <= n; i++ {\n\t\tq[i], _ = nextFloat64()\n\t}\n\n\t// fmt.Println(p)\n\t// fmt.Println(q)\n\n\te, _ := optimalBst(p, q, n)\n\n\t// fmt.Println(root)\n\tfmt.Println(e[1][n])\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(sys.stdin.readline())\n\nky = list(map(float, sys.stdin.readline().split()))\ndm = list(map(float, sys.stdin.readline().split()))\ndepth = [0]*n\nans = max(max(ky),max(dm))*(n*2+1)*(n+1)\n\nprint(ky, dm)\n\n\ndef traverse(d, s, e, note):\n    global ans\n    if s==e:\n        depth[s]=d\n        r = 0\n        for i in range(n):         r += depth[i]*ky[i]\n        r += (depth[0]+1)*dm[0]\n        for i in range(1, n):      r += (max(depth[i-1], depth[i])+1)*dm[i]\n        r += (depth[n-1]+1)*dm[n]\n        if ans>r: ans = r\n        return\n    for m in range(s, e+1):\n        depth[m]=d\n        if s<=m-1: traverse(d+1,  s, m-1, 'left')\n        if m+1<=e: traverse(d+1, m+1, e, 'right')\n\n\ntraverse(1, 0, n-1, '')\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN = int(readline())\n*P, = map(float, readline().split())\n*Q, = map(float, readline().split())\n\nK = [[None]*(N+1) for i in range(N+1)]\nC = [[None]*(N+1) for i in range(N+1)]\nS = [0]*(2*N+2)\nfor i in range(2*N+1):\n    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])\n\nfor i in range(N+1):\n    C[i][i] = Q[i]\n    K[i][i] = i\n\nfor l in range(1, N+1):\n    for i in range(N+1-l):\n        j = i+l\n        k0 = K[i][j-1]; k1 = K[i+1][j]\n        tmp = 1e30\n        k2 = None\n        for k in range(k0, min(k1+1, j)):\n            v = C[i][k] + C[k+1][j]\n            if v < tmp:\n                k2 = k\n                tmp = v\n        K[i][j] = k2\n        C[i][j] = tmp + (S[2*j+1] - S[2*i])\nwrite(\"%.10f\\n\" % C[0][N])\n\n"
  },
  {
    "language": "Python",
    "code": "global memo\nglobal memo_pq\nglobal p_list\nglobal q_list\n\n\n\ndef mk_memo(i,j):#memo[i][j]を求める\n    tmp_min=9999999\n    for k in range(1,j-1):\n        tmp=p_list[i+k] + memo[i][k] + memo_pq[i][k] + memo[i+k+1][j-k-1] + memo_pq[i+k+1][j-k-1]\n        if(tmp < tmp_min):\n            tmp_min=tmp\n    if(j!=1):\n        tmp_min=min([tmp_min, p_list[i] +2*q_list[i] + memo[i+1][j-1] +memo_pq[i+1][j-1]])\n        tmp_min=min([tmp_min, p_list[i+j-1] +2*q_list[i+j] + memo[i][j-1] +memo_pq[i][j-1]])\n    else:\n        tmp_min=p_list[i] + 2*q_list[i] + 2*q_list[i+1]\n    memo[i][j]=tmp_min\n\n\n\nn=int(input())\np_list=list(map(float,input().split()))\nq_list=list(map(float,input().split()))\n\n\n\nmemo=[[0]*(n+1-i) for i in range(n+1)]#memo[i][j]はlist[i]から始まるj個の部分集合に対する解\nmemo_pq=[[0]*(n+1-i) for i in range(n+1)]#memo_pq[i][j]はlist[i]から始まる\n                                       #ｊ個の部分集合に対応する重みpと重みqの和\nfor p in range(n+1):\n    for q in range(n+1-p):\n        if(q==0):\n            memo_pq[p][q]=q_list[p]\n        else:\n            memo_pq[p][q]=memo_pq[p][q-1] + p_list[p+q-1] + q_list[p+q]\n    \n\n\n\nfor i in range(n):\n    for j in range(1,2+i):\n        mk_memo(n-1-i,j)\n\nprint(memo[0][-1])\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nA=[0.0]+[float(i) for i in input().split()]\nB=[float(i) for i in input().split()]\nW={}\nE={}\nfor i in range(1,n+2):\n    W[i,i-1] = B[i-1]\n    E[i,i-1] = B[i-1],i\nfor i in range(1,n+1):\n    for j in range(i,n+1):\n        W[i,j] = W[i,j-1]+A[j]+B[j]\nfor i in range(1,n+1):\n    E[i,i] = E[i,i-1][0] + E[i+1,i][0] + W[i,i],i\nfor h in range(1,n):\n    for i in range(1,n-h+1):\n        e = 1001,None\n        j = i + h\n        k0 = E[i,j-1][1]\n        k1 = E[i+1,j][1]\n        for r in range(k0,k1+1):\n            tmp = E[i,r-1][0] + E[r+1,j][0] + W[i,j]\n            if tmp < e[0]:\n                e = tmp,r\n        E[i,j] = e\nprint(E[1,n][0])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN = int(readline())\n*P, = map(float, readline().split())\n*Q, = map(float, readline().split())\n\nK = [[None]*(N+1) for i in range(N+1)]\nC = [[None]*(N+1) for i in range(N+1)]\nS = [0]*(2*N+2)\nfor i in range(2*N+1):\n    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])\n\nfor i in range(N+1):\n    C[i][i] = Q[i]\n    K[i][i] = i\n\nfor l in range(1, N+1):\n    for i in range(N+1-l):\n        j = i+l\n        k0 = K[i][j-1]; k1 = K[i+1][j]\n        tmp = 1e30\n        k2 = None\n        for k in range(k0, min(k1+1, j)):\n            v = C[i][k] + C[k+1][j]\n            if v < tmp:\n                k2 = k\n                tmp = v\n        K[i][j] = k2\n        C[i][j] = tmp + (S[2*j+1] - S[2*i])\nwrite(\"%.10f\\n\" % C[0][N])\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(sys.stdin.readline())\na = [0.0] * (2*n+1)\nb = list(map(float, sys.stdin.readline().split()))\nfor i,c in enumerate(b):    a[i*2+1] = c\nb = list(map(float, sys.stdin.readline().split()))\nfor i,c in enumerate(b):    a[i*2] = c\ndepth = [0]*(n*2+1)\nans = max(a)*(n*2+1)*(n+1)\ndef walk(d, s, e):\n    global ans\n    if s>=e:\n        depth[s*2+1]=d\n        er = 0\n        for i in range(0,n*2+1,2):\n            if i==0:      depth[i]=depth[i+1]+1\n            elif i==n*2:  depth[i]=depth[i-1]+1\n            else:         depth[i]=max(depth[i-1],depth[i+1])+1\n        for i in range(n*2+1):\n            er += (depth[i]+1)*a[i]\n        if ans>er: ans = er\n        return\n    for m in range(s, e+1):\n        depth[m*2+1]=d\n        if s<=m-1:  walk(d+1,  s, m-1)\n        if m+1<=e:  walk(d+1, m+1, e)\n        \nwalk(0, 0, n-1)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\np=[float(i) for i in input().split()]\nq=[float(i) for i in input().split()]\npq = [q[-1]]*(2*n+1)\ndp = {}\nfor i in range(n):\n    pq[2*i] = q[i]\n    pq[2*i+1] = p[i]\npq = [0.0]+pq\nfor j in range(len(pq)):\n    for i in range(len(pq)-j):\n        if j == 0:\n            dp[(i,i+j)] = 0.0\n        elif j == 1:\n            dp[(i,i+j)] = pq[i+j]\n        else:\n            tmp = 1001\n            for k in range(j):\n                c = dp[(i,i+k)] + dp[(i+k+1,i+j)]+sum(pq[i+1:i+j+1])\n                if c < tmp:\n                    if j == len(pq)-1 and i+k % 2 == 1:\n                        continue\n                    tmp = c\n            dp[(i,i+j)] = tmp\nprint(dp[(0,2*n+1)])\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\np=[float(i) for i in input().split()]\nq=[float(i) for i in input().split()]\npq = [q[-1]]*2*(n+1)\ndp = {}\nfor i in range(n):\n    pq[2*i+1] = q[i]\n    pq[2*i+2] = p[i]\nfor i in range(len(pq)):\n    for j in range(len(pq)-i):\n        if i == 0:\n            dp[(j,j+i)] = 0\n        elif i == 1:\n            dp[(j,j+i)] = pq[j+i]\n        else:\n            tmp = 1001\n            for k in range(i):\n                c = dp[(j,j+k)] + dp[(j+k+1,j+i)]+sum(pq[j+1:j+i+1])\n                if c < tmp:\n                    tmp = c\n            dp[(j,j+i)] = tmp\nprint(dp[(0,2*n+1)])\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(sys.stdin.readline())\na = [0.0] * (2*n+1)\nb = list(map(float, sys.stdin.readline().split()))\nfor i,c in enumerate(b):    a[i*2+1] = c\nb = list(map(float, sys.stdin.readline().split()))\nfor i,c in enumerate(b):    a[i*2] = c\ndepth = [0]*(n*2+1)\nans = max(a)*(n*2+1)*n\ndef walk(d, s, e):\n    global ans\n    if s>=e:\n        depth[s*2+1]=d\n        er = 0\n        for i in range(0,n*2+1,2):\n            if i==0:      depth[i]=depth[i+1]+1\n            elif i==n*2:  depth[i]=depth[i-1]+1\n            else:         depth[i]=max(depth[i-1],depth[i+1])+1\n        for i in range(n*2+1):\n            er += (depth[i]+1)*a[i]\n        if ans>er: ans = er\n        return\n    for m in range(s, e+1):\n        depth[m*2+1]=d\n        if s<=m-1:  walk(d+1,  s, m-1)\n        if m+1<=e:  walk(d+1, m+1, e)\n        \nwalk(0, 0, n-1)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "if __name__ == \"__main__\":\n    num_nodes = int(input())\n    P = list(map(lambda x: float(x), input().split()))\n    Q = list(map(lambda x: float(x), input().split()))\n\n    Depth = [[0] * (num_nodes + 1) for i in range(num_nodes + 1)]\n    Exp = [[0.0] * (num_nodes + 1) for i in range(num_nodes + 1)]\n    Cum_prob = [0.0] * (2 * num_nodes + 2)\n\n    for i in range(2 * num_nodes + 1):\n        Cum_prob[i + 1] = Cum_prob[i] + (P[i // 2] if i % 2 else Q[i // 2])\n\n    for i in range(num_nodes + 1):\n        Exp[i][i] = Q[i]\n        Depth[i][i] = i\n\n    for l in range(1, num_nodes + 1):\n        for i in range(num_nodes + 1 - l):\n            j = i + l\n            d0 = Depth[i][j - 1]\n            d1 = Depth[i + 1][j]\n            d2 = -1\n            cost = 1e30\n            for k in range(d0, min(d1 + 1, j)):\n                v = Exp[i][k] + Exp[k + 1][j]\n                if v < cost:\n                    d2 = k\n                    cost = v\n            Depth[i][j] = d2\n            Exp[i][j] = cost + Cum_prob[2 * j + 1] - Cum_prob[2 * i]\n\n    print(f\"{Exp[0][num_nodes]:.5f}\")\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\np=[float(i) for i in input().split()]\nq=[float(i) for i in input().split()]\npq = [q[-1]]*2*(n+1)\ndp = {}\nfor i in range(n):\n    pq[2*i+1] = q[i]\n    pq[2*i+2] = p[i]\nfor i in range(len(pq)):\n    for j in range(len(pq)-i):\n        if i == 0:\n            dp[(j,j+i)] = 0\n        elif i == 1:\n            dp[(j,j+i)] = pq[j+i]\n        else:\n            tmp = 1001\n            for k in range(i):\n                c = dp[(j,j+k)] + dp[(j+k+1,j+i)]+sum(pq[j+1:j+i+1])\n                if c < tmp:\n                    tmp = c\n            dp[(j,j+i)] = tmp\nprint(dp[(0,2*n+1)])\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(sys.stdin.readline())\n\nky = list(map(float, sys.stdin.readline().split()))\ndm = list(map(float, sys.stdin.readline().split()))\ndepth = [0]*n\nans = max(max(ky),max(dm))*(n*2+1)*(n+1)\n\ndef traverse(d, s, e, note):\n    global ans\n    if s==e:\n        depth[s]=d\n        er = 0\n\n        for i in range(n):         er += depth[i]*ky[i]\n        er += (depth[0]+1)*dm[0]\n        for i in range(1, n):      er += (max(depth[i-1], depth[i])+1)*dm[i]\n        er += (depth[n-1]+1)*dm[n]\n        \n        if ans>er: ans = er\n        return\n    for m in range(s, e+1):\n        depth[m]=d\n        if s<=m-1: traverse(d+1,  s, m-1, 'left')\n        if m+1<=e: traverse(d+1, m+1, e, 'right')\n\n\ntraverse(1, 0, n-1, '')\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(sys.stdin.readline())\n\nky = list(map(float, sys.stdin.readline().split()))\ndm = list(map(float, sys.stdin.readline().split()))\ndepth = [0]*n\nans = max(max(ky),max(dm))*(n*2+1)*(n+1)\n\nprint(ky, dm)\n\n\ndef traverse(d, s, e, note):\n    global ans\n    if s==e:\n        depth[s]=d\n        er = 0\n\n        for i in range(n):         er += depth[i]*ky[i]\n        er += (depth[0]+1)*dm[0]\n        for i in range(1, n):      er += (max(depth[i-1], depth[i])+1)*dm[i]\n        er += (depth[n-1]+1)*dm[n]\n        \n        if ans>er: ans = er\n        return\n    for m in range(s, e+1):\n        depth[m]=d\n        if s<=m-1: traverse(d+1,  s, m-1, 'left')\n        if m+1<=e: traverse(d+1, m+1, e, 'right')\n\n\ntraverse(1, 0, n-1, '')\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "global memo\nglobal memo_pq\nglobal p_list\nglobal q_list\n\n\n\ndef mk_memo(i,j):#memo[i][j]を求める\n    tmp_min=9999999\n    for k in range(1,j-1):\n        tmp=p_list[i+k] + memo[i][k] + memo_pq[i][k] + memo[i+k+1][j-k-1] + memo_pq[i+k+1][j-k-1]\n        if(tmp < tmp_min):\n            tmp_min=tmp\n    if(j!=1):\n        tmp_min=min([tmp_min, p_list[i] +2*q_list[i] + memo[i+1][j-1] +memo_pq[i+1][j-1]])\n        tmp_min=min([tmp_min, p_list[i+j-1] +2*q_list[i+j] + memo[i][j-1] +memo_pq[i][j-1]])\n    else:\n        tmp_min=p_list[i] + 2*q_list[i] + 2*q_list[i+1]\n    memo[i][j]=tmp_min\n\n\n\nn=int(input())\np_list=list(map(float,input().split()))\nq_list=list(map(float,input().split()))\n\n\n\nmemo=[[0]*(n+1-i) for i in range(n+1)]#memo[i][j]はlist[i]から始まるj個の部分集合に対する解\nmemo_pq=[[0]*(n+1-i) for i in range(n+1)]#memo_pq[i][j]はlist[i]から始まる\n                                       #ｊ個の部分集合に対応する重みpと重みqの和\nfor p in range(n+1):\n    for q in range(n+1-p):\n        if(q==0):\n            memo_pq[p][q]=q_list[p]\n        else:\n            memo_pq[p][q]=memo_pq[p][q-1] + p_list[p+q-1] + q_list[p+q]\n    \n\n\n\nfor i in range(n):\n    for j in range(1,2+i):\n        mk_memo(n-1-i,j)\n\nprint(memo[0][-1])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN = int(readline())\n*P, = map(float, readline().split())\n*Q, = map(float, readline().split())\n\nK = [[None]*(N+1) for i in range(N+1)]\nC = [[None]*(N+1) for i in range(N+1)]\nS = [0]*(2*N+2)\nfor i in range(2*N+1):\n    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])\n\nfor i in range(N+1):\n    C[i][i] = Q[i]\n    K[i][i] = i\n\nfor l in range(1, N+1):\n    for i in range(N+1-l):\n        j = i+l\n        k0 = K[i][j-1]; k1 = K[i+1][j]\n        tmp = 1e30\n        k2 = None\n        for k in range(k0, min(k1+1, j)):\n            v = C[i][k] + C[k+1][j]\n            if v < tmp:\n                k2 = k\n                tmp = v\n        K[i][j] = k2\n        C[i][j] = tmp + (S[2*j+1] - S[2*i])\nwrite(\"%.10f\\n\" % C[0][N])\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# ALDS_10_D: Dynamic Programming - Optimal Binary Search Tree\n\n\ndef optimal_cost(n, kp, dp):\n    sums = [sum(kp[0:i]) + sum(dp[0:i+1]) for i in range(n+1)]\n    expects = [[kp[i] + (dp[i] + dp[i+1])*2 for i in range(n)]]\n\n    for w in range(2, n+1):\n        exps = []\n        for i in range(n-w+1):\n            j = i + w\n            exp = min(dp[i] + expects[j-i-2][i+1], expects[j-i-2][i] + dp[j])\n            for k in range(i+1, j-1):\n                _exp = expects[k-i-1][i] + expects[j-k-2][k+1]\n                if exp > _exp:\n                    exp = _exp\n            exps.append(exp + sums[j] - sums[i] + dp[i])\n        expects.append(exps)\n\n    return expects[-1][0]\n\n\ndef run():\n    n = int(input())\n    ps = [float(x) for x in input().split()]\n    qs = [float(x) for x in input().split()]\n\n    print(\"{:.8f}\".format(optimal_cost(n, ps, qs)))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef input():\n    return sys.stdin.readline()[:-1]\n    \nn = int(input())\np = [None] + list(map(float, input().split()))\nq = list(map(float, input().split()))\nT = [[500 for i in range(n+1)] for j in range(n+1)]\n\npsum = [0] * (n+1)\nqsum = [0] * (n+1)\nqsum[0] = q[0]\nfor i in range(1,n+1):\n    psum[i] = psum[i-1] + p[i]\n    qsum[i] = qsum[i-1] + q[i]\n    \nfor i in range(1,n+1):\n    T[i][i] = p[i] + (q[i-1] + q[i])*2\n    \nfor l in range(2,n+1):\n    for i in range(1,n-l+1+1):\n        val_list = [T[i][j] + T[j+2][i+l-1] for j in range(i,i+l-2)]\n        val_list.append(T[i][i+l-2] + q[i+l-1])\n        val_list.append(T[i+1][i+l-1] + q[i-1])\n        if i-2>=0:\n            w = psum[i+l-1]-psum[i-1] + qsum[i+l-1]-qsum[i-2]\n        else:\n            w = psum[i+l-1]-psum[i-1] + qsum[i+l-1]\n        T[i][i+l-1] = min(val_list) + w\n        \nprint(T[1][n])\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    \"\"\"最適二分探索木での探索一回あたりの期待値の最小値を求める\n    \"\"\"\n    inf = 10*6\n    n = int(input())\n    # 内包よりはやい\n    P = [0.0] + list(map(float, input().split()))\n    Q = list(map(float, input().split()))\n    E = [[0.0]*(n+1) for _ in range(n+1)]\n    W = [[0.0]*(n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        W[i][i] = Q[i-1] + P[i] + Q[i]\n        E[i][i] = P[i] + (Q[i-1] + Q[i])*2\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            W[i][j] = W[i][j-1] + P[j] + Q[j]\n    for d in range(1, n):\n        for i in range(1, n-d+1):\n            j = i + d\n            e = Q[i-1] + E[i+1][j] + W[i][j] \n            for k in range(i+1, j):\n                ne =  E[i][k-1] + E[k+1][j] + W[i][j]\n                if ne < e:\n                    e = ne\n            ne = E[i][j-1] + Q[j] + W[i][j]\n            if ne < e:\n                e = ne\n            E[i][j] = e\n    print(E[1][-1])\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "global memo\nglobal memo_pq\nglobal p_list\nglobal q_list\n\n\n\ndef mk_memo(i,j):#memo[i][j]を求める\n    tmp=[]\n    for k in range(1,j-1):\n        tmp.append(p_list[i+k] + memo[i][k] + memo_pq[i][k] + memo[i+k+1][j-k-1] + memo_pq[i+k+1][j-k-1])        \n    if(j!=1):\n        tmp.append(p_list[i] +2*q_list[i] + memo[i+1][j-1] +memo_pq[i+1][j-1])\n        tmp.append(p_list[i+j-1] +2*q_list[i+j] + memo[i][j-1] +memo_pq[i][j-1])\n        memo[i][j]=min(tmp)\n    else:\n        memo[i][j]=p_list[i] + 2*q_list[i] + 2*q_list[i+1]\n\n\n\nn=int(input())\np_list=list(map(float,input().split()))\nq_list=list(map(float,input().split()))\n\n\n\nmemo=[[0]*(n+1-i) for i in range(n+1)]#memo[i][j]はlist[i]から始まるj個の部分集合に対する解\nmemo_pq=[[0]*(n+1-i) for i in range(n+1)]#memo_pq[i][j]はlist[i]から始まる\n                                       #ｊ個の部分集合に対応する重みpと重みqの和\nfor p in range(n+1):\n    for q in range(n+1-p):\n        if(q==0):\n            memo_pq[p][q]=q_list[p]\n        else:\n            memo_pq[p][q]=memo_pq[p][q-1] + p_list[p+q-1] + q_list[p+q]\n    \n\n\n\nfor i in range(n):\n    for j in range(1,2+i):\n        mk_memo(n-1-i,j)\n\nprint(memo[0][-1])\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(sys.stdin.readline())\n\nky = list(map(float, sys.stdin.readline().split()))\ndm = list(map(float, sys.stdin.readline().split()))\ndepth = [0]*n\nans = max(max(ky),max(dm))*(n*2+1)*(n+1)\n\n\ndef traverse(d, s, e, note):\n    global ans\n    if s==e:\n        depth[s]=d\n        r = 0\n        for i in range(n):         r += depth[i]*ky[i]\n        r += (depth[0]+1)*dm[0]\n        for i in range(1, n):      r += (max(depth[i-1], depth[i])+1)*dm[i]\n        r += (depth[n-1]+1)*dm[n]\n        if ans>r: ans = r\n        return\n    for m in range(s, e+1):\n        depth[m]=d\n        if s<=m-1: traverse(d+1,  s, m-1, 'left')\n        if m+1<=e: traverse(d+1, m+1, e, 'right')\n\n\ntraverse(1, 0, n-1, '')\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(sys.stdin.readline())\na = [0.0] * (2*n+1)\nb = list(map(float, sys.stdin.readline().split()))\nfor i,c in enumerate(b):    a[i*2+1] = c\nb = list(map(float, sys.stdin.readline().split()))\nfor i,c in enumerate(b):    a[i*2] = c\ndepth = [0]*(n*2+1)\nans = max(a)*(n*2+1)*(n+1)\ndef traverse(d, s, e):\n    global ans\n    if s>=e:\n        depth[s*2+1]=d\n        er = 0\n        for i in range(0,n*2+1,2):\n            if i==0:      depth[i]=depth[i+1]+1\n            elif i==n*2:  depth[i]=depth[i-1]+1\n            else:         depth[i]=max(depth[i-1],depth[i+1])+1\n        for i in range(n*2+1):\n            er += (depth[i]+1)*a[i]\n        if ans>er: ans = er\n        return\n    for m in range(s, e+1):\n        depth[m*2+1]=d\n        if s<=m-1: traverse(d+1,  s, m-1)\n        if m+1<=e: traverse(d+1, m+1, e)\n        \ntraverse(0, 0, n-1)\nprint(ans)\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::min;\nuse std::io::*;\nuse std::str::FromStr;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn main() {\n    let n: usize = read();\n    let p: Vec<f32> = (1..n + 1)\n        .map(|_| {\n            let number: f32 = read();\n            number\n        })\n        .collect();\n    let q: Vec<f32> = (0..n + 1)\n        .map(|_| {\n            let number: f32 = read();\n            number\n        })\n        .collect();\n\n    let mut k: Vec<Vec<usize>> = vec![vec![0; n + 1]; n + 1];\n    let mut c: Vec<Vec<f32>> = vec![vec![0.0; n + 1]; n + 1];\n    let mut s: Vec<f32> = vec![0.0; (2 * n) + 2];\n    for index in 0..2 * n + 1 {\n        if index % 2 == 1 {\n            s[index + 1] = s[index] + p[index / 2];\n        } else {\n            s[index + 1] = s[index] + q[index / 2];\n        }\n    }\n\n    for index in 0..n + 1 {\n        c[index][index] = q[index];\n        k[index][index] = index;\n    }\n\n    for index_i in 1..n + 1 {\n        for index_j in 0..n + 1 - index_i {\n            let m = index_i + index_j;\n            let k0 = k[index_j][m - 1];\n            let k1 = k[index_j + 1][m];\n\n            let mut temp = 1e30;\n\n            let mut k2: Option<usize> = None;\n\n            for index_k in k0..min(k1 + 1, m) {\n                let v = c[index_j][index_k] + c[index_k + 1][m];\n                if v < temp {\n                    k2 = Some(index_k);\n                    temp = v;\n                }\n            }\n            k[index_j][m] = k2.unwrap();\n\n            c[index_j][m] = temp + (s[2 * m + 1] - s[2 * index_j]);\n        }\n    }\n    println!(\"{}\", c[0][n]);\n}\n\n"
  }
]