[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp[55], N, L[55], minx = (1 << 30);\n\nint solve(int pos) {\n\tfor (int i = 0; i < 55; i++) dp[i] = (1 << 30);\n\tdp[0] = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\tsum += L[j];\n\t\t\tif (sum >= pos && !(i == 0 && j == N)) dp[j] = min(dp[j], max(dp[i], sum));\n\t\t}\n\t}\n\treturn dp[N];\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) cin >> L[i];\n\tvector<int>vec;\n\tfor (int i = 1; i <= N; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = i; j <= N; j++) {\n\t\t\tsum += L[j]; if (!(i == 1 && j == N)) vec.push_back(sum);\n\t\t}\n\t}\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tminx = min(minx, solve(vec[i]) - vec[i]);\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 2019/09/02 Tazoe\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint solve(const int len, const int L[50], const int N)\n{\n\tint DP[51];\n\tDP[0] = len;\n\n\tfor(int i=0; i<N; i++){\n\n\t\tint piece_len = 0;\n\t\tDP[i+1] = 100000;\n\n\t\tfor(int j=i; j>=0; j--){\n\n\t\t\tpiece_len += L[j];\n\n\t\t\tif(i==N-1 && j==0)\n\t\t\t\tcontinue;\n\n\t\t\tif(piece_len>=len){\n\t\t\t\tint high = max(piece_len, DP[j]);\n\t\t\t\tDP[i+1] = min(DP[i+1], high);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn DP[N]-len;\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\n\tint L[50];\n\tfor(int i=0; i<N; i++){\n\t\tcin >> L[i];\n\t}\n\n\tint ans = 100000;\n\n\tfor(int i= 0; i<N; i++){\n\t\tint len = 0;\t\t\t// 水ようかんのすべての長さ\n\t\tfor(int j=i; j<N; j++){\n\t\t\tlen += L[j];\n\n\t\t\tint tmp = solve(len, L, N);\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX_N 50\n\nint N;\nint L[MAX_N+1];\n\nint dpMin[MAX_N][MAX_N+1];\nint dpMax[MAX_N][MAX_N+1];\n\nvoid dp(int cut, int begin){\n\tif(dpMin[cut][begin]) return;\n\tif(cut == 0){\n\t\tdpMin[cut][begin] = L[N] - L[begin];\n\t\tdpMax[cut][begin] = L[N] - L[begin];\n\t}else{\n\t\tint bestMin = -99999999;\n\t\tint bestMax = +99999999;\n\t\tfor(int pos=begin+1; pos+cut<=N; ++pos){\n\t\t\tconst int left = L[pos]-L[begin];\n\t\t\tdp(cut-1, pos);\n\t\t\tif( bestMax - bestMin > max(dpMax[cut-1][pos], left) - min(dpMin[cut-1][pos], left) ){\n\t\t\t\tbestMax = max(dpMax[cut-1][pos], left);\n\t\t\t\tbestMin = min(dpMin[cut-1][pos], left);\n\t\t\t}\n\t\t}\n\t\tdpMin[cut][begin] = bestMin;\n\t\tdpMax[cut][begin] = bestMax;\n\t}\n\t//printf(\"dp[%2d][%2d]={%4d,%4d}\\n\",cut,begin,dpMin[cut][begin],dpMax[cut][begin]);\n}\n\nint main(){\n\tcin >> N;\n\t\n\tfor(int i=1; i<=N; ++i){\n\t\tcin >> L[i];\n\t\tL[i] += L[i-1];\n\t}\n\t\n\tint best = 1<<29;\n\tfor(int n=1; n<N; ++n){\n\t\tdp(n,0);\n\t\tbest = min(best, dpMax[n][0] - dpMin[n][0]);\n\t}\n\t\n\tcout << best << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define PP std::pair<int,int>\nint N;\nint L[50];\nPP D[51][51];\nint res[51][51];\nint ans=1<<30;\nint main(){\n    std::cin>>N;\n    for(int i=1;i<=N;i++){\n        std::cin>>L[i];\n        L[i]+=L[i-1];\n    }\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            res[i][j]=1<<30;\n        }\n    }\n    for(int i=0;i<=N;i++){\n        D[i][1]={std::min(L[N]-L[i],L[i]),std::min(L[N]-L[i],L[i])};\n        ans=std::min(ans,std::abs(L[N]-L[i]-L[i]));\n    }\n    for(int i=1;i<=N;i++){\n        for(int j=2;j<=i;j++){\n            for(int k=j-1;k<i;k++){\n                int m=std::min({D[k][j-1].first,L[N]-L[i],L[i]-L[k]});\n                int M=std::max({D[k][j-1].second,L[N]-L[i],L[i]-L[k]});\n                if(res[i][j]>M-m){\n                    res[i][j]=M-m;\n                    ans=std::min(res[i][j],ans);\n                    int m=std::min(D[k][j-1].first,L[i]-L[k]);\n                    int M=std::max(D[k][j-1].second,L[i]-L[k]);\n                    D[i][j]={m,M};\n                }\n            }\n        }\n    }\n    std::cout<<ans<<std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst int SIZE = 50;\n\nint dp[SIZE+1][SIZE*1000+1];\n\nint main(){\n  int n, sum[SIZE+1], l[SIZE];\n  \n  scanf(\"%d\",&n);\n\n  sum[0] = 0;\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",l+i);\n    sum[i+1] = sum[i] + l[i];\n  }\n\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=sum[n];j++)\n      dp[i][j] = INF;\n    if(i < n) dp[i][sum[i]] = sum[i];\n  }\n  \n  for(int i=1;i<n;i++){\n    for(int j=0;j<=sum[i];j++){\n      for(int k=i+1;k<=n;k++){\n        if(dp[i][j] == INF) continue;\n\n        int t = max(j, sum[k]-sum[i]);\n        int p = min(dp[i][j], sum[k]-sum[i]);\n        if(dp[k][t] == INF)\n          dp[k][t] = p;\n        else\n          dp[k][t] = max(dp[k][max(j, sum[k]-sum[i])], p);\n      }\n    }\n  }\n\n  int ans = INF;\n  \n  for(int i=0;i<=sum[n];i++){\n    if(dp[n][i] != INF)\n      ans = min(ans, i - dp[n][i]);\n  }\n  \n\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    int n;\n    cin >>n;\n    vector<int> l(n);\n    rep(i,n) cin >>l[i];\n\n    int s = 0;\n    rep(i,n) s += l[i];\n\n    int ans = 10101010;\n\n    for(int lb=1; lb<=s; ++lb){\n\n        int mn = s, mx = 0;\n\n        int c = 0;\n        int cut = 0;\n        rep(i,n){\n            c += l[i];\n\n            if(c>=lb){\n                mn = min(mn,c);\n                mx = max(mx,c);\n                c = 0;\n                ++cut;\n            }\n        }\n        if(c>0){\n            mn = min(mn,c);\n            mx = max(mx,c);\n            ++cut;\n        }\n\n        if(cut>=2) ans = min(ans, mx-mn);\n    }\n    assert(ans>=0);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint max(int a, int b) {\n  return a > b ? a : b;\n}\n\nint main(void) {\n  int i, j, k, n, ans = 1000000;\n  scanf(\"%d\", &n);\n  int l[n], sum = 0;\n  for(i = 0; i < n; ++i) {\n    scanf(\"%d\", &l[i]);\n    sum += l[i];\n  }\n  for(i = 1; i <= 50000; ++i) {\n    int dp[n];\n    for(j = 0; j < n; ++j) dp[j] = 1000000;\n    for(j = 0; j < n; ++j) {\n      int now = 0;\n      for(k = j; k < n; ++k) {\n        now += l[k];\n        int tt;\n        if(!j) tt = 0;\n        else tt = dp[j - 1];\n        if(now >= i && dp[k] > max(now, tt)) dp[k] = max(now, tt); \n      }\n    }\n    if(dp[n - 1] != sum && ans > dp[n - 1] - i) ans = dp[n - 1] - i;\n    /*if(i == 17) {\n      for(j = 0; j < n; ++j) printf(\"%d \", dp[j]);\n     printf(\"\\n\");\n    }*/\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(void){\n\tint n;\n\tint dp[51];\n\tint cut[51];\n\tint i,j,k;\n\tint high=0;\n\tint MIN=INT_MAX; \n\tint MAX;\n\tint low=-1;\n\tcin>>n;\n\tfor(i=0;i<n;i++){\n\t\tcin>>cut[i];\n\t\thigh+=cut[i];\n\t\tlow=max(low,cut[i]);\n\t}\n\tfor(k=low;k<high;k++){\n\t\t//cout<<\" K=\" <<k<<endl;\n\t\tfor(i=0;i<51;i++){\n\t\t\tdp[i]=0;\n\t\t}\n\t\tint sum=0;\n\t\tdp[0]=cut[0];\n\t\tfor(i=0;i<n;i++){\n\t\t\tif((dp[i]+cut[i+1])>k)\tbreak;\n\t\t\tdp[i+1]=dp[i]+cut[i+1];\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tint sum=0;\n\t\t\t//cout<<\"i=\"<<i<<endl<<endl<<endl;\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tsum+=cut[j];\n\t\t\t\tif(sum>k)\tbreak;\n\t\t\t\t//cout<<\"SUM=\"<<sum<<endl<<endl;\n\t\t\t\t//cout<<\"dp[j]=\"<<dp[j]<<\"dp[i]\"<<dp[i]<<\"sum\"<<sum<<endl<<endl;\n\t\t\t\tdp[j]=max(dp[j],min(dp[i],sum));\n\t\t\t\t//cout<<\"DP[j]\"<<dp[j]<<endl<<endl;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t/*for(i=0;i<n;i++){\n\t\t\tcout<<dp[i]<<endl;\n\t\t}\n\t\tcout<<endl;*/\n\t\tMIN=min(MIN,k-dp[n-1]);\n\t}\n\tcout<<MIN<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint main(void)\n{\n\tint n,l[50],dp[51],i,j,k,sum,high,mn,s1,m1,x;\n\tscanf(\"%d\",&n);\n\tm1=-1;\ts1=0;\n\tfor(i=0;i<n;i++)\t{\n\t\tscanf(\"%d\",&l[i]);\n\t\ts1+=l[i];\n\t\tm1=max(m1,l[i]);\n\t}\n\tmn=50000;\n\tfor(i=m1;i<s1;i++)\t{\n\t\tfor(j=0;j<n;j++)\tdp[j]=0;\n\t\tsum=0;\n\t\tfor(j=0;j<n;j++)\t{\n\t\t\tsum+=l[j];\n\t\t\tif(sum>i)\tbreak;\n\t\t\tdp[j]=sum;\n\t\t}\n\t\tfor(j=0;j<n-1;j++)\t{\n\t\t\tsum=0;\n\t\t\tfor(k=j+1;k<n;k++)\t{\n\t\t\t\tsum+=l[k];\n\t\t\t\tif(sum>i)\tbreak;\n\t\t\t\tx=min(sum,dp[j]);\n\t\t\t\tdp[k]=max(dp[k],x);\n\t\t\t}\n\t\t}\n//\t\tprintf(\" %d %d\\n\",i,dp[n-1]);\n\t\tmn=min(mn,i-dp[n-1]);\n\t}\n\tprintf(\"%d\\n\",mn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint sumin(vector<int>::iterator begin, vector<int>::iterator end)\n{\n    ++end;\n    return accumulate(begin, end, 0);\n}\nint main()\n{\n    //宣言\n    vector<int> input;    //入力されたデータ配列\n    int elementCount = 0; //要素数\n    int sum = 0;          //母集団の合計\n    int i = 0;\n    //要素数の入力\n    //cout << \"elementCount : \";\n    cin >> elementCount;\n    //要素の入力\n    for (int tmp, i = 0; i < elementCount; i++)\n    {\n        //cout << \"element No.\" << i + 1 << \" : \";\n        cin >> tmp;\n        sum += tmp;\n        input.push_back(tmp);\n    }\n    //各グループの最大値\n    int maxValue = *max_element(input.begin(), input.end());\n\n    vector<int>::iterator groupBegin = input.begin();\n    vector<int>::iterator groupEnd = input.begin();\n    vector<int>::iterator nextGroupBegin = input.begin();\n    int groupSum = 0;\n    int thresholdMax = 0;\n    int thresholdMin = sum;\n    int ans = sum;\n    int flag = 0;\n    vector<int>::iterator lastElement = input.end();\n    --lastElement;\n    //求める値に関する処理\n    while (maxValue < sum)\n    {\n        //cout << \"START : search sikiichi : \" << maxValue << endl;\n        //各閾値ごとの初期化処理\n        groupBegin = input.begin();\n        groupEnd = input.begin();\n        nextGroupBegin = input.begin();\n        thresholdMax = 0;\n        thresholdMin = sum;\n        flag = 0;\n        while (flag != 2 && flag != 4)\n        {\n            //各グループごとの初期化処理\n            groupBegin = nextGroupBegin;\n            groupEnd = groupBegin;\n            //cout << \"      START : search group start at: \" << *groupBegin << endl;\n            while (sumin(groupBegin, groupEnd) < maxValue)\n            {\n                //グループ内の総和が最大値を超えない場合\n                if (groupEnd != lastElement)\n                {\n                    //cout << \"            group Extended | group end at: \" << *groupEnd ;\n                    //端に到達していないので、グループの範囲を1個広げる\n                    ++groupEnd;\n                    //cout << \" -> \"<<*groupEnd<<endl;\n                    flag = 1;\n                }\n                else\n                {\n                    //グループ完成\n                    //端に到達しているので、この閾値での調査完了\n                    groupSum = sumin(groupBegin, groupEnd);\n                    flag = 2;\n                    //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n                    break;\n                }\n            }\n            if (sumin(groupBegin, groupEnd) == maxValue)\n            {\n                //グループ内の総和が最大値と一致する場合\n                if (groupEnd != lastElement)\n                {\n                    //グループ完成\n                    //端に達していないので、次のグループ用にはじめを設定\n                    groupSum = sumin(groupBegin, groupEnd);\n                    ++groupEnd;\n                    nextGroupBegin = groupEnd;\n                    flag = 3;\n                    --groupEnd;\n                    //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n                }\n                else\n                {\n                    //グループ完成\n                    //端に達しているので、この閾値で調査完了\n                    groupSum = sumin(groupBegin, groupEnd);\n                    flag = 4;\n                    //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n                }\n            }\n            if (sumin(groupBegin, groupEnd) > maxValue)\n            {\n                //グループ内の総和が最大値を超えた場合\n                //グループ完成\n                //次のグループ用にはじめを設定\n                --groupEnd;\n                groupSum = sumin(groupBegin, groupEnd);\n                ++groupEnd;\n                nextGroupBegin = groupEnd;\n                flag = 5;\n                --groupEnd;\n                //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n            }\n            //グループごとの終了処理\n            if (groupSum > thresholdMax)\n            {\n                thresholdMax = groupSum;\n            }\n            if (groupSum < thresholdMin)\n            {\n                thresholdMin = groupSum;\n            }\n        }\n        //閾値ごとの終了処理\n        //cout << \"END : search sikiichi : \" << maxValue << \" , \"\n        //     << \"RESULT : \" << thresholdMax - thresholdMin << endl;\n        if (thresholdMax - thresholdMin < ans)\n        {\n            ans = thresholdMax - thresholdMin;\n        }\n        maxValue++;\n    }\n    cout << ans << endl;\n    cin >> i;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint sumin(vector<int>::iterator begin, vector<int>::iterator end)\n{\n    ++end;\n    return accumulate(begin, end, 0);\n}\nint main()\n{\n    //宣言\n    vector<int> input;    //入力されたデータ配列\n    int elementCount = 0; //要素数\n    int sum = 0;          //母集団の合計\n    int i = 0;\n    //要素数の入力\n    //cout << \"elementCount : \";\n    cin >> elementCount;\n    //要素の入力\n    for (int tmp, i = 0; i < elementCount; i++)\n    {\n        //cout << \"element No.\" << i + 1 << \" : \";\n        cin >> tmp;\n        sum += tmp;\n        input.push_back(tmp);\n    }\n    //各グループの最大値\n    int maxValue = *max_element(input.begin(), input.end());\n\n    vector<int>::iterator groupBegin = input.begin();\n    vector<int>::iterator groupEnd = input.begin();\n    vector<int>::iterator nextGroupBegin = input.begin();\n    int groupSum = 0;\n    int thresholdMax = 0;\n    int thresholdMin = sum;\n    int ans = sum;\n    int flag = 0;\n    vector<int>::iterator lastElement = input.end();\n    --lastElement;\n    //求める値に関する処理\n    while (maxValue < sum)\n    {\n        //cout << \"START : search sikiichi : \" << maxValue << endl;\n        //各閾値ごとの初期化処理\n        groupBegin = input.begin();\n        groupEnd = input.begin();\n        nextGroupBegin = input.begin();\n        thresholdMax = 0;\n        thresholdMin = sum;\n        flag = 0;\n        while (flag != 2 && flag != 4)\n        {\n            //各グループごとの初期化処理\n            groupBegin = nextGroupBegin;\n            groupEnd = groupBegin;\n            //cout << \"      START : search group start at: \" << *groupBegin << endl;\n            while (sumin(groupBegin, groupEnd) < maxValue)\n            {\n                //グループ内の総和が最大値を超えない場合\n                if (groupEnd != lastElement)\n                {\n                    //cout << \"            group Extended | group end at: \" << *groupEnd ;\n                    //端に到達していないので、グループの範囲を1個広げる\n                    ++groupEnd;\n                    //cout << \" -> \"<<*groupEnd<<endl;\n                    flag = 1;\n                }\n                else\n                {\n                    //グループ完成\n                    //端に到達しているので、この閾値での調査完了\n                    groupSum = sumin(groupBegin, groupEnd);\n                    flag = 2;\n                    //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n                    break;\n                }\n            }\n            if (sumin(groupBegin, groupEnd) == maxValue)\n            {\n                //グループ内の総和が最大値と一致する場合\n                if (groupEnd != lastElement)\n                {\n                    //グループ完成\n                    //端に達していないので、次のグループ用にはじめを設定\n                    groupSum = sumin(groupBegin, groupEnd);\n                    ++groupEnd;\n                    nextGroupBegin = groupEnd;\n                    flag = 3;\n                    --groupEnd;\n                    //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n                }\n                else\n                {\n                    //グループ完成\n                    //端に達しているので、この閾値で調査完了\n                    groupSum = sumin(groupBegin, groupEnd);\n                    flag = 4;\n                    //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n                }\n            }\n            if (sumin(groupBegin, groupEnd) > maxValue)\n            {\n                //グループ内の総和が最大値を超えた場合\n                //グループ完成\n                //次のグループ用にはじめを設定\n                --groupEnd;\n                groupSum = sumin(groupBegin, groupEnd);\n                ++groupEnd;\n                nextGroupBegin = groupEnd;\n                flag = 5;\n                --groupEnd;\n                //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n            }\n            //グループごとの終了処理\n            if (groupSum > thresholdMax)\n            {\n                thresholdMax = groupSum;\n            }\n            if (groupSum < thresholdMin)\n            {\n                thresholdMin = groupSum;\n            }\n        }\n        //閾値ごとの終了処理\n        //cout << \"END : search sikiichi : \" << maxValue << \" , \"\n        //     << \"RESULT : \" << thresholdMax - thresholdMin << endl;\n        if (thresholdMax - thresholdMin < ans)\n        {\n            ans = thresholdMax - thresholdMin;\n        }\n        maxValue++;\n    }\n    cout << ans << endl;\n    cin >> i;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nconstexpr int INF = 1 << 30;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> ls(n + 1);\n    ls[0] = 0;\n    for (int i = 1; i <= n; ++i) {\n        int l;\n        std::cin >> l;\n        ls[i] = ls[i - 1] + l;\n    }\n    int lsum = ls.back();\n\n    int ans = INF;\n    for (int min = 0; min < lsum; ++min) {\n        std::vector<int> lodp(n + 1, INF), tidp(n + 1, INF);\n        lodp[0] = 0;\n        for (int r = 1; r <= n; ++r) {\n            for (int l = 0; l < r; ++l) {\n                int len = ls[r] - ls[l];\n                if (len < min) continue;\n                lodp[r] = std::min(lodp[r], std::max(lodp[l], len));\n                tidp[r] = std::min(tidp[r], std::max(tidp[l], len));\n                if (len > min) continue;\n                tidp[r] = std::min(tidp[r], std::max(lodp[l], len));\n            }\n        }\n        ans = std::min(ans, tidp[n] - min);\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MAX = 51*1001;\nInt dp[2][55][MAX];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  vector<Int> s(n,a[0]);\n  for(Int i=1;i<n;i++) s[i]=s[i-1]+a[i];\n  \n  for(Int i=0;i<2;i++)\n    for(Int j=0;j<55;j++)\n      for(Int k=0;k<MAX;k++)\n\tdp[i][j][k]=MAX;\n  dp[0][n][MAX-1]=0;\n\n  auto chmin=[](Int &a,Int b){if(a>b) a=b;};\n  \n  for(Int i=0;i<n;i++){\n    bool f=i%2;\n    for(Int k=0;k<MAX;k++){\n      for(Int j=0;j<n;j++){\n\tInt &res=dp[f][j][k];\n\tif(res==MAX) continue;\n\t//cout<<i<<\" \"<<j<<\" \"<<k<<\":\"<<res<<endl;\n\tchmin(dp[!f][j][k],dp[f][j][k]);\n\tchmin(dp[!f][i][min(k,s[i]-s[j])],\n\t      max(dp[f][j][k],s[i]-s[j]));\n\tres=MAX;\n      }\n      if(dp[f][n][k]!=MAX){\n\t//cout<<i<<\" \"<<n<<\" \"<<k<<\":\"<<dp[f][n][k]<<endl;\n\tchmin(dp[!f][n][k],dp[f][n][k]);\n\tif(i+1!=n){\n\t  chmin(dp[!f][i][min(k,s[i])],\n\t\tmax(dp[f][n][k],s[i]));\n\t}\n\tdp[f][n][k]=MAX;\n      }\n    }\n  }\n  /*//\n  for(Int i=0;i<MAX;i++)\n    if(dp[n%2][n-1][i]!=MAX)\n      cout<<n<<\" \"<<n-1<<\" \"<<i<<\":\"<<dp[n%2][n-1][i]<<endl;\n  //*/\t\t\t\n  Int ans=MAX;\t       \n  for(Int i=0;i<MAX;i++)\n    if(dp[n%2][n-1][i]!=MAX) chmin(ans,dp[n%2][n-1][i]-i);\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; i++)  cin >> a[i];\n    vector<int> sum(n+1, 0);\n    for(int i = 1; i <= n; i++) sum[i] = sum[i-1] + a[i-1];\n    vector<int> lb;\n    for(int i = 0; i+1 <= n; i++){\n        for(int j = i+1; j <= n; j++){\n            lb.push_back(sum[j]-sum[i]);\n        }\n    }\n    sort(lb.begin(), lb.end());\n    lb.erase(unique(lb.begin(),lb.end()), lb.end());\n    int ans = 1<<30;\n    for(int x : lb){\n        vector<int> dp(n+1, 1<<30);\n        dp[0] = 0;\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= i; j++){\n                if(i == n && j == 1)    continue;\n                if(sum[i]-sum[j-1] < x)   continue;\n                dp[i] = min(dp[i], max(dp[j-1], sum[i]-sum[j-1]));\n            }\n        }\n        ans = min(ans, dp[n]-x);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nint N;\nint L[51];\nint dp[51];\n\nint calc(int d) {\n    memset(dp, 0x3f, sizeof(dp));\n    dp[0] = 0;\n    for (int i = 0; i < N; ++i) {\n        int sum = 0;\n        for (int j = i; j >= 0; --j) {\n            if (i + 1 == N && j == 0) continue;\n            sum += L[j];\n            if (sum >= d) dp[i + 1] = min(dp[i + 1], max(dp[j], sum));\n        }\n    }\n    return dp[N];\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N;\n    int sum = 0;\n    REP(i, N) cin >> L[i], sum += L[i];\n    int ans = 1LL << 30;\n    calc(53);\n    FOR(i, 1, sum) {\n        ans = min(ans, calc(i) - i);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int INF = 1e9;\n\nint N;\nint L[100], sum[100];\nvector<int> lb;\nint main() {\n\tcin >> N;\n\trep(i, N) {\n\t\tcin >> L[i];\n\t}\n\tsum[0] = 0;\n\trep(i, N) {\n\t\tsum[i + 1] = sum[i] + L[i];\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i; j < N; j++) {\n\t\t\tlb.push_back(sum[j + 1] - sum[i]);\n\t\t}\n\t}\n\tsort(lb.begin(), lb.end());\n\tlb.erase(unique(lb.begin(), lb.end()), lb.end());\n\n\tint ans = INF;\n\tfor (int e:lb) {\n\t\tvector<int> dp(N + 1, INF);\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i; j < N; j++) {\n\t\t\t\tif (i == 0 && j == N - 1) continue;\n\t\t\t\tint tmp = sum[j + 1] - sum[i];\n\t\t\t\tif (tmp < e) continue;\n\t\t\t\tdp[j + 1] = min(dp[j + 1], max(dp[i], tmp));\n\t\t\t}\n\t\t}\n\t\tans = min(ans, dp[N] - e);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint L[50];\n\nbool check(int x,int y){\n  map<int,bool> visited;\n  queue<int> Q;\n  Q.push(0);\n  visited[0]=true;\n  while(!Q.empty()){\n    int p=Q.front();\n    Q.pop();\n    if(p==N)return true;\n    int sum=0;\n    for(int to=p+1;to<=N;to++){\n      if(p==0 && to==N)continue;\n      sum+=L[to-1];\n      if(sum<x || y<sum)continue;\n      if( !visited[to] ){\n        visited[to]=true;\n        Q.push(to);\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>L[i];\n  }\n  for(int i=0;i<=1000;i++){\n    for(int j=1;j<=25000;j++){\n      if( check(j,i+j) ){\n        cout<<i<<endl;\n        return 0;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define INF 100000\nint n,a[55],ans=INF;\nvector<int>s;\nint main(void){\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        int b;\n        cin>>b;\n        a[i]+=b;\n        a[i+1]+=a[i];\n    }\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<=n;j++){\n            s.push_back(a[j]-a[i]);\n        }\n    }\n    for(int k=0;k<s.size();k++){\n        int dp[55][3];\n        for(int i=0;i<=n;i++){\n            dp[i][0]=INF;\n            dp[i][1]=INF;\n            dp[i][2]=INF;\n        }\n        dp[0][0]=0;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<=n;j++){\n                if(a[j]-a[i]>=s[k]){\n                    dp[j][1]=min(dp[j][1],max(dp[i][0],a[j]-a[i]));\n                    dp[j][2]=min(dp[j][2],max(min(dp[i][1],dp[i][2]),a[j]-a[i]));\n                }\n            }\n        }\n        ans=min(ans,dp[n][2]-s[k]);\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\t\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <cassert>\n#define INF 2000000000\n#define MOD 1000000007\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define mk make_pair\n#define en endl\n#define RE return 0\n#define int ll\n#define P pair<int,int>\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\nint lcm(int a,int b){if(a==0){return b;} return a/gcd(a,b)*b;}\n\nint n;\n#define MAX 55\nint l[MAX];\n\nint dp[MAX];\n\nsigned main(){\n\tcin>>n; \n\tint sum=0;\n\tfor(int i=1; i<=n; i++){ \n\t\tcin>>l[i];\n\t\tsum+=l[i];\n\t}\n\t\n\tint ans=INF;\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=i; j<=n; j++){\n\t\t\tint cnt=0;\n\t\t\tfor(int k=i; k<=j; k++){\n\t\t\t\tcnt+=l[k];\n\t\t\t}\n\t\t\tfill(dp, dp+n+1, INF);\n\t\t\tif(sum==cnt) continue;\n\t\t\tdp[0]=cnt;\n\t\t\tfor(int k=1; k<=n; k++){\n\t\t\t\tint c=0;\n\t\t\t\tfor(int f=k; f>=1; f--){\n\t\t\t\t\tc+=l[f];\n\t\t\t\t\tif(k==n&&f==1) continue;\n\t\t\t\t\tif(c>=cnt){\n\t\t\t\t\t\tint a=max(c, dp[f-1]);\n\t\t\t\t\t\tdp[k]=min(dp[k], a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=min(ans, dp[n]-cnt);\n\t\t}\n\t}\n\tcout<<ans<<en;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <queue>\nusing ll = long long;\nusing namespace std;\nint L[51];\nint LL[52];\nint N;\nint get_segment(int a, int b) //L[a] + L[a+1] + ... + L[b]\n{\n    int sm = LL[b];\n    if (a)\n        sm -= LL[a - 1];\n    return sm;\n}\nint memo[55];\n\nint check(int idx, int mi, int ma)\n{\n    if (0 <= memo[idx])\n        return memo[idx];\n    if (idx == N)\n        return 1;\n\n    int lim = (idx == 0) ? N - 1 : N;\n    for (int i = idx; i < lim; ++i)\n    {\n        int sm = get_segment(idx, i);\n        if (sm >= mi && sm <= ma)\n        {\n            if (check(i + 1, mi, ma))\n                return memo[idx] = 1;\n        }\n    }\n\n    return memo[idx] = 0;\n}\nint main(void)\n{\n    cin >> N;\n    for (int i = 0; i < N; ++i)\n        cin >> L[i];\n\n    LL[0] = L[0];\n    for (int i = 1; i < N; ++i)\n        LL[i] = LL[i - 1] + L[i];\n\n    vector<int> v;\n    for (int i = 0; i < N; ++i)\n    {\n        for (int j = i; j < N; ++j)\n        {\n            int sm = get_segment(i, j);\n            v.push_back(sm);\n        }\n    }\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n\n    int n = v.size();\n    int ans = 1000000;\n    for (int i = 0; i < n; ++i)\n    {\n        for (int j = i; j < n; ++j)\n        {\n            int mi = v[i];\n            int ma = v[j];\n\n            for (int k = 0; k < N + 1; ++k)\n                memo[k] = -1;\n            if (check(0, mi, ma))\n                ans = min(ans, ma - mi);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n, a[55], dp[55][50005], sum[55];\n\nint main(){\n\tscanf(\"%d\", &n);\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum[i] = sum[i - 1] + a[i];\n\t}\n\t\n\tfor(int i = 1; i <= 50000; i++)\n\tdp[0][i] = i + 1;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= 50000; j++){\n\t\t\tdp[i][j] = -INF;\n\t\t\t\n\t\t\tfor(int k = 0; k < i; k++){\n\t\t\t\tif(i == n && k == 0) continue;\n\t\t\t\t\n\t\t\t\tint v = sum[i] - sum[k];\n\t\t\t\tif(v <= j)\n\t\t\t\tdp[i][j] = max(dp[i][j], min(v, dp[k][j]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint res = INF;\n\t\n\tfor(int i = 1; i <= 50000; i++)\n\tres = min(res, i - dp[n][i]);\n\t\n\tprintf(\"%d\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-7)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n\n\nint a[60];\nint r[60];\nint n;\nbool ch(int h,int m){\n\tif(m<h) return 0;\n\t\n\tint dp[60]={0};\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<i;j++)if(dp[j])if(r[i]-r[j]>=h &&r[i]-r[j]<=m){\n\t\t\tif(!(i==n && j==0))dp[i]=1;\n\t\t}\n\t}\n\t\n\t//cout<<h<<\" \"<<m<<\" \"<<dp[n]<<endl;\n\treturn dp[n];\n}\t\n\n   signed main(){\n        cin.tie(0);\n    \t\tios::sync_with_stdio(false);\n\n  \n   \tcin>>n;\n   \tfor(int i=1;i<=n;i++)cin>>a[i];\n   \tr[0]=0;\n   \tfor(int i=1;i<=n;i++)r[i]=r[i-1]+a[i];\n   \t\n   \tint ans=inf;\n   \tfor(int i1=1;i1<=n;i1++)for(int i2=i1;i2<=n;i2++){\n   \t\tint mi=r[i2]-r[i1-1];\n   \t\tif(ch(mi,mi)){\n   \t\t\tans=0;\n   \t\t\tcontinue;\n   \t\t}\n   \t\t\n   \tint si=mi-1,ue=mi+50*1000+1,me;\n   \t\twhile(ue-si>1){\n   \t\t\tme=(ue+si)/2;\n   \t\t\tif(ch(mi,me))ue=me;\n   \t\t\telse si=me;\n   \t\t}\n   \t\tans=min(ue-mi,ans);\n   \t\n   \t\n   \t}\n   \t\n   \tcout<<ans<<endl;\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    int a[n];\n    r(i,n)cin>>a[i];\n    vector<int>v;\n    for(int i=0;i<n;i++){\n        int sum=0;\n        for(int j=i;j<n;j++){\n            sum+=a[j];\n            v.push_back(sum);\n        }\n    }\n    int ans=1e9;\n    r(i,v.size()){\n        int sum=0;\n        vector<int>t;\n        r(j,n){\n            sum+=a[j];\n            if(sum>=v[i]||j==n-1){\n                t.push_back(sum);\n                sum=0;\n            }\n        }\n        sort(t.begin(),t.end());\n        if(t.size()>=2)ans=min(ans,t[t.size()-1]-t[0]);\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\ntypedef pair< int, int > Pi;\ntypedef pair< long long, long long > P;\ntypedef pair< long long, P > PP;\ntypedef pair< P, P > PPP;\n\nconst long long MOD = 1e9 + 7;\nconst long long INF = 5e18;\nconst int di[4] = { 1,0,-1,0 };\nconst int dj[4] = { 0,1,0,-1 };\n\n#define fr first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define ALL(x) (x).begin(),(x).end()\n\nll n,l[51],rui[55];\nll dp[55][50010],ans=INF;\n\nvoid input(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>l[i];\n\t\trui[i+1]=rui[i]+l[i];\n\t}\n\treturn;\n}\n\nvoid solve(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<50010;j++){\n\t\t\tdp[i][j]=INF;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<50010;j++){\n\t\t\tfor(int k=i+1;k<=n;k++){\n\t\t\t\tif(dp[i][j]==INF)continue;\n\t\t\t\tif(k==n&&j==0)continue;\n\t\t\t\tif(j==0)dp[k][rui[k]]=min(dp[k][rui[k]],rui[k]);\n\t\t\t\telse{\n\t\t\t\t\tif(rui[k]-rui[i]<j)dp[k][rui[k]-rui[i]]=min(dp[k][rui[k]-rui[i]],dp[i][j]);\n\t\t\t\t\telse dp[k][j]=min(dp[k][j],max(dp[i][j],rui[k]-rui[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=50000;i++){\n\t\tif(dp[n][i]==INF||dp[n][i]==0)continue;\n\t\tans=min(ans,dp[n][i]-i);\n\t}\n\tcout<<ans<<endl;\n\treturn;\n}\n\nint main(){\n\tinput();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint L[50];\n\nbool check(int x,int y){\n  map<int,bool> visited;\n  queue<int> Q;\n  Q.push(0);\n  visited[0]=true;\n  while(!Q.empty()){\n    int p=Q.front();\n    Q.pop();\n    if(p==N)return true;\n    int sum=0;\n    for(int to=p+1;to<=N;to++){\n      if(p==0 && to==N)continue;\n      sum+=L[to-1];\n      if(sum<x || y<sum)continue;\n      if( !visited[to] ){\n        visited[to]=true;\n        Q.push(to);\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>L[i];\n  }\n  for(int i=1;i<=1000;i++){\n    for(int j=1;j<=25000;j++){\n      if( check(j,i+j) ){\n        cout<<i<<endl;\n        return 0;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define PP std::pair<int,int>\nint N;\nint L[50];\nPP D[51][51];\nint res[51][51];\nint ans=1<<30;\nint main(){\n    std::cin>>N;\n    for(int i=1;i<=N;i++){\n        std::cin>>L[i];\n        L[i]+=L[i-1];\n    }\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            res[i][j]=1<<30;\n        }\n    }\n    for(int i=0;i<=N;i++){\n        D[i][1]={std::min(L[N]-L[i],L[i]),std::min(L[N]-L[i],L[i])};\n        ans=std::min(ans,std::abs(L[N]-L[i]-L[i]));\n    }\n    for(int i=1;i<=N;i++){\n        for(int j=2;j<=i;j++){\n            for(int k=j-1;k<i;k++){\n                int m=std::min({D[k][j-1].first,L[N]-L[i],L[i]-L[k]});\n                int M=std::max({D[k][j-1].second,L[N]-L[i],L[i]-L[k]});\n                if(res[i][j]>M-m){\n                    res[i][j]=M-m;\n                    ans=std::min(res[i][j],ans);\n                    int m=std::min(D[k][j-1].first,L[i]-L[k]);\n                    int M=std::max(D[k][j-1].second,L[i]-L[k]);\n                    D[i][j]={m,M};\n                }\n            }\n        }\n    }\n    std::cout<<ans<<std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (((bit >> i) & 1) > 0)\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\nvoid print() { std::cout << std::endl; }\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { std::cout << head; if (sizeof...(tail) != 0) {std::cout << \" \";} print(std::forward<Tail>(tail)...); }\ntemplate <class T> void print(std::vector<T> &v) {for (auto& a : v) { std::cout << a; if (&a != &v.back()) {std::cout << \" \";} }std::cout << std::endl;}\ntemplate <class T> void print(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int)v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 58u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};    // 右，下，左，上\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\ntemplate<typename T>class CumulativeSum {\npublic:\n    std::vector<T> memo1;               // 1次元用の累積和表\n    std::vector<std::vector<T>> memo2;  // 2次元用の累積和表\n\n    CumulativeSum() {}\n\n    void build(const std::vector<T> &line) {\n        this->memo1.assign(line.size() + 1, 0);\n\n        for (int i = 0; i < line.size(); ++i) {\n            this->memo1[i + 1] = this->memo1[i] + line[i];\n        }\n    }\n\n    // 2次元の累積和表を作成\n    void build(const std::vector<std::vector<T>> &board) {\n        int height = board.size();\n        int width = board[0].size();\n        this->memo2.assign(height + 1, std::vector<T>(width + 1, 0));\n\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                memo2[y + 1][x + 1] = board[y][x] + memo2[y + 1][x];\n            }\n            for (int x = 0; x < width; ++x) {\n                memo2[y + 1][x + 1] += memo2[y][x + 1];\n            }\n        }\n    }\n\n    T sum(int left, int right) {\n        return this->memo1[right] - this->memo1[left];\n    }\n\n    /*\n    (y1, x1)から(y2, x2)の合計を返す．(y2, x2)は含まない\n    座標はmemoを作成したboard準拠\n    (ex, sum(0, 0, 2, 2)なら(0, 0), (0, 1), (1, 0), (1, 1)の合計を返す)\n    */\n    T sum(int y1, int x1, int y2, int x2) {\n        return this->memo2[y2][x2] - this->memo2[y2][x1] - this->memo2[y1][x2] + this->memo2[y1][x1];\n    }\n};\n\n\nCumulativeSum<LL> cs;\nLL func(const int l, const int r, const vector<LL> &a, const LL maxi) {\n    if (l == r) {\n        return 0;\n    }\n\n    int N = r - l;\n    vector<vector<long long>> dp(r + 1, vector<long long>(r + 1, LINF));\n    for (int length = 1; length < N + 1; ++length) {\n        for (int left = l; left < r; ++left) {\n            int right = left + length;\n            if (right > r) {\n                continue;\n            }\n\n            auto sum = cs.sum(left, right);\n            if (sum <= maxi) {\n                chmin(dp[left][right], maxi - sum);\n            }\n            for (int m = left + 1; m < right; ++m) {\n                chmin(dp[left][right], max(dp[left][m], dp[m][right]));\n            }\n        }\n    }\n\n    return dp[l][r];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    LL N;\n    cin >> N;\n    auto L = make_v<LL>(N);\n    FOR(i, 0, N) {\n        cin >> L[i];\n    }\n    cs.build(L);\n    LL maxi = MAX(L);\n\n    LL ans = LINF;\n    FOR(i, 0, N) {\n        FOR(j, i + 1, N + 1) {\n\n            LL len = cs.sum(i, j);\n            if (len < maxi or j - i == N) {\n                continue;\n            }\n\n            LL left = func(0, i, L, len);\n            LL right = func(j, L.size(), L, len);\n            chmin(ans, max(left, right));\n        }\n    }\n    print(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<int> L(N);\n\tfor (int i = 0; i < N; ++i) cin >> L[i];\n\tvector<int> S(N + 1);\n\tfor (int i = 0; i < N; ++i) S[i + 1] = S[i] + L[i];\n\tvector<int> lens;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tlens.push_back(S[i] - S[j]);\n\t\t}\n\t}\n\tsort(lens.begin(), lens.end());\n\tlens.erase(unique(lens.begin(), lens.end()), lens.end());\n\tint ans = lens.back();\n\tfor (int i : lens) {\n\t\tif (i == lens.back()) continue;\n\t\tvector<int> dp(N + 1, -1); dp[0] = i;\n\t\tfor (int j = 1; j <= N; ++j) {\n\t\t\tfor (int k = 0; k < j; ++k) {\n\t\t\t\tif (S[j] - S[k] <= i) {\n\t\t\t\t\tdp[j] = max(dp[j], min(dp[k], S[j] - S[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp[N] != -1) ans = min(ans, i - dp[N]);\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, sum[100], last, cnt, ans=INF, a[100],dp[100][1000];\nstring str, ss;\nbool f;\nchar c;\nint d[4][2] = { {1,0},{-1,0} ,{0,1},{0,-1} };\nstruct Edge { LL to,cost; };\nLL vec[1000][1000];\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nint main() {\n\tcin >> n;\n\tsum[0] = 0;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t\tsum[i + 1] = sum[i] + a[i];\n\t}\n\trep(i, n+1)\n\t\trep(j, sum[n])dp[i][j] = -1;\n\tdp[0][0] = INF;\n\trep(i, n)\n\t\trep(j, sum[n]+100) {\t\n\t\tif (dp[i][j] != -1) {\n\t\tfor (int k = i; k < n; k++) {\n\t\t\tif (i == 0 && k == n-1) continue;\n\t\t\t\tLL l = min(dp[i][j], sum[k + 1] - sum[i]), r = max(sum[k + 1] - sum[i], j);\n\t\t\t\tdp[k + 1][r] = max(l, dp[k + 1][r]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, sum[n]) {\n\t\tif(dp[n][i]!=-1)\n\t\tans = min(ans, i - dp[n][i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nint p[60];\nint sum[60];\nint dp[60][51000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\t// int sum=0;\n\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);\n\tfor(int i=0;i<a;i++)sum[i+1]=sum[i]+p[i];\n\tfor(int i=0;i<60;i++)for(int j=0;j<51000;j++)dp[i][j]=mod;\n\tfor(int i=0;i<51000;i++)dp[0][i]=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=1;j<51000;j++){\n\t\t\tif(dp[i][j]==mod)continue;\n\t\t\tfor(int k=i+1;k<=a;k++){\n\t\t\t\tif(i==0&&k==a)continue;\n\t\t\t\tint val=sum[k]-sum[i];\n\t\t\t\tif(val<j)continue;\n\t\t\t\tdp[k][j]=min(dp[k][j],max(val,dp[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tint ret=mod;\n\tfor(int i=0;i<51000;i++){\n\t\t// if(dp[a][i]<100)printf(\"%d: %d\\n\",i,dp[a][i]);\n\t\tret=min(ret,dp[a][i]-i);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint L[50];\n\nbool check(int x,int y){\n  map<int,bool> visited;\n  queue<int> Q;\n  Q.push(0);\n  visited[0]=true;\n  while(!Q.empty()){\n    int p=Q.front();\n    Q.pop();\n    if(p==N)return true;\n    int sum=0;\n    for(int to=p+1;to<=N;to++){\n      if(p==0 && to==N)continue;\n      sum+=L[to-1];\n      if(sum<x || y<sum)continue;\n      if( !visited[to] ){\n        visited[to]=true;\n        Q.push(to);\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>N;\n\n  vector<int> d;\n  for(int i=0;i<N;i++){\n    cin>>L[i];\n    int sum=0;\n    for(int j=0;j<=i;j++){\n      sum+=L[j];\n      d.push_back(sum);\n    }\n  }\n  \n  for(int i=0;i<=1000;i++){\n    for(int j=0;j<(int)d.size();j++){\n      if( check(d[j],d[j]+i) ){\n        cout<<i<<endl;\n        return 0;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint max(int a, int b) {\n  return a > b ? a : b;\n}\n\nint main(void) {\n  int i, j, k, n, ans = 1000000;\n  scanf(\"%d\", &n);\n  int l[n], sum = 0;\n  for(i = 0; i < n; ++i) {\n    scanf(\"%d\", &l[i]);\n    sum += l[i];\n  }\n  for(i = 1; i <= 1000; ++i) {\n    int dp[n];\n    for(j = 0; j < n; ++j) dp[j] = 1000000;\n    for(j = 0; j < n; ++j) {\n      int now = 0;\n      for(k = j; k < n; ++k) {\n        now += l[k];\n        int tt;\n        if(!j) tt = 0;\n        else tt = dp[j - 1];\n        if(now >= i && dp[k] > max(now, tt)) dp[k] = max(now, tt); \n      }\n    }\n    if(dp[n - 1] != sum && ans > dp[n - 1] - i) ans = dp[n - 1] - i;\n    /*if(i == 17) {\n      for(j = 0; j < n; ++j) printf(\"%d \", dp[j]);\n     printf(\"\\n\");\n    }*/\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint L[50];\n\nbool check(int x,int y){\n  map<int,bool> visited;\n  queue<int> Q;\n  Q.push(0);\n  visited[0]=true;\n  while(!Q.empty()){\n    int p=Q.front();\n    Q.pop();\n    if(p==N)return true;\n    int sum=0;\n    for(int to=p+1;to<=N;to++){\n      if(p==0 && to==N)continue;\n      sum+=L[to-1];\n      if(sum<x || y<sum)continue;\n      if( !visited[to] ){\n        visited[to]=true;\n        Q.push(to);\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>L[i];\n  }\n  \n  vector<int> d;\n  for(int i=0;i<N;i++){\n    int sum=0;\n    for(int j=i;j<N;j++){\n      sum+=L[j];\n      d.push_back(sum);\n    }\n  }\n  \n  for(int i=0;i<=1000;i++){\n    for(int j=0;j<(int)d.size();j++){\n      if( check(d[j],d[j]+i) ){\n        cout<<i<<endl;\n        return 0;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int INF=(int)1e9;\n\nint solve(const int low,const vector<int>& ls)\n{\n\tconst int n=ls.size();\n\tvector<int> dp(n+1);\n\tdp[0]=low;\n\t\n\tfor(int position=0;position<n;position++)\n\t{\n\t\tint piece_length=0;\n\t\tint& value=dp[position+1];\n\t\t\n\t\tvalue=INF;\n\t\t\n\t\tfor(int piece_left=position;piece_left>=0;piece_left--){\n\t\t\t\n\t\t\tpiece_length+=ls[piece_left];\n\t\t\t\n\t\t\tif(position==n-1&&piece_left==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(piece_length>=low){\n\t\t\t\tconst int high=max(piece_length,dp[piece_left]);\n\t\t\t\tvalue=min(value,high);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n]-low;\n}\n\nint main()\n{\n\tint n;\n\tvector<int> ls;\n\t\n\tcin>>n;\n\tls.resize(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>ls[i];\n\t}\n\t\n\tint answer=INF;\n\tfor(int left=0;left<n;left++){\n\t\t\tint total_length=0;\n\t\t\tfor(int right=left;right<n;right++){\n\t\t\t\ttotal_length+=ls[right];\n\t\t\t\tint temp=solve(total_length,ls);\n\t\t\t\tanswer=min(answer,temp);\n\t\t\t}\n\t}\n\tcout<<answer<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n \nusing namespace std;\n \n#define INF (10000000)\n \nint main()\n{\n    int N;\n    cin >> N;\n \n    vector<int> L;\n \n    for(int i=0; i<N; ++i) {\n        int temp;\n        cin >> temp;\n        if(i!=0) temp+=L[i-1];\n        L.push_back(temp);\n    }\n \n    pair<int,int> dp[N][N];\n \n    for(int i=1; i<N; ++i) { // initialize ... divide into 2 parts / i...last index\n        int mx=INF, mn=-1, gap=INF;\n        for(int j=0; j<N-1; ++j) {\n            int temp=abs(L[i]-2*L[j]); // when cut after index-j\n            if(gap>temp) { // compare gap\n                mx=max(L[i]-L[j],L[j]); //update\n                mn=min(L[i]-L[j],L[j]);\n                gap=temp;\n            }\n        }\n        dp[1][i].first=mx;\n        dp[1][i].second=mn;\n    }\n \n    for(int i=2; i<N; ++i) { // i... number of divides\n        for(int j=1; j<N; ++j) { // j... last index\n            int mx=INF, mn=-1, gap=INF;\n            for(int k=1; j-k>=i-1; ++k) { // k...add new section to i-1 divides\n                int temp=abs(L[j]-L[j-k]);\n                if(max(dp[i-1][j-k].first,temp)-min(dp[i-1][j-k].second,temp)<gap) {\n                    mx=max(dp[i-1][j-k].first,temp);\n                    mn=min(dp[i-1][j-k].second,temp);\n                    gap=mx-mn;\n                }\n            }\n            dp[i][j].first=mx;\n            dp[i][j].second=mn;\n        }\n    }\n \n    int ans=10000000;\n \n    for(int i=1; i<N; ++i) {\n        ans=min(ans,dp[i][N-1].first-dp[i][N-1].second);\n    }\n \n    cout << ans << endl;\n \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx\")\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;i<(n);i++)\n#define rrep(i,n) for(int (i)=1;i<=(n);i++)\n#define REP(i,m,n) for(int (i)=(m);(i)<(n);(i)++)\n#define MOD 1000000007\n#define INF 1e18\n#define int long long\n#define endl \"\\n\"\n#define yorn(f) puts((f)?\"Yes\":\"No\")\n#define YORN(f) puts((f)?\"YES\":\"NO\")\ntypedef long long ll;\ntypedef pair<int, int> P;\nint gcd(int a,int b){return b?gcd(b,a%b):a;};\nint lcm(int a,int b){return a/gcd(a,b)*b;};\nint mod(int a,int b){return (a+b-1)/b;};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N],const T &val){std::fill((T*)array,(T*)(array+N),val);}\ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;};\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;};\n\nint n;\nvector<int> l(55);\nvector<int> sum(55);\nvector<int> yokan;\n\nbool check(int minlen, int maxlen) {\n\tvector<int> dp(55, 0);\n\tdp[0] = 1;\n\trrep(i, n) {\n\t\trep(j, i) {\n\t\t\tint nowlen = sum[i] - sum[j];\n\t\t\tif(minlen <= nowlen && nowlen <= maxlen && dp[j]) dp[i] = 1;\n\t\t}\n\t}\n\treturn dp[n];\n}\n\nsigned main() {\n\tcin.tie(0);\n\tcout.tie(0);\n\tios::sync_with_stdio(false);\n\t//cout << fixed << setprecision(15);\n\t\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> l[i];\n\t\tsum[i+1] = sum[i] + l[i];\n\t}\n\trep(i, n+1) {\n\t\tREP(j, i+1, n+1) {\n\t\t\tif(i == 0 && j == n) continue;\n\t\t\tyokan.push_back(sum[j] - sum[i]);\n\t\t}\n\t}\n\t//for(auto &x : yokan) cout << x << \" \";\n\tsort(all(yokan));\n\tint ans = sum[n];\n\trep(i, yokan.size()) {\n\t\tREP(j, i+1, yokan.size()) {\n\t\t\tint minlen = yokan[i];\n\t\t\tint maxlen = yokan[j];\n\t\t\tif(check(minlen, maxlen)) chmin(ans, maxlen - minlen);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> v[i];\n\t\tv[i] += v[i - 1];\n\t}\n\tL = -1;\n\tR = 50000;\n\twhile (R - L > 1) {\n\t\tint mid = (R + L + 1) / 2;\n\t\tvector<vector<int>>dp(N + 1, vector<int>(25001));\n\t\tfor (int i = 0; i <= 25000; i++) {\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = max(0, i - (int)N + 1); j < i; j++) {\n\t\t\t\tfor (int k = 1; k <= 25000; k++) {\n\t\t\t\t\tif (k + mid >= v[i] - v[j]&&k<=v[i]-v[j]) {\n\t\t\t\t\t\tdp[i][k] |= dp[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint box = 0;\n\t\tfor (int i = 1; i <= 25000; i++) {\n\n\t\t\tbox |= dp[N][i];\n\t\t}\n\t\tif (box) {\n\t\t\tR = mid;\n\t\t}\n\t\telse {\n\t\t\tL = mid;\n\t\t}\n\t}\n\tcout << R << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <bitset>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <list>\n#include <deque>\nusing namespace std;\n#define INF 10000000\n#define LLINF 100000000000000\ntypedef pair<int, int> P;\ntypedef long long ll;\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define VSORT(v) sort(v.begin(), v.end());\n#define fi first\n#define se second\n#define out(x) cout << x << endl;\nint dx[] = {1, 0, -1, 0}, dy[] = { 0,1,0,-1 };\nll MOD = 1000000007;\nstruct edge {\n\tll from, to, cost;\n};\n\nint n;\nint l[55] = {0};\n\nint main() {\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> l[i];\n\t\tl[i] += l[i-1];\n\t}\n\tint res = INF;\n\trep(i, 50000){\n\t\tint minl = i;\n\t\tint dp[55] = {0};\n\t\trep(k, 55) dp[k] = INF;\n\t\tdp[0] = 0;\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tfor(int k = 0; k < j; k++){\n\t\t\t\tint now = l[j] - l[k];\n\t\t\t\tif(now < minl) continue;\n\t\t\t\tdp[j] = min(dp[j], max(dp[k], now));\n\t\t\t}\n\t\t}\n\t\tif(dp[n] == l[n]) continue;\n\t\tif(dp[n] < minl) continue;\n\t\tres = min(res, dp[n] - minl);\n\t}\n\tcout << res << endl;\n \treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define PP std::pair<int,int>\nint N;\nint L[51];\nstd::vector<PP> D[51][51];\nint res[51][51];\nint ans=1<<30;\nint main(){\n    std::cin>>N;\n    for(int i=1;i<=N;i++){\n        std::cin>>L[i];\n        L[i]+=L[i-1];\n    }\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            res[i][j]=1<<30;\n        }\n    }\n    for(int i=0;i<=N;i++){\n        D[i][1].push_back(PP{L[i],L[i]});\n        ans=std::min(ans,std::abs(L[N]-L[i]-L[i]));\n    }\n    for(int i=1;i<N;i++){\n        for(int j=2;j<=i;j++){\n            for(int k=j-1;k<i;k++){\n                for(auto u:D[k][j-1]){\n                    int m=std::min({u.first,L[N]-L[i],L[i]-L[k]});\n                    int M=std::max({u.second,L[N]-L[i],L[i]-L[k]});\n                    if(res[i][j]>=M-m){\n                        if(res[i][j]>M-m){\n                            D[i][j].clear();\n                        }\n                        res[i][j]=M-m;\n                        ans=std::min(res[i][j],ans);\n                        int m=std::min(u.first,L[i]-L[k]);\n                        int M=std::max(u.second,L[i]-L[k]);\n                        if(M-m>ans)continue;\n                        D[i][j].push_back(PP{m,M});\n                    }\n                }\n            }\n        }\n    }\n    std::cout<<ans<<std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (auto &&i : v) scanf(\"%d\", &i);\n    vector<int> S(n+1);\n    for (int i = 0; i < n; ++i) {\n        S[i+1] = S[i] + v[i];\n    }\n    int ans = INF<int>;\n    for (int l = 0; l < n; ++l) {\n        for (int r = l+1; r <= n; ++r) {\n            if(r-l == n) continue;\n            int m = S[r] - S[l];\n            int M = m;\n            if(l) {\n                if(S[l]-S[0] < m) continue;\n                vector<int> dp(l+1, INF<int>);\n                dp[0] = 0;\n                for (int i = 1; i <= l; ++i) {\n                    for (int j = 0; j < i; ++j) {\n                        if(S[i]-S[j] >= m) dp[i] = min(dp[i], max(dp[j], S[i]-S[j]));\n                    }\n                }\n                M = max(M, dp[l]);\n            }\n            if(r != n) {\n                if(S[n]-S[r] < m) continue;\n                vector<int> dp(n+1, INF<int>);\n                dp[r] = 0;\n                for (int i = r+1; i <= n; ++i) {\n                    for (int j = r; j < i; ++j) {\n                        if(S[i]-S[j] >= m) dp[i] = min(dp[i], max(dp[j], S[i]-S[j]));\n                    }\n                }\n                M = max(M, dp[n]);\n            }\n            ans = min(ans, M-m);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 1000 * 50 + 1;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass CumulativeSum{\npublic:\n  vector<int> sum;\n  CumulativeSum(){}\n  CumulativeSum(vector<int> A){\n    int n = A.size();\n    sum.resize(n+1,0);\n    for(int i=1;i<=n;i++) sum[i] += sum[i-1] + A[i-1];\n  }\n  int get(int l,int r){assert(l>=0 && r<=(int)sum.size());return sum[r] - sum[l];} //[l,r)\n};\n\n\nint n;\nvector<int> A;\nCumulativeSum Sum;\n\nsigned main(){\n  cin>>n;\n  A.resize(n);\n  cin>>A;\n  Sum = CumulativeSum(A);\n  \n  vector<vector<int> >dp(n+1,vector<int>(N,-INF));\n  dp[0][0] = INF;\n  \n  for(int i=0;i<n;i++){\n    for(int mx = 0;mx < N; mx++){\n      if(dp[i][mx] == -INF) continue;\n      for(int k=i;k<n;k++){\n        if(i == 0 && k == n-1) continue;\n        int sum = Sum.get(i,k+1);\n        int nmx = max(mx,sum);\n        int na = min(dp[i][mx],sum);\n        Max(dp[k+1][nmx] ,na);\n      }\n    }\n  }\n\n  int ans = INF;\n  for(int i=0;i<N;i++) if(dp[n][i] != -INF)  Min(ans, i - dp[n][i]);\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint L[50];\n\nint calc(int x,int y){\n  int maxm=0;\n  int mini=1e9;\n  int sum=0;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    sum+=L[i];\n    if(sum>=x){\n      cnt++;\n      maxm=max(maxm,sum);\n      mini=min(mini,sum);\n      sum=0;\n    }else if(sum>y){\n      return 1e9;\n    }\n  }\n  if(sum>0){\n    cnt++;\n    maxm=max(maxm,sum);\n    mini=min(mini,sum);\n  }\n  if(cnt>1){\n    return maxm-mini;\n  }else{\n    return 1e9;\n  }\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>L[i];\n  }\n  int ans=1e9;\n  for(int i=1;i<=50000;i++){\n    for(int j=i;j<=i+1000;j++){\n      ans=min(ans,calc(i,j));\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint qmin(int a, int b) {\n    if (a == 0) {\n        return b;\n    }\n    else {\n        return min(a, b);\n    }\n}\nint main() {\n    int n;\n    cin >> n;\n    vector<int> l(n);\n    for (int i = 0; i < n; i++) {\n        cin >> l[i];\n    }\n    vector<int> su(n+1);\n    su[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        su[i] = su[i - 1] + l[i-1];\n    }\n    vector<vector<int> > a(n + 1, vector<int>(su[n]+1, -1));\n    a[0][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= su[i - 1];j++) {\n                for (int k = 0; k < i; k++) {\n                    if (a[k][j] != -1) {\n                        int z = max(su[i] - su[k], j);\n                        a[i][z] = max(a[i][z],qmin(a[k][j], su[i]-su[k]));\n                    }\n                }\n          }\n    }\n    int ans = su[n];\n    for (int i = 0; i < su[n]; i++) {\n        if (a[n][i] != -1) {\n            ans = min(ans, i - a[n][i]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX_N = 50;\nstatic const int INF = 1 << 30;\n\nint N;\nint L[MAX_N];\nint sum[MAX_N + 1];\nint memo[MAX_N + 1];\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\", &L[i]);\n\t\tsum[i + 1] = sum[i] + L[i];\n\t}\n\tint res = INF;\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tint min_l = sum[i] - sum[j];\n\t\t\tfill(memo, memo + N + 1, INF);\n\t\t\tmemo[j] = 0;\n\t\t\tfor(int k = j - 1; k >= 0; k--){\n\t\t\t\tfor(int l = j; l > k; l--){\n\t\t\t\t\tif(memo[l] != INF && sum[l] - sum[k] >= min_l) memo[k] = min(memo[k], max(memo[l], sum[l] - sum[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[i] = 0;\n\t\t\tfor(int k = i + 1; k < N + 1; k++){\n\t\t\t\tfor(int l = i; l < k; l++){\n\t\t\t\t\tif(memo[l] != INF && sum[k] - sum[l] >= min_l) memo[k] = min(memo[k], max(memo[l], sum[k] - sum[l]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(memo[0] == INF || memo[N] == INF) continue;\n\t\t\tif(max(memo[0], memo[N]) - min_l < 0) continue;\n\t\t\tres = min(res, max(memo[0], memo[N]) - min_l);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 2147483647\n#define INF_LL 9223372036854775807\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n// 2 3 8 4\n// 0 2 5 13 17\nint N;\n\nint solve(int m, vector<int> ls) {\n\tvector<int> dp(N+1,0);\n\tdp[0] = m;\n\tfor (int i = 0; i < N; i++) {\n\t\tint p_n = 0;\n\t\tdp[i+1] = INF / 2;\n\t\tfor (int j = i; j >= 0; j--) {\n\t\t\tp_n += ls[j];\n\t\t\tif (i == N - 1 && j == 0)continue;\n\t\t\tif (p_n >= m) {\n\t\t\t\tint high = max(dp[j], p_n);\n\t\t\t\tdp[i + 1] = min(dp[i + 1], high);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[N] - m;\n}\n\nint main() {\n\tcin >> N;\n\tvector<int> ls(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ls[i];\n\t}\n\n\tint ans = INF / 2;\n\tfor (int i = 0; i < N; i++) {\n\t\tint l = 0;\n\t\tfor (int j = i; j < N; j++) {\n\t\t\tl += ls[j];\n\t\t\tans = min(ans, solve(l, ls));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<int,int>;\nusing P3 = pair<ll,P>;\nusing PP = pair<P, P>;\nconstexpr int INF = 1<<30;\n\nvoid chmin(int &a, int b){\n    a = min(a, b);\n}\n\nint l[55], dp[55][50005];  // dp[i][j] i番目の切れ目まで見て最小長さがjであるときの最大長さの最小値\nbool solve(){\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> l[i+1];\n        l[i+1] += l[i];\n    }\n    for(int i=0;i<=n;i++){\n        fill(dp[i], dp[i]+l[n]+1, INF);\n    }\n    dp[0][l[n]] = 0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=l[n];j++){\n            if(dp[i][j] == INF) continue;\n            for(int k=i+1;k<=n;k++){\n                int L = l[k]-l[i];\n                chmin(dp[k][min(j,L)], max(dp[i][j], L));\n            }\n        }\n    }\n    int ans = INF;\n    for(int i=0;i<l[n];i++){\n        chmin(ans,dp[n][i]-i);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main(){\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> L(N), sum(N + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L[i];\n\t\tsum[i + 1] = sum[i] + L[i];\n\t}\n\tint res = sum[N];\n\tfor (int i = 1; i <= sum[N] - 1; i++) {\n\t\tvector<int> dp(N + 1, -sum[N]);\n\t\tdp[0] = i;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tfor (int k = 0; k <= j; k++) if (sum[j + 1] - sum[k] <= i) {\n\t\t\t\tdp[j + 1] = max(dp[j + 1], min(dp[k], sum[j + 1] - sum[k]));\n\t\t\t}\n\t\t}\n\t\tres = min(res, i - dp[N]);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\n#define INF (10000000)\n\nint main()\n{\n    int N;\n    cin >> N;\n\n    vector<int> L;\n\n    for(int i=0; i<N; ++i) {\n        int temp;\n        cin >> temp;\n        if(i!=0) temp+=L[i-1];\n        L.push_back(temp);\n    }\n\n    pair<int,int> dp[N][N];\n\n    for(int i=1; i<N; ++i) { // initialize ... divide into 2 parts / i...last index\n        int mx=INF, mn=-1, gap=INF;\n        for(int j=0; j<N-1; ++j) {\n            int temp=abs(L[i]-2*L[j]); // when cut after index-j\n            if(gap>temp) { // compare gap\n                mx=max(L[i]-L[j],L[j]); //update\n                mn=min(L[i]-L[j],L[j]);\n                gap=temp;\n            }\n        }\n        dp[1][i].first=mx;\n        dp[1][i].second=mn;\n    }\n\n    for(int i=2; i<N; ++i) { // i... number of divides\n        for(int j=1; j<N; ++j) { // j... last index\n            int mx=INF, mn=-1, gap=INF;\n            for(int k=1; j-k>=i-1; ++k) { // k...add new section to i-1 divides\n                int temp=abs(L[j]-L[j-k]);\n                if(max(dp[i-1][j-k].first,temp)-min(dp[i-1][j-k].second,temp)<gap) {\n                    mx=max(dp[i-1][j-k].first,temp);\n                    mn=min(dp[i-1][j-k].second,temp);\n                    gap=mx-mn;\n                }\n            }\n            dp[i][j].first=mx;\n            dp[i][j].second=mn;\n        }\n    }\n\n    int ans=10000000;\n\n    for(int i=1; i<N; ++i) {\n        ans=min(ans,dp[i][N-1].first-dp[i][N-1].second);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <utility>\n#include <functional>\n#define INF 0x3f3f3f3f\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint dp[60][60000];\nint l[60];\nint main() {\n\tint n; cin >> n;\n\tmemset(dp, 0x3f, sizeof(dp));\n\tint cnt = 0;\n\trep(i, n) {\n\t\tcin >> l[i];\n\t\tcnt += l[i];\n\t\tdp[i][cnt] = 0;\n\t}\n\trep(i, n)rep(j, 60000) {\n\t\tif (dp[i][j] == INF)continue;\n\t\tint Min = j, Max = j + dp[i][j];\n\t\tint sum = 0;\n\t\tfor (int k = i + 1; k < n; k++) {\n\t\t\tsum += l[k];\n\t\t\tdp[k][min(Min, sum)] = min(dp[k][min(Min, sum)], max(sum, Max) - min(Min, sum));\n\t\t}\n\t}\n\tint Min = INF;\n\trep(i, cnt)Min = min(Min, dp[n - 1][i]);\n\tcout << Min << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint l[51],dp[51];\nint main(void)\n{\n\tint n,MIN,sum,lsum,i,j,k,ans,MAX2,a;\n\tscanf(\"%d\",&n);\n\tlsum=0;\n\tMAX2=0;\n\tans=50001;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&l[i]);\n\t\tlsum+=l[i];\n\t\tMAX2=max(MAX2,l[i]);\n\t}\n\tfor(i=MAX2;i<lsum;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[j]=0;\n\t\t}\n\t\tsum=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tsum+=l[j];\n\t\t\tif(sum>i){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdp[j]=sum;\n\t\t}\n\t\tfor(j=0;j<n;j++){\n\t\t\tsum=0;\n\t\t\tfor(k=j+1;k<n;k++){\n\t\t\t\tsum+=l[k];\n\t\t\t\tif(sum>i){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ta=min(sum,dp[j]);\n\t\t\t\tdp[k]=max(a,dp[k]);\n\t\t\t}\n\t\t}\n\t\tans=min(ans,i-dp[n-1]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "// mizuyokan\n// JOI 2017/2018 yosen Q4\n// YAMADA Terushige  2018.8.18.\n\n#include<iostream>\nusing namespace std;\n#define NMAX 51\n#define INF (1<<30)\n\nint N;\nint TL[NMAX];// 左端から切れ目までの長さ\n\n// 最小のピース長 lmin に対する適切な最大のピース長を動的計画法で求める\nint lmax(int lmin){\n  //  cout << \"lmin = \" << lmin << endl;\n  int dp[NMAX];// i 番目の切れ目まで考えるときの適切な最大のピース長\n  dp[0]=0;\n\n  for(int i=1;i<=N;i++){ // ピースの右端\n    //    cout << \"i = \" << i << endl;\n    dp[i]=INF;\n    for(int j=0;j<i;j++){ // ピースの左端\n      if(i==N && j==0) continue;// 最低でも1箇所はカットする\n      //      cout << \"(\" << j << \",\" << i << \") \"; \n      int lpiece=TL[i]-TL[j]; // ピースの長さ\n      //      cout << \"lpiece = \" << lpiece << endl;\n      if(lpiece >= lmin)\n\tdp[i]=min( max(lpiece,dp[j]) ,dp[i]);\n      //      cout << \" dp[\" << i << \"] = \" << dp[i];\n    }\n    //    cout << endl;\n  }\n  return dp[N];\n}\n\nint main(){\n  cin >> N;\n  TL[0]=0;\n  for(int i=1;i<=N;i++){\n    int l;\n    cin >> l;\n    TL[i]=TL[i-1]+l; // 左端から切れ目までの長さ\n  }\n\n  int ans=INF;\n  for(int i=0;i<N;i++){// left of minimum piece\n    for(int j=i+1;j<=N;j++){// right of minimum piece\n      if(i==0 && j==N) continue;\n      int lmin=TL[j]-TL[i];// length of minimum piece\n      ans = min( lmax(lmin)-lmin ,ans);\n      //      cout << \"ans = \" << ans << endl;\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 2018/12/19 Tazoe\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint DFS(int m[50], int n, int bef)\n{\n\tint max_m = m[0];\n\tint min_m = m[0];\n\n\tfor(int i=1; i<n; i++){\n\t\tmax_m = max(max_m, m[i]);\n\t\tmin_m = min(min_m, m[i]);\n\t}\n\n\tint dif = min(bef, max_m-min_m);\n\n\n\tif(n==2)\n\t\treturn dif;\n\n\n\tint dif2 = dif;\n\n\tfor(int i=0; i<n-1; i++){\n\t\tint t[50];\n\t\tfor(int j=0; j<i; j++)  t[j] = m[j];\n\t\tt[i] = m[i]+m[i+1];\n\t\tfor(int j=i+1; j<n-1; j++)  t[j] = m[j+1];\n\n\t\tdif2 = min(dif2, DFS(t, n-1, dif));\n\t}\n\n\treturn dif2;\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\n\tint L[50];\n\tfor(int i=0; i<N; i++){\n\t\tcin >> L[i];\n\t}\n\n\tcout << DFS(L, N, 1000) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint n, l[50];\nint sum[51];\nbool ok[51];\n\nbool check(int H, int h) { // max H - min H - h\n  for (int i = 1; i <= n; i++) ok[i] = false;\n  ok[0] = true;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < i; j++) {\n      int len = sum[i] - sum[j];\n      if (i == n && j == 0) continue;\n      if (ok[j] && H - h <= len && len <= H) {\n        ok[i] = true;\n        break;\n      }\n    }\n  }\n  return ok[n];\n}\n\nint search(int H) {\n  int lb = 0, ub = 5000;\n  while (lb + 1 < ub) {\n    int md = (lb + ub) / 2;\n    if (check(H, md)) ub = md;\n    else lb = md;\n  }\n  if (check(H, lb)) return lb;\n  return ub;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) scanf(\"%d\", &l[i]);\n  sum[0] = 0;\n  for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + l[i];\n  int ans = 500000;\n  for (int i = 0; i < 50000; i++) ans = min(ans, search(i));\n  printf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    int a[n];\n    r(i,n)cin>>a[i];\n    vector<int>v;\n    for(int i=0;i<n;i++){\n        int sum=0;\n        for(int j=i;j<n;j++){\n            sum+=a[j];\n            v.push_back(sum);\n        }\n    }\n    int ans=1e9;\n    r(i,v.size()){\n        vector<int>t;\n        for(int k=0;k<n;k++){\n            for(int l=k;l<n;l++){\n                int sum=0;\n                for(int j=0;j<k;j++){\n                    sum+=a[j];\n                    if(sum>=v[i]||j==k-1){\n                        t.push_back(sum);\n                        sum=0;\n                    }\n                }\n                sum=0;\n                for(int j=k;j<l;j++){\n                    sum+=a[j];\n                    if(sum>=v[i]||j==l-1){\n                        t.push_back(sum);\n                        sum=0;\n                    }\n                }\n                sum=0;\n                for(int j=l;j<n;j++){\n                    sum+=a[j];\n                    if(sum>=v[i]||j==n-1){\n                        t.push_back(sum);\n                        sum=0;\n                    }\n                }\n                sort(t.begin(),t.end());\n                if(t.size()>=2)ans=min(ans,t[t.size()-1]-t[0]);\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = std::numeric_limits<long long>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, s, t, q, sum[100], last, cnt, ans=INF, a[100],dp[100][100000];\nstring str, ss;\nbool f;\nchar c;\nint d[4][2] = { {1,0},{-1,0} ,{0,1},{0,-1} };\nstruct Edge { LL to,cost; };\nLL vec[1000][1000];\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nint main() {\n\tcin >> n;\n\tsum[0] = 0;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t\tsum[i + 1] = sum[i] + a[i];\n\t}\n\trep(i, n+1)\n\t\trep(j, sum[n])dp[i][j] = -1;\n\tdp[0][0] = INF;\n\trep(i, n)\n\t\trep(j, sum[n]+100) {\t\n\t\tif (dp[i][j] != -1) {\n\t\tfor (int k = i; k < n; k++) {\n\t\t\tif (i == 0 && k == n-1) continue;\n\t\t\t\tLL l = min(dp[i][j], sum[k + 1] - sum[i]), r = max(sum[k + 1] - sum[i], j);\n\t\t\t\tdp[k + 1][r] = max(l, dp[k + 1][r]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, sum[n]) {\n\t\tif(dp[n][i]!=-1)\n\t\tans = min(ans, i - dp[n][i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int INF = 10101010;\n\nint main(){\n    int n;\n    cin >>n;\n    vector<int> l(n);\n    rep(i,n) cin >>l[i];\n\n    vector<int> pre(n+1);\n    rep(i,n) pre[i+1] = l[i];\n    rep(i,n) pre[i+1] += pre[i];\n\n    vector<int> v;\n    rep(i,n)for(int j=i; j<n; ++j) v.pb(pre[j+1]-pre[i]);\n    sort(all(v));\n    v.erase(unique(all(v)), v.end());\n\n    int ans = INF;\n    for(int lb:v){\n        vector<int> dp(n+1,INF);\n        dp[0]=0;\n        rep(i,n){\n            for(int j=i; j<n; ++j){\n                if(i==0 && j==n-1) continue;\n\n                int t = pre[j+1]-pre[i];\n                if(t<lb) continue;\n                dp[j+1] = min(dp[j+1], max(dp[i],t));\n            }\n        }\n\n        ans = min(ans, dp[n]-lb);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint N;\nint L[50]{};\nint a[51]{}; // 累積和\nint ans = INT32_MAX;\nint x, y; // x <= y\n\nint dp[51]{};\n\nvoid solve(int l) {\n    fill(dp, dp + 51, 100000000);\n    \n    dp[0] = 0;\n    for (int i = 0; i < N; i++) {\n        int t = 0;\n        for (int j = i; j >= 0; j--) {\n            t += L[j];\n            // 水ようかん全てを連結したものは除外する\n            if(i == N - 1 && j == 0) continue;\n            if (t >= l) {\n                dp[i + 1] = min(dp[i + 1], max(dp[j], t));  \n            }\n        }\n    }\n    ans = min(ans, dp[N] - l);\n}\n\nint main() {\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> L[i];\n    }\n    for (int i = 0; i < N; i++) {\n        a[i + 1] += a[i] + L[i];\n    }\n    set<int> s;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            s.insert(a[j] - a[i]);\n        }\n    }\n    \n    // 水ようかんの全体の長さは除外\n    s.erase(*s.rbegin());\n    for (int i : s) {\n        solve(i);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint L[N];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&L[i]);\n\t\tif(i > 0){\n\t\t\tL[i] += L[i-1];\n\t\t}\n\t}\n\n\tint length[N+1][N+1];\n\n\tfor(int left = 0; left <= N-1; left++){\n\t\tfor(int right = 1; right <= N; right++){\n\t\t\tif(left == 0){\n\t\t\t\tlength[left][right] = L[right-1];\n\t\t\t}else{\n\t\t\t\tlength[left][right] = L[right-1]-L[left-1];\n\t\t\t}\n\t\t}\n\t}\n\n\tint dp[N+1][N+1],ans = BIG_NUM;\n\n\tint min_length,value_1,value_2;\n\n\tfor(int min_range_left = 0; min_range_left <= N-1; min_range_left++){\n\t\tfor(int min_range_right = min_range_left+1; min_range_right <= N; min_range_right++){\n\n\t\t\tmin_length = length[min_range_left][min_range_right];\n\n\t\t\tif((min_range_left > 0 && min_length > length[0][min_range_left]) ||\n\t\t\t\t\t(min_range_right <= N-1 && min_length > length[min_range_right][N]))continue;\n\n\t\t\tvalue_1 = value_2 = 0;\n\n\t\t\tif(min_range_left > 0){\n\n\t\t\t\tfor(int left = 0; left <= min_range_left-1; left++){\n\t\t\t\t\tfor(int right = left+1; right <= min_range_left; right++)dp[left][right] = BIG_NUM;\n\t\t\t\t}\n\n\t\t\t\tfor(int len = 1; len <= min_range_left; len++){\n\t\t\t\t\tfor(int left = 0;left <= min_range_left-1; left++){\n\t\t\t\t\t\tint right = left+len;\n\t\t\t\t\t\tif(right > min_range_left)break;\n\n\t\t\t\t\t\tfor(int mid = left; mid <= right-1; mid++){\n\t\t\t\t\t\t\tif(mid == left){\n\t\t\t\t\t\t\t\tif(length[mid][right] >= min_length){\n\t\t\t\t\t\t\t\t\tdp[left][right] = min(dp[left][right],length[mid][right]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(dp[left][mid] != BIG_NUM && dp[mid][right] != BIG_NUM){\n\t\t\t\t\t\t\t\t\tdp[left][right] = min(dp[left][right],max(dp[left][mid],dp[mid][right]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvalue_1 = dp[0][min_range_left]-min_length;\n\t\t\t}\n\n\t\t\tif(min_range_right <= N-1){\n\n\t\t\t\tfor(int left = min_range_right; left <= N-1; left++){\n\t\t\t\t\tfor(int right = left+1; right <= N; right++)dp[left][right] = BIG_NUM;\n\t\t\t\t}\n\n\t\t\t\tfor(int len = 1; min_range_right+len <= N; len++){\n\t\t\t\t\tfor(int left = min_range_right;left <= N-1; left++){\n\t\t\t\t\t\tint right = left+len;\n\t\t\t\t\t\tif(right > N)break;\n\n\t\t\t\t\t\tfor(int mid = left; mid <= right-1; mid++){\n\t\t\t\t\t\t\tif(mid == left){\n\t\t\t\t\t\t\t\tif(length[mid][right] >= min_length){\n\t\t\t\t\t\t\t\t\tdp[left][right] = min(dp[left][right],length[mid][right]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(dp[left][mid] != BIG_NUM && dp[mid][right] != BIG_NUM){\n\t\t\t\t\t\t\t\t\tdp[left][right] = min(dp[left][right],max(dp[left][mid],dp[mid][right])); //分割した区間の大きい方\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalue_2 = dp[min_range_right][N]-min_length;\n\t\t\t}\n\t\t\tif(min_range_left != 0 || min_range_right != N){\n\t\t\t\tans = min(ans,max(value_1,value_2));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint max(int a, int b) {\n  return a > b ? a : b;\n}\n\nint main(void) {\n  int i, j, k, n, ans = 100000;\n  scanf(\"%d\", &n);\n  int l[n], sum = 0;\n  for(i = 0; i < n; ++i) {\n    scanf(\"%d\", &l[i]);\n    sum += l[i];\n  }\n  for(i = 1; i <= 1000; ++i) {\n    int dp[n];\n    for(j = 0; j < n; ++j) dp[j] = 1000000;\n    for(j = 0; j < n; ++j) if(!j || dp[j - 1] != 1000000) {\n      int now = 0;\n      for(k = j; k < n; ++k) {\n        now += l[k];\n        int tt;\n        if(!j) tt = 0;\n        else tt = dp[j - 1];\n        if(now >= i && dp[k] > max(now, tt)) dp[k] = max(now, tt); \n      }\n    }\n    if(dp[n - 1] != sum && ans > dp[n - 1] - i) ans = dp[n - 1] - i;\n    /*if(i == 17) {\n      for(j = 0; j < n; ++j) printf(\"%d \", dp[j]);\n     printf(\"\\n\");\n    }*/\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define PP std::pair<int,int>\nint N;\nint L[51];\nPP D[51][51];\nint res[51][51];\nint ans=1<<30;\nint main(){\n    std::cin>>N;\n    for(int i=1;i<=N;i++){\n        std::cin>>L[i];\n        L[i]+=L[i-1];\n    }\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            res[i][j]=1<<30;\n        }\n    }\n    for(int i=0;i<=N;i++){\n        D[i][1]={std::min(L[N]-L[i],L[i]),std::min(L[N]-L[i],L[i])};\n        ans=std::min(ans,std::abs(L[N]-L[i]-L[i]));\n    }\n    for(int i=1;i<=N;i++){\n        for(int j=2;j<=i;j++){\n            for(int k=j-1;k<i;k++){\n                int m=std::min({D[k][j-1].first,L[N]-L[i],L[i]-L[k]});\n                int M=std::max({D[k][j-1].second,L[N]-L[i],L[i]-L[k]});\n                if(res[i][j]>M-m){\n                    res[i][j]=M-m;\n                    ans=std::min(res[i][j],ans);\n                    int m=std::min(D[k][j-1].first,L[i]-L[k]);\n                    int M=std::max(D[k][j-1].second,L[i]-L[k]);\n                    D[i][j]={m,M};\n                }\n            }\n        }\n    }\n    std::cout<<ans<<std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst long double INF = (1e10);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll a[55],dp[55];\n\nint main(void){\n\tint n,i,j,l,r;\n\tll m,ans=INFLL;\n\tcin >> n;\n\tfor(i=0; i<n; ++i){\n\t\tcin >> a[i+1];\n\t\ta[i+1] += a[i];\n\t}\n\tfor(r=0; r<=n; ++r){\n\t\tfor(l=0; l<r; ++l){\n\t\t\tif(r==n&&l==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm = a[r]-a[l];\n\t\t\tfor(i=0; i<=n; ++i){\n\t\t\t\tdp[i] = (a[i]<m)?INFLL:a[i];\n\t\t\t\tif(i==n){\n\t\t\t\t\tdp[i] = INFLL;\n\t\t\t\t}\n\t\t\t\tfor(j=1; j<i; ++j){\n\t\t\t\t\tif(a[i]-a[j]<m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i] = min(dp[i],max(dp[j],a[i]-a[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(ans,dp[n]-m);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nint main() {\n    int n; cin >> n;\n    vector<int> l(n), sum(n + 1);\n    for(int i = 0; i < n; ++i) {\n        cin >> l[i];\n        sum[i + 1] = sum[i] + l[i];\n    }\n\n    const int max_l = n * 1000 + 1;\n    vector<vector<int>> dp(n + 1, vector<int>(max_l, inf));\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j < i; ++j) {\n            for(int mini_l = 0; mini_l < max_l; ++mini_l) {\n                const int nmin = min(mini_l, sum[i] - sum[j]);\n                const int nmax = max(dp[j][mini_l], sum[i] - sum[j]);\n                dp[i][nmin] = min(dp[i][nmin], nmax);\n            }\n        }\n        if(i != n) {\n            dp[i][sum[i]] = sum[i];\n        }\n    }\n\n    int ans = inf;\n    for(int i = 0; i < max_l; ++i) {\n        if(dp[n][i] == inf) continue;\n        ans = min(ans, dp[n][i] - i);\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define PP std::pair<int,int>\nint N;\nint L[50];\nPP D[51][51];\nint res[51][51];\nint ans=1<<30;\nint main(){\n    std::cin>>N;\n    for(int i=1;i<=N;i++){\n        std::cin>>L[i];\n        L[i]+=L[i-1];\n    }\n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            res[i][j]=1<<30;\n        }\n    }\n    for(int i=0;i<=N;i++){\n        D[i][1]={std::min(L[N]-L[i],L[i]),std::min(L[N]-L[i],L[i])};\n        ans=std::min(ans,std::abs(L[N]-L[i]-L[i]));\n    }\n    for(int i=1;i<=N;i++){\n        for(int j=2;j<=i;j++){\n            for(int k=j-1;k<i;k++){\n                int m=std::min({D[k][j-1].first,L[N]-L[i],L[i]-L[k]});\n                int M=std::max({D[k][j-1].second,L[N]-L[i],L[i]-L[k]});\n                if(res[i][j]>M-m){\n                    res[i][j]=M-m;\n                    ans=std::min(res[i][j],ans);\n                    int m=std::min(D[k][j-1].first,L[i]-L[k]);\n                    int M=std::max(D[k][j-1].second,L[i]-L[k]);\n                    D[i][j]={m,M};\n                }\n            }\n        }\n    }\n    std::cout<<ans<<std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tint L[N];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&L[i]);\n\t\tif(i > 0){\n\t\t\tL[i] += L[i-1];\n\t\t}\n\t}\n\n\tint length[N+1][N+1];\n\n\tfor(int left = 0; left <= N-1; left++){\n\t\tfor(int right = 1; right <= N; right++){\n\t\t\tif(left == 0){\n\t\t\t\tlength[left][right] = L[right-1];\n\t\t\t}else{\n\t\t\t\tlength[left][right] = L[right-1]-L[left-1];\n\t\t\t}\n\t\t}\n\t}\n\n\tint dp[N+1],ans = BIG_NUM;\n\n\tint min_length,value_1,value_2;\n\n\tfor(int min_range_left = 0; min_range_left <= N-1; min_range_left++){\n\t\tfor(int min_range_right = min_range_left+1; min_range_right <= N; min_range_right++){\n\n\t\t\tmin_length = length[min_range_left][min_range_right];\n\n\t\t\tif((min_range_left > 0 && min_length > length[0][min_range_left]) ||\n\t\t\t\t\t(min_range_right <= N-1 && min_length > length[min_range_right][N]))continue;\n\n\t\t\t\tvalue_1 = value_2 = 0;\n\n\t\t\tif(min_range_left > 0){\n\n\t\t\t\tfor(int right = 1; right <= min_range_left; right++)dp[right] = BIG_NUM;\n\n\t\t\t\tfor(int right = 1; right <= min_range_left; right++){\n\t\t\t\t\tdp[right] = length[0][right];\n\n\t\t\t\t\tif(length[0][right] < min_length)continue;\n\n\t\t\t\t\tfor(int mid = 1; mid <= right-1; mid++){\n\t\t\t\t\t\tif(length[0][mid] < min_length || length[mid][right] < min_length)continue;\n\t\t\t\t\t\tdp[right] = min(dp[right],max(dp[mid],length[mid][right]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvalue_1 = dp[min_range_left]-min_length;\n\t\t\t}\n\n\t\t\tif(min_range_right <= N-1){\n\n\t\t\t\tfor(int right = min_range_right+1; right <= N; right++)dp[right] = BIG_NUM;\n\n\n\t\t\t\tfor(int right = 1; right <= N; right++){\n\t\t\t\t\tdp[right] = length[min_range_right][right];\n\n\t\t\t\t\tif(length[min_range_right][right] < min_length)continue;\n\n\t\t\t\t\tfor(int mid = 1; mid <= right-1; mid++){\n\t\t\t\t\t\tif(length[min_range_right][mid] < min_length || length[mid][right] < min_length)continue;\n\t\t\t\t\t\tdp[right] = min(dp[right],max(dp[mid],length[mid][right]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvalue_2 = dp[N]-min_length;\n\t\t\t}\n\t\t\tif(min_range_left != 0 || min_range_right != N){\n\t\t\t\tans = min(ans,max(value_1,value_2));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[55][50005], mon;\nint main() {\n\tint n, k[55], ans = 99999;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> k[i];\n\t}\n\tfor (int i = 0; i < 51; ++i) {\n\t\tfor (int j = 0; j < 50001; ++j) {\n\t\t\tdp[i][j] = 99999;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tmon += k[i];\n\t\tif (i + 1 < n) {\n\t\t\tdp[i + 1][mon] = mon;\n\t\t}\n\t\tfor (int j = 50000; j >= 0; --j) {\n\t\t\tif (dp[i][j] == 99999) continue;\n\t\t\tint monn = 0;\n\t\t\tfor (int kk = i; kk < n; ++kk) {\n\t\t\t\tmonn += k[kk];\n\t\t\t\tdp[kk + 1][min(monn, j)] = min(dp[kk + 1][min(monn, j)], max(dp[i][j], monn));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 50001; ++i) {\n\t\tans = min(ans, dp[n][i] - i);\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\ntypedef pair<long long int, long long int> P;\n\nint main(){\n\t\n\tint N, L[100];\n\t\n\tcin >> N;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> L[i];\n\t}\n\t\n\tvector<int> v;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tint S = 0;\n\t\tfor(int j = i; j < N; j++){\n\t\t\tS += L[j];\n\t\t\tv.push_back(S);\n\t\t}\n\t}\n\t\n\tsort(v.begin(), v.end());\n\tv.pop_back();\n\t\n\tint ans = 100000;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tint DP[60] = {};\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tDP[j] = 100000;\n\t\t}\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tint S = 0;\n\t\t\tfor(int k = j; k < N; k++){\n\t\t\t\tif(j == 0 && k == N - 1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tS += L[k];\n\t\t\t\tif(S >= v[i]){\n\t\t\t\t\tDP[k + 1] = min(max(DP[j], S), DP[k + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = min(ans, DP[N] - v[i]);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nTimeLimit:8sec,Memory Limit:Limit:262144KB,isSolved:-\n水ようかん(Mizuyoukan)\n<問題文>\n水ようかんとは，おもに小豆からなる餡を型に流し込んで寒天で固めることにより作られる和菓子である．\nいま，JOI 君の手元には，横長の直方体の形をした水ようかんがひとつある．\nJOI 君は，今日のおやつとしてこの水ようかんを食べる予定である．\nこの水ようかんには，縦方向の切れ目が全部で N−1 箇所に入っている．水ようかんの長さは \nL1+L2+…+LN であり，i 番目 (1≦i≦N−1) の切れ目は，左から L1+L2+…+Li の位置にある．\nこの水ようかんは丸ごと食べるには大きすぎるので，\nJOI 君は，水ようかんに入っている切れ目から 1 箇所以上を選び，\n選んだ切れ目に沿って水ようかんを切って，複数のピースに切り分けることにした．\nただし，ピースの大きさが不揃いでは見栄えが悪いので，\n長さ最大のピースと最小のピースの長さの差ができるだけ小さくなるように切ることにした．\n長さ最大のピースと最小のピースの長さの差の最小値を求めよ．\n<制約>\n2≤N≤50\n1≤Li≤1000(1≤i≤N)\n<入力>\n入力は以下の形式で標準入力から与えられる．\nN\nL1\nL2\n:\nLN\n<出力>\n長さ最大のピースと最小のピースの長さの差の最小値を 1 行で出力せよ．\n*/\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int INF=(int)1e9;\nint solve(const int low,const vector<int>& ls)\n{\n\tconst int n=ls.size();\n\tvector<int> dp(n+1);\n\tdp[0]=low;\n\tfor(int position=0;position<n;position++){\n\t\tint piece_length=0;\n\t\tint& value=dp[position+1];\n\t\tvalue=INF;\n\t\tfor(int piece_left=position;piece_left>=0;piece_left--){\n\t\t\tpiece_length+=ls[piece_left];\n\t\t\tif(position==n-1&&piece_left==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(piece_length>=low){\n\t\t\t\tconst int high=max(piece_length,dp[piece_left]);\n\t\t\t\tvalue=min(value,high);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n]-low;\n}\nint main(void)\n{\n\tint n;\n\tvector<int> ls;\n\tcin>>n;\n\tls.resize(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>ls[i];\n\t}\n\tint answer=INF;\n\tfor(int left=0;left<n;left++){\n\t\tint total_length=0;\n\t\tfor(int right=left;right<n;right++){\n\t\t\ttotal_length+=ls[right];\n\t\t\tint temp=solve(total_length,ls);\n\t\t\tanswer=min(answer,temp);\n\t\t}\n\t}\n\tcout<<answer<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint L[50];\n\nint calc(int k){\n  int maxm=0;\n  int mini=1e9;\n  int sum=0;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    sum+=L[i];\n    if(sum>=k){\n      cnt++;\n      maxm=max(maxm,sum);\n      mini=min(mini,sum);\n      sum=0;\n    }\n  }\n  if(sum>0){\n    cnt++;\n    maxm=max(maxm,sum);\n    mini=min(mini,sum);\n  }\n  if(cnt>1){\n    return maxm-mini;\n  }else{\n    return 1e9;\n  }\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>L[i];\n  }\n  int ans=1e9;\n  for(int i=1;i<=50000;i++){\n    ans=min(ans,calc(i));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint L[55];\nint sum[55];\n\nint search(int MIN){\n\tint dp[55];\n\tmemset(dp,-1,sizeof(dp));\n\n\tfor (int i = 1;i <= n;i++){\n\t\tint next = INT_MAX;\n\t\tfor (int j = i-1;j >= 0;j--){\n\t\t\tint a = sum[i]-sum[j];\n\t\t\tif(a >= MIN && (dp[j] != -1 || j == 0)){\n\t\t\t\tif(i == n && j == 0) continue;\n\t\t\t\tnext = min(next,max(dp[j],a));\n\t\t\t}\n\t\t}\n\t\tdp[i] = next;\n\t}\n\treturn dp[n]-MIN;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n;\n\n\tsum[0] = 0;\n\tfor (int i = 0;i < n;i++){\n\t\tcin >> L[i];\n\t\tsum[i+1] = sum[i]+L[i];\n\t}\n\n\tint ans = INT_MAX;\n\tfor (int i = 0;i < n;i++){\n\t\tfor (int j = i+1;j <= n;j++){\n\t\t\tans = min(ans,search(sum[j]-sum[i]));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//y18-4 水ようかん(最大値の最小値→最小値固定)X\n#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#include <boost/multiprecision/cpp_int.hpp>\nnamespace boost_multiprecision = boost::multiprecision;\n#define LL long long\n#define CINT boost_multiprecision::cpp_int\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define segment_size 65536\n#define ROOP() while (true)\n\nint N;\nvector<int> L;\nvector<int> Lsum;\nint sum = 0;\n\nint dp[50005][51];\n\nint solve(int m, int now, int c){//最大値の最小値を求める\n    if(now == N && c > 0) return INT_MIN;\n    if(now == N) return INT_MAX;\n    if(dp[m][now] != INT_MAX) return dp[m][now];\n    int re = INT_MAX-1;\n    for(int i = now; i<N; i++){\n        if(Lsum[i+1]-Lsum[now] >= m && Lsum[i+1]-Lsum[now] < sum)\n            re = min(re, max(solve(m, i+1, c+1), Lsum[i+1]-Lsum[now]));\n    }\n    dp[m][now] = re;\n    return re;\n}\n\nint main(){\n    cin >> N;\n\n    int maximum = INT_MIN;\n    int minium = INT_MAX;\n    \n    Lsum.push_back(0);\n    for(int i=0; i<N; i++){\n        int l;\n        cin >> l;\n        L.push_back(l);\n        sum += l;\n        Lsum.push_back(sum);\n        maximum = max(maximum,l);\n        minium = min(minium,l);\n    }\n\n    for(int i=0; i<sum+1; i++){\n        for(int j=0; j<N; j++){\n            dp[i][j] = INT_MAX;\n        }\n    }\n\n    int ans = INT_MAX;\n    for(int i=minium; i<sum; i++){\n        ans = min(ans, solve(i, 0, 0) - i);\n        //cout << i << \" \" << solve(i, 0, 0) << endl;\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    int n;\n    cin >>n;\n    vector<int> l(n);\n    rep(i,n) cin >>l[i];\n\n    int s = 0;\n    rep(i,n) s += l[i];\n\n    int ans = 10101010;\n\n    for(int lb=1; lb<=s; ++lb){\n\n        int mn = s, mx = 0;\n\n        int c = 0;\n        int cut = 0;\n        rep(i,n){\n            c += l[i];\n\n            if(c>=lb){\n                mn = min(mn,c);\n                mx = max(mx,c);\n                c = 0;\n                if(i<n-1) ++cut;\n            }\n        }\n\n        if(c==0 && cut) ans = min(ans, mx-mn);\n    }\n    assert(ans>=0);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint sumin(vector<int>::iterator begin, vector<int>::iterator end)\n{\n    ++end;\n    return accumulate(begin, end, 0);\n}\nint main()\n{\n    //宣言\n    vector<int> input;    //入力されたデータ配列\n    int elementCount = 0; //要素数\n    int sum = 0;          //母集団の合計\n    int i = 0;\n    //要素数の入力\n    //cout << \"elementCount : \";\n    cin >> elementCount;\n    //要素の入力\n    for (int tmp, i = 0; i < elementCount; i++)\n    {\n        //cout << \"element No.\" << i + 1 << \" : \";\n        cin >> tmp;\n        sum += tmp;\n        input.push_back(tmp);\n    }\n    //各グループの最大値\n    int maxValue = *max_element(input.begin(), input.end());\n\n    vector<int>::iterator groupBegin = input.begin();\n    vector<int>::iterator groupEnd = input.begin();\n    vector<int>::iterator nextGroupBegin = input.begin();\n    int groupSum = 0;\n    int thresholdMax = 0;\n    int thresholdMin = sum;\n    int ans = sum;\n    int flag = 0;\n    vector<int>::iterator lastElement = input.end();\n    --lastElement;\n    //求める値に関する処理\n    while (maxValue < sum)\n    {\n        //cout << \"START : search sikiichi : \" << maxValue << endl;\n        //各閾値ごとの初期化処理\n        groupBegin = input.begin();\n        groupEnd = input.begin();\n        nextGroupBegin = input.begin();\n        thresholdMax = 0;\n        thresholdMin = sum;\n        flag = 0;\n        while (flag != 2 && flag != 4)\n        {\n            //各グループごとの初期化処理\n            groupBegin = nextGroupBegin;\n            groupEnd = groupBegin;\n            //cout << \"      START : search group start at: \" << *groupBegin << endl;\n            while (sumin(groupBegin, groupEnd) < maxValue)\n            {\n                //グループ内の総和が最大値を超えない場合\n                if (groupEnd != lastElement)\n                {\n                    //cout << \"            group Extended | group end at: \" << *groupEnd ;\n                    //端に到達していないので、グループの範囲を1個広げる\n                    ++groupEnd;\n                    //cout << \" -> \"<<*groupEnd<<endl;\n                    flag = 1;\n                }\n                else\n                {\n                    //グループ完成\n                    //端に到達しているので、この閾値での調査完了\n                    groupSum = sumin(groupBegin, groupEnd);\n                    flag = 2;\n                    //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n                    break;\n                }\n            }\n            if (sumin(groupBegin, groupEnd) == maxValue)\n            {\n                //グループ内の総和が最大値と一致する場合\n                if (groupEnd != lastElement)\n                {\n                    //グループ完成\n                    //端に達していないので、次のグループ用にはじめを設定\n                    groupSum = sumin(groupBegin, groupEnd);\n                    ++groupEnd;\n                    nextGroupBegin = groupEnd;\n                    flag = 3;\n                    --groupEnd;\n                    //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n                }\n                else\n                {\n                    //グループ完成\n                    //端に達しているので、この閾値で調査完了\n                    groupSum = sumin(groupBegin, groupEnd);\n                    flag = 4;\n                    //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n                }\n            }\n            if (sumin(groupBegin, groupEnd) > maxValue)\n            {\n                //グループ内の総和が最大値を超えた場合\n                //グループ完成\n                //次のグループ用にはじめを設定\n                --groupEnd;\n                groupSum = sumin(groupBegin, groupEnd);\n                ++groupEnd;\n                nextGroupBegin = groupEnd;\n                flag = 5;\n                --groupEnd;\n                //cout << \"            group complete | group end at: \" << *groupEnd << \" flag : \" << flag << endl;\n            }\n            //グループごとの終了処理\n            if (groupSum > thresholdMax)\n            {\n                thresholdMax = groupSum;\n            }\n            if (groupSum < thresholdMin)\n            {\n                thresholdMin = groupSum;\n            }\n        }\n        //閾値ごとの終了処理\n        //cout << \"END : search sikiichi : \" << maxValue << \" , \"\n        //     << \"RESULT : \" << thresholdMax - thresholdMin << endl;\n        if (thresholdMax - thresholdMin < ans)\n        {\n            ans = thresholdMax - thresholdMin;\n        }\n        maxValue++;\n    }\n    cout << ans << endl;\n    //cin >> i;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\n#define NMAX 51\n#define INF (1<<30)\n\nint N;\nint TL[NMAX];// 左端から切れ目までの長さ\n\n// 最小のピース長 lmin に対する適切な最大のピース長を動的計画法で求める\nint lmax(int lmin){\n  //  cout << \"lmin = \" << lmin << endl;\n  int dp[NMAX];// i 番目の切れ目まで考えるときの適切な最大のピース長\n  dp[0]=0;\n\n  for(int i=1;i<=N;i++){ // ピースの右端\n    //    cout << \"i = \" << i << endl;\n    dp[i]=INF;\n    for(int j=0;j<i;j++){ // ピースの左端\n      if(i==N && j==0) continue;// 最低でも1箇所はカットする\n      //      cout << \"(\" << j << \",\" << i << \") \"; \n      int lpiece=TL[i]-TL[j]; // ピースの長さ\n      //      cout << \"lpiece = \" << lpiece << endl;\n      if(lpiece >= lmin)\n\tdp[i]=min( max(lpiece,dp[j]) ,dp[i]);\n      //      cout << \" dp[\" << i << \"] = \" << dp[i];\n    }\n    //    cout << endl;\n  }\n  return dp[N];\n}\n\nint main(){\n  cin >> N;\n  TL[0]=0;\n  for(int i=1;i<=N;i++){\n    int l;\n    cin >> l;\n    TL[i]=TL[i-1]+l; // 左端から切れ目までの長さ\n  }\n\n  int ans=INF;\n  for(int i=0;i<N;i++){// left of minimum piece\n    for(int j=i+1;j<=N;j++){// right of minimum piece\n      if(i==0 && j==N) continue;\n      int lmin=TL[j]-TL[i];// length of minimum piece\n      ans = min( lmax(lmin)-lmin ,ans);\n      //      cout << \"ans = \" << ans << endl;\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int N;\n  cin >> N;\n  vector<int> L(N);\n  for(int i = 0; i < N; ++i) cin >> L[i];\n  vector<int> Lsum(N+1, 0);\n  for(int i = 0; i < N; ++i) Lsum[i+1] = Lsum[i]+L[i];\n  vector<vector<int> > dp(N+1, vector<int>(Lsum[N]+1, -1));\n  dp[0][0] = INT_MAX;\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j <= i; ++j) {\n      int len = Lsum[i+1]-Lsum[j];\n      for(int k = 0; k < Lsum[N]; ++k) {\n\tif(dp[j][k] == -1) continue;\n\tint idx = max(k, len);\n\tdp[i+1][idx] = max(dp[i+1][idx], min(dp[j][k], len));\n      }\n    }\n  }\n  int ans = *max_element(L.begin(), L.end())-*min_element(L.begin(), L.end());\n  for(int i = 0; i < Lsum[N]; ++i) {\n    if(~dp[N][i]) ans = min(ans, i-dp[N][i]);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 2018/12/19 Tazoe\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint DFS(int m[50], int n, int bef)\n{\n\tint max_m = m[0];\n\tint min_m = m[0];\n\n\tfor(int i=1; i<n; i++){\n\t\tmax_m = max(max_m, m[i]);\n\t\tmin_m = min(min_m, m[i]);\n\t}\n\n\tint dif = min(bef, max_m-min_m);\n\n\n\tif(dif==0)\n\t\treturn 0;\n\n\tif(n==2)\n\t\treturn dif;\n\n\n\tint dif2 = dif;\n\n\tfor(int i=0; i<n-1; i++){\n\t\tint t[50];\n\t\tfor(int j=0; j<i; j++)  t[j] = m[j];\n\t\tt[i] = m[i]+m[i+1];\n\t\tfor(int j=i+1; j<n-1; j++)  t[j] = m[j+1];\n\n\t\tdif2 = min(dif2, DFS(t, n-1, dif));\n\t}\n\n\treturn dif2;\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\n\tint L[50];\n\tfor(int i=0; i<N; i++){\n\t\tcin >> L[i];\n\t}\n\n\tcout << DFS(L, N, 1000) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NSIZE 50\n#define INFTY (1<<21)\n\nvoid initW(int (*W)[NSIZE], int N, int *L)\n{\n  int i, j, weight;\n\n  for (i = 0; i < N; i++)\n  {\n    weight = 0;\n    for (j = i; j < N; j++)\n    {\n      weight += L[j];\n      W[i][j] = weight;\n    }\n  }\n}\n\nvoid calc(int *A, int (*W)[NSIZE], int N, int index, int count, int *ans)\n{\n  int i, diff;\n  for (i = index; i < N; i++)\n  {\n    A[count] = i;\n    calc(A, W, N, i + 1, count + 1, ans);\n    diff = getDiff(A, W, N, count);\n    if (diff < *ans) *ans = diff;\n  }  \n}\n\nint getDiff(int *A, int(*W)[NSIZE], int N, int count)\n{\n  int min, max, start, end, i, weight;\n\n  min = INFTY;\n  max = min * (-1);\n\n  A[++count] = N;\n\n  end = 0;\n  for (i = 0; i <= count; i++)\n  {\n    start = end;\n    end = A[i];\n    weight = W[start][end-1];\n    if (weight < min)\n    {\n      min = weight;\n    }\n    if (weight > max)\n    {\n      max = weight;\n    }\n  }\n  return max - min;\n}\n\nint main()\n{\n  int i, N, ans;\n  int L[NSIZE];\n  int W[NSIZE][NSIZE];\n  int A[NSIZE + 1];\n\n  scanf(\"%d\", &N);\n\n  for (i = 0; i < N; i++)\n  {\n    scanf(\"%d\", &L[i]);\n  }\n\n  initW(W,N,L);\n\n  ans = INFTY;\n  calc(A, W, N, 1, 0, &ans);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0644 Mizuyokan\n// 2018.3.30 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\t/* 整数値の入力 */\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define INF 0x10101010\nint  L[53];\nint dp[53];\n\nint main()\n{\n\tint N, i, j, k, lo, hi, w, ans;\n\n\tN = in();\n\tfor (i = 0; i < N; i++) L[i] = in();\n\n\tans = 1000;\n\tfor (lo = 0; lo < N; lo++) {\n\t\tw = 0;\n\t\tfor (hi = lo; hi < N; hi++) {\n\t\t\tw += L[hi];\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\tdp[0] = w;\n\t\t\tfor (i = 0; i < N; i++) {\n\t\t\t\tk = 0;\n\t\t\t\tdp[i+1] = INF;\n\t\t\t\tfor (j = i; j >= 0; j--) {\n\t\t\t\t\tk += L[j];\n\t\t\t\t\tif (i == N-1 && j == 0) continue;\n\t\t\t\t\tif (k >= w) {\n\t\t\t\t\t\tint x = dp[j]; if (x < k) x = k;\n\t\t\t\t\t\tif (dp[i+1] > x) dp[i+1] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp[N]-w < ans) ans = dp[N]-w;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint N;\nint L[64];\n\nint ruiseki[64];\n\nint sedai;\nint saisyou;\nint target;\nint visited[64];\n\nint dekiru(int idx) {\n\tint i;\n\tif (idx >= N) return 1;\n\tif (visited[idx] >= sedai) return visited[idx] & 1;\n\tfor (i = idx + 1; i <= N; i++) {\n\t\tint len = ruiseki[i] - ruiseki[idx];\n\t\tif (len < saisyou) continue;\n\t\tif (saisyou + target < len) break;\n\t\tif (dekiru(i)) {\n\t\t\tvisited[idx] = sedai + 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tvisited[idx] = sedai;\n\treturn 0;\n}\n\nint dekirukana(void) {\n\tint i, j, k;\n\t/* doko wo saisyou ni suru ka tansaku */\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tsaisyou = ruiseki[j] - ruiseki[i];\n\t\t\t/* toriaezu kiru */\n\t\t\tfor (k = 1; k < N; k++) {\n\t\t\t\tint len = ruiseki[k] - ruiseki[0];\n\t\t\t\tif (len < saisyou) continue;\n\t\t\t\tif (saisyou + target < len) break;\n\t\t\t\tsedai += 2;\n\t\t\t\tif (dekiru(k)) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tint i;\n\tif (scanf(\"%d\", &N) != 1) return 1;\n\tfor (i = 1; i <= N; i++) {\n\t\tif (scanf(\"%d\", &L[i]) != 1) return 1;\n\t\truiseki[i] = ruiseki[i - 1] + L[i];\n\t}\n\ttarget = 0;\n\tif (dekirukana()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tint ng = 0, ok = 1000;\n\t\twhile (ng + 1 < ok) {\n\t\t\tint mid = ng + (ok - ng) / 2;\n\t\t\ttarget = mid;\n\t\t\tif (dekirukana()) ok = mid; else ng = mid;\n\t\t}\n\t\tprintf(\"%d\\n\", ok);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "\nfun canMakePeaces(l: Int, minLimit:Int, maxLimit:Int, peaceSizes:Array<IntArray>, memo: Array<Boolean?>): Boolean {\n    return when{\n        l >= memo.size -> true\n        memo[l] != null -> memo[l]!!\n        else -> {\n            var i = l\n            while (i < memo.size && peaceSizes[l][i - l] < minLimit) ++i\n            memo[l] = if (i == memo.size) false\n            else {\n                var res = false\n                while (i < memo.size && peaceSizes[l][i - l] <= maxLimit && !res){\n                    res = canMakePeaces(++i, minLimit, maxLimit, peaceSizes, memo)\n                }\n                (i - l < memo.size) && res\n            }\n            memo[l]!!\n        }\n    }\n}\nfun minDiff(minLimit: Int, peaceSizes: Array<IntArray>, memo: Array<Boolean?>, currentMin: Int = Int.MAX_VALUE): Int {\n    var left = minLimit\n    var right = if (currentMin != Int.MAX_VALUE) minLimit + currentMin else peaceSizes[0].last()\n    while (left < right){\n        val mid = (left + right) / 2\n        memo.fill(null)\n        if (canMakePeaces(0, minLimit, mid, peaceSizes, memo)) {\n            right = mid\n        }else {\n            left = mid + 1\n        }\n    }\n    return right - minLimit\n}\nfun main(args:Array<String>){\n    val n = readLine()!!.toInt()\n    val lines = IntArray(n){readLine()!!.toInt()}\n    val peaceSizes = Array(n){l -> IntArray(n - l){r -> lines[l + r]}.also{\n        for (i in 1 until it.size){\n            it[i] += it[i - 1]\n        }\n    }}\n    val memo = Array(n){null as Boolean?}\n    var min = Int.MAX_VALUE\n    for (i in 0 until n) for (j in i until n){\n        if (i != 0 || j != n - 1) {\n            val temp = minDiff(peaceSizes[i][j - i], peaceSizes, memo, min)\n            if (min > temp) min = temp\n        }\n    }\n    println(min)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjastment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\tboolean flag = true;\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(flag) {\n\t\t\t\t\t\tnumber -= adjastment;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnumber += adjastment;\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjastment = number - floor;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjastment = ceiling - number;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, k, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box = 0, floor = 0, ceiling = 0, adjustment_sum = 0;\n\t\tint[] a = new int[51];\n\t\tdouble[] adjustment = new double[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tfor(k = 1; k < j; k++) {\n\t\t\t\t\t\tadjustment_sum += adjustment[k] / (j - k + 1);\n\t\t\t\t\t}\n\t\t\t\t\tnumber += adjustment_sum;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment[j] = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment[j] = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box = 0, floor = 0, ceiling = 0;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment / i;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment += floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment += ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment += (floor - number) / (i - 1);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment += (ceiling - number) / (i - 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, sum = 0, subsum = 0, floor = 0, ceiling = 0, number = 0, nearestPrime, max, min, box, calcu;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Integer> ts = new TreeSet<Integer>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tnearestPrime = number - floor <= ceiling - number ? floor : ceiling;\n\t\t\t\t\tcalcu = nearestPrime - box;\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, sum = 0, subsum = 0, floor, ceiling, number = 0, nearestPrime, max, min, box, calcu;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Integer> ts = new TreeSet<Integer>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(i = 2; i < n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tnearestPrime = number - floor <= ceiling - number ? floor : ceiling;\n\t\t\t\t\tcalcu = nearestPrime - box;\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box = 0, floor = 0, ceiling = 0, adjust;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjust = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjust / (j / i);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjust = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjust = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\t//number += adjustment / (i - 1);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment += floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment += ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box = 0, floor = 0, ceiling = 0, adjust;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjust = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjust / (i - 1);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjust = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjust = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment / (i - 1);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment += floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment += ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, sum = 0, subsum = 0, floor, ceiling, number = 0, nearestPrime, max, min, box, calcu;\n\t\tint[] a = new int[10];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Integer> ts = new TreeSet<Integer>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(i = 2; i < n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tnearestPrime = number - floor <= ceiling - number ? floor : ceiling;\n\t\t\t\t\tcalcu = nearestPrime - box;\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, sum = 0, subsum = 0, floor = 0, ceiling = 0, number = 0, nearestPrime, max, min, box, calcu;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Integer> ts = new TreeSet<Integer>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tnearestPrime = number - floor <= ceiling - number ? floor : ceiling;\n\t\t\t\t\tcalcu = nearestPrime - box;\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment / (i - 1);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment / (i - 1);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment += floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment += ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, k, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box = 0, floor = 0, ceiling = 0, adjustment_sum = 0;\n\t\tint[] a = new int[51];\n\t\tdouble[] adjustment = new double[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment_sum = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tfor(k = 1; k < j; k++) {\n\t\t\t\t\t\tadjustment_sum += adjustment[k] / (j - k + 1);\n\t\t\t\t\t}\n\t\t\t\t\tnumber += adjustment_sum;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment[j] = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment[j] = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjastment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tadjastment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjastment / (i - 1);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjastment += floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjastment += ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjastment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\tboolean flag = true;\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(flag) {\n\t\t\t\t\t\tnumber -= adjastment / i;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnumber += adjastment / i;\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjastment = number - floor;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjastment = ceiling - number;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment;\n\t\t\t\t\tSystem.out.println(adjustment);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment += (floor - number) / (i - 1);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment += (ceiling - number) / (i - 1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box = 0, floor = 0, ceiling = 0;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\t\n\t\tint sum = 0;\n\t\tint l[] = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tl[i] = sc.nextInt();\n\t\t\tsum += l[i];\n\t\t}\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int left = 0; left < n; left++) {\n\t\t\tint low = 0;\n\t\t\tfor(int right = left; right < n; right++) {\n\t\t\t\tlow += l[right];\n\t\t\t\tint[] dp = new int[n + 1];\n\t\t\t\tdp[0] = low;\n\t\t\t\t\n\t\t\t\tfor(int position = 0; position < n; position++) {\n\t\t\t\t\tint length = 0;\n\t\t\t\t\tdp[position + 1] = Integer.MAX_VALUE;\n\t\t\t\t\t\n\t\t\t\t\tfor(int le = position; le >= 0; le--) {\n\t\t\t\t\t\tlength += l[le];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(position == n - 1 && le == 0) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(length >= low) dp[position + 1] = Math.min(dp[position + 1], Math.max(length, dp[le ]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans = Math.min(ans, dp[n] - low);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjastment, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\tboolean flag;\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n//\t\t\t\t\t\tadjastment = number - floor;\n//\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n//\t\t\t\t\t\tadjastment = ceiling - number;\n//\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box = 0, floor = 0, ceiling = 0, adjust;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjust = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjust / (j / i);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjust = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjust = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment / (i - 1);\n\t\t\t\t\tSystem.out.println(adjustment);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment / i;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment += floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment += ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjastment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\tboolean flag = true;\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(flag) {\n\t\t\t\t\t\tnumber -= adjastment / (i - 1);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnumber += adjastment / (i - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjastment = number - floor;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjastment = ceiling - number;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, k, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box = 0, floor = 0, ceiling = 0, adjustment_sum = 0;\n\t\tint[] a = new int[51];\n\t\tdouble[] adjustment = new double[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tfor(k = 1; k < j; k++) {\n\t\t\t\t\t\tadjustment_sum += adjustment[k] / (k + 1);\n\t\t\t\t\t}\n\t\t\t\t\tnumber += adjustment_sum;\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment[j] = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment[j] = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjastment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\tboolean flag = true;\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tadjastment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(flag) {\n\t\t\t\t\t\tnumber -= adjastment / (i - 1);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnumber += adjastment / (i - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjastment = number - floor;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjastment = ceiling - number;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjastment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\tboolean flag = true;\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(flag) {\n\t\t\t\t\t\tnumber -= adjastment / j;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnumber += adjastment / j;\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjastment = number - floor;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjastment = ceiling - number;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjastment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\tboolean flag = true;\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(flag) {\n\t\t\t\t\t\tnumber -= adjastment / i;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnumber += adjastment / i;\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjastment = number - floor;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjastment = ceiling - number;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjastment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\tboolean flag = true;\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 1000;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tif(flag) {\n\t\t\t\t\t\tnumber -= adjastment / (i - 1);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnumber += adjastment / (i - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjastment = number - floor;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjastment = ceiling - number;\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 1000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment / (i - 1);\n\t\t\t\t\tSystem.out.println(adjustment);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment += floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment += ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box = 0, floor = 0, ceiling = 0, adjust;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjust = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjust / (j / i);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjust = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjust = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class JOI_0644 {\n\tpublic static void main(String[] args){\n\t\tint n, i, j, max, min, calcu;\n\t\tdouble sum = 0, subsum = 0, number = 0, nearestPrime, box, adjustment = 0, floor = 0, ceiling = 0 ;\n\t\tint[] a = new int[51];\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tn = sc.nextInt();\n\t\t\tTreeSet<Double> ts = new TreeSet<Double>();\n\t\t\tfor(i = 0; i < n; i++) {\n\t\t\t\tsum += sc.nextInt();\n\t\t\t\tts.add(sum);\n\t\t\t}\n\t\t\tloop : for(i = 2; i <= n; i++) {\n\t\t\t\tsubsum = sum;\n\t\t\t\tnearestPrime = 0;\n\t\t\t\tmax = 0;\n\t\t\t\tmin = 50000;\n\t\t\t\tadjustment = 0;\n\t\t\t\tfor(j = 1; j < i; j++) {\n\t\t\t\t\tnumber = sum * j / i;\n\t\t\t\t\tnumber += adjustment / (i - 1);\n\t\t\t\t\tSystem.out.println(adjustment);\n\t\t\t\t\tif(ts.ceiling(number) != null && ts.floor(number) != null) {\n\t\t\t\t\t\tceiling = ts.ceiling(number);\n\t\t\t\t\t\tfloor = ts.floor(number);\n\t\t\t\t\t}else {\n\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t}\n\t\t\t\t\tbox = nearestPrime;\n\t\t\t\t\tif(number - floor <= ceiling - number) {\n\t\t\t\t\t\tnearestPrime = floor;\n\t\t\t\t\t\tadjustment = floor - number;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tnearestPrime = ceiling;\n\t\t\t\t\t\tadjustment = ceiling - number;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcalcu = (int) (nearestPrime - box);\n\t\t\t\t\tif(max < calcu) {\n\t\t\t\t\t\tmax = calcu;\n\t\t\t\t\t}\n\t\t\t\t\tif(min > calcu) {\n\t\t\t\t\t\tmin = calcu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubsum = sum - nearestPrime;\n\t\t\t\tif(max < subsum) {\n\t\t\t\t\tmax = (int) subsum;\n\t\t\t\t}\n\t\t\t\tif(min > subsum) {\n\t\t\t\t\tmin = (int) subsum;\n\t\t\t\t}\n\t\t\t\ta[i] = max - min;\n\t\t\t}\n\t\t\tmin = 50000;\n\t\t\tfor(j = 2; j < i; j++) {\n\t\t\t\tif(min > a[j]) {\n\t\t\t\t\tmin = a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace _0644\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tint n = int.Parse(Console.ReadLine());\n\t\t\tint[] sum = new int[n + 1];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tsum[i + 1] = sum[i] + int.Parse(Console.ReadLine());\n\t\t\t}\n\t\t\tint[,] dp = new int[n + 1, 50001];//value is max length\n\t\t\tfor (int i = 1; i <= 50000; i++) dp[0, i] = 1145141919;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= 50000; j++) dp[i, j] = 1145141919;\n\t\t\t\tdp[i, sum[i]] = sum[i];\n\t\t\t\tfor (int j = i - 1; j >= 0; j--)\n\t\t\t\t{\n\t\t\t\t\tint len = sum[i] - sum[j];\n\t\t\t\t\tfor (int k = 0; k <= 50000; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i, Math.Min(k, len)] = Math.Min(dp[i, Math.Min(k, len)], Math.Max(dp[j, k], len));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret = int.MaxValue;\n\t\t\tfor (int i = 0; i < sum[n]; i++) ret = Math.Min(ret, dp[n, i] - i);\n\t\t\tConsole.WriteLine(ret);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass quiz\n{\n    public int solve(int N, int[] L)\n    {\n        int[] Lprime = new int[N];\n        int length;\n\n        Lprime[0] = L[0];\n\n        for (int i = 1; i < N; i++)\n        {\n            Lprime[i] = L[i] + Lprime[i - 1];\n        }\n\n        length = Lprime[N - 1];\n        int[,] dp = new int[N + 1, length + 1];\n\n        for (int i = 0; i < N + 1; i++)\n        {\n            for (int j = 0; j < length + 1; j++)\n            {\n                dp[i, j] = -1;\n            }\n        }\n\n        for (int i = 0; i <= Lprime[0]; i++)\n        {\n            dp[1, i] = Lprime[0] - i;\n        }\n\n        for (int i = 1; i <= N; i++)\n        {\n            for (int j = 0; j <= Lprime[i - 1]; j++)\n            {\n                for (int k = 1; k < i; k++)\n                {\n                    if (dp[k, j] >= 0)\n                    {\n                        if (Lprime[i - 1] >= Lprime[k - 1] + j)\n                        {\n                            if (dp[i, j] >= 0)\n                                dp[i, j] = Math.Min(dp[i, j], Math.Max(dp[k, j], Lprime[i - 1] - Lprime[k - 1] - j));\n                            else\n                                dp[i, j] = Math.Max(dp[k, j], Lprime[i - 1] - Lprime[k - 1] - j);\n                        }\n                        else if(i<N)\n                        {\n                            if (dp[i, j] >= 0)\n                                dp[i, j] = Math.Min(dp[i, j], dp[k, j] + Lprime[i - 1] - Lprime[k - 1]);\n                            else\n                                dp[i, j] = dp[k, j] + Lprime[i - 1] - Lprime[k - 1];\n                        }\n                        //\n                        //else必要？\n                        //\n                    }\n                    else if(i < N)\n                    {\n                        dp[i, j] = Lprime[i - 1] - j;\n                    }\n                    //\n                    //もしかしてここ？\n                    //\n                }\n            }\n        }\n\n        int ans = int.MaxValue;\n\n        for (int i = 0; i < length + 1; i++)\n        {\n            if (dp[N, i] >= 0)\n                ans = Math.Min(ans, dp[N, i]);\n        }\n\n        return ans;\n    }\n\n    public int[] ParseIntBySpace(string str)\n    {\n        int[] array = new int[str.Length];\n        int lastloc = 0, spaceloc = -1;\n\n        for (int i = 0; i < str.Length; i++)\n        {\n            if (str[i] == ' ')\n            {\n                array[lastloc++] = int.Parse(str.Substring(spaceloc + 1, i - spaceloc - 1));\n                spaceloc = i;\n            }\n            else if (i == str.Length - 1)\n            {\n                array[lastloc++] = int.Parse(str.Substring(spaceloc + 1, i - spaceloc));\n            }\n        }\n\n        Array.Resize(ref array, lastloc);\n\n        return array;\n    }\n}\n\nclass Example\n{\n    static void Main()\n    {\n        quiz ex = new quiz();\n        int N;\n\n        //while (true)\n        //{\n        N = int.Parse(Console.ReadLine());\n        int[] L = new int[N];\n\n        for (int i = 0; i < N; i++)\n        {\n            L[i] = int.Parse(Console.ReadLine());\n        }\n        //while (true)\n        //{\n        Console.WriteLine(ex.solve(N, L));\n        //}\n        //}\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "$best = Float::INFINITY\ndef search(a, n, i, min, max, cur)\n    return Float::INFINITY if max - min >= $best\n    if i >= n - 1\n        max = cur if cur > max\n        min = cur if cur < min\n        ans = max - min\n        $best = ans if ans < $best\n        return\n    end\n    search(a, n, i+1, min, max, cur+a[i+1])\n    max = cur if cur > max\n    min = cur if cur < min\n    search(a, n, i+1, min, max, a[i+1])\nend\n\nn = gets.to_i\na = (1..n).map { gets.to_i }\ns = 0\n(0..n-2).each {|i|\n    s += a[i]\n    search(a, n, i+1, s, s, a[i+1])\n}\np $best\n"
  },
  {
    "language": "Ruby",
    "code": "def search(a, n, i, min, max, cur)\n    return Float::INFINITY if max - min >= $best\n    if i >= n - 1\n        max = cur if cur > max\n        min = cur if cur < min\n        ans = max - min\n        $best = ans if ans < $best\n        return\n    end\n    search(a, n, i+1, min, max, cur+a[i+1])\n    max = cur if cur > max\n    min = cur if cur < min\n    search(a, n, i+1, min, max, a[i+1])\nend\n\nn = gets.to_i\na = (1..n).map { gets.to_i }\ns = 0\n$best = a.max - a.min\n(0..n-2).each {|i|\n    s += a[i]\n    search(a, n, i+1, s, s, a[i+1])\n}\np $best\n"
  },
  {
    "language": "Ruby",
    "code": "def search(a, n, i, min, max, cur)\n    return Float::INFINITY if max - min >= $best\n    if i >= n - 1\n        max = cur if cur > max\n        min = cur if cur < min\n        ans = max - min\n        $best = ans if ans < $best\n        return\n    end\n    search(a, n, i+1, min, max, cur+a[i+1])\n    max = cur if cur > max\n    min = cur if cur < min\n    search(a, n, i+1, min, max, a[i+1])\nend\n\nn = gets.to_i\na = (1..n).map { gets.to_i }\ns = 0\n$best = a.max - a.min\n(0..n-2).each {|i|\n    s += a[i]\n    search(a, n, i+1, s, s, a[i+1])\n}\np $best\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nminl = max(l) - 1\nfor i in range(minl + 1, sum(l) - 1):\n    nl = 0\n    minn = 0\n    for j in range(n):\n        if nl + l[j] <= i:\n            nl += l[j]\n        elif i - nl >= minl:\n            break\n        else:\n            minn = max(minn, i - nl)\n            nl = l[j]\n    else:\n        minn = max(minn, i - nl)\n        minl = min(minl, minn)\nprint(minl)\n"
  },
  {
    "language": "Python",
    "code": "N, *L = map(int, open(0).read().split())\nmemo = [set() for i in range(N)]\nans = sum(L)\ndef dfs(i, mi, ma):\n    global ans\n    if i == N:\n        ans = min(ans, ma - mi)\n        return\n    key = (mi, ma)\n    if ma - mi >= ans or key in memo[i]:\n        return\n    memo[i].add(key)\n    s = 0\n    for j in range(i, N-(i==0)):\n        s += L[j]\n        dfs(j+1, min(mi, s), max(ma, s))\ndfs(0, 10**18, -10**18)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve(low, n, ls):\n    dp = [10 ** 20 for i in range(n + 1)]\n    dp[0] = low\n    for i in range(n):\n        length = 0\n        for j in range(i, -1, -1):\n            length += ls[j]\n            if i + 1 == n and j == 0:\n                continue\n            if length >= low:\n                high = max(length, dp[j])\n                dp[i+1] = min(dp[i+1], high)\n    return dp[n] - low\n\n\ndef main():\n    n = int(input())\n    ls = [int(input()) for i in range(n)]\n    ans = 10 ** 20\n    for i in range(n):\n        length = 0\n        for j in range(i, n):\n            length += ls[j]\n            ans = min(ans, solve(length, n, ls))\n\n    print(ans)\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nmind = max(l) - min(l)\n\ndef youkan(l, target, nl, minn):\n    global mind\n    n = len(l)\n    for j in range(n):\n        v = nl + l[j]\n        if v <= target:\n            if target - v < mind:\n                if j + 1 < n and v + l[j + 1] <= target:\n                    youkan(l[j + 1:], target, 0, max(minn, target - v))\n                    youkan(l[j + 1:], target, v, minn)\n                else:\n                    minn = max(minn, target - v)\n                    nl = 0\n            else:\n                nl = v\n        else:\n            return\n    else:\n        if nl == 0:\n            mind = min(mind, minn)\n    return mind\n        \nfor i in range(max(l) + 1, sum(l) - 1):\n    youkan(l, i, 0, 0)\n    \nprint(mind)\n"
  },
  {
    "language": "Python",
    "code": "# 水ようかん 2018/12/27\nfrom itertools import combinations\n\ndef main():\n    N = input_int()\n    L = [input_int() for i in range(N)]\n\n    # 切れ目は1本からN-1本\n    min_diff = 1000\n    for n in range(1, N):#range(1, N):\n        for kireme in combinations(range(N), n):\n            tmp = diff(L, kireme)\n            if tmp < min_diff:\n                min_diff = tmp\n    print(min_diff)\n\ndef input_int():\n    return int(input().strip())\n\n\ndef diff(L, kireme):\n    size_list = []\n    s = 0\n    for idx in range(len(L)):\n        s += L[idx]\n        if idx in kireme:\n            size_list.append(s)\n            s = 0\n    else:\n        size_list.append(s)\n    return max(size_list) - min(size_list)\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nmind = max(l) - min(l)\n        \nfor i in range(1, sum(l) - 1):\n    k = []\n    p = 0\n    for j in range(n):\n        p += l[j]\n        if p >= i:\n            if p - i >= mind:\n                break\n            k.append(p)\n            p = 0\n    else:\n        if p == 0:\n            mind = min(mind, max(k) - i)\n    \nprint(mind)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nminl = max(l)\nfor i in range(minl, sum(l) - 1):\n    nl = 0\n    minn = 0\n    for j in range(n):\n        if nl + l[j] <= i:\n            nl += l[j]\n        elif i - nl >= minl:\n            break\n        else:\n            minn = max(minn, i - nl)\n            nl = l[j]\n    else:\n        minn = max(minn, i - nl)\n        minl = min(minl, minn)\nprint(minl)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nmind = max(l) - min(l)\n\ndef youkan(l, target, nl, minn):\n    global mind\n    n = len(l)\n    for j in range(n):\n        v = nl + l[j]\n        if v <= target:\n            if target - v < mind:\n                if j + 1 < n and v + l[j + 1] <= target:\n                    youkan(l[j + 1:], target, 0, max(minn, target - v))\n                    youkan(l[j + 1:], target, v, minn)\n                else:\n                    minn = max(minn, target - v)\n                    nl = 0\n            else:\n                nl = v\n        else:\n            return\n    else:\n        if nl == 0:\n            mind = min(mind, minn)\n    return mind\n        \nfor i in range(max(l) + 1, sum(l) - 1):\n    youkan(l, i, 0, 0)\n    \nprint(mind)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nminl = max(l)\nfor i in range(1 , sum(l) - 1):\n    nl = 0\n    minn = 0\n    for j in range(n):\n        if nl + l[j] <= i:\n            nl += l[j]\n        elif i - nl >= minl:\n            break\n        else:\n            minn = max(minn, i - nl)\n            nl = l[j]\n    else:\n        minn = max(minn, i - nl)\n        minl = min(minl, minn)\nprint(minl)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nmind = max(l) - min(l)\n\ndef youkan(l, target, nl, minn):\n    global mind\n    n = len(l)\n    for j in range(n):\n        v = nl + l[j]\n        if v <= target:\n            if target - v < mind:\n                if j + 1 < n and v + l[j + 1] <= target:\n                    youkan(l[j + 1:], target, 0, max(minn, target - v))\n                    youkan(l[j + 1:], target, v, minn)\n                else:\n                    minn = max(minn, target - v)\n                    nl = 0\n            else:\n                nl = v\n        else:\n            break\n    else:\n        if nl == 0:\n            mind = min(mind, minn)\n        \nfor i in range(max(l), sum(l) - 1):\n    youkan(l, i, 0, 0)\n    \nprint(mind)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport os\nimport sys\n\n\ndef main():\n    N = read_int()\n    A = [read_int() for _ in range(N)]\n    print(solve(N, A))\n\n\ndef solve(N, A):\n    lens = set()\n    for i in range(N):\n        s = A[i]\n        lens.add(s)\n        for j in range(i + 1, N):\n            s += A[j]\n            lens.add(s)\n\n    lens = list(lens)\n    lens.sort()\n    best = lens[-1]\n    lens.pop()\n    M = len(lens)\n\n    for li in range(M):\n        lmin = lens[li]\n        for lj in range(li, M):\n            lmax = lens[lj]\n            if lmax - lmin >= best:\n                break\n\n            D = set()\n            D.add(0)\n            for a in A:\n                ND = set()\n                for d in D:\n                    if d + a <= lmax:\n                        ND.add(d + a)\n                    if lmin <= d <= lmax and a <= lmax:\n                        ND.add(a)\n                D = ND\n            if any([lmin <= d <= lmax for d in D]):\n                best = lmax - lmin\n                break\n\n    return best\n\n\n###############################################################################\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nminl = max(l) - min(l)\nfor i in range(max(l) + 1, sum(l)):\n    nl = 0\n    minn = 0\n    for j in range(n):\n        if nl + l[j] <= i:\n            nl += l[j]\n        elif i - nl >= minl:\n            break\n        else:\n            minn = max(minn, i - nl)\n            nl = l[j]\n    else:\n        minn = max(minn, i - nl)\n        minl = min(minl, minn)\nprint(minl)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = []\nfor _ in range(n):\n    l.append(int(input()))\nmind = max(l) - min(l)\n\ndef youkan(l, target, nl, minn):\n    global mind\n    n = len(l)\n    for j in range(n):\n        v = nl + l[j]\n        if v <= target:\n            if target - v < mind:\n                if j + 1 < n and v + l[j + 1] <= target:\n                    youkan(l[j + 1:], target, 0, max(minn, target - v))\n                    youkan(l[j + 1:], target, v, minn)\n                else:\n                    minn = max(minn, target - v)\n                    nl = 0\n            else:\n                nl = v\n        else:\n            break\n    else:\n        if nl == 0:\n            mind = min(mind, minn)\n        \nfor i in range(max(l) + 1, sum(l) - 1):\n    youkan(l, i, 0, 0)\n    \nprint(mind)\n"
  }
]