[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n} Interval;\n\nint compare(const void *a, const void *b) {\n    return ((Interval *)a)->start - ((Interval *)b)->start;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    Interval *intervals = malloc(M * sizeof(Interval));\n    for (int i = 0; i < M; i++) {\n        int a, L;\n        scanf(\"%d %d\", &a, &L);\n        intervals[i].start = a;\n        intervals[i].end = (a + L) % N;\n    }\n    \n    qsort(intervals, M, sizeof(Interval), compare);\n    \n    Interval *merged = malloc(M * sizeof(Interval));\n    int merged_count = 0;\n    \n    for (int i = 0; i < M; i++) {\n        if (merged_count == 0) {\n            merged[merged_count++] = intervals[i];\n        } else {\n            Interval *last = &merged[merged_count - 1];\n            if (intervals[i].start <= last->end || \n                (intervals[i].start > last->end && intervals[i].end < intervals[i].start && last->end >= intervals[i].start)) {\n                int new_end = last->end;\n                if (intervals[i].end < intervals[i].start) {\n                    if (last->end >= intervals[i].start || last->end < intervals[i].end) {\n                        new_end = (last->end > intervals[i].end) ? last->end : (intervals[i].end < intervals[i].start ? N - 1 : intervals[i].end);\n                    }\n                } else {\n                    if (intervals[i].end > last->end) {\n                        new_end = intervals[i].end;\n                    }\n                }\n                last->end = new_end;\n            } else {\n                merged[merged_count++] = intervals[i];\n            }\n        }\n    }\n    \n    if (merged_count > 1) {\n        Interval *first = &merged[0];\n        Interval *last = &merged[merged_count - 1];\n        if (first->start == 0 && last->end == N - 1) {\n            first->start = last->start;\n            merged_count--;\n        }\n    }\n    \n    int *lengths = malloc(merged_count * sizeof(int));\n    for (int i = 0; i < merged_count; i++) {\n        lengths[i] = (merged[i].end - merged[i].start + 1 + N) % N;\n        if (lengths[i] <= 0) lengths[i] += N;\n    }\n    \n    int *count = calloc(N + 1, sizeof(int));\n    for (int i = 0; i < merged_count; i++) {\n        count[lengths[i]]++;\n    }\n    \n    for (int i = N; i >= 1; i--) {\n        if (count[i] > 0) {\n            printf(\"%d %d\\n\", i, count[i]);\n        }\n    }\n    \n    free(intervals);\n    free(merged);\n    free(lengths);\n    free(count);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:00:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<pair<int, int>> intervals;\n\n    for (int i = 0; i < M; ++i) {\n        int a, L;\n        cin >> a >> L;\n        int end = (a + L) % N;\n        if (a < end) {\n            intervals.push_back({a, end});\n        } else {\n            intervals.push_back({a, N});\n            intervals.push_back({0, end});\n        }\n    }\n\n    sort(intervals.begin(), intervals.end());\n\n    vector<pair<int, int>> merged;\n    for (const auto &interval : intervals) {\n        if (merged.empty()) {\n            merged.push_back(interval);\n        } else {\n            auto &last = merged.back();\n            if (interval.first <= last.second) {\n                last.second = max(last.second, interval.second);\n            } else {\n                merged.push_back(interval);\n            }\n        }\n    }\n\n    if (!merged.empty() && merged.back().second == N && merged.front().first == 0) {\n        merged.front().first = merged.back().first;\n        merged.pop_back();\n    }\n\n    map<int, int> lengthCounts;\n    for (const auto &interval : merged) {\n        int length = interval.second - interval.first;\n        lengthCounts[length]++;\n    }\n\n    for (auto it = lengthCounts.rbegin(); it != lengthCounts.rend(); ++it) {\n        cout << it->first << \" \" << it->second << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WallPainting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        boolean[] wall = new boolean[N];\n        \n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt();\n            int L = scanner.nextInt();\n            for (int j = 0; j < L; j++) {\n                int pos = (a + j) % N;\n                wall[pos] = true;\n            }\n        }\n        \n        List<Integer> paintedSections = new ArrayList<>();\n        int currentLength = 0;\n        \n        for (int i = 0; i < N; i++) {\n            if (wall[i]) {\n                currentLength++;\n            } else {\n                if (currentLength > 0) {\n                    paintedSections.add(currentLength);\n                    currentLength = 0;\n                }\n            }\n        }\n        \n        if (currentLength > 0) {\n            paintedSections.add(currentLength);\n        }\n        \n        if (paintedSections.isEmpty()) {\n            System.out.println(0);\n            return;\n        }\n        \n        Collections.sort(paintedSections, Collections.reverseOrder());\n        \n        Map<Integer, Integer> lengthCount = new HashMap<>();\n        for (int len : paintedSections) {\n            lengthCount.put(len, lengthCount.getOrDefault(len, 0) + 1);\n        }\n        \n        List<Integer> sortedLengths = new ArrayList<>(lengthCount.keySet());\n        Collections.sort(sortedLengths, Collections.reverseOrder());\n        \n        for (int len : sortedLengths) {\n            System.out.println(len + \" \" + lengthCount.get(len));\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:01:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WallPainting {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        boolean[] wall = new boolean[N];\n        \n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt();\n            int L = scanner.nextInt();\n            \n            for (int j = 0; j < L; j++) {\n                wall[(a + j) % N] = true;\n            }\n        }\n        \n        Map<Integer, Integer> paintLengths = new TreeMap<>(Collections.reverseOrder());\n        \n        int currentLength = 0;\n        for (int i = 0; i < N * 2; i++) {\n            if (wall[i % N]) {\n                currentLength++;\n            } else {\n                if (currentLength > 0) {\n                    paintLengths.put(currentLength, paintLengths.getOrDefault(currentLength, 0) + 1);\n                    currentLength = 0;\n                }\n            }\n        }\n        \n        if (currentLength > 0) {\n            paintLengths.put(currentLength, paintLengths.getOrDefault(currentLength, 0) + 1);\n        }\n        \n        for (Map.Entry<Integer, Integer> entry : paintLengths.entrySet()) {\n            System.out.println(entry.getKey() + \" \" + entry.getValue());\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:01:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100001\n\nint main() {\n    int N, M, a, L;\n    int wall[MAX_N] = {0};\n    int painted[MAX_N] = {0};\n\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &a, &L);\n        for (int j = 0; j < L; j++) {\n            wall[(a + j) % N] = 1;\n        }\n    }\n\n    int count[MAX_N] = {0};\n    int current_length = 0;\n    int max_length = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (wall[i]) {\n            current_length++;\n        } else {\n            if (current_length > 0) {\n                count[current_length]++;\n                max_length = (current_length > max_length) ? current_length : max_length;\n            }\n            current_length = 0;\n        }\n    }\n\n    if (current_length > 0) {\n        count[current_length]++;\n        max_length = (current_length > max_length) ? current_length : max_length;\n    }\n\n    for (int i = max_length; i > 0; i--) {\n        if (count[i] > 0) {\n            printf(\"%d %d\\n\", i, count[i]);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<pair<int, int>> painted_sections;\n\n    for (int i = 0; i < M; ++i) {\n        int a, L;\n        cin >> a >> L;\n\n        if (a + L <= N) {\n            painted_sections.push_back({a, a + L});\n        } else {\n            painted_sections.push_back({a, N});\n            painted_sections.push_back({0, (a + L) % N});\n        }\n    }\n\n    sort(painted_sections.begin(), painted_sections.end());\n\n    vector<pair<int, int>> merged_sections;\n    for (const auto& section : painted_sections) {\n        if (merged_sections.empty() || section.first > merged_sections.back().second) {\n            merged_sections.push_back(section);\n        } else {\n            merged_sections.back().second = max(merged_sections.back().second, section.second);\n        }\n    }\n\n    vector<int> section_lengths;\n    for (const auto& section : merged_sections) {\n        section_lengths.push_back(section.second - section.first);\n    }\n\n    sort(section_lengths.begin(), section_lengths.end(), greater<int>());\n\n    map<int, int> length_count;\n    for (int length : section_lengths) {\n        length_count[length]++;\n    }\n\n    for (const auto& entry : length_count) {\n        cout << entry.first << \" \" << entry.second << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def painted_wall(N, children):\n    painted = [False] * N\n    for a, L in children:\n        for i in range(L):\n            painted[(a + i) % N] = True\n\n    sections = []\n    length = 0\n    for i in range(N):\n        if painted[i]:\n            length += 1\n        else:\n            if length > 0:\n                sections.append(length)\n                length = 0\n\n    if length > 0:  # Add the last segment if it wraps around\n        sections.append(length)\n\n    sections.sort(reverse=True)\n    \n    length_count = {}\n    for section in sections:\n        length_count[section] = length_count.get(section, 0) + 1\n\n    result = [(length, count) for length, count in length_count.items()]\n    result.sort(reverse=True, key=lambda x: x[0])\n\n    for length, count in result:\n        print(f'{length} {count}')\n\n# Example usage:\nN = 10\nchildren = [(0, 3), (5, 3), (8, 4)]\npainted_wall(N, children)",
    "timestamp": "2025-08-13 04:33:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PaintedWall {\n    public static void main(String[] args) {\n        int N = 10; // Number of sections in the circular wall\n        int M = 3; // Number of children\n        \n        int[] starts = { 1, 3, 6 }; // Starting positions\n        int[] lengths = { 4, 5, 3 }; // Lengths to paint\n\n        boolean[] paintedWall = new boolean[N];\n        \n        // Paint the wall sections\n        for (int i = 0; i < M; i++) {\n            int start = starts[i];\n            int length = lengths[i];\n            \n            for (int j = 0; j < length; j++) {\n                int position = (start + j) % N;\n                paintedWall[position] = true;\n            }\n        }\n        \n        // Determine painted sections\n        List<Integer> paintedSections = new ArrayList<>();\n        int currentSectionLength = 0;\n        \n        for (int i = 0; i < N; i++) {\n            if (paintedWall[i]) {\n                currentSectionLength++;\n            } else {\n                if (currentSectionLength > 0) {\n                    paintedSections.add(currentSectionLength);\n                    currentSectionLength = 0;\n                }\n            }\n        }\n        \n        if (currentSectionLength > 0) {\n            paintedSections.add(currentSectionLength);\n        }\n        \n        // Sort painted sections in descending order\n        paintedSections.sort(Collections.reverseOrder());\n        \n        // Count frequencies of each section length\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int length : paintedSections) {\n            frequencyMap.put(length, frequencyMap.getOrDefault(length, 0) + 1);\n        }\n        \n        // Print the results\n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            System.out.println(\"Length: \" + entry.getKey() + \", Count: \" + entry.getValue());\n        }\n    }\n}",
    "timestamp": "2025-08-13 04:33:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n} Interval;\n\nint compare(const void *a, const void *b) {\n    Interval *intervalA = (Interval *)a;\n    Interval *intervalB = (Interval *)b;\n    if (intervalA->start != intervalB->start)\n        return intervalA->start - intervalB->start;\n    else\n        return intervalA->end - intervalB->end;\n}\n\nvoid mergeIntervals(Interval arr[], int n, int N, int *lengths, int *index) {\n    qsort(arr, n, sizeof(Interval), compare);\n    Interval current = arr[0];\n    for (int i = 1; i < n; i++) {\n        if ((current.end + 1) % N >= arr[i].start) {\n            current.end = (current.end + arr[i].end - arr[i].start + 1) % N;\n        } else {\n            lengths[(*index)++] = (current.end - current.start + N) % N + 1;\n            current = arr[i];\n        }\n    }\n    lengths[(*index)++] = (current.end - current.start + N) % N + 1;\n}\n\nint compareLengths(const void *a, const void *b) {\n    return *(int *)b - *(int *)a;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    Interval intervals[M];\n    for (int i = 0; i < M; i++) {\n        int a, L;\n        scanf(\"%d %d\", &a, &L);\n        intervals[i].start = a;\n        intervals[i].end = (a + L) % N;\n    }\n\n    int lengths[M];\n    int index = 0;\n    mergeIntervals(intervals, M, N, lengths, &index);\n\n    qsort(lengths, index, sizeof(int), compareLengths);\n\n    int count = 1;\n    for (int i = 1; i <= index; i++) {\n        if (i == index || lengths[i] != lengths[i-1]) {\n            printf(\"%d %d\\n\", lengths[i-1], count);\n            count = 1;\n        } else {\n            count++;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 04:33:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def paint_wall(N, children_paint):\n    # Initialize wall sections\n    wall = [0] * N\n    \n    # Paint wall sections according to children's specifications\n    for a, L in children_paint:\n        for i in range(L):\n            wall[(a + i) % N] = 1\n    \n    # Count painted sections\n    painted_sections = {}\n    current_section = 0\n    current_length = 0\n    \n    # Iterate through wall to find painted sections\n    for i in range(N * 2):\n        current_pos = i % N\n        if wall[current_pos] == 1:\n            current_length += 1\n        else:\n            if current_length > 0:\n                painted_sections[current_length] = painted_sections.get(current_length, 0) + 1\n            current_length = 0\n    \n    # Handle case of section extending past end of wall\n    if current_length > 0:\n        painted_sections[current_length] = painted_sections.get(current_length, 0) + 1\n    \n    # Sort painted sections in descending order\n    result = sorted(painted_sections.items(), reverse=True)\n    \n    return result\n\n# Example usage\nN = 10\nchildren_paint = [(2, 5), (3, 3), (5, 4)]\nprint(paint_wall(N, children_paint))",
    "timestamp": "2025-08-13 04:34:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    intervals = []\n    index = 2\n    for _ in range(M):\n        a = int(data[index])\n        L = int(data[index + 1])\n        index += 2\n        end = (a + L) % N\n        if a <= end:\n            intervals.append((a, end))\n        else:\n            intervals.append((a, N - 1))\n            intervals.append((0, end))\n    \n    if not intervals:\n        print(0)\n        return\n    \n    intervals.sort()\n    merged = []\n    current_start, current_end = intervals[0]\n    \n    for start, end in intervals[1:]:\n        if start <= current_end:\n            current_end = max(current_end, end)\n        else:\n            merged.append((current_start, current_end))\n            current_start, current_end = start, end\n    merged.append((current_start, current_end))\n    \n    length_counts = {}\n    for start, end in merged:\n        length = end - start + 1\n        length_counts[length] = length_counts.get(length, 0) + 1\n    \n    sorted_lengths = sorted(length_counts.items(), key=lambda x: (-x[0], x[1]))\n    \n    print(len(sorted_lengths))\n    for length, count in sorted_lengths:\n        print(f\"{length} {count}\")\n\nsolve()",
    "timestamp": "2025-08-13 04:34:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<bool> wall(N, false);\n\n    for (int i = 0; i < M; ++i) {\n        int a, L;\n        cin >> a >> L;\n\n        for (int j = 0; j < L; ++j) {\n            wall[(a + j) % N] = true;\n        }\n    }\n\n    vector<int> paintedSections;\n    int currentLength = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        if (wall[i]) {\n            ++currentLength;\n        } else {\n            if (currentLength > 0) {\n                paintedSections.push_back(currentLength);\n                currentLength = 0;\n            }\n        }\n    }\n    if (currentLength > 0) {\n        paintedSections.push_back(currentLength);\n    }\n\n    sort(paintedSections.begin(), paintedSections.end(), greater<int>());\n\n    map<int, int> sectionCount;\n    for (int len : paintedSections) {\n        sectionCount[len]++;\n    }\n\n    vector<pair<int, int>> output;\n    for (const auto& entry : sectionCount) {\n        output.push_back(entry);\n    }\n\n    sort(output.begin(), output.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.first > b.first;\n    });\n\n    for (const auto& entry : output) {\n        cout << entry.first << \" \" << entry.second << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:20:15"
  }
]