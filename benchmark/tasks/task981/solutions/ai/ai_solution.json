[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 1000\n#define MAX_QUERIES 420\n\nint n;\nchar board[2][MAX_N];\nbool queried[2][MAX_N];\nint query_count = 0;\n\nbool query(int r1, int c1, int r2, int c2) {\n    if (query_count >= MAX_QUERIES) return false;\n    \n    printf(\"? %d %d %d %d\\n\", r1 + 1, c1 + 1, r2 + 1, c2 + 1);\n    fflush(stdout);\n    \n    query_count++;\n    \n    char response[4];\n    scanf(\"%s\", response);\n    \n    return (strcmp(response, \"YES\") == 0);\n}\n\nvoid solve() {\n    memset(queried, 0, sizeof(queried));\n    query_count = 0;\n\n    for (int col = 0; col < n; col++) {\n        // If column not fully queried, query each cell\n        if (!queried[0][col] || !queried[1][col]) {\n            for (int row = 0; row < 2; row++) {\n                if (!queried[row][col]) {\n                    bool result = query(row, col, row, col);\n                    queried[row][col] = true;\n                    board[row][col] = result ? '#' : '.';\n                }\n            }\n        }\n    }\n\n    // Print final board\n    for (int row = 0; row < 2; row++) {\n        for (int col = 0; col < n; col++) {\n            printf(\"%c\", board[row][col]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 23:33:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_QUERIES 420\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    char blackboard[2][N + 1];\n    memset(blackboard[0], 0, N + 1);\n    memset(blackboard[1], 0, N + 1);\n\n    int queries = 0;\n    int total_queried = 0;\n\n    while (total_queried < 2 * N && queries < MAX_QUERIES) {\n        int r1, c1, r2, c2;\n        r1 = 1;\n        c1 = total_queried / 2 + 1;\n        r2 = 2;\n        c2 = total_queried / 2 + 1;\n\n        printf(\"? %d %d %d %d\\n\", r1, c1, r2, c2);\n        fflush(stdout);\n\n        char response[10];\n        scanf(\"%s\", response);\n\n        if (strcmp(response, \"present\") == 0) {\n            blackboard[r1 - 1][c1 - 1] = 1;\n            blackboard[r2 - 1][c2 - 1] = 1;\n            total_queried += 2;\n        } else {\n            blackboard[r1 - 1][c1 - 1] = 0;\n            blackboard[r2 - 1][c2 - 1] = 0;\n            total_queried += 2;\n        }\n        queries++;\n    }\n\n    printf(\"!\\n\");\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < N; j++) {\n            printf(\"%d\", blackboard[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    fflush(stdout);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<string> board(2, string(N, '?'));\n    int queries = 0;\n\n    auto query = [&](int r1, int c1, int r2, int c2) {\n        cout << \"? \" << r1+1 << \" \" << c1+1 << \" \" << r2+1 << \" \" << c2+1 << endl;\n        cout.flush();\n        string res;\n        cin >> res;\n        queries++;\n        return res == \"YES\";\n    };\n\n    // Find a path from (0,0) to (1, N-1)\n    string path;\n    int r = 0, c = 0;\n    while (r + c < N - 1) {\n        if (query(r, c + 1, 1, N - 1)) {\n            path += 'R';\n            c++;\n        } else {\n            path += 'D';\n            r++;\n        }\n    }\n\n    string path2;\n    r = 1, c = N - 1;\n    while (r + c > N - 1) {\n        if (query(0, 0, r - 1, c)) {\n            path2 += 'D';\n            r--;\n        } else {\n            path2 += 'R';\n            c--;\n        }\n    }\n\n    reverse(path2.begin(), path2.end());\n    string full_path = path + path2;\n    cout << \"! \" << full_path << endl;\n    cout.flush();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class BlackboardQuery {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(System.out, true);\n\n    public static void main(String[] args) throws IOException {\n        int N = Integer.parseInt(br.readLine());\n        char[][] board = new char[2][N];\n        int queries = 0;\n        boolean[][] queried = new boolean[2][N];\n\n        for (int i = 0; i < N && queries < 420; i++) {\n            for (int row = 0; row < 2 && queries < 420; row++) {\n                if (!queried[row][i]) {\n                    out.println(\"? \" + (row + 1) + \" \" + (i + 1) + \" \" + (row + 1) + \" \" + (i + 1));\n                    out.flush();\n                    queries++;\n                    String response = br.readLine();\n                    board[row][i] = response.charAt(0);\n                    queried[row][i] = true;\n                }\n            }\n        }\n\n        out.println(\"!\");\n        for (int row = 0; row < 2; row++) {\n            for (int i = 0; i < N; i++) {\n                out.print(board[row][i]);\n            }\n            out.println();\n        }\n        out.flush();\n    }\n}",
    "timestamp": "2025-08-05 23:34:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class BlackboardQuery {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(System.out, true);\n    static int N, queries;\n    static boolean[][] board;\n\n    public static void main(String[] args) throws IOException {\n        N = Integer.parseInt(br.readLine());\n        board = new boolean[2][N];\n        queries = 0;\n\n        while (queries < 420 && !isFullyQueried()) {\n            String bestQuery = findBestQuery();\n            if (bestQuery == null) break;\n            \n            out.println(bestQuery);\n            out.flush();\n\n            String response = br.readLine();\n            processResponse(bestQuery, response);\n            queries++;\n        }\n    }\n\n    static String findBestQuery() {\n        for (int width = N; width > 0; width--) {\n            for (int height = 1; height <= 2; height++) {\n                for (int row = 0; row < 2; row++) {\n                    for (int col = 0; col <= N - width; col++) {\n                        if (isQueryNeeded(row, col, height, width)) {\n                            return formatQuery(row, col, height, width);\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    static boolean isQueryNeeded(int startRow, int startCol, int height, int width) {\n        for (int r = startRow; r < startRow + height; r++) {\n            for (int c = startCol; c < startCol + width; c++) {\n                if (!board[r][c]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    static String formatQuery(int startRow, int startCol, int height, int width) {\n        return (startRow + 1) + \" \" + (startCol + 1) + \" \" + height + \" \" + width;\n    }\n\n    static void processResponse(String query, String response) {\n        String[] parts = query.split(\" \");\n        int startRow = Integer.parseInt(parts[0]) - 1;\n        int startCol = Integer.parseInt(parts[1]) - 1;\n        int height = Integer.parseInt(parts[2]);\n        int width = Integer.parseInt(parts[3]);\n\n        if (response.equals(\"YES\")) {\n            for (int r = startRow; r < startRow + height; r++) {\n                for (int c = startCol; c < startCol + width; c++) {\n                    board[r][c] = true;\n                }\n            }\n        }\n    }\n\n    static boolean isFullyQueried() {\n        for (boolean[] row : board) {\n            for (boolean cell : row) {\n                if (!cell) return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 23:34:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nclass BlackboardSearch {\nprivate:\n    int N;\n    vector<vector<bool>> board;\n    int queryCount;\n\n    bool makeQuery(int r1, int c1, int r2, int c2) {\n        if (queryCount >= 420) return false;\n        queryCount++;\n        \n        cout << r1 << \" \" << c1 << \" \" << r2 << \" \" << c2 << endl;\n        cout.flush();\n        \n        string response;\n        cin >> response;\n        \n        return response == \"YES\";\n    }\n\n    void searchRectangle(int r1, int c1, int r2, int c2) {\n        if (r1 > r2 || c1 > c2) return;\n        \n        if (r1 == r2 && c1 == c2) {\n            board[r1][c1] = makeQuery(r1, c1, r1, c1);\n            return;\n        }\n        \n        bool query = makeQuery(r1, c1, r2, c2);\n        \n        if (!query) {\n            int midRow = (r1 + r2) / 2;\n            int midCol = (c1 + c2) / 2;\n            \n            searchRectangle(r1, c1, midRow, midCol);\n            searchRectangle(r1, midCol + 1, midRow, c2);\n            searchRectangle(midRow + 1, c1, r2, midCol);\n            searchRectangle(midRow + 1, midCol + 1, r2, c2);\n        } else {\n            for (int r = r1; r <= r2; r++) {\n                for (int c = c1; c <= c2; c++) {\n                    board[r][c] = true;\n                }\n            }\n        }\n    }\n\npublic:\n    BlackboardSearch(int length) : N(length), board(2, vector<bool>(N, false)), queryCount(0) {\n        searchRectangle(0, 0, 1, N-1);\n    }\n\n    void printResult() {\n        for (int r = 0; r < 2; r++) {\n            for (int c = 0; c < N; c++) {\n                cout << (board[r][c] ? '1' : '0');\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    \n    BlackboardSearch bs(N);\n    bs.printResult();\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def query(rectangle):\n    print(f\"? {rectangle[0]} {rectangle[1]} {rectangle[2]} {rectangle[3]}\")\n    response = input().strip()\n    return response\n\ndef flush_query():\n    import sys\n    sys.stdout.flush()\n\ndef search_blackboard(n):\n    max_queries = 420\n    queries_made = 0\n    queried_cells = [[False] * n for _ in range(2)]\n\n    def query_status(i1, j1, i2, j2):\n        if queries_made < max_queries:\n            rectangle = (i1+1, j1+1, i2+1, j2+1)\n            response = query(rectangle)\n            flush_query()\n            for i in range(i1, i2+1):\n                for j in range(j1, j2+1):\n                    queried_cells[i][j] = True\n            return response\n        \n    for col in range(n):\n        if queries_made >= max_queries:\n            break\n        for row in range(2):\n            if not queried_cells[row][col]:\n                response = query_status(row, col, row, col)\n                queries_made += 1\n                if queries_made >= max_queries:\n                    break\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    search_blackboard(n)",
    "timestamp": "2025-08-13 16:00:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class BlackboardQuery {\n\n    private static final int MAX_QUERIES = 420;\n    private static final char USED = '1';\n    private static final char UNUSED = '0';\n\n    private int queriesCount = 0;\n    private int length;\n    private char[][] blackboard;\n\n    public BlackboardQuery(int length) {\n        this.length = length;\n        this.blackboard = new char[2][length];\n    }\n\n    private void initializeBlackboard() {\n        // As an example, initialize with unused cells\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < length; j++) {\n                blackboard[i][j] = UNUSED;\n            }\n        }\n    }\n\n    private boolean query(int rowStart, int colStart, int rowEnd, int colEnd) {\n        queriesCount++;\n\n        if (queriesCount > MAX_QUERIES) {\n            System.out.println(\"Query limit exceeded\");\n            System.exit(0);\n        }\n\n        // Simulating a query to check if a rectangle of USED cells exists\n        boolean allUsed = true;\n        for (int i = rowStart; i <= rowEnd; i++) {\n            for (int j = colStart; j <= colEnd; j++) {\n                if (blackboard[i][j] != USED) {\n                    allUsed = false;\n                    break;\n                }\n            }\n        }\n\n        // Output the result of the query\n        System.out.println(allUsed ? \"Exists\" : \"Does not exist\");\n        System.out.flush();\n\n        return allUsed;\n    }\n\n    private void queryWholeBlackboard() {\n        int step = length / 20 + 1;  // Example step size, may need adjustment\n        for (int colStart = 0; colStart < length; colStart += step) {\n            for (int rowStart = 0; rowStart < 2; rowStart++) {\n                if (!query(rowStart, colStart, rowStart, Math.min(colStart + step - 1, length - 1))) {\n                    break;  // Exit if query limit exceeded or no 'USED' cell found\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int length = scanner.nextInt();\n        BlackboardQuery blackboardQuery = new BlackboardQuery(length);\n        \n        blackboardQuery.initializeBlackboard();\n        blackboardQuery.queryWholeBlackboard();\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 16:00:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_QUERIES 420\n\nint queryCount = 0;\n\n// Function to simulate querying the blackboard\nint queryBlackboard(int x1, int y1, int x2, int y2) {\n    queryCount++;\n    printf(\"? %d %d %d %d\\n\", x1, y1, x2, y2);\n    fflush(stdout);\n    int response;\n    scanf(\"%d\", &response);\n    return response;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int status[2][N]; // Array to store the status of the blackboard\n\n    // Initialize the status to -1 (unknown)\n    for (int i = 0; i < 2; i++)\n        for (int j = 0; j < N; j++)\n            status[i][j] = -1;\n\n    // Query each cell individually to determine the status\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < N; j++) {\n            if (queryCount >= MAX_QUERIES) {\n                fprintf(stderr, \"Query limit exceeded\\n\");\n                return -1;\n            }\n            status[i][j] = queryBlackboard(i + 1, j + 1, i + 1, j + 1);\n        }\n    }\n\n    // Output the final status of the blackboard\n    printf(\"! \");\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < N; j++) {\n            printf(\"%d\", status[i][j]);\n            if (i == 0 && j == N - 1) printf(\", \");\n        }\n    }\n    printf(\"\\n\");\n    fflush(stdout);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 16:00:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\n// Function to simulate the status of blackboard (for demonstration purposes)\nbool queryBlackboard(int row1, int col1, int row2, int col2) {\n    // Simulate some arbitrary condition on the blackboard\n    // You need to replace this with the actual device querying logic\n    return (rand() % 2) == 0;\n}\n\n// Printing a query and getting response from blackboard simulation\nbool query(int row1, int col1, int row2, int col2) {\n    cout << \"? \" << row1 << \" \" << col1 << \" \" << row2 << \" \" << col2 << endl;\n    cout.flush();\n    // Get response from blackboard\n    return queryBlackboard(row1, col1, row2, col2);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N; // Number of columns in the blackboard\n\n    int queryLimit = 420;\n    int queries = 0;\n\n    // Performing a binary search-like strategy to minimize queries\n    for (int i = 0; i < N && queries < queryLimit; ++i) {\n        // Querying each column for simplified demo purposes\n        bool status = query(1, i, 2, i);\n        ++queries;\n\n        if (queries >= queryLimit) {\n            cout << \"Query limit exceeded\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"Blackboard querying complete within the limit.\\n\";\n    return 0;\n}",
    "timestamp": "2025-08-13 16:01:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_rectangles(N):\n    board = [[0] * N for _ in range(2)]\n    queries = 0\n    max_queries = 420\n\n    def query(r1, c1, r2, c2):\n        nonlocal queries\n        queries += 1\n        print(f\"? {r1+1} {c1+1} {r2+1} {c2+1}\")\n        flush()\n        response = input().strip()\n        return response == \"YES\"\n\n    def mark_rectangle(r1, c1, r2, c2):\n        for r in range(r1, r2+1):\n            for c in range(c1, c2+1):\n                board[r][c] = 1\n\n    # Try to find all possible rectangles efficiently\n    for width in range(1, N+1):\n        for height in range(1, 3):\n            for start_col in range(N - width + 1):\n                for start_row in range(2 - height + 1):\n                    if queries >= max_queries:\n                        return\n\n                    if not any(board[r][c] for r in range(start_row, start_row+height)\n                               for c in range(start_col, start_col+width)):\n                        if query(start_row, start_col, start_row+height-1, start_col+width-1):\n                            mark_rectangle(start_row, start_col, start_row+height-1, start_col+width-1)\n\n    # Ensure all cells are queried if not already\n    for r in range(2):\n        for c in range(N):\n            if board[r][c] == 0:\n                if query(r, c, r, c):\n                    board[r][c] = 1\n\ndef flush():\n    import sys\n    sys.stdout.flush()\n\ndef main():\n    N = int(input())\n    find_rectangles(N)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 16:01:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef main():\n    N = int(sys.stdin.readline())\n    queries = 0\n    max_queries = 420\n    blackboard = [['?'] * (N + 2) for _ in range(3)]  # 1-based indexing, rows 1 and 2\n    \n    # We'll try to find contiguous blocks column by column\n    for col in range(1, N + 1):\n        if queries >= max_queries:\n            break\n        # Query the two cells in the current column\n        print(f\"? 1 {col} 2 {col}\")\n        sys.stdout.flush()\n        queries += 1\n        res = sys.stdin.readline().strip()\n        if res == '0':\n            blackboard[1][col] = '0'\n            blackboard[2][col] = '0'\n        elif res == '1':\n            # Need to find which one is 1\n            print(f\"? 1 {col} 1 {col}\")\n            sys.stdout.flush()\n            queries += 1\n            res1 = sys.stdin.readline().strip()\n            if res1 == '1':\n                blackboard[1][col] = '1'\n                blackboard[2][col] = '0'\n            else:\n                blackboard[1][col] = '0'\n                blackboard[2][col] = '1'\n        else:\n            # Both are 1\n            blackboard[1][col] = '1'\n            blackboard[2][col] = '1'\n    \n    # Now reconstruct the answer\n    print(\"!\", end=' ')\n    for row in [1, 2]:\n        for col in range(1, N + 1):\n            print(blackboard[row][col], end='')\n    print()\n    sys.stdout.flush()\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 16:01:23"
  }
]