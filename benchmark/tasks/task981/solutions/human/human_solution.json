[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n//#define ln cout<<'\\n'\n#define ln cout<<endl\ntemplate<C T>void pr(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n;\n  R n;\n  string s[2]={\"\",\"\"};\n  char b[2]={'.','#'};\n  bool f=0;\n  while(1) {\n    rep(i,4) {\n      if(!f) pr(s[0]+b[i&1]);\n      else pr(b[i&1]+s[0]);\n      if(!f) pr(s[1]+b[i&2]);\n      else pr(b[i&2]+s[1]);\n      char c;\n      R c;\n      if(c=='T') {\n        if(!f) s[0]=s[0]+b[i&1];\n        else s[0]=b[i&1]+s[0];\n        if(!f) s[1]=s[1]+b[i&2];\n        else s[1]=b[i&2]+s[1];\n        goto next;\n      } else if(c=='F') continue;\n      else return;\n    }\n    f=1;\n  next:;\n  } \n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nclass DLongBlackboard {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      deque<char> s1, s2;\n      vector<char> v1 = {'.', '.', '#', '#'};\n      vector<char> v2 = {'.', '#', '.', '#'};\n      bool flag = false;\n      while(true) {\n        if (!flag) {\n          bool found = false;\n          rep(i, 4) {\n            s1.push_back(v1[i]);\n            s2.push_back(v2[i]);\n            for(auto c: s1) {\n              cout << c;\n            }\n            cout << endl;\n            for(auto c: s2) {\n              cout << c;\n            }\n            cout << endl;\n            string r; cin >> r;\n            if (r == \"end\") {\n              return;\n            } else if (r == \"T\") {\n              found = true;\n              break;\n            } else {\n              s1.pop_back();\n              s2.pop_back();\n            }\n          }\n          if (!found) {\n            flag = true;\n          }\n        } else {\n          rep(i, 4) {\n            s1.push_front(v1[i]);\n            s2.push_front(v2[i]);\n            for(auto c: s1) {\n              cout << c;\n            }\n            cout << endl;\n            for(auto c: s2) {\n              cout << c;\n            }\n            cout << endl;\n            string r; cin >> r;\n            if (r == \"end\") {\n              return;\n            } else if (r == \"T\") {\n              break;\n            } else {\n              s1.pop_front();\n              s2.pop_front();\n            }\n          }\n        }\n      }\n    }\n};\n\nsigned main() {\n  DLongBlackboard solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n\tll n;\n\tcin>>n;\n\tstring input =\"\";\n\tstring s1 =\"..##\";\n\tstring s2 =\"..##\";\n\tstring ans1 = \"\" , ans2=\"\";\n\t\tbool balik = 1;\n\twhile(input != \"end\")\n\t{\n\t\tfor(int i = 0; i  < 4;  i++)\n\t\t{\n\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\ttemp1 += s1[i];\n\t\t\ttemp2 += s2[i];\n\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\tfflush(stdout);\n\t\t\tcin>>input;\n\t\t\tif(input == \"end\") return 0;\n\t\t\tif(input == \"T\" || input == \"end\")\n\t\t\t{\n\t\t\t\tans1 = temp1;\n\t\t\t\tans2 = temp2;\n\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( i == 3)\n\t\t\t\t{\n\t\t\t\t\tbalik = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(balik == 0)\n\t\t{\n\t\t\tfor(int i = 0; i  < 4;  i++)\n\t\t\t{\n\t\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\t\ttemp1 = s1[i] + ans1;\n\t\t\t\ttemp2 = s2[i] + ans2;\n\t\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin>>input;\n\t\t\t\tif(input == \"end\") return 0;\n\t\t\t\tif(input == \"T\" )\n\t\t\t\t{\n\t\t\t\t\tans1 = temp1;\n\t\t\t\t\tans2 = temp2;\n\t\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif( i == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tbalik = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nstring f=\"\";\nstring s=\"\";\nstring df=\".#.#\";\nstring ds=\"..##\";\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tint i=0;\n\twhile(i<n){\n\t\tbool flag=false;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tstring ff=f+df[j];\n\t\t\tstring ss=s+ds[j];\n\t\t\tcout << ff << endl;\n\t\t\tcout << ss << endl;\n\t\t\tstring b;\n\t\t\tcin >> b;\n\t\t\tif(b==\"T\" || b==\"end\"){\n\t\t\t\tf=ff;\n\t\t\t\ts=ss;\n\t\t\t\ti++;\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag)break;\n\t}\n\twhile(i<n){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tstring ff=df[j]+f;\n\t\t\tstring ss=ds[j]+s;\n\t\t\tcout << ff << endl;\n\t\t\tcout << ss << endl;\n\t\t\tstring b;\n\t\t\tcin >> b;\n\t\t\tif(b==\"T\" || b==\"end\"){\n\t\t\t\tf=ff;\n\t\t\t\ts=ss;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nbool stop = false;\nvoid dfs(string s1, string s2, bool f) {\n    if (s1.size() == N) return;\n    if (stop) return;\n    string res;\n    bool f2 = false;\n    rep(i, 2) rep(j, 2) {\n        if (stop) return;\n        char c1 = i == 0 ? '.' : '#';\n        char c2 = j == 0 ? '.' : '#';\n        string t1, t2;\n        if (f) {\n            t1 = s1 + c1;\n            t2 = s2 + c2;\n        } else {\n            t1 = c1 + s1;\n            t2 = c2 + s2;\n        }\n        printf(\"%s\\n%s\\n\", t1.c_str(), t2.c_str());\n        fflush(stdout);\n        cin >> res;\n        if (res == \"end\") {\n            stop = true;\n            break;\n        }\n        if (res == \"T\") {\n            dfs(t1, t2, f);\n            f2 = true;\n        }\n        if (stop) return;\n    }\n    if (!f2) dfs(s1, s2, !f);\n}\nint main() {\n    cin >> N;\n    dfs(\"\", \"\", 1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\n#define int long long\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(a) (a).begin(), (a).end()\n#define PB push_back\n#define MP make_pair\n#define FST first\n#define SND second\n#define SZ(a) (signed)((a).size())\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\nconst int MOD = 1000000007;\nconst char ENDL = '\\n';\n\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\"  << \" \" << __FILE__ << endl;\n\nsigned main(void) {\n    ios::sync_with_stdio(false);\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.precision(10);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    string s1,s2;\n\n    string r;\n    int state=0;\n    while(r!=\"end\"){\n        if(r==\"T\"){\n            if(state<=3){\n                state=0;\n            }else{\n                state=4;\n            }\n        }else if(r==\"F\"){\n            if(state==3){\n                s1.erase(s1.end());\n                s2.erase(s1.end());\n            }\n            state++;\n        }\n        switch (state){\n            case 0:\n                s1+=\".\";\n                s2+=\".\";\n                break;\n            case 1:\n                s1.back()='.';\n                s2.back()='#';\n                break;\n            case 2:\n                s1.back()='#';\n                s2.back()='.';\n                break;\n            case 3:\n                s1.back()='#';\n                s2.back()='#';\n                break;\n            case 4:\n                s1.insert(0,\".\");\n                s2.insert(0,\".\");\n                break;\n            case 5:\n                s1.front()='.';\n                s2.front()='#';\n                break;\n            case 6:\n                s1.front()='#';\n                s2.front()='.';\n                break;\n            case 7:\n                s1.front()='#';\n                s2.front()='#';\n                break;\n        }\n        cout << s1 << ENDL << s2 << ENDL;\n        fflush(stdout);\n        cin >> r;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef pair<string, string>P;\ntypedef long long ll;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\nint main() {\n\tint n; cin >> n;\n\tset<P>po;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po.insert(P(s1, s2));\n\t}\n\tint cnt = 2;\n\twhile (1) {\n\t\tauto iter = po.end();\n\t\tfor (auto i = po.begin(); i != iter; i++) {\n\t\t\tfor (auto j = po.begin(); j != iter; j++) {\n\t\t\t\tP p1 = *i, p2 = *j;\n\t\t\t\tif (p1.first.size() + p2.first.size() == p1.second.size() + p2.second.size() && p1.first.size() + p2.second.size() == cnt) {\n\t\t\t\t\tcout << p1.first + p2.first << endl << p1.second + p2.second << endl;\n\t\t\t\t\tcin >> res;\n\t\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\t\tif (res == \"T\")po.insert(P(p1.first + p2.first, p1.second + p2.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst string u = \"#.\";\n\nint N;\nstring s[2];\n\nint main() {\n\tscanf(\"%d\", &N);\n\n\trep(i, N) {\n\t\trep(j, 4) {\n\t\t\ts[0].pb(u[j&1]);\n\t\t\ts[1].pb(u[(j/2)&1]);\n\t\t\tprintf(\"%s\\n%s\\n\", s[0].c_str(), s[1].c_str()); fflush(stdout);\n\t\t\tchar res[4];\n\t\t\tscanf(\"%s\", res);\n\t\t\tif (strcmp(res, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (res[0] == 'T') {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ts[0].pop_back();\n\t\t\t\ts[1].pop_back();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<string, string>P;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\ndeque<P>po[200];\nint main() {\n\tint n; cin >> n;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po[1].push_back(P(s1, s2));\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tint j = i / 2;\n\t\tfor (P p1 : po[j]) {\n\t\t\tfor (P p2 : po[i - j]) {\n\t\t\t\tcout << p1.first + p2.first << endl << p1.second + p2.second << endl;\n\t\t\t\tcin >> res;\n\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\tif (res == \"T\")po[i].push_back(P(p1.first + p2.first, p1.second + p2.second));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tstring s, t;\n\n\twhile (true) {\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tstring ns = s + (\"#.\")[i >> 0 & 1];\n\t\t\tstring nt = t + (\"#.\")[i >> 1 & 1];\n\t\t\tcout << ns << endl;\n\t\t\tcout << nt << endl;\n\t\t\tstring res;\n\t\t\tcin >> res;\n\t\t\tif (res == \"end\") return 0;\n\t\t\tif (res == \"T\") {\n\t\t\t\tok = true;\n\t\t\t\ts = ns;\n\t\t\t\tt = nt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok) continue;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tstring ns = (\"#.\")[i >> 0 & 1] + s;\n\t\t\tstring nt = (\"#.\")[i >> 1 & 1] + t;\n\t\t\tcout << ns << endl;\n\t\t\tcout << nt << endl;\n\t\t\tstring res;\n\t\t\tcin >> res;\n\t\t\tif (res == \"end\") return 0;\n\t\t\tif (res == \"T\") {\n\t\t\t\tok = true;\n\t\t\t\ts = ns;\n\t\t\t\tt = nt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nchar xx[] = {'.', '#', '.', '#'};\nchar yy[] = {'.', '.', '#', '#'};\n\nint main() {\n    int n; cin.ignore();\n    string s1 = \"\", s2 = \"\", q;\n    string t1 = \"\", t2 = \"\";\n    while(1) {\n        rep(i,0,4) {\n            t1 = s1; t2 = s2;\n            t1 += xx[i];\n            t2 += yy[i];\n            cout << t1 << endl << t2 << endl; fflush(stdout);\n            cin >> q;\n            if(q == \"end\") return 0;\n            else if(q == \"T\") {\n                s1 = t1;\n                s2 = t2;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <math.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nstruct edge {\n\tint to, cost;\n\tedge(int t,int c):to(t),cost(c) {}\n};\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\n//-----------------------------------------------------------------------------\n\nint n;\nstring s[2]={\"..##\",\".#.#\"};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin>>n;\n\tstring t[2];\n\tREP(i,4) {\n\t\tchar res;\n\t\tcout<<s[0][i]<<endl<<s[1][i]<<endl;\n\t\tcin>>res;\n\t\tif(res=='T') {\n\t\t\tt[0]=s[0][i],t[1]=s[1][i];\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (true) {\n\t\tbool flg=false;\n\t\tREP(j,4) {\n\t\t\tREP(i,2) {\n\t\t\t\tcout<<t[i]<<s[i][j]<<endl;\n\t\t\t}\n\t\t\tchar res;\n\t\t\tcin>>res;\n\t\t\tif(res=='T') {\n\t\t\t\tREP(k,2) t[k]+=s[k][j];\n\t\t\t\tflg=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flg||t[0].size()==n) break;\n\t}\n\tif(t[0].size()==n) {\n\t\tREP(i,2) cout<<t[i]<<endl;\n\t\treturn 0;\n\t}\n\twhile (true) {\n\t\tbool flg=false;\n\t\tREP(j,4) {\n\t\t\tREP(i,2) {\n\t\t\t\tcout<<s[i][j]<<t[i]<<endl;\n\t\t\t}\n\t\t\tchar res;\n\t\t\tcin>>res;\n\t\t\tif(res=='T') {\n\t\t\t\tREP(k,2) t[k]=s[k][j]+t[k];\n\t\t\t\tflg=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flg||t[0].size()==n) break;\n\t}\n\tREP(i,2) cout<<t[i]<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nusing vs=vector<string>;\n\nconst char status[]={'.', '#'};\n\nint send_query(vs &query, bool rightward) {\n    for (size_t i=0; i<4; ++i) {\n        if (rightward) {\n            printf(\"%s%c\\n\", query[0].c_str(), status[i&1]);\n            printf(\"%s%c\\n\", query[1].c_str(), status[i>>1]);\n        } else {\n            printf(\"%c%s\\n\", status[i&1], query[0].c_str());\n            printf(\"%c%s\\n\", status[i>>1], query[1].c_str());\n        }\n        fflush(stdout);\n\n        char buf[1<<2];\n        scanf(\"%s\", buf);\n        string ans=buf;\n\n        if (ans == \"end\") {\n            return 2;\n        } else if (ans == \"T\") {\n            if (rightward) {\n                query[0] += status[i&1];\n                query[1] += status[i>>1];\n            } else {\n                query[0] = status[i&1] + query[0];\n                query[1] = status[i>>1] + query[1];\n            }\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    size_t N;\n    scanf(\"%zu\", &N);\n\n    vs query(2);\n    for (int i=0; i<2;)\n        i += send_query(query, i);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nchar s[SIZE];\nint main(){\n    DRI(N);\n    string up,dn;\n    bool right=1;\n    while(SZ(up)<N){\n        if(!right){\n            up=\".\"+up;\n            dn=\".\"+dn;\n        }\n        if(right){\n            up+=\".\";\n            dn+=\".\";\n            cout<<up<<endl<<dn<<endl;\n            fflush(stdout);\n            RS(s);\n            if(s[0]!='F')continue;\n\n            up[SZ(up)-1]='#';\n            cout<<up<<endl<<dn<<endl;\n            fflush(stdout);\n            RS(s);\n            if(s[0]!='F')continue;\n            \n            dn[SZ(dn)-1]='#';\n            cout<<up<<endl<<dn<<endl;\n            fflush(stdout);\n            RS(s);\n            if(s[0]!='F')continue;\n            \n            up[SZ(up)-1]='.';\n            cout<<up<<endl<<dn<<endl;\n            fflush(stdout);\n            RS(s);\n            if(s[0]!='F')continue;\n            right=0;\n            up=\".\"+up.substr(0,SZ(up)-1);\n            dn=\".\"+dn.substr(0,SZ(dn)-1);\n        }\n        cout<<up<<endl<<dn<<endl;\n        fflush(stdout);\n        RS(s);\n        if(s[0]!='F')continue;\n        \n        up[0]='#';\n        cout<<up<<endl<<dn<<endl;\n        fflush(stdout);\n        RS(s);\n        if(s[0]!='F')continue;\n\n        dn[0]='#';\n        cout<<up<<endl<<dn<<endl;\n        fflush(stdout);\n        RS(s);\n        if(s[0]!='F')continue;\n\n        up[0]='.';\n        cout<<up<<endl<<dn<<endl;\n        fflush(stdout);\n        RS(s);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nchar a[3] = {'.','#'};\n\nsigned main()\n{ // #define int long long をしてるのでscanfを使うと意味不明な値が入力され死にます\n    int N; cin >> N;\n\n    string S[2];\n\n    bool r = true; // 右に伸ばしているか\n\n    while (true) {\n        if (r) {\n            bool f = true;\n\n            S[0] += ' ';\n            S[1] += ' ';\n\n            int pos = S[0].size() - 1;\n\n            rep(i, 2) rep(j, 2) {\n                S[0][pos] = a[i];\n                S[1][pos] = a[j];\n\n                cout << S[0] << endl;\n                cout << S[1] << endl;\n\n                char C; cin >> C;\n\n                if (C == 'T') {\n                    f = false;\n                    goto nxt1;\n                }\n            }\n\n            if (f) {\n                r = false;\n            }\n\nnxt1:;\n        } else {\n            bool f = true;\n\n            string T[2];\n\n            T[0] += ' ';\n            T[0] += S[0];\n            T[1] += ' ';\n            T[1] += S[1];\n\n            rep(i, 2) rep(j, 2) {\n                T[0][0] = a[i];\n                T[1][0] = a[j];\n\n                cout << T[0] << endl;\n                cout << T[1] << endl;\n\n                char C; cin >> C;\n\n                if (C == 'T') {\n                    f = false;\n                    goto nxt2;\n                }\n            }\n\n            if (f) {\n                break;\n            }\n\n            S[0] = T[0];\n            S[1] = T[1];\nnxt2:;\n        }\n    }\n\n    cout << S[0] << endl;\n    cout << S[1] << endl;\n\n    string s; cin >> s;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include<map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\nusing namespace std;\n#define MAX_MOD 1000000007\n#define REP(i,n) for(int i = 0;i < n;++i)\n#define LONGINF 1000000000000000000\nint main(){\n\tint n;\n\tcin >> n;\n\tstring ans_top_second, ans_top_first, ans_bot_first, ans_bot_second;\n\tstring returnings;\n\twhile (true) {\n\trooped:;\n\t\tcout << ans_top_second + '.' << endl;\n\t\tcout << ans_bot_second + '.' << endl;\n\t\tcin >> returnings;\n\t\tif (returnings == \"end\") return 0;\n\t\tif (returnings == \"T\") {\n\t\t\tans_top_second.push_back('.');\n\t\t\tans_bot_second.push_back('.');\n\t\t\tgoto rooped;\n\t\t}\n\t\tcout << ans_top_second + '#' << endl;\n\t\tcout << ans_bot_second + '.' << endl;\n\t\tcin >> returnings;\n\t\tif (returnings == \"end\") return 0;\n\t\tif (returnings == \"T\") {\n\t\t\tans_top_second.push_back('#');\n\t\t\tans_bot_second.push_back('.');\n\t\t\tgoto rooped;\n\t\t}\n\t\tcout << ans_top_second + '#' << endl;\n\t\tcout << ans_bot_second + '#' << endl;\n\t\tcin >> returnings;\n\t\tif (returnings == \"end\") return 0;\n\t\tif (returnings == \"T\") {\n\t\t\tans_top_second.push_back('#');\n\t\t\tans_bot_second.push_back('#');\n\t\t\tgoto rooped;\n\t\t}\n\t\tcout << ans_top_second + '.' << endl;\n\t\tcout << ans_bot_second + '#' << endl;\n\t\tcin >> returnings;\n\t\tif (returnings == \"end\") return 0;\n\t\tif (returnings == \"T\") {\n\t\t\tans_top_second.push_back('.');\n\t\t\tans_bot_second.push_back('#');\n\t\t\tgoto rooped;\n\t\t}\n\t\tgoto right_over;\n\t}\nright_over:;\n\twhile (true) {\n\tloool:;\n\t\tcout << '.' + ans_top_first + ans_top_second << endl;\n\t\tcout << '.' + ans_bot_first + ans_bot_second << endl;\n\t\tcin >> returnings;\n\t\tif (returnings == \"end\") return 0;\n\t\tif (returnings == \"T\") {\n\t\t\tans_top_first.insert(0, \".\");\n\t\t\tans_bot_first.insert(0, \".\");\n\t\t\tgoto loool;\n\t\t}\n\t\tcout << '.' + ans_top_first + ans_top_second << endl;\n\t\tcout << '#' + ans_bot_first + ans_bot_second << endl;\n\t\tcin >> returnings;\n\t\tif (returnings == \"end\") return 0;\n\t\tif (returnings == \"T\") {\n\t\t\tans_top_first.insert(0, \".\");\n\t\t\tans_bot_first.insert(0, \"#\");\n\t\t\tgoto loool;\n\t\t}\n\t\tcout << '#' + ans_top_first + ans_top_second << endl;\n\t\tcout << '.' + ans_bot_first + ans_bot_second << endl;\n\t\tcin >> returnings;\n\t\tif (returnings == \"end\") return 0;\n\t\tif (returnings == \"T\") {\n\t\t\tans_top_first.insert(0, \"#\");\n\t\t\tans_bot_first.insert(0, \".\");\n\t\t\tgoto loool;\n\t\t}\n\t\tcout << '#' + ans_top_first + ans_top_second << endl;\n\t\tcout << '#' + ans_bot_first + ans_bot_second << endl;\n\t\tcin >> returnings;\n\t\tif (returnings == \"end\") return 0;\n\t\tif (returnings == \"T\") {\n\t\t\tans_top_first.insert(0, \"#\");\n\t\t\tans_bot_first.insert(0, \"#\");\n\t\t\tgoto loool;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n#define fi first\n#define se second\n\ntypedef long long LL;\n\nconst double EPS=1e-9;\nconst double PI=acos(-1.0);\nconst int MAXN=100005;\nconst LL MOD=1000000007;\nconst int dx[8]={-1, 0, 1, -1, 1, -1, 0, 1}, dy[8]={-1, -1, -1, 0, 0, 1, 1, 1};\n\nvoid base(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n}\n\nint stat;\n\nint main(){\n\tbase();\n\tint n;\n\tbool rev=0;\n\tstring stat;\n\tstring s1=\"\", s2=\"\";\n\tcin>>n;\n\twhile(1){\n\t\tif(!rev){\n\t\t\tcout<<s1<<'.'<<endl;\n\t\t\tcout<<s2<<'.'<<endl;\n\t\t\tcin>>stat;\n\t\t\tif(stat==\"end\") return 0;\n\t\t\tif(stat==\"T\"){\n\t\t\t\ts1=s1+'.';\n\t\t\t\ts2=s2+'.';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<s1<<'#'<<endl;\n\t\t\tcout<<s2<<'.'<<endl;\n\t\t\tcin>>stat;\n\t\t\tif(stat==\"end\") return 0;\n\t\t\tif(stat==\"T\"){\n\t\t\t\ts1=s1+'#';\n\t\t\t\ts2=s2+'.';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<s1<<'.'<<endl;\n\t\t\tcout<<s2<<'#'<<endl;\n\t\t\tcin>>stat;\n\t\t\tif(stat==\"end\") return 0;\n\t\t\tif(stat==\"T\"){\n\t\t\t\ts1=s1+'.';\n\t\t\t\ts2=s2+'#';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<s1<<'#'<<endl;\n\t\t\tcout<<s2<<'#'<<endl;\n\t\t\tcin>>stat;\n\t\t\tif(stat==\"end\") return 0;\n\t\t\tif(stat==\"T\"){\n\t\t\t\ts1=s1+'#';\n\t\t\t\ts2=s2+'#';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trev=1;\n\t\t}\n\t\telse{\n\t\t\tcout<<'.'<<s1<<endl;\n\t\t\tcout<<'.'<<s2<<endl;\n\t\t\tcin>>stat;\n\t\t\tif(stat==\"end\") return 0;\n\t\t\tif(stat==\"T\"){\n\t\t\t\ts1='.'+s1;\n\t\t\t\ts2='.'+s2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<'#'<<s1<<endl;\n\t\t\tcout<<'.'<<s2<<endl;\n\t\t\tcin>>stat;\n\t\t\tif(stat==\"end\") return 0;\n\t\t\tif(stat==\"T\"){\n\t\t\t\ts1='#'+s1;\n\t\t\t\ts2='.'+s2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<'.'<<s1<<endl;\n\t\t\tcout<<'#'<<s2<<endl;\n\t\t\tcin>>stat;\n\t\t\tif(stat==\"end\") return 0;\n\t\t\tif(stat==\"T\"){\n\t\t\t\ts1='.'+s1;\n\t\t\t\ts2='#'+s2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcout<<'#'<<s1<<endl;\n\t\t\tcout<<'#'<<s2<<endl;\n\t\t\tcin>>stat;\n\t\t\tif(stat==\"end\") return 0;\n\t\t\tif(stat==\"T\"){\n\t\t\t\ts1='#'+s1;\n\t\t\t\ts2='#'+s2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trev=0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nusing vs=vector<string>;\n\nconst char status[]={'.', '#'};\n\nint send_query(vs &query, bool rightward) {\n    for (size_t i=0; i<4; ++i) {\n        if (rightward) {\n            printf(\"%s%c\\n\", query[0].c_str(), status[i&1]);\n            printf(\"%s%c\\n\", query[1].c_str(), status[i>>1]);\n        } else {\n            printf(\"%c%s\\n\", status[i&1], query[0].c_str());\n            printf(\"%c%s\\n\", status[i>>1], query[1].c_str());\n        }\n        fflush(stdout);\n\n        char buf[1<<2];\n        scanf(\"%s\", buf);\n        string ans=buf;\n\n        if (ans == \"end\") {\n            return -1;\n        } else if (ans == \"T\") {\n            if (rightward) {\n                query[0] += status[i&1];\n                query[1] += status[i>>1];\n            } else {\n                query[0] = status[i&1] + query[0];\n                query[1] = status[i>>1] + query[1];\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    size_t N;\n    scanf(\"%zu\", &N);\n\n    vs query(2);\n    for (int i=0; i<2;) {\n        int ans=send_query(query, i);\n        if (ans == -1) {\n            return 0;\n        } else if (ans == 0) {\n            ++i;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tstring atas = \"\";\n\tstring bawah = \"\";\n\t\n\tchar in_buffer[10] = {};\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas = '.' + atas;\n\t\tbawah = '.' + bawah;\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[0] = tempatas[j];\n\t\t\tbawah[0] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tfflush(stdout);\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint len = atas.length();\n\tfor(len++; len <= n; len++) {\n\t\tatas = atas + '.';\n\t\tbawah = bawah + '.';\n\t\t\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[len-1] = tempatas[j];\n\t\t\tbawah[len-1] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tfflush(stdout);\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nchar x[] = {'#','#','.','.'};\nchar y[] = {'#','.','#','.'};\nchar buf[125];\n\nint main(){\n  int n;\n  scanf(\"%d\",&n);\n  string a,b;\n  bool go = true;\n  REP(i,n){\n    bool flag = false;\n    if(go){\n      REP(j,4){\n        string c,d;\n        c=a+x[j];\n        d=b+y[j];\n        printf(\"%s\\n%s\\n\",c.c_str(),d.c_str());\n        fflush(stdout);\n        scanf(\"%s\",buf);\n        if(buf[0]=='e')return 0;\n        if(buf[0]=='T'){\n          a=c;\n          b=d;\n          flag=true;\n          break;\n        }\n      }\n    }else{\n      REP(j,4){\n        string c,d;\n        c=x[j]+a;\n        d=y[j]+b;\n        printf(\"%s\\n%s\\n\",c.c_str(),d.c_str());\n        fflush(stdout);\n        scanf(\"%s\",buf);\n        if(buf[0]=='e')return 0;\n        if(buf[0]=='T'){\n          a=c;\n          b=d;\n          flag=true;\n          break;\n        }\n      }\n    }\n    if(!flag){\n      go=false;\n      --i;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//TEST_CODE\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8101145141919364364;\n\nint main(){\n\tint n; cin>>n;\n\tstring r,s1,s2;\n\tstring eins[]={\".\",\".\",\"#\",\"#\"};\n\tstring zwei[]={\".\",\"#\",\".\",\"#\"};\n\tbool side=1;\n\twhile(1){\n\t\trep(i,4){\n\t\t\tstring tmp1=(side?s1+eins[i]:eins[i]+s1);\n\t\t\tstring tmp2=(side?s2+zwei[i]:zwei[i]+s2);\n\t\t\tcout<<tmp1<<\"\\n\"<<tmp2<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>r;\n\t\t\tif(r==\"end\") return 0;\n\t\t\tif(r==\"T\"){\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tif(s1.size()==n)\n\t\t\t\t{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else if(i==3){\n\t\t\t\tside=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> void chmax(T& a,const T& b){if(a < b) a = b;}\ntemplate<typename T> void chmin(T& a,const T& b){if(b < a) a = b;}\ntypedef long long ll;\n\nint N,K = 420;\nchar ch [] = {'.','#'};\n\nint main()\n{\n\tcin >> N;\n\n\tstring S,T;\n\tint i;\n\tfor(i = 0;i < 420;i++){\n\t\tbool flag = false;\n\t\tFOR(j,0,4){\n\t\t\tstring r;\n\t\t\tcout << S + ch [j / 2] << endl;\n\t\t\tcout << T + ch [j % 2] << endl;\n\t\t\tfflush(stdout);\n\t\t\tcin >> r;\n\t\t\tif(r == \"end\"){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if(r == \"T\"){\n\t\t\t\tS += ch [j / 2];\n\t\t\t\tT += ch [j % 2];\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag == false){\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(;i < 420;i++){\n\t\tFOR(j,0,4){\n\t\t\tstring r;\n\t\t\tcout << ch [j / 2] + S << endl;\n\t\t\tcout << ch [j % 2] + T << endl;\n\t\t\tfflush(stdout);\n\t\t\tcin >> r;\n\t\t\tif(r == \"end\"){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if(r == \"T\"){\n\t\t\t\tS = ch [j / 2] + S;\n\t\t\t\tT = ch [j % 2] + T;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    vector<string> s(2);\n    bool isRight = true;\n    for(int i=0; i<n; ++i){\n        for(int j=0; ; ++j){\n            vector<string> t(2);\n            if(isRight){\n                t[0] = s[0] + ((j & 1) ? '#' : '.');\n                t[1] = s[1] + ((j & 2) ? '#' : '.');\n            }\n            else{\n                t[0] = ((j & 1) ? '#' : '.') + s[0];\n                t[1] = ((j & 2) ? '#' : '.') + s[1];\n            }\n\n            cout << t[0] << endl << t[1] << endl;\n            string input;\n            cin >> input;\n            if(input == \"T\" || input == \"end\"){\n                s = t;\n                break;\n            }\n            if(j == 3)\n                isRight = false;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\n\nstring S0[4] = {\".\", \"#\", \".\", \"#\"};\nstring S1[4] = {\".\", \".\", \"#\", \"#\"};\n\nint main(){\n\tcin >> N;\n\tlong long len = 0;\n\tbool right = true;\n\tlong long tmp = 0;\n\n\tstring s0 = \"\";\n\tstring s1 = \"\";\n\n\twhile(1){\n\t\tstring S;\n\n\t\tif(right == true){\n\t\t\tcout << s0 << S0[tmp] << endl;\n\t\t\tcout << s1 << S1[tmp] << endl;\n\t\t}else{\n\t\t\tcout << S0[tmp] << s0 << endl;\n\t\t\tcout << S1[tmp] << s1 << endl;\n\t\t}\n\n\t\tcin >> S;\n\t\tif(S == \"F\"){\n\t\t\ttmp++;\n\t\t\tif(tmp == 4){\n\t\t\t\ttmp = 0;\n\t\t\t\tright = false;\n\t\t\t}\n\t\t}else if(S == \"end\"){\n\t\t\tbreak;\n\t\t}else{\n\t\t\tif(right == true){\n\t\t\t\ts0 += S0[tmp];\n\t\t\t\ts1 += S1[tmp];\n\t\t\t}else{\n\t\t\t\ts0 = S0[tmp] + s0;\n\t\t\t\ts1 = S1[tmp] + s1;\n\t\t\t}\n\t\t\ttmp = 0;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef pair<string, string>P;\ntypedef long long ll;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\nint main() {\n\tint n; cin >> n;\n\tset<P>po;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po.insert(P(s1, s2));\n\t}\n\tint cnt = 2;\n\twhile (1) {\n\t\tauto iter = po.end();\n\t\tfor (auto i = po.begin(); i != iter; i++) {\n\t\t\tfor (auto j = po.begin(); j != iter; j++) {\n\t\t\t\tP p1 = *i, p2 = *j;\n\t\t\t\tif (p1.first.size() + p2.first.size() == p1.second.size() + p2.second.size() && p1.first.size() + p2.first.size() == cnt) {\n\t\t\t\t\tcout << p1.first + p2.first << endl << p1.second + p2.second << endl;\n\t\t\t\t\tcin >> res;\n\t\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\t\tif (res == \"T\")po.insert(P(p1.first + p2.first, p1.second + p2.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst string dot_and_sharp[2] = {\".\", \"#\"};\n\nint main(){\n    int N;\n    cin >> N;\n    string space[2] = {\"\", \"\"};\n    bool if_push_right = true;\n    while(space[0].size() != N){\n        bool if_input_true = false;\n        for(int i = 0; i < 4; i++){\n            if(if_push_right){\n                cout << space[0] + dot_and_sharp[i % 2] << endl;\n                cout << space[1] + dot_and_sharp[i / 2] << endl;\n            }else{\n                cout << dot_and_sharp[i % 2] + space[0] << endl;\n                cout << dot_and_sharp[i / 2] + space[1] << endl;\n            }\n            string if_right;\n            cin >> if_right;\n            if(if_right == \"end\"){\n                return 0;\n            }else if(if_right == \"T\"){\n                if(if_push_right){\n                    space[0] += dot_and_sharp[i % 2];\n                    space[1] += dot_and_sharp[i / 2];\n                }else{\n                    space[0] = dot_and_sharp[i % 2] + space[0];\n                    space[1] = dot_and_sharp[i / 2] + space[1];\n                }\n                if_input_true = true;\n                break;\n            }\n        }\n        if(!if_input_true){\n            if_push_right = false;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nchar xx[] = {'.', '#', '.', '#'};\nchar yy[] = {'.', '.', '#', '#'};\n\nint main() {\n    int n; cin.ignore();\n    string s1, s2, q;\n    while(1) {\n        string t1, t2;\n        rep(i,0,4) {\n            t1 = s1; t2 = s2;\n            t1 += xx[i];\n            t2 += yy[i];\n            printf(\"%s\\n%s\\n\", t1, t2); fflush(stdout);\n            cin >> q;\n            if(q == \"end\") return 0;\n            else if(q == \"T\") {\n                s1 = t1;\n                s2 = t2;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst char s1[4] = { '.', '#', '.', '#'};\nconst char s2[4] = { '.', '.', '#', '#'};\n\nbool found;\nset<string> exclusion;\n\nvoid dfs(int depth, string t1, string t2){\n\tif (depth >= 110) return;\n\tif (found) return;\n\n\trep (i, 4){\n\t\tstring u1 = t1 + s1[i];\n\t\tstring u2 = t2 + s2[i];\n\t\tif (exclusion.count(u1+u2)) continue;\n\t\tcout << u1 << endl;\n\t\tcout << u2 << endl;\n\t\tfflush(stdout);\n\t\texclusion.insert(u1+u2);\n\t\tstring ans; cin >> ans;\n\t\tif (ans[0] == 'F')\n\t\t\tcontinue;\n\t\tif (ans == \"end\"){\n\t\t\tfound = true;\n\t\t\treturn;\n\t\t} // end if\n\t\t// if (ans[0] == 'T')\n\t\tdfs(depth + 1, u1, u2);\n\t} // end rep \n}\n \nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N; cin >> N;\n\texclusion.clear();\n\tfound = false;\n\tdfs(0, \"\", \"\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstring query(pair<string,string> p1,pair<string,string> p2){\n  string s1,s2;\n  s1 = p1.first + p2.first;\n  s2 = p1.second + p2.second;\n  printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n  string str;\n  cin >> str;\n  return str;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  vector<pair<string,string> >vec;\n  for(int i = 0 ; i < 2 ; i++){\n    string str1;\n    string str2;\n    for(int j = 0 ; j < 4 ; j++){\n      str1 += (j%2?\".\":\"#\");\n      str2 += ((j >> 1)%2?\".\":\"#\");\n    }\n    vec.push_back(make_pair(str1,str2));\n  }\n  \n  while(1){\n    for(int i = 0 ; i < vec.size() ; i++){\n      for(int j = i ; j < vec.size() ; j++){\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  string r;\n\t  pair<string,string>p;\n\t  if(k % 2){\n\t    r = query(vec[i],vec[j]);\n\t    p = make_pair(vec[i].first + vec[j].first,vec[i].second + vec[j].second);\n\t  }\n\t  else {\n\t    r = query(vec[j],vec[i]);\n\t    p = make_pair(vec[j].first + vec[i].first,vec[j].second + vec[i].second);\n\t  }\n\t  // in\n\t  if(r == \"T\"){\n\t    vec.push_back(p);\n\t  }\n\t  else if(r == \"end\"){\n\t    return 0;\n\t  }\n\t}\n      }\n    }\n  }\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nstatic const double EPS = 1e-8;\nstatic const double PI = 4.0 * atan(1.0);\nbool ISINT(double x){return fabs(x-(int)round(x))<EPS;}\nbool ISEQ(double x,double y){return fabs(x-y)<EPS;}\nstring itos(ll x){stringstream ss;ss<<x;return ss.str();}\n#define foreach(itr,c) for(__typeof(c.begin()) itr=c.begin();itr!=c.end();itr++)\n\nbool check(const string &s1, const string &s2) {\n  printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str());\n  fflush(stdout);\n\n  char res_c[128];\n  scanf(\"%s\", res_c);\n\n  string res(res_c);\n  \n  if (res == \"T\" || res == \"end\") {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  string pat1 = \"..##\";\n  string pat2 = \".#.#\";\n  \n  int N;\n  \n  scanf(\"%d\", &N);\n\n  bool rightFlg = true;\n  string s1 = \"\";\n  string s2 = \"\";\n\n  while (s1.size() < N) {\n    // 右側にくっつける\n    if (rightFlg) {\n      bool success = false;\n      \n      for (int i = 0; i < 4; i++) {\n        string ts1 = s1;\n        ts1 += pat1[i];\n        string ts2 = s2;\n        ts2 += pat2[i];\n\n        if (check(ts1, ts2)) {\n          s1 = ts1;\n          s2 = ts2;\n          success = true;\n          break;\n        }\n      }\n      if (success) {\n        continue;\n      } else {\n        rightFlg = false;\n      }\n    }\n\n    // 左側にくっつける\n    bool success = false;\n      \n    for (int i = 0; i < 4; i++) {\n      string ts1 = \"\";\n      ts1 += pat1[i];\n      ts1 += s1;\n      string ts2 = \"\";\n      ts2 += pat2[i];\n      ts2 += s2;\n\n      if (check(ts1, ts2)) {\n        s1 = ts1;\n        s2 = ts2;\n        success = true;\n        break;\n      }\n    }\n    if (success) {\n      continue;\n    } else {\n      // ありえないやつ\n      while (true) {}\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for (int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for (int (i) = (a) - 1; (i) >= (b); (i)--)\n#define PI acos(-1.0)\n#define DEBUG(C) cout<< C <<endl;\n#define VI vector <int>\n#define VII vector <VI>\n#define VL vector <LL>\n#define VLL vector <VL>\n#define VD vector <double>\n#define VDD vector <VD>\n#define PII pair <int, int>\n#define PDD pair <double, double>\n#define PLL pair <LL, LL>\n#define VPII vector <PII>\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define REVERSE(a) reverse(ALL(a))\n#define MP make_pair\n#define EB emplace_back\n#define FORE(a, b) for (auto &&a:b)\n#define FIND(s, n) (s.find(n) != s.end())\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int INF = 1e9;\nconst int MOD = INF + 7;\n\nstring cc[2];\n\nint main(void) {\n    cc[0] = \"..##\";\n    cc[1] = \".#.#\";\n    int N; cin >> N;\n    vector <string> S(2, \"\"), Sbuf(2);\n    int cnt = 0;\n    S[0] += cc[0][0];\n    S[1] += cc[1][0];\n    REP(_, 420) {\n        printf(\"%s\\n%s\\n\", S[0].c_str(), S[1].c_str());\n        string c; cin >> c;\n        if (c == \"T\") {\n            Sbuf = S;\n            cnt = 0;\n            REP(i, 2) {\n                S[i] += cc[i][cnt];\n            }\n        } else if (c == \"F\") {\n            S = Sbuf;\n            cnt++;\n            if (cnt >= 4) {\n                REP(i, 2) {\n                    S[i] = cc[i][cnt % 4] + S[i];\n                }\n            } else {\n                REP(i, 2) {\n                    S[i] += cc[i][cnt % 4];\n                }\n            }\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstring temp = \".#\";\n\nint main()\n{\n  int N;\n  cin >> N;\n\n  string Low, High;\n  bool left = false;\n  bool right = false;\n\n  while(Low.size() + 2 < N) {\n    if(!left) {\n      for(char c : temp) {\n        for(char d : temp) {\n          for(char e : temp) {\n            for(char f : temp) {\n              string U = Low + string(1, c) + string(1, d);\n              string E = High + string(1, e) + string(1, f);\n              cout << U << endl;\n              cout << E << endl;\n              char cc;\n              cin >> cc;\n              if(cc == 'T') {\n                Low = U;\n                High = E;\n                goto foo;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    left = true;\n\n    if(!right) {\n      for(char c : temp) {\n        for(char d : temp) {\n          for(char e : temp) {\n            for(char f : temp) {\n              string U = string(1, c) + string(1, d) + Low;\n              string E = string(1, e) + string(1, f) + High;\n              cout << U << endl;\n              cout << E << endl;\n              char cc;\n              cin >> cc;\n              if(cc == 'T') {\n                Low = U;\n                High = E;\n                goto foo;\n              }\n            }\n          }\n        }\n      }\n    }\n    right = true;\n\n    if(left && right) {\n      for(char c : temp) {\n        for(char d : temp) {\n          for(char e : temp) {\n            for(char f : temp) {\n              string U = string(1, c) + string(1, d) + Low;\n              string E = string(1, e) + string(1, f) + High;\n              cout << U << endl;\n              cout << E << endl;\n              char cc;\n              cin >> cc;\n              if(cc == 'T') {\n                Low = U;\n                High = E;\n                goto foo;\n              }\n            }\n          }\n        }\n      }\n    }\n    foo:;\n  }\n\n  if(Low.size() + 1 == N) {\n    for(char c : temp) {\n      for(char e : temp) {\n        string U = Low + string(1, c);\n        string E = High + string(1, e);\n        cout << U << endl;\n        cout << E << endl;\n        char cc;\n        cin >> cc;\n        if(cc == 'T') {\n          Low = U;\n          High = E;\n          goto hoge;\n        }\n      }\n    }\n    for(char c : temp) {\n      for(char e : temp) {\n        string U = string(1, c) + Low;\n        string E = string(1, e) + High;\n        cout << U << endl;\n        cout << E << endl;\n        char cc;\n        cin >> cc;\n        if(cc == 'T') {\n          Low = U;\n          High = E;\n          goto hoge;\n        }\n      }\n    }\n    hoge:;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nconst string st = \".#\";\n\nint f(deque<int>& a) {\n  string s, t;\n  rep(i,sz(a)) {\n    s += st[a[i]&1];\n    t += st[a[i]>>1&1];\n  }\n  cout<<s<<endl;\n  cout<<t<<endl;\n  cin >> s;\n  if (s == \"end\") return -1;\n  return s == \"T\";\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  deque<int> a;\n  rep(i,n) {\n    a.pb(0);\n    for (; a.back() < 4; ++a.back()) {\n      int res = f(a);\n      if (res == -1) return 0;\n      if (res) break;\n    }\n    if (a.back() == 4) {\n      a.pop_back();\n      break;\n    }\n  }\n  rep(i,n) {\n    a.push_front(0);\n    for (; a[0] < 4; ++a[0]) {\n      int res = f(a);\n      if (res == -1) return 0;\n      if (res) break;\n    }\n    if (a[0] == 4) {\n      assert(false);\n    }\n  }\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool check(ll x, ll y, ll xMax, ll yMax) { return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toint(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string tostring(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntemplate<class T> inline T mypow(T x, ll n) { T res = 1; while (n > 0) { if (n & 1)res = res * x;\tx = x * x;\tn >>= 1; }return res; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define tostr(a)\ttostring(a)\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e17 + 9;\n\n#define int ll\n#define double ld\n\nbool query(deque<char> d1, deque<char> d2) {\n\tstring s1, s2;\n\teach(i, d1)s1 += i;\n\teach(i, d2)s2 += i;\n\n\tprintf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n\tchar c; cin >> c;\n\treturn c == 'T';\n}\n\nsigned main() {\n\n\tint n;\n\tcin >> n;\n\n\tdeque<char> d1, d2;\n\n\tbool re = false;\n\n\tauto unko = [&]() {\n\t\tif (!re) {\n\t\t\td1.push_back('.');\td2.push_back('.'); if (query(d1, d2))return 0; d1.pop_back(); d2.pop_back();\n\t\t\td1.push_back('.');\td2.push_back('#'); if (query(d1, d2))return 0; d1.pop_back(); d2.pop_back();\n\t\t\td1.push_back('#');\td2.push_back('.'); if (query(d1, d2))return 0; d1.pop_back(); d2.pop_back();\n\t\t\td1.push_back('#');\td2.push_back('#'); if (query(d1, d2))return 0; d1.pop_back(); d2.pop_back();\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\td1.push_front('.');\td2.push_front('.'); if (query(d1, d2))return 0; d1.pop_front(); d2.pop_front();\n\t\t\td1.push_front('.');\td2.push_front('#'); if (query(d1, d2))return 0; d1.pop_front(); d2.pop_front();\n\t\t\td1.push_front('#');\td2.push_front('.'); if (query(d1, d2))return 0; d1.pop_front(); d2.pop_front();\n\t\t\td1.push_front('#');\td2.push_front('#'); if (query(d1, d2))return 0; d1.pop_front(); d2.pop_front();\n\t\t}\n\t};\n\twhile (1) {\n\t\tint t = unko();\n\t\tif (t == 1)re = true;\n\t\telse\n\t\tif (d1.size() == n)return 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstring s1;\nstring s2;\n\nvoid query1(char a, char b)\n{\n\tcout << s1 << a << endl;\n\tcout << s2 << b << endl;\n\tfflush(stdout);\n}\n\nvoid query2(char a, char b)\n{\n\tcout << a << s1 << endl;\n\tcout << b << s2 << endl;\n\tfflush(stdout);\n}\n\nbool read()\n{\n\tchar c; cin >> c;\n\tif(c == 'T') return true;\n\telse return false;\n}\n\nchar dx[4] = {'.', '.', '#', '#'};\nchar dy[4] = {'.', '#', '.', '#'};\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin >> n;\n\tbool bac = true;\n\twhile(s1.length() < n && s2.length() < n && bac)\n\t{\n\t\tbac = false;\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tquery1(dx[i], dy[i]);\n\t\t\tif(read())\n\t\t\t{\n\t\t\t\tbac = true;\n\t\t\t\ts1 += dx[i];\n\t\t\t\ts2 += dy[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twhile(s1.length() < n && s2.length() < n)\n\t{\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tquery2(dx[i], dy[i]);\n\t\t\tif(read())\n\t\t\t{\n\t\t\t\tbac = true;\n\t\t\t\ts1 = dx[i] + s1;\n\t\t\t\ts2 = dy[i] + s2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << s1 << endl << s2 << endl; fflush(stdout);\n\tstring s; cin >> s;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(X) X.begin(), X.end()\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\ntypedef std::pair<LL,LL> PLL;//\ntypedef std::pair<int,int> PII;//\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18+20;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\nbool END = false;\nint ENDcount = 0;\nvector< vector< vector<int> > > word(7);\n\nbool check(deque<int> v){\n\t++ENDcount;\n\tif( ENDcount > 420 ){\n\t\tEND = true;\n\t\treturn true;\n\t}\n\tint size = v.size();\n\tstring A,B;\n\tfor(int i=0;i<size;++i){\n\t\tif( v[i]&1 ){\n\t\t\tA += '#';\n\t\t}else{\n\t\t\tA += '.';\n\t\t}\n\t\tif( v[i]&2 ){\n\t\t\tB += '#';\n\t\t}else{\n\t\t\tB += '.';\n\t\t}\n\t}\n\tcout << A << '\\n' << B << endl;\n\tstring res;\n\tcin >> res;\n\tif( res[0] == 'T' ){\n\t\treturn true;\n\t}else if( res[0] == 'F' ){\n\t\treturn false;\n\t}\n\tEND = true;\n\treturn true;\n}\n\nvoid solve(){\n\tint N;\n\tcin >> N;\n\t\n\tdeque<int> ans;\n\tint pos = -1;\n\twhile(1){//右に伸ばす\n\t\tans.push_back(0);\n\t\t++pos;\n\t\tbool flag = false;\n\t\tfor(int i=0;i<4;++i){\n\t\t\tans[pos] = i;\n\t\t\tif( check( ans ) ){\n\t\t\t\tflag = true;\n\t\t\t\tif( END ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( flag == false ){//右に伸ばす4通りがダメだった\n\t\t\tans.pop_back();//右の伸ばしたものを消す。\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile(1){//左に伸ばす\n\t\tans.push_front(0);\n\t\tfor(int i=0;i<4;++i){\n\t\t\tans[0] = i;\n\t\t\tif( check( ans ) ){\n\t\t\t\tif( END ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8101145141919364364;\n\nint main(){\n\tint n; cin>>n;\n\tstring r,s1,s2;\n\tstring eins[]={\".\",\".\",\"#\",\"#\"};\n\tstring zwei[]={\".\",\"#\",\".\",\"#\"};\n\tbool side=1;\n\twhile(1){\n\t\trep(i,3){\n\t\t\tstring tmp1=(side?s1+eins[i]:eins[i]+s1);\n\t\t\tstring tmp2=(side?s2+zwei[i]:zwei[i]+s2);\n\t\t\tcout<<tmp1<<\"\\n\"<<tmp2<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>r;\n\t\t\tif(r==\"end\") return 0;\n\t\t\tif(r==\"T\"){\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tbreak;\n\t\t\t}else if(i==2){\n\t\t\t\ttmp1=(side?s1+eins[3]:eins[3]+s1);\n\t\t\t\ttmp2=(side?s2+zwei[3]:zwei[3]+s2);\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint x=s1.size();\n\t\tif(x==n){\n\t\t\tcout<<s1<<\"\\n\"<<s2<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>r;\n\t\t\tif(r==\"end\") return 0;\n\t\t\ts1=s1.substr(0,n-1);\n\t\t\ts2=s2.substr(0,n-1);\n\t\t\tside=0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main(){\n\tint N; cin >> N;\n\tstring s1 = \"\", s2 = \"\";\n\tchar c[2] = {'.', '#'};\n\tstring res;\n\tfor(int i=0;i<N;i++){\n\t\tstring t1, t2;\n\t\tbool ok = false;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tt1 = s1 + c[j/2];\n\t\t\tt2 = s2 + c[j%2];\n\t\t\tcout << t1 << endl;\n\t\t\tcout << t2 << endl;\n\t\t\tcin >> res;\n\t\t\tif(res == \"end\") return 0;\n\t\t\tif(res == \"T\"){\n\t\t\t\tok = true;\n\t\t\t\ts1 = t1;\n\t\t\t\ts2 = t2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) break;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tstring t1, t2;\n\t\tbool ok = false;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tt1 = c[j/2] + s1;\n\t\t\tt2 = c[j%2] + s2;\n\t\t\tcout << t1 << endl;\n\t\t\tcout << t2 << endl;\n\t\t\tcin >> res;\n\t\t\tif(res == \"end\") return 0;\n\t\t\tif(res == \"T\"){\n\t\t\t\tok = true;\n\t\t\t\ts1 = t1;\n\t\t\t\ts2 = t2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) break;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Kyoto University Programming Contest 2016\n// D - 長い黒板 / Long Blackboard\n\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <set>\n#include <queue>\n#define MAX_N 100\n#define R 2\nusing namespace std;\n\n\nclass Board {\npublic:\n  vector<bool> row[R];\n  int end_base;\n  bool operator<(Board brd);\n  void clear();\n  string to_s() const;\n};\n\nstring Board::to_s() const {\n  string str;\n  for (int j = 0; j < R; j++) {\n    for (int i = 0; i < (int)row[j].size(); i++) {\n      str += row[j][i] ? '#' : '.';\n    }\n    str += '\\n';\n  }\n  return str;\n}\n\nvoid Board::clear() {\n  for (int j = 0; j < R; j++) {\n    row[j].clear();\n  }\n}\n\nbool operator<(Board b1, Board b2) {\n  if (b1.row[0] == b2.row[0]) {\n    return b1.row[1] < b2.row[1];\n  }\n  return b1.row[0] < b2.row[0];\n}\n\nint N;\nbool mat[MAX_N][MAX_N];\nvector<Board> cands_base;\nqueue<Board> q;\n\nbool query() {\n  char buff[256];\n  string search_result;\n\n  cands_base.clear();\n  while (!q.empty()) {\n    cands_base.push_back(q.front());\n    q.pop();\n  }\n\n  for (auto itr = cands_base.begin(); itr != cands_base.end(); ) {\n    printf(\"%s\", itr->to_s().c_str()); fflush(stdout);\n    scanf(\"%s\", buff);\n    search_result = string(buff);\n    if (search_result == \"T\") {\n      itr++;\n    } else if (search_result == \"F\") {\n      itr = cands_base.erase(itr);\n    } else {\n      return false;\n    }\n  }\n\n  for (int s = 0; s < (int)cands_base.size(); s++) {\n    cands_base[s].end_base = s;\n    q.push(cands_base[s]);\n    for (int t = 0; t < (int)cands_base.size(); t++) {\n      // printf(\"s: %d, t: %d\\n%s%s\\n\", s, t, cands_base[s].to_s().c_str(), cands_base[t].to_s().c_str());\n      mat[s][t] = true;\n      for (int j = 0; j < R; j++) {\n        for (int i = 0; i < (int)cands_base[s].row[j].size() - 1; i++) {\n          if (cands_base[s].row[j][i + 1] != cands_base[t].row[j][i]) {\n            mat[s][t] = false;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n\n}\n\nint main() {\n\n  Board b;\n  int cands_size = 0;\n  bool query_result;\n\n  scanf(\"%d\", &N);\n  for (int pat = 0; pat < (1 << R); pat++) {\n    b.clear();\n    for (int j = 0; j < R; j++) {\n      b.row[j].push_back((pat & (1 << j)) > 0);\n    }\n    q.push(b);\n  }\n\n  for (int l = 1; l < N; l++) {\n    if (cands_size < (int)q.size()) {\n      query_result = query();\n      if (!query_result) {\n        return 0;\n      }\n    }\n\n    cands_size = q.size();\n    for (int c = 0; c < cands_size; c++) {\n      int s = q.front().end_base;\n      for (int t = 0; t < (int)cands_base.size(); t++) {\n        if (!mat[s][t]) {\n          continue;\n        }\n        b = q.front();\n        for (int j = 0; j < R; j++) {\n          int row_size = cands_base[t].row[j].size();\n          b.row[j].push_back(cands_base[t].row[j][row_size - 1]);\n        }\n        b.end_base = t;\n        q.push(b);\n      }\n      q.pop();\n    }\n  }\n\n  query();\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n\nusing namespace std;\nint i,j,m,n,p,k;\nchar C[2];\nchar s1[4]={'.','.','#','#'};\nchar s2[4]={'#','.','#','.'};\nint main()\n{\n\t\tscanf(\"%d\",&n);\n\t\tstring a,b;\n\t\tfor (;;)\n\t\t{\n\t\t\t\tstring c,d;\n\t\t\t\tfor (i=0;i<4;++i) \n\t\t\t\t{\n\t\t\t\t\tc=a+s1[i];\n\t\t\t\t\td=b+s2[i];\n\t\t\t\t\tcout<<c<<'\\n'<<d<<endl;\n\t\t\t\t\tscanf(\"%s\",&C);\n\t\t\t\t\tif (C[0]=='T') break;\n\t\t\t\t}\n\t\t\t\tif (i==4)\tbreak;\n\t\t\t\ta=c; b=d;\n\t\t}\n\t\tfor (;;)\n\t\t{\n\t\t\t\tstring c,d;\n\t\t\t\tfor (i=0;i<4;++i)\n\t\t\t\t{\n\t\t\t\t\t\tc=s1[i]+a;\n\t\t\t\t\t\td=s2[i]+b;\n\t\t\t\t\t\tcout<<c<<'\\n'<<d<<endl;\n\t\t\t\t\t\tscanf(\"%s\",&C);\n\t\t\t\t\t\tif (C[0]=='T') break;\n\t\t\t\t}\n\t\t\t\tif (i==4) break;\n\t\t\t\ta=c; b=d; \n\t\t}\n\t\tcout<<a<<'\\n'<<b<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<string, string>P;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\ndeque<P>po[200];\nint main() {\n\tint n; cin >> n;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po[1].push_back(P(s1, s2));\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j <= i / 2; j++) {\n\t\t\tfor (P p1 : po[j]) {\n\t\t\t\tfor (P p2 : po[i - j]) {\n\t\t\t\t\tcout << p1.first + p2.first << endl << p1.second + p2.second << endl;\n\t\t\t\t\tcin >> res;\n\t\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\t\tif (res == \"T\")po[i].push_back(P(p1.first + p2.first, p1.second + p2.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n    int N;\n    string r,s1=\"\",s2=\"\";\n    cin>>N;\n    bool flag=true;\n    while(s1.size()<N){\n        if(flag)\n        for(int k=0;k<4;k++){\n            cout<<(s1+(k&1?'#':'.'))<<endl<<flush;\n            cout<<(s2+(k&2?'#':'.'))<<endl<<flush;\n            cin>>r;\n            if(r==\"end\") return 0;\n            if(r==\"T\"){\n                s1=s1+(k&1?'#':'.');\n                s2=s2+(k&2?'#':'.');\n                break;\n            }else if(k==3){\n                flag=false;\n                break;\n            }\n        }\n        if(!flag)\n        for(int k=0;k<4;k++){\n            cout<<((k&1?'#':'.')+s1)<<endl<<flush;\n            cout<<((k&2?'#':'.')+s2)<<endl<<flush;\n            cin>>r;\n            if(r==\"end\") return 0;\n            if(r==\"T\"){\n                s1=(k&1?'#':'.')+s1;\n                s2=(k&2?'#':'.')+s2;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<bitset>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(void){\n\tint i;\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\tstring s1,s2;\n\tstring r;\n\tfor(i=0;i<N;i++){\n\t\ts1+='.'; s2+='.';\n\t\tcout << s1 << endl;\n\t\tcout << s2 << endl;\n\t\tcout.flush();\n\tcin >> r;\n\tif(r==\"end\") return 0;\n\telse if(r==\"T\") continue;\n\n\n\ts1[i]='.'; s2[i]='#';\n\tcout << s1 << endl;\n\tcout << s2 << endl;\n\tcout.flush();\n    cin >> r;\n    if(r==\"end\") return 0;\n    else if(r==\"T\") continue;\n\n\n\ts1[i]='#'; s2[i]='.';\n\tcout << s1 << endl;\n\tcout << s2 << endl;\n\tcout.flush();\n    cin >> r;\n    if(r==\"end\") return 0;\n    else if(r==\"T\") continue;\n\n\ts1[i]='#'; s2[i]='#';\n\tcout << s1 << endl;\n\tcout << s2 << endl;\n\tcout.flush();\n    cin >> r;\n    if(r==\"end\") return 0;\n    else if(r==\"T\") continue;\n\n\n    }\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n\ntypedef long long ll;\n\nchar asd[10]={'.','.','#','#'};\nchar dsa[10]={'.','#','.','#'};\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\t\n\tint r;\n\tcin>>r;\n\tstring a=\"\";\n\tstring s=\"\";\n\tstring z,x;\n\tchar c;\n\tbool cek=false;\n\tfor(int q=1;q<420;q++)\n\t{\n\t\tif(a.size()==r)break;\n\t\t\n\t\tif(!cek)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\tfor(int q=0;q<4;q++)\n\t\t\t{\n\t\t\t\tz=a;\n\t\t\t\tx=s;\n\t\t\t\tz+=asd[q];\n\t\t\t\tx+=dsa[q];\n\t\t\t\tcout<<z<<endl;\n\t\t\t\tcout<<x<<endl;\n\t\t\t\tcin>>c;\n\t\t\t\tif(c=='T')\n\t\t\t\t{\n\t\t\t\t\ta=z;\n\t\t\t\t\ts=x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\t\n\t\t\t}\n\t\t\tif(cnt==4)\n\t\t\tcek=true;\n\t\t}\n\t\tif(cek)\n\t\t{\n\t\t\tfor(int q=0;q<4;q++)\n\t\t\t{\n\t\t\t\tz=asd[q]+a;\n\t\t\t\tx=dsa[q]+s;\n\t\t\t\tcout<<z<<endl;\n\t\t\t\tcout<<x<<endl;\n\t\t\t\tcin>>c;\n\t\t\t\tif(c=='T')\n\t\t\t\t{\n\t\t\t\t\ta=z;\n\t\t\t\t\ts=x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n\tcout<<a<<endl;\n\tcout<<s<<endl;\n\tstring d;\n\tcin>>d;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<string> res(2);\nint ok=0;\nstring up=\".##.\",down=\"##..\";\n\nbool lft()\n{\n    for(int i=0;i<4;++i)\n    {\n        cout<<res[0]+up[i]<<'\\n';\n        cout<<res[1]+down[i]<<'\\n';\n        cout.flush();\n        char c;\n        cin>>c;\n        if(c=='T')\n        {\n            res[0]+=up[i];\n            res[1]+=down[i];\n            return 1;\n        }\n    }\n    return 0;\n}\n\nbool rgt()\n{\n    for(int i=0;i<4;++i)\n    {\n        cout<<up[i]+res[0]<<'\\n';\n        cout<<down[i]+res[1]<<'\\n';\n        cout.flush();\n        char c;\n        cin>>c;\n        if(c=='T')\n        {\n            res[0]=up[i]+res[0];\n            res[1]=down[i]+res[1];\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    getchar();\n    bool yee=0;\n    while(ok<n)\n    {\n        lft()||rgt();\n        ++ok;\n    }\n    cout<<res[0]<<'\\n';\n    cout<<res[1]<<'\\n';\n    cout.flush();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8101145141919364364;\n\nint main(){\n\tint n; cin>>n;\n\tstring r,s1,s2;\n\tstring eins[]={\".\",\".\",\"#\",\"#\"};\n\tstring zwei[]={\".\",\"#\",\".\",\"#\"};\n\tbool side=1;\n\twhile(1){\n\t\trep(i,4){\n\t\t\tstring tmp1=(side?s1+eins[i]:eins[i]+s1);\n\t\t\tstring tmp2=(side?s2+zwei[i]:zwei[i]+s2);\n\t\t\tcout<<tmp1<<\"\\n\"<<tmp2<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>r;\n\t\t\tif(r==\"end\") return 0;\n\t\t\tif(r==\"T\"){\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tbreak;\n\t\t\t}else if(i==3){\n\t\t\t\tside=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint x=s1.size();\n\t\tif(x==n){\n\t\t\tcout<<s1<<\"\\n\"<<s2<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>r;\n\t\t\tif(r==\"end\") return 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nchar S1[4]={'.','.','#','#'};\nchar S2[4]={'.','#','.','#'};\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  int P[1000],Q[1000];\n  int N=0;\n  while(N<n){\n    bool F=0;\n    for(int v=0;v<4;v++){\n      for(int i=0;i<N;i++){\n\tputchar(S1[P[i]]);\n      }\n      putchar(S1[v]);\n      putchar('\\n');\n      for(int i=0;i<N;i++){\n\tputchar(S2[P[i]]);\n      }\n      putchar(S2[v]);\n      putchar('\\n');\n      fflush(stdout);\n      char s[5];\n      scanf(\"%s\",s);\n      if(s[0]!='F'){\n\tP[N]=v;\n\tF=1;\n\tbreak;\n      }\n    }\n    if(!F){\n      break;\n    }\n    N++;\n  }\n  for(int M=0;M<n-N;M++){\n    for(int v=0;v<4;v++){\n      putchar(S1[v]);\n      for(int i=M-1;i>=0;i--){\n\tputchar(S1[Q[i]]);\n      }\n      for(int i=0;i<N;i++){\n\tputchar(S1[P[i]]);\n      }\n      putchar('\\n');\n      putchar(S2[v]);\n      for(int i=M-1;i>=0;i--){\n\tputchar(S2[Q[i]]);\n      }\n      for(int i=0;i<N;i++){\n\tputchar(S2[P[i]]);\n      }\n      putchar('\\n');\n      fflush(stdout);\n      char s[5];\n      scanf(\"%s\",s);\n      if(s[0]!='F'){\n\tQ[M]=v;\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstring s1;\nstring s2;\n\nvoid query1(char a, char b)\n{\n\tcout << s1 << a << endl;\n\tcout << s2 << b << endl;\n\tfflush(stdout);\n}\n\nvoid query2(char a, char b)\n{\n\tcout << a << s1 << endl;\n\tcout << b << s2 << endl;\n\tfflush(stdout);\n}\n\nbool read()\n{\n\tchar c; cin >> c;\n\tif(c == 'T') return true;\n\telse return false;\n}\n\nchar dx[4] = {'.', '.', '#', '#'};\nchar dy[4] = {'.', '#', '.', '#'};\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin >> n;\n\tbool bac = true;\n\twhile(s1.length() < n && s2.length() < n && bac)\n\t{\n\t\tbac = false;\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tquery1(dx[i], dy[i]);\n\t\t\tif(read())\n\t\t\t{\n\t\t\t\tbac = true;\n\t\t\t\ts1 += dx[i];\n\t\t\t\ts2 += dy[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twhile(s1.length() < n && s2.length() < n)\n\t{\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tquery2(dx[i], dy[i]);\n\t\t\tif(read())\n\t\t\t{\n\t\t\t\tbac = true;\n\t\t\t\ts1 = dx[i] + s1;\n\t\t\t\ts2 = dy[i] + s2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << s1 << endl << s2 << endl; fflush(stdout);\n\tstring s; cin >> s;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst char s1[4] = { '.', '#', '.', '#'};\nconst char s2[4] = { '.', '.', '#', '#'};\n\nbool used[4];\nbool found;\nset<string> exclusion;\nint cnt;\n\nvoid dfs(int depth, string t1, string t2){\n\tif (cnt >= 420) return;\n\tif (found) return;\n\n\tcerr << t1 << endl;\n\tcerr << t2 << endl;\n\trep (i, 4){\n\t\t++cnt;\n\t\tif (!used[i]) continue;\n\t\tstring u1 = t1 + s1[i];\n\t\tstring u2 = t2 + s2[i];\n\t\tif (exclusion.count(u1+u2)) continue;\n\t\tcout << u1 << endl;\n\t\tcout << u2 << endl;\n\t\tfflush(stdout);\n\t\tstring ans; cin >> ans;\n\t\tif (ans[0] == 'F'){\n\t\t\tif (depth == 0) used[i] = false;\n\t\t\texclusion.insert(u1+u2);\n\t\t\tcontinue;\n\t\t} // end if\n\n\t\tif (ans == \"end\"){\n\t\t\tfound |= true;\n\t\t\treturn;\n\t\t} // end if\n\t\t// if (ans[0] == 'T')\n\t\tdfs(depth + 1, u1, u2);\n\t} // end rep \n}\n \nint main()\n{\n\tmemset(used, false, sizeof(used));\n\trep (i, 4) used[i] = true;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N; cin >> N;\n\tcnt = 0;\n\texclusion.clear();\n\tfound = false;\n\tdfs(0, \"\", \"\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; cin >> n;\n    string s1, s2;\n    char c[2] = {'.', '#'};\n    while ((int) s1.size() < n) {\n        bool found = false;\n        for (int c1 = 0; c1 < 2 && !found; ++c1) {\n            for (int c2 = 0; c2 < 2 && !found; ++c2) {\n                cout << s1 + c[c1] << '\\n' << s2 + c[c2] << endl;\n                string res; cin >> res;\n                if (res != \"F\") {\n                    found = true;\n                    s1 += c[c1];\n                    s2 += c[c2];\n                }\n            }\n        }\n        if (!found) break;\n    }\n    while ((int) s1.size() < n) {\n        bool found = false;\n        for (int c1 = 0; c1 < 2 && !found; ++c1) {\n            for (int c2 = 0; c2 < 2 && !found; ++c2) {\n                cout << c[c1] + s1 << '\\n' << c[c2] + s2 << endl;\n                string res; cin >> res;\n                if (res != \"F\") {\n                    found = true;\n                    s1 = c[c1] + s1;\n                    s2 = c[c2] + s2;\n                }\n            }\n        }\n        if (!found) break;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nvoid Yes(){\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n}\n\nvoid No(){\n\tcout<<\"No\"<<endl;\n\texit(0);\n}\n\ntemplate<class T>\nvoid chmax(T& a,T b){\n\ta=max(a,b);\n}\n\ntemplate<class T>\nvoid chmin(T& a,T b){\n\ta=min(a,b);\n}\n\ntemplate<class T>\nvoid ResetVector(vector<T>& v,int n,const T& t){\n\tv.clear();\n\tv.resize(n,t);\n}\n\nconst char* table=\"#.\";\n\nint main(){\n\tint n=read();\n\tstring u,b;\n\twhile(1){\n\t\tbool found=false;\n\t\tREP(i,2)REP(j,2){\n\t\t\tstring p=u+table[i],q=b+table[j];\n\t\t\tcout<<p<<endl<<q<<endl;\n\t\t\tstring res;\n\t\t\tcin>>res;\n\t\t\tif(res==\"end\")\n\t\t\t\treturn 0;\n\t\t\tif(res==\"T\"){\n\t\t\t\tu+=table[i];\n\t\t\t\tb+=table[j];\n\t\t\t\tfound=true;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tEND:;\n\t\tif(!found)\n\t\t\tbreak;\n\t}\n\twhile(1){\n\t\tbool found=false;\n\t\tREP(i,2)REP(j,2){\n\t\t\tstring p=string()+table[i]+u,q=string()+table[j]+b;\n\t\t\tcout<<p<<endl<<q<<endl;\n\t\t\tstring res;\n\t\t\tcin>>res;\n\t\t\tif(res==\"end\")\n\t\t\t\treturn 0;\n\t\t\tif(res==\"T\"){\n\t\t\t\tu=string()+table[i]+u;\n\t\t\t\tb=string()+table[j]+b;\n\t\t\t\tfound=true;\n\t\t\t\tgoto END2;\n\t\t\t}\n\t\t}\n\t\tEND2:;\n\t\tif(!found)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <complex>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n \ntypedef tuple<ll,ll,ll> T;\n\n\nstring a=\"\";\nstring b=\"\";\n\t\nstring check(string x, string y){\n\tstring r;\n\tprintf(\"%s\\n%s\\n\", (a+x).c_str(), (b+y).c_str()); fflush(stdout);\n\tcin >> r;\n\tif(r==\"end\")\n\t\treturn r;\n\telse if(r==\"T\"){\n\t\ta=a+x;\n\t\tb=b+y;\n\t}\n\treturn r;\n}\n\nstring check2(string x, string y){\n\tstring r;\n\tprintf(\"%s\\n%s\\n\", (x+a).c_str(), (y+b).c_str());\n\tcin >> r;\n\tif(r==\"end\")\n\t\treturn r;\n\telse if(r==\"T\"){\n\t\ta=x+a;\n\t\tb=y+b;\n\t}\n\treturn r;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\twhile(1){\n\t\twhile(1){\n\t\t\tstring r=check(\".\",\".\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\n\t\t\tr=check(\"#\",\".\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tr=check(\".\",\"#\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tr=check(\"#\",\"#\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\twhile(1){\n\t\t\tstring r=check2(\".\",\".\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\n\t\t\tr=check2(\"#\",\".\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tr=check2(\".\",\"#\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tr=check2(\"#\",\"#\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tstring atas = \"\";\n\tstring bawah = \"\";\n\t\n\tchar in_buffer[10] = {};\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas = '.' + atas;\n\t\tbawah = '.' + bawah;\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[0] = tempatas[j];\n\t\t\tbawah[0] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\", atas.c_str(), bawah.c_str());\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint len = atas.length();\n\tfor(len++; len <= n; len++) {\n\t\tatas = atas + '.';\n\t\tbawah = bawah + '.';\n\t\t\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[len-1] = tempatas[j];\n\t\t\tbawah[len-1] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\", atas.c_str(), bawah.c_str());\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tbool f;\n\tstring s1, s2;\n\tchar c;\n\tchar c1[] = { '.', '#', '.', '#' };\n\tchar c2[] = { '.', '.', '#', '#' };\n\tcin >> N;\n\tdo {\n\t\tf = false;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcout << s1 << c1[i] << endl;\n\t\t\tcout << s2 << c2[i] << endl;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\ts1 += c1[i];\n\t\t\t\ts2 += c2[i];\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (f);\n\tdo {\n\t\tf = false;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcout << c1[i] << s1 << endl;\n\t\t\tcout << c2[i] << s2 << endl;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\ts1 = c1[i] + s1;\n\t\t\t\ts2 = c2[i] + s2;\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (f);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>//min/max/sort(rand-access it)/merge\n#include <array>\n#include <bitset>\n#include <climits>//INT_MAX/INT_MIN/ULLONG_MAX\n#include <cmath>//fmin/fmax/fabs/sin(h)/cos(h)/tan(h)/exp/log/pow/sqrt/cbrt/ceil/floor/round/trunc\n#include <cstdlib>//abs/atof/atoi/atol/atoll/strtod/strtof/..., srand/rand, calloc/malloc, exit, qsort\n#include <iomanip>//setfill/setw\n#include <iostream>//cin/cout/wcin/wcout/left/right/internal/dec/hex/oct/fixed/scientific\n#include <iterator>\n#include <list>\n#include <queue>\n#include <string>//stoi/stol/stoul/stoll/stoull/stof/stod/stold/to_string/getline\n#include <tuple>\n#include <utility>//pair\n#include <valarray>\n#include <vector>\n\n#define PRIME_SHORT 10007\n#define PRIME 1000000007\n\nusing namespace std;\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> plli;\ntypedef pair<ull, int> puli;\ntypedef pair<double, int> pdi;\ntypedef pair<ll, ll> pllll;\ntypedef pair<ull, ull> pulul;\ntypedef pair<double, double> pdd;\ntypedef tuple<int, int, int> ti3;\ntypedef tuple<int, int, int, int> ti4;\n\nconst bool debug = false;\n\nvoid rar(int n, int* a);\nvoid rar2(int n, int m, int** a);\n\nint ipow(int base, int exp);\nint left(int current, bool swap);\nint right(int current, bool swap);\nint griddist(int x, int y, int s, int t);\nint griddist(pii one, pii two);\ndouble sqeucldist(double x, double y, double s, double t);\ndouble sqeucldist(pii one, pii two);\null modadd(ull a, ull b, int mod);\null modmult(ull a, ull b, int mod);\n\nvoid set(string top, string bot, bool up, bool down)\n{\n    top += up?\".\":\"#\";\n    bot += down?\".\":\"#\";\n}\n\nvoid set_front(string top, string bot, deque<char> ttop, deque<char> bbot, bool up, bool down)\n{\n    ttop.push_front(up?'.':'#');\n    bbot.push_front(down?'.':'#');\n    size_t n = ttop.size();\n    char* ctop = new char[n];\n    char* cbot = new char[n];\n    for (size_t i = 0; i < n; ++i)\n    {\n        ctop[i] = ttop[i];\n        cbot[i] = bbot[i];\n    }\n    top = string(ctop, n);\n    bot = string(cbot, n);\n}\n\nvoid pop(string top, string bot)\n{\n    top.pop_back();\n    bot.pop_back();\n}\n\nvoid pop_front(string top, string bot, deque<char> ttop, deque<char> bbot)\n{\n    ttop.pop_front();\n    bbot.pop_front();\n    size_t n = ttop.size();\n    char* ctop = new char[n];\n    char* cbot = new char[n];\n    for (size_t i = 0; i < n; ++i)\n    {\n        ctop[i] = ttop[i];\n        cbot[i] = bbot[i];\n    }\n    top = string(ctop, n);\n    bot = string(cbot, n);\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n\n    pair< deque<char>, deque<char> > backend;\n\n    //.. .# #. ##\n    bool possible[4] = {true, true, true, true};\n    pair<bool, bool> comb[4];\n    comb.emplace_back(true, true);\n    comb.emplace_back(true, false);\n    comb.emplace_back(false, true);\n    comb.emplace_back(false, false);\n\n    string status;\n\n    string top = \"\";\n    string bot = \"\";\n\n    for (int i = 0; i < 4; ++i)\n    {\n        set(top, bot, comb[i].first, comb[i].second);\n        printf(\"%s\\n%s\\n\", top, bot); fflush(stdout);\n        cin >> status;\n        if (status == \"T\") {\n            pop(top, bot);\n        } else if (status == \"F\") {\n            possible[i] = false;\n            pop(top, bot);\n        } else if (status == \"end\") {\n            return 0;\n        }\n    }\n\n    std::vector<int> good;\n\n    for (int i = 0; i < 4; ++i)\n    {\n        if (possible[i])\n        {\n            good.push_back(i);\n        }\n    }\n\n    int wid = 1;\n    bool btof = false;\n    while (wid <= n) {\n\n        //debug output\n        if (debug)\n        {\n            cout << top << endl;\n            cout << bot << endl;\n        }\n\n        bool found = false;\n        if (!btof)\n        {\n            for (int i = 0; i < good.size(); ++i)\n            {\n                set_front(top, bot, backend.first, backend.second, comb[good[i]].first, comb[good[i]].second);\n                printf(\"%s\\n%s\\n\", top, bot); fflush(stdout);\n                cin >> status;\n                if (status == \"T\")\n                {\n                    found = true;\n                    break;\n                } else if (status == \"F\") {\n                    pop_front(top, bot, backend.first, backend.second);\n                    continue;\n                } else if (status == \"end\") {\n                    return 0;\n                }\n            }\n            if (!found)\n            {\n                if (debug)\n                {\n                    cout << \"error\" << endl;\n                }\n                return 1;\n            }\n        } else {\n            for (int i = 0; i < good.size(); ++i)\n            {\n                set(top, bot, comb[good[i]].first, comb[good[i]].second);\n                printf(\"%s\\n%s\\n\", top, bot); fflush(stdout);\n                cin >> status;\n                if (status == \"T\")\n                {\n                    found = true;\n                    break;\n                } else if (status == \"F\") {\n                    pop(top, bot);\n                    continue;\n                } else if (status == \"end\") {\n                    return 0;\n                }\n            }       \n            if (!found)\n            {\n                deque<char> ttop, bbot;\n                for (int i = 0; i < top.size(); ++i)\n                {\n                    ttop.push_back(top[i]);\n                    bbot.push_back(bot[i]);\n                }\n                backend = make_pair(ttop, bbot);\n                btof = true;\n            }     \n        }\n    }\n\n    return 0;\n}\n\nvoid rar(int n, int* a)\n{\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> a[i];\n    }\n    return;\n}\n\nvoid rar2(int n, int m, int** a)\n{\n    for (int i = 0; i < n; ++i)\n    {\n        a[i] = new int[m];\n        for (int j = 0; j < m; ++j)\n        {\n            cin >> a[i][j];\n        }\n    }\n    return;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint ipow(int base, int exp) {\n    int result = 1;\n    while (exp)\n    {\n        if (exp & 1)\n            result *= base;\n        exp >>= 1;\n        base *= base;\n    }\n\n    return result;\n}\nint left(int current, bool swap = false) {\n    if(swap){\n        return right(current, false);\n    } else {\n        return 2*current + 1;\n    }\n}\nint right(int current, bool swap = false) {\n    if(swap){\n        return left(current, false);\n    } else {\n        return 2*(current+1);\n    }\n}\nint griddist(int x, int y, int s, int t) {\n    return abs(x-s) + abs(y-t);\n}\nint griddist(pii one, pii two) {\n    return abs(one.first - two.first) + abs(one.second - two.second);\n}\ndouble sqeucldist(double x, double y, double s, double t) {\n    double a = x-s;\n    double b = y-t;\n    return a*a+b*b;\n}\ndouble sqeucldist(pii one, pii two) {\n    double a = one.first - two.first;\n    double b = one.second - two.second;\n    return a*a+b*b;\n}\n\null modadd(ull a, ull b, int mod) {\n    return (a%mod + b%mod)%mod;\n}\null modmult(ull a, ull b, int mod) {\n    return ((a%mod)*(b%mod))%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring f(string s,char c){\n\tstring ret = \"\";\n\tret += c;\n\trep(i,s.size()){\n\t\tret += s[i];\n\t}\n\treturn ret;\n}\nstring b(string s,char c){\n\ts += c;\n\treturn s;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tstring s[2] = { \"\" , \"\" };\n\t\n\tconst char c[4][2] = { {'.','.'},{'.','#'},{'#','.'},{'#','#'} };\n\t\n\tchar R;\n\tbool t = false;\n\twhile(1){\n\t\tif(!t){\n\t\t\trep(i,4){\n\t\t\t\tcout << b(s[0],c[i][0]) << \"\\n\" << b(s[1],c[i][1]) << \"\\n\";\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin >> R;\n\t\t\t\tif(R == 'T'){\n\t\t\t\t\ts[0] = b(s[0],c[i][0]);\n\t\t\t\t\ts[1] = b(s[1],c[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i == 3)t = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trep(i,4){\n\t\t\t\tcout << f(s[0],c[i][0]) << \"\\n\" << f(s[1],c[i][1]) << \"\\n\";\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin >> R;\n\t\t\t\tif(R == 'T'){\n\t\t\t\t\ts[0] = f(s[0],c[i][0]);\n\t\t\t\t\ts[1] = f(s[1],c[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(s[0].size() == n)break;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define mod 1000000007\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\nstring str[2];\nstring X[] = {\".\",\"#\",\".\",\"#\"};\nstring Y[] = {\"#\",\".\",\".\",\"#\"};\n\nchar A[] = {'.','#','.','#'};\nchar B[] = {'#','.','.','#'};\n\nint main() {\n\n\tint i, j;\n\tint N;\n\n\tcin >> N;\n\n\tint ind;\n\tbool flag = 1;\n\n\tstring ans;\n\n\tfor(ind = 0; ind < N; ind++)\n\t{\n\t\tbool done = 0;\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tstr[0].push_back(A[i]);\n\t\t\t\tstr[1].push_back(B[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr[0].insert(0,X[i]);\n\t\t\t\tstr[1].insert(0,Y[i]);\n\t\t\t}\n\t\t\tcout << str[0] << \"\\n\" << str[1] << \"\\n\";\n\t\t\tfflush(stdout);\n\t\t\tcin >> ans;\n\t\t\tif(ans == \"T\")\n\t\t\t\tdone = 1;\n\t\t\telse if(ans == \"F\")\n\t\t\t{\n\t\t\t\tif(flag)\n\t\t\t\t{\n\t\t\t\t\tstr[0].pop_back();\n\t\t\t\t\tstr[1].pop_back();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstr[0].erase(0,1);\n\t\t\t\t\tstr[1].erase(0,1);\n\t\t\t\t}\n\t\t\t\tdone = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tif(!done)\n\t\t{\n\t\t\tflag ^= 1;\n\t\t}\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <iostream>\n#include <ctime>\n#include <complex>\n\n#define enp \tprintf(\"**Entry Point**\\n\")\n#define A\t\tfirst\n#define B\t\tsecond\n#define MP\t\tmake_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 0x6fffffff;\nconst int MINF = 0x80000000;\nconst ll mod = 100003;\nconst int cons = 100001;\nconst double pi = 3.141592653589793;\n\nchar ch[2] = { '.', '#' };\nint nxt[4][2];\nchar s1[400];\nchar s2[400];\n\nint main()\n{\n\tnxt[0][0] = 0;\n\tnxt[0][1] = 1;\n\tnxt[1][0] = 1;\n\tnxt[1][1] = 0;\n\tnxt[2][0] = 1;\n\tnxt[2][1] = 1;\n\tnxt[3][0] = 0;\n\tnxt[3][1] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint front = 200;\n\tint rear = 200;\n\tint i1 = 0, i2 = 0;\n\tbool flag = true;\n\tint cur = 0;\n\n\twhile (1)\n\t{\n\t\tif (flag)\n\t\t{\n\t\t\ts1[rear] = ch[i1];\n\t\t\ts2[rear++] = ch[i2];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts1[front - 1] = ch[i1];\n\t\t\ts2[front - 1] = ch[i2];\n\t\t\tfront--;\n\t\t}\n\n\t\tprintf(\"%s\\n%s\\n\", s1 + front, s2 + front); fflush(stdout);\n\n\t\tstring ans;\n\t\tcin >> ans;\n\t\tif (ans == \"END\")break;\n\n\t\tif (ans == \"F\")\n\t\t{\n\t\t\ti1 = nxt[cur][0];\n\t\t\ti2 = nxt[cur][1];\n\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\trear--;\n\t\t\t\ts1[rear] = 0;\n\t\t\t\ts2[rear] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfront++;\n\t\t\t}\n\n\t\t\tcur++;\n\t\t\tcur %= 4;\n\t\t\tif (cur == 0)\n\t\t\t{\n\t\t\t\tflag ^= true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur = 0;\n\t\t\ti1 = 0;\n\t\t\ti2 = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define base 1000000007LL\n#define ll long long\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define CLR(a) memset(a,0,sizeof(a))\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORE(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n\nusing namespace std;\n\ntypedef pair<ll, ll> II;\ntypedef vector<II> vi;\n\nint n;\nchar s1[110], s2[110];\nchar p[4] = {'.', '.', '#', '#'};\nchar q[4] = {'.', '#', '.', '#'};\nchar res[5];\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    //freopen(\"inp.txt\", \"r\", stdin);\n    scanf(\"%d\", &n);\n    s1[1] = s2[1] = '\\0';\n    FOR(i,0,3) {\n        s1[0] = p[i];\n        s2[0] = q[i];\n        printf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n        scanf(\"%s\", res);\n        if (strcmp(res, \"T\") == 0) break;\n        else if (strcmp(res, \"end\") == 0) return 0;\n    }\n    int remain = n-1;\n    while (remain) {\n        s1[n-remain+1] = s1[n-remain];\n        s2[n-remain+1] = s2[n-remain];\n        bool co = false;\n        FOR(i,0,3) {\n            s1[n-remain] = p[i];\n            s2[n-remain] = q[i];\n            printf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n            scanf(\"%s\", res);\n            if (strcmp(res, \"T\") == 0) {\n                co = true;\n                break;\n            }\n            else if (strcmp(res, \"end\") == 0) return 0;\n        }\n        if (co) remain--;\n        else break;\n    }\n    if (remain) s1[n-remain] = s2[n-remain] = '\\0';\n    while (remain) {\n        FORE(i,n-remain+1,1) {\n            s1[i] = s1[i-1];\n            s2[i] = s2[i-1];\n        }\n        FOR(i,0,3) {\n            s1[0] = p[i];\n            s2[0] = q[i];\n            printf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n            scanf(\"%s\", res);\n            if (strcmp(res, \"T\") == 0) break;\n            else if (strcmp(res, \"end\") == 0) return 0;\n        }\n        remain--;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstring query(pair<string,string> p1,pair<string,string> p2){\n  string s1,s2;\n  s1 = p1.first + p2.first;\n  s2 = p1.second + p2.second;\n  printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n  string str;\n  cin >> str;\n  return str;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  set<pair<string,string> >st;\n  for(int i = 0 ; i < 2 ; i++){\n    string str1;\n    string str2;\n    for(int j = 0 ; j < 4 ; j++){\n      str1 += (j%2?\".\":\"#\");\n      str2 += ((j >> 1)%2?\".\":\"#\");\n    }\n    st.insert(make_pair(str1,str2));\n  }\n  \n  while(1){\n    vector<pair<string,string>vec(st.begin(),st.end());\n    for(int i = 0 ; i < vec.size() ; i++){\n      for(int j = i ; j < vec.size() ; j++){\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  string r;\n\t  pair<string,string>p;\n\t  if(k % 2){\n\t    r = query(vec[i],vec[j]);\n\t    p = make_pair(vec[i].first + vec[j].first,vec[i].second + vec[j].second);\n\t  }\n\t  else {\n\t    r = query(vec[j],vec[i]);\n\t    p = make_pair(vec[j].first + vec[i].first,vec[j].second + vec[i].second);\n\t  }\n\t  // in\n\t  if(r == \"T\"){\n\t    st.insert(p);\n\t  }\n\t  else if(r == \"end\"){\n\t    return 0;\n\t  }\n\t}\n      }\n    }\n  }\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n\tll n;\n\tcin>>n;\n\tstring input =\"\";\n\tstring s1 =\"..##\";\n\tstring s2 =\".#.#\";\n\tstring ans1 = \"\" , ans2=\"\";\n\twhile(input != \"end\")\n\t{\n\t\tbool balik = 1;\n\t\tfor(int i = 0; i  < 4;  i++)\n\t\t{\n\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\ttemp1 += s1[i];\n\t\t\ttemp2 += s2[i];\n\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\tfflush(stdout);\n\t\t\tcin>>input;\n\t\t\tif(input == \"end\") return 0;\n\t\t\tif(input == \"T\" || input == \"end\")\n\t\t\t{\n\t\t\t\tans1 = temp1;\n\t\t\t\tans2 = temp2;\n\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( i == 3)\n\t\t\t\t{\n\t\t\t\t\tbalik = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(balik == 0)\n\t\t{\n\t\t\tfor(int i = 0; i  < 4;  i++)\n\t\t\t{\n\t\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\t\ttemp1 = s1[i] + ans1;\n\t\t\t\ttemp2 = s2[i] + ans2;\n\t\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin>>input;\n\t\t\t\tif(input == \"end\") return 0;\n\t\t\t\tif(input == \"T\" )\n\t\t\t\t{\n\t\t\t\t\tans1 = temp1;\n\t\t\t\t\tans2 = temp2;\n\t\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif( i == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tbalik = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n//#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n;\nstring a,b,ta,tb,s;\nbool st;\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n//    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n;\n    while(1){\n    \tif(st){\n    \t\tta = '.'+a, tb = '.'+b;\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n    \t\tta = '.'+a, tb = '#'+b;\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n    \t\tta = '#'+a, tb = '.'+b;\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n    \t\tta = '#'+a, tb = '#'+b;\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t}\n\t\telse {\n\t\t\tta = a+'.', tb = b+'.';\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t\tta = a+'.', tb = b+'#';\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t\tta = a+'#', tb = b+'.';\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t\tta = a+'#', tb = b+'#';\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t\tst = 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <deque>\nusing namespace std;\n\ndeque<char> d[2];\nbool query() {\n\tstring s1, s2;\n\tint n = d[0].size();\n\tfor(int i = 0; i < n; i++) {\n\t\ts1 += d[0][i] == 0 ? '.' : '#';\n\t\ts2 += d[1][i] == 0 ? '.' : '#';\n\t}\n\tcout << s1 << endl << s2 << endl;\n\tcout.flush();\n\tchar c;\n\tcin >> c;\n\treturn c == 'T';\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tbool right = true;\n\twhile(d[0].size() < N) {\n\t\t//cout << \"right \" << right << endl;\n\t\tint idx = -1;\n\t\tif(right) {\n\t\t\td[0].push_back(0);\n\t\t\td[1].push_back(0);\n\t\t\tidx = d[0].size() - 1;\n\t\t}\n\t\telse {\n\t\t\td[0].push_front(0);\n\t\t\td[1].push_front(0);\n\t\t\tidx = 0;\n\t\t}\n\t\tbool flag = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\td[0][idx] = j & 1;\n\t\t\td[1][idx] = j & 2;\n\t\t\tif(query()) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag) {\n\t\t\tright = false;\n\t\t\td[0].pop_back();\n\t\t\td[1].pop_back();\n\t\t}\n\t}\n\n\tassert(query());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nchar ans[2][205];\nchar q[4];\n\nvoid set_value(int pos, int val){\n    if(val == 0 || val == 1){\n        ans[0][pos] = '.';\n    }else{\n        ans[0][pos] = '#';\n    }\n    if(val == 0 || val == 3){\n        ans[1][pos] = '.';\n    }else{\n        ans[1][pos] = '#';\n    }\n}\n\nint main(){\n    int N;\n\n    scanf(\"%d\",&N);\n\n    int start = N,end = N;\n    memset(ans,0,sizeof ans);\n\n    for(int i = 0;i < 4;++i){\n        set_value(end,i);\n        printf(\"%s\\n%s\\n\",ans[0] + start,ans[1] + start);\n        fflush(stdout);\n        scanf(\"%s\",q);\n        if(q[0] == 'T' || q[0] == 'e'){\n            ++end;\n            break;\n        }\n    }\n\n    if(q[0] == 'e'){\n        return 0;\n    }\n\n    bool found = true;\n    while(found){\n        found = false;\n        for(int i = 0;i < 4;++i){\n            set_value(end,i);\n            printf(\"%s\\n%s\\n\",ans[0] + start,ans[1] + start);\n            fflush(stdout);\n            scanf(\"%s\",q);\n            if(q[0] == 'T' || q[0] == 'e'){\n                found = true;\n                ++end;\n                break;\n            }\n        }\n\n        if(q[0] == 'e'){\n            return 0;\n        }\n    }\n\n    ans[0][end] = ans[1][end] = 0;\n\n    found = true;\n    while(found){\n        found = false;\n        --start;\n        for(int i = 0;i < 4;++i){\n            set_value(start,i);\n            printf(\"%s\\n%s\\n\",ans[0] + start,ans[1] + start);\n            fflush(stdout);\n            scanf(\"%s\",q);\n            if(q[0] == 'T' || q[0] == 'e'){\n                found = true;\n                break;\n            }\n        }\n\n        if(q[0] == 'e'){\n            return 0;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint main(){\n\tsrand(time(NULL));\n\tint N;\n\tcin >> N;\n\tset<vector<string> > used;\n\n\tstring c[2];\n\twhile(true){\n\t\tvector<vector<string>> lst;\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] += (k>>0&1?\".\":\"#\");\n\t\t\tb[1] += (k>>1&1?\".\":\"#\");\n\t\t\tlst.push_back(b);\n\t\t}\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] = (k>>0&1?\".\":\"#\") + b[0];\n\t\t\tb[1] = (k>>1&1?\".\":\"#\") + b[1];\n\t\t\tlst.push_back(b);\n\t\t}\n\t\trandom_shuffle(lst.begin(),lst.end());\n\t\tfor(int i = 0 ; i < 8 ; i++){\n\t\t\tvector<string> b = lst[i];\n\t\t\tif( i == 7 ){\n\n\t\t\t\tc[0] = b[0];\n\t\t\t\tc[1] = b[1];\n\t\t\t\tif( c[0].size() == N ){\n\t\t\t\t\tcout << c[0] << endl;\n\t\t\t\t\tcout << c[1] << endl;\t\n\t\t\t\t\tstring res;\n\t\t\t\t\tcin >> res;\t\t\t\n\t\t\t\t\tassert(res==\"end\");\n\t\t\t\t\treturn 0;\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif( used.count(b) ) continue;\n\t\t\t\tused.insert(b);\n\t\t\t\tcout << b[0] << endl;\n\t\t\t\tcout << b[1] << endl;\n\t\t\t\tstring res;\n\t\t\t\tcin >> res;\n\t\t\t\tif( res == \"T\" ){\n\t\t\t\t\tc[0] = b[0];\n\t\t\t\t\tc[1] = b[1];\n\t\t\t\t\tbreak;\t \n\t\t\t\t}\n\t\t\t\tif( res == \"end\"){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n \n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n \n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n \ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n \ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n \nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n \nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n \nchar xx[] = {'.', '#', '.', '#'};\nchar yy[] = {'.', '.', '#', '#'};\n \nint main() {\n    int n; cin >> n; cin.ignore();\n    string s1 = \"\", s2 = \"\", q;\n    string t1, t2;\n    bool back = false;\n    while(1) {\n        rep(i,0,4) {\n            t1 = s1; t2 = s2;\n            if(back) {\n                t1 = xx[i] + t1;\n                t2 = yy[i] + t2;\n            }\n            else {\n                t1 = t1 + xx[i];\n                t2 = t2 + yy[i];\n            }\n            cout << t1 << endl << t2 << endl; fflush(stdout);\n            cin >> q;\n            if(q == \"end\") return 0;\n            else if(q == \"T\") {\n                s1 = t1;\n                s2 = t2;\n                break;\n            }\n            else if(q == \"F\" && i == 3) back = true;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst char c1[4] = { '.', '#', '.', '#' };\nconst char c2[4] = { '.', '.', '#', '#' };\n\nint N;\nbool found;\n\nvoid dfs(string s1, string s2, bool f){\n\tif (s1.size() == N) return;\n\tif (found) return;\n\n\tbool f2 = false;\n\trep (i, 4){\n\t\tstring t1 = \"\", t2 = \"\";\n\t\tif (f){\n\t\t\tt1 = s1 + c1[i];\n\t\t\tt2 = s2 + c2[i];\n\t\t}else{\n\t\t\tt1 = c1[i] + s1;\n\t\t\tt2 = c2[i] + s2;\n\t\t} // end if\n\t\tcout << t1 << endl;\n\t\tcout << t2 << endl;\n\t\tfflush(stdout);\n\t\tstring res; cin >> res;\n\t\tif (res == \"end\"){\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}else\n\t\tif (res[0] == 'T'){\n\t\t\tdfs (t1, t2, f);\n\t\t\tf2 = true;\n\t\t} // end if\n\t} // end rep\n\n\tif (!f2) dfs(s1, s2, !f);\n}\t\n\t\t\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tfound = false;\n\tcin >> N;\n\n\tdfs (\"\", \"\", true);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tchar in_buffer[10] = {};\n\t\n\tdeque<char> atas;\n\tdeque<char> bawah;\n\t\n\tdeque<char> printatas;\n\tdeque<char> printbawah;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas.push_front('.');\n\t\tbawah.push_front('.');\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas.pop_front();\n\t\t\tbawah.pop_front();\n\t\t\tatas.push_front(tempatas[j]);\n\t\t\tbawah.push_front(tempbawah[j]);\n\t\t\t\n\t\t\tprintatas = atas;\n\t\t\tprintbawah = bawah;\n\t\t\t\n\t\t\twhile(!printatas.empty()) {\n\t\t\t\tprintf(\"%c\", printatas.front());\n\t\t\t\tprintatas.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\twhile(!printbawah.empty()) {\n\t\t\t\tprintf(\"%c\", printbawah.front());\n\t\t\t\tprintbawah.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\t\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tatas.pop_front();\n\tbawah.pop_front();\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas.push_back('.');\n\t\tbawah.push_back('.');\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas.pop_back();\n\t\t\tbawah.pop_back();\n\t\t\tatas.push_back(tempatas[j]);\n\t\t\tbawah.push_back(tempbawah[j]);\n\t\t\t\n\t\t\tprintatas = atas;\n\t\t\tprintbawah = bawah;\n\t\t\t\n\t\t\twhile(!printatas.empty()) {\n\t\t\t\tprintf(\"%c\", printatas.front());\n\t\t\t\tprintatas.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\twhile(!printbawah.empty()) {\n\t\t\t\tprintf(\"%c\", printbawah.front());\n\t\t\t\tprintbawah.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\t\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid output(const vector<int>& a) {\n\tfor (int c : a) {\n\t\tcout << ((c&1)?\"#\":\".\");\n\t}\n\tcout << endl;\n\tfor (int c : a) {\n\t\tcout << ((c&2)?\"#\":\".\");\n\t}\n\tcout << endl;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tint mode = 0;\n\tvector<int> a;\n\tfor (;;) {\n\t\tif (!mode) {\n\t\t\ta.push_back(0);\n\t\t} else {\n\t\t\ta.insert(a.begin(), 0);\n\t\t}\n\t\tfor (int i = 0; i < 4; ++ i) {\n\t\t\ta[mode ? 0 : a.size()-1] = i;\n\t\t\toutput(a);\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif (s == \"end\") return 0;\n\t\t\tif (s == \"T\") goto next;\n\t\t}\n\t\tif (mode) throw 1;\n\t\ta.pop_back();\n\t\tmode = 1;\n\t\tnext:;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tstring a=\"\";\n\tstring b=\"\";\n\tstring aa=\"..##\";\n\tstring bb=\".#.#\";\n\twhile(1){\n\t\tbool ok = false;\n\t\trep(i,4){\n\t\t\tstring na = a + aa[i];\n\t\t\tstring nb = b + bb[i];\n\t\t\tcout<<na<<endl<<nb<<endl;\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(t==\"end\") return;\n\t\t\tif(t==\"T\"){\n\t\t\t\tok=true;\n\t\t\t\ta=na;\n\t\t\t\tb=nb;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) break;\n\t}\n\twhile(1){\n\t\tbool ok = false;\n\t\trep(i,4){\n\t\t\tstring na = aa[i] + a;\n\t\t\tstring nb = bb[i] + b;\n\t\t\tcout<<na<<endl<<nb<<endl;\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(t==\"end\") return;\n\t\t\tif(t==\"T\"){\n\t\t\t\tok=true;\n\t\t\t\ta=na;\n\t\t\t\tb=nb;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) break;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n\n\nint n;\nstring c, sx, sy, x[] = {\".\", \".\", \"#\", \"#\"}, y[] = {\".\", \"#\", \".\", \"#\"}, t, lx, ly;\nbool re;\n\nsigned main() {\n\tcin >> n;\n\twhile (1) {\n\t\tif (!re) rep(i,4) {\n\t\t\tcout << sx+x[i] << endl << sy+y[i] << endl << flush;\n\t\t\tcin >> t;\n\t\t\tif (t==\"end\") return 0;\n\t\t\tif (t==\"T\") {\n\t\t\t\tsx += x[i], sy += y[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i==3) re = 1;\n\t\t} else rep(i,4) {\n\t\t\tcout << lx+x[i]+sx << endl << ly+y[i]+sy << endl << flush;\n\t\t\tcin >> t;\n\t\t\tif (t==\"end\") return 0;\n\t\t\tif (t==\"T\") {\n\t\t\t\tlx += x[i], ly += y[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(X) X.begin(), X.end()\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\ntypedef std::pair<LL,LL> PLL;//\ntypedef std::pair<int,int> PII;//\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18+20;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\nbool END = false;\nint ENDcount = 0;\nvector< vector< vector<int> > > word(7);\n\nbool check(vector<int> v){\n\t++ENDcount;\n\tif( ENDcount > 420 ){\n\t\tEND = true;\n\t\treturn true;\n\t}\n\tint size = v.size();\n\tstring A,B;\n\tfor(int i=0;i<size;++i){\n\t\tif( v[i]&1 ){\n\t\t\tA += '#';\n\t\t}else{\n\t\t\tA += '.';\n\t\t}\n\t\tif( v[i]&2 ){\n\t\t\tB += '#';\n\t\t}else{\n\t\t\tB += '.';\n\t\t}\n\t}\n\tcout << A << '\\n' << B << endl;\n\tstring res;\n\tcin >> res;\n\tif( res[0] == 'T' ){\n\t\treturn true;\n\t}else if( res[0] == 'F' ){\n\t\treturn false;\n\t}\n\tEND = true;\n\treturn true;\n}\n\nvoid make(int POW ){\n\tif( POW == 0 ){\n\t\tvector<int> temp(1);\n\t\tfor(int i=0;i<4;++i){\n\t\t\ttemp[0] = i;\n\t\t\tif( check( temp ) ){\n\t\t\t\tword[POW].push_back( temp );\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector< vector<int> >::iterator itrA,itrB,begin,end;\n\tbegin = word[POW-1].begin();\n\tend = word[POW-1].end();\n\tfor(itrA=begin;itrA != end;++itrA){\n\t\tfor(itrB=begin;itrB != end;++itrB){\n\t\t\tvector<int> temp;\n\t\t\ttemp.reserve( 1<<POW );\n\t\t\ttemp.insert( temp.end(), itrA->begin(),itrA->end() );\n\t\t\ttemp.insert( temp.end(), itrB->begin(),itrB->end() );\n\t\t\tif( check( temp ) ){\n\t\t\t\tword[POW].push_back( temp );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid f(int N,int POW){\n\tint LEN = (1<<POW);\n\tint over =2*LEN-N;\n\tvector< vector<int> >::iterator itrA,itrB,begin,end;\n\tbegin = word[POW].begin();\n\tend = word[POW].end();\n\tvector<int> temp(N);\n\tfor(itrA=begin;itrA != end;++itrA){\n\t\tfor(itrB=begin;itrB != end;++itrB){\n\t\t\tbool flag = true;\n\t\t\tfor(int i=0;i<over;++i){\n\t\t\t\tif( itrA[LEN-1-i] != itrB[over-1-i] ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag == false ) continue;\n\t\t\tfor(int i=0;i<N;++i){\n\t\t\t\tif( i < LEN ){\n\t\t\t\t\ttemp[i] = (*itrA)[i];\n\t\t\t\t}else{\n\t\t\t\t\ttemp[i] = (*itrB)[i-(N-LEN)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( check( temp ) ){\n\t\t\t\tif( END ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve(){\n\tint N;\n\tcin >> N;\n\t\n\tint Len = 0;\n\tfor(Len=0;(1<<Len)<=N;++Len){\n\t\tmake(Len);\n\t\tif( END ){\n\t\t\treturn;\n\t\t}\n\t}\n\tLen >>= 1;\n\tf(N,Len);\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\nstring S1, S2;\n\nbool query()\n{\n\tprintf(\"%s\\n%s\\n\", S1.c_str(), S2.c_str());\n\tfflush(stdout);\n\tchar ans[10];\n\tscanf(\"%s\", ans);\n\tif (ans[0] == 'e') exit(0);\n\treturn ans[0] == 'T';\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tbool app_right = true;\n\twhile (S1.size() < N) {\n\t\tif (app_right) {\n\t\t\tS1.push_back('.');\n\t\t\tS2.push_back('.');\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tS1[S1.size() - 1] = (i % 2 == 0 ? '.' : '#');\n\t\t\t\tS2[S2.size() - 1] = (i / 2 == 0 ? '.' : '#');\n\t\t\t\tif (query()) goto nxt;\n\t\t\t}\n\t\t\tapp_right = false;\n\t\t\tS1.pop_back();\n\t\t\tS2.pop_back();\n\t\t}\n\t\tS1.insert(S1.begin(), '.');\n\t\tS2.insert(S2.begin(), '.');\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tS1[0] = (i % 2 == 0 ? '.' : '#');\n\t\t\tS2[0] = (i / 2 == 0 ? '.' : '#');\n\t\t\tif (query()) goto nxt;\n\t\t}\n\tnxt:\n\t\tcontinue;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define FOR( i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define FOR1(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define REV( i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define REV1(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define INC( i, n) FOR( i, 0, n)\n#define INC1(i, n) FOR1(i, 1, n)\n#define DEC( i, n) REV( i, 0, n)\n#define DEC1(i, n) REV1(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n;\nchar s1[101], s2[101];\nint len;\n\nvoid plus() {\n\tlen++;\n\ts1[len] = s2[len] = '\\0';\n}\n\nvoid shift() {\n\tDEC(i, len) {\n\t\ts1[i + 1] = s1[i];\n\t\ts2[i + 1] = s2[i];\n\t}\n}\n\nint ask(int i, int p) {\n\tchar as1[] = \"..##\";\n\tchar as2[] = \".#.#\";\n\tchar r[4];\n\t\n\ts1[p] = as1[i];\n\ts2[p] = as2[i];\n\t\n\tprintf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n\t\n\tscanf(\"%s\", r);\n\t\n\t     if(r[0] == 'F') { return 0; }\n\telse if(r[0] == 'T') { return 1; }\n\telse                 { return 2; }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\t\n\ts1[0] = s2[0] = '\\0';\n\t\n\twhile(len < n) {\n\t\tbool flag = false;\n\t\tbool r_flag = false;\n\t\tint res;\n\t\tplus();\n\t\tif(! r_flag) {\n\t\t\tINC(i, 5) {\n\t\t\t\tif(i == 4) { r_flag = true; break; }\n\t\t\t\tres = ask(i, len - 1);\n\t\t\t\tif(res != 0) { break; }\n\t\t\t}\n\t\t} else {\n\t\t\tshift();\n\t\t\tINC(i, 4) {\n\t\t\t\tres = ask(i, 0);\n\t\t\t\tif(res != 0) { break; }\n\t\t\t}\n\t\t}\n\t\tif(res == 2) { break; }\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nstring check(vector<string> b){\n\tcout << b[0] << endl;\n\tcout << b[1] << endl;\n\tstring res;\n\tcin >> res;\n\tif( res == \"end\") exit(0);\n\treturn res;\n}\n\n\nint main(){\n\tsrand(time(NULL));\n\tint N;\n\tcin >> N;\n\tset<vector<string> > used;\n\n\tvector<string> c(2);\n\tint rev = 0;\n\twhile(true){\n\t\tif( !rev ){\n\t\t\tvector<vector<string>> lst;\n\t\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\t\tb[0] += (k>>0&1?\".\":\"#\");\n\t\t\t\tb[1] += (k>>1&1?\".\":\"#\");\n\t\t\t\tlst.push_back(b);\n\t\t\t}\n\t\t\tint f = 0;\n\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\tif( check(lst[i]) == \"T\" ){\n\t\t\t\t\tc = lst[i];\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !f ){\n\t\t\t\trev = 1;\n\t\t\t}\n\t\t}\n\n\t\tif( rev ){\n\t\t\tvector<vector<string>> lst;\n\t\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\t\tb[0] = (k>>0&1?\".\":\"#\") + b[0];\n\t\t\t\tb[1] = (k>>1&1?\".\":\"#\") + b[1];\n\t\t\t\tlst.push_back(b);\n\t\t\t}\n\t\t\tint f = 0;\n\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\tif( check(lst[i]) == \"T\" ){\n\t\t\t\t\tc = lst[i];\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nchar up[]={'.','#','.','#'}, down[]={'.','#','#','.'};\nstring judge, nowup, nowdown;\n\nint main()\n{\n    cin >> n;\n    while(true) {\n        for(int i=0; i<4; i++) {\n            cout << nowup+up[i] << endl << nowdown+down[i] << endl;\n            cin >> judge;\n            if(judge==\"T\") {\n                nowup+=up[i];\n                nowdown+=down[i];\n            }\n            else if(judge==\"F\") continue;\n            else return 0;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DBG(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nstring str = \".\\n.\\n\";\n\nvoid fuck(string &str) {\n    string up, down;\n    int cnt = 0;\n    for(auto c : str) {\n        if(c != '\\n') {\n            if(cnt & 1) down.push_back(c);\n            else up.push_back(c);\n            ++cnt;\n        }\n    }\n    cout << up << endl;\n    cout << down << endl;\n}\n\nint main(int argc, char **argv) {\n    int n;\n    cin >> n;\n    int cnt = 1;\n    bool toRight = true;\n    while(true) {\n        fuck(str);\n        fflush(stdout);\n        string st;\n        cin >> st;\n        if(st == \"end\") break;\n        if(st == \"F\") {\n            if(cnt == 4) {\n                toRight = !toRight;\n                str.erase(str.size() - 4, 4);\n                str = \".\\n.\\n\" + str;\n                cnt = 1;\n            } else {\n                if(toRight) {\n                    str.erase(str.size() - 4, 4);\n                    string add;\n                    if(cnt & (1 << 0)) add += '#'; else add += '.'; add += '\\n';\n                    if(cnt & (1 << 1)) add += '#'; else add += '.'; add += '\\n';\n                    str += add;\n                    ++cnt;\n                } else {\n                    str.erase(0, 4);\n                    string add;\n                    if(cnt & (1 << 0)) add += '#'; else add += '.'; add += '\\n';\n                    if(cnt & (1 << 1)) add += '#'; else add += '.'; add += '\\n';\n                    str += add;\n                    ++cnt;\n                }\n            }\n        } else if(st == \"T\") {\n            cnt = 1;\n            if(toRight) str += \".\\n.\\n\";\n            else str = \".\\n.\\n\" + str;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nbool stop = false;\nvoid dfs(string s1, string s2) {\n    if (stop) return;\n    string res;\n    rep(i, 2) rep(j, 2) {\n        if (stop) return;\n        char c1 = i == 0 ? '.' : '#';\n        char c2 = j == 0 ? '.' : '#';\n        auto t1 = s1 + c1;\n        auto t2 = s2 + c2;\n        cout << t1 << '\\n';\n        cout << t2 << '\\n';\n        cout << flush;\n        cin >> res;\n        if (res == \"end\") {\n            stop = true;\n            break;\n        }\n        if (res == \"T\") {\n            dfs(t1, t2);\n        }\n    }\n}\nint main() {\n    cin >> N;\n    dfs(\"\", \"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(X) X.begin(), X.end()\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\ntypedef std::pair<LL,LL> PLL;//\ntypedef std::pair<int,int> PII;//\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18+20;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\nbool END = false;\nint ENDcount = 0;\nvector< vector< vector<int> > > word(7);\n\nbool check(vector<int> v){\n\t++ENDcount;\n\tif( ENDcount > 420 ){\n\t\tEND = true;\n\t\treturn true;\n\t}\n\tint size = v.size();\n\tstring A,B;\n\tfor(int i=0;i<size;++i){\n\t\tif( v[i]&1 ){\n\t\t\tA += '#';\n\t\t}else{\n\t\t\tA += '.';\n\t\t}\n\t\tif( v[i]&2 ){\n\t\t\tB += '#';\n\t\t}else{\n\t\t\tB += '.';\n\t\t}\n\t}\n\tcout << A << '\\n' << B << endl;\n\tstring res;\n\tcin >> res;\n\tif( res[0] == 'T' ){\n\t\treturn true;\n\t}else if( res[0] == 'F' ){\n\t\treturn false;\n\t}\n\tEND = true;\n\treturn true;\n}\n\nvoid make(int POW ){\n\tif( POW == 0 ){\n\t\tvector<int> temp(1);\n\t\tfor(int i=0;i<4;++i){\n\t\t\ttemp[0] = i;\n\t\t\tif( check( temp ) ){\n\t\t\t\tword[POW].push_back( temp );\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector< vector<int> >::iterator itrA,itrB,begin,end;\n\tbegin = word[POW-1].begin();\n\tend = word[POW-1].end();\n\tfor(itrA=begin;itrA != end;++itrA){\n\t\tfor(itrB=begin;itrB != end;++itrB){\n\t\t\tvector<int> temp;\n\t\t\ttemp.reserve( 1<<POW );\n\t\t\ttemp.insert( temp.end(), itrA->begin(),itrA->end() );\n\t\t\ttemp.insert( temp.end(), itrB->begin(),itrB->end() );\n\t\t\tif( check( temp ) ){\n\t\t\t\tword[POW].push_back( temp );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid f(int N,int POW){\n\tint LEN = (1<<POW);\n\tint over =2*LEN-N;\n\tvector< vector<int> >::iterator itrA,itrB,begin,end;\n\tbegin = word[POW].begin();\n\tend = word[POW].end();\n\tvector<int> temp(N);\n\tfor(itrA=begin;itrA != end;++itrA){\n\t\tfor(itrB=begin;itrB != end;++itrB){\n\t\t\tbool flag = true;\n\t\t\tfor(int i=0;i<over;++i){\n\t\t\t\tif( itrA[LEN-1-i] != itrB[over-1-i] ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag == false ) continue;\n\t\t\tfor(int i=0;i<N;++i){\n\t\t\t\tif( i < LEN ){\n\t\t\t\t\ttemp[i] = (*itrA)[i];\n\t\t\t\t}else{\n\t\t\t\t\ttemp[i] = (*itrB)[i-(N-LEN)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( check( temp ) ){\n\t\t\t\tif( END ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve(){\n\tint N;\n\tcin >> N;\n\t\n\tint Len = 0;\n\tfor(Len=0;(1<<Len)<=N;++Len){\n\t\tmake(Len);\n\t\tif( END ) return;\n\t}\n\tLen >>= 1;\n\tf(N,Len);\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nusing ll=long long int;\nusing pii=pair<int,int>;\nusing pil=pair<int,ll>;\nusing pli=pair<ll,int>;\nusing pll=pair<ll,ll>;\nusing psi=pair<string,int>;\nusing pis=pair<int,string>;\nusing psl=pair<string,ll>;\nusing pls=pair<ll,string>;\nusing pss=pair<string,string>;\n\n\n\ntemplate<typename T> using vc=vector<T>;\ntemplate<typename T> using vvc=vector<vector<T>>;\ntemplate<typename T> using vvvc=vector<vector<vector<T>>>;\ntemplate<typename T> using vvvvc=vector<vvvc<T>>;\ntemplate<typename T> using vvvvvc=vector<vvvvc<T>>;\n\ntemplate<class T,class U>inline constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>inline constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\ninline void bin101(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(20);\n}\n\ntemplate<typename T>\ninline void Yes(T flag){\n    if(flag) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\ntemplate<typename T>\ninline void YES(T flag){\n    if(flag) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\n//1-indexed vector cin\ntemplate<typename T>\ninline void vin1(vector<T> &v){\n    for(int i=1;i<v.size();i++) cin>>v[i];\n}\n\n//0-indexed vector cin\ntemplate<typename T>\ninline void vin0(vector<T> &v){\n    for(int i=0;i<v.size();i++) cin>>v[i];\n}\n\n//1-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin1(vector<vector<T>> &v){\n    for(int i=1;i<v.size();i++){\n        for(int j=1;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n//0-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin0(vector<vector<T>> &v){\n    for(int i=0;i<v.size();i++){\n        for(int j=0;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<v[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            cout<<i<<\" \"<<j<<\" \"<<v[i][j]<<'\\n';\n        }\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        if(i) cout<<\" \";\n\t\tcout<<v[i];\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n\t\t\tif(j) cout<<\" \";\n            cout<<v[i][j];\n        }\n\t\tcout<<endl;\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            int sssz=v[i][j].size();\n            for(int k=0;k<sssz;k++){\n                cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<v[i][j][k]<<'\\n';\n            }\n        }\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//pair cout\ntemplate<typename T, typename U>\ninline ostream &operator<<(ostream &os,const pair<T,U> &p) {\n  os<<p.first<<\" \"<<p.second;\n  return os;\n}\n\n//pair cin\ntemplate<typename T, typename U>\ninline istream &operator>>(istream &is,pair<T,U> &p) {\n  is>>p.first>>p.second;\n  return is;\n}\n\n//ソート\ntemplate<typename T>\ninline void vsort(vector<T> &v){\n    sort(v.begin(),v.end());\n}\n\n//逆順ソート\ntemplate<typename T>\ninline void rvsort(vector<T> &v){\n  sort(v.rbegin(),v.rend());\n}\n\n//要素数a 初期値x\ntemplate<typename T>\ninline vector<T> vmake(int a,T x){\n  return vector<T>(a,x);\n}\n\n//data[a][b] 初期値x\ntemplate<typename T>\ninline vector<vector<T>> vmake(int a,int b,T x){\n  return vector<vector<T>>(a, vector<T>(b,x));\n}\n\n//data[a][b][c] 初期値x\ntemplate<typename T>\ninline vector<vector<vector<T>>> vmake(int a,int b,int c,T x){\n  return vector<vector<vector<T>>> (a, vector<vector<T>>(b, vector<T>(c, x)));\n}\n\n//data[a][b][c][d]　初期値x\ntemplate<typename T>\ninline vector<vector<vector<vector<T>>>> vmake(int a,int b,int c,int d,T x){\n  return vector<vector<vector<vector<T>>>> (a,vvvc<T>(b,vvc<T>(c,vc<T>(d,x))));\n}\n\n//data[a][b][c][d][e] 初期値x\ntemplate<typename T>\ninline vvvvvc<T> vmake(int a,int b,int c,int d,int e,T x){\n  return vvvvvc<T> (a,vvvvc<T>(b,vvvc<T>(c,vvc<T>(d,vc<T>(e,x)))));\n}\n\n//1ビットの数を返す\ninline int popcount(int x){\n  return __builtin_popcount(x);\n}\n//1ビットの数を返す\ninline int popcount(ll x){\n  return __builtin_popcountll(x);\n}\n\n//queのfront() pop()\ntemplate<typename T>\ninline T pop(queue<T> &que){\n    T x=que.front();\n    que.pop();\n    return x;\n}\n\n//priority_que top() pop()\ntemplate<typename T>\ninline T pop(priority_queue<T> &que){\n  T x=que.top();\n  que.pop();\n  return x;\n}\n\n//stack top() pop()\ntemplate<typename T>\ninline T pop(stack<T> &st){\n  T x=st.top();\n  st.pop();\n  return x;\n}\n\n#define SZ(x) ( (int)x.size()  )\n#define pb push_back\n\n/*\n満たすものの個数を返す\nmode:0 x未満\nmode:1 x以下の数\nmode:2 x以上の数\nmode:3 x超\nmode:4 x\n*/\ntemplate<typename T>\ninline int count_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return lower_bound(v.begin(),v.end(),x)-v.begin();\n        case 1:\n            return upper_bound(v.begin(),v.end(),x)-v.begin();\n        case 2:\n            return v.end()-lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return v.end()-upper_bound(v.begin(),v.end(),x);\n        case 4:\n            return upper_bound(v.begin(),v.end(),x)-lower_bound(v.begin(),v.end(),x);\n    }\n}\n\n/*\nmode:0 xより小さい数で最大の数\nmode:1 x以下の数で最大の数\nmode:2 x以上の数で最小の数\nmode:3 xより大きい数で最小の数\n*/\ntemplate<typename T>\ninline T value_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return *(--lower_bound(v.begin(),v.end(),x));\n        case 1:\n            return *(--upper_bound(v.begin(),v.end(),x));\n        case 2:\n            return *lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return *upper_bound(v.begin(),v.end(),x);\n    }\n}\n\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr ll MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nsigned main(){\n\tbin101();\n\n\tint N;\n\tcin>>N;\n\tint now=0;\n\tstring up;\n\tstring down;\n\tstring du=\"..##\",dd=\".#.#\";\n\twhile(true){\n\t\tbool flag=false;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tup+=du[i]; down+=dd[i];\n\t\t\tcout<<up<<\"\\n\";\n\t\t\tcout<<down<<endl;\n\t\t\tchar t; cin>>t;\n\t\t\tif(t=='F'){\n\t\t\t\tup.pop_back();\n\t\t\t\tdown.pop_back();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(flag && up.size()!=N) continue;\n\t\tbreak;\n\t}\n\tif(up.size()==N){\n\t\treturn 0;\n\t}\n\twhile(true){\n\t\tstring U,D;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tU=du[i]+up; D=dd[i]+down;\n\t\t\tcout<<U<<\"\\n\";\n\t\t\tcout<<D<<endl;\n\t\t\tchar t; cin>>t;\n\t\t\tif(t=='F'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tup=U; down=D;\n\t\t\tif(up.size()==N){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n#define Yes(condition) if(condition){ cout << \"Yes\" << '\\n'; }else{ cout << \"No\" << '\\n'; }\n#define YES(condition) if(condition){ cout << \"YES\" << '\\n'; }else{ cout << \"NO\" << '\\n'; }\n#define yes(condition) if(condition){ cout << \"yes\" << '\\n'; }else{ cout << \"no\" << '\\n'; }\n\n\n\n\n\nint main() {\n    ll n;\n    cin >> n;\n    string s[2];\n    REP(i, n){\n        string t;\n        \n        s[0] += \".\";\n        s[1] += \".\";\n        cout << s[0] << endl << s[1] << endl;\n        cin >> t;\n        if(t == \"end\") return 0;\n        if(t == \"T\") continue;\n        \n        s[0][i] = '#';\n        cout << s[0] << endl << s[1] << endl;\n        cin >> t;\n        if(t == \"end\") return 0;\n        if(t == \"T\") continue;\n        \n        s[0][i] = '.';\n        s[1][i] = '#';\n        cout << s[0] << endl << s[1] << endl;\n        cin >> t;\n        if(t == \"end\") return 0;\n        if(t == \"T\") continue;\n        \n        s[0][i] = '#';\n        cout << s[0] << endl << s[1] << endl;\n        cin >> t;\n        if(t == \"end\") return 0;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N;\n    cin >> N;\n    vector<string> s(2);\n    bool toRight = true;\n    while (true) {\n        rep(state, 4) {\n            if (toRight) {\n                cout << s[0] + (state % 2 ? '.' : '#') << endl;\n                cout << s[1] + (state / 2 ? '.' : '#') << endl;\n            } else {\n                cout << (state % 2 ? '.' : '#') + s[0] << endl;\n                cout << (state / 2 ? '.' : '#') + s[1] << endl;\n            }\n            string ret;\n            cin >> ret;\n            if (ret[0] == 'e') {\n                return 0;\n            } else if (ret[0] == 'T') {\n                // next_step\n                if (toRight) {\n                    s[0] = s[0] + (state % 2 ? '.' : '#');\n                    s[1] = s[1] + (state / 2 ? '.' : '#');\n                } else {\n                    s[0] = (state % 2 ? '.' : '#') + s[0];\n                    s[1] = (state / 2 ? '.' : '#') + s[1];\n                }\n                break;\n            } else {\n                // go_on_this_step\n\n                if (state == 3) {\n                    // change_direction\n                    assert(toRight);\n                    toRight = false;\n                }\n            }\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n%s\\n\", u.c_str(), d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  int sw = 0;\n  while (true) {\n    int j;\n    for (j = 0; j < 4; ++j) {\n      string r = (sw == 0 ? ask(u + du[j], d + dd[j]) : ask(du[j] + u, dd[j] + d));\n      if (r == \"end\") {\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    if (j == 4) {\n      sw = 1 - sw;\n      continue;\n    }\n    if (sw == 0) {\n      u += du[j];\n      d += dd[j];\n    } else {\n      u = du[j] + u;\n      d = dd[j] + d;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n \n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n \n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n \ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n \ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n \nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n \nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n \nchar xx[] = {'.', '#', '.', '#'};\nchar yy[] = {'.', '.', '#', '#'};\n \nint main() {\n    int n; cin.ignore();\n    string s1 = \"\", s2 = \"\", q;\n    string t1, t2;\n    bool back = false;\n    while(1) {\n        rep(i,0,4) {\n            t1 = s1; t2 = s2;\n            if(back) {\n                t1 = xx[i] + t1;\n                t2 = yy[i] + t2;\n            }\n            else {\n                t1 = t1 + xx[i];\n                t2 = t2 + yy[i];\n            }\n            cout << t1 << endl << t2 << endl; fflush(stdout);\n            cin >> q;\n            if(q == \"end\") return 0;\n            else if(q == \"T\") {\n                s1 = t1;\n                s2 = t2;\n                break;\n            }\n            else if(q == \"F\" && i == 3) back = true;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <iostream>\n#include <ctime>\n#include <complex>\n\n#define enp \tprintf(\"**Entry Point**\\n\")\n#define A\t\tfirst\n#define B\t\tsecond\n#define MP\t\tmake_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 0x6fffffff;\nconst int MINF = 0x80000000;\nconst ll mod = 100003;\nconst int cons = 100001;\nconst double pi = 3.141592653589793;\n\nchar ch[2] = { '.', '#' };\nint nxt[4][2];\n\nint main()\n{\n\tnxt[0][0] = 0;\n\tnxt[0][1] = 1;\n\tnxt[1][0] = 1;\n\tnxt[1][1] = 0;\n\tnxt[2][0] = 1;\n\tnxt[2][1] = 1;\n\tnxt[3][0] = 0;\n\tnxt[3][1] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstring s1, s2;\n\tint i1 = 0, i2 = 0;\n\tbool flag = true;\n\tint cur = 0;\n\n\twhile (1)\n\t{\n\t\tif (flag)\n\t\t{\n\t\t\ts1 += ch[i1];\n\t\t\ts2 += ch[i2];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts1 = ch[i1] + s1;\n\t\t\ts2 = ch[i2] + s2;\n\t\t}\n\n\t\tprintf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str());\n\n\t\tstring ans;\n\t\tcin >> ans;\n\t\tif (ans == \"END\")break;\n\n\t\tif (ans == \"F\")\n\t\t{\n\t\t\ti1 = nxt[cur][0];\n\t\t\ti2 = nxt[cur][1];\n\n\t\t\tcur++;\n\t\t\tcur %= 4;\n\t\t\tif (cur == 0)\n\t\t\t{\n\t\t\t\tflag ^= true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\ts1.pop_back();\n\t\t\t\t\ts2.pop_back();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1 = s1.substr(1);\n\t\t\t\t\ts2 = s2.substr(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti1 = 0;\n\t\t\ti2 = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<numeric>\n#include<functional>\n#include<algorithm>\n#include<bitset>\n#include<tuple>\n#include<unordered_set>\n#include<random>\n#include<array>\n#include<cassert>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define uniq(v) v.erase(unique(all(v)),v.end())\n\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint w=0;\n\tint n;\n\tcin>>n;\n\tstring s1,s2;\n\twhile (1){\n\t\tint a=-1;\n\t\trep(i,4){\n\t\t\tcout<<s1;\n\t\t\tcout << (i/2?'.':'#')<<endl;\n\t\t\tcout << s2;\n\t\t\tcout << (i % 2 ? '.' : '#') << endl;\n\t\t\tstring res;\n\t\t\tcin>>res;\n\t\t\tif (res==\"end\")return 0;\n\t\t\tif (res == \"T\"){\n\t\t\t\ta=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (a==-1)break;\n\t\ts1 += a / 2 ? '.' : '#';\n\t\ts2 += a % 2 ? '.' : '#';\n\t\tw++;\n\t}\n\twhile (w < n){\n\t\trep(i, 4){\n\t\t\tcout << (i / 2 ? '.' : '#') <<s1<< endl;\n\t\t\tcout << (i % 2 ? '.' : '#') <<s2<< endl;\n\t\t\tstring res;\n\t\t\tcin >> res;\n\t\t\tif (res==\"end\")return 0;\n\t\t\tif (res == \"T\"){\n\t\t\t\ts1 = (i / 2 ? '.' : '#')+s1;\n\t\t\t\ts2 = (i % 2 ? '.' : '#')+s2;\n\t\t\t\tw++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool query(string s, string t){\n\tcout << s << endl;\n\tcout << t << endl;\n\tstring r; cin >> r;\n\tif(r == \"end\") exit(0);\n\treturn r[0] == 'T';\n}\nint main(){\n\tint n; cin >> n;\n\tstring s1, s2;\n\twhile(true){\n\t\tchar a = 0, b = 0;\n\t\tfor(char va : {'.', '#'}){\n\t\t\tfor(char vb : {'.', '#'}){\n\t\t\t\tif(query(s1 + va, s2 + vb)){\n\t\t\t\t\ta = va;\n\t\t\t\t\tb = vb;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a) break;\n\t\t}\n\t\tif(a){\n\t\t\ts1 += a;\n\t\t\ts2 += b;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(true){\n\t\tchar a = 0, b = 0;\n\t\tfor(char va : {'.', '#'}){\n\t\t\tfor(char vb : {'.', '#'}){\n\t\t\t\tif(query(va + s1, vb + s2)){\n\t\t\t\t\ta = va;\n\t\t\t\t\tb = vb;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(a) break;\n\t\t}\n\t\tif(a){\n\t\t\ts1 = a + s1;\n\t\t\ts2 = b + s2;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main()\n{\n  int n;\n  string s1;\n  string s2;\n  string ans;\n  char add[4][2]={{'.','.'},{'#','.'},{'.','#'},{'#','#'}};\n  int i;\n  int l=4;\n  cin>>n;\n\n  printf(\"#\\n#\\n\");\n  fflush(stdout);\n  cin>>ans;\n  if(ans==\"end\")return 0;\n  if(ans==\"T\"){\n    s1=\"#\";\n    s2=\"#\";\n  }else{\n    l--;\n    printf(\".\\n#\\n\");\n    fflush(stdout);\n    cin>>ans;\n    if(ans==\"end\")return 0;\n    if(ans==\"T\"){\n      s1=\".\";\n      s2=\"#\";\n    }else{\n      l--;\n      printf(\"#\\n.\\n\");\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n      if(ans==\"T\"){\n\ts1=\"#\";\n\ts2=\".\";\n      }else{\n\tl--;\n\ts1=\".\";\n\ts2=\".\";\n      }\n    }\n  }\n\n  while(1){\n    rep(i,l){\n      cout<<s1<<add[i][0]<<endl;\n      cout<<s2<<add[i][1]<<endl;\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n      if(ans==\"T\"){\n\ts1=s1+add[i][0];\n\ts2=s2+add[i][1];\n\tbreak;\n      }\n    }\n    if(i==l){\n      rep(i,l){\n\tcout<<add[i][0]<<s1<<endl;\n\tcout<<add[i][1]<<s2<<endl;\n\tfflush(stdout);\n\tcin>>ans;\n\tif(ans==\"end\")return 0;\n\tif(ans==\"T\"){\n\t  s1=add[i][0]+s1;\n\t  s2=add[i][1]+s2;\n\t  break;\n\t}\n      }\n    }\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <random>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\n\ntypedef\ntree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> orderedSet;\n\n#define pb push_back\n#define F first\n#define S second\n#define all(a) (a).begin(), (a).end()\n\n#define for1(i0, l0, r0) for (int i0 = l0; i0 < r0; ++i0)\n#define for2(i0, l0, r0) for (int i0 = l0; i0 <= r0; ++i0)\n#define forn(i0, n0) for (int i0 = 0; i0 < n0; ++i0)\n#define forn1(i0, n0) for (int i0 = 1; i0 < n0; ++i0)\n#define forr(i0, n0) for (int i0 = n0; i0 >= 0; --i0)\n#define forr1(i0, r0, l0) for (int i0 = r0; i0 > l0; --i0)\n#define forr2(i0, r0, l0) for (int i0 = r0; i0 >= l0; --i0)\n\n#define Sort(a) sort(all(a))\n#define Reverse(a) reverse(all(a))\n#define relaxMax(a, b) a = max(a, b)\n#define relaxMin(a, b) a = min(a, b)\n\ntypedef long double ld;\n#define ui unsigned int\n#define ull unsigned long long\n\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef pair<string, string> pss;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<ld> vld;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\n\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\n\ntypedef vector<vi> vvi;\ntypedef vector<vd> vvd;\ntypedef vector<vll> vvll;\ntypedef vector<vb> vvb;\n\n#define vpss vector<pss>\n#define vvs vector<vs>\n#define vvpii vector<vpii>\n#define vvpll vector<vpll>\n#define vpt vector<pt>\n#define vvvi vector<vvi>\n#define vsi vector<set<int>>\n#define ss second\n#define ff first\n\n#define printvi(arr) for (int x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printvll(arr) for (ll x0 : arr) cout << x0 << ' '; cout << '\\n';\n#define printpair(pair0) cout << pair0.F << ' ' << pair0.S << '\\n';\n#define printvp(arr) for (auto pair0 : arr) printpair(pair0);\n#define initArray(arr, N0, X0) memset(arr, X0, N0 * sizeof(int))\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid init() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.precision(16);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string s1, s2;\n    bool end = false;\n    forn(i, n){\n        bool flag = false;\n        if (!end) {\n            for (char c1 : {'.', '#'}) {\n                for (char c2 : {'.', '#'}) {\n                    cout << s1 + c1 << '\\n' << s2 + c2 << endl;\n                    string r;\n                    cin >> r;\n                    if (r == \"end\") return;\n                    if (r == \"T\") {\n                        s1 += c1;\n                        s2 += c2;\n                        flag = true;\n                        break;\n                    }\n                }\n                if (flag){\n                    break;\n                }\n            }\n            if (!flag) end = true;\n        }\n        if (end){\n            for (char c1 : {'.', '#'}) {\n                for (char c2 : {'.', '#'}) {\n                    cout << c1 << s1 << '\\n' << c2 << s2 << endl;\n                    string r;\n                    cin >> r;\n                    if (r == \"end\") return;\n                    if (r == \"T\") {\n                        s1 = c1 + s1;\n                        s2 = c2 + s2;\n                        flag = true;\n                        break;\n                    }\n                }\n                if (flag){\n                    break;\n                }\n            }\n        }\n    }\n}\n\nbool multitest = false;\n\nint main() {\n    init();\n    int t = 1;\n    if (multitest) cin >> t;\n    forn(i, t) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n;\n  char s1[501],s2[501];\n  scanf(\"%d\",&n);\n  int x = 200;\n  while(true){\n    bool flag = true;\n    for(int i=0;i<4;i++){\n      char res[3];\n      if(i==0){\n        s1[x] = '.';\n        s2[x] = '.';\n      }else if(i==1){\n        s1[x] = '#';\n        s2[x] = '.';\n      }else if(i==2){\n        s1[x] = '.';\n        s2[x] = '#';\n      }else if(i==3){\n        s1[x] = '#';\n        s2[x] = '#';\n      }\n      s1[x+1] = '\\0';\n      s2[x+1] = '\\0';\n      printf(\"%s\\n%s\\n\", s1+200, s2+200); fflush(stdout);\n      scanf(\"%s\",res);\n      if(res[0]=='T'){\n        flag = false;\n        x++;\n        break;\n      }\n    }\n    if(flag){\n      s1[x] ='\\0';\n      s2[x] ='\\0';\n      break;\n    }\n  }\n  x = 199;\n  while(true){\n    bool flag = true;\n    for(int i=0;i<4;i++){\n      char res[3];\n      if(i==0){\n        s1[x] = '.';\n        s2[x] = '.';\n      }else if(i==1){\n        s1[x] = '#';\n        s2[x] = '.';\n      }else if(i==2){\n        s1[x] = '.';\n        s2[x] = '#';\n      }else if(i==3){\n        s1[x] = '#';\n        s2[x] = '#';\n      }\n      printf(\"%s\\n%s\\n\", s1+x, s2+x); fflush(stdout);\n      scanf(\"%s\",res);\n      if(res[0]=='T'){\n        flag = false;\n        x--;\n        break;\n      }\n    }\n    if(flag) break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//1列(4通り)を質問 -> 当たったら1列（右側に）追加して(4通り)質問 -> …を繰り返すと400回以内で当たらなくなる（かendが返る）\n//このとき、質問した列は黒板の右端にある。あとは、同様にして左側を特定すればよい。\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring reverse(string str) {\n\tstring ret;\n\tfor (int i = (int)str.length() - 1; i >= 0; i--) ret += str[i];\n\treturn ret;\n}\n\nint n;\nstring query[2];\n\nvoid addCharRight(int type) {\n\tchar c0 = ((type / 2) % 2 ? '#' : '.');\n\tchar c1 = (type % 2 ? '#' : '.');\n\tquery[0] += c0;\n\tquery[1] += c1;\n}\n\nvoid addCharLeft(int type) {\n\tchar c0 = ((type / 2) % 2 ? '#' : '.');\n\tchar c1 = (type % 2 ? '#' : '.');\n\tquery[0] = reverse(query[0]);\n\tquery[1] = reverse(query[1]);\n\tquery[0] += c0;\n\tquery[1] += c1;\n\tquery[0] = reverse(query[0]);\n\tquery[1] = reverse(query[1]);\n}\n\nvoid delCharRight() {\n\tstring s[2];\n\tfor (int i = 0; i < (int)query[0].size() - 1; i++) s[0] += query[0][i];\n\tfor (int i = 0; i < (int)query[1].size() - 1; i++) s[1] += query[1][i];\n\tquery[0] = s[0];\n\tquery[1] = s[1];\n}\n\nvoid delCharLeft() {\n\tstring s[2];\n\tfor (int i = 1; i < (int)query[0].size(); i++) s[0] += query[0][i];\n\tfor (int i = 1; i < (int)query[1].size(); i++) s[1] += query[1][i];\n\tquery[0] = s[0];\n\tquery[1] = s[1];\n}\n\n//return : {T, F, end}\nchar getQuery() {\n\tcout << query[0] << endl;\n\tcout << query[1] << endl;\n\tcout.flush();\n\tstring ret;\n\tcin >> ret;\n\treturn ret[0];\n}\n\n//return : {T, F, e}\nchar addQueryRight(int type) {\n\taddCharRight(type);\n\tchar res = getQuery();\n\tif (res == 'e' || res == 'T') return res;\n\tdelCharRight();\n\treturn res;\n}\n\nchar addQueryLeft(int type) {\n\taddCharLeft(type);\n\tchar res = getQuery();\n\tif (res == 'e' || res == 'T') return res;\n\tdelCharLeft();\n\treturn res;\n}\n\nsigned main() {\n\tcin >> n;\n\t\n\tint j;\n\t\n\twhile (true) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tchar res = addQueryRight(j);\n\t\t\tif (res == 'e') return 0;\n\t\t\tif (res == 'T') break;\n\t\t}\n\t\tif (j == 4) break;\n\t}\n\t\n\twhile (true) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tchar res = addQueryLeft(j);\n\t\t\tif (res == 'e') return 0;\n\t\t\tif (res == 'T') break;\n\t\t}\n\t\tif (j == 4) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8101145141919364364;\n\nint main(){\n\tint n; cin>>n;\n\tstring r,s1,s2;\n\tstring eins[]={\".\",\".\",\"#\",\"#\"};\n\tstring zwei[]={\".\",\"#\",\".\",\"#\"};\n\twhile(1){\n\t\trep(i,4){\n\t\t\tstring tmp1=eins[i]+s1;\n\t\t\tstring tmp2=zwei[i]+s2;\n\t\t\tprintf(\"%s\\n%s\\n\",tmp1,tmp2); fflush(stdout);\n\t\t\tcin>>r;\n\t\t\tif(r==\"end\") return 0;\n\t\t\tif(r==\"T\"){\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(i==2){\n\t\t\t\ttmp1=eins[3]+s1;\n\t\t\t\ttmp2=zwei[3]+s2;\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint x=s1.size();\n\t\tif(x==n){\n\t\t\tprintf(\"%s\\n%s\\n\",s1,s2); fflush(stdout);\n\t\t\tcin>>r;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring s,t;\nint N;\nmain()\n{\n\tcin>>N;\n\tbool head=true;\n\twhile(true)\n\t{\n\t\tbool now=false;\n\t\tfor(int r=0;r<4;r++)\n\t\t{\n\t\t\tif(head)\n\t\t\t{\n\t\t\t\tcout<<(r&1?'#':'.')<<s<<endl;\n\t\t\t\tcout<<(r&2?'#':'.')<<t<<endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<s<<(r&1?'#':'.')<<endl;\n\t\t\t\tcout<<t<<(r&2?'#':'.')<<endl;\n\t\t\t}\n\t\t\tstring ans;cin>>ans;\n\t\t\tif(ans==\"end\")return 0;\n\t\t\tif(ans==\"T\")\n\t\t\t{\n\t\t\t\tnow=true;\n\t\t\t\tif(head)\n\t\t\t\t{\n\t\t\t\t\ts=(r&1?\"#\":\".\")+s;\n\t\t\t\t\tt=(r&2?\"#\":\".\")+t;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts+=r&1?'#':'.';\n\t\t\t\t\tt+=r&2?'#':'.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!now)head=!head;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint now = 1;\n\tstring s1 = \"\";\n\tstring s2 = \"\";\n\tstring r = \"\";\n\t\n\twhile(r != \"end\"){\n\t\tif(r == \"F\"){\n\t\t\tif(s1[s1.length() - 1] == '.' && s2[s2.length() - 1] == '.'){\n\t\t\t\ts1[s1.length() - 1] = '#';\n\t\t\t}else if(s1[s1.length() - 1] == '#' && s2[s2.length() - 1] == '.'){\n\t\t\t\ts1[s1.length() - 1] = '.';\n\t\t\t\ts2[s2.length() - 1] = '#';\n\t\t\t}else if(s1[s1.length() - 1] == '.' && s2[s2.length() - 1] == '#'){\n\t\t\t\ts1[s1.length() - 1] = '#';\n\t\t\t\tif(now < n){\n\t\t\t\t\ts1 += \".\";\n\t\t\t\t\ts2 += \".\";\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\ts1 += \".\";\n\t\t\ts2 += \".\";\n\t\t\tnow++;\n\t\t}\n\t\t\n\t\tcout << s1 << endl;\n\t\tcout << s2 << endl;\n\t\tfflush(stdout);\n\n\t\tcin >> r;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\nusing namespace std;\n     \nint main(){\n  int N;\n  cin >> N;\n  string table[2];\n  bool flag = false;\n  \n  while(1){\n    // query\n    string n_table[2];\n    int cnt = 0;\n\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n    \tn_table[j] = table[j];\n      }\n\n      if(flag){\n\tn_table[0] += (i%2?'#':'.');\n\tn_table[1] += ((i >> 1)%2?'#':'.');\n      }\n      else {\n\tstring s1 = (i%2?'#':'.');\n\tstring s2 = ((i >> 1)%2?'#':'.');\n\tn_table[0] = s1 + n_table[0];\n\tn_table[1] = s2 + n_table[1];\n      }\n          \n      printf(\"%s\\n%s\\n\", n_table[0].c_str(), n_table[1].c_str()); fflush(stdout);\n      // in\n      string str;\n      cin >> str;\n      if(str == \"T\"){\n    \tfor(int j = 0 ; j < 2 ; j++){\n    \t  table[j] = n_table[j];\n    \t}\n    \tbreak;\n      }\n      if(str == \"F\"){\n\tcnt++;\n      }\n      else if(str == \"end\"){\n    \treturn 0;\n      }\n    }\n    if(cnt == 4)flag = true;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for (int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for (int (i) = (a) - 1; (i) >= (b); (i)--)\n#define PI acos(-1.0)\n#define DEBUG(C) cout<< C <<endl;\n#define VI vector <int>\n#define VII vector <VI>\n#define VL vector <LL>\n#define VLL vector <VL>\n#define VD vector <double>\n#define VDD vector <VD>\n#define PII pair <int, int>\n#define PDD pair <double, double>\n#define PLL pair <LL, LL>\n#define VPII vector <PII>\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define REVERSE(a) reverse(ALL(a))\n#define MP make_pair\n#define EB emplace_back\n#define FORE(a, b) for (auto &&a:b)\n#define FIND(s, n) (s.find(n) != s.end())\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int INF = 1e9;\nconst int MOD = INF + 7;\n\nstring cc[2];\n\nint main(void) {\n    cc[0] = \"..##\";\n    cc[1] = \".#.#\";\n    set <vector <string>> nai;\n    int N; cin >> N;\n    vector <string> S(2, \"\"), Sbuf(2);\n    int cnt = 0;\n    S[0] += cc[0][0];\n    S[1] += cc[1][0];\n    bool f = false;\n    REP(_, 420) {\n        printf(\"%s\\n%s\\n\", S[0].c_str(), S[1].c_str());\n        string c; cin >> c;\n        if (c == \"T\") {\n            Sbuf = S;\n            cnt = 0;\n            REP(i, 2) {\n                S[i] += cc[i][cnt];\n            }\n        } else if (c == \"F\") {\n            nai.insert(S);\n            label:\n            S = Sbuf;\n            cnt++;\n            if (cnt >= 4 || f) {\n                f = true;\n                REP(i, 2) {\n                    S[i] = cc[i][cnt % 4] + S[i];\n                }\n            } else {\n                REP(i, 2) {\n                    S[i] += cc[i][cnt % 4];\n                }\n            }\n            if (FIND(nai, S)) {\n                goto label;\n            }\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MEM(a,b) memset((a),(b),sizeof(a))\nconst LL INF = 1e9 + 7;\nconst int N = 1e3 + 10;\nstring x = \"..##\";\nstring y = \".#.#\";\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tstring s1, s2;\n\tint n;\n\tcin >> n;\n\tint len = 0;\n\tint flag = 1;\n\tchar c;\n\twhile (1)\n\t{\n\t\tif (s1.length() == n) break;\n\t\tif (flag)\n\t\t{\n\t\t\tint key = -1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tcout << s1 << x[i] << '\\n';\n\t\t\t\tcout << s2 << y[i] << endl;\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == 'T')\n\t\t\t\t{\n\t\t\t\t\tkey == i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif (key == -1) flag = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\ts1.push_back(x[key]);\n\t\t\t\ts2.push_back(y[key]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint key = -1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tcout << x[i] << s1 << '\\n';\n\t\t\t\tcout << y[i] << s2 << endl;\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == 'T')\n\t\t\t\t{\n\t\t\t\t\tkey = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (key == -1) break;\n\t\t\ts1 = x[key] + s1;\n\t\t\ts2 = y[key] + s2;\n\t\t}\n\t}\n\tcout << s1 << endl;\n\tcout << s2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nchar s[SIZE];\nint main(){\n    DRI(N);gets(s);\n    string up,dn;\n    bool right=1;\n    while(SZ(up)<N){\n        if(!right){\n            up=\".\"+up;\n            dn=\".\"+dn;\n        }\n        if(right){\n            up+=\".\";\n            dn+=\".\";\n            cout<<up<<endl<<dn<<endl;\n            fflush(stdout);\n            gets(s);\n            if(s[0]!='F')continue;\n\n            up[SZ(up)-1]='#';\n            cout<<up<<endl<<dn<<endl;\n            fflush(stdout);\n            gets(s);\n            if(s[0]!='F')continue;\n            \n            dn[SZ(dn)-1]='#';\n            cout<<up<<endl<<dn<<endl;\n            fflush(stdout);\n            gets(s);\n            if(s[0]!='F')continue;\n            \n            up[SZ(up)-1]='.';\n            cout<<up<<endl<<dn<<endl;\n            fflush(stdout);\n            gets(s);\n            if(s[0]!='F')continue;\n            right=0;\n            up=\".\"+up.substr(0,SZ(up)-1);\n            dn=\".\"+dn.substr(0,SZ(dn)-1);\n        }\n        cout<<up<<endl<<dn<<endl;\n        fflush(stdout);\n        gets(s);\n        if(s[0]!='F')continue;\n        \n        up[0]='#';\n        cout<<up<<endl<<dn<<endl;\n        fflush(stdout);\n        gets(s);\n        if(s[0]!='F')continue;\n\n        dn[0]='#';\n        cout<<up<<endl<<dn<<endl;\n        fflush(stdout);\n        gets(s);\n        if(s[0]!='F')continue;\n\n        up[0]='.';\n        cout<<up<<endl<<dn<<endl;\n        fflush(stdout);\n        gets(s);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstring temp = \".#\";\n\nint main()\n{\n  int N;\n  cin >> N;\n\n  string Low, High;\n  bool left = false;\n  bool right = false;\n\n  for(char c : temp) {\n    for(char d : temp) {\n      for(char e : temp) {\n        for(char f : temp) {\n          string U = Low + string(1, c) + string(1, d);\n          string E = High + string(1, e) + string(1, f);\n          cout << U << endl;\n          cout << E << endl;\n          char cc;\n          cin >> cc;\n          if(cc == 'T') {\n            Low = U;\n            High = E;\n            goto foo;\n          }\n        }\n      }\n    }\n  }\n  while(Low.size() < N) {\n    if(!left) {\n      for(char c : temp) {\n        for(char e : temp) {\n          string U = Low + string(1, c);\n          string E = High + string(1, e);\n          cout << U << endl;\n          cout << E << endl;\n          string cc;\n          cin >> cc;\n          if(cc == \"T\") {\n            Low = U;\n            High = E;\n            goto foo;\n          } else if(cc == \"end\") {\n            return (0);\n          }\n        }\n      }\n    }\n    left = true;\n\n    if(!right) {\n      for(char c : temp) {\n        for(char e : temp) {\n          string U = string(1, c) + Low;\n          string E = string(1, e) + High;\n          cout << U << endl;\n          cout << E << endl;\n          string cc;\n          cin >> cc;\n          if(cc == \"T\") {\n            Low = U;\n            High = E;\n            goto foo;\n          } else if(cc == \"end\") {\n            return (0);\n          }\n        }\n      }\n    }\n    foo:;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n\nstring query(pair<string,string> p1,pair<string,string> p2){\n  string s1,s2;\n  s1 = p1.first + p2.first;\n  s2 = p1.second + p2.second;\n  printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n  string str;\n  cin >> str;\n  return str;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  set<pair<string,string> >st;\n  for(int i = 0 ; i < 2 ; i++){\n    string str1;\n    string str2;\n    for(int j = 0 ; j < 4 ; j++){\n      str1 += (j%2?\".\":\"#\");\n      str2 += ((j >> 1)%2?\".\":\"#\");\n    }\n    st.insert(make_pair(str1,str2));\n  }\n  \n  while(1){\n    vector<pair<string,string>vec(st.begin(),st.end());\n    for(int i = 0 ; i < vec.size() ; i++){\n      for(int j = i ; j < vec.size() ; j++){\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  string r;\n\t  pair<string,string>p;\n\t  if(k % 2){\n\t    r = query(vec[i],vec[j]);\n\t    p = make_pair(vec[i].first + vec[j].first,vec[i].second + vec[j].second);\n\t  }\n\t  else {\n\t    r = query(vec[j],vec[i]);\n\t    p = make_pair(vec[j].first + vec[i].first,vec[j].second + vec[i].second);\n\t  }\n\t  // in\n\t  if(r == \"T\"){\n\t    st.insert(p);\n\t  }\n\t  else if(r == \"end\"){\n\t    return 0;\n\t  }\n\t}\n      }\n    }\n  }\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef  long long ll;\n//double pi=3.1415926535898;\n//double pi=acos(-1.0);\n#define scarr(a,s,e) for(int i=s;i<=int(e);i++) scanf(\"%d \",&a[i]);\n#define prarr(a,s,e) for(int i=s;i<=int(e);i++) printf(\"%d \",a[i]);\n#define speed      ios::sync_with_stdio(false);cin.tie(NULL); cout.tie(NULL);\n#define rng(i,a,b) for(int i=a;i>=int(b);i--)\n#define rep(i,a,b) for(int i=a;i<=int(b);++i)\n#define lop(i,n)   for(int i=0;i<int(n);i++)\n#define ms(x,a)    memset(x,a,sizeof(x))\n#define all(x)     (x).begin(),(x).end()\n#define sz(x)      int(x.size())\n#define pb         push_back\n#define mkp        make_pair\n#define fr         first\n#define se         second\n#define sc(x)      scanf(\"%d\",&x)\n#define pr(x)      printf(\"%d \",x)\n#define scl(x)     scanf(\"%lld\",&x)\n#define prl(x)     printf(\"%lld \",x)\n#define prln(x)    printf(\"%d\\n\",x)\n#define r0         return 0;\n#define CC         continue;\n#define scd(x)     scanf(\"%lf\",&x)\n#define prd(x)     printf(\"%.10f\\n\",x);\n#define bb(x)      cerr<< x <<endl;\n#define ii         pair<int,int>\n//#define max(a,b) a<b?b:a\n//#define min(a,b) a<b?a:b\nconst ll M   = 1e7+9 ;\nconst ll inf = 1e19  ;\nconst int si = 1e5+9 ;\n//////////////////////    Hi    ^_^  hack me if you can :P\n\nchar b(bool x)\n{\n    return x?'#':'.';\n}\nbool q(string&s1,string&s2)\n{\n    cout<<s1<<endl<<s2<<endl;\n    fflush(stdout);\n    string ans;\n    cin>>ans;\n    if(ans==\"end\")\n        exit(0);\n    return ans==\"T\";\n}\nint main()\n{\n    int n ;\n    cin >> n;\n    string s1 = \"\",s2 = \"\";\n    lop(i,4)\n    {\n        s1=b(i&1);\n        s2=b(i&2);\n        if(q(s1,s2))\n        {\n            break;\n        }\n    }\n    while (1) {\n    bool ok = 0;\n    lop(i, 4) {\n      string q1 = s1 + b(i & 1);\n      string q2 = s2 + b(i & 2);\n      if (q(q1, q2)) {\n        ok = 1;\n        s1 = q1;\n        s2 = q2;\n        break;\n      }\n    }\n    if (!ok) break;\n  }\n  while (1) {\n    bool ok = 0;\n    lop(i, 4) {\n      string q1 = b(i & 1) + s1;\n      string q2 = b(i & 2) + s2;\n      if (q(q1, q2)) {\n        ok = 1;\n        s1 = q1;\n        s2 = q2;\n        break;\n      }\n    }\n    if (!ok) break;\n  }\n\n    r0;\n}\n\n\n/*\n\nll pwmod(ll a, ll n, ll mod) {\n    ll ret = 1;\n    while (n) {\n        if (n & 1) ret = ret * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\n*/\n/*\nfreopen(\"output.txt\",\"w\",stdout);\nfreopen(\"input.txt\",\"r\",stdin);\nfor (int i=0;i<n;i++)            Hi    ^_^  hack me if you can :P\nint mx[]= {0,0,1,1,1,-1,-1,-1};\nint my[]= {1,-1,0,1,-1,0,1,-1};\nbool inside (int i,int j) {return (i>=0 && i<n && j>=0 && j<m);}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define FOR( i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define FOR1(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define REV( i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define REV1(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define INC( i, n) FOR( i, 0, n)\n#define INC1(i, n) FOR1(i, 1, n)\n#define DEC( i, n) REV( i, 0, n)\n#define DEC1(i, n) REV1(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n;\nchar s1[101], s2[101];\nint len;\n\nvoid plus() {\n\tlen++;\n\ts1[len] = s2[len] = '\\0';\n}\n\nvoid shift() {\n\tDEC(i, len) {\n\t\ts1[i + 1] = s1[i];\n\t\ts2[i + 1] = s2[i];\n\t}\n}\n\nint ask(int i, int p) {\n\tchar as1[] = \"..##\";\n\tchar as2[] = \".#.#\";\n\tchar r[4];\n\t\n\ts1[p] = as1[i];\n\ts2[p] = as2[i];\n\t\n\tprintf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n\t\n\tscanf(\"%s\", r);\n\t\n\t     if(r[0] == 'F') { return 0; }\n\telse if(r[0] == 'T') { return 1; }\n\telse                 { return 2; }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\t\n\ts1[0] = s2[0] = '\\0';\n\t\n\twhile(len < n) {\n\t\tbool flag = false;\n\t\tint res;\n\t\tplus();\n\t\tINC(i, 8) {\n\t\t\tif(i == 4) { shift(); }\n\t\t\tres = ask(i % 4, (i < 4 ? len - 1 : 0) );\n\t\t\tif(res != 0) { break; }\n\t\t}\n\t\tif(res == 2) { break; }\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stdio.h>\n#include <string>\nusing namespace std;\nstring ans[3],tmp[3],r;\nchar atas[4]={'#','.','#','.'},bawah[4] = {'.','.','#','#'};\nint n;\nbool cek;\nint main()\n{\n    scanf(\"%d\",&n);\n    while(1)\n    {\n        for(int i=0;i<4;i++)\n        {\n            if(cek)\n            {\n                tmp[0] = ans[0]+atas[i];\n                tmp[1] = ans[1]+bawah[i];\n            }\n            else\n            {\n                tmp[0] = atas[i]+ans[0];\n                tmp[1] = bawah[i]+ans[1];\n            }\n            for(int i=0;i<2;i++) cout<<tmp[i]<<endl;\n            cin>>r;\n            cout<<\"r : \"<<r<<endl;\n            if(r==\"end\")\n            {\n                break;\n            }\n            if(r==\"T\")\n            {\n                ans[0] = tmp[0];\n                ans[1] = tmp[1];\n                break;\n            }\n            if(i==3)\n            {\n                cek = 1;\n            }\n        }\n        if(r==\"end\") break;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[2][200];\nchar in[3];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tint dir=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(dir==0){\n\t\t\tstr[0][i+1]=str[1][i+1]=0;\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tif(j&(1<<k))str[k][i]='#';\n\t\t\t\t\telse str[k][i]='.';\n\t\t\t\t}\n\t\t\t\tprintf(\"%s\\n\",str[0]);\n\t\t\t\tprintf(\"%s\\n\",str[1]);\n\t\t\t\tfflush(stdout);\n\t\t\t\tscanf(\"%s\",in);\n\t\t\t\tif(in[0]=='T'){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok)dir=1;\n\t\t}\n\n\t\tif(dir){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tstr[0][j+1]=str[0][j];\n\t\t\t\tstr[1][j+1]=str[1][j];\n\t\t\t}\n\t\t\tstr[0][i+1]=str[1][i+1]=0;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tif(j&(1<<k))str[k][0]='#';\n\t\t\t\t\telse str[k][0]='.';\n\t\t\t\t}\n\t\t\t\tprintf(\"%s\\n\",str[0]);\n\t\t\t\tprintf(\"%s\\n\",str[1]);\n\t\t\t\tfflush(stdout);\n\t\t\t\tscanf(\"%s\",in);\n\t\t\t\tif(in[0]=='T'){\n\t\t\t\t//\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%s\\n%s\\n\",str[0],str[1]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n#define INF 1e9\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef vector < pair<int, int> > vii;\ntypedef long double ld;\ntypedef tree<pair<int,int>, null_type, less<pair<int,int> >, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstring s1, s2, reply;\nint dir, cur, n;\nstring t1=\"..##\";\nstring t2=\".##.\";\n\nint main()\n{\n\tcin >> n;\n\tdir=1;\n\twhile(reply!=\"end\"){\n\t\tif(dir==1){\n\t\t\tcout << s1+t1[cur] << endl;\n\t\t\tcout << s2+t2[cur] << endl;\n\t\t\tcin >> reply;\n\t\t\tif(reply==\"F\"){\n\t\t\t\tif(cur==3){\n\t\t\t\t\tdir=-1;\n\t\t\t\t\tcur=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts1+=t1[cur];\n\t\t\t\ts2+=t2[cur];\n\t\t\t\tcur=0;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcout << t1[cur]+s1 << endl;\n\t\t\tcout << t2[cur]+s2 << endl;\n\t\t\tcin >> reply;\n\t\t\tif(reply==\"F\"){\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts1=t1[cur]+s1;\n\t\t\t\ts2=t2[cur]+s2;\n\t\t\t\tcur=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n%s\\n\", u.c_str(), d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  int sw = 0;\n  while (true) {\n    int j;\n    for (j = 0; j < 4; ++j) {\n      ++cnt;\n      string r = (sw == 0 ? ask(u + du[j], d + dd[j]) : ask(du[j] + u, dd[j] + d));\n      if (r == \"end\") {\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    if (j == 4) {\n      sw = 1 - sw;\n      continue;\n    }\n    if (sw == 0) {\n      u += du[j];\n      d += dd[j];\n    } else {\n      u = du[j] + u;\n      d = dd[j] + d;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n\tll n;\n\tcin>>n;\n\tstring input =\"\";\n\tstring s1 =\"..##\";\n\tstring s2 =\"..##\";\n\tstring ans1 = \"\" , ans2=\"\";\n\t\tbool balik = 1;\n\twhile(input != \"end\")\n\t{\n\t\tif(balik == 1)\n\t\t{\n\t\t\t\n\t\t\tfor(int i = 0; i  < 4;  i++)\n\t\t\t{\n\t\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\t\ttemp1 += s1[i];\n\t\t\t\ttemp2 += s2[i];\n\t\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin>>input;\n\t\t\t\tif(input == \"end\") return 0;\n\t\t\t\tif(input == \"T\" || input == \"end\")\n\t\t\t\t{\n\t\t\t\t\tans1 = temp1;\n\t\t\t\t\tans2 = temp2;\n\t\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif( i == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tbalik = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(balik == 0)\n\t\t{\n\t\t\tfor(int i = 0; i  < 4;  i++)\n\t\t\t{\n\t\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\t\ttemp1 = s1[i] + ans1;\n\t\t\t\ttemp2 = s2[i] + ans2;\n\t\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin>>input;\n\t\t\t\tif(input == \"end\") return 0;\n\t\t\t\tif(input == \"T\" )\n\t\t\t\t{\n\t\t\t\t\tans1 = temp1;\n\t\t\t\t\tans2 = temp2;\n\t\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif( i == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tbalik = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<string.h>\n#include<iostream>\n\nusing namespace std;\n\nchar str1[] = {'.','#','.','#'};\nchar str2[] = {'.','.','#','#'};\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\t\n\tstring s1,s2;\n\t\n\tint toright = 1;\n\t\n\twhile(1)\n\t{\n\t\t\n\t\tint f = 0;\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\t\n\t\t\tstring temp1 = s1;\n\t\t\tstring temp2 = s2;\n\t\t\t\n\t\t\tif (toright)\n\t\t\t{\n\t\t\t\ttemp1 += str1[i];\n\t\t\t\ttemp2 += str2[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp1 = str1[i] + temp1;\n\t\t\t\ttemp2 = str2[i] + temp2;\n\t\t\t}\n\t\t\t\n\t\t\tcout << temp1 << \"\\n\" << temp2 << \"\\n\";\n\t\t\tchar s[6];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tif (!strcmp(s,\"end\"))\n\t\t\t\treturn 0;\n\t\t\t\n\t\t\tif (!strcmp(s,\"T\"))\n\t\t\t{\n\t\t\t\tf = 1;\n\t\t\t\ts1 = temp1;\n\t\t\t\ts2 = temp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif (!f)\n\t\t \ttoright = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    string s1, s2;\n    cin >> n;\n    \n    char c[3] = {'.', '#'};\n    \n    string res;\n    while (res != \"end\") {\n        char tes[3];\n        bool ok = 0;\n        for (int i=0; i<2; i++) for (int j=0; j<2; j++) {\n            if (ok) break;\n            cout << s1 + c[i] << \"\\n\" << s2 + c[j] << \"\\n\"; fflush(stdout);\n            cin >> res;\n            if (res == \"end\") return 0;\n            if (res == \"T\") ok = 1, tes[0] = c[i], tes[1] = c[j];\n        }\n        \n        if (ok) s1 += tes[0], s2 += tes[1];\n        else break;\n    }\n    \n    \n    while (res != \"end\") {\n        char tes[3];\n        bool ok = 0;\n        for (int i=0; i<2; i++) for (int j=0; j<2; j++) {\n            if (ok) break;\n            cout << (string)\"\" + c[i] + s1 << \"\\n\" << (string)\"\" + c[j] + s2 << \"\\n\"; fflush(stdout);\n            cin >> res;\n            if (res == \"end\") return 0;\n            if (res == \"T\") ok = 1, tes[0] = c[i], tes[1] = c[j];\n        }\n        \n        if (ok) s1 = (string)\"\" + tes[0] + s1, s2 = (string)\"\" + tes[1] + s2;\n        else break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nint first = 100;\nint last = 100;\n\n\nstring ans = \"F\";\n\nbool isRight = true;\n\nint main(){\n\n\t/*char dumup[201];\n\tchar *up;\n\tup = dumup + 100;\n\n\tchar dumdown[201];\n\tchar *down;\n\tdown = dumdown + 100;\n\t\n\tcin >> N;\n\tmemset(dumup,'.',sizeof(dumup));\n\tmemset(dumdown,'.',sizeof(dumdown));*/\n\n\tchar up[201];\n\tchar down[201];\n\tmemset(up,'.',sizeof(up));\n\tmemset(down,'.',sizeof(down));\n\t\n\tcin >> N;\n\t\n\twhile(1){\n\t\t\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[last] = intup;\n\t\t\t\tdown[last] = intdown;\n\t\t\t\tlast++;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"F\" && i == 3){\n\t\t\t\tisRight = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!isRight) break;\n\t}\n\twhile(last - first != N){\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\t\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[first-1] = intup;\n\t\t\t\tdown[first-1] = intdown;\n\t\t\t\tfirst--;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"end\"){\n\t\t\t\tisRight = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(isRight) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nbool stop = false;\nvoid dfs(string s1, string s2) {\n    if (stop) return;\n    string res;\n    rep(i, 2) rep(j, 2) {\n        if (stop) return;\n        char c1 = i == 0 ? '.' : '#';\n        char c2 = j == 0 ? '.' : '#';\n        auto t1 = s1 + c1;\n        auto t2 = s2 + c2;\n        printf(\"%s\\n%s\\n\", t1.c_str(), t2.c_str()); fflush(stdout);\n        cin >> res;\n        if (res == \"end\") {\n            stop = true;\n            break;\n        }\n        if (res == \"T\") {\n            dfs(t1, t2);\n        }\n    }\n}\nint main() {\n    cin >> N;\n    dfs(\"\", \"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tchar in_buffer[10] = {};\n\t\n\tdeque<char> atas;\n\tdeque<char> bawah;\n\t\n\tdeque<char> printatas;\n\tdeque<char> printbawah;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas.push_front('.');\n\t\tbawah.push_front('.');\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas.pop_front();\n\t\t\tbawah.pop_front();\n\t\t\tatas.push_front(tempatas[j]);\n\t\t\tbawah.push_front(tempbawah[j]);\n\t\t\t\n\t\t\tprintatas = atas;\n\t\t\tprintbawah = bawah;\n\t\t\t\n\t\t\twhile(!printatas.empty()) {\n\t\t\t\tprintf(\"%c\", printatas.front());\n\t\t\t\tprintatas.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\twhile(!printbawah.empty()) {\n\t\t\t\tprintf(\"%c\", printbawah.front());\n\t\t\t\tprintbawah.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tfflush(stdin);\n\t\t\t\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tatas.pop_front();\n\tbawah.pop_front();\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas.push_back('.');\n\t\tbawah.push_back('.');\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas.pop_back();\n\t\t\tbawah.pop_back();\n\t\t\tatas.push_back(tempatas[j]);\n\t\t\tbawah.push_back(tempbawah[j]);\n\t\t\t\n\t\t\tprintatas = atas;\n\t\t\tprintbawah = bawah;\n\t\t\t\n\t\t\twhile(!printatas.empty()) {\n\t\t\t\tprintf(\"%c\", printatas.front());\n\t\t\t\tprintatas.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\twhile(!printbawah.empty()) {\n\t\t\t\tprintf(\"%c\", printbawah.front());\n\t\t\t\tprintbawah.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t\n\t\t\tfflush(stdin);\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n%s\\n\", u.c_str(), d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  int cnt = 0;\n  int sw = 0;\n  while (true) {\n    int j;\n    for (j = 0; j < 4; ++j) {\n      ++cnt;\n      string r = (sw == 0 ? ask(u + du[j], d + dd[j]) : ask(du[j] + u, dd[j] + d));\n      if (r == \"end\") {\n        while (1);\n\n        //assert(false);\n\n        //assert(cnt <= 420);\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    if (j == 5) {\n      assert(sw == 0);\n      sw = 1 - sw;\n      continue;\n    }\n    if (sw == 0) {\n      u += du[j];\n      d += dd[j];\n    } else {\n      u = du[j] + u;\n      d = dd[j] + d;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ temp.cpp\n// C++ includes used for precompiling -*- C++ -*-\n\n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n\n// 17.4.1.2 Headers\n\n// C\n//#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n/*\n//#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n*/\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n/*\n//#if __cplusplus >= 201103L\n#include <array>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n*/\nusing namespace std;\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF INT_MAX/3\n#define MAX_N 1000\nvoid solve(){\n  int n;\n  string board[2];\n  cin>>n;\n  rep(i,2){\n    cin>>board[i];\n  }\n  string a,b;\n  while(true){\n    cin>>a>>b;\n    if(a.size()>=n){\n      cout<<'end'<<endl;\n      break;\n    }\n    int temp=0;\n    rep(i,n-a.size()){\n      repl(j,i,i+a.size()){\n        if(board[0][j]==a[j]) temp++;\n        if(board[1][j]==b[j]) temp++;\n      }\n    }\n    if(temp==a.size()*2) cout<<\"T\"<<endl;\n    else cout<<\"F\"<<endl;\n  }\n}\nint main(){\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAX_N 105\n\nint N;\nvoid input()\n{\n  cin >> N;\n}\n\nstring InitString[4];\nbool used[4];\n\nvoid solve()\n{\n\n  string Q;\n\n  InitString[0] = \"..\";\n  InitString[1] = \".#\";\n  InitString[2] = \"#.\";\n  InitString[3] = \"##\";\n\n  memset(used, 0, sizeof(used));\n\n  string A, B;\n  bool f = true;\n  bool update = false;\n\n  while(true){\n\n    update = false;\n\n    if(A.length() == N){\n      cout << A << endl << B << endl;\n      cin >> Q;\n      return;\n    }\n\n    for (size_t i = 0; i < 4; i++) {\n      if(f){\n        string _A = A + InitString[i][0];\n        string _B = B + InitString[i][1];\n        cout << _A << endl << _B << endl;\n        cin >> Q;\n        if(Q == \"T\"){\n          A += InitString[i][0];\n          B += InitString[i][1];\n          update = true;\n          break;\n        }\n        else if(Q == \"end\"){\n          return;\n        }\n      }\n      else{\n        string _A = InitString[i][0] + A;\n        string _B = InitString[i][1] + B;\n        cout << _A << endl << _B << endl;\n        cin >> Q;\n        if(Q == \"T\"){\n          A = InitString[i][0] + A;\n          B = InitString[i][1] + B;\n          update = true;\n          break;\n        }\n        else if(Q == \"end\"){\n          return;\n        }\n      }\n    }\n\n    if(!update){\n      f = false;\n    }\n\n  }\n\n}\n\nint main()\n{\n  input();\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<string.h>\n#include<iostream>\n\nusing namespace std;\n\nchar str1[] = {'.','#','.','#'};\nchar str2[] = {'.','.','#','#'};\n\nint main()\n{\n\tint n;\n//\tscanf(\"%d\",&n);\n\tcin >> n;\n\t\n\tstring s1,s2;\n\t\n\tint toright = 1;\n\t\n\twhile(1)\n\t{\n\t\t\n\t\tint f = 0;\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\t\n\t\t\tstring temp1 = s1;\n\t\t\tstring temp2 = s2;\n\t\t\t\n\t\t\tif (toright)\n\t\t\t{\n\t\t\t\ttemp1 += str1[i];\n\t\t\t\ttemp2 += str2[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp1 = str1[i] + temp1;\n\t\t\t\ttemp2 = str2[i] + temp2;\n\t\t\t}\n\t\t\t\n\t\t\tcout << temp1 << \"\\n\" << temp2 << \"\\n\" << flush;\n//\t\t\tchar s[6];\n//\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\t\n\t\t\tif (s == \"end\")\n\t\t\t\treturn 0;\n\t\t\t\n\t\t\tif (s == \"T\")\n\t\t\t{\n\t\t\t\tf = 1;\n\t\t\t\ts1 = temp1;\n\t\t\t\ts2 = temp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif (!f)\n\t\t \ttoright = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\numap<ti3, ll> memo;\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s[2];\n\tbool end = 0;\n\trep(i, n) {\n\t\tbool ac = 0;\n\t\tbool t = 0;\n\t\tif (!end) {\n\t\t\trep(j, 4) {\n\t\t\t\tcout << s[0] << (j & 1 ? \"#\" : \".\") << endl << s[1] << (j & 2 ? \"#\" : \".\") << endl;\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tif (a == \"T\") {\n\t\t\t\t\tt = 1;\n\t\t\t\t\ts[0] += (j & 1 ? \"#\" : \".\");\n\t\t\t\t\ts[1] += (j & 2 ? \"#\" : \".\");\n\t\t\t\t}\n\t\t\t\tif (a == \"end\")ac = 1;\n\t\t\t\tif (t || ac)break;\n\t\t\t}\n\t\t\tif (t)continue;\n\t\t\tif (ac)break;\n\t\t\tend = 1;\n\t\t}\n\t\trep(j, 4) {\n\t\t\tcout << (j & 1 ? \"#\" : \".\") << s[0] << endl << (j & 2 ? \"#\" : \".\") << s[1] << endl;\n\t\t\tstring a;\n\t\t\tcin >> a;\n\t\t\tif (a == \"T\") {\n\t\t\t\tt = 1;\n\t\t\t\ts[0] = (j & 1 ? \"#\" : \".\") + s[0];\n\t\t\t\ts[1] = (j & 2 ? \"#\" : \".\") + s[1];\n\t\t\t}\n\t\t\tif (a == \"end\")ac = 1;\n\t\t\tif (t || ac)break;\n\t\t}\n\t\tif (ac)break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\nusing namespace std;\n     \nint main(){\n  int N;\n  cin >> N;\n  string table[2];\n  bool flag = false;\n  \n  while(1){\n    // query\n    string n_table[2];\n    int cnt = 0;\n\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n    \tn_table[j] = table[j];\n      }\n\n      if(flag){\n\tn_table[0] += (i%2?'#':'.');\n\tn_table[1] += ((i >> 1)%2?'#':'.');\n      }\n      else {\n\tstring s1 = \"\";\n\ts1 += (i%2?'#':'.');\n\tstring s2 = \"\";\n\ts2 += ((i >> 1)%2?'#':'.');\n\tn_table[0] = s1 + n_table[0];\n\tn_table[1] = s2 + n_table[1];\n      }\n          \n      printf(\"%s\\n%s\\n\", n_table[0].c_str(), n_table[1].c_str()); fflush(stdout);\n      // in\n      string str;\n      cin >> str;\n      if(str == \"T\"){\n    \tfor(int j = 0 ; j < 2 ; j++){\n    \t  table[j] = n_table[j];\n    \t}\n    \tbreak;\n      }\n      if(str == \"F\"){\n\tcnt++;\n      }\n      else if(str == \"end\"){\n    \treturn 0;\n      }\n    }\n    if(cnt == 4)flag = true;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    vector<string> s(2);\n    bool isRight = true;\n    for(int i=0; i<n; ++i){\n        for(int j=0; ; ++j){\n            vector<string> t(2);\n            if(isRight){\n                t[0] = s[0] + ((j & 1) ? '#' : '.');\n                t[1] = s[1] + ((j & 2) ? '#' : '.');\n            }\n            else{\n                t[0] = ((j & 1) ? '#' : '.') + s[0];\n                t[1] = ((j & 2) ? '#' : '.') + s[1];\n            }\n\n            cout << s[0] << endl << s[1] << endl;\n            string input;\n            cin >> input;\n            if(input == \"T\" || input == \"end\"){\n                s = t;\n                break;\n            }\n            if(j == 3)\n                isRight = false;\n        }\n    }\n\n    return 0\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nint first = 0;\nint last = 0;\n\n\nchar ans = 'F';\n\nbool isRight = true;\n\nint main(){\n\n\tchar dumup[201];\n\tchar *up;\n\tup = dumup + 100;\n\n\tchar dumdown[201];\n\tchar *down;\n\tdown = dumdown + 100;\n\t\n\tcin >> N;\n\tmemset(dumup,'.',sizeof(dumup));\n\tmemset(dumdown,'.',sizeof(dumdown));\n\t\n\twhile(1){\n\t\t\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\tif(ans == 'T'){\n\t\t\t\tup[last+1] = intup;\n\t\t\t\tdown[last+1] = intdown;\n\t\t\t\tlast++;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == 'F' && i == 3){\n\t\t\t\tisRight = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!isRight) break;\n\t}\n\twhile(last - first != N){\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\t\n\t\t\tif(ans == 'T'){\n\t\t\t\tup[first-1] = intup;\n\t\t\t\tdown[first-1] = intdown;\n\t\t\t\tfirst--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nchar a[3] = {'.','#'};\n\nsigned main()\n{ // #define int long long をしてるのでscanfを使うと意味不明な値が入力され死にます\n    int N; cin >> N;\n\n    string S[2];\n\n    bool r = true; // 右に伸ばしているか\n\n    while (S[0].size() != N) {\n        if (r) {\n            bool f = true;\n\n            S[0] += ' ';\n            S[1] += ' ';\n\n            int pos = S[0].size() - 1;\n\n            rep(i, 2) rep(j, 2) {\n                S[0][pos] = a[i];\n                S[1][pos] = a[j];\n\n                cout << S[0] << endl;\n                cout << S[1] << endl;\n\n                char C; cin >> C;\n\n                if (C == 'T') {\n                    f = false;\n                    goto nxt1;\n                }\n            }\n\n            if (f) {\n                r = false;\n            }\n\nnxt1:;\n        } else {\n            bool f = true;\n\n            string T[2];\n\n            T[0] += ' ';\n            T[0] += S[0];\n            T[1] += ' ';\n            T[1] += S[1];\n\n            rep(i, 2) rep(j, 2) {\n                T[0][0] = a[i];\n                T[1][0] = a[j];\n\n                cout << T[0] << endl;\n                cout << T[1] << endl;\n\n                char C; cin >> C;\n\n                if (C == 'T') {\n                    f = false;\n                    goto nxt2;\n                }\n            }\n\n            if (f) {\n                break;\n            }\n\n            S[0] = T[0];\n            S[1] = T[1];\nnxt2:;\n        }\n    }\n\n    cout << S[0] << endl;\n    cout << S[1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\n\nmap<int, char>mp;\nint check(vector<vector<int>>&sts) {\n\tfor (int i = 0; i < 2; ++i) {\n\t\tfor (int j = 0; j < sts[i].size(); ++j) {\n\t\t\tcout << mp[sts[i][j]];\n\t\t}\n\t\tcout << endl;\n\t}\n\tfflush(stdout);\n\tstring ans;\n\tcin >> ans;\n\tif (ans == \"T\")return 1;\n\telse if (ans == \"F\")return 0;\n\telse {\n\t\texit(0);\n\t\treturn -1;\n\t}\n}\nint main() {\n\tmp[0] = '.';\n\tmp[1] = '#';\n\tint N; cin >> N;\n\tvector<vector<int>>sts(2);\n\tfor (int i = 0; i < 4; ++i) {\n\t\tsts[0] = vector<int>(1, i % 2);\n\t\tsts[1] = vector<int>(1, i / 2);\n\t\tint ok = check(sts);\n\t\tif (ok == 1) {\n\t\t\tbreak;\n\t\t}\n\t\telse if (ok == 0)continue;\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbool isleft = true;\n\tint num = 0;\n\tbool flag = false;\n\twhile (1) {\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tauto it = isleft ? sts[i].begin() : sts[i].end();\n\t\t\tconst int val = i ? num % 2 : num / 2;\n\t\t\tsts[i].insert(it, val);\n\t\t}\n\t\tint ok = check(sts);\n\t\tif (ok == 1) {\n\t\t\tnum = 0;\n\t\t\tflag = false;\n\t\t}\n\t\telse if (ok == 0) {\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tauto it = isleft ? sts[i].begin() : sts[i].end()-1;\n\t\t\t\tsts[i].erase(it);\n\t\t\t}\n\t\t\tnum++;\n\t\t\tif (num == 4) {\n\t\t\t\tisleft = false;\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for (int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for (int (i) = (a) - 1; (i) >= (b); (i)--)\n#define PI acos(-1.0)\n#define DEBUG(C) cout<< C <<endl;\n#define VI vector <int>\n#define VII vector <VI>\n#define VL vector <LL>\n#define VLL vector <VL>\n#define VD vector <double>\n#define VDD vector <VD>\n#define PII pair <int, int>\n#define PDD pair <double, double>\n#define PLL pair <LL, LL>\n#define VPII vector <PII>\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define REVERSE(a) reverse(ALL(a))\n#define MP make_pair\n#define EB emplace_back\n#define FORE(a, b) for (auto &&a:b)\n#define FIND(s, n) (s.find(n) != s.end())\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int INF = 1e9;\nconst int MOD = INF + 7;\n\nstring cc[2];\n\nint main(void) {\n    cc[0] = \"..##\";\n    cc[1] = \".#.#\";\n    int N; cin >> N;\n    vector <string> S(2, \"\"), Sbuf(2);\n    int cnt = 0;\n    S[0] += cc[0][0];\n    S[1] += cc[1][0];\n    REP(_, 420) {\n        printf(\"%s\\n%s\\n\", S[0].c_str(), S[1].c_str());\n        string c; cin >> c;\n        if (c == \"T\") {\n            Sbuf = S;\n            cnt = 0;\n            REP(i, 2) {\n                S[i] += cc[i][cnt];\n            }\n        } else if (c == \"F\") {\n            S = Sbuf;\n            cnt++;\n            if (cnt >= 4) {\n                REP(i, 2) {\n                    S[i] = cc[i][cnt] + S[i];\n                }\n            } else {\n                REP(i, 2) {\n                    S[i] += cc[i][cnt];\n                }\n            }\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0, _n = (int)(n); i < _n; ++i)\nconst int N = (int) 0, mod = (int) 0;\nchar ch[] = {'.', '#'};\nbool query(string a, string b) {\n    cout << a << endl << b << endl;\n    string x; cin >> x;\n    if (x == \"end\") {\n        exit(0);\n    }\n    return x[0] == 'T';\n}\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n;\n    cin >> n;\n    string x = \"\", y = \"\";\n    while (true) {\n        int flag = 0;\n        for (int i = 0; i < 2 && !flag; ++i)\n            for (int j = 0; j < 2 && !flag; ++j) {\n                string a = x; a += ch[i];\n                string b = y; b += ch[j];\n                if (query(a, b)) {\n                    flag = 1;\n                    x = a;\n                    y = b;\n                }\n            }\n        if (!flag) break;\n    }\n    while (true) {\n        int flag = 0;\n        for (int i = 0; i < 2 && !flag; ++i)\n            for (int j = 0; j < 2 && !flag; ++j) {\n                string a = \"\"; a += ch[i]; a += x;\n                string b = \"\"; b += ch[j], b += y;\n                if (query(a, b)) {\n                    flag = 1;\n                    x = a;\n                    y = b;\n                }\n            }\n        if (!flag) break;\n    }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\n\n#define FORN(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n\n#define DEBUG(X) { cout << #X << \" = \" << (X) << endl; }\n#define PR0(A,n) { cout << #A << \" = \"; FORN(_,n) cout << A[_] << ' '; cout << endl; }\n\n#define MOD 1000000007\n#define INF 2000000000\n\nint GLL(LL& x) {\n    return scanf(\"%lld\", &x);\n}\n\nint GI(int& x) {\n    return scanf(\"%d\", &x);\n}\n\nint n;\n\nstring s1, s2, tval;\n\nchar up[4] = {'.', '.', '#', '#'};\nchar dn[4] = {'.', '#', '.', '#'};\n\nint main() {\n    GI(n);\n\n    bool fwd = true;\n\n    while (s1.size() < n) {\n        bool ok = true;\n\n        FORN(i, 4) {\n            string ns1 = (fwd ? s1 + up[i] : up[i] + s1);\n            string ns2 = (fwd ? s2 + dn[i] : dn[i] + s2);\n\n            cout << ns1 << \"\\n\" << ns2 << \"\\n\";\n            cin >> tval;\n\n            if (tval[0] == 'T') {\n                s1 = ns1;\n                s2 = ns2;\n                ok = true;\n                break;\n            }\n            else if (tval[0] == 'e') {\n                return 0;\n            }\n        }\n\n        if (!ok) {\n            fwd = false;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\numap<ti3, ll> memo;\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s[2];\n\tbool end = 0;\n\trep(i, n) {\n\t\tbool ac = 0;\n\t\tbool t = 0;\n\t\tif (!end) {\n\t\t\trep(j, 4) {\n\t\t\t\tcout << s[0] << (j & 1 ? \"#\" : \"-\") << end << s[1] << (j & 2 ? \"#\" : \"-\") << endl;\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tif (a == \"T\") {\n\t\t\t\t\tt = 1;\n\t\t\t\t\ts[0] += (j & 1 ? \"#\" : \"-\");\n\t\t\t\t\ts[1] += (j & 2 ? \"#\" : \"-\");\n\t\t\t\t}\n\t\t\t\tif (a == \"end\")ac = 1;\n\t\t\t\tif(t||ac)break;\n\t\t\t}\n\t\t\tif (t)continue;\n\t\t\tif (ac)break;\n\t\t\tend = 1;\n\t\t}\n\t\trep(j, 4) {\n\t\t\tcout <<  (j & 1 ? \"#\" : \"-\") << s[0] << end <<  (j & 2 ? \"#\" : \"-\") << s[1] << endl;\n\t\t\tstring a;\n\t\t\tcin >> a;\n\t\t\tif (a == \"T\") {\n\t\t\t\tt = 1;\n\t\t\t\ts[0] = (j & 1 ? \"#\" : \"-\")+s[0];\n\t\t\t\ts[1] = (j & 2 ? \"#\" : \"-\")+s[1];\n\t\t\t}\n\t\t\tif (a == \"end\")ac = 1;\n\t\t\tif (t || ac)break;\n\t\t}\n\t\tif (ac)break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ask(const std::deque<int>& a)\n{\n  for (int j = 0; j < 2; ++ j) {\n    for (int x : a) {\n      std::cout << \".#\"[x >> j & 1];\n    }\n    std::cout << \"\\n\";\n  }\n  std::cout << std::flush;\n  std::string verdict;\n  std::cin >> verdict;\n  if (verdict == \"end\") {\n    return -1;\n  }\n  return verdict == \"T\";\n}\n\nint main()\n{\n  int n;\n  std::cin >> n;\n  std::deque<int> guess;\n  bool found = true;\n  while (static_cast<int>(guess.size()) < n && found) {\n    found = false;\n    for (int a = 0; a < 4; ++ a) {\n      guess.push_back(a);\n      auto verdict = ask(guess);\n      if (verdict == -1) {\n        return 0;\n      }\n      if (verdict) {\n        found = true;\n        break;\n      }\n      guess.pop_back();\n    }\n  }\n  while (static_cast<int>(guess.size()) < n) {\n    for (int a = 0; a < 4; ++ a) {\n      guess.push_front(a);\n      auto verdict = ask(guess);\n      if (verdict == -1) {\n        return 0;\n      }\n      if (verdict) {\n        break;\n      }\n      guess.pop_front();\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nchar a[3] = {'.','#'};\n\nstring answer() {\n    string s; cin >> s;\n    return s;\n}\n\nsigned main()\n{ // #define int long long をしてるのでscanfを使うと意味不明な値が入力され死にます\n    int N; cin >> N;\n\n    string S[2];\n\n    bool r = true; // 右に伸ばしているか\n\n    while (true) {\n        if (r) {\n            bool f = true;\n\n            S[0] += ' ';\n            S[1] += ' ';\n\n            int pos = S[0].size() - 1;\n\n            rep(i, 2) rep(j, 2) {\n                S[0][pos] = a[i];\n                S[1][pos] = a[j];\n\n                cout << S[0] << endl;\n                cout << S[1] << endl;\n\n                string ans = answer();\n\n                if (ans == \"end\") return 0;\n\n                if (ans == \"T\") {\n                    f = false;\n                    goto nxt1;\n                }\n            }\n\n            if (f) {\n                r = false;\n            }\n\nnxt1:;\n        } else {\n            bool f = true;\n\n            string T[2];\n\n            T[0] += ' ';\n            T[0] += S[0];\n            T[1] += ' ';\n            T[1] += S[1];\n\n            rep(i, 2) rep(j, 2) {\n                T[0][0] = a[i];\n                T[1][0] = a[j];\n\n                cout << T[0] << endl;\n                cout << T[1] << endl;\n\n                string ans = answer();\n\n                if (ans == \"end\") return 0;\n\n                if (ans == \"T\") {\n                    f = false;\n                    goto nxt2;\n                }\n            }\n\n            if (f) {\n                break;\n            }\n\n            S[0] = T[0];\n            S[1] = T[1];\nnxt2:;\n        }\n    }\n\n    cout << S[0] << endl;\n    cout << S[1] << endl;\n\n    string s; cin >> s;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\nusing namespace std;\nint n;\nstring s1,s2;\nbool ff;\nstring a[2]={\".\",\"#\"};\nbool tri(string s1,string s2){\n\tputs(s1.c_str());\n\tputs(s2.c_str());\n\tfflush(stdout);\n\tchar s[9];\n\tscanf(\"%s\",s);\n\tif(*s=='e')exit(0);\n\treturn *s=='T';\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tff = true;\n\twhile(1){\n\t\tif(ff){\n\t\t\tff = false;\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t\tif(tri(s1 + a[i/2], s2 + a[i%2])){\n\t\t\t\t\ts1 += a[i/2];\n\t\t\t\t\ts2 += a[i%2];\n\t\t\t\t\tff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t\tif(tri(a[i/2] + s1, a[i%2] + s2)){\n\t\t\t\t\ts1 = a[i/2] + s1;\n\t\t\t\t\ts2 = a[i%2] + s2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define FOR( i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define FOR1(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define REV( i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define REV1(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define INC( i, n) FOR( i, 0, n)\n#define INC1(i, n) FOR1(i, 1, n)\n#define DEC( i, n) REV( i, 0, n)\n#define DEC1(i, n) REV1(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n;\nchar s1[101], s2[101];\nint len;\n\nvoid plus() {\n\tlen++;\n\ts1[len] = s2[len] = '\\0';\n}\n\nvoid shift() {\n\tDEC(i, len) {\n\t\ts1[i + 1] = s1[i];\n\t\ts2[i + 1] = s2[i];\n\t}\n}\n\nint ask(int i, int p) {\n\tchar as1[] = \"..##\";\n\tchar as2[] = \".#.#\";\n\tchar r[4];\n\t\n\ts1[p] = as1[i];\n\ts2[p] = as2[i];\n\t\n\tprintf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n\t\n\tscanf(\"%s\", r);\n\t\n\t     if(r[0] == 'F') { return 0; }\n\telse if(r[0] == 'T') { return 1; }\n\telse                 { return 2; }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\t\n\ts1[0] = s2[0] = '\\0';\n\t\n\tbool flag = true;\n\twhile(len < n) {\n\t\tint res;\n\t\tplus();\n\t\tif(flag) {\n\t\t\tINC(i, 4) {\n\t\t\t\tres = ask(i, len - 1);\n\t\t\t\tif(res != 0) { break; }\n\t\t\t}\n\t\t\tif(res == 0) { flag = false; }\n\t\t} else {\n\t\t\tshift();\n\t\t\tINC(i, 4) {\n\t\t\t\tres = ask(i, 0);\n\t\t\t\tif(res != 0) { break; }\n\t\t\t}\n\t\t}\n\t\tif(res == 2) { break; }\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n\nstring query(pair<string,string> p1,pair<string,string> p2){\n  string s1,s2;\n  s1 = p1.first + p2.first;\n  s2 = p1.second + p2.second;\n  printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n  string str;\n  cin >> str;\n  return str;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  set<pair<string,string> >st;\n  for(int i = 0 ; i < 2 ; i++){\n    string str1;\n    string str2;\n    for(int j = 0 ; j < 4 ; j++){\n      str1 += (j%2?\".\":\"#\");\n      str2 += ((j >> 1)%2?\".\":\"#\");\n    }\n    st.insert(make_pair(str1,str2));\n  }\n\n  pair<string,string>rp;\n  \n  while(1){\n    vector<pair<string,string> >vec(st.begin(),st.end());\n    for(int i = 0 ; i < vec.size() ; i++){\n      for(int k = 0 ; k < 2 ; k++){\n\tstring r;\n\tpair<string,string>p;\n\tif(k % 2){\n\t  r = query(rp,vec[i]);\n\t  p = make_pair(rp.first + vec[i].first,rp.second + vec[i].second);\n\t}\n\telse {\n\t  r = query(vec[i],rp);\n\t  p = make_pair(vec[i].first + rp.first,vec[i].second + rp.second);\n\t}\n\t// in\n\tif(r == \"T\"){\n\t  if(rp.first.size() > p.first.size())rp = p;\n\t  st.insert(p);\n\t}\n\telse if(r == \"end\"){\n\t  return 0;\n\t}\n      }\n    }\n  }\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\numap<ti3, ll> memo;\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s[2];\n\tbool end = 0;\n\trep(i, n) {\n\t\tbool ac = 0;\n\t\tbool t = 0;\n\t\tif (!end) {\n\t\t\trep(j, 4) {\n\t\t\t\tcout << s[0] << (j & 1 ? \"#\" : \"-\") << endl << s[1] << (j & 2 ? \"#\" : \"-\") << endl;\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tif (a == \"T\") {\n\t\t\t\t\tt = 1;\n\t\t\t\t\ts[0] += (j & 1 ? \"#\" : \"-\");\n\t\t\t\t\ts[1] += (j & 2 ? \"#\" : \"-\");\n\t\t\t\t}\n\t\t\t\tif (a == \"end\")ac = 1;\n\t\t\t\tif(t||ac)break;\n\t\t\t}\n\t\t\tif (t)continue;\n\t\t\tif (ac)break;\n\t\t\tend = 1;\n\t\t}\n\t\trep(j, 4) {\n\t\t\tcout <<  (j & 1 ? \"#\" : \"-\") << s[0] << endl <<  (j & 2 ? \"#\" : \"-\") << s[1] << endl;\n\t\t\tstring a;\n\t\t\tcin >> a;\n\t\t\tif (a == \"T\") {\n\t\t\t\tt = 1;\n\t\t\t\ts[0] = (j & 1 ? \"#\" : \"-\")+s[0];\n\t\t\t\ts[1] = (j & 2 ? \"#\" : \"-\")+s[1];\n\t\t\t}\n\t\t\tif (a == \"end\")ac = 1;\n\t\t\tif (t || ac)break;\n\t\t}\n\t\tif (ac)break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <iostream>\n#include <set>\n\nusing namespace std;\n\nchar c1[] = {'.', '.', '#', '#'};\nchar c2[] = {'.', '#', '.', '#'};\n\nint main(){\n  string s1;\n  string s2;\n\n  const int n = getInt();\n\n  bool rev = false;\n\n  while ((int)s1.size() < n){\n    REP(j,4){\n      string ss1;\n      string ss2;\n\n      if(!rev){\n        ss1 = s1 + c1[j];\n        ss2 = s2 + c2[j];\n      }else{\n        ss1 = c1[j] + s1;\n        ss2 = c2[j] + s2;\n      }\n\n      printf(\"%s\\n%s\\n\", ss1.c_str(), ss2.c_str());\n      fflush (stdout);\n\n      char buff[16];\n      scanf(\"%s\", buff);\n      if(buff[0] == 'T'){\n        s1 = ss1;\n        s2 = ss2;\n        goto ok;\n      }\n    }\n\n    if(rev) break;\n    rev = true;\n  ok:;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n\tll n;\n\tcin>>n;\n\tstring input =\"\";\n\tstring s1 =\"..##\";\n\tstring s2 =\"#..#\";\n\tstring ans1 = \"\" , ans2=\"\";\n\twhile(input != \"end\")\n\t{\n\t\tbool balik = 1;\n\t\tfor(int i = 0; i  < 4;  i++)\n\t\t{\n\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\ttemp1 += s1[i];\n\t\t\ttemp2 += s2[i];\n\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\tcin>>input;\n\t\t\tif(input == \"end\") return 0;\n\t\t\tif(input == \"T\" || input == \"end\")\n\t\t\t{\n\t\t\t\tans1 = temp1;\n\t\t\t\tans2 = temp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( i == 3)\n\t\t\t\t{\n\t\t\t\t\tbalik = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(balik == 0)\n\t\t{\n\t\t\tfor(int i = 0; i  < 4;  i++)\n\t\t\t{\n\t\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\t\ttemp1 = s1[i] + ans1;\n\t\t\t\ttemp2 = s2[i] + ans2;\n\t\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\t\tcin>>input;\n\t\t\t\tif(input == \"end\") return 0;\n\t\t\t\tif(input == \"T\" )\n\t\t\t\t{\n\t\t\t\t\tans1 = temp1;\n\t\t\t\t\tans2 = temp2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif( i == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tbalik = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst char s1[4] = { '.', '#', '.', '#'};\nconst char s2[4] = { '.', '.', '#', '#'};\n\nbool used[4];\nbool found;\nset<string> exclusion;\n\nvoid dfs(int depth, string t1, string t2){\n\tif (depth >= 110) return;\n\tif (found) return;\n\n\trep (i, 4){\n\t\tif (!used[i]) continue;\n\t\tstring u1 = t1 + s1[i];\n\t\tstring u2 = t2 + s2[i];\n\t\tif (exclusion.count(u1+u2)) continue;\n\t\tcout << u1 << endl;\n\t\tcout << u2 << endl;\n\t\tfflush(stdout);\n\t\tstring ans; cin >> ans;\n\t\tif (ans[0] == 'F'){\n\t\t\tif (depth == 0) used[i] = false;\n\t\t\texclusion.insert(u1+u2);\n\t\t\tcontinue;\n\t\t} // end if\n\n\t\tif (ans == \"end\"){\n\t\t\tfound |= true;\n\t\t\treturn;\n\t\t} // end if\n\t\t// if (ans[0] == 'T')\n\t\tdfs(depth + 1, u1, u2);\n\t} // end rep \n}\n \nint main()\n{\n\tmemset(used, false, sizeof(used));\n\trep (i, 4) used[i] = true;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N; cin >> N;\n\texclusion.clear();\n\tfound = false;\n\tdfs(0, \"\", \"\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n%s\\n\", u.c_str(), d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  int sw = 0;\n  while (true) {\n    int j = 0;\n    for (j = 0; j < 4; ++j) {\n      string r = (sw == 0 ? ask(u + du[j], d + dd[j]) : ask(du[j] + u, dd[j] + d));\n      if (r == \"end\") {\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    if (j == 5) {\n      assert(sw == 0);\n      sw = 1 - sw;\n      continue;\n    }\n    if (sw == 0) {\n      u += du[j];\n      d += dd[j];\n    } else {\n      u = du[j] + u;\n      d = dd[j] + d;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\nstring d[2]={{\".#.#\"},{\"..##\"}};\n\nint main(){\n\tint n;\n\tcin>>n;\n\t\n\t\n\tstring ans[2]={\"\",\"\"};\n\tbool left = false;\n\twhile(1){\n\t\tbool f=false;\n\t\trep(i,4){\n\t\t\tif(left==false)\tcout<< ans[0]+d[0][i] <<'\\n'<< ans[1]+d[1][i] <<endl;\n\t\t\telse\t\t\tcout<< d[0][i]+ans[0] <<'\\n'<< d[1][i]+ans[1] <<endl;\n\t\t\tstring res;\n\t\t\tcin>>res;\n\t\t\tif(res==\"end\")return 0;\n\t\t\tif(res==\"T\"){\n\t\t\t\tif(left==false){\n\t\t\t\t\tans[0] += d[0][i];\n\t\t\t\t\tans[1] += d[1][i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tans[0] = d[0][i]+ans[0];\n\t\t\t\t\tans[1] = d[1][i]+ans[1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f==false)left=true;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nchar a[4][3] = {\"..\", \"#.\", \".#\", \"##\"};\n\nvoid pushLine(int cnt, list< pair<char, char> > &v, bool c){\n    if(c){\n        v.push_front(make_pair(a[cnt][0], a[cnt][1]));\n    }else{\n        v.push_back(make_pair(a[cnt][0], a[cnt][1]));\n    }\n}\n\nint main(){\n    int n;\n    list< pair<char, char> > v;\n    cin >> n;\n\n    bool c = true; //true == front, false == back\n    int cnt = 0;\n    while(true){\n        if(c){\n            cout << a[cnt][0];\n            for(auto p : v) cout << p.first;\n            cout << endl;\n            cout << a[cnt][1];\n            for(auto p : v) cout << p.second;\n            cout << endl;\n        }else{\n            for(auto p : v) cout << p.first;\n            cout << a[cnt][0];\n            cout << endl;\n            for(auto p : v) cout << p.second;\n            cout << a[cnt][1];\n            cout << endl;\n        }\n        fflush(stdout);\n\n        string str;\n        cin >> str;\n        if(str[0] == 'T'){\n            pushLine(cnt, v, c);\n            cnt = 0;\n        }else if(str[0] == 'F'){\n            cnt++;\n        }else{\n            break;\n        }\n        if(cnt == 4){\n            cnt = 0;\n            c = false;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nbool stop = false;\nvoid dfs(string s1, string s2) {\n    if(s1.size() == N + 1) return;\n    if (stop) return;\n    string res;\n    rep(i, 2) rep(j, 2) {\n        if (stop) return;\n        char c1 = i == 0 ? '.' : '#';\n        char c2 = j == 0 ? '.' : '#';\n        auto t1 = s1 + c1;\n        auto t2 = s2 + c2;\n        printf(\"%s\\n%s\\n\", t1.c_str(), t2.c_str()); fflush(stdout);\n        cin >> res;\n        if (res == \"end\") {\n            stop = true;\n            break;\n        }\n        if (res == \"T\") {\n            dfs(t1, t2);\n        }\n    }\n}\nint main() {\n    cin >> N;\n    dfs(\"\", \"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nbool stop = false;\nvoid dfs(string s1, string s2) {\n    if(s1.size() == N + 1) return;\n    if (stop) return;\n    string res;\n    rep(i, 2) rep(j, 2) {\n        if (stop) return;\n        char c1 = i == 0 ? '.' : '#';\n        char c2 = j == 0 ? '.' : '#';\n        auto t1 = s1 + c1;\n        auto t2 = s2 + c2;\n        printf(\"%s\\n%s\\n\", t1.c_str(), t2.c_str()); fflush(stdout);\n        cin >> res;\n        if (res == \"end\") {\n            stop = true;\n            break;\n        }\n        if (stop) return;\n        if (res == \"T\") {\n            dfs(t1, t2);\n            if (stop) return;\n        }\n        if (stop) return;\n    }\n}\nint main() {\n    cin >> N;\n    dfs(\"\", \"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tstring atas = \"\";\n\tstring bawah = \"\";\n\t\n\tchar in_buffer[10] = {};\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas = '.' + atas;\n\t\tbawah = '.' + bawah;\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[0] = tempatas[j];\n\t\t\tbawah[0] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint len = atas.length();\n\tfor(len++; len <= n; len++) {\n\t\tatas = atas + '.';\n\t\tbawah = bawah + '.';\n\t\t\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[len-1] = tempatas[j];\n\t\t\tbawah[len-1] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nint first = 100;\nint last = 100;\n\n\nstring ans = \"F\";\n\nbool isRight = true;\n\nint main(){\n\n\t/*char dumup[201];\n\tchar *up;\n\tup = dumup + 100;\n\n\tchar dumdown[201];\n\tchar *down;\n\tdown = dumdown + 100;\n\t\n\tcin >> N;\n\tmemset(dumup,'.',sizeof(dumup));\n\tmemset(dumdown,'.',sizeof(dumdown));*/\n\n\tchar up[201];\n\tchar down[201];\n\tmemset(up,'.',sizeof(up));\n\tmemset(down,'.',sizeof(down));\n\t\n\tcin >> N;\n\t\n\twhile(1){\n\t\t\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[last] = intup;\n\t\t\t\tdown[last] = intdown;\n\t\t\t\tlast++;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"F\" && i == 3){\n\t\t\t\tisRight = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!isRight) break;\n\t}\n\twhile(last - first != N){\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tcout << intup;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << intdown;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\t\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[first-1] = intup;\n\t\t\t\tdown[first-1] = intdown;\n\t\t\t\tfirst--;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"end\"){\n\t\t\t\tisRight = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(isRight) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define range(i,x,y) i=(x);i<(y);i++\n#define rep(i,n) for(int i=0,i##_len=n;i<i##_len;i++)\n#define all(x) begin(x),end(x)\n#define lim(x,r,l) (r<=x&&x<l)\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\nsigned main(){\n  int n; cin >> n;\n  string res1, res2;\n  const string d1 = \".#.#\";\n  const string d2 = \"..##\";\n\n  for(int i = 0; ; i++){\n    res1 = res1 + \"X\";\n    res2 = res2 + \"X\";\n    int j = 0;\n    for(;j < 4; j++){\n      res1[res1.size()-1] = d1[j];\n      res2[res2.size()-1] = d2[j];\n      cout << res1 << endl << res2 << endl;\n      string ans; cin >> ans;\n      if(ans == \"T\"){ break; }\n      if(ans == \"end\"){ return 0; }\n    }\n    if(j >= 4){ break; }\n  }\n  res1 = res1.substr(0,res1.size()-1);\n  res2 = res2.substr(0,res2.size()-1);\n  for(int i = 0; ; i++){\n    res1 = \"X\" + res1;\n    res2 = \"X\" + res2;\n    int j = 0;\n    for(;j < 4; j++){\n      res1[0] = d1[j];\n      res2[0] = d2[j];\n      cout << res1 << endl << res2 << endl;\n      string ans; cin >> ans;\n      if(ans == \"T\"){ break; }\n      if(ans == \"end\"){ return 0; }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main()\n{\n  int n;\n  string s1;\n  string s2;\n  string ans;\n  char add[4][2]={{'.','.'},{'#','.'},{'.','#'},{'#','#'}};\n  int i;\n  int l=4;\n  cin>>n;\n\n  printf(\"#\\n#\\n\");\n  fflush(stdout);\n  cin>>ans;\n  if(ans==\"end\")return 0;\n  if(ans==\"T\"){\n    s1=\"#\";\n    s2=\"#\";\n  }else{\n    l--;\n    printf(\".\\n#\\n\");\n    fflush(stdout);\n    cin>>ans;\n    if(ans==\"end\")return 0;\n    if(ans==\"T\"){\n      s1=\".\";\n      s2=\"#\";\n    }else{\n      l--;\n      printf(\"#\\n.\\n\");\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n      if(ans==\"T\"){\n\ts1=\"#\";\n\ts2=\".\";\n      }else{\n\tl--;\n\ts1=\".\";\n\ts2=\".\";\n      }\n    }\n  }\n\n  while(1){\n    rep(i,l){\n      cout<<s1<<add[i][0]<<endl;\n      cout<<s2<<add[i][1]<<endl;\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n      if(ans==\"T\"){\n\ts1=s1+add[i][0];\n\ts2=s2+add[i][1];\n\tbreak;\n      }\n    }\n  }\n  while(1){\n    rep(i,l){\n      cout<<add[i][0]<<s1<<endl;\n      cout<<add[i][1]<<s2<<endl;\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n\tif(ans==\"T\"){\n\t  s1=add[i][0]+s1;\n\t  s2=add[i][1]+s2;\n\t  break;\n\t}\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n\tll n;\n\tcin>>n;\n\tstring input =\"\";\n\tstring s1 =\"..##\";\n\tstring s2 =\".#.#\";\n\tstring ans1 = \"\" , ans2=\"\";\n\t\tbool balik = 1;\n\twhile(input != \"end\")\n\t{\n\t\tif(balik == 1)\n\t\t{\n\t\t\t\n\t\t\tfor(int i = 0; i  < 4;  i++)\n\t\t\t{\n\t\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\t\ttemp1 += s1[i];\n\t\t\t\ttemp2 += s2[i];\n\t\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin>>input;\n\t\t\t\tif(input == \"end\") return 0;\n\t\t\t\tif(input == \"T\" || input == \"end\")\n\t\t\t\t{\n\t\t\t\t\tans1 = temp1;\n\t\t\t\t\tans2 = temp2;\n\t\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif( i == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tbalik = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(balik == 0)\n\t\t{\n\t\t\tfor(int i = 0; i  < 4;  i++)\n\t\t\t{\n\t\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\t\ttemp1 = s1[i] + ans1;\n\t\t\t\ttemp2 = s2[i] + ans2;\n\t\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin>>input;\n\t\t\t\tif(input == \"end\") return 0;\n\t\t\t\tif(input == \"T\" )\n\t\t\t\t{\n\t\t\t\t\tans1 = temp1;\n\t\t\t\t\tans2 = temp2;\n\t\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif( i == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tbalik = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//1列(4通り)を質問 -> 当たったら1列（右側に）追加して(4通り)質問 -> …を繰り返すと400回以内で当たらなくなる（かendが返る）\n//このとき、質問した列は黒板の右端にある。あとは、同様にして左側を特定すればよい。\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring reverse(string str) {\n\tstring ret;\n\tfor (int i = (int)str.length() - 1; i >= 0; i--) ret += str[i];\n\treturn ret;\n}\n\nint n;\nstring query[2];\n\nvoid addCharRight(int type) {\n\tchar c0 = ((type / 2) % 2 ? '#' : '.');\n\tchar c1 = (type % 2 ? '#' : '.');\n\tquery[0] += c0;\n\tquery[1] += c1;\n}\n\nvoid addCharLeft(int type) {\n\tchar c0 = ((type / 2) % 2 ? '#' : '.');\n\tchar c1 = (type % 2 ? '#' : '.');\n\treverse(query[0]);\n\treverse(query[1]);\n\tquery[0] += c0;\n\tquery[1] += c1;\n\treverse(query[0]);\n\treverse(query[1]);\n}\n\nvoid delCharRight() {\n\tstring s[2];\n\tfor (int i = 0; i < (int)query[0].size() - 1; i++) s[0] += query[0][i];\n\tfor (int i = 0; i < (int)query[1].size() - 1; i++) s[1] += query[1][i];\n\tquery[0] = s[0];\n\tquery[1] = s[1];\n}\n\nvoid delCharLeft() {\n\tstring s[2];\n\tfor (int i = 1; i < (int)query[0].size(); i++) s[0] += query[0][i];\n\tfor (int i = 1; i < (int)query[1].size(); i++) s[1] += query[1][i];\n\tquery[0] = s[0];\n\tquery[1] = s[1];\n}\n\n//return : {T, F, end}\nchar getQuery() {\n\tcout << query[0] << endl;\n\tcout << query[1] << endl;\n\tcout.flush();\n\tstring ret;\n\tcin >> ret;\n\treturn ret[0];\n}\n\n//return : {T, F, e}\nchar addQueryRight(int type) {\n\taddCharRight(type);\n\tchar res = getQuery();\n\tif (res == 'e' || res == 'T') return res;\n\tdelCharRight(type);\n\treturn res;\n}\n\nchar addQueryLeft(int type) {\n\taddCharLeft(type);\n\tchar res = getQuery();\n\tif (res == 'e' || res == 'T') return res;\n\tdelCharLeft(type);\n\treturn res;\n}\n\nsigned main() {\n\tcin >> n;\n\t\n\tint j;\n\t\n\twhile (true) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tchar res = addQueryRight(j);\n\t\t\tif (res == 'e') return 0;\n\t\t\tif (res == 'T') break;\n\t\t}\n\t\tif (j == 4) break;\n\t}\n\t\n\twhile (true) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tchar res = addQueryLeft(j);\n\t\t\tif (res == 'e') return 0;\n\t\t\tif (res == 'T') break;\n\t\t}\n\t\tif (j == 4) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nchar s1[202],s2[202];\nint st=100,ed=100,now=100,nown;\nint n;\nbool l;\nchar s[20];\nbool jud()\n{\n\tfor(int i=st;i<=ed;i++)\n\t\tprintf(\"%c\",s1[i]);\n\tprintf(\"\\n\");\n\tfor(int i=st;i<=ed;i++)\n\t\tprintf(\"%c\",s2[i]);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n\tscanf(\"%s\",s);\n\tif(s[0]=='F')\n\t\treturn false;\n\treturn true;\n}\nbool work()\n{\n\tif(ed-st+1>n)\n\t\treturn false;\n\tif(nown==4)\n\t{\n\t\tl=false;\n\t\tst++;\n\t\ted++;\n\t\tnown=0;\n\t}\n\tif(l)\n\t\tnow=st;\n\telse\n\t\tnow=ed;\n\tif(nown&2)\n\t\ts1[now]='#';\n\telse\n\t\ts1[now]='.';\n\tif(nown&1)\n\t\ts2[now]='#';\n\telse\n\t\ts2[now]='.';\n\tif(jud())\n\t{\n\t\tnown=0;\n\t\tif(l)\n\t\t\tst--;\n\t\telse\n\t\t\ted++;\n\t}\n\telse\n\t\tnown++;\n\treturn true;\n}\nint main()\n{\n\tl=true;\n\tscanf(\"%d\",&n);\n\tnown=0;\n\twhile(work());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\tstring p,q;\n\tstring yes = \"#\";\n\tstring no = \".\"; \n\tbool flag = false;\n\tbool last = false;\n\twhile(true) {\n\t\tfor(int i=0; i<4; i++) {\n\t\t\tstring s = p;\n\t\t\tstring t = q;\n\t\t\tif(!last) {\n\t\t\t\tif(i%2==1) s += yes;\n\t\t\t\telse s += no;\n\t\t\t\tif(i<=1) t += yes;\n\t\t\t\telse t += no;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(i%2==1) s = yes + s;\n\t\t\t\telse s = no + s;\n\t\t\t\tif(i<=1) t = yes + t;\n\t\t\t\telse t = no + t;\n\t\t\t}\n\t\t\tcout << s << endl << t << endl;\n\t\t\tfflush(stdout);\n\t\t\tstring data;\n\t\t\tcin >> data;\n\t\t\tif(data == \"end\") {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(data == \"T\") {\n\t\t\t\tp = s;\n\t\t\t\tq = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(data==\"F\" && i==3) {\n\t\t\t\tlast = true;\n\t\t\t}\n\t\t}\n\t\tif(flag) break;\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//ここからテンプレート\n//#define PLASMA_NO_BOOST\n#if 1\n\n#include<iostream>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<type_traits>\n#include<tuple>\n#include<memory>\n#include<iterator>\n#include<string>\n#include<functional>\n#include<list>\n#include<array>\n#include<complex>\n#include<numeric>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<random>\n#include<map>\n#include<chrono>\n#include<stack>\n#include<set>\n\n#ifndef PLASMA_NO_BOOST\n#include<boost/optional.hpp>\n#include<boost/optional/optional_io.hpp>\n#include<boost/variant.hpp>\n#include<boost/range/adaptor/transformed.hpp>\n#include<boost/range/adaptor/indexed.hpp>\n#include<boost/range/adaptor/filtered.hpp>\n#include<boost/range/algorithm.hpp>\n#include<boost/range/irange.hpp>\n#include<boost/multi_array.hpp>\n#include<boost/preprocessor.hpp>\n#endif\n\ntypedef long long int int64;\ntypedef unsigned long long uint64;\ntypedef long double double64;\n\n#ifdef PLASMA_NO_BOOST\nstruct none_t {};\nconstexpr none_t none{};\ntemplate<class T>class optional\n{\n\tunion inside_t\n\t{\n\t\tT value;\n\t\tnone_t ignore;\n\t\tconstexpr inside_t(T const& v) :value(v) {}\n\t\tconstexpr inside_t(T&& v) : value(std::move(v)) {}\n\t\tconstexpr inside_t(none_t) : ignore(none) {}\n\t\tconstexpr inside_t() : ignore(none) {}\n\t\tconstexpr inside_t(inside_t const&) = default;\n\t\tinside_t(inside_t&&) = default;\n\t\tinside_t& operator=(inside_t const&) = default;\n\t\tinside_t& operator=(inside_t&&) = default;\n\t\t~inside_t() = default;\n\t};\n\tinside_t inside;\n\tbool flag;\npublic:\n\tvoid swap(optional&& v)\n\t{\n\t\tstd::swap(this->inside, v.inside);\n\t\tstd::swap(this->flag, v.flag);\n\t}\n\tvoid reset()\n\t{\n\t\tif (flag)\n\t\t{\n\t\t\tinside.value.~T();\n\t\t\tinside.ignore = none;\n\t\t\tflag = false;\n\t\t}\n\t}\n\n\tconstexpr optional(T const& v) :inside(v), flag(true) {}\n\tconstexpr optional(T&& v) : inside(std::move(v)), flag(true) {}\n\tconstexpr optional(none_t) : inside(), flag(false) {}\n\tconstexpr optional() : inside(), flag(false) {}\n\tconstexpr optional(optional const& v) : inside(v.inside), flag(v.flag) {}\n\toptional(optional&& v) : optional()\n\t{\n\t\tswap(std::move(v));\n\t}\n\toptional& operator=(optional const& v)\n\t{\n\t\tthis->inside = v.inside;\n\t\tthis->flag = v.flag;\n\t\treturn *this;\n\t}\n\toptional& operator=(optional&& v)\n\t{\n\t\tswap(std::move(v));\n\t\tv.reset();\n\t\treturn *this;\n\t}\n\toptional& operator=(T const& v)\n\t{\n\t\treset();\n\t\tinside.value = v;\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(T&& v)\n\t{\n\t\treset();\n\t\tinside.value = std::move(v);\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(none_t)\n\t{\n\t\treset();\n\t\treturn *this;\n\t}\n\n\tconstexpr operator bool()const\n\t{\n\t\treturn flag;\n\t}\n\tconstexpr T const& operator*()const\n\t{\n\t\treturn flag ? inside.value : throw std::domain_error(\"optional error: dont have value\");\n\t}\n};\ntemplate<class T>constexpr optional<typename std::remove_reference<typename std::remove_const<T>::type>::type>make_optional(T&& v)\n{\n\treturn optional<std::remove_reference_t<std::remove_const_t<T>>>(std::forward<T>(v));\n}\n#else\nusing boost::optional;\nusing boost::none_t;\nusing boost::none;\n#endif\n\n#ifndef PLASMA_NO_BOOST\nnamespace adaptor\n{\n\tusing namespace boost::adaptors;\n}\nnamespace algorithm\n{\n\tusing namespace boost::range;\n\ttemplate<class SinglePassRange, class Pred>bool any_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::any_of(std::begin(range), std::end(range), pred);\n\t}\n\ttemplate<class SinglePassRange, class Pred>bool all_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::all_of(std::begin(range), std::end(range), pred);\n\t}\n}\n#endif\nnamespace math\n{\n\ttemplate<class T>constexpr T pow(T p, int n)\n\t{\n\t\treturn n == 0 ? T(1) : n == 1 ? p : n == 2 ? p*p : n % 2 == 0 ? pow(pow(p, n / 2), 2) : pow(pow(p, n / 2), 2)*p;\n\t}\n\n\tint log(long long int p, int n)\n\t{\n\t\tint64 t = n;\n\t\tfor (int i = 0;;++i)\n\t\t{\n\t\t\tif (t > p)\n\t\t\t\treturn i;\n\t\t\tt *= n;\n\t\t}\n\t}\n\n\tconstexpr double pi = 3.141592653589793;\n\n\tnamespace detail\n\t{\n\t\tint gcd(int larger, int less)\n\t\t{\n\t\t\treturn less == 0 ? larger : gcd(less, larger%less);\n\t\t}\n\t}\n\n\tint gcd(int lhs, int rhs)\n\t{\n\t\treturn lhs < rhs ? detail::gcd(rhs, lhs) : detail::gcd(lhs, rhs);\n\t}\n\n\tvoid fourier_transform(\n\t\tstd::vector<std::complex<double>>& vec, std::size_t N)\n\t{\n\t\tstd::vector<std::complex<double>> butterfly;\n\t\tvec.resize(N);\n\t\tbutterfly.resize(N);\n\n\t\tstd::complex<double> half(std::cos(pi), std::sin(pi));\n\t\tfor (uint64 i = 1, k = N / 2;i < N;[&]() {i *= 2;k /= 2;}())//i*k == N/4\n\t\t{\n\t\t\tstd::complex<double> circle(std::cos(pi / i), std::sin(pi / i));\n\t\t\tstd::complex<double> c(1.0, 0);\n\t\t\tfor (auto count = 0ull; count < i;++count)\n\t\t\t{\n\t\t\t\tfor (auto j = 0ull;j < k;++j)\n\t\t\t\t{\n\t\t\t\t\tbutterfly[count*k + j] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c;\n\t\t\t\t\tbutterfly[count*k + j + N / 2] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c*half;\n\t\t\t\t}\n\t\t\t\tc *= circle;\n\t\t\t}\n\t\t\tstd::swap(vec, butterfly);\n\t\t}\n\t}\n\n\tclass polynomial\n\t{\n\t\tstd::vector<std::complex<double>> value;\n\t\tvoid swap(polynomial&& p)\n\t\t{\n\t\t\tstd::swap(value, p.value);\n\t\t}\n\tpublic:\n\t\tpolynomial() :value{ 0.0 } {}\n\t\tpolynomial(polynomial const&) = default;\n\t\tpolynomial(std::vector<std::complex<double>>&& vec) :value(std::move(vec)) {}\n\t\tpolynomial(polynomial&& p) :polynomial()\n\t\t{\n\t\t\tswap(std::move(p));\n\t\t}\n\t\tpolynomial(std::initializer_list<std::complex<double>> lis) :value(lis) {}\n\t\tpolynomial(std::complex<double> c) :polynomial({ c }) {}\n\n\t\tpolynomial& operator=(polynomial const&) = default;\n\t\tpolynomial& operator=(polynomial&& p)\n\t\t{\n\t\t\tvalue = std::vector<std::complex<double>>{ 0.0 };\n\t\t\tswap(std::move(p));\n\t\t\treturn *this;\n\t\t}\n\n\t\t~polynomial() = default;\n\t\tstd::complex<double> operator[](std::size_t deg)const\n\t\t{\n\t\t\treturn deg >= value.size() ? 0.0 : value[deg];\n\t\t}\n\t\tstd::size_t degree()const\n\t\t{\n\t\t\treturn value.size() - 1;\n\t\t}\n\t\tvoid strict_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tif (value[N] != 0.0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\t\tvoid integer_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tstd::cout << value[N] << \" \" << (std::norm(value[N]) > (1.0e-20)) << std::endl;\n\t\t\t\tif (std::norm(value[N]) > (1.0e-20))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\n\t\tfriend polynomial operator*(polynomial const& lhs, polynomial const& rhs)\n\t\t{\n\t\t\tstd::size_t N = 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tN *= 2;\n\t\t\t\tif (N > (lhs.degree() + rhs.degree()))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto lhs_ = lhs.value;\n\t\t\tauto rhs_ = rhs.value;\n\t\t\tfourier_transform(lhs_, N);\n\t\t\tfourier_transform(rhs_, N);\n\t\t\tstd::vector<std::complex<double>> vec;\n\t\t\tvec.reserve(N);\n\t\t\tfor (std::size_t i = 0;i < N;++i)\n\t\t\t{\n\t\t\t\tvec.push_back(lhs_[i] * rhs_[i]);\n\t\t\t}\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = 2 * v.real() - v;\n\t\t\t}\n\t\t\tfourier_transform(vec, N);\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = (2 * v.real() - v)*(1.0 / N);\n\t\t\t}\n\t\t\tstd::size_t k = N;\n\t\t\tfor (;k > 0;--k)\n\t\t\t{\n\t\t\t\tif (std::norm(vec[k]) > 1.0e-23)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec.resize(k + 1);\n\t\t\treturn polynomial(std::move(vec));\n\t\t}\n\t};\n\n\tint real_integer(std::complex<double> c)\n\t{\n\t\tint v = static_cast<int>(c.real());\n\t\tdouble u = c.real() - v;\n\t\treturn v + static_cast<int>(2 * u);\n\t}\n\n\ttemplate<class T>polynomial make_poly(std::vector<T> const& vec)\n\t{\n\t\tauto range = vec | adaptor::transformed([](T const& v) {return static_cast<std::complex<double>>(v);});\n\t\tstd::vector<std::complex<double>> ret(std::begin(range), std::end(range));\n\t\treturn polynomial(std::move(ret));\n\t}\n\tpolynomial make_poly(std::initializer_list<double>init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\tpolynomial make_poly(std::initializer_list<int> init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\ttemplate<class T>class infinite_value\n\t{\n\t\toptional<T> val;\n\tpublic:\n\t\tinfinite_value(T const& v) :val(v) {}\n\t\tinfinite_value(T&& v) :val(std::move(v)) {}\n\t\tinfinite_value(none_t = none) :val() {}\n\t\tinfinite_value(infinite_value const&) = default;\n\t\tinfinite_value(infinite_value&&) = default;\n\t\t~infinite_value() = default;\n\n\t\tinfinite_value& operator=(T const& v)\n\t\t{\n\t\t\tval = v;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(T&& v)\n\t\t{\n\t\t\tval = std::move(v);\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(none_t)\n\t\t{\n\t\t\tval = boost::none;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(infinite_value const&) = default;\n\t\tinfinite_value& operator=(infinite_value&&) = default;\n\n\t\toperator bool()const\n\t\t{\n\t\t\treturn static_cast<bool>(val);\n\t\t}\n\t\tT const& operator*()const\n\t\t{\n\t\t\treturn *val;\n\t\t}\n\n\t\tfriend infinite_value operator+(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs ? infinite_value<T>(*lhs + rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\n\t\tfriend bool operator==(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (!lhs && !rhs) || (lhs&&rhs && (*lhs == *rhs));\n\t\t}\n\t\tfriend bool operator==(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs && (*lhs == rhs);\n\t\t}\n\t\tfriend bool operator==(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn rhs && (lhs == *rhs);\n\t\t}\n\n\n\t\tfriend bool operator<(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : !rhs ? true : *lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : *lhs < rhs;\n\t\t}\n\t\tfriend bool operator<(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? true : lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\n\n\t\tfriend bool operator>(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn  !rhs ? false : !lhs ? true : *lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? true : *lhs > rhs;\n\t\t}\n\t\tfriend bool operator>(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? false : lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\n\t};\n\ttemplate<std::size_t Mod>class modulo_number\n\t{\n\t\tuint64 val = {};\n\t\tstatic constexpr uint64 abs(int64 n)\n\t\t{\n\t\t\treturn n <= -1 ? n + Mod : n;\n\t\t}\n\tpublic:\n\t\tmodulo_number(modulo_number const&) = default;\n\t\tmodulo_number(modulo_number&&) = default;\n\t\tmodulo_number& operator=(modulo_number const&) = default;\n\t\tmodulo_number& operator=(modulo_number&&) = default;\n\t\t~modulo_number() = default;\n\n\t\tconstexpr modulo_number(uint64 num = {}) : val(num%Mod) {}\n\t\tconstexpr modulo_number(unsigned int num) : val(num%Mod) {}\n\t\tconstexpr modulo_number(int64 num) : val(abs(num%Mod)) {}\n\t\tconstexpr modulo_number(int num) : val(abs(num%Mod)) {}\n\n\t\tmodulo_number& operator=(uint64 num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int64 num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(unsigned int num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn val;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + Mod - rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val*rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn lhs*math::pow(rhs, Mod - 2);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\n\t\ttemplate<class Rhs>decltype(auto) operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator/=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this / rhs;\n\t\t}\n\t};\n\n\ttemplate<class T>constexpr T factorial(std::size_t n, std::size_t goal = 1)\n\t{\n\t\treturn n == goal ? T(n) : n == 0 ? T(1) : factorial<T>(n, (n + goal) / 2 + 1)*factorial<T>((n + goal) / 2, goal);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr uint64 integral_sqrt_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? start :\n\t\t\t\tpow((start + end) / 2 + 1, 2) <= v ?\n\t\t\t\tintegral_sqrt_i(v, (start + end) / 2 + 1, end) :\n\t\t\t\tintegral_sqrt_i(v, start, (start + end) / 2);\n\t\t}\n\t}\n\n\tconstexpr uint64 integral_sqrt(uint64 v)\n\t{\n\t\treturn v == 0 ? 0 :\n\t\t\tv == 1 ? 1 :\n\t\t\tdetail::integral_sqrt_i(v, 1, 0b100000000000000000000000000000000ull);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr bool is_prime_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? v%end != 0 :\n\t\t\t\tis_prime_i(v, start, (start + end) / 2) &&\n\t\t\t\tis_prime_i(v, (start + end) / 2 + 1, end);\n\t\t}\n\t}\n\n\tconstexpr bool is_prime(uint64 v)\n\t{\n\t\treturn v == 0 ? false :\n\t\t\tv == 1 ? false :\n\t\t\tv == 2 ? true :\n\t\t\tv == 3 ? true : detail::is_prime_i(v, 2, integral_sqrt(v));\n\t}\n\n\tclass dynamic_modulo\n\t{\n\t\tuint64 value;\n\t\tuint64 mod;\n\t\tstatic constexpr uint64 abs(int64 v, uint64 mod)\n\t\t{\n\t\t\treturn v <= -1 ? v + mod : v;\n\t\t}\n\tpublic:\n\t\tconstexpr dynamic_modulo() :value(), mod(2) {}\n\t\tconstexpr dynamic_modulo(uint64 v, uint64 m) : value(v), mod(m) {}\n\t\tdynamic_modulo(dynamic_modulo const&) = default;\n\t\tdynamic_modulo(dynamic_modulo&&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo const&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo&&) = default;\n\t\t~dynamic_modulo() = default;\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value + rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value * rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo(abs((lhs.value - rhs.value) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\ttemplate<class Rhs>dynamic_modulo& operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t};\n}\nnamespace geometry\n{\n\ttemplate<class Type>struct point\n\t{\n\t\tType x, y;\n\t};\n\ttemplate<class Type>auto make_point(Type x, Type y)\n\t{\n\t\treturn point<Type>{x, y};\n\t}\n\ttemplate<class Type>auto operator+(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x + rhs.x, lhs.y + rhs.y);\n\t}\n\ttemplate<class Type>auto operator-(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x - rhs.x, lhs.y - rhs.y);\n\t}\n\ttemplate<class Point>struct box\n\t{\n\t\tPoint small, large;\n\t};\n\ttemplate<class Point>auto make_box(Point a, Point b)\n\t{\n\t\treturn box<Point>{\n\t\t\tmake_point(std::min(a.x, b.x), std::min(a.y, b.y)),\n\t\t\t\tmake_point(std::max(a.x, b.x), std::max(a.y, b.y))};\n\t}\n#ifndef  PLASMA_NO_BOOST\n\ttemplate<class Point>boost::optional<box<Point>> hit_check(box<Point> a, box<Point> b)\n\t{\n\t\tif (a.small.x > b.small.x)\n\t\t\tstd::swap(a, b);\n\t\tif (a.large.x < b.small.x)\n\t\t\treturn boost::none;\n\t\tauto small_x = b.small.x;\n\t\tauto large_x = std::min(b.large.x, a.large.x);\n\t\tif (a.small.y < b.small.y)\n\t\t{\n\t\t\tif (b.small.y < a.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, b.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a.small.y < b.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, a.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t}\n#endif\n}\nnamespace graph_traits\n{\n\tclass graph\n\t{\n\t\tstd::vector<int64> node_data;\n\t\tstd::vector<std::vector<std::pair<int, int64>>> edge_data;\n\tpublic:\n\t\tgraph() = default;\n\t\tgraph(std::vector<int64>&& n) :node_data(std::move(n)), edge_data{}\n\t\t{\n\t\t\tedge_data.resize(node_data.size());\n\t\t}\n\t\tgraph(std::size_t size) :node_data(size), edge_data{}\n\t\t{\n\n\t\t}\n\n\t\tvoid resize(int size)\n\t\t{\n\t\t\tnode_data.resize(size);\n\t\t\tedge_data.resize(size);\n\t\t}\n\t\tvoid edge_reserve(int size)\n\t\t{\n\t\t\tfor (auto& v : edge_data)\n\t\t\t{\n\t\t\t\tv.reserve(size);\n\t\t\t}\n\t\t}\n\n\t\tvoid add_node(int64 data)\n\t\t{\n\t\t\tnode_data.emplace_back(data);\n\t\t\tedge_data.emplace_back();\n\t\t}\n\t\tvoid add_edge(int from, int to, int64 data)\n\t\t{\n\t\t\tedge_data[from].emplace_back(to, data);\n\t\t}\n\t\tstd::vector<math::infinite_value<int64>> dijkstra(int from)const\n\t\t{\n\t\t\tstruct compare\n\t\t\t{\n\t\t\t\tbool operator()(\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& lhs,\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& rhs)const\n\t\t\t\t{\n\t\t\t\t\treturn lhs.second > rhs.second;\n\t\t\t\t}\n\t\t\t};\n\t\t\tstd::priority_queue<\n\t\t\t\tstd::pair<int, math::infinite_value<int64>>,\n\t\t\t\tstd::vector<std::pair<int, math::infinite_value<int64>>>,\n\t\t\t\tcompare>nodes;\n\t\t\tstd::vector<math::infinite_value<int64>> ret(node_data.size());\n\t\t\tfor (int i{};i < node_data.size();++i)\n\t\t\t{\n\t\t\t\tnodes.emplace(i, math::infinite_value<int64>());\n\t\t\t}\n\t\t\tnodes.emplace(from, int());\n\n\t\t\twhile (nodes.size())\n\t\t\t{\n\t\t\t\tauto p = nodes.top();\n\t\t\t\tnodes.pop();\n\t\t\t\tif (ret[p.first] <= p.second)\n\t\t\t\t\tcontinue;\n\t\t\t\tret[p.first] = p.second;\n\t\t\t\tfor (auto const& d : edge_data[p.first])\n\t\t\t\t{\n\t\t\t\t\tnodes.emplace(d.first, std::min(ret[d.first], ret[p.first] + d.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint64 operator[](int n)const\n\t\t{\n\t\t\treturn node_data[n];\n\t\t}\n\t};\n}\nnamespace container\n{\n\ttemplate<class T>using p_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n}\n\nvoid Main();\n#endif//テンプレートここまで\n//ここを書き換える\n#define PROBLEM 4\n\n//ここは書き換えない\nint main()\n{\n\tstd::cin.sync_with_stdio(false);\n\tstd::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1);\n\tMain();\n}\n\n#if BOOST_PP_EQUAL(PROBLEM, 1)\n\nvoid Main()\n{\n\tint N, A, B;\n\tstd::cin >> N >> A >> B;\n\tcontainer::p_queue<int> t;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint x;\n\t\tstd::cin >> x;\n\t\tt.emplace(x);\n\t}\n\tint size{};\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t\telse if (x >= A)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t++size;\n\t}\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tstd::cout << size << std::endl;\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 2)\n\nvoid Main()\n{\n\tint N, K;\n\tstd::cin >> N >> K;\n\tstd::array<int, 26>count = {};\n\tfor (int i{};i < N;++i)\n\t{\n\t\tstd::string str;\n\t\tstd::cin >> str;\n\t\t++count[str.front() - 'A'];\n\t}\n\tint loop{};\n\twhile (true)\n\t{\n\t\talgorithm::sort(count, std::greater<>());\n\t\tfor (int i{};i < K;++i)\n\t\t{\n\t\t\tif (count[i])\n\t\t\t{\n\t\t\t\t--count[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::cout << loop << std::endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t++loop;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 3)\n\nvoid Main()\n{\n\tstd::vector<std::pair<int,int>> table;\n\tfor (int i{};i < 128;++i)\n\t{\n\t\tint max{};\n\t\tint y{};\n\t\tfor (int j{};j < 128;++j)\n\t\t{\n\t\t\tif (max <= (i^j) + j - i)\n\t\t\t{\n\t\t\t\tmax = (i^j) + j - i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\ttable.emplace_back(std::make_pair(y, max));\n\t}\n\talgorithm::sort(table, std::greater<>());\n\tint N;\n\tstd::cin >> N;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint C, D;\n\t\tstd::cin >> C >> D;\n\t\tstd::vector<int> cookie = { D };\n\t\tint now = D;\n\t\tfor (int x = 1;x < C;++x)\n\t\t{\n\t\t\tint target{};\n\t\t\tint max{};\n\t\t\tfor (int index{};index < cookie.size();++index)\n\t\t\t{\n\t\t\t\tif (max < table[cookie[index]].second)\n\t\t\t\t{\n\t\t\t\t\tmax = table[cookie[index]].second;\n\t\t\t\t\ttarget = index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow += max;\n\t\t\tcookie.emplace_back(table[cookie[target]].first);\n\t\t\tcookie[target] ^= table[cookie[target]].first;\n\t\t}\n\t\tstd::cout << now << std::endl;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 4)\n\nvoid Main()\n{\n\tint N;\n\tstd::cin >> N;\n\tstd::vector<std::pair<char, char>> basic;\n\tstd::vector<std::pair<std::string, std::string>> data;\n\tstd::string ret;\n\tfor (auto x1 : { '.','#' })for (auto x2 : { '.','#' })\n\t{\n\t\tstd::cout << x1 << std::endl << x2 << std::endl;\n\t\tstd::cin >> ret;\n\t\tif (ret == \"T\")\n\t\t{\n\t\t\tbasic.emplace_back(x1, x2);\n\t\t\tdata.emplace_back(std::string() + x1, std::string() + x2);\n\t\t}\n\t\telse if (ret == \"end\")\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (true)\n\t{\n\t\tstd::vector<std::pair<std::string, std::string>> impl;\n\t\tfor (auto const& c : basic)for (auto const& s : data)\n\t\t{\n\t\t\tstd::cout << s.first + c.first << std::endl << s.second + c.second << std::endl;\n\t\t\tstd::cin >> ret;\n\t\t\tif (ret == \"T\")\n\t\t\t{\n\t\t\t\timpl.emplace_back(s.first + c.first, s.second + c.second);\n\t\t\t}\n\t\t\telse if (ret == \"end\")\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tstd::swap(impl, data);\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 5)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 6)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 7)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 8)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 9)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 10)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 11)\n\nvoid Main()\n{\n\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\n\nint ask(string a,string b) {\n\tcout<<a<<endl;\n\tcout<<b<<endl;\n\tstring s;\n\tcin>>s;\n\tif(s==\"end\") exit(0);\n\treturn s==\"T\";\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\tcin>>N;\n\t\n\tstring a=\"\";\n\tstring b=\"\";\n\twhile(1) {\n\t\tFOR(i,4) {\n\t\t\ta+=\".#\"[i/2];\n\t\t\tb+=\".#\"[i%2];\n\t\t\tif(ask(a,b)) break;\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t}\n\t\tif(i==4) break;\n\t}\n\twhile(1) {\n\t\tFOR(i,4) {\n\t\t\ta=\".#\"[i/2] + a;\n\t\t\tb=\".#\"[i%2] + b;\n\t\t\tif(ask(a,b)) break;\n\t\t\ta.erase(a.begin());\n\t\t\tb.erase(b.begin());\n\t\t}\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N;\nstring x, y;\nchar s[100];\n\nbool q (string a, string b) {\n        printf(\"%s\\n%s\\n\", a.c_str(), b.c_str()); fflush(stdout);\n        scanf(\" %s\", s);\n        if (s[0] == 'e') exit(0);\n        return s[0] == 'T';\n}\n\nint main () {\n        scanf(\"%d\", &N);\n        while (1) {\n                if ((int) x.size() == N) break;\n                bool ok = 0;\n                fo(i, 0, 4) {\n                        char c1 = '.', c2 = '.';\n                        if (i&1) c1 = '#';\n                        if (i&2) c2 = '#';\n                        if (q(x+c1, y+c2)) {\n                                ok = 1;\n                                x = x + c1;\n                                y = y + c2;\n                                break;\n                        }\n                }\n                if (!ok) break;\n        }\n        while (1) {\n                if ((int) x.size() == N) break;\n                bool ok = 0;\n                fo(i, 0, 4) {\n                        char c1 = '.', c2 = '.';\n                        if (i&1) c1 = '#';\n                        if (i&3) c2 = '#';\n                        if (q(c1+x, c2+y)) {\n                                ok = 1;\n                                x = c1 + x;\n                                y = c2 + y;\n                                break;\n                        }\n                }\n                if (!ok) break;\n        }\n        printf(\"%s\\n%s\\n\", x.c_str(), y.c_str()); fflush(stdout);\n        scanf(\" %s\", s);\n        assert(s[0] == 'e');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nbool stop = false;\nvoid dfs(string s1, string s2, bool f2) {\n    if (s1.size() == N + 1) return;\n    if (stop) return;\n    string res;\n    bool f = false;\n    rep(i, 2) rep(j, 2) {\n        if (stop) return;\n        char c1 = i == 0 ? '.' : '#';\n        char c2 = j == 0 ? '.' : '#';\n        string t1, t2;\n        if (f2) {\n            t1 = s1 + c1;\n            t2 = s2 + c2;\n        } else {\n            t1 = c1 + s1;\n            t2 = c2 + s2;\n        }\n        printf(\"%s\\n%s\\n\", t1.c_str(), t2.c_str());\n        fflush(stdout);\n        cin >> res;\n        if (res == \"end\") {\n            stop = true;\n            break;\n        }\n        if (res == \"T\") {\n            f = true;\n            dfs(t1, t2, f2);\n        }\n        if (!f2) {\n            dfs(s1, s2, !f2);\n        }\n        if (stop) return;\n    }\n}\nint main() {\n    cin >> N;\n    dfs(\"\", \"\", 1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <list>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\n\nstring pat[4] = {\"..\", \".#\", \"#.\", \"##\"};\n\nvoid dump(const string& s){\n  for(int i=0; i<s.size(); i+=2){\n    cout << s[i];\n  }\n  cout << endl;\n  for(int i=1; i<s.size(); i+=2){\n    cout << s[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  string res;\n  int pi = 0;\n  rep(i,4){\n    dump(pat[i]);\n    cin >> res;\n    if(res == \"T\"){\n      pi = i;\n      break;\n    }\n  }\n\n  string st = pat[pi];\n  while(true){\n    rep(i,4){\n      string tmp = st + pat[i];\n      dump(tmp);\n      cin >> res;\n      if(res == \"end\") return 0;\n      if(res == \"T\"){\n        st += pat[i];\n        break;\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nint first = 0;\nint last = 0;\n\n\nstring ans = \"F\";\n\nbool isRight = true;\n\nint main(){\n\n\tchar dumup[201];\n\tchar *up;\n\tup = dumup + 100;\n\n\tchar dumdown[201];\n\tchar *down;\n\tdown = dumdown + 100;\n\t\n\tcin >> N;\n\tmemset(dumup,'.',sizeof(dumup));\n\tmemset(dumdown,'.',sizeof(dumdown));\n\t\n\twhile(1){\n\t\t\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[last+1] = intup;\n\t\t\t\tdown[last+1] = intdown;\n\t\t\t\tlast++;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"F\" && i == 3){\n\t\t\t\tisRight = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!isRight) break;\n\t}\n\twhile(last - first != N){\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\t\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[first-1] = intup;\n\t\t\t\tdown[first-1] = intdown;\n\t\t\t\tfirst--;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"end\"){\n\t\t\t\tisRight = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(isRight) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//諸機能\n#pragma region MACRO \n#define putans(x)  std::cerr << \"answer: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"answer: \"; cout << setprecision(13) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //ファイルからテストデータを読み込む\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //ジャッジシステムでいい感じにやる\n#define put cin >>\n#endif\n#pragma endregion\n\n//デバッグなどの支援\n#pragma region CODING_SUPPORT\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#ifndef _DEBUG\n#define dbg1 {}\n#define dbg2 {}\n#define dbg3 {}\n#define dbgArray {}\n#endif \n#pragma endregion \n//typedef（書き換える、書き足す可能性ある）\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//諸々の定数(書き換える可能性ある)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-9)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(1e9)\n#pragma endregion\n//\n//class Point {//幾何上のべクトル\n//public:\n//\tdouble x, y;\n//\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n//\n//\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n//\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n//\tPoint operator * (double a) { return Point(x * a, y * a); }\n//\tdouble operator * (Point p) { return dot(p); }\n//\tPoint operator / (double a) { return Point(x / a, y / a); }\n//\n//\tdouble abs() { return sqrt(norm()); }\n//\tdouble norm() { return x*x + y*y; }\n//\n//\tbool operator < (const Point &p) const {return  x != p.x ? x < p.x : y < p.y;}\n//\tbool operator == (const Point &p) const {return  fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;}\n//\t//内積、外積\n//\tdouble dot(Point p) {return x * p.x + y * p.y;}\n//\tdouble cross(Point p) { return x * p.y - y * p.x; }\n//\n//\n//};\n//\n//double abs(Vector p) { return norm(p); }\n//double norm(Vector p) { return p.x * p.x + p.y * p.y; }\n//double dot(Point p, Point q) { return p.x * q.x + p.y * q.y; }\n//double cross(Point p, Point q) { return q.x * p.y - p.y * p.x; }\n//\n//class Circle {\n//public:\n//\tPoint c;\n//\tdouble r;\n//\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n//};\n//struct Segment {//線分\n//\tPoint p1, p2;\n//};\n//\n//typedef Point Vector;\n//typedef Segment Line;//直線\n//typedef vector<Point> Polygon;\n//\n////直行、並行\n//bool isOrthogonal(Vector a, Vector b) { return equals(a*b, 0.0); }\n//bool isParallel(Vector a, Vector b) { return equals(cross(a,b), 0.0); }\n//\n////線分sに対する点pの射影\n//Point projection(Segment s, Point p) {\n//\tVector base = s.p2 - s.p1;\n//\tdouble r = dot((p - s.p1),base) / norm(base);\n//\treturn s.p1 + base*r;\n//}\n////線分sに対する点pの反射\n//Point reflection(Segment s, Point p) {return p + ( projection(s, p) - p ) * 2;}\n//\n//\n\n//\n//double getDistance(Point a, Point b) {return ( a - b ).abs;}\n//double getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1)); }\n//double getDistanceSP(Segment s, Point p) {\n//\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n//\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n//}\n//\n//double getDistance(Segment s1, Segment s2) {\n//\tif (intersect(s1, s2)) return 0;\n//\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2))\n//\t         , min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n//}\n//\n////p1-p0を基準として p2-p0 の2ベクトルについて\n//static const int COUNTER_CLOCKWISE = 1;//反時計回り\n//static const int CLOCKWISE = -1;//時計回り\n//static const int ONLINE_BACK = 2;//同一直線状p2,p0,p1の順\n//static const int ONLINE_FRONT = 1;//同一直線上p0,p1,p2の順\n//static const int ON_SEGMENT = 0;//p2がp0,p1上にある場合\n//int ccw(Point p0, Point p1, Point p2) {//上記の分類関数\n//\tVector a = p1 - p0;\n//\tVector b = p2 - p0;\n//\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n//\tif (cross(a, b) < EPS) return CLOCKWISE;\n//\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n//\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n//\treturn ON_SEGMENT;\n//}\n////線分p1p2とp3p4の交差判定\n//bool intersect(Point p1, Point p2, Point p3, Point p4) {return ( (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) && (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0));}\n//bool intersect(Segment s1, Segment s2) {return intersect(s1.p1 , s1.p1, s2.p1, s2.p2);}\n//\n//Point getCrossPoint(Segment s1, Segment s2) {\n//\tVector base = s2.p2 - s2.p1;\n//\tdouble d1 = abs(cross(base , s1.p1 - s2.p1));\n//\tdouble d2 = abs(cross(base , s1.p2 - s2.p1));\n//\tdouble t = d1 / ( d1 + d2 );\n//\treturn s1.p1 + (s1.p2 - s1.p1 ) * t;\n//}\n//\n////直線と円の交点を調べる\n//pair<Point, Point> getCrossPoints(Circle c, Line l) {\n//\t//assert(intersect(c, i)); 交差しない場合についてのはず\n//\tVector pr = projection(c, l);\n//\tVector e = ( l.p2 - l.p1 ) / abs(l.p2 - l.p1);\n//\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n//\treturn mp(pr + e * base, pr - e * base);\n//}\n//\n////点の内包を調べる\n//static const int IN_POLYGON = 2;//多角形の内部\n//static const int OUT_POLYGON = 1;//多角形の外部\n//static const int ON_POLYGON = 0;//多角形の線分上\n//int contains(Polygon g, Point p) {\n//\tint n = g.size();\n//\tbool x = false;\n//\trep(i, n) {\n//\t\tPoint a = g[i] - p, b = g[( i + 1 ) % n] - p;\n//\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return OUT_POLYGON;\n//\t\tif (a.y > b.y) swap(a, b);\n//\t\tif (a.y < EPS && EPS < b.y && cross(a, b)) x = !x;\n//\t}\n//\treturn ( x ? IN_POLYGON : ON_POLYGON );\n//}\n\n//凸包\n\n\n/*\n#define i(x) int x; scanf(\"%d\",&x);\n#define l(x) ll x; scanf(\"%lld\",&x);\n#define d(x) double  x; scanf(\"%lf\",&x);\n*/\n//今度実装がんばる\n//https://www23.atwiki.jp/akitaicpc/pages/65.html\n\n\nint main() {\n\t/*double xp1, yp1, xp2, yp2; put xp1 >> yp1 >> xp2 >> yp2;\n\tSegment s;\n\ts.p1 = Point(xp1, yp1);\n\ts.p2 = Point(xp2, yp2);\n\n\tint n; put n;\n\trep(i, n) {\n\t\tPoint p;\n\t\tput p.x >> p.y;\n\t\tPoint prj =reflection(s, p);\n\t\tcout << setprecision(13) << prj.x << \" \" << prj.y << endl;\n\t}*/\n\t//テンプレート化を来世に考える\n\tauto getI = [&]()->auto { int tmp; put tmp; return tmp; };\n\tauto getLL = [&]()->auto { ll tmp; put tmp; return tmp; };\n\tauto getS = [&]()->auto { string tmp; put tmp; return tmp; };\n\n\tint n; put n;\n\tstring s1, s2;\n\tstring r;\n\tstring patan1[4] = { \".\",\"#\",\".\",\"#\" };\n\tstring patan2[4] = { \".\",\".\",\"#\",\"#\" };\n\trep(j, n) {\n\t\trep(i, 4) {\n\t\t\tcout << s1 + patan1[i] + \"\\n\" << s2 + patan2[i] << endl;\n\t\t\tcin >> r;\n\t\t\tif (r == \"T\") {\n\t\t\t\ts1 += patan1[i];\n\t\t\t\ts2 += patan2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (r == \"end\")goto END;\n\t\t}\n\t}\n\tEND:\n\tcout << endl;\n\treturn 0;\n}\n\n//\n//int n, a, b; put n >> a >> b;\n//\tvi t;\n//\trep(i, n) {\n//\t\tt.push_back(get());\n//\t}\n//\tint count = 0;\n//\trep(i, n) {\n//\t\tif (t[i] < a || b <= t[i])count++;\n//\t}\n//\tputans(count);\n\n//\n//\tset<string> list;\n//\tint ans = 0;\n//\tint n; put n;\n//\tint k; put k;\n//\tint numAlphabet[26];\n//\tfill(all(numAlphabet), 0);\n//\trep(i, n) {\n//\t\tstring s; put s;\n//\t\tif (exist(list, s))continue;\n//\t\tlist.insert(s);\n//\t\tnumAlphabet[s[0] - 'A']++;\n//\t}\n//\tsort(all(numAlphabet),greater<int>());\n//\twhile (true) {\n//\t\trep(i, k) {\n//\t\t\tif (numAlphabet[i] == 0) goto END;\n//\t\t\telse numAlphabet[i]--;\n//\t\t}\n//\t\tsort(all(numAlphabet), greater<int>());\n//\t\tans++;\n//\t}\n//END:\n//\tputans(ans);\n\n\n\t//int t; put t;\n\t//rep(i, t) {\n\t//\tint n, d; put n >> d;\n\t//\tif (n == 1) {\n\t//\t\tputans(d);\n\t//\t\tcontinue;\n\t//\t}\n\t//\tputans(n % 2 != 0 ? ( n - 1 ) * 127 + d : ( n - 1 ) * 127 + ( 127 ^ d ));\n\t//}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstring S1, S2; int n; char C[3] = \".#\";\nint Division = 2;\nint main() {\n\tcin >> n; bool END = false;\n\twhile (true) {\n\t\tstring S3 = S1, S4 = S2;\n\t\tif (Division == 2) {\n\t\t\tbool OK = false;\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tS3 = S1; S4 = S2;\n\t\t\t\tS3 = S3 + C[j / 2];\n\t\t\t\tS4 = S4 + C[j % 2];\n\t\t\t\tcout << S3 << endl << S4 << endl;\n\t\t\t\tstring D; cin >> D;\n\t\t\t\tif (D == \"end\")END = true;\n\t\t\t\tif (D == \"T\" || D == \"end\") { OK = true; S1 = S3; S2 = S4; break; }\n\t\t\t}\n\t\t\tif (OK == false)Division = 1;\n\t\t}\n\t\tif (Division == 1) {\n\t\t\tbool OK = false;\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tS3 = S1; S4 = S2;\n\t\t\t\tS3 = C[j / 2] + S3;\n\t\t\t\tS4 = C[j % 2] + S4;\n\t\t\t\tcout << S3 << endl << S4 << endl;\n\t\t\t\tstring D; cin >> D;\n\t\t\t\tif (D == \"end\")END = true;\n\t\t\t\tif (D == \"T\" || D == \"end\") { OK = true; S1 = S3; S2 = S4; break; }\n\t\t\t}\n\t\t}\n\t\tif (END == true)break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\n\n#define FORN(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n\n#define DEBUG(X) { cout << #X << \" = \" << (X) << endl; }\n#define PR0(A,n) { cout << #A << \" = \"; FORN(_,n) cout << A[_] << ' '; cout << endl; }\n\n#define MOD 1000000007\n#define INF 2000000000\n\nint GLL(LL& x) {\n    return scanf(\"%lld\", &x);\n}\n\nint GI(int& x) {\n    return scanf(\"%d\", &x);\n}\n\nint n;\n\nstring s1, s2, tval;\n\nchar up[4] = {'.', '.', '#', '#'};\nchar dn[4] = {'.', '#', '.', '#'};\n\nint main() {\n    GI(n);\n\n    bool fwd = true;\n\n    while (s1.size() < n) {\n        bool ok = false;\n\n        FORN(i, 4) {\n            string ns1 = (fwd ? s1 + up[i] : up[i] + s1);\n            string ns2 = (fwd ? s2 + dn[i] : dn[i] + s2);\n\n            cout << ns1 << \"\\n\" << ns2 << \"\\n\";\n            cin >> tval;\n\n            if (tval[0] == 'T') {\n                s1 = ns1;\n                s2 = ns2;\n                ok = true;\n                break;\n            }\n            else if (tval[0] == 'e') {\n                return 0;\n            }\n        }\n\n        if (!ok) {\n            fwd = false;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nchar res[4];\n\nbool query(string s1,string s2){\n\tprintf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str());\n\tfflush(stdout);\n\tscanf(\"%s\",res);\n\treturn (res[0]=='e');\n}\n\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\n\tstring all[2]={\"\",\"\"};\n\t\n\trep(i,n){\n\t\tbool ok=false;\n\t\trep(mask,4){\n\t\t\tstring t0=string(1,((mask&2)?'#':'.'));\n\t\t\tstring t1=string(1,((mask&1)?'#':'.'));\t\t\t\n\t\t\tif(query(all[0]+t0,all[1]+t1)) return 0;\n\t\t\tif(res[0]=='T'){\n\t\t\t\tall[0]=all[0]+t0,all[1]=all[1]+t1;\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok==false) break;\n\t}\n\n\trep(i,n){\n\t\tbool ok=false;\n\t\trep(mask,4){\n\t\t\tstring t0=string(1,((mask&2)?'#':'.'));\n\t\t\tstring t1=string(1,((mask&1)?'#':'.'));\t\t\t\n\t\t\tif(query(t0+all[0],t1+all[1])) return 0;\n\t\t\tif(res[0]=='T'){\n\t\t\t\tall[0]=t0+all[0],all[1]=t1+all[1];\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok==false) break;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n//#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\ndeque<char> d[2];\n\nvoid hora(int tc) {\n\tint n;\n\tcin>>n;\n\twhile(1) {\n\t\tbool ada = false;\n\t\tfor(int i = 0;i < 4;i++) {\n\t\t\tada = true;\n\t\t\tfor(auto x: d[0]) cout<<x;\n\t\t\tif(i == 0 || i == 2) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tcout<<endl;\n\t\t\tfor(auto x: d[1]) cout<<x;\n\t\t\tif(i == 0 || i == 1) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tcout<<endl;\n\t\t\tstring c;\n\t\t\tcin>>c;\n\t\t\tif(c == \"T\") {\n\t\t\t\tada = true;\n\t\t\t\tif(i == 0 || i == 2) d[0].PB('.');\n\t\t\t\telse d[0].PB('#');\n\t\t\t\tif(i == 0 || i == 1) d[1].PB('.');\n\t\t\t\telse d[1].PB('#');\n\t\t\t\tbreak;\n\t\t\t} else if(c == \"end\") return ;\n\t\t}\n\t\tif(ada == false) break;\t\n\t}\n\twhile(1) {\n\t\tbool ada = false;\n\t\tfor(int i = 0;i < 4;i++) {\n\t\t\tada = true;\n\t\t\tif(i == 0 || i == 2) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tfor(auto x: d[0]) cout<<x;\n\t\t\tcout<<endl;\n\t\t\tif(i == 0 || i == 1) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tfor(auto x: d[1]) cout<<x;\n\t\t\tcout<<endl;\n\t\t\tstring c;\n\t\t\tcin>>c;\n\t\t\tif(c == \"T\") {\n\t\t\t\tada = true;\n\t\t\t\tif(i == 0 || i == 2) d[0].PF('.');\n\t\t\t\telse d[0].PF('#');\n\t\t\t\tif(i == 0 || i == 1) d[1].PF('.');\n\t\t\t\telse d[1].PF('#');\n\t\t\t\tbreak;\n\t\t\t} else if(c == \"end\") return ;\n\t\t}\t\n\t}\n}\n\nint main(){\n//\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main()\n{\n  int n;\n  string s1;\n  string s2;\n  string ans;\n  char add[4][2]={{'.','.'},{'#','.'},{'.','#'},{'#','#'}};\n  int i;\n  int l=4;\n  cin>>n;\n\n  printf(\"#\\n#\\n\");\n  fflush(stdout);\n  cin>>ans;\n  if(ans==\"end\")return 0;\n  if(ans==\"T\"){\n    s1=\"#\";\n    s2=\"#\";\n  }else{\n    l--;\n    printf(\".\\n#\\n\");\n    fflush(stdout);\n    cin>>ans;\n    if(ans==\"end\")return 0;\n    if(ans==\"T\"){\n      s1=\".\";\n      s2=\"#\";\n    }else{\n      l--;\n      printf(\"#\\n.\\n\");\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n      if(ans==\"T\"){\n\ts1=\"#\";\n\ts2=\".\";\n      }else{\n\tl--;\n\ts1=\".\";\n\ts2=\".\";\n      }\n    }\n  }\n\n  while(1){\n    rep(i,l){\n      cout<<s1<<add[i][0]<<endl;\n      cout<<s2<<add[i][1]<<endl;\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n      if(ans==\"T\"){\n\ts1=s1+add[i][0];\n\ts2=s2+add[i][1];\n\tbreak;\n      }\n    }\n    if(i==l)break;\n  }\n  while(1){\n    rep(i,l){\n      cout<<add[i][0]<<s1<<endl;\n      cout<<add[i][1]<<s2<<endl;\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n\tif(ans==\"T\"){\n\t  s1=add[i][0]+s1;\n\t  s2=add[i][1]+s2;\n\t  break;\n\t}\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define FOR( i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define FOR1(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define REV( i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define REV1(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define INC( i, n) FOR( i, 0, n)\n#define INC1(i, n) FOR1(i, 1, n)\n#define DEC( i, n) REV( i, 0, n)\n#define DEC1(i, n) REV1(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint n;\nchar s1[101], s2[101];\nint len;\n\nvoid plus() {\n\tlen++;\n\ts1[len] = s2[len] = '\\0';\n}\n\nvoid minus() {\n\tlen--;\n\ts1[len] = s2[len] = '\\0';\n}\n\nvoid shift() {\n\tDEC(i, len) {\n\t\ts1[i + 1] = s1[i];\n\t\ts2[i + 1] = s2[i];\n\t}\n}\n\nint ask(int i, int p) {\n\tchar as1[] = \"..##\";\n\tchar as2[] = \".#.#\";\n\tchar r[4];\n\t\n\ts1[p] = as1[i];\n\ts2[p] = as2[i];\n\t\n\tprintf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n\t\n\tscanf(\"%s\", r);\n\t\n\t     if(r[0] == 'F') { return 0; }\n\telse if(r[0] == 'T') { return 1; }\n\telse                 { return 2; }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\t\n\ts1[0] = s2[0] = '\\0';\n\t\n\tbool flag = true;\n\twhile(len < n) {\n\t\tint res;\n\t\tplus();\n\t\tif(flag) {\n\t\t\tINC(i, 4) {\n\t\t\t\tres = ask(i, len - 1);\n\t\t\t\tif(res != 0) { break; }\n\t\t\t}\n\t\t\tif(res == 0) { flag = false; minus(); }\n\t\t} else {\n\t\t\tshift();\n\t\t\tINC(i, 4) {\n\t\t\t\tres = ask(i, 0);\n\t\t\t\tif(res != 0) { break; }\n\t\t\t}\n\t\t}\n\t\tif(res == 2) { break; }\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tstring atas = \"\";\n\tstring bawah = \"\";\n\t\n\tchar in_buffer[10] = {};\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas = '.' + atas;\n\t\tbawah = '.' + bawah;\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[0] = tempatas[j];\n\t\t\tbawah[0] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint len = atas.length();\n\tfor(len++; len <= n; len++) {\n\t\tatas = atas + '.';\n\t\tbawah = bawah + '.';\n\t\t\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[len-1] = tempatas[j];\n\t\t\tbawah[len-1] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nvoid pushLine(int cnt, vector< pair<char, char> > &v){\n    if(cnt == 0){\n        v.emplace_back(make_pair('.', '.'));\n    }else if(cnt == 1){\n        v.emplace_back(make_pair('#', '.'));\n    }else if(cnt == 2){\n        v.emplace_back(make_pair('.', '#'));\n    }else{\n        v.emplace_back(make_pair('#', '#'));\n    }\n}\n\nint main(){\n    int n;\n    vector< pair<char, char> > v;\n    cin >> n;\n\n    char a[4][3] = {\"..\", \"#.\", \".#\", \"##\"};\n    bool c = true; //true == front, false == back\n    int cnt = 0;\n    while(true){\n        if(c){\n            cout << a[cnt][0];\n            rep(i, v.size()) cout << v[i].first;\n            cout << endl;\n            cout << a[cnt][1];\n            rep(i, v.size()) cout << v[i].second;\n            cout << endl;\n        }else{\n            rep(i, v.size()) cout << v[i].first;\n            cout << a[cnt][0];\n            cout << endl;\n            rep(i, v.size()) cout << v[i].second;\n            cout << a[cnt][1];\n            cout << endl;\n        }\n        fflush(stdout);\n\n        string str;\n        cin >> str;\n        if(str[0] == 'T'){\n            pushLine(cnt, v);\n            cnt = 0;\n        }else if(str[0] == 'F'){\n            cnt++;\n        }else{\n            break;\n        }\n        if(cnt == 4){\n            cnt = 0;\n            c = false;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int n;\n  std::cin >> n;\n  string s = \"\", ss = \"\", r;\n  string ds[] = {\".\", \"#\"};\n  for (int i = 0; i < 111; i++) {\n    for (int j = 0; j < 4; j++) {\n      printf(\"%s\\n%s\\n\", s + ds[j/2], ss + ds[j%2]); fflush(stdout);\n      std::cin >> r;\n      if(r == \"T\"){\n        s  += ds[j/2];\n        ss += ds[j%2];\n      }else if(r == \"end\"){\n        i = 1e9, j = 1e9;\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n; \nint main()\n{\n\tcin >> n;\n\tbool en = 0;\n\tstring s=\"\",t=\"\";\n\twhile(1){\n\t\tchar a[4]={'.','.','#','#'};\n\t\tchar b[4]={'.','#','.','#'};\n\t\tif(!en){\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\ts.push_back(a[i]);\n\t\t\t\tt.push_back(b[i]);\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<s.size();i++) printf(\"%c\",s[i]);\n\t\t\t\tputs(\"\");\n\t\t\t\tfor(int i=0;i<t.size();i++) printf(\"%c\",t[i]);\n\t\t\t\tputs(\"\"); fflush(stdout);\n\t\t\t\t\n\t\t\t\tchar res[5]; scanf(\"%s\",&res);\n\t\t\t\tif(res[0] == 'T') break;\n\t\t\t\telse if(res[0] == 'F'){\n\t\t\t\t\tif(i==3) en = 1;\n\t\t\t\t\ts.resize(s.size()-1); t.resize(t.size()-1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\treverse(s.begin(),s.end());\n\t\t\t\treverse(t.begin(),t.end());\n\t\t\t\ts.push_back(a[i]);\n\t\t\t\tt.push_back(b[i]);\n\t\t\t\treverse(s.begin(),s.end());\n\t\t\t\treverse(t.begin(),t.end());\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<s.size();i++) printf(\"%c\",s[i]);\n\t\t\t\tputs(\"\");\n\t\t\t\tfor(int i=0;i<t.size();i++) printf(\"%c\",t[i]);\n\t\t\t\tputs(\"\"); fflush(stdout);\n\t\t\t\t\n\t\t\t\tchar res[5]; scanf(\"%s\",&res);\n\t\t\t\tif(res[0] == 'T') break;\n\t\t\t\telse if(res[0] == 'F'){\n\t\t\t\t\tif(i==3) assert(0);\n\t\t\t\t\treverse(s.begin(),s.end());\n\t\t\t\t\treverse(t.begin(),t.end());\n\t\t\t\t\ts.resize(s.size()-1); t.resize(t.size()-1);\n\t\t\t\t\treverse(s.begin(),s.end());\n\t\t\t\t\treverse(t.begin(),t.end());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long long LL;\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#ifdef DEBUG\n    #define cek(x) cout<<x\n#else\n    #define cek(x) if(false){}\n#endif // DEBUG\n\n#define fi first\n#define se second\n#define INF 1000000000\n#define INFLL 1000000000000000000LL\n#define EPS 1e-9\n#define PI acos(-1.0)\n#define pb push_back\n#define TC() while(tc--)\n#define FOR(i,n) for(int i=0;i<n;i++)\n#define FORN(i,n) for(int i=0;i<=n;i++)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define REPN(i,a,b) for(int i=a;i<=b;i++)\n#define reset(a,b) memset(a,b,sizeof(a))\n#define sc(x) scanf(\"%d\",&x)\n\nint main(void){\n    #ifdef ccsnoopy\n        freopen(\"D:/Code/in.txt\",\"r\",stdin);\n    #endif\n\n    int n;\n    sc(n);\n    string res;\n    deque<char> atas,bawah;\n    char iatas[] = {'.','.','#','#'};\n    char ibawah[] = {'.','#','.','#'};\n    bool gausah = false;\n    while(true){\n        bool valid = false;\n        if(!gausah)FOR(i,4){\n            FOR(j,atas.size()){\n                printf(\"%c\", atas[j]);\n            }\n            printf(\"%c\\n\", iatas[i]);\n            FOR(j,bawah.size()){\n                printf(\"%c\", bawah[j]);\n            }\n            printf(\"%c\\n\", ibawah[i]);\n            fflush(stdout);\n            cin>>res;\n            if(res == \"T\"){\n                atas.push_back(iatas[i]);\n                bawah.push_back(ibawah[i]);\n                valid = true;\n                break;\n            }else if(res == \"end\"){\n                return 0;\n            }\n        }\n\n        if(valid)continue;\n        gausah = true;\n        FOR(i,4){\n            printf(\"%c\", iatas[i]);\n            FOR(j,atas.size()){\n                printf(\"%c\", atas[j]);\n            }\n            printf(\"\\n%c\", ibawah[i]);\n            FOR(j,bawah.size()){\n                printf(\"%c\", bawah[j]);\n            }\n            printf(\"\\n\");\n            fflush(stdout);\n            cin >> res;\n            if(res == \"T\"){\n                atas.push_front(iatas[i]);\n                bawah.push_front(ibawah[i]);\n                break;\n            }else if(res == \"end\"){\n                return 0;\n            }\n        }\n\n    }\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DBG(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nstring str = \".\\n.\\n\";\n\nvoid fuck(string &str) {\n    string up, down;\n    int cnt = 0;\n    for(auto c : str) {\n        if(c != '\\n') {\n            if(cnt & 1) down.push_back(c);\n            else up.push_back(c);\n            ++cnt;\n        }\n    }\n    cout << up << endl;\n    cout << down << endl;\n}\n\nint main(int argc, char **argv) {\n    int n;\n    cin >> n;\n    int cnt = 1;\n    bool toRight = true;\n    while(true) {\n        fuck(str);\n        fflush(stdout);\n        string st;\n        cin >> st;\n        if(st == \"end\") break;\n        else if(st == \"F\") {\n            if(cnt == 4) {\n                toRight = !toRight;\n                str.erase(str.size() - 4, 4);\n                str = \".\\n.\\n\" + str;\n                cnt = 1;\n            } else {\n                if(toRight) {\n                    str.erase(str.size() - 4, 4);\n                    string add;\n                    if(cnt & (1 << 0)) add += '#'; else add += '.'; add += '\\n';\n                    if(cnt & (1 << 1)) add += '#'; else add += '.'; add += '\\n';\n                    str += add;\n                    ++cnt;\n                } else {\n                    str.erase(0, 4);\n                    string add;\n                    if(cnt & (1 << 0)) add += '#'; else add += '.'; add += '\\n';\n                    if(cnt & (1 << 1)) add += '#'; else add += '.'; add += '\\n';\n                    str = add + str;\n                    ++cnt;\n                }\n            }\n        } else if(st == \"T\") {\n            cnt = 1;\n            if(toRight) str += \".\\n.\\n\";\n            else str = \".\\n.\\n\" + str;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(X) X.begin(), X.end()\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\ntypedef std::pair<LL,LL> PLL;//\ntypedef std::pair<int,int> PII;//\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18+20;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\nbool END = false;\nvector< vector< vector<int> > > word(7);\n\nbool check(vector<int> v){\n\tint size = v.size();\n\tstring A,B;\n\tfor(int i=0;i<size;++i){\n\t\tif( v[i]&1 ){\n\t\t\tA += '#';\n\t\t}else{\n\t\t\tA += '.';\n\t\t}\n\t\tif( v[i]&2 ){\n\t\t\tB += '#';\n\t\t}else{\n\t\t\tB += '.';\n\t\t}\n\t}\n\tcout << A << '\\n' << B << endl;\n\tstring res;\n\tcin >> res;\n\tif( res[0] == 'T' ){\n\t\treturn true;\n\t}else if( res[0] == 'F' ){\n\t\treturn false;\n\t}\n\tEND = true;\n\treturn true;\n}\n\nvoid make(int POW ){\n\tif( POW == 0 ){\n\t\tvector<int> temp(1);\n\t\tfor(int i=0;i<4;++i){\n\t\t\ttemp[0] = i;\n\t\t\tif( check( temp ) ){\n\t\t\t\tword[POW].push_back( temp );\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector< vector<int> >::iterator itrA,itrB,begin,end;\n\tbegin = word[POW-1].begin();\n\tend = word[POW-1].end();\n\tfor(itrA=begin;itrA != end;++itrA){\n\t\tfor(itrB=begin;itrB != end;++itrB){\n\t\t\tvector<int> temp;\n\t\t\ttemp.reserve( 1<<POW );\n\t\t\ttemp.insert( temp.end(), itrA->begin(),itrA->end() );\n\t\t\ttemp.insert( temp.end(), itrB->begin(),itrB->end() );\n\t\t\tif( check( temp ) ){\n\t\t\t\tword[POW].push_back( temp );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid f(int N,int POW){\n\tint LEN = (1<<POW);\n\tint over =2*LEN-N;\n\tvector< vector<int> >::iterator itrA,itrB,begin,end;\n\tbegin = word[POW].begin();\n\tend = word[POW].end();\n\tvector<int> temp(N);\n\tfor(itrA=begin;itrA != end;++itrA){\n\t\tfor(itrB=begin;itrB != end;++itrB){\n\t\t\tbool flag = true;\n\t\t\tfor(int i=0;i<over;++i){\n\t\t\t\tif( itrA[LEN-1-i] != itrB[over-1-i] ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag == false ) continue;\n\t\t\tfor(int i=0;i<N;++i){\n\t\t\t\tif( i < LEN ){\n\t\t\t\t\ttemp[i] = (*itrA)[i];\n\t\t\t\t}else{\n\t\t\t\t\ttemp[i] = (*itrB)[i-(N-LEN)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( check( temp ) ){\n\t\t\t\tif( END ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve(){\n\tint N;\n\tcin >> N;\n\t\n\tint Len = 0;\n\tfor(Len=0;(1<<Len)<=N;++Len){\n\t\tmake(Len);\n\t}\n\tLen >>= 1;\n\tf(N,Len);\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\nconst int INT_INF = 500000000;\nconst long long LONG_LONG_INF = (long long)pow(10, 18);\nconst int MOD = pow(10, 9) + 7;\n/* contest template */\nint N, cnt;\nstring s1, s2, r;\n\nint main() {\n  cin >> N;\n  while (true) {\n    cnt = 0;\n    r = \"F\";\n    while (r == \"F\" && cnt < 4) {\n      cnt++;\n      if (cnt == 1) {\n        cout << s1 << \".\" << endl;\n        cout << s2 << \".\" << endl;\n      } else if (cnt == 2) {\n        cout << s1 << \"#\" << endl;\n        cout << s2 << \".\" << endl;\n      } else if (cnt == 3) {\n        cout << s1 << \".\" << endl;\n        cout << s2 << \"#\" << endl;\n      } else if (cnt == 4) {\n        cout << s1 << \"#\" << endl;\n        cout << s2 << \"#\" << endl;\n      }\n      cin >> r;\n    }\n    if (r == \"end\") {\n      return 0;\n    } else if (r == \"T\") {\n      if (cnt == 1) {\n        s1 = s1 + \".\";\n        s2 = s2 + \".\";\n      } else if (cnt == 2) {\n        s1 = s1 + \"#\";\n        s2 = s2 + \".\";\n      } else if (cnt == 3) {\n        s1 = s1 + \".\";\n        s2 = s2 + \"#\";\n      } else if (cnt == 4) {\n        s1 = s1 + \"#\";\n        s2 = s2 + \"#\";\n      }\n    } else if (r == \"F\") {\n      break;\n    }\n  }\n  while (true) {\n    cnt = 0;\n    r = \"F\";\n    while (r == \"F\" && cnt < 4) {\n      cnt++;\n      if (cnt == 1) {\n        cout << \".\" << s1 << endl;\n        cout << \".\" << s2 << endl;\n      } else if (cnt == 2) {\n        cout << \"#\" << s1 << endl;\n        cout << \".\" << s2 << endl;\n      } else if (cnt == 3) {\n        cout << \".\" << s1 << endl;\n        cout << \"#\" << s2 << endl;\n      } else if (cnt == 4) {\n        cout << \"#\" << s1 << endl;\n        cout << \"#\" << s2 << endl;\n      }\n      cin >> r;\n    }\n    if (r == \"end\") {\n      return 0;\n    } else if (r == \"T\") {\n      if (cnt == 1) {\n        s1 = \".\" + s1;\n        s2 = \".\" + s2;\n      } else if (cnt == 2) {\n        s1 = \"#\" + s1;\n        s2 = \".\" + s2;\n      } else if (cnt == 3) {\n        s1 = \".\" + s1;\n        s2 = \"#\" + s2;\n      } else if (cnt == 4) {\n        s1 = \"#\" + s1;\n        s2 = \"#\" + s2;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stdio.h>\n#include <string>\nusing namespace std;\nstring ans[3],tmp[3],r;\nchar atas[4]={'#','.','#','.'},bawah[4] = {'.','.','#','#'};\nint n;\nbool cek;\nint main()\n{\n    scanf(\"%d\",&n);\n    while(1)\n    {\n        for(int i=0;i<4;i++)\n        {\n            if(cek)\n            {\n                tmp[0] = ans[0]+atas[i];\n                tmp[1] = ans[1]+bawah[i];\n            }\n            else\n            {\n                tmp[0] = atas[i]+ans[0];\n                tmp[1] = bawah[i]+ans[1];\n            }\n            for(int i=0;i<2;i++) cout<<tmp[i]<<endl;\n            cin>>r;\n           // cout<<\"r : \"<<r<<endl;\n            if(r==\"end\")\n            {\n                break;\n            }\n            if(r==\"T\")\n            {\n                ans[0] = tmp[0];\n                ans[1] = tmp[1];\n                break;\n            }\n            if(i==3)\n            {\n                cek = 1;\n            }\n        }\n        if(r==\"end\") break;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstring query(pair<string,string> p1,pair<string,string> p2){\n  string s1,s2;\n  s1 = p1.first + p2.first;\n  s2 = p1.second + p2.second;\n  printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n  string str;\n  cin >> str;\n  return str;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  vector<vector<pair<string,string> > >vec;\n  for(int i = 0 ; i < 2 ; i++){\n    string str1;\n    string str2;\n    for(int j = 0 ; j < 4 ; j++){\n      str1 += (j%2?\".\":\"#\");\n      str2 += ((j >> 1)%2?\".\":\"#\");\n    }\n    vector<pair<string,string> > v;\n    v.push_back(make_pair(str1,str2));\n    vec.push_back(v);\n  }\n  \n  while(1){\n    for(int i = 0 ; i < vec.size() ; i++){\n      for(int j = i ; j < vec.size() ; j++){\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  string r;\n\t  pair<string,string>p;\n\t  if(k % 2){\n\t    r = query(vec[i],vec[j]);\n\t    p = make_pair(vec[i].first + vec[j].first,vec[i].second + vec[j].second);\n\t  }\n\t  else {\n\t    r = query(vec[j],vec[i]);\n\t    p = make_pair(vec[j].first + vec[i].first,vec[j].second + vec[i].second);\n\t  }\n\t  // in\n\t  if(r == \"T\"){\n\t    vec.push_back(p);\n\t  }\n\t  else if(r == \"end\"){\n\t    return 0;\n\t  }\n\t}\n      }\n    }\n  }\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<char> aBener,bBener;\n\tint t = 1;\n\t\n\tchar atas[4] = {'.','#','.','#'};\n\t char bwh[4] = {'.','.','#','#'};\n\tstring s;\n\tint idx = 0,ct = 0;\n\tdo{\n\t\tct++;\n\t\tif(s == \"end\") break;\n\t\tif(s == \"F\") idx++;\n\t\tif(s == \"T\") {\n\t\t\taBener.push_back(atas[idx]);\n\t\t\tbBener.push_back(bwh[idx]);\n\t\t\tidx = 0;\n\t\t}\n\t\tfor(int i = 0;i<aBener.size();i++){\n\t\t\tprintf(\"%c\",aBener[i]);\n\t\t}\n\t\t\n\t\tif(idx >3) idx = 0;\n\t\t\n\t\t//coba\n\t\tprintf(\"%c\",atas[idx]);\n\t\tprintf(\"\\n\");\n\t\tfor(int i = 0;i<bBener.size();i++){\n\t\t\tprintf(\"%c\",bBener[i]);\n\t\t}\n\t\tprintf(\"%c\",bwh[idx]);\n\t\tprintf(\"\\n\");\n\t}while(cin>>s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ask(const std::deque<int>& a)\n{\n  for (int j = 0; j < 2; ++ j) {\n    for (int x : a) {\n      std::cout << \".#\"[x >> j & 1];\n    }\n    std::cout << \"\\n\";\n  }\n  std::cout << std::flush;\n  std::string verdict;\n  std::cin >> verdict;\n  if (verdict == \"end\") {\n    return -1;\n  }\n  return verdict == \"T\";\n}\n\nint main()\n{\n  int n;\n  std::cin >> n;\n  std::deque<int> guess;\n  while (static_cast<int>(guess.size()) < n) {\n    for (int a = 0; a < 4; ++ a) {\n      guess.push_back(a);\n      auto verdict = ask(guess);\n      if (verdict == -1) {\n        return 0;\n      }\n      if (verdict) {\n        break;\n      }\n      guess.pop_back();\n    }\n  }\n  while (static_cast<int>(guess.size()) < n) {\n    for (int a = 0; a < 4; ++ a) {\n      guess.push_front(a);\n      auto verdict = ask(guess);\n      if (verdict == -1) {\n        return 0;\n      }\n      if (verdict) {\n        break;\n      }\n      guess.pop_front();\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  4*100+8 ?\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\nusing ll = long long;\n\nstring convert(deque<int> &a){\n    string s,t;\n    rep(i,a.size()){\n        s += \"#.\"[a[i]>>0&1];\n        t += \"#.\"[a[i]>>1&1];\n    }\n    return s + \"\\n\" + t;\n}\n\nchar ask(deque<int> &a){\n    cout << convert(a) << endl;\n    string s;\n    cin >> s;\n    char c = s[0];\n    if(c == 'e') exit(0);\n    return c;\n}\n\nint main(){\n    int N;\n    while(cin >> N){\n        deque<int> X;\n        while(1){\n            int f = -1;\n            rep(i,4){\n                X.push_back(i);\n                char c = ask(X);\n                if(c == 'T'){\n                    f = i;\n                    break;\n                }\n                X.pop_back();\n            }\n            if((int)X.size() == N || f == -1) break;\n        }\n        while(1){\n            int f = -1;\n            rep(i,4){\n                X.push_front(i);\n                char c = ask(X);\n                if(c == 'T'){\n                    f = -1;\n                    break;\n                }\n                X.pop_front();\n            }\n            assert(f != -1);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 50010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nstring a=\"\",b=\"\",g[2]={\".\",\"#\"};\nint out(string &s,string &t){\n\tcout<<s<<\"\\n\"<<t<<\"\\n\";fflush(stdout);\n\tstring x;\n\tcin>>x;\n\tif(x[0]=='e')exit(0);\n\treturn x[0]=='T';\n}\nint main(){\n    int T,i,j,k,ca=0,m,n,K;\n    //cout<<setprecision(10)<<fixed;\n    cin>>n;\n    int x,v[4]={0};\n    rep(i,0,4){\n    \ta=g[i&1],b=g[i>>1&1];\n    \tk=out(a,b);\n    \tif(k)v[i]=1,x=i;\n    }\n    int len=0;\n    a=g[x&1],b=g[x>>1&1];\n    rep(i,1,n){\n    \tint flag=0;\n    \trep(j,0,4)if(v[j]){\n    \t\tstring aa=a+g[j&1],bb=b+g[j>>1&1];\n    \t\tk=out(aa,bb);\n    \t\tif(k){a=aa,b=bb;flag=1;break;}\n    \t}\n    \tif(!flag){\n    \t\tlen=i;break;\n    \t}\n    }\n\trep(i,0,n-len){\n\t\trep(j,0,4)if(v[j]){\n    \t\tstring aa=g[j&1]+a,bb=g[j>>1&1]+b;\n    \t\tk=out(aa,bb);\n    \t\tif(k){a=aa,b=bb;break;}\n    \t}\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\nusing namespace std;\n\nint main(){\n  int N;\n  cin >> N;\n\n  string table[2];\n  for(int i = 0 ; i < 2 ; i++){\n    for(int j = 0 ; j < N ; j++){\n      table[i] += '.';\n    }\n  }\n  \n  while(1){\n    // query\n    string n_table[2];\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n\tn_table[j] = table[j];\n      }\n\n      n_table[0] += (i%2?'#':'.');\n      n_table[1] += ((i >> 1)%2?'#':'.');\n      \n      printf(\"%s\\n%s\\n\", n_table[0].c_str(), n_table[1].c_str()); fflush(stdout);\n      // in\n      string str;\n      cin >> str;\n      if(str == \"T\"){\n\tfor(int j = 0 ; j < 2 ; j++){\n\t  table[j] = n_table[j];\n\t}\n\tbreak;\n      }\n      else if(str == \"end\"){\n\treturn 0;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <list>\n#include <stack>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\ntypedef long long ll;\n\nstring pat[4] = {\"..\", \".#\", \"#.\", \"##\"};\n\nvoid dump(const string& s){\n  for(int i=0; i<s.size(); i+=2){\n    cout << s[i];\n  }\n  cout << endl;\n  for(int i=1; i<s.size(); i+=2){\n    cout << s[i];\n  }\n  cout << endl;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  string res;\n  string st = \"\";\n  bool back = true;\n  while(true){\n    bool flg = false;\n    rep(i,4){\n      string tmp;\n      if(back) tmp = st + pat[i];\n      else tmp = pat[i] + st;\n      dump(tmp);\n      cin >> res;\n      if(res == \"end\") return 0;\n      if(res == \"T\"){\n        st = tmp;\n        flg = true;\n        break;\n      }\n    }\n    if(!flg){\n      back = false;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid output(const deque<int>& dq) {\n  for (int i = 0; i < dq.size(); ++i) {\n    cout << \".#\"[dq[i] / 2];\n  }\n  cout << endl;\n  for (int i = 0; i < dq.size(); ++i) {\n    cout << \".#\"[dq[i] % 2];\n  }\n  cout << endl;\n}\n\nbool read() {\n  string s; cin >> s;\n  if (s == \"end\") exit(0);\n  return s == \"T\";\n}\n\nint main() {\n  int N; cin >> N;\n  deque<int> dq;\n  bool test = false;\n  do {\n    test = false;\n    for (int i = 0; i < 4; ++i) {\n      dq.push_back(i);\n      output(dq);\n      if (read()) {\n        test = true;\n        break;\n      }\n      else dq.pop_back();\n    }\n  } while (test);\n  do {\n    test = false;\n    for (int i = 0; i < 4; ++i) {\n      dq.push_front(i);\n      output(dq);\n      if (read()) {\n        test = true;\n        break;\n      }\n      else dq.pop_front();\n    }\n  } while (test);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\nint query(const string s[2]) {\n\tputs(s[0].c_str());\n\tputs(s[1].c_str());\n\tfflush(stdout);\n\tchar q[4];\n\tscanf(\"%s\", q);\n\tif(*q == 'e') exit(0);\n\treturn *q == 'T' ? 1 : 0;\n}\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tstring s[2];\n\t\twhile(1) {\n\t\t\trep(k, 2) s[k] += '?';\n\t\t\tbool ok = false;\n\t\t\trep(p, 1 << 2) {\n\t\t\t\trep(k, 2) s[k].back() = \".#\"[p >> k & 1];\n\t\t\t\tif(query(s) == 1) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) {\n\t\t\t\trep(k, 2)\n\t\t\t\t\ts[k].pop_back();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(1) {\n\t\t\trep(k, 2) s[k] = '?' + s[k];\n\t\t\tbool ok = false;\n\t\t\trep(p, 1 << 2) {\n\t\t\t\trep(k, 2) s[k][0] = \".#\"[p >> k & 1];\n\t\t\t\tif(query(s) == 1) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(ok);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define SIZE 200005\n\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\nll MOD = 924844033;\n\nchar a[4]={'.','.','#','#'};\nchar b[4]={'.','#','.','#'};\nint main(){\n\tint n;\n\tcin>>n;\n\tstring s1,s2;\n\tchar ch;\n\tbool bigfl=false;\n\tint sz=0;\n\tstring str;\n\twhile(sz<=n){\n\t\tbool flag=false;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tstring hoge,fuga;\n\t\t\thoge=s1+a[i];\n\t\t\tfuga=s2+b[i];\n\t\t\tcout<<hoge<<\"\\n\"<<fuga<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>str;\n\t\t\tch=str[0];\n\t\t\tif(ch=='e')goto HOGE;\n\t\t\tif(ch=='T'&&!flag){\n\t\t\t\tsz++;\n\t\t\t\tflag=true;\n\t\t\t\ts1=hoge;\n\t\t\t\ts2=fuga;\n\t\t\t\tgoto A;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tbreak;\n\t\t}\n\t  A:;\n\t}\n\twhile(sz<=n){\n\t\tbool flag=false;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tstring hoge,fuga;\n\t\t\thoge=a[i]+s1;\n\t\t\tfuga=b[i]+s2;\n\t\t\tcout<<hoge<<\"\\n\"<<fuga<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>str;\n\t\t\tch=str[0];\n\t\t\tif(ch=='e')goto HOGE;\n\t\t\tif(ch=='T'&&!flag){\n\t\t\t\tsz++;\n\t\t\t\tflag=true;\n\t\t\t\ts1=hoge;\n\t\t\t\ts2=fuga;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tbreak;\n\t\t}\n\t}\n  HOGE:;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N;\n\nint main(){\n\tcin >> N;\n\tlong long len = 0;\n\tbool right = true;\n\tlong long tmp = 0;\n\n\tstring s0 = \"\";\n\tstring s1 = \"\";\n\n\twhile(1){\n\t\tif(tmp == 0){\n\t\t\tif(right){\n\t\t\t\tcout << s0 << \".\" << endl;\n\t\t\t\tcout << s1 << \".\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \".\" << s0 << endl;\n\t\t\t\tcout << \".\" << s1 << endl;\n\t\t\t}\n\t\t}else if(tmp == 1){\n\t\t\tif(right){\n\t\t\t\tcout << s0 << \"#\" << endl;\n\t\t\t\tcout << s1 << \".\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"#\" << s0 << endl;\n\t\t\t\tcout << \".\" << s1 << endl;\n\t\t\t}\n\t\t}else if(tmp == 2){\n\t\t\tif(right){\n\t\t\t\tcout << s0 << \".\" << endl;\n\t\t\t\tcout << s1 << \"#\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \".\" << s0 << endl;\n\t\t\t\tcout << \"#\" << s1 << endl;\n\t\t\t}\n\t\t}else if(tmp == 3){\n\t\t\tif(right){\n\t\t\t\tcout << s0 << \"#\" << endl;\n\t\t\t\tcout << s1 << \"#\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"#\" << s0 << endl;\n\t\t\t\tcout << \"#\" << s1 << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tright = false;\n\t\t\tcontinue;\n\t\t}\n\t\tstring S;\n\t\tcin >> S;\n\t\tif(S == \"F\"){\n\t\t\ttmp++;\n\t\t}else if(S == \"end\"){\n\t\t\tbreak;\n\t\t}else{\n\t\t\tif(tmp == 0){\n\t\t\t\tif(right){\n\t\t\t\t\ts0 += \".\";\n\t\t\t\t\ts1 += \".\";\n\t\t\t\t}else{\n\t\t\t\t\ts0 = \".\" + s0;\n\t\t\t\t\ts1 = \".\" + s1;\n\t\t\t\t}\n\t\t\t}else if(tmp == 1){\n\t\t\t\tif(right){\n\t\t\t\t\ts0 += \"#\";\n\t\t\t\t\ts1 += \".\";\n\t\t\t\t}else{\n\t\t\t\t\ts0 = \"#\" + s0;\n\t\t\t\t\ts1 = \".\" + s1;\n\t\t\t\t}\n\t\t\t}else if(tmp == 2){\n\t\t\t\tif(right){\n\t\t\t\t\ts0 += \".\";\n\t\t\t\t\ts1 += \"#\";\n\t\t\t\t}else{\n\t\t\t\t\ts0 = \".\" + s0;\n\t\t\t\t\ts1 = \"#\" + s1;\n\t\t\t\t}\n\t\t\t}else if(tmp == 3){\n\t\t\t\tif(right){\n\t\t\t\t\ts0 += \"#\";\n\t\t\t\t\ts1 += \"#\";\n\t\t\t\t}else{\n\t\t\t\t\ts0 = \"#\" + s0;\n\t\t\t\t\ts1 = \"#\" + s1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = 0;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tdeque<char> aBener,bBener;\n\tint t = 1;\n\t\n\tchar atas[4] = {'.','#','.','#'};\n\t char bwh[4] = {'.','.','#','#'};\n\tstring s;\n\tint idx = 0,ct = 0;\n\tdo{\n\t\tct++;\n\t\tif(s == \"end\") break;\n\t\tif(s == \"F\") idx++;\n\t\tif(s == \"T\" ) {\n\t\t\tif(idx <= 3){\n\t\t\t\taBener.push_back(atas[idx]);\n\t\t\t\tbBener.push_back(bwh[idx]);\t\n\t\t\t}else{\n\t\t\t\taBener.push_front(atas[idx-4]);\n\t\t\t\tbBener.push_front(bwh[idx-4]);\n\t\t\t}\n\t\t\tidx = 0;\n\t\t}\n\t\tif(idx >3){\n\t\t\t//maka coba masukin di blkgnya\n\t\t\tint tidx = idx-4;\n\t\t\tprintf(\"%c\",atas[tidx]);\n\t\t\tfor(int i = 0;i<aBener.size();i++){\n\t\t\t\tprintf(\"%c\",aBener[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%c\",bwh[tidx]);\n\t\t\tfor(int i = 0;i<bBener.size();i++){\n\t\t\t\tprintf(\"%c\",bBener[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0;i<aBener.size();i++){\n\t\t\tprintf(\"%c\",aBener[i]);\n\t\t}\n\t\t\n\t\t//coba\n\t\tprintf(\"%c\",atas[idx]);\n\t\tprintf(\"\\n\");\n\t\tfor(int i = 0;i<bBener.size();i++){\n\t\t\tprintf(\"%c\",bBener[i]);\n\t\t}\n\t\tprintf(\"%c\",bwh[idx]);\n\t\tprintf(\"\\n\");\n\t}while(cin>>s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nchar up[]={'.','#','.','#'}, down[]={'.','#','#','.'};\nstring judge, nowup, nowdown;\n\nint main()\n{\n    cin >> n;\n    while(true) {\n        bool start = false;\n        for(int i=0; i<4; i++) {\n            if(start) continue;\n            cout << nowup+up[i] << endl << nowdown+down[i] << endl;\n            cin >> judge;\n            if(judge==\"T\") {\n                nowup+=up[i];\n                nowdown+=down[i];\n                start = true;\n            }\n            else if(judge==\"F\") continue;\n            else return 0;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tchar in_buffer[10] = {};\n\t\n\tdeque<char> atas;\n\tdeque<char> bawah;\n\t\n\tdeque<char> printatas;\n\tdeque<char> printbawah;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas.push_front('.');\n\t\tbawah.push_front('.');\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas.pop_front();\n\t\t\tbawah.pop_front();\n\t\t\tatas.push_front(tempatas[j]);\n\t\t\tbawah.push_front(tempbawah[j]);\n\t\t\t\n\t\t\tprintatas = atas;\n\t\t\tprintbawah = bawah;\n\t\t\t\n\t\t\twhile(!printatas.empty()) {\n\t\t\t\tprintf(\"%c\", printatas.front());\n\t\t\t\tprintatas.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\twhile(!printbawah.empty()) {\n\t\t\t\tprintf(\"%c\", printbawah.front());\n\t\t\t\tprintbawah.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tfflush(stdin);\n\t\t\t\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tatas.pop_front();\n\tbawah.pop_front();\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas.push_back('.');\n\t\tbawah.push_back('.');\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas.pop_back();\n\t\t\tbawah.pop_back();\n\t\t\tatas.push_back(tempatas[j]);\n\t\t\tbawah.push_back(tempbawah[j]);\n\t\t\t\n\t\t\tprintatas = atas;\n\t\t\tprintbawah = bawah;\n\t\t\t\n\t\t\twhile(!printatas.empty()) {\n\t\t\t\tprintf(\"%c\", printatas.front());\n\t\t\t\tprintatas.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\twhile(!printbawah.empty()) {\n\t\t\t\tprintf(\"%c\", printbawah.front());\n\t\t\t\tprintbawah.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t\n\t\t\tfflush(stdin);\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tvector<char> aBener,bBener;\n\tint t = 1;\n\t\n\tchar atas[4] = {'.','#','.','#'};\n\t char bwh[4] = {'.','.','#','#'};\n\tstring s;\n\tint idx = 0,ct = 0;\n\tdo{\n\t\tct++;\n\t\tif(s == \"end\") break;\n\t\tif(s == \"F\") idx++;\n\t\tif(s == \"T\") {\n\t\t\taBener.push_back(atas[idx]);\n\t\t\tbBener.push_back(bwh[idx]);\n\t\t\tidx = 0;\n\t\t}\n\t\tfor(int i = 0;i<aBener.size();i++){\n\t\t\tprintf(\"%c\",aBener[i]);\n\t\t}\n\t\t//coba\n\t\tprintf(\"%c\",atas[idx]);\n\t\tprintf(\"\\n\");\n\t\tfor(int i = 0;i<bBener.size();i++){\n\t\t\tprintf(\"%c\",bBener[i]);\n\t\t}\n\t\tprintf(\"%c\",bwh[idx]);\n\t\tprintf(\"\\n\");\n\t}while(cin>>s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst string u = \"#.\";\n\nint N;\nstring s[2];\n\nint main() {\n\tscanf(\"%d\", &N);\n\n\tbool flg = 1;\n\n\trep(i, N) {\n\t\tbool fd = 0;\n\t\trep(j, 4) {\n\t\t\tif (flg) {\n\t\t\t\ts[0].pb(u[j&1]);\n\t\t\t\ts[1].pb(u[(j/2)&1]);\n\n\t\t\t\tprintf(\"%s\\n%s\\n\", s[0].c_str(), s[1].c_str()); fflush(stdout);\n\t\t\t\tchar res[4];\n\t\t\t\tscanf(\"%s\", res);\n\n\t\t\t\tif (strcmp(res, \"end\") == 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tif (res[0] == 'T') {\n\t\t\t\t\tfd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\ts[0].pop_back();\n\t\t\t\t\ts[1].pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!fd) {\n\t\t\tflg = 0;\n\t\t\trep(j, 4) {\n\t\t\t\tstring t[2];\n\t\t\t\tt[0] = s[0], t[1] = s[1];\n\t\t\t\tt[0].insert(t[0].begin(), u[j&1]);\n\t\t\t\tt[1].insert(t[1].begin(), u[(j/2)&1]);\n\t\t\t\tprintf(\"%s\\n%s\\n\", t[0].c_str(), t[1].c_str()); fflush(stdout);\n\t\t\t\tchar res[4];\n\t\t\t\tscanf(\"%s\", res);\n\n\t\t\t\tif (strcmp(res, \"end\") == 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tif (res[0] == 'T') {\n\t\t\t\t\ts[0] = t[0];\n\t\t\t\t\ts[1] = t[1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n/** Header .. **/ //{\n#define LOCAL\n\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n#define REP_1(i, n) for (int i=1;i<=int(n);++i)\n#define FOR_1(i, a, b) for (int i=int(a);i<=int(b);++i)\n#define DWN_1(i, b, a) for (int i=int(b);i>=int(a);--i)\n#define REP_C(i, n) for (int n____=int(n),i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=int(b),i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<int(n);++i)\n#define FOR_N(i, a, b) for (i=int(a);i<int(b);++i)\n#define DWN_N(i, b, a) for (i=int(b-1);i>=int(a);--i)\n#define REP_1_C(i, n) for (int n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=int(n);++i)\n#define FOR_1_N(i, a, b) for (i=int(a);i<=int(b);++i)\n#define DWN_1_N(i, b, a) for (i=int(b);i>=int(a);--i)\n#define REP_C_N(i, n) for (int n____=(i=0,int(n));i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,int(b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,int(a));i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,int(n));i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=1,int(b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,int(a));i>=a____;--i)\n\n#define ECH(it, A) for (__typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, nxt) for (int i=hd;i;i=nxt[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define DO(n) for ( int ____n ## __line__ = n; ____n ## __line__ -- ; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define BSC(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int(A.size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define fi first\n#define se second\n\n#define Rush for(int ____T=RD(); ____T--;)\n\n#define Display(A, n, m) {                      \\\n\tREP(i, n){\t\t                            \\\n        REP(j, m) cout << A[i][j] << \" \";       \\\n        cout << endl;\t\t\t\t            \\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#define Display_1(A, n, m) {\t\t\t\t    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m) cout << A[i][j] << \" \";     \\\n\t\tcout << endl;\t\t            \t\t\\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define Ruby system(\"ruby main.rb\")\n#define Haskell system(\"runghc main.hs\")\n#define Python system(\"python main.py\")\n#define Pascal system(\"fpc main.pas\")\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned UINT;\ntypedef unsigned long long ULL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &x){\n    char c; for (c = getchar(); c < '-'; c = getchar());\n    if (c == '-'){x = '0' - getchar(); for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + '0' - c;}\n    else {x = c - '0'; for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + c - '0';}\n    return x;\n}\n\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline void RDD(const T0&a, const T1&b){RDD(a),RDD(b);}\ntemplate<class T0,class T1,class T2>inline void RDD(const T0&a, const T1&b, const T2&c){RDD(a),RDD(b),RDD(c);}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& UNQ(T &A){A.resize(unique(ALL(SRT(A)))-A.begin());return A;}\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\n\nconst int dx8[] = {-1, 0, 1, 0 , -1 , -1 , 1 , 1};\nconst int dy8[] = {0, 1, 0, -1 , -1 , 1 , -1 , 1};\n\nconst int dxhorse[] = {-2 , -2 , -1 , -1 , 1 , 1 , 2 , 2};\nconst int dyhorse[] = {1 ,  -1 , 2  , -2 , 2 ,-2 , 1 ,-1};\n\nconst int MOD = 1000000007;\n//int MOD = 99990001;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 1LL << 60;\nconst DB EPS = 1e-9;\nconst DB OO = 1e15;\nconst DB PI = acos(-1.0); //M_PI;\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\ntemplate<class T> inline void checkMin(T &a,const T b){if (b<a) a=b;}\ntemplate<class T> inline void checkMax(T &a,const T b){if (a<b) a=b;}\ntemplate<class T> inline void checkMin(T &a, T &b, const T x){checkMin(a, x), checkMin(b, x);}\ntemplate<class T> inline void checkMax(T &a, T &b, const T x){checkMax(a, x), checkMax(b, x);}\ntemplate <class T, class C> inline void checkMin(T& a, const T b, C c){if (c(b,a)) a = b;}\ntemplate <class T, class C> inline void checkMax(T& a, const T b, C c){if (c(a,b)) a = b;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ninline int ceil(int x, int y){return (x - 1) / y + 1;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n\ninline bool _1(int x, int i){return bool(x&1<<i);}\ninline bool _1(LL x, int i){return bool(x&1LL<<i);}\ninline LL _1(int i){return 1LL<<i;}\ninline LL _U(int i){return _1(i) - 1;};\n\ninline int reverse_bits(int x){\n    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n    x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n    return x;\n}\n\ninline LL reverse_bits(LL x){\n    x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n    x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n    x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n    x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n    x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n    x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n    return x;\n}\n\ntemplate<class T> inline bool odd(T x){return x&1;}\ntemplate<class T> inline bool even(T x){return !odd(x);}\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\ntemplate<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\ntemplate<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n\ninline int low_idx(int x){return __builtin_ffs(x);}\ninline int low_idx(LL x){return __builtin_ffsll(x);}\ninline int high_idx(int x){return low_idx(reverse_bits(x));}\ninline int high_idx(LL x){return low_idx(reverse_bits(x));}\ninline int clz(int x){return __builtin_clz(x);}\ninline int clz(LL x){return __builtin_clzll(x);}\ninline int ctz(int x){return __builtin_ctz(x);}\ninline int ctz(LL x){return __builtin_ctzll(x);}\ninline int parity(int x){return __builtin_parity(x);}\ninline int parity(LL x){return __builtin_parityll(x);}\ninline int lg2(int a){return 31 - clz(a);}\ninline int lg2(LL a){return 63 - clz(a);}\ninline int count_bits(int x){return __builtin_popcount(x);}\ninline int count_bits(LL x){return __builtin_popcountll(x);}\n\n} using namespace BO;//}\n// <<= '2. Number Theory .,//{\nnamespace NT{\ninline LL __lcm(LL a, LL b){return a*b/__gcd(a,b);}\ninline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\ninline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\ninline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\ninline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\ninline void MUL(int &a, int b){a = (LL)a * b % MOD;}\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\n\ninline int sum(int a, int b, int c){return sum(sum(a, b), c);}\ninline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\ninline int pdt(int a, int b, int c){return pdt(pdt(a, b), c);}\ninline int pdt(int a, int b, int c, int d){return pdt(pdt(pdt(a, b), c), d);}\n\ninline int pow(int a, int b){\n    int c(1); while (b){\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ninline int pow(int a, LL b){\n    int c(1); while (b){\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ntemplate<class T> inline T pow(T a, LL b){\n    T c(1); while (b){\n        if (b&1) c *= a;\n        a *= a, b >>= 1;\n    }\n    return c;\n}\n\ninline int _I(int b){\n    int a = MOD, x1 = 0, x2 = 1, q;\n    while (true){\n        q = a / b, a %= b;\n        if (!a) return (x2 + MOD) % MOD;\n        DEC(x1, pdt(q, x2));\n\n        q = b / a, b %= a;\n        if (!b) return (x1 + MOD) % MOD;\n        DEC(x2, pdt(q, x1));\n    }\n}\n\ninline void DIV(int &a, int b){MUL(a, _I(b));}\ninline int qtt(int a, int b){return pdt(a, _I(b));}\n\ninline int phi(int n){\n    int res = n; for (int i=2;sqr(i)<=n;++i) if (!(n%i)){\n        DEC(res, qtt(res, i));\n        do{n /= i;} while(!(n%i));\n    }\n    if (n != 1)\n        DEC(res, qtt(res, n));\n    return res;\n}\n\n} using namespace NT;//}\n//}\n\n/** Miscellaneous .. **/ //{\n// <<= 'Random Event .. . //{\nnamespace RNG{\n//srand((unsigned)time(NULL));\ninline unsigned int rand16(){return ((rand()) << 15) ^ rand();}\ninline unsigned int rand32(){return (rand16() << 16) | rand16();}\ninline ULL rand64(){return ((LL)rand32() << 32) | rand32();}\ninline ULL random(LL l, LL r){return l == r ? l : rand64() % (r - l) + l;}\nint dice(){return rand() % 6;}\nbool coin(){return bool(rand() % 2);}\n} using namespace RNG;\n//}\n// <<= 'Clock .. . //{\nnamespace CLOCK{\nDB s0, s1, rd, k, T;\ninline DB getTime(){\n#ifdef LOCAL\n    return 1.0 * clock() / CLOCKS_PER_SEC;\n#else\n    timeval tv;\n    gettimeofday(&tv, 0);\n    return tv.tv_sec + tv.tv_usec * 1e-6;\n#endif\n}\n\ninline void st0(DB _T = 0.98){T = _T, s0 = getTime();}\ninline void st1(DB _k = 1.618){k = _k, s1 = getTime();}\ninline void ed1(){rd = getTime() - s1;}\ninline DB elapsed(){return getTime() - s0;}\ninline bool safe(){return elapsed() + rd * k < T;}\n} //using namespace CLOCK;\n//}\n// <<= 'Temp .. . //{\nnamespace TMP{\ntemplate<class T> PTT operator+(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi + p2.fi, p1.se + p2.se);\n}\n\ntemplate<class T> PTT operator-(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi - p2.fi, p1.se - p2.se);\n}\n\ntemplate<class T> PTT operator*(const PTT &lhs, T k){\n    return PTT(lhs.fi * k, lhs.se * k);\n}\n} using namespace TMP;\n//}\n//}\n\n/** Algorithm    .. */ //{\n// <<= '-. Math .,//{\nnamespace Math{\n\ttypedef long long typec;\n\t///Lib functions\n\ttypec GCD(typec a, typec b)\n\t{\n\t\treturn b ? GCD(b, a % b) : a;\n\t}\n\ttypec extendGCD(typec a, typec b, typec& x, typec& y)\n\t{\n\t\tif(!b) return x = 1, y = 0, a;\n\t\ttypec res = extendGCD(b, a % b, x, y), tmp = x;\n\t\tx = y, y = tmp - (a / b) * y;\n\t\treturn res;\n\t}\n\t///for x^k\n\ttypec power(typec x, typec k)\n\t{\n\t\ttypec res = 1;\n\t\twhile(k)\n\t\t{\n\t\t\tif(k&1) res *= x;\n\t\t\tx *= x, k >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t///for x^k mod m\n\ttypec powerMod(typec x, typec k, typec m)\n\t{\n\t\ttypec res = 1;\n\t\twhile(x %= m, k)\n\t\t{\n\t\t\tif(k&1) res *= x, res %= m;\n\t\t\tx *= x, k >>=1;\n\t\t}\n\t\treturn res;\n\t}\n\t/***************************************\n\tInverse in mod p^t system\n\t***************************************/\n\ttypec inverse(typec a, typec p, typec t = 1)\n\t{\n\t\ttypec pt = power(p, t);\n\t\ttypec x, y;\n\t    y = extendGCD(a, pt, x, y);\n\t\treturn x < 0 ? x += pt : x;\n\t}\n\t/***************************************\n\tLinear congruence theorem\n\tx = a (mod p)\n\tx = b (mod q)\n\tfor gcd(p, q) = 1, 0 <= x < pq\n\t***************************************/\n\ttypec linearCongruence(typec a, typec b, typec p, typec q)\n\t{\n\t\ttypec x, y;\n\t\ty = extendGCD(p, q, x, y);\n\t\twhile(b < a) b += q / y;\n\t\tx *= b - a, x = p * x + a, x %= p * q;\n\t\tif(x < 0) x += p * q;\n\t\treturn x;\n\t}\n\t/***************************************\n\tprime table\n\tO(n)\n\t***************************************/\n\tconst int PRIMERANGE = 1000000;\n\tint prime[PRIMERANGE + 1];\n\tint getPrime()\n\t{\n\t\tmemset (prime, 0, sizeof (int) * (PRIMERANGE + 1));\n\t\tfor (int i = 2; i <= PRIMERANGE; i++)\n\t\t{\n\t\t\tif (!prime[i]) prime[++prime[0]] = i;\n\t\t\tfor (int j = 1; j <= prime[0] && prime[j] <= PRIMERANGE / i; j++)\n\t\t\t{\n\t\t\t\tprime[prime[j]*i] = 1;\n\t\t\t\tif (i % prime[j] == 0) break;\n\t\t\t}\n\t\t}\n\t\treturn prime[0];\n\t}\n\t/***************************************\n\tget factor of n\n\tO(sqrt(n))\n\tfactor[][0] is prime factor\n\tfactor[][1] is factor generated by this prime\n\tfactor[][2] is factor counter\n\n\tneed: Prime Table\n\t***************************************/\n\t///you should init the prime table before\n\tint factor[100][3], facCnt;\n\tint getFactors(int x)\n\t{\n\t\tfacCnt = 0;\n\t\tint tmp = x;\n\t\tfor(int i = 1; prime[i] <= tmp / prime[i]; i++)\n\t\t{\n\t\t\tfactor[facCnt][1] = 1, factor[facCnt][2] = 0;\n\t\t\tif(tmp % prime[i] == 0)\n\t\t\t\tfactor[facCnt][0] = prime[i];\n\t\t\twhile(tmp % prime[i] == 0)\n\t\t\t\tfactor[facCnt][2]++, factor[facCnt][1] *= prime[i], tmp /= prime[i];\n\t\t\tif(factor[facCnt][1] > 1) facCnt++;\n\t\t}\n\t\tif(tmp != 1)\n\t\t\tfactor[facCnt][0] = tmp, factor[facCnt][1] = tmp, factor[facCnt++][2] = 1;\n\t\treturn facCnt;\n\t}\n\ttypec combinationModP(typec n, typec k, typec p)\n\t{\n\t\tif(k > n) return 0;\n\t\tif(n - k < k) k = n - k;\n\t\ttypec a = 1, b = 1, x, y;\n\t\tint pcnt = 0;\n\t\tfor(int i = 1; i <= k; i++)\n\t\t{\n\t\t\tx = n - i + 1, y = i;\n\t\t\twhile(x % p == 0) x /= p, pcnt++;\n\t\t\twhile(y % p == 0) y /= p, pcnt--;\n\t\t\tx %= p, y %= p, a *= x, b *= y;\n\t\t\tb %= p, a %= p;\n\t\t}\n\t\tif(pcnt) return 0;\n\t\textendGCD(b, p, x, y);\n\t\tif(x < 0) x += p;\n\t\ta *= x, a %= p;\n\t\treturn a;\n\t}\n};//using namespace Math;\n//}\n// <<= '-. Geo ,.//{\nnamespace Geo{\n\t#define typec double\n    const typec eps=1e-8;\n    int dblcmp(double d){\n        return d < -eps ? -1 : d > eps;\n    }\n    int sgn(double a) {return a<-eps?-1:a>eps;}\n    inline double sqr(double x){return x*x;}\n    struct Point2D{\n\t\ttypec x,y;\n\t\tPoint2D(){}\n\t\tPoint2D(typec _x,typec _y):x(_x),y(_y){};\n\t\tvoid input(){\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t}\n\t\tvoid output(){\n\t\t\tprintf(\"%.2f %.2f\\n\",x,y);\n\t\t}\n\t\tbool operator==(Point2D a)const{\n\t\t\treturn dblcmp(a.x-x)==0&&dblcmp(a.y-y)==0;\n\t\t}\n\t\tbool operator<(Point2D a)const{\n\t\t\treturn dblcmp(a.x-x)==0?dblcmp(y-a.y)<0:x<a.x;\n\t\t}\n\t\ttypec len(){\n\t\t\treturn hypot(x,y);\n\t\t}\n\t\ttypec len2(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tPoint2D operator + (const Point2D &A) const{\n\t\t\treturn Point2D(x + A.x , y + A.y);\n\t\t}\n\t\tPoint2D operator - (const Point2D &A) const{\n\t\t\treturn Point2D(x - A.x , y - A.y);\n\t\t}\n\t\tPoint2D operator * (const typec _x) const{\n\t\t\treturn Point2D(x * _x , y * _x);\n\t\t}\n\t\ttypec operator * (const Point2D &A) const{\n\t\t\treturn x * A.x + y * A.y;\n\t\t}\n\t\ttypec operator ^ (const Point2D &A) const{\n\t\t\treturn x * A.y - y * A.x;\n\t\t}\n\t\tPoint2D operator / (const typec _p) const{\n\t\t\treturn Point2D(x / _p , y / _p);\n\t\t}\n\t\ttypec distance(Point2D p){\n\t\t\treturn hypot(x-p.x,y-p.y);\n\t\t}\n\t\tPoint2D add(Point2D p){\n\t\t\treturn Point2D(x+p.x,y+p.y);\n\t\t}\n\t\tPoint2D sub(Point2D p){\n\t\t\treturn Point2D(x-p.x,y-p.y);\n\t\t}\n\t\tPoint2D mul(typec b){\n\t\t\treturn Point2D(x*b,y*b);\n\t\t}\n\t\tPoint2D div(typec b){\n\t\t\treturn Point2D(x/b,y/b);\n\t\t}\n\t\ttypec dot(Point2D p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\ttypec det(Point2D p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\ttypec rad(Point2D a,Point2D b){\n\t\t\tPoint2D p=*this;\n\t\t\treturn fabs(atan2(fabs(a.sub(p).det(b.sub(p))),a.sub(p).dot(b.sub(p))));\n\t\t}\n\t\tPoint2D trunc(typec r){\n\t\t\ttypec l=len();\n\t\t\tif (!dblcmp(l))return *this;\n\t\t\tr/=l;\n\t\t\treturn Point2D(x*r,y*r);\n\t\t}\n\t\tPoint2D rotleft(){\n\t\t\treturn Point2D(-y,x);\n\t\t}\n\t\tPoint2D rotright(){\n\t\t\treturn Point2D(y,-x);\n\t\t}\n\t\tPoint2D rotate(Point2D p,typec angle)//�Ƶ�p��ʱ����תangle�Ƕ�\n\t\t{\n\t\t\tPoint2D v=this->sub(p);\n\t\t\ttypec c=cos(angle),s=sin(angle);\n\t\t\treturn Point2D(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n\t\t}\n\t};\n\n\ttypec cross(Point2D a,Point2D b,Point2D c){\n\t\treturn (b.sub(a)).det(c.sub(a));\n\t}\n}using namespace Geo;\n//}\n//}\n\n/** I/O Accelerator Interface .. **/ //{\ntemplate<class T> inline T& RD(T &x){\n    //cin >> x;\n    //scanf(\"%d\", &x);\n    char c; for (c = getchar(); c < '-'; c = getchar());\n    if (c == '-'){x = '0' - getchar(); for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + '0' - c;}\n    else {x = c - '0'; for (c = getchar(); '0' <= c && c <= '9'; c = getchar()) x = x * 10 + c - '0';}\n    return x;\n}\n\ninline DB& RF(DB &x){\n    //cin >> x;\n    scanf(\"%lf\", &x);\n    /*char t; while ((t=getchar())==' '||t=='\\n'); x = t - '0';\n    while ((t=getchar())!=' '&&t!='\\n'&&t!='.')x*=10,x+=t-'0';\n    if (t=='.'){DB l=1; while ((t=getchar())!=' '&&t!='\\n')l*=0.1,x += (t-'0')*l;}*/\n    return x;\n}\n\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nint Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case %d: %d\\n\", ++Case, x);\n    //printf(\"%.2lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n}\n//}\n\n/* .................................................................................................................................. */\nint test(string A , string B){\n    printf(\"%s\\n%s\\n\" , A.c_str() , B.c_str());\n    fflush(stdout);\n    static char op[5];\n    RS(op);\n    if (op[0] == 'T') return 1;\n    if (op[0] == 'F') return 0;\n    return 2;\n}\nstring C = \".#\";\nint main(){\n    int n;\n    RD(n);\n    string ans[2];\n    ans[0] = \"\";\n    ans[1] = \"\";\n    bool f = true;\n    for (int i = 0 ; i < n ; ++i){\n        bool ok = false;\n        for (int j = 0 ; j < 2 && !ok; ++j)\n        for (int k = 0 ; k < 2 && !ok; ++k){\n            if (f){\n                int res = test(ans[0] + C[j] , ans[1] + C[k]);\n                if (res == 2) return 0;\n                if (res == 1){\n                    ans[0] += C[j];\n                    ans[1] += C[k];\n                    ok = true;\n                }\n            }\n            else{\n                int res = test(C[j] + ans[0] , C[k] + ans[1]);\n                if (res == 2) return 0;\n                if (res == 1){\n                    ans[0] = C[j] + ans[0];\n                    ans[1] = C[k] + ans[1];\n                    ok = true;\n                }\n            }\n        }\n        if (!ok){\n            --i;\n            f = false;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <deque>\n\nusing namespace std;\ntypedef long long int ll;\n\n#define rep(x, a, b) for (int x = a; x < b; x++)\n\nbool query(const deque<int> &pohe) {\n  for (auto a : pohe)\n    cout << ((a & 1) ? '#' : '.');\n  cout << endl;\n  for (auto a : pohe)\n    cout << ((a & 2) ? '#' : '.');\n  cout << endl;\n\n  string str;\n  cin >> str;\n  \n  return str == \"T\";\n}\n\nint main()\n{\n  int n;\n\n  cin >> n;\n\n  deque<int> pohe;\n\n  rep(i, 0, 4) {\n    pohe.push_back(i);\n    if (query(pohe))\n      break;\n    pohe.pop_back();\n  }\n\n  bool top = false, bot = false;\n\n retry:\n  while (pohe.size() < (size_t)n) {\n    if (!top) {\n      rep(i, 0, 4) {\n        pohe.push_back(i);\n        if (query(pohe)) {\n          goto retry;\n        }\n        pohe.pop_back();\n      }\n      top = true;\n    }\n\n    if (!bot) {\n      rep(i, 0, 4) {\n        pohe.push_front(i);\n        if (query(pohe)) {\n          goto retry;\n        }\n        pohe.pop_front();\n      }\n      bot = false;\n    }\n  }\n\n  string end;\n  cin >> end;\n  (void) end;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tstring atas = \"\";\n\tstring bawah = \"\";\n\t\n\tchar in_buffer[10] = {};\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas = '.' + atas;\n\t\tbawah = '.' + bawah;\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[0] = tempatas[j];\n\t\t\tbawah[0] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint len = atas.length();\n\tfor(len++; len <= n; len++) {\n\t\tatas = atas + '.';\n\t\tbawah = bawah + '.';\n\t\t\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[len-1] = tempatas[j];\n\t\t\tbawah[len-1] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n\nstring query(pair<string,string> p1,pair<string,string> p2){\n  string s1,s2;\n  s1 = p1.first + p2.first;\n  s2 = p1.second + p2.second;\n  printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n  string str;\n  cin >> str;\n  return str;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  set<pair<string,string> >st;\n  for(int i = 0 ; i < 2 ; i++){\n    string str1;\n    string str2;\n    for(int j = 0 ; j < 4 ; j++){\n      str1 += (j%2?\".\":\"#\");\n      str2 += ((j >> 1)%2?\".\":\"#\");\n    }\n    st.insert(make_pair(str1,str2));\n  }\n  \n  while(1){\n    vector<pair<string,string> >vec(st.begin(),st.end());\n    for(int i = 0 ; i < vec.size() ; i++){\n      for(int j = i ; j < vec.size() ; j++){\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  string r;\n\t  pair<string,string>p;\n\t  if(k % 2){\n\t    r = query(vec[i],vec[j]);\n\t    p = make_pair(vec[i].first + vec[j].first,vec[i].second + vec[j].second);\n\t  }\n\t  else {\n\t    r = query(vec[j],vec[i]);\n\t    p = make_pair(vec[j].first + vec[i].first,vec[j].second + vec[i].second);\n\t  }\n\t  // in\n\t  if(r == \"T\"){\n\t    st.insert(p);\n\t  }\n\t  else if(r == \"end\"){\n\t    return 0;\n\t  }\n\t}\n      }\n    }\n  }\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint main(){\n\tsrand(time(NULL));\n\tint N;\n\tcin >> N;\n\tset<vector<string> > used;\n\n\tstring c[2];\n\twhile(true){\n\t\tvector<vector<string>> lst;\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] += (k>>0&1?\".\":\"#\");\n\t\t\tb[1] += (k>>1&1?\".\":\"#\");\n\t\t\tlst.push_back(b);\n\t\t}\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] = (k>>0&1?\".\":\"#\") + b[0];\n\t\t\tb[1] = (k>>1&1?\".\":\"#\") + b[1];\n\t\t\tlst.push_back(b);\n\t\t}\n\t\trandom_shuffle(lst.begin(),lst.end());\n\t\tfor(int i = 0 ; i < 8 ; i++){\n\t\t\tvector<string> b = lst[i];\n\t\t\tif( i == 7 ){\n\n\t\t\t\tc[0] = b[0];\n\t\t\t\tc[1] = b[1];\n\t\t\t\tif( c[0].size() == N ){\n\t\t\t\t\tcout << c[0] << endl;\n\t\t\t\t\tcout << c[1] << endl;\t\n\t\t\t\t\tstring res;\n\t\t\t\t\tcin >> res;\t\t\t\n\t\t\t\t\tassert(res==\"end\");\n\t\t\t\t\treturn 0;\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif( used.count(b) ) continue;\n\t\t\t\tused.insert(b);\n\t\t\t\tcout << b[0] << endl;\n\t\t\t\tcout << b[1] << endl;\n\t\t\t\tstring res;\n\t\t\t\tcin >> res;\n\t\t\t\tif( res == \"T\" ){\n\t\t\t\t\tc[0] = b[0];\n\t\t\t\t\tc[1] = b[1];\n\t\t\t\t\tbreak;\t \n\t\t\t\t}\n\t\t\t\tif( res == \"end\"){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint main(){\n\tsrand(time(NULL));\n\tint N;\n\tcin >> N;\n\tset<vector<string> > used;\n\n\tstring c[2];\n\twhile(true){\n\t\tvector<vector<string>> lst;\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] += (k>>0&1?\".\":\"#\");\n\t\t\tb[1] += (k>>1&1?\".\":\"#\");\n\t\t\tlst.push_back(b);\n\t\t}\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] = (k>>0&1?\".\":\"#\") + b[0];\n\t\t\tb[1] = (k>>1&1?\".\":\"#\") + b[1];\n\t\t\tlst.push_back(b);\n\t\t}\n\t\trandom_shuffle(lst.begin(),lst.end());\n\t\tfor(int i = 0 ; i < 8 ; i++){\n\t\t\tvector<string> b = lst[i];\n\t\t\tif( i == 7 ){\n\n\t\t\t\tc[0] = b[0];\n\t\t\t\tc[1] = b[1];\n\t\t\t\tif( c[0].size() == N ){\n\t\t\t\t\tcout << c[0] << endl;\n\t\t\t\t\tcout << c[1] << endl;\t\n\t\t\t\t\tstring res;\n\t\t\t\t\tcin >> res;\t\t\t\n\t\t\t\t\tassert(res==\"end\");\n\t\t\t\t\treturn 0;\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif( used.count(b) ) continue;\n\t\t\t\tused.insert(b);\n\t\t\t\tcout << b[0] << endl;\n\t\t\t\tcout << b[1] << endl;\n\t\t\t\tstring res;\n\t\t\t\tcin >> res;\n\t\t\t\tif( res == \"T\" ){\n\t\t\t\t\tc[0] = b[0];\n\t\t\t\t\tc[1] = b[1];\n\t\t\t\t\tbreak;\t \n\t\t\t\t}\n\t\t\t\tif( res == \"end\"){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) begin(a),end(a)\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX (int)1e6 + 5\n\nint N;\n\nsigned main() {\n\tcout << setprecision(20) << fixed;\n\tcin >> N;\n\tstring s1_ans, s2_ans;\n\tstring s1, s2;\n\tstring res;\n\tchar a[] = \".#\";\n\tsrand(time(NULL));\n\tint mode = 0;\n\twhile (1) {\n\t\twhile (1) rep(i, 2) rep(j, 2) {\n\t\t\tif (mode == 0) {\n\t\t\t\ts1 = s1_ans + a[i];\n\t\t\t\ts2 = s2_ans + a[j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts1 = a[i] + s1_ans;\n\t\t\t\ts2 = a[j] + s2_ans;\n\t\t\t}\n\t\t\tcout << s1 << endl;\n\t\t\tcout << s2 << endl;\n\t\t\tcin >> res;\n\t\t\tif (res == \"end\") return 0;\n\t\t\tif (res == \"T\") {\n\t\t\t\ts1_ans = s1;\n\t\t\t\ts2_ans = s2;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tmode++;\n\tnext:;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define base 1000000007LL\n#define ll long long\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define CLR(a) memset(a,0,sizeof(a))\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORE(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n\nusing namespace std;\n\ntypedef pair<ll, ll> II;\ntypedef vector<II> vi;\n\nint n;\nchar s1[110], s2[110];\nchar p[4] = {'.', '.', '#', '#'};\nchar q[4] = {'.', '#', '.', '#'};\nchar res[5];\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    //freopen(\"inp.txt\", \"r\", stdin);\n    scanf(\"%d\", &n);\n    s1[1] = s2[1] = '\\0';\n    FOR(i,0,3) {\n        s1[0] = p[i];\n        s2[0] = q[i];\n        printf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n        scanf(\"%s\", res);\n        if (strcmp(res, \"T\") == 0) break;\n        else if (strcmp(res, \"end\") == 0) return 0;\n    }\n    int remain = n-1;\n    while (remain) {\n        s1[n-remain+1] = s1[n-remain];\n        s2[n-remain+1] = s2[n-remain];\n        bool co = false;\n        FOR(i,0,3) {\n            s1[n-remain] = p[i];\n            s2[n-remain] = q[i];\n            printf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n            scanf(\"%s\", res);\n            if (strcmp(res, \"T\") == 0) {\n                co = true;\n                break;\n            }\n            else if (strcmp(res, \"end\") == 0) return 0;\n        }\n        if (co) remain--;\n        else break;\n    }\n    while (remain) {\n        FORE(i,n-remain+1,1) {\n            s1[i] = s1[i-1];\n            s2[i] = s2[i-1];\n        }\n        FOR(i,0,3) {\n            s1[n-remain] = p[i];\n            s2[n-remain] = q[i];\n            printf(\"%s\\n%s\\n\", s1, s2); fflush(stdout);\n            scanf(\"%s\", res);\n            if (strcmp(res, \"T\") == 0) break;\n            else if (strcmp(res, \"end\") == 0) return 0;\n        }\n        remain--;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint query(string s1,string s2){\n  cout << s1 << \"\\n\" << s2 << endl;\n  string a;cin>>a;\n  if(a==\"T\") return 0;\n  if(a==\"F\") return 1;\n  return -1;\n}\nint main(){\n  int n,i,j,k;cin>>n;\n  string s1,s2;\n  string a1[]={\".\",\".\",\"#\",\"#\"},a2[]={\".\",\"#\",\".\",\"#\"};\n  bool f;\n  while(1){\n    f=false;\n    for(i=0;i<4;i++){\n      k=query(s1+a1[i],s2+a2[i]);\n      if(k==-1) return 0;\n      if(k==0){\n\ts1+=a1[i];\n\ts2+=a2[i];\n\tf=true;\n\tbreak;\n      }\n    }\n    if(f) continue;\n    break;\n  }\n  while(1){\n    f=false;\n    for(i=0;i<4;i++){\n      k=query(a1[i]+s1,a2[i]+s2);\n      if(k==-1) return 0;\n      if(k==0){\n\ts1=a1[i]+s1;\n\ts2=a2[i]+s2;\n\tf=true;\n\tbreak;\n      }\n    }\n    if(f) continue;\n    break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nint n;\nvi v;\n\nbool test() {\n  string s , t;\n  for(auto e : v) {\n    s += char(\".#\"[e>>1]);\n    t += char(\".#\"[e&1]);\n  }\n  cout << s << endl;\n  cout << t << endl;\n  cin >> s;\n  if(s == \"end\")\n    exit(0);\n  return s[0] == 'T';\n}\n\nint main(){\n  cin >> n;\n  bool rev = false;\n  while(true) {\n    int i = 0;\n    for(;i < 4;++i) {\n      if(rev) v.insert(v.begin() , i);\n      else v.pb(i);\n      if(test()) break;\n      if(rev) v.erase(v.begin());\n      else v.pop_back();\n    }\n    if(i == 4) rev = true;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N;\nstring x, y;\nchar s[100];\n\nbool q (string a, string b) {\n        printf(\"%s\\n%s\\n\", a.c_str(), b.c_str()); fflush(stdout);\n        scanf(\" %s\", s);\n        if (s[0] == 'e') exit(0);\n        return s[0] == 'T';\n}\n\nint main () {\n        scanf(\"%d\", &N);\n        while (1) {\n                if ((int) x.size() == N) break;\n                bool ok = 0;\n                fo(i, 0, 4) {\n                        char c1 = '.', c2 = '.';\n                        if (i&1) c1 = '#';\n                        if (i&2) c2 = '#';\n                        if (q(x+c1, y+c2)) {\n                                ok = 1;\n                                x = x + c1;\n                                y = y + c2;\n                                break;\n                        }\n                }\n                if (!ok) break;\n        }\n        while (1) {\n                if ((int) x.size() == N) break;\n                bool ok = 0;\n                fo(i, 0, 4) {\n                        char c1 = '.', c2 = '.';\n                        if (i&1) c1 = '#';\n                        if (i&2) c2 = '#';\n                        if (q(c1+x, c2+y)) {\n                                ok = 1;\n                                x = c1 + x;\n                                y = c2 + y;\n                                break;\n                        }\n                }\n                if (!ok) break;\n        }\n        printf(\"%s\\n%s\\n\", x.c_str(), y.c_str()); fflush(stdout);\n        scanf(\" %s\", s);\n        assert(s[0] == 'e');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ここからテンプレート\n//#define PLASMA_NO_BOOST\n#if 1\n\n#include<iostream>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<type_traits>\n#include<tuple>\n#include<memory>\n#include<iterator>\n#include<string>\n#include<functional>\n#include<list>\n#include<array>\n#include<complex>\n#include<numeric>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<random>\n#include<map>\n#include<chrono>\n#include<stack>\n#include<set>\n\n#ifndef PLASMA_NO_BOOST\n#include<boost/optional.hpp>\n#include<boost/optional/optional_io.hpp>\n#include<boost/variant.hpp>\n#include<boost/range/adaptor/transformed.hpp>\n#include<boost/range/adaptor/indexed.hpp>\n#include<boost/range/adaptor/filtered.hpp>\n#include<boost/range/algorithm.hpp>\n#include<boost/range/irange.hpp>\n#include<boost/multi_array.hpp>\n#include<boost/preprocessor.hpp>\n#endif\n\ntypedef long long int int64;\ntypedef unsigned long long uint64;\ntypedef long double double64;\n\n#ifdef PLASMA_NO_BOOST\nstruct none_t {};\nconstexpr none_t none{};\ntemplate<class T>class optional\n{\n\tunion inside_t\n\t{\n\t\tT value;\n\t\tnone_t ignore;\n\t\tconstexpr inside_t(T const& v) :value(v) {}\n\t\tconstexpr inside_t(T&& v) : value(std::move(v)) {}\n\t\tconstexpr inside_t(none_t) : ignore(none) {}\n\t\tconstexpr inside_t() : ignore(none) {}\n\t\tconstexpr inside_t(inside_t const&) = default;\n\t\tinside_t(inside_t&&) = default;\n\t\tinside_t& operator=(inside_t const&) = default;\n\t\tinside_t& operator=(inside_t&&) = default;\n\t\t~inside_t() = default;\n\t};\n\tinside_t inside;\n\tbool flag;\npublic:\n\tvoid swap(optional&& v)\n\t{\n\t\tstd::swap(this->inside, v.inside);\n\t\tstd::swap(this->flag, v.flag);\n\t}\n\tvoid reset()\n\t{\n\t\tif (flag)\n\t\t{\n\t\t\tinside.value.~T();\n\t\t\tinside.ignore = none;\n\t\t\tflag = false;\n\t\t}\n\t}\n\n\tconstexpr optional(T const& v) :inside(v), flag(true) {}\n\tconstexpr optional(T&& v) : inside(std::move(v)), flag(true) {}\n\tconstexpr optional(none_t) : inside(), flag(false) {}\n\tconstexpr optional() : inside(), flag(false) {}\n\tconstexpr optional(optional const& v) : inside(v.inside), flag(v.flag) {}\n\toptional(optional&& v) : optional()\n\t{\n\t\tswap(std::move(v));\n\t}\n\toptional& operator=(optional const& v)\n\t{\n\t\tthis->inside = v.inside;\n\t\tthis->flag = v.flag;\n\t\treturn *this;\n\t}\n\toptional& operator=(optional&& v)\n\t{\n\t\tswap(std::move(v));\n\t\tv.reset();\n\t\treturn *this;\n\t}\n\toptional& operator=(T const& v)\n\t{\n\t\treset();\n\t\tinside.value = v;\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(T&& v)\n\t{\n\t\treset();\n\t\tinside.value = std::move(v);\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(none_t)\n\t{\n\t\treset();\n\t\treturn *this;\n\t}\n\n\tconstexpr operator bool()const\n\t{\n\t\treturn flag;\n\t}\n\tconstexpr T const& operator*()const\n\t{\n\t\treturn flag ? inside.value : throw std::domain_error(\"optional error: dont have value\");\n\t}\n};\ntemplate<class T>constexpr optional<typename std::remove_reference<typename std::remove_const<T>::type>::type>make_optional(T&& v)\n{\n\treturn optional<std::remove_reference_t<std::remove_const_t<T>>>(std::forward<T>(v));\n}\n#else\nusing boost::optional;\nusing boost::none_t;\nusing boost::none;\n#endif\n\n#ifndef PLASMA_NO_BOOST\nnamespace adaptor\n{\n\tusing namespace boost::adaptors;\n}\nnamespace algorithm\n{\n\tusing namespace boost::range;\n\ttemplate<class SinglePassRange, class Pred>bool any_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::any_of(std::begin(range), std::end(range), pred);\n\t}\n\ttemplate<class SinglePassRange, class Pred>bool all_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::all_of(std::begin(range), std::end(range), pred);\n\t}\n}\n#endif\nnamespace math\n{\n\ttemplate<class T>constexpr T pow(T p, int n)\n\t{\n\t\treturn n == 0 ? T(1) : n == 1 ? p : n == 2 ? p*p : n % 2 == 0 ? pow(pow(p, n / 2), 2) : pow(pow(p, n / 2), 2)*p;\n\t}\n\n\tint log(long long int p, int n)\n\t{\n\t\tint64 t = n;\n\t\tfor (int i = 0;;++i)\n\t\t{\n\t\t\tif (t > p)\n\t\t\t\treturn i;\n\t\t\tt *= n;\n\t\t}\n\t}\n\n\tconstexpr double pi = 3.141592653589793;\n\n\tnamespace detail\n\t{\n\t\tint gcd(int larger, int less)\n\t\t{\n\t\t\treturn less == 0 ? larger : gcd(less, larger%less);\n\t\t}\n\t}\n\n\tint gcd(int lhs, int rhs)\n\t{\n\t\treturn lhs < rhs ? detail::gcd(rhs, lhs) : detail::gcd(lhs, rhs);\n\t}\n\n\tvoid fourier_transform(\n\t\tstd::vector<std::complex<double>>& vec, std::size_t N)\n\t{\n\t\tstd::vector<std::complex<double>> butterfly;\n\t\tvec.resize(N);\n\t\tbutterfly.resize(N);\n\n\t\tstd::complex<double> half(std::cos(pi), std::sin(pi));\n\t\tfor (uint64 i = 1, k = N / 2;i < N;[&]() {i *= 2;k /= 2;}())//i*k == N/4\n\t\t{\n\t\t\tstd::complex<double> circle(std::cos(pi / i), std::sin(pi / i));\n\t\t\tstd::complex<double> c(1.0, 0);\n\t\t\tfor (auto count = 0ull; count < i;++count)\n\t\t\t{\n\t\t\t\tfor (auto j = 0ull;j < k;++j)\n\t\t\t\t{\n\t\t\t\t\tbutterfly[count*k + j] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c;\n\t\t\t\t\tbutterfly[count*k + j + N / 2] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c*half;\n\t\t\t\t}\n\t\t\t\tc *= circle;\n\t\t\t}\n\t\t\tstd::swap(vec, butterfly);\n\t\t}\n\t}\n\n\tclass polynomial\n\t{\n\t\tstd::vector<std::complex<double>> value;\n\t\tvoid swap(polynomial&& p)\n\t\t{\n\t\t\tstd::swap(value, p.value);\n\t\t}\n\tpublic:\n\t\tpolynomial() :value{ 0.0 } {}\n\t\tpolynomial(polynomial const&) = default;\n\t\tpolynomial(std::vector<std::complex<double>>&& vec) :value(std::move(vec)) {}\n\t\tpolynomial(polynomial&& p) :polynomial()\n\t\t{\n\t\t\tswap(std::move(p));\n\t\t}\n\t\tpolynomial(std::initializer_list<std::complex<double>> lis) :value(lis) {}\n\t\tpolynomial(std::complex<double> c) :polynomial({ c }) {}\n\n\t\tpolynomial& operator=(polynomial const&) = default;\n\t\tpolynomial& operator=(polynomial&& p)\n\t\t{\n\t\t\tvalue = std::vector<std::complex<double>>{ 0.0 };\n\t\t\tswap(std::move(p));\n\t\t\treturn *this;\n\t\t}\n\n\t\t~polynomial() = default;\n\t\tstd::complex<double> operator[](std::size_t deg)const\n\t\t{\n\t\t\treturn deg >= value.size() ? 0.0 : value[deg];\n\t\t}\n\t\tstd::size_t degree()const\n\t\t{\n\t\t\treturn value.size() - 1;\n\t\t}\n\t\tvoid strict_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tif (value[N] != 0.0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\t\tvoid integer_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tstd::cout << value[N] << \" \" << (std::norm(value[N]) > (1.0e-20)) << std::endl;\n\t\t\t\tif (std::norm(value[N]) > (1.0e-20))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\n\t\tfriend polynomial operator*(polynomial const& lhs, polynomial const& rhs)\n\t\t{\n\t\t\tstd::size_t N = 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tN *= 2;\n\t\t\t\tif (N > (lhs.degree() + rhs.degree()))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto lhs_ = lhs.value;\n\t\t\tauto rhs_ = rhs.value;\n\t\t\tfourier_transform(lhs_, N);\n\t\t\tfourier_transform(rhs_, N);\n\t\t\tstd::vector<std::complex<double>> vec;\n\t\t\tvec.reserve(N);\n\t\t\tfor (std::size_t i = 0;i < N;++i)\n\t\t\t{\n\t\t\t\tvec.push_back(lhs_[i] * rhs_[i]);\n\t\t\t}\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = 2 * v.real() - v;\n\t\t\t}\n\t\t\tfourier_transform(vec, N);\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = (2 * v.real() - v)*(1.0 / N);\n\t\t\t}\n\t\t\tstd::size_t k = N;\n\t\t\tfor (;k > 0;--k)\n\t\t\t{\n\t\t\t\tif (std::norm(vec[k]) > 1.0e-23)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec.resize(k + 1);\n\t\t\treturn polynomial(std::move(vec));\n\t\t}\n\t};\n\n\tint real_integer(std::complex<double> c)\n\t{\n\t\tint v = static_cast<int>(c.real());\n\t\tdouble u = c.real() - v;\n\t\treturn v + static_cast<int>(2 * u);\n\t}\n\n\ttemplate<class T>polynomial make_poly(std::vector<T> const& vec)\n\t{\n\t\tauto range = vec | adaptor::transformed([](T const& v) {return static_cast<std::complex<double>>(v);});\n\t\tstd::vector<std::complex<double>> ret(std::begin(range), std::end(range));\n\t\treturn polynomial(std::move(ret));\n\t}\n\tpolynomial make_poly(std::initializer_list<double>init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\tpolynomial make_poly(std::initializer_list<int> init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\ttemplate<class T>class infinite_value\n\t{\n\t\toptional<T> val;\n\tpublic:\n\t\tinfinite_value(T const& v) :val(v) {}\n\t\tinfinite_value(T&& v) :val(std::move(v)) {}\n\t\tinfinite_value(none_t = none) :val() {}\n\t\tinfinite_value(infinite_value const&) = default;\n\t\tinfinite_value(infinite_value&&) = default;\n\t\t~infinite_value() = default;\n\n\t\tinfinite_value& operator=(T const& v)\n\t\t{\n\t\t\tval = v;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(T&& v)\n\t\t{\n\t\t\tval = std::move(v);\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(none_t)\n\t\t{\n\t\t\tval = boost::none;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(infinite_value const&) = default;\n\t\tinfinite_value& operator=(infinite_value&&) = default;\n\n\t\toperator bool()const\n\t\t{\n\t\t\treturn static_cast<bool>(val);\n\t\t}\n\t\tT const& operator*()const\n\t\t{\n\t\t\treturn *val;\n\t\t}\n\n\t\tfriend infinite_value operator+(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs ? infinite_value<T>(*lhs + rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\n\t\tfriend bool operator==(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (!lhs && !rhs) || (lhs&&rhs && (*lhs == *rhs));\n\t\t}\n\t\tfriend bool operator==(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs && (*lhs == rhs);\n\t\t}\n\t\tfriend bool operator==(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn rhs && (lhs == *rhs);\n\t\t}\n\n\n\t\tfriend bool operator<(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : !rhs ? true : *lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : *lhs < rhs;\n\t\t}\n\t\tfriend bool operator<(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? true : lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\n\n\t\tfriend bool operator>(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn  !rhs ? false : !lhs ? true : *lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? true : *lhs > rhs;\n\t\t}\n\t\tfriend bool operator>(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? false : lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\n\t};\n\ttemplate<std::size_t Mod>class modulo_number\n\t{\n\t\tuint64 val = {};\n\t\tstatic constexpr uint64 abs(int64 n)\n\t\t{\n\t\t\treturn n <= -1 ? n + Mod : n;\n\t\t}\n\tpublic:\n\t\tmodulo_number(modulo_number const&) = default;\n\t\tmodulo_number(modulo_number&&) = default;\n\t\tmodulo_number& operator=(modulo_number const&) = default;\n\t\tmodulo_number& operator=(modulo_number&&) = default;\n\t\t~modulo_number() = default;\n\n\t\tconstexpr modulo_number(uint64 num = {}) : val(num%Mod) {}\n\t\tconstexpr modulo_number(unsigned int num) : val(num%Mod) {}\n\t\tconstexpr modulo_number(int64 num) : val(abs(num%Mod)) {}\n\t\tconstexpr modulo_number(int num) : val(abs(num%Mod)) {}\n\n\t\tmodulo_number& operator=(uint64 num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int64 num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(unsigned int num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn val;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + Mod - rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val*rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn lhs*math::pow(rhs, Mod - 2);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\n\t\ttemplate<class Rhs>decltype(auto) operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator/=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this / rhs;\n\t\t}\n\t};\n\n\ttemplate<class T>constexpr T factorial(std::size_t n, std::size_t goal = 1)\n\t{\n\t\treturn n == goal ? T(n) : n == 0 ? T(1) : factorial<T>(n, (n + goal) / 2 + 1)*factorial<T>((n + goal) / 2, goal);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr uint64 integral_sqrt_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? start :\n\t\t\t\tpow((start + end) / 2 + 1, 2) <= v ?\n\t\t\t\tintegral_sqrt_i(v, (start + end) / 2 + 1, end) :\n\t\t\t\tintegral_sqrt_i(v, start, (start + end) / 2);\n\t\t}\n\t}\n\n\tconstexpr uint64 integral_sqrt(uint64 v)\n\t{\n\t\treturn v == 0 ? 0 :\n\t\t\tv == 1 ? 1 :\n\t\t\tdetail::integral_sqrt_i(v, 1, 0b100000000000000000000000000000000ull);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr bool is_prime_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? v%end != 0 :\n\t\t\t\tis_prime_i(v, start, (start + end) / 2) &&\n\t\t\t\tis_prime_i(v, (start + end) / 2 + 1, end);\n\t\t}\n\t}\n\n\tconstexpr bool is_prime(uint64 v)\n\t{\n\t\treturn v == 0 ? false :\n\t\t\tv == 1 ? false :\n\t\t\tv == 2 ? true :\n\t\t\tv == 3 ? true : detail::is_prime_i(v, 2, integral_sqrt(v));\n\t}\n\n\tclass dynamic_modulo\n\t{\n\t\tuint64 value;\n\t\tuint64 mod;\n\t\tstatic constexpr uint64 abs(int64 v, uint64 mod)\n\t\t{\n\t\t\treturn v <= -1 ? v + mod : v;\n\t\t}\n\tpublic:\n\t\tconstexpr dynamic_modulo() :value(), mod(2) {}\n\t\tconstexpr dynamic_modulo(uint64 v, uint64 m) : value(v), mod(m) {}\n\t\tdynamic_modulo(dynamic_modulo const&) = default;\n\t\tdynamic_modulo(dynamic_modulo&&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo const&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo&&) = default;\n\t\t~dynamic_modulo() = default;\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value + rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value * rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo(abs((lhs.value - rhs.value) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\ttemplate<class Rhs>dynamic_modulo& operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t};\n}\nnamespace geometry\n{\n\ttemplate<class Type>struct point\n\t{\n\t\tType x, y;\n\t};\n\ttemplate<class Type>auto make_point(Type x, Type y)\n\t{\n\t\treturn point<Type>{x, y};\n\t}\n\ttemplate<class Type>auto operator+(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x + rhs.x, lhs.y + rhs.y);\n\t}\n\ttemplate<class Type>auto operator-(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x - rhs.x, lhs.y - rhs.y);\n\t}\n\ttemplate<class Point>struct box\n\t{\n\t\tPoint small, large;\n\t};\n\ttemplate<class Point>auto make_box(Point a, Point b)\n\t{\n\t\treturn box<Point>{\n\t\t\tmake_point(std::min(a.x, b.x), std::min(a.y, b.y)),\n\t\t\t\tmake_point(std::max(a.x, b.x), std::max(a.y, b.y))};\n\t}\n#ifndef  PLASMA_NO_BOOST\n\ttemplate<class Point>boost::optional<box<Point>> hit_check(box<Point> a, box<Point> b)\n\t{\n\t\tif (a.small.x > b.small.x)\n\t\t\tstd::swap(a, b);\n\t\tif (a.large.x < b.small.x)\n\t\t\treturn boost::none;\n\t\tauto small_x = b.small.x;\n\t\tauto large_x = std::min(b.large.x, a.large.x);\n\t\tif (a.small.y < b.small.y)\n\t\t{\n\t\t\tif (b.small.y < a.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, b.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a.small.y < b.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, a.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t}\n#endif\n}\nnamespace graph_traits\n{\n\tclass graph\n\t{\n\t\tstd::vector<int64> node_data;\n\t\tstd::vector<std::vector<std::pair<int, int64>>> edge_data;\n\tpublic:\n\t\tgraph() = default;\n\t\tgraph(std::vector<int64>&& n) :node_data(std::move(n)), edge_data{}\n\t\t{\n\t\t\tedge_data.resize(node_data.size());\n\t\t}\n\t\tgraph(std::size_t size) :node_data(size), edge_data{}\n\t\t{\n\n\t\t}\n\n\t\tvoid resize(int size)\n\t\t{\n\t\t\tnode_data.resize(size);\n\t\t\tedge_data.resize(size);\n\t\t}\n\t\tvoid edge_reserve(int size)\n\t\t{\n\t\t\tfor (auto& v : edge_data)\n\t\t\t{\n\t\t\t\tv.reserve(size);\n\t\t\t}\n\t\t}\n\n\t\tvoid add_node(int64 data)\n\t\t{\n\t\t\tnode_data.emplace_back(data);\n\t\t\tedge_data.emplace_back();\n\t\t}\n\t\tvoid add_edge(int from, int to, int64 data)\n\t\t{\n\t\t\tedge_data[from].emplace_back(to, data);\n\t\t}\n\t\tstd::vector<math::infinite_value<int64>> dijkstra(int from)const\n\t\t{\n\t\t\tstruct compare\n\t\t\t{\n\t\t\t\tbool operator()(\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& lhs,\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& rhs)const\n\t\t\t\t{\n\t\t\t\t\treturn lhs.second > rhs.second;\n\t\t\t\t}\n\t\t\t};\n\t\t\tstd::priority_queue<\n\t\t\t\tstd::pair<int, math::infinite_value<int64>>,\n\t\t\t\tstd::vector<std::pair<int, math::infinite_value<int64>>>,\n\t\t\t\tcompare>nodes;\n\t\t\tstd::vector<math::infinite_value<int64>> ret(node_data.size());\n\t\t\tfor (int i{};i < node_data.size();++i)\n\t\t\t{\n\t\t\t\tnodes.emplace(i, math::infinite_value<int64>());\n\t\t\t}\n\t\t\tnodes.emplace(from, int());\n\n\t\t\twhile (nodes.size())\n\t\t\t{\n\t\t\t\tauto p = nodes.top();\n\t\t\t\tnodes.pop();\n\t\t\t\tif (ret[p.first] <= p.second)\n\t\t\t\t\tcontinue;\n\t\t\t\tret[p.first] = p.second;\n\t\t\t\tfor (auto const& d : edge_data[p.first])\n\t\t\t\t{\n\t\t\t\t\tnodes.emplace(d.first, std::min(ret[d.first], ret[p.first] + d.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint64 operator[](int n)const\n\t\t{\n\t\t\treturn node_data[n];\n\t\t}\n\t};\n}\nnamespace container\n{\n\ttemplate<class T>using p_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n}\n\nvoid Main();\n#endif//テンプレートここまで\n//ここを書き換える\n#define PROBLEM 4\n\n//ここは書き換えない\nint main()\n{\n\tstd::cin.sync_with_stdio(false);\n\tstd::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1);\n\tMain();\n}\n\n#if BOOST_PP_EQUAL(PROBLEM, 1)\n\nvoid Main()\n{\n\tint N, A, B;\n\tstd::cin >> N >> A >> B;\n\tcontainer::p_queue<int> t;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint x;\n\t\tstd::cin >> x;\n\t\tt.emplace(x);\n\t}\n\tint size{};\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t\telse if (x >= A)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t++size;\n\t}\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tstd::cout << size << std::endl;\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 2)\n\nvoid Main()\n{\n\tint N, K;\n\tstd::cin >> N >> K;\n\tstd::array<int, 26>count = {};\n\tfor (int i{};i < N;++i)\n\t{\n\t\tstd::string str;\n\t\tstd::cin >> str;\n\t\t++count[str.front() - 'A'];\n\t}\n\tint loop{};\n\twhile (true)\n\t{\n\t\talgorithm::sort(count, std::greater<>());\n\t\tfor (int i{};i < K;++i)\n\t\t{\n\t\t\tif (count[i])\n\t\t\t{\n\t\t\t\t--count[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::cout << loop << std::endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t++loop;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 3)\n\nvoid Main()\n{\n\tstd::vector<std::pair<int,int>> table;\n\tfor (int i{};i < 128;++i)\n\t{\n\t\tint max{};\n\t\tint y{};\n\t\tfor (int j{};j < 128;++j)\n\t\t{\n\t\t\tif (max <= (i^j) + j - i)\n\t\t\t{\n\t\t\t\tmax = (i^j) + j - i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\ttable.emplace_back(std::make_pair(y, max));\n\t}\n\talgorithm::sort(table, std::greater<>());\n\tint N;\n\tstd::cin >> N;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint C, D;\n\t\tstd::cin >> C >> D;\n\t\tstd::vector<int> cookie = { D };\n\t\tint now = D;\n\t\tfor (int x = 1;x < C;++x)\n\t\t{\n\t\t\tint target{};\n\t\t\tint max{};\n\t\t\tfor (int index{};index < cookie.size();++index)\n\t\t\t{\n\t\t\t\tif (max < table[cookie[index]].second)\n\t\t\t\t{\n\t\t\t\t\tmax = table[cookie[index]].second;\n\t\t\t\t\ttarget = index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow += max;\n\t\t\tcookie.emplace_back(table[cookie[target]].first);\n\t\t\tcookie[target] ^= table[cookie[target]].first;\n\t\t}\n\t\tstd::cout << now << std::endl;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 4)\n\ntypedef std::pair<std::string, std::string> data_t;\ntemplate<class Lhs,class Rhs>auto add(Lhs const& lhs, Rhs const& rhs)\n{\n\treturn std::make_pair(lhs.first + rhs.first, lhs.second + rhs.second);\n}\n\ntemplate<class T>auto size(T const& t)\n{\n\treturn t.first.size();\n}\n\ntemplate<class T>int query(T const& t)\n{\n\tstatic std::string str;\n\tstd::cout << t.first << \"\\n\" << t.second << std::endl;\n\tstd::cin >> str;\n\tif (str == \"T\")\n\t\treturn 1;\n\tif (str == \"F\")\n\t\treturn 0;\n\treturn -1;\n}\n\nvoid Main()\n{\n\tint N;\n\tconst std::pair<char, char> basic[] ={\n\t\tstd::make_pair('.','.'),\n\t\tstd::make_pair('.','#'),\n\t\tstd::make_pair('#','.'),\n\t\tstd::make_pair('#','#')\n\t};\n\tstd::cin >> N;\n\tdata_t d;\n\tfor (auto const& b : basic)\n\t{\n\t\td = add(data_t(), b);\n\t\tauto result = query(d);\n\t\tif (result == 1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse if (result == -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\nloop1:\n\tfor (auto const& b : basic)\n\t{\n\t\tauto v = add(d, b);\n\t\tauto result = query(v);\n\t\tif (result == 1)\n\t\t{\n\t\t\tstd::swap(v, d);\n\t\t\tgoto loop1;\n\t\t}\n\t\telse if (result == -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\nloop2:\n\tfor (auto const& b : basic)\n\t{\n\t\tauto v = add(b, d);\n\t\tauto result = query(v);\n\t\tif (result == 1)\n\t\t{\n\t\t\tstd::swap(v, d);\n\t\t\tgoto loop2;\n\t\t}\n\t\telse if (result == -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 5)\n\nvoid Main()\n{\n\tint H, W;\n\tstd::cin >> H >> W;\n\tstd::vector<std::string> grid;\n\tstd::string str;\n\tstd::cin >> str;\n\tif (algorithm::count(str, 'X'))\n\t{\n\t\tstd::cout << -1 << std::endl;\n\t\treturn;\n\t}\n\tgrid.emplace_back(std::move(str));\n\tfor (int i = 1;i < H;++i)\n\t{\n\t\tstd::cin >> str;\n\t\tif (str[0] == 'X' || str[W - 1] == 'X')\n\t\t{\n\t\t\tstd::cout << -1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t\tgrid.emplace_back(std::move(str));\n\t}\n\tstd::cin >> str;\n\tif (algorithm::count(str, 'X'))\n\t{\n\t\tstd::cout << -1 << std::endl;\n\t\treturn;\n\t}\n\tgrid.emplace_back(std::move(str));\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 6)\n\ntypedef std::string::iterator iterator;\nenum class func_type\n{\n\tmax, min\n};\n\nstruct tree\n{\n\titerator first, last;\n\tstd::shared_ptr<tree> lhs;\n\tstd::shared_ptr<tree> rhs;\n\tfunc_type func;\n\toptional<int> num;\n};\ntree parse(iterator first, iterator last)\n{\n\tfunc_type f;\n\tif (*first == '^')\n\t{\n\t\tf = func_type::max;\n\t}\n\telse if (*first == '_')\n\t{\n\t\tf = func_type::min;\n\t}\n\n}\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 7)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 8)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 9)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 10)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 11)\n\nvoid Main()\n{\n\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "// Kyoto University Programming Contest 2016\n// D - 長い黒板 / Long Blackboard\n\n#include <cstdio>\n#include <deque>\n#include <string>\n#define R 2\nusing namespace std;\n\n\nint N;\ndeque<char> d[2];\n\nint main() {\n\n  char c;\n  char buff[256];\n  bool dir, updated;\n\n  scanf(\"%d\", &N);\n  dir = true;\n  for (int n = 0; n < N; n++) {\n    updated = false;\n    for (int b = 0; b < (1 << R); b++) {\n      for (int j = 0; j < R; j++) {\n        c = (b & (1 << j)) > 0 ? '#' : '.';\n        if (dir) {\n          d[j].push_back(c);\n        } else {\n          d[j].push_front(c);\n        }\n        printf(\"%s\\n\", string(d[j].begin(), d[j].end()).c_str());\n      }\n      fflush(stdout);\n      scanf(\"%s\", buff);\n      if (buff[0] == 'T') {\n        updated = true;\n        break;\n      } else if (buff[0] != 'F') {\n        return 0;\n      }\n      for (int j = 0; j < R; j++) {\n        if (dir) {\n          d[j].pop_back();\n        } else {\n          d[j].pop_front();\n        }\n      }\n    }\n    if (!updated) {\n      dir = !dir;\n      n--;\n    }\n  }\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nusing ll=long long int;\nusing pii=pair<int,int>;\nusing pil=pair<int,ll>;\nusing pli=pair<ll,int>;\nusing pll=pair<ll,ll>;\nusing psi=pair<string,int>;\nusing pis=pair<int,string>;\nusing psl=pair<string,ll>;\nusing pls=pair<ll,string>;\nusing pss=pair<string,string>;\n\n\n\ntemplate<typename T> using vc=vector<T>;\ntemplate<typename T> using vvc=vector<vector<T>>;\ntemplate<typename T> using vvvc=vector<vector<vector<T>>>;\ntemplate<typename T> using vvvvc=vector<vvvc<T>>;\ntemplate<typename T> using vvvvvc=vector<vvvvc<T>>;\n\ntemplate<class T,class U>inline constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>inline constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\ninline void bin101(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(20);\n}\n\ntemplate<typename T>\ninline void Yes(T flag){\n    if(flag) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\ntemplate<typename T>\ninline void YES(T flag){\n    if(flag) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\n//1-indexed vector cin\ntemplate<typename T>\ninline void vin1(vector<T> &v){\n    for(int i=1;i<v.size();i++) cin>>v[i];\n}\n\n//0-indexed vector cin\ntemplate<typename T>\ninline void vin0(vector<T> &v){\n    for(int i=0;i<v.size();i++) cin>>v[i];\n}\n\n//1-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin1(vector<vector<T>> &v){\n    for(int i=1;i<v.size();i++){\n        for(int j=1;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n//0-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin0(vector<vector<T>> &v){\n    for(int i=0;i<v.size();i++){\n        for(int j=0;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<v[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            cout<<i<<\" \"<<j<<\" \"<<v[i][j]<<'\\n';\n        }\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        if(i) cout<<\" \";\n\t\tcout<<v[i];\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n\t\t\tif(j) cout<<\" \";\n            cout<<v[i][j];\n        }\n\t\tcout<<endl;\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            int sssz=v[i][j].size();\n            for(int k=0;k<sssz;k++){\n                cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<v[i][j][k]<<'\\n';\n            }\n        }\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//pair cout\ntemplate<typename T, typename U>\ninline ostream &operator<<(ostream &os,const pair<T,U> &p) {\n  os<<p.first<<\" \"<<p.second;\n  return os;\n}\n\n//pair cin\ntemplate<typename T, typename U>\ninline istream &operator>>(istream &is,pair<T,U> &p) {\n  is>>p.first>>p.second;\n  return is;\n}\n\n//ソート\ntemplate<typename T>\ninline void vsort(vector<T> &v){\n    sort(v.begin(),v.end());\n}\n\n//逆順ソート\ntemplate<typename T>\ninline void rvsort(vector<T> &v){\n  sort(v.rbegin(),v.rend());\n}\n\n//要素数a 初期値x\ntemplate<typename T>\ninline vector<T> vmake(int a,T x){\n  return vector<T>(a,x);\n}\n\n//data[a][b] 初期値x\ntemplate<typename T>\ninline vector<vector<T>> vmake(int a,int b,T x){\n  return vector<vector<T>>(a, vector<T>(b,x));\n}\n\n//data[a][b][c] 初期値x\ntemplate<typename T>\ninline vector<vector<vector<T>>> vmake(int a,int b,int c,T x){\n  return vector<vector<vector<T>>> (a, vector<vector<T>>(b, vector<T>(c, x)));\n}\n\n//data[a][b][c][d]　初期値x\ntemplate<typename T>\ninline vector<vector<vector<vector<T>>>> vmake(int a,int b,int c,int d,T x){\n  return vector<vector<vector<vector<T>>>> (a,vvvc<T>(b,vvc<T>(c,vc<T>(d,x))));\n}\n\n//data[a][b][c][d][e] 初期値x\ntemplate<typename T>\ninline vvvvvc<T> vmake(int a,int b,int c,int d,int e,T x){\n  return vvvvvc<T> (a,vvvvc<T>(b,vvvc<T>(c,vvc<T>(d,vc<T>(e,x)))));\n}\n\n//1ビットの数を返す\ninline int popcount(int x){\n  return __builtin_popcount(x);\n}\n//1ビットの数を返す\ninline int popcount(ll x){\n  return __builtin_popcountll(x);\n}\n\n//queのfront() pop()\ntemplate<typename T>\ninline T pop(queue<T> &que){\n    T x=que.front();\n    que.pop();\n    return x;\n}\n\n//priority_que top() pop()\ntemplate<typename T>\ninline T pop(priority_queue<T> &que){\n  T x=que.top();\n  que.pop();\n  return x;\n}\n\n//stack top() pop()\ntemplate<typename T>\ninline T pop(stack<T> &st){\n  T x=st.top();\n  st.pop();\n  return x;\n}\n\n#define SZ(x) ( (int)x.size()  )\n#define pb push_back\n\n/*\n満たすものの個数を返す\nmode:0 x未満\nmode:1 x以下の数\nmode:2 x以上の数\nmode:3 x超\nmode:4 x\n*/\ntemplate<typename T>\ninline int count_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return lower_bound(v.begin(),v.end(),x)-v.begin();\n        case 1:\n            return upper_bound(v.begin(),v.end(),x)-v.begin();\n        case 2:\n            return v.end()-lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return v.end()-upper_bound(v.begin(),v.end(),x);\n        case 4:\n            return upper_bound(v.begin(),v.end(),x)-lower_bound(v.begin(),v.end(),x);\n    }\n}\n\n/*\nmode:0 xより小さい数で最大の数\nmode:1 x以下の数で最大の数\nmode:2 x以上の数で最小の数\nmode:3 xより大きい数で最小の数\n*/\ntemplate<typename T>\ninline T value_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return *(--lower_bound(v.begin(),v.end(),x));\n        case 1:\n            return *(--upper_bound(v.begin(),v.end(),x));\n        case 2:\n            return *lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return *upper_bound(v.begin(),v.end(),x);\n    }\n}\n\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr ll MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nsigned main(){\n\tbin101();\n\n\tint N;\n\tcin>>N;\n\tint now=0;\n\tstring up;\n\tstring down;\n\tstring du=\"..##\",dd=\".#.#\";\n\twhile(true){\n\t\tbool flag=false;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tup+=du[i]; down+=dd[i];\n\t\t\tcout<<up<<\"\\n\";\n\t\t\tcout<<down<<endl;\n\t\t\tchar t; cin>>t;\n\t\t\tif(t=='F'){\n\t\t\t\tup.pop_back();\n\t\t\t\tdown.pop_back();\n\t\t\t}\n\t\t\tflag=true;\n\t\t\tbreak;\n\t\t}\n\t\tif(flag && up.size()!=N) continue;\n\t\tbreak;\n\t}\n\tif(up.size()==N){\n\t\treturn 0;\n\t}\n\tcout<<-1<<endl;\n\twhile(true){\n\t\tstring U,D;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tU+=du[i]+up; D+=dd[i]+down;\n\t\t\tcout<<U<<\"\\n\";\n\t\t\tcout<<D<<endl;\n\t\t\tchar t; cin>>t;\n\t\t\tif(t=='F'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tup=U; down=D;\n\t\t\tif(up.size()==N){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n\tll n;\n\tcin>>n;\n\tstring input =\"\";\n\tstring s1 =\"..##\";\n\tstring s2 =\"#..#\";\n\tstring ans1 = \"\" , ans2=\"\";\n\twhile(input != \"end\")\n\t{\n\t\tbool balik = 1;\n\t\tfor(int i = 0; i  < 4;  i++)\n\t\t{\n\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\ttemp1 += s1[i];\n\t\t\ttemp2 += s2[i];\n\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\tfflush(stdout);\n\t\t\tcin>>input;\n\t\t\tif(input == \"end\") return 0;\n\t\t\tif(input == \"T\" || input == \"end\")\n\t\t\t{\n\t\t\t\tans1 = temp1;\n\t\t\t\tans2 = temp2;\n\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( i == 3)\n\t\t\t\t{\n\t\t\t\t\tbalik = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(balik == 0)\n\t\t{\n\t\t\tfor(int i = 0; i  < 4;  i++)\n\t\t\t{\n\t\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\t\ttemp1 = s1[i] + ans1;\n\t\t\t\ttemp2 = s2[i] + ans2;\n\t\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin>>input;\n\t\t\t\tif(input == \"end\") return 0;\n\t\t\t\tif(input == \"T\" )\n\t\t\t\t{\n\t\t\t\t\tans1 = temp1;\n\t\t\t\t\tans2 = temp2;\n\t\t\t\t\tif(ans1.size() == n) return 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif( i == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tbalik = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MEM(a,b) memset((a),(b),sizeof(a))\nconst LL INF = 1e9 + 7;\nconst int N = 1e3 + 10;\nstring x = \"..##\";\nstring y = \".#.#\";\nclass AbstactSolver\n{\npublic:\n\tvirtual void outputGuess() = 0;\n\tvirtual void getResult() = 0;\n\tvirtual void outputFinalResult() = 0;\n\tvoid solve()\n\t{\n\t\tstring s1, s2;\n\t\tcin >> n;\n\t\tint len = 0;\n\t\tint flag = 1;\n\t\tchar c;\n\t\twhile (1)\n\t\t{\n\t\t\tif (s1.length() == n) break;\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tint key = -1;\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tgx = s1 + x[i];\n\t\t\t\t\tgy = s2 + y[i];\n\t\t\t\t\toutputGuess();\n\t\t\t\t\tgetResult();\n\t\t\t\t\tc = response[0];\n\t\t\t\t\tif (c == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tkey = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (key == -1) flag = 0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1 = gx;\n\t\t\t\t\ts2 = gy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint key = -1;\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tgx = x[i] + s1;\n\t\t\t\t\tgy = y[i] + s2;\n\t\t\t\t\toutputGuess();\n\t\t\t\t\tgetResult();\n\t\t\t\t\tc = response[0];\n\t\t\t\t\tif (c == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tkey = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (key == -1) break;\n\t\t\t\ts1 = gx;\n\t\t\t\ts2 = gy;\n\t\t\t}\n\t\t}\n\t\t// 这里输出最后认为正确的猜测\n\t\tgx = s1;\n\t\tgy = s2;\n\t\toutputFinalResult();\n\t}\npublic:\n\tstring gx, gy; // \n\tchar response[10]; // 反馈的结果\n\tint n;\n};\n\n// LocalSolve用于解决本地调试的情况\nclass LocalSolver : public AbstactSolver\n{\npublic:\n\tstring cx, cy; // 这里是提供给我们要猜的数字\n\tint guessCount; // 记录猜测次数\n\tLL pre;\npublic:\n\tLocalSolver()\n\t{\n\t\tguessCount = 0;\n\t\t// 这里放入正确的结果，也就是我们要去猜的数\n\t\tcx = \"#.\";\n\t\tcy = \"#.\";\n\t}\n\tvoid outputGuess()\n\t{\n\t\t// 这里之前已经把要猜测的东西保存下来了，只记录猜测次数\n\t\tprintf(\"the %d round, you guess the number is: %s %s\\n\", ++guessCount, gx.c_str(), gy.c_str());\n\t}\n\n\n\tvoid getResult()\n\t{\n\t\t// 这里写本地调试器，不要在意细节\n\t\tint k = gx.length();\n\t\tresponse[0] = 'F';\n\t\tfor (int i = 0; i + k <= n; i++)\n\t\t{\n\t\t\tif (gx == cx.substr(i, k) && gy == cy.substr(i, k)) response[0] = 'T';\n\t\t}\n\t\tprintf(\"the %d round, the feedback is:\\n%c\\n\\n\", guessCount, response);\n\t}\n\n\tbool isGuessCorrect()\n\t{\n\t\treturn gx == cx &&\n\t\t\tgy == cy;\n\t}\n\tvoid outputFinalResult()\n\t{\n\n\t\tprintf(\"\\nYou guess the number is: %s %s\\n,\", gx.c_str(), gy.c_str());\n\t\tprintf(\"The correct Number is: %s %s\\n\", cx.c_str(), cy.c_str());\n\t\tprintf(\"your guess is %s\\n\", isGuessCorrect() ? \"TRUE\" : \"FALSE\");\n\t\tprintf(\"total guess count is: %d\\n\", guessCount);\n\t}\n\n};\n\nclass RemoteSolver : public AbstactSolver\n{\npublic:\n\tvoid outputGuess()\n\t{\n\t\tprintf(\"%s\\n%s\\n\", gx.c_str(), gy.c_str());\n\t\tfflush(stdout);\n\t}\n\tvoid getResult()\n\t{\n\t\tscanf(\"%s\", response);\n\t}\n\tvoid outputFinalResult()\n\t{\n\t\tprintf(\"%s\\n%s\\n\", gx.c_str(), gy.c_str());\n\t\tfflush(stdout);\n\t}\n};\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//#ifdef ONLINE\n\tRemoteSolver solver;\n\t//#else\n\t//\tLocalSolver solver;\n\t//#endif\n\n\tsolver.solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) begin(a),end(a)\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX (int)1e6 + 5\n\nint N;\n\nsigned main() {\n\tcout << setprecision(20) << fixed;\n\tcin >> N;\n\tstring s1_ans, s2_ans;\n\tstring s1, s2;\n\tstring res;\n\tchar a[] = \".#\";\n\twhile (1) {\n\t\trep(i, 2) rep(j, 2) rep(k, 2) {\n\t\t\tif (i == 0) {\n\t\t\t\ts1 = s1_ans + a[j];\n\t\t\t\ts2 = s2_ans + a[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts1 = a[j] + s1_ans;\n\t\t\t\ts2 = a[k] + s2_ans;\n\t\t\t}\n\t\t\tcout << s1 << endl;\n\t\t\tcout << s2 << endl;\n\t\t\tcin >> res;\n\t\t\tif (res == \"end\") return 0;\n\t\t\tif (res == \"T\") {\n\t\t\t\ts1_ans = s1;\n\t\t\t\ts2_ans = s2;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\tnext:;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N;\nint now=0;\nstring S1,S2;\nbool ask(int k){\n\tif(k>=4){\n\t\tstring SS1,SS2;\n\t\tif(k==4){\n\t\t\tSS1='.'+S1;\n\t\t\tSS2='.'+S2;\n\t\t}\n\t\telse if(k==5){\n\t\t\tSS1='.'+S1;\n\t\t\tSS2='#'+S2;\n\t\t}\n\t\telse if(k==6){\n\t\t\tSS1='#'+S1;\n\t\t\tSS2='.'+S2;\n\t\t}\n\t\telse{\n\t\t\tSS1='#'+S1;\n\t\t\tSS2='#'+S2;\n\t\t}\n\t\tcout << SS1 << \"\\n\" << SS2 << \"\\n\";\n\t\tstring ans;\n\t\tcin >> ans;\n\t\tif(ans==\"T\")return true;\n\t\treturn false;\n\t}\n\telse{\n\t\tstring SS1,SS2;\n\t\tif(k==0){\n\t\t\tSS1=(S1+'.');\n\t\t\tSS2=(S2+'.');\n\t\t}\n\t\telse if(k==1){\n\t\t\tSS1=(S1+'.');\n\t\t\tSS2=(S2+'#');\n\t\t}\n\t\telse if(k==2){\n\t\t\tSS1=(S1+'#');\n\t\t\tSS2=(S2+'.');\n\t\t}\n\t\telse{\n\t\t\tSS1=(S1+'#');\n\t\t\tSS2=(S2+'#');\n\t\t}\n\t\tcout << SS1 << \"\\n\" << SS2 << \"\\n\";\n\t\tstring ans;\n\t\tcin >> ans;\n\t\tif(ans==\"T\")return true;\n\t\treturn false;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tbool F=false;\n\t\tif(now==0){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(ask(j)){\n\t\t\t\t\tF=true;\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tS1+='.';S2+='.';\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==1){\n\t\t\t\t\t\tS1+='.';S2+='#';\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==2){\n\t\t\t\t\t\tS1+='#';S2+='.';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tS1+='#';S2+='#';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==N-1&&F)return 0;\n\t\t\tif(!F){\n\t\t\t\tnow=1;\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=4;j<8;j++){\n\t\t\t\tif(ask(j)){\n\t\t\t\t\tF=true;\n\t\t\t\t\tif(j==4){\n\t\t\t\t\t\tS1=('.'+S1);S2=('.'+S2);\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==5){\n\t\t\t\t\t\tS1=('.'+S1);S2=('#'+S2);\n\t\t\t\t\t}\n\t\t\t\t\telse if(j==6){\n\t\t\t\t\t\tS1=('#'+S1);S2=('.'+S2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tS1=('#'+S1);S2=('#'+S2);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==N-1&&F)return 0;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DBG(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nstring str = \".\\n#\\n\";\n\nvoid fuck(string &str) {\n    string up, down;\n    int cnt = 0;\n    for(auto c : str) {\n        if(c != '\\n') {\n            if(cnt & 1) down.push_back(c);\n            else up.push_back(c);\n            ++cnt;\n        }\n    }\n    cout << up << endl;\n    cout << down << endl;\n}\n\nint main(int argc, char **argv) {\n    int n;\n    cin >> n;\n    int cnt = 1;\n    bool toRight = true;\n    while(true) {\n        fuck(str);\n        fflush(stdout);\n        string st;\n        cin >> st;\n        if(st == \"end\") break;\n        if(st == \"F\") {\n            if(cnt == 4) {\n                if(toRight) {\n                    toRight = !toRight;\n                    str.erase(str.size() - 4, 4);\n                    str = \".\\n.\\n\" + str;\n                } else {\n                    toRight = !toRight;\n                    str.erase(0, 4);\n                    str += \".\\n.\\n\";\n                }\n                cnt = 1;\n            } else {\n                if(toRight) {\n                    str.erase(str.size() - 4, 4);\n                    string add;\n                    if(cnt & (1 << 0)) add += '#'; else add += '.'; add += '\\n';\n                    if(cnt & (1 << 1)) add += '#'; else add += '.'; add += '\\n';\n                    str += add;\n                    ++cnt;\n                } else {\n                    str.erase(0, 4);\n                    string add;\n                    if(cnt & (1 << 0)) add += '#'; else add += '.'; add += '\\n';\n                    if(cnt & (1 << 1)) add += '#'; else add += '.'; add += '\\n';\n                    str += add;\n                    ++cnt;\n                }\n            }\n        } else if(st == \"T\") {\n            cnt = 1;\n            if(toRight) str += \".\\n.\\n\";\n            else str = \".\\n.\\n\" + str;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long long LL;\ntypedef pair<int,int> ii;\ntypedef vector<ii> vii;\ntypedef vector<int> vi;\n\n#ifdef DEBUG\n    #define cek(x) cout<<x\n#else\n    #define cek(x) if(false){}\n#endif // DEBUG\n\n#define fi first\n#define se second\n#define INF 1000000000\n#define INFLL 1000000000000000000LL\n#define EPS 1e-9\n#define PI acos(-1.0)\n#define pb push_back\n#define TC() while(tc--)\n#define FOR(i,n) for(int i=0;i<n;i++)\n#define FORN(i,n) for(int i=0;i<=n;i++)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define REPN(i,a,b) for(int i=a;i<=b;i++)\n#define reset(a,b) memset(a,b,sizeof(a))\n#define sc(x) scanf(\"%d\",&x)\n\nint main(void){\n    #ifdef ccsnoopy\n        freopen(\"D:/Code/in.txt\",\"r\",stdin);\n    #endif\n\n    int n;\n    sc(n);\n    string res;\n    deque<char> atas,bawah;\n    char iatas[] = {'.','.','#','#'};\n    char ibawah[] = {'.','#','.','#'};\n\n    while(true){\n        bool valid = false;\n        FOR(i,4){\n            FOR(j,atas.size()){\n                printf(\"%c\", atas[j]);\n            }\n            printf(\"%c\\n\", iatas[i]);\n            FOR(j,bawah.size()){\n                printf(\"%c\", bawah[j]);\n            }\n            printf(\"%c\\n\", ibawah[i]);\n            fflush(stdout);\n            cin>>res;\n            if(res == \"T\"){\n                atas.push_back(iatas[i]);\n                bawah.push_back(ibawah[i]);\n                valid = true;\n                break;\n            }else if(res == \"end\"){\n                return 0;\n            }\n        }\n\n        if(valid)continue;\n\n        FOR(i,4){\n            printf(\"%c\", iatas[i]);\n            FOR(j,atas.size()){\n                printf(\"%c\", atas[j]);\n            }\n            printf(\"\\n%c\", ibawah[i]);\n            FOR(j,bawah.size()){\n                printf(\"%c\", bawah[j]);\n            }\n            printf(\"\\n\");\n            fflush(stdout);\n            cin >> res;\n            if(res == \"T\"){\n                atas.push_front(iatas[i]);\n                bawah.push_front(ibawah[i]);\n                break;\n            }else if(res == \"end\"){\n                return 0;\n            }\n        }\n\n    }\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\nusing namespace std;\n\nint main(){\n  int N;\n  cin >> N;\n\n  string table[2];\n  for(int i = 0 ; i < 2 ; i++){\n    for(int j = 0 ; j < N ; j++){\n      table[i] += '.';\n    }\n  }\n  \n  while(1){\n    // query\n    string n_table[2];\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n\tn_table[j] = table[j];\n      }\n\n      n_table[0] += (i%2?'#':'.');\n      n_table[1] += ((i >> 1)%2?'#':'.');\n      \n      printf(\"%s\\n%s\\n\", n_table[0], n_table[1]); fflush(stdout);\n      // in\n      string str;\n      cin >> str;\n      if(str == \"T\"){\n\tfor(int j = 0 ; j < 2 ; j++){\n\t  table[j] = n_table[j];\n\t}\n\tbreak;\n      }\n      else if(str == \"end\"){\n\treturn 0;\n      }\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n//#define ln cout<<'\\n'\n#define ln cout<<endl\ntemplate<C T>void pr(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n;\n  R n;\n  string s[2]={\"\",\"\"};\n  char b[2]={'.','#'};\n  bool f=0;\n  while(1) {\n    rep(i,4) {\n      if(!f) pr(s[0]+b[i&1]);\n      else pr(b[i&1]+s[0]);\n      if(!f) pr(s[1]+b[!!(i&2)]);\n      else pr(b[!!(i&2)]+s[1]);\n      char c;\n      R c;\n      if(c=='T') {\n        if(!f) s[0]=s[0]+b[i&1];\n        else s[0]=b[i&1]+s[0];\n        if(!f) s[1]=s[1]+b[!!(i&2)];\n        else s[1]=b[!!(i&2)]+s[1];\n        goto next;\n      } else if(c=='F') continue;\n      else return;\n    }\n    f=1;\n  next:;\n  } \n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100 + 5;\n\nint n;\nstring a, b;\n\nbool check(char aa, char bb){\n\ta += aa;\n\tb += bb;\n\tcout << a << endl;\n\tcout << b << endl;\n\tchar t;\tcin >> t;\n\tif (t == 'T')\treturn true;\n\ta.pop_back();\n\tb.pop_back();\n\treturn false;\n}\n\nbool check2(char aa, char bb){\n\ta = aa + a;\n\tb = bb + b;\n\tcout << a << endl;\n\tcout << b << endl;\n\tchar t;\tcin >> t;\n\tif (t == 'T')\treturn true;\n\ta.erase(a.begin());\n\tb.erase(b.begin());\n\treturn false;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tbool fail = 0;\n\twhile (a.size() < n){\n\t\tbool done = 0;\n\t\tif (!fail){\n\t\t\tif (check('#', '.'))\tdone = 1;\n\t\t\telse if (check('#', '#'))\tdone = 1;\n\t\t\telse if (check('.', '#'))\tdone = 1;\n\t\t\telse if (check('.', '.'))\tdone = 1;\n\t\t}\n\t\tif (!done)\tfail = 1;\n\t\tif (fail){\n\t\t\tif (check2('#', '.'))\tdone = 1;\n\t\t\telse if (check2('#', '#'))\tdone = 1;\n\t\t\telse if (check2('.', '#'))\tdone = 1;\n\t\t\telse if (check2('.', '.'))\tdone = 1;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\tcin>>n;\n\tstring a=\"\",b=\"\";\n\tchar c[2][2]={\".\",\"#\"};\n\twhile(1){\n\t\tbool h=false;\n\t\trep(i,2)rep(j,2){\n\t\t\tstring ta=a+(string)c[i],tb=b+(string)c[j];\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tstring out;\n\t\t\tcin>>out;\n\t\t\tif(out==\"T\"){\n\t\t\t\ta=ta;b=tb;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tend:;\n\t\tif(a.size()==n)break;\n\t}\n\tif(a.size()!=n)while(1){\n\t\tbool h=false;\n\t\trep(i,2)rep(j,2){\n\t\t\tstring ta=(string)c[i]+a,tb=(string)c[j]+b;\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tstring out;\n\t\t\tcin>>out;\n\t\t\tif(out==\"T\"){\n\t\t\t\ta=ta;b=tb;\n\t\t\t\tgoto end1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tend1:;\n\t\tif(a.size()==n)break;\n\t}\n\tcout<<a<<endl<<b<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nbool query(VS& vs){\n  cout << vs[0] << endl << vs[1] << endl;\n  char c; cin >> c;\n  return c == 'T';\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  int len = 0;\n  string ch = \".#\";\n  VS vs(2);\n  bool up = true;\n  while(up && len < N){\n\tup = false;\n\tVS qs = vs;\n\tqs[0] += \"x\";\n\tqs[1] += \"x\";\n\tREP(i,2) REP(j,2){\n\t  qs[0][len] = ch[i];\n\t  qs[1][len] = ch[j];\n\t  if(query(qs)){\n\t\ti = j = 2;\n\t\tvs = qs;\n\t\t++len;\n\t\tup = true;\n\t  }\n\t}\n  }\n\n  up = true;\n  while(up && len < N){\n\tup = false;\n\tVS qs(2);\n\tqs[0] = \"x\" + vs[0];\n\tqs[1] = \"x\" + vs[1];\n\tREP(i,2) REP(j,2){\n\t  qs[0][0] = ch[i];\n\t  qs[1][0] = ch[j];\n\t  if(query(qs)){\n\t\ti = j = 2;\n\t\tvs = qs;\n\t\t++len;\n\t\tup = true;\n\t  }\n\t}\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    string s1, s2;\n    cin >> n;\n    \n    char c[3] = {'.', '#'};\n    \n    string res;\n    while (res != \"end\") {\n        char tes[3];\n        bool ok = 0;\n        for (int i=0; i<2; i++) for (int j=0; j<2; j++) {\n            if (ok) break;\n            cout << s1 + c[i] << \"\\n\" << s2 + c[j] << \"\\n\"; fflush(stdout);\n            cin >> res;\n            if (res == \"end\") return 0;\n            if (res == \"T\") ok = 1, tes[0] = c[i], tes[1] = c[j];\n        }\n        \n        if (ok) s1 += tes[0], s2 += tes[1];\n        else break;\n    }\n    \n    while (res != \"end\") {\n        char tes[3];\n        bool ok = 0;\n        for (int i=0; i<2; i++) for (int j=0; j<2; j++) {\n            if (ok) break;\n            cout << \"\" + c[i] + s1 << \"\\n\" << \"\" + c[j] + s2 << \"\\n\"; fflush(stdout);\n            cin >> res;\n            if (res == \"end\") return 0;\n            if (res == \"T\") ok = 1, tes[0] = c[i], tes[1] = c[j];\n        }\n        \n        if (ok) s1 = \"\" + tes[0] + s1, s2 = \"\" + tes[1] + s2;\n        else break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nbool query(string s,string t){\n\tcout<<s<<endl<<t<<endl;\n\tstring h;\n\tcin>>h;\n\treturn h[0]=='T';\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tstring s[2];\n\tbool forward=1;\n\trep(i,N){\n\t\tbool done=0;\n\t\trep(j,4){\n\t\t\tstring ns[2];\n\t\t\tif(forward){\n\t\t\t\tns[0]=s[0]+(j%2==0?'#':'.');\n\t\t\t\tns[1]=s[1]+(j/2==0?'#':'.');\n\t\t\t}else{\n\t\t\t\tns[0]=(j%2==0?'#':'.')+s[0];\n\t\t\t\tns[1]=(j/2==0?'#':'.')+s[1];\n\t\t\t}\n\t\t\tif(query(ns[0],ns[1])){\n\t\t\t\tdone=1;\n\t\t\t\ts[0]=ns[0],s[1]=ns[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!done){\n\t\t\tassert(forward);\n\t\t\tforward=0;\n\t\t\ti--;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n#include<numeric>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\nusing ulong = unsigned long;\nusing ll = long long;\nconst int M = 1e9 + 7;\n#pragma unused(M)\n\nint main(){\n\tint n;\n\tcin >> n;\n\tstring s1, s2;\n\tchar q[2][4] = {\n\t\t{'.', '.', '#', '#',},\n\t\t{'.', '#', '.', '#',},\n\t};\n\tstring ans;\n\tbool next = false;\n\t//right\n\twhile(!next){\n\t\ts1 += ' '; s2 += ' ';\n\t\tfor(int i=0;i<4;i++){\n\t\t\ts1.back() = q[0][i];\n\t\t\ts2.back() = q[1][i];\n\t\t\tcout << s1 << '\\n' << s2 << endl;\n\t\t\tcin >> ans;\n\t\t\tif(ans == \"F\"){\n\t\t\t\tif(i == 3){\n\t\t\t\t\tnext = true;\n\t\t\t\t\ts1.pop_back();\n\t\t\t\t\ts2.pop_back();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}else if(ans == \"T\"){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t//left\n\twhile(1){\n\t\ts1 = ' ' + s1; s2 = ' ' + s2;\n\t\tfor(int i=0;i<4;i++){\n\t\t\ts1[0] = q[0][i];\n\t\t\ts2[0] = q[1][i];\n\t\t\tcout << s1 << '\\n' << s2 << endl;\n\t\t\tcin >> ans;\n\t\t\tif(ans == \"F\"){\n\t\t\t\tcontinue;\n\t\t\t}else if(ans == \"T\"){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint main(){\n\tint N;\n\tcin >> N;\n\tstring c[2];\n\twhile(true){\n\t\tvector<vector<string>> lst;\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] += (k>>0&1?\".\":\"#\");\n\t\t\tb[1] += (k>>1&1?\".\":\"#\");\n\t\t\tlst.push_back(b);\n\t\t}\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] = (k>>0&1?\".\":\"#\") + b[0];\n\t\t\tb[1] = (k>>1&1?\".\":\"#\") + b[1];\n\t\t\tlst.push_back(b);\n\t\t}\n\t\trandom_shuffle(lst.begin(),lst.end());\n\t\tfor(int i = 0 ; i < 8 ; i++){\n\t\t\tvector<string> b = lst[i];\n\t\t\tif( i == 7 ){\n\n\t\t\t\tc[0] = b[0];\n\t\t\t\tc[1] = b[1];\n\t\t\t\tif( c[0].size() == N ){\n\t\t\t\t\tcout << c[0] << endl;\n\t\t\t\t\tcout << c[1] << endl;\t\n\t\t\t\t\tstring res;\n\t\t\t\t\tcin >> res;\t\t\t\n\t\t\t\t\tassert(res==\"end\");\n\t\t\t\t\treturn 0;\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcout << b[0] << endl;\n\t\t\t\tcout << b[1] << endl;\n\t\t\t\tstring res;\n\t\t\t\tcin >> res;\n\t\t\t\tif( res == \"T\" ){\n\t\t\t\t\tc[0] = b[0];\n\t\t\t\t\tc[1] = b[1];\n\t\t\t\t\tbreak;\t \n\t\t\t\t}\n\t\t\t\tif( res == \"end\"){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nbool stop = false;\nvoid dfs(string s1, string s2) {\n    if(s1.size() == N) return;\n    if (stop) return;\n    string res;\n    rep(i, 2) rep(j, 2) {\n        if (stop) return;\n        char c1 = i == 0 ? '.' : '#';\n        char c2 = j == 0 ? '.' : '#';\n        auto t1 = s1 + c1;\n        auto t2 = s2 + c2;\n        printf(\"%s\\n%s\\n\", t1.c_str(), t2.c_str()); fflush(stdout);\n        cin >> res;\n        if (res == \"end\") {\n            stop = true;\n            break;\n        }\n        if (res == \"T\") {\n            dfs(t1, t2);\n        }\n    }\n}\nint main() {\n    cin >> N;\n    dfs(\"\", \"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ここからテンプレート\n//#define PLASMA_NO_BOOST\n#if 1\n\n#include<iostream>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<type_traits>\n#include<tuple>\n#include<memory>\n#include<iterator>\n#include<string>\n#include<functional>\n#include<list>\n#include<array>\n#include<complex>\n#include<numeric>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<random>\n#include<map>\n#include<chrono>\n#include<stack>\n#include<set>\n\n#ifndef PLASMA_NO_BOOST\n#include<boost/optional.hpp>\n#include<boost/optional/optional_io.hpp>\n#include<boost/variant.hpp>\n#include<boost/range/adaptor/transformed.hpp>\n#include<boost/range/adaptor/indexed.hpp>\n#include<boost/range/adaptor/filtered.hpp>\n#include<boost/range/algorithm.hpp>\n#include<boost/range/irange.hpp>\n#include<boost/multi_array.hpp>\n#include<boost/preprocessor.hpp>\n#endif\n\ntypedef long long int int64;\ntypedef unsigned long long uint64;\ntypedef long double double64;\n\n#ifdef PLASMA_NO_BOOST\nstruct none_t {};\nconstexpr none_t none{};\ntemplate<class T>class optional\n{\n\tunion inside_t\n\t{\n\t\tT value;\n\t\tnone_t ignore;\n\t\tconstexpr inside_t(T const& v) :value(v) {}\n\t\tconstexpr inside_t(T&& v) : value(std::move(v)) {}\n\t\tconstexpr inside_t(none_t) : ignore(none) {}\n\t\tconstexpr inside_t() : ignore(none) {}\n\t\tconstexpr inside_t(inside_t const&) = default;\n\t\tinside_t(inside_t&&) = default;\n\t\tinside_t& operator=(inside_t const&) = default;\n\t\tinside_t& operator=(inside_t&&) = default;\n\t\t~inside_t() = default;\n\t};\n\tinside_t inside;\n\tbool flag;\npublic:\n\tvoid swap(optional&& v)\n\t{\n\t\tstd::swap(this->inside, v.inside);\n\t\tstd::swap(this->flag, v.flag);\n\t}\n\tvoid reset()\n\t{\n\t\tif (flag)\n\t\t{\n\t\t\tinside.value.~T();\n\t\t\tinside.ignore = none;\n\t\t\tflag = false;\n\t\t}\n\t}\n\n\tconstexpr optional(T const& v) :inside(v), flag(true) {}\n\tconstexpr optional(T&& v) : inside(std::move(v)), flag(true) {}\n\tconstexpr optional(none_t) : inside(), flag(false) {}\n\tconstexpr optional() : inside(), flag(false) {}\n\tconstexpr optional(optional const& v) : inside(v.inside), flag(v.flag) {}\n\toptional(optional&& v) : optional()\n\t{\n\t\tswap(std::move(v));\n\t}\n\toptional& operator=(optional const& v)\n\t{\n\t\tthis->inside = v.inside;\n\t\tthis->flag = v.flag;\n\t\treturn *this;\n\t}\n\toptional& operator=(optional&& v)\n\t{\n\t\tswap(std::move(v));\n\t\tv.reset();\n\t\treturn *this;\n\t}\n\toptional& operator=(T const& v)\n\t{\n\t\treset();\n\t\tinside.value = v;\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(T&& v)\n\t{\n\t\treset();\n\t\tinside.value = std::move(v);\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(none_t)\n\t{\n\t\treset();\n\t\treturn *this;\n\t}\n\n\tconstexpr operator bool()const\n\t{\n\t\treturn flag;\n\t}\n\tconstexpr T const& operator*()const\n\t{\n\t\treturn flag ? inside.value : throw std::domain_error(\"optional error: dont have value\");\n\t}\n};\ntemplate<class T>constexpr optional<typename std::remove_reference<typename std::remove_const<T>::type>::type>make_optional(T&& v)\n{\n\treturn optional<std::remove_reference_t<std::remove_const_t<T>>>(std::forward<T>(v));\n}\n#else\nusing boost::optional;\nusing boost::none_t;\nusing boost::none;\n#endif\n\n#ifndef PLASMA_NO_BOOST\nnamespace adaptor\n{\n\tusing namespace boost::adaptors;\n}\nnamespace algorithm\n{\n\tusing namespace boost::range;\n\ttemplate<class SinglePassRange, class Pred>bool any_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::any_of(std::begin(range), std::end(range), pred);\n\t}\n\ttemplate<class SinglePassRange, class Pred>bool all_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::all_of(std::begin(range), std::end(range), pred);\n\t}\n}\n#endif\nnamespace math\n{\n\ttemplate<class T>constexpr T pow(T p, int n)\n\t{\n\t\treturn n == 0 ? T(1) : n == 1 ? p : n == 2 ? p*p : n % 2 == 0 ? pow(pow(p, n / 2), 2) : pow(pow(p, n / 2), 2)*p;\n\t}\n\n\tint log(long long int p, int n)\n\t{\n\t\tint64 t = n;\n\t\tfor (int i = 0;;++i)\n\t\t{\n\t\t\tif (t > p)\n\t\t\t\treturn i;\n\t\t\tt *= n;\n\t\t}\n\t}\n\n\tconstexpr double pi = 3.141592653589793;\n\n\tnamespace detail\n\t{\n\t\tint gcd(int larger, int less)\n\t\t{\n\t\t\treturn less == 0 ? larger : gcd(less, larger%less);\n\t\t}\n\t}\n\n\tint gcd(int lhs, int rhs)\n\t{\n\t\treturn lhs < rhs ? detail::gcd(rhs, lhs) : detail::gcd(lhs, rhs);\n\t}\n\n\tvoid fourier_transform(\n\t\tstd::vector<std::complex<double>>& vec, std::size_t N)\n\t{\n\t\tstd::vector<std::complex<double>> butterfly;\n\t\tvec.resize(N);\n\t\tbutterfly.resize(N);\n\n\t\tstd::complex<double> half(std::cos(pi), std::sin(pi));\n\t\tfor (uint64 i = 1, k = N / 2;i < N;[&]() {i *= 2;k /= 2;}())//i*k == N/4\n\t\t{\n\t\t\tstd::complex<double> circle(std::cos(pi / i), std::sin(pi / i));\n\t\t\tstd::complex<double> c(1.0, 0);\n\t\t\tfor (auto count = 0ull; count < i;++count)\n\t\t\t{\n\t\t\t\tfor (auto j = 0ull;j < k;++j)\n\t\t\t\t{\n\t\t\t\t\tbutterfly[count*k + j] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c;\n\t\t\t\t\tbutterfly[count*k + j + N / 2] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c*half;\n\t\t\t\t}\n\t\t\t\tc *= circle;\n\t\t\t}\n\t\t\tstd::swap(vec, butterfly);\n\t\t}\n\t}\n\n\tclass polynomial\n\t{\n\t\tstd::vector<std::complex<double>> value;\n\t\tvoid swap(polynomial&& p)\n\t\t{\n\t\t\tstd::swap(value, p.value);\n\t\t}\n\tpublic:\n\t\tpolynomial() :value{ 0.0 } {}\n\t\tpolynomial(polynomial const&) = default;\n\t\tpolynomial(std::vector<std::complex<double>>&& vec) :value(std::move(vec)) {}\n\t\tpolynomial(polynomial&& p) :polynomial()\n\t\t{\n\t\t\tswap(std::move(p));\n\t\t}\n\t\tpolynomial(std::initializer_list<std::complex<double>> lis) :value(lis) {}\n\t\tpolynomial(std::complex<double> c) :polynomial({ c }) {}\n\n\t\tpolynomial& operator=(polynomial const&) = default;\n\t\tpolynomial& operator=(polynomial&& p)\n\t\t{\n\t\t\tvalue = std::vector<std::complex<double>>{ 0.0 };\n\t\t\tswap(std::move(p));\n\t\t\treturn *this;\n\t\t}\n\n\t\t~polynomial() = default;\n\t\tstd::complex<double> operator[](std::size_t deg)const\n\t\t{\n\t\t\treturn deg >= value.size() ? 0.0 : value[deg];\n\t\t}\n\t\tstd::size_t degree()const\n\t\t{\n\t\t\treturn value.size() - 1;\n\t\t}\n\t\tvoid strict_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tif (value[N] != 0.0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\t\tvoid integer_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tstd::cout << value[N] << \" \" << (std::norm(value[N]) > (1.0e-20)) << std::endl;\n\t\t\t\tif (std::norm(value[N]) > (1.0e-20))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\n\t\tfriend polynomial operator*(polynomial const& lhs, polynomial const& rhs)\n\t\t{\n\t\t\tstd::size_t N = 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tN *= 2;\n\t\t\t\tif (N > (lhs.degree() + rhs.degree()))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto lhs_ = lhs.value;\n\t\t\tauto rhs_ = rhs.value;\n\t\t\tfourier_transform(lhs_, N);\n\t\t\tfourier_transform(rhs_, N);\n\t\t\tstd::vector<std::complex<double>> vec;\n\t\t\tvec.reserve(N);\n\t\t\tfor (std::size_t i = 0;i < N;++i)\n\t\t\t{\n\t\t\t\tvec.push_back(lhs_[i] * rhs_[i]);\n\t\t\t}\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = 2 * v.real() - v;\n\t\t\t}\n\t\t\tfourier_transform(vec, N);\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = (2 * v.real() - v)*(1.0 / N);\n\t\t\t}\n\t\t\tstd::size_t k = N;\n\t\t\tfor (;k > 0;--k)\n\t\t\t{\n\t\t\t\tif (std::norm(vec[k]) > 1.0e-23)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec.resize(k + 1);\n\t\t\treturn polynomial(std::move(vec));\n\t\t}\n\t};\n\n\tint real_integer(std::complex<double> c)\n\t{\n\t\tint v = static_cast<int>(c.real());\n\t\tdouble u = c.real() - v;\n\t\treturn v + static_cast<int>(2 * u);\n\t}\n\n\ttemplate<class T>polynomial make_poly(std::vector<T> const& vec)\n\t{\n\t\tauto range = vec | adaptor::transformed([](T const& v) {return static_cast<std::complex<double>>(v);});\n\t\tstd::vector<std::complex<double>> ret(std::begin(range), std::end(range));\n\t\treturn polynomial(std::move(ret));\n\t}\n\tpolynomial make_poly(std::initializer_list<double>init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\tpolynomial make_poly(std::initializer_list<int> init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\ttemplate<class T>class infinite_value\n\t{\n\t\toptional<T> val;\n\tpublic:\n\t\tinfinite_value(T const& v) :val(v) {}\n\t\tinfinite_value(T&& v) :val(std::move(v)) {}\n\t\tinfinite_value(none_t = none) :val() {}\n\t\tinfinite_value(infinite_value const&) = default;\n\t\tinfinite_value(infinite_value&&) = default;\n\t\t~infinite_value() = default;\n\n\t\tinfinite_value& operator=(T const& v)\n\t\t{\n\t\t\tval = v;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(T&& v)\n\t\t{\n\t\t\tval = std::move(v);\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(none_t)\n\t\t{\n\t\t\tval = boost::none;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(infinite_value const&) = default;\n\t\tinfinite_value& operator=(infinite_value&&) = default;\n\n\t\toperator bool()const\n\t\t{\n\t\t\treturn static_cast<bool>(val);\n\t\t}\n\t\tT const& operator*()const\n\t\t{\n\t\t\treturn *val;\n\t\t}\n\n\t\tfriend infinite_value operator+(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs ? infinite_value<T>(*lhs + rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\n\t\tfriend bool operator==(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (!lhs && !rhs) || (lhs&&rhs && (*lhs == *rhs));\n\t\t}\n\t\tfriend bool operator==(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs && (*lhs == rhs);\n\t\t}\n\t\tfriend bool operator==(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn rhs && (lhs == *rhs);\n\t\t}\n\n\n\t\tfriend bool operator<(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : !rhs ? true : *lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : *lhs < rhs;\n\t\t}\n\t\tfriend bool operator<(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? true : lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\n\n\t\tfriend bool operator>(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn  !rhs ? false : !lhs ? true : *lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? true : *lhs > rhs;\n\t\t}\n\t\tfriend bool operator>(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? false : lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\n\t};\n\ttemplate<std::size_t Mod>class modulo_number\n\t{\n\t\tuint64 val = {};\n\t\tstatic constexpr uint64 abs(int64 n)\n\t\t{\n\t\t\treturn n <= -1 ? n + Mod : n;\n\t\t}\n\tpublic:\n\t\tmodulo_number(modulo_number const&) = default;\n\t\tmodulo_number(modulo_number&&) = default;\n\t\tmodulo_number& operator=(modulo_number const&) = default;\n\t\tmodulo_number& operator=(modulo_number&&) = default;\n\t\t~modulo_number() = default;\n\n\t\tconstexpr modulo_number(uint64 num = {}) : val(num%Mod) {}\n\t\tconstexpr modulo_number(unsigned int num) : val(num%Mod) {}\n\t\tconstexpr modulo_number(int64 num) : val(abs(num%Mod)) {}\n\t\tconstexpr modulo_number(int num) : val(abs(num%Mod)) {}\n\n\t\tmodulo_number& operator=(uint64 num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int64 num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(unsigned int num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn val;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + Mod - rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val*rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn lhs*math::pow(rhs, Mod - 2);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\n\t\ttemplate<class Rhs>decltype(auto) operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator/=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this / rhs;\n\t\t}\n\t};\n\n\ttemplate<class T>constexpr T factorial(std::size_t n, std::size_t goal = 1)\n\t{\n\t\treturn n == goal ? T(n) : n == 0 ? T(1) : factorial<T>(n, (n + goal) / 2 + 1)*factorial<T>((n + goal) / 2, goal);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr uint64 integral_sqrt_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? start :\n\t\t\t\tpow((start + end) / 2 + 1, 2) <= v ?\n\t\t\t\tintegral_sqrt_i(v, (start + end) / 2 + 1, end) :\n\t\t\t\tintegral_sqrt_i(v, start, (start + end) / 2);\n\t\t}\n\t}\n\n\tconstexpr uint64 integral_sqrt(uint64 v)\n\t{\n\t\treturn v == 0 ? 0 :\n\t\t\tv == 1 ? 1 :\n\t\t\tdetail::integral_sqrt_i(v, 1, 0b100000000000000000000000000000000ull);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr bool is_prime_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? v%end != 0 :\n\t\t\t\tis_prime_i(v, start, (start + end) / 2) &&\n\t\t\t\tis_prime_i(v, (start + end) / 2 + 1, end);\n\t\t}\n\t}\n\n\tconstexpr bool is_prime(uint64 v)\n\t{\n\t\treturn v == 0 ? false :\n\t\t\tv == 1 ? false :\n\t\t\tv == 2 ? true :\n\t\t\tv == 3 ? true : detail::is_prime_i(v, 2, integral_sqrt(v));\n\t}\n\n\tclass dynamic_modulo\n\t{\n\t\tuint64 value;\n\t\tuint64 mod;\n\t\tstatic constexpr uint64 abs(int64 v, uint64 mod)\n\t\t{\n\t\t\treturn v <= -1 ? v + mod : v;\n\t\t}\n\tpublic:\n\t\tconstexpr dynamic_modulo() :value(), mod(2) {}\n\t\tconstexpr dynamic_modulo(uint64 v, uint64 m) : value(v), mod(m) {}\n\t\tdynamic_modulo(dynamic_modulo const&) = default;\n\t\tdynamic_modulo(dynamic_modulo&&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo const&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo&&) = default;\n\t\t~dynamic_modulo() = default;\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value + rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value * rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo(abs((lhs.value - rhs.value) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\ttemplate<class Rhs>dynamic_modulo& operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t};\n}\nnamespace geometry\n{\n\ttemplate<class Type>struct point\n\t{\n\t\tType x, y;\n\t};\n\ttemplate<class Type>auto make_point(Type x, Type y)\n\t{\n\t\treturn point<Type>{x, y};\n\t}\n\ttemplate<class Type>auto operator+(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x + rhs.x, lhs.y + rhs.y);\n\t}\n\ttemplate<class Type>auto operator-(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x - rhs.x, lhs.y - rhs.y);\n\t}\n\ttemplate<class Point>struct box\n\t{\n\t\tPoint small, large;\n\t};\n\ttemplate<class Point>auto make_box(Point a, Point b)\n\t{\n\t\treturn box<Point>{\n\t\t\tmake_point(std::min(a.x, b.x), std::min(a.y, b.y)),\n\t\t\t\tmake_point(std::max(a.x, b.x), std::max(a.y, b.y))};\n\t}\n#ifndef  PLASMA_NO_BOOST\n\ttemplate<class Point>boost::optional<box<Point>> hit_check(box<Point> a, box<Point> b)\n\t{\n\t\tif (a.small.x > b.small.x)\n\t\t\tstd::swap(a, b);\n\t\tif (a.large.x < b.small.x)\n\t\t\treturn boost::none;\n\t\tauto small_x = b.small.x;\n\t\tauto large_x = std::min(b.large.x, a.large.x);\n\t\tif (a.small.y < b.small.y)\n\t\t{\n\t\t\tif (b.small.y < a.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, b.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a.small.y < b.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, a.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t}\n#endif\n}\nnamespace graph_traits\n{\n\tclass graph\n\t{\n\t\tstd::vector<int64> node_data;\n\t\tstd::vector<std::vector<std::pair<int, int64>>> edge_data;\n\tpublic:\n\t\tgraph() = default;\n\t\tgraph(std::vector<int64>&& n) :node_data(std::move(n)), edge_data{}\n\t\t{\n\t\t\tedge_data.resize(node_data.size());\n\t\t}\n\t\tgraph(std::size_t size) :node_data(size), edge_data{}\n\t\t{\n\n\t\t}\n\n\t\tvoid resize(int size)\n\t\t{\n\t\t\tnode_data.resize(size);\n\t\t\tedge_data.resize(size);\n\t\t}\n\t\tvoid edge_reserve(int size)\n\t\t{\n\t\t\tfor (auto& v : edge_data)\n\t\t\t{\n\t\t\t\tv.reserve(size);\n\t\t\t}\n\t\t}\n\n\t\tvoid add_node(int64 data)\n\t\t{\n\t\t\tnode_data.emplace_back(data);\n\t\t\tedge_data.emplace_back();\n\t\t}\n\t\tvoid add_edge(int from, int to, int64 data)\n\t\t{\n\t\t\tedge_data[from].emplace_back(to, data);\n\t\t}\n\t\tstd::vector<math::infinite_value<int64>> dijkstra(int from)const\n\t\t{\n\t\t\tstruct compare\n\t\t\t{\n\t\t\t\tbool operator()(\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& lhs,\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& rhs)const\n\t\t\t\t{\n\t\t\t\t\treturn lhs.second > rhs.second;\n\t\t\t\t}\n\t\t\t};\n\t\t\tstd::priority_queue<\n\t\t\t\tstd::pair<int, math::infinite_value<int64>>,\n\t\t\t\tstd::vector<std::pair<int, math::infinite_value<int64>>>,\n\t\t\t\tcompare>nodes;\n\t\t\tstd::vector<math::infinite_value<int64>> ret(node_data.size());\n\t\t\tfor (int i{};i < node_data.size();++i)\n\t\t\t{\n\t\t\t\tnodes.emplace(i, math::infinite_value<int64>());\n\t\t\t}\n\t\t\tnodes.emplace(from, int());\n\n\t\t\twhile (nodes.size())\n\t\t\t{\n\t\t\t\tauto p = nodes.top();\n\t\t\t\tnodes.pop();\n\t\t\t\tif (ret[p.first] <= p.second)\n\t\t\t\t\tcontinue;\n\t\t\t\tret[p.first] = p.second;\n\t\t\t\tfor (auto const& d : edge_data[p.first])\n\t\t\t\t{\n\t\t\t\t\tnodes.emplace(d.first, std::min(ret[d.first], ret[p.first] + d.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint64 operator[](int n)const\n\t\t{\n\t\t\treturn node_data[n];\n\t\t}\n\t};\n}\nnamespace container\n{\n\ttemplate<class T>using p_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n}\n\nvoid Main();\n#endif//テンプレートここまで\n//ここを書き換える\n#define PROBLEM 4\n\n//ここは書き換えない\nint main()\n{\n\tstd::cin.sync_with_stdio(false);\n\tstd::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1);\n\tMain();\n}\n\n#if BOOST_PP_EQUAL(PROBLEM, 1)\n\nvoid Main()\n{\n\tint N, A, B;\n\tstd::cin >> N >> A >> B;\n\tcontainer::p_queue<int> t;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint x;\n\t\tstd::cin >> x;\n\t\tt.emplace(x);\n\t}\n\tint size{};\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t\telse if (x >= A)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t++size;\n\t}\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tstd::cout << size << std::endl;\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 2)\n\nvoid Main()\n{\n\tint N, K;\n\tstd::cin >> N >> K;\n\tstd::array<int, 26>count = {};\n\tfor (int i{};i < N;++i)\n\t{\n\t\tstd::string str;\n\t\tstd::cin >> str;\n\t\t++count[str.front() - 'A'];\n\t}\n\tint loop{};\n\twhile (true)\n\t{\n\t\talgorithm::sort(count, std::greater<>());\n\t\tfor (int i{};i < K;++i)\n\t\t{\n\t\t\tif (count[i])\n\t\t\t{\n\t\t\t\t--count[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::cout << loop << std::endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t++loop;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 3)\n\nvoid Main()\n{\n\tstd::vector<std::pair<int,int>> table;\n\tfor (int i{};i < 128;++i)\n\t{\n\t\tint max{};\n\t\tint y{};\n\t\tfor (int j{};j < 128;++j)\n\t\t{\n\t\t\tif (max <= (i^j) + j - i)\n\t\t\t{\n\t\t\t\tmax = (i^j) + j - i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\ttable.emplace_back(std::make_pair(y, max));\n\t}\n\talgorithm::sort(table, std::greater<>());\n\tint N;\n\tstd::cin >> N;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint C, D;\n\t\tstd::cin >> C >> D;\n\t\tstd::vector<int> cookie = { D };\n\t\tint now = D;\n\t\tfor (int x = 1;x < C;++x)\n\t\t{\n\t\t\tint target{};\n\t\t\tint max{};\n\t\t\tfor (int index{};index < cookie.size();++index)\n\t\t\t{\n\t\t\t\tif (max < table[cookie[index]].second)\n\t\t\t\t{\n\t\t\t\t\tmax = table[cookie[index]].second;\n\t\t\t\t\ttarget = index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow += max;\n\t\t\tcookie.emplace_back(table[cookie[target]].first);\n\t\t\tcookie[target] ^= table[cookie[target]].first;\n\t\t}\n\t\tstd::cout << now << std::endl;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 4)\n\nvoid Main()\n{\n\tint N;\n\tstd::cin >> N;\n\tstd::vector<std::pair<char, char>> basic;\n\tstd::vector<std::pair<std::string, std::string>> data;\n\tstd::string ret;\n\tfor (auto x1 : { '.','#' })for (auto x2 : { '.','#' })\n\t{\n\t\tstd::cout << x1 << std::endl << x2 << std::endl;\n\t\tstd::cin >> ret;\n\t\tif (ret == \"T\")\n\t\t{\n\t\t\tbasic.emplace_back(x1, x2);\n\t\t\tdata.emplace_back(x1, x2);\n\t\t}\n\t\telse if (ret == \"end\")\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (true)\n\t{\n\t\tstd::vector<std::pair<std::string, std::string>> impl;\n\t\tfor (auto const& c : basic)for (auto const& s : data)\n\t\t{\n\t\t\tstd::cout << s.first + c.first << std::endl << s.second + c.second << std::endl;\n\t\t\tstd::cin >> ret;\n\t\t\tif (ret == \"T\")\n\t\t\t{\n\t\t\t\timpl.emplace_back(s.first + c.first, s.second + c.second);\n\t\t\t}\n\t\t\telse if (ret == \"end\")\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tstd::swap(impl, data);\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 5)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 6)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 7)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 8)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 9)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 10)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 11)\n\nvoid Main()\n{\n\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n%s\\n\", u.c_str(), d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  int cnt = 0;\n  int sw = 0;\n  while (true) {\n    int j;\n    for (j = 0; j < 4; ++j) {\n      ++cnt;\n      string r = (sw == 0 ? ask(u + du[j], d + dd[j]) : ask(du[j] + u, dd[j] + d));\n      if (r == \"end\") {\n        assert(cnt <= 420);\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    if (j == 5) {\n      assert(sw == 0);\n      sw = 1 - sw;\n      continue;\n    }\n    if (sw == 0) {\n      u += du[j];\n      d += dd[j];\n    } else {\n      u = du[j] + u;\n      d = dd[j] + d;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define each(i, c) for (auto& i : c)\n#define unless(cond) if (!(cond))\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned long long ull;\ntypedef complex<double> point;\n\ntemplate<typename P, typename Q>\nostream& operator << (ostream& os, pair<P, Q> p)\n{\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n\nstruct K {\n  string s, t;\n  K(){}\n  K(string _s, string _t) : s(_s), t(_t) {}\n};\n\nK operator + (const K& a, const K& b)\n{\n  K c;\n  c.s = a.s + b.s;\n  c.t = a.t + b.t;\n  return c;\n}\n\nostream& operator << (ostream& os, const K& k)\n{\n  os << k.s << endl;\n  os << k.t << endl;\n  return os;\n}\n\nint main(int argc, char *argv[])\n{\n  int n;\n  while (cin >> n) {\n    K a(\".\", \".\");\n    K b(\".\", \"#\");\n    K c(\"#\", \".\");\n    K d(\"#\", \"#\");\n    vector<K> v;\n    {\n      char x;\n      cout << a << flush;\n      cin >> x;\n      if (x == 'T') v.push_back(a);\n\n      cout << b << flush;\n      cin >> x;\n      if (x == 'T') v.push_back(b);\n\n      cout << c << flush;\n      cin >> x;\n      if (x == 'T') v.push_back(c);\n\n      cout << d << flush;\n      cin >> x;\n      if (x == 'T') v.push_back(d);\n    }\n\n    K ans = v[0];\n    // right\n    while (true) {\n      bool f = false;\n      each (k, v) {\n        K n = ans + k;\n        cout << n << flush;\n        char c;\n        cin >> c;\n        if (c == 'e') exit(0);\n        if (c == 'T') {\n          f = true;\n          ans = n;\n          break;\n        }\n      }\n      if (!f) break;\n    }\n    // left\n    while (true) {\n      bool f = false;\n      each (k, v) {\n        K n = k + ans;\n        cout << n << flush;\n        char c;\n        cin >> c;\n        if (c == 'e') exit(0);\n        if (c == 'T') {\n          f = true;\n          ans = n;\n          break;\n        }\n      }\n      if (!f) break;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-9;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)(n); i++)\n#define Loopr(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\nbool nearlyeq(double x, double y) { return abs(x - y) < eps; }\nbool inrange(int x, int t) { return x >= 0 && x < t; }\nbool inrange(vi xs, int t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\nvoid pr(const vector<deque<int>> &board, int j0, int j1, bool flag) {\n\tif (!flag) {\n\t\tif (j0 == 1) cout << '#';\n\t\telse cout << '.';\n\t}\n\tLoop(j, board[0].size()) {\n\t\tif (board[0][j] == 1) cout << '#';\n\t\telse cout << '.';\n\t}\n\tif (flag) {\n\t\tif (j0 == 1) cout << '#';\n\t\telse cout << '.';\n\t}\n\tcout << endl;\n\tif (!flag) {\n\t\tif (j1 == 1) cout << '#';\n\t\telse cout << '.';\n\t}\n\tLoop(j, board[1].size()) {\n\t\tif (board[1][j] == 1) cout << '#';\n\t\telse cout << '.';\n\t}\n\tif (flag) {\n\t\tif (j1 == 1) cout << '#';\n\t\telse cout << '.';\n\t}\n\tcout << endl;\n}\n\nint main() {\n  \tquickio();\n\tint n; cin >> n;\n\tvector<deque<int>> board(2);\n\tbool flag = true;\n\tLoop(unused, 420) {\n\t\tint x0 = -1, x1 = -1;\n\t\tLoop(j0, 2) {\n\t\t\tLoop(j1, 2) {\n\t\t\t\tpr(board, j0, j1, flag);\n\t\t\t\tstring res; cin >> res;\n\t\t\t\tif (res == \"T\") {\n\t\t\t\t\tx0 = j0;\n\t\t\t\t\tx1 = j1;\n\t\t\t\t}\n\t\t\t\telse if (res == \"end\") {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (x0 == -1) {\n\t\t\tflag = false;\n\t\t}\n\t\telse {\n\t\t\tif (flag) {\n\t\t\t\tboard[0].push_back(x0);\n\t\t\t\tboard[1].push_back(x1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboard[0].push_front(x0);\n\t\t\t\tboard[1].push_front(x1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\nstring d[2]={{\".#.#\"},{\"..##\"}};\n\nint main(){\n\tint n;\n\tcin>>n;\n\t\n\t\n\tstring ans[2]={\"\",\"\"};\n\tbool left = false;\n\twhile(1){\n\t\tbool f=false;\n\t\trep(i,4){\n\t\t\tif(left==false)\tcout<< ans[0]+d[0][i] <<'\\n'<< ans[1]+d[1][i] <<endl;\n\t\t\telse\t\t\tcout<< d[0][i]+ans[0] <<'\\n'<< d[1][i]+ans[1] <<endl;\n\t\t\tstring res;\n\t\t\tcin>>res;\n\t\t\tif(res==\"end\")return 0;\n\t\t\tif(res==\"T\"){\n\t\t\t\tans[0] += d[0][i];\n\t\t\t\tans[1] += d[1][i];\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f==false)left=true;\n\t\tif(ans[0].size()==n)break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstring query(pair<string,string> p1,pair<string,string> p2){\n  string s1,s2;\n  s1 = p1.first + p2.first;\n  s2 = p1.second + p2.second;\n  printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n  string str;\n  cin >> str;\n  return str;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  vector<vector<pair<string,string> > >vec;\n  for(int i = 0 ; i < 2 ; i++){\n    string str1;\n    string str2;\n    for(int j = 0 ; j < 4 ; j++){\n      str1 += (j%2?\".\":\"#\");\n      str2 += ((j >> 1)%2?\".\":\"#\");\n    }\n    vector<pair<string,string> v;\n    v.push_back(make_pair(str1,str2));\n    vec.push_back(v);\n  }\n  \n  while(1){\n    for(int i = 0 ; i < vec.size() ; i++){\n      for(int j = i ; j < vec.size() ; j++){\n\tfor(int k = 0 ; k < 2 ; k++){\n\t  string r;\n\t  pair<string,string>p;\n\t  if(k % 2){\n\t    r = query(vec[i],vec[j]);\n\t    p = make_pair(vec[i].first + vec[j].first,vec[i].second + vec[j].second);\n\t  }\n\t  else {\n\t    r = query(vec[j],vec[i]);\n\t    p = make_pair(vec[j].first + vec[i].first,vec[j].second + vec[i].second);\n\t  }\n\t  // in\n\t  if(r == \"T\"){\n\t    vec.push_back(p);\n\t  }\n\t  else if(r == \"end\"){\n\t    return 0;\n\t  }\n\t}\n      }\n    }\n  }\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\nusing namespace std;\nint n,flg=1;\nstring upp[4]={\".\",\".\",\"#\",\"#\"}, dwn[4]={\".\",\"#\",\"#\",\".\"}, lst[2],nw[2];\nchar ss[4];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\nint main()\n{\n\t//freopen(\"Long Blackboard.in\",\"r\",stdin);\n\tread(n);\n\twhile( true )\n\t{\n\t\tfor(RG int i=0;i<4;i++)\n\t\t{\n\t\t\tnw[0]= flg ? lst[0]+upp[i] : upp[i]+lst[0];\n\t\t\tnw[1]= flg ? lst[1]+dwn[i] : dwn[i]+lst[1];\n\t\t\tcout<<nw[0]<<endl<<nw[1]<<endl;\n\t\t\tscanf(\"%s\",ss);\n\t\t\tif(ss[0]=='T')\n\t\t\t{\n\t\t\t\tlst[0]=nw[0];\n\t\t\t\tlst[1]=nw[1];\n\t\t\t\tif(lst[0].size()==n) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i==3) flg=0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,n,N) for(ll i=n;i<=N;++i)\n#define rap(i,n,N) for(ll i=n;i>=N;--i)\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define fi first\n#define se second\n#define ff fi.fi\n#define fs fi.se\n#define sf se.fi\n#define ss se.se\n#define lc (id<<1)\n#define rc ((id<<1)|1)\n#define db(x) cout << \">>>>>> \" << #x << \" -> \" << x << endl;\n#define all(x) x.begin(),x.end()\n#define pii pair<int,int> \n#define pll pair<ll,ll>\n#define piii pair<int,pii>\n#define piiii pair<pii,pii>\n#define psi pair<string,int>\n//#define endl \"\\n\"\nconst int MAX = 3e5+5;\nconst ll MAX2 = 11;\nconst ll MOD = 1000000007;\nconst ll INF = 2e18;\nconst int dr[]={1,0,-1,0,1,1,-1,-1,0};\nconst int dc[]={0,1,0,-1,1,-1,1,-1,0};\nconst double pi = acos(-1);\nconst double EPS = 1e-9;\nconst int block = 450;\n\nint n;\nstring a,b,ta,tb,s;\nbool st;\n\nint main(){\n//\tcout<<fixed<<setprecision(15);\n//    freopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n//    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin>>n;\n    while(1){\n    \tif(st){\n    \t\tta = '.'+a, tb = '.'+b;\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n    \t\tta = '.'+a, tb = '#'+b;\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n    \t\tta = '#'+a, tb = '.'+b;\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n    \t\tta = '#'+a, tb = '#'+b;\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t}\n\t\telse {\n\t\t\tta = a+'.', tb = b+'.';\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t\tta = a+'.', tb = b+'#';\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t\tta = a+'#', tb = b+'.';\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t\tta = a+'#', tb = b+'#';\n\t\t\tcout<<ta<<endl<<tb<<endl;\n\t\t\tcin>>s;\n\t\t\tif(s==\"end\")break;\n\t\t\telse if(s==\"T\"){a = ta, b = tb; continue;}\n\t\t\tst = 1;\n\t\t}\n\t}\n\treturn 0;\n}//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=2001;\nchar x[]{'.','.','#','#'},y[]{'.','#','.','#'};\nint main(){\n\tint N;\n\tcin >> N;\n\tstring s1,s2;\n\tstring ret;\n\tbool last=false;\n\tREP(i,N){\n\t\tif(!last)\n\t\t\tREP(j,4){\n\t\t\t\tcout << s1+x[j] <<endl << s2+y[j] << endl;\n\t\t\t\tcin >> ret;\n\t\t\t\tif(ret==\"End\") return 0;\n\t\t\t\tif(ret==\"T\"){\n\t\t\t\t\ts1+=x[j];\n\t\t\t\t\ts2+=y[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ret==\"F\" && j==3){\n\t\t\t\t\tlast=true;\n\t\t\t\t}\n\t\t\t}\n\t\telse{\t\t\n\t\t\tREP(j,4){\n\t\t\t\tcout << s1+x[j] <<endl << s2+y[j] << endl;\n\t\t\t\tcin >> ret;\n\t\t\t\tif(ret==\"End\") return 0;\n\t\t\t\tif(ret==\"T\"){\n\t\t\t\t\ts1=x[j]+s1;\n\t\t\t\t\ts2=y[j]+s2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<algorithm>\n#include<list>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<climits>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\n#include<map>\n#include<set>\n#include<typeinfo>\nusing namespace std;\n\nconst double pi=4*atan(1.0);\n\nconstexpr long long mod=static_cast<long long>(1e9+7);\n\nusing cWeightEdges=vector<vector<pair<int,int>>>;\nusing cEdges=vector<vector<int>>;\n\nbool check(string s1,string s2,int num){\n\tfor(int i=0;i<num;++i){\n\t\tcout<<s1;\n\t}\n\tcout<<\"\\n\";\n\tfor(int i=0;i<num;++i){\n\t\tcout<<s2;\n\t}\n\tcout<<endl;\n\tfflush(stdout);\n\tstring str;\n\tcin>>str;\n\tif(str==\"F\")return false;\n\telse return true;\n}\n\nint getMaxLength(int N,string s1,string s2){\n\tint Min=1,Max=N+1,Mid=0;\n\twhile(1){\n\t\tMid=(Max-Min)/2+Min;\n\t\tbool ans=check(s1,s2,Mid);\n\t\tif(ans){\n\t\t\tif(Min==Mid){\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tMin=Mid;\n\t\t}\n\t\telse{\n\t\t\tif(Min==Mid){\n\t\t\t\tif(Min==1)return 0;\n\t\t\t\telse{\n\t\t\t\t\treturn Max;\n\t\t\t\t}\n\t\t\t}\n\t\t\tMax=Mid;\n\t\t}\n\t}\n}\n\nbool check1(const deque<pair<char,char>>& deq,string s1,string s2){\n\tfor(const auto& val:deq)\n\t\tcout<<val.first;\n\tcout<<s1;\n\tcout<<\"\\n\";\n\tfor(const auto& val:deq)\n\t\tcout<<val.second;\n\tcout<<s2;\n\tcout<<endl;\n\tfflush(stdout);\n\tstring str;\n\tcin>>str;\n\tif(str==\"F\")return false;\n\telse return true;\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tint BB=0,WW=0,WB=0,BW=0;\n\tBB=getMaxLength(N,\"#\",\"#\");\n\tif(BB==N)return 0;\n\tWW=getMaxLength(N,\".\",\".\");\n\tif(WW==N)return 0;\n\tWB=getMaxLength(N,\".\",\"#\");\n\tif(WB==N)return 0;\n\tBW=getMaxLength(N,\"#\",\".\");\n\tif(BW==N)return 0;\n\n\tarray<pair<int,string>,4> a;\n\ta[0]=make_pair(BB,\"##\");\n\ta[1]=make_pair(WW,\"..\");\n\ta[2]=make_pair(WB,\".#\");\n\ta[3]=make_pair(BW,\"#.\");\n\tsort(begin(a),end(a),[](auto x,auto y)->bool{return x.first>y.first;});\n\tint length=a.front().first;\n\tdeque<pair<char,char>> deq(length,make_pair(a.front().second[0],a.front().second[1]));\n\n\twhile(length<N){\n\t\tif(check1(deq,\".\",\".\")){\n\t\t\t++length;\n\t\t\tdeq.push_back(make_pair('.','.'));\n\t\t}\n\t\telse{\n\t\t\tif(check1(deq,\"#\",\"#\")){\n\t\t\t\t++length;\n\t\t\t\tdeq.push_back(make_pair('#','#'));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(check1(deq,\".\",\"#\")){\n\t\t\t\t\t++length;\n\t\t\t\t\tdeq.push_back(make_pair('.','#'));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(check1(deq,\"#\",\".\")){\n\t\t\t\t\t\t++length;\n\t\t\t\t\t\tdeq.push_back(make_pair('#','.'));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(length<N){\n\t\tif(check1(deq,\".\",\".\")){\n\t\t\t++length;\n\t\t\tdeq.push_front(make_pair('.','.'));\n\t\t}\n\t\telse{\n\t\t\tif(check1(deq,\"#\",\"#\")){\n\t\t\t\t++length;\n\t\t\t\tdeq.push_front(make_pair('#','#'));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(check1(deq,\".\",\"#\")){\n\t\t\t\t\t++length;\n\t\t\t\t\tdeq.push_front(make_pair('.','#'));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(check1(deq,\"#\",\".\")){\n\t\t\t\t\t\t++length;\n\t\t\t\t\t\tdeq.push_front(make_pair('#','.'));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <deque>\nusing namespace std;\n#define REP(i,a,n) for(int i = a; i < n; ++i)\n#define EPS 0.0001\n\nint N;\nbool END = false;\ndeque<int> question;\nvoid out(int ch, bool front_flg) {\n\tfront_flg ? question.push_front(ch) : question.push_back(ch);\n\tREP(k, 0, 2) {\n\t\tREP(i, 0, question.size()) {\n\t\t\tcout << ((question[i] & (1 << k)) ? '#': '.');\n\t\t}\n\t\tcout << endl;\n\t}\n\tfront_flg ? question.pop_front() : question.pop_back();\n}\n\nbool in() {\n\tstring a;\n\tcin >> a;\n\tif (a == \"end\") END = true;\n\treturn a[0] != 'F';\n}\n\nvoid query() {\n\tREP(front, 0, 2) {\n\t\tbool flg = true;\n\t\twhile (flg) {\n\t\t\tflg = false;\n\t\t\tREP(ch, 0, 4) {\n\t\t\t\tout(ch, front);\n\t\t\t\tif (in()) {\n\t\t\t\t\tif (END) return;\n\t\t\t\t\tfront ? question.push_front(ch) : question.push_back(ch);\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tcin >> N;\n\tquery();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include<fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tbool left = true;\n\tstd::string s1(\"\"), s2(\"\");\n\tstd::vector<std::string> s({ \"..\", \".#\", \"#.\", \"##\" });\n\twhile (true) {\n\t\tbool f = false;\n\t\tREP(i, 4) {\n\t\t\tif (left) {\n\t\t\t\tOUT(s1)OUT(s[i][0])BR;\n\t\t\t\tOUT(s2)OUT(s[i][1])ENDL;\n\t\t\t\tVAR(char, c);\n\t\t\t\tif (c == 'e') return 0;\n\t\t\t\tif (c == 'T') {\n\t\t\t\t\ts1 += s[i][0];\n\t\t\t\t\ts2 += s[i][1];\n\t\t\t\t\tf = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tOUT(s[i][0])OUT(s1)BR;\n\t\t\t\tOUT(s[i][1])OUT(s2)ENDL;\n\t\t\t\tVAR(char, c);\n\t\t\t\tif (c == 'T') {\n\t\t\t\t\ts1 = s[i][0] + s1;\n\t\t\t\t\ts2 = s[i][1] + s2;\n\t\t\t\t\tf = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f) left = false;\n\t\tif (s1.size() == n) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef long double LD;\ntypedef pair<LD, LD> PLDLD;\ntypedef pair<char, char> PCC;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\nLL MOD = 1e9+7;\nint INF = (1e9) *2+1;\ndouble EPS=1.0e-9;\ndouble PI=atan2(0,-1);\n\nint main()\n{\n    int n;\n    cin>>n;\n    string s1,s2,s=\"T\";\n    bool re=0;\n    while(1)\n    {\n        if(s==\"T\")\n        {\n            if(re)\n            {\n                s1=\".\"+s1;\n                s2=\".\"+s2;\n            }\n            else\n            {\n                s1+=\".\";\n                s2+=\".\";\n            }\n        }\n        else\n        {\n            if(re)\n            {\n                if(s1[0]=='.')\n                {\n                    s1[0]='#';\n                }\n                else\n                {\n                    if(s2[0]=='.')\n                    {\n                        s1[0]='.';\n                        s2[0]='#';\n                    }\n                    else\n                    {\n                        cout<<\"???\"<<endl;\n                    }\n                }\n            }\n            else\n            {\n                if(s1[s1.size()-1]=='.')\n                {\n                    s1[s1.size()-1]='#';\n                }\n                else\n                {\n                    if(s2[s2.size()-1]=='.')\n                    {\n                        s1[s1.size()-1]='.';\n                        s2[s2.size()-1]='#';\n                    }\n                    else\n                    {\n                        re=1;\n                        s1.pop_back();\n                        s2.pop_back();\n                        s=\"T\";\n                        continue;\n                    }\n                }\n            }\n        }\n        cout<<s1<<endl<<s2<<endl;\n        cin>>s;\n        if(s==\"end\") break;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n;\n    cin >> n;\n    string s1, s2;\n    string c;\n    while(s1.length() < n && c != \"end\"){\n        printf(\"%s.\\n%s.\\n\", s1.c_str(), s2.c_str());   fflush(stdout);\n        cin >> c;\n        if (c == \"T\" || c == \"end\"){\n            s1 += '.';\n            s2 += '.';\n            continue;\n        }        \n        printf(\"%s.\\n%s#\\n\", s1.c_str(), s2.c_str());   fflush(stdout);\n        cin >> c;\n        if (c == \"T\" || c == \"end\"){\n            s1 += '.';\n            s2 += '#';\n            continue;\n        }        \n        printf(\"%s#\\n%s.\\n\", s1.c_str(), s2.c_str());   fflush(stdout);\n        cin >> c;\n        if (c == \"T\" || c == \"end\"){\n            s1 += '#';\n            s2 += '.';\n            continue;\n        }\n        printf(\"%s#\\n%s#\\n\", s1.c_str(), s2.c_str());   fflush(stdout);\n        cin >> c;\n        if (c == \"T\" || c == \"end\"){\n            s1 += '#';\n            s2 += '#';\n            continue;\n        }\n        break;\n    }\n    while(s1.length() < n && c != \"end\"){\n        printf(\".%s\\n.%s\\n\", s1.c_str(), s2.c_str());   fflush(stdout);\n        cin >> c;\n        if (c == \"T\" || c == \"end\"){\n            s1 = '.' + s1;\n            s2 = '.' + s2;\n            continue;\n        }        \n        printf(\".%s\\n#%s\\n\", s1.c_str(), s2.c_str());   fflush(stdout);\n        cin >> c;\n        if (c == \"T\" || c == \"end\"){\n            s1 = '.' + s1;\n            s2 = '#' + s2;\n            continue;\n        }        \n        printf(\"#%s\\n.%s\\n\", s1.c_str(), s2.c_str());   fflush(stdout);\n        cin >> c;\n        if (c == \"T\" || c == \"end\"){\n            s1 = '#' + s1;\n            s2 = '.' + s2;\n            continue;\n        }\n        printf(\"#%s\\n#%s\\n\", s1.c_str(), s2.c_str());   fflush(stdout);\n        cin >> c;\n        if (c == \"T\" || c == \"end\"){\n            s1 = '#' + s1;\n            s2 = '#' + s2;\n            continue;\n        }\n        break;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n;\n  cin>>n;\n  string s1,s2;\n  char c1[4]={'.','.','#','#'};\n  char c2[4]={'.','#','.','#'};\n  bool b=true;\n  while(s1.size()<n){\n    bool flag=false;\n    if(b){\n      rep(i,4){\n        cout<<s1<<c1[i]<<endl;\n        cout<<s2<<c2[i]<<endl;\n        string q;\n        cin>>q;\n        if(q[0]=='e') return 0;\n        if(q[0]=='T'){\n          s1+=c1[i];\n          s2+=c2[i];\n          flag=true;\n          break;\n        }\n      }\n      if(!flag) b=false;\n    }else{\n      rep(i,4){\n        cout<<c1[i]<<s1<<endl;\n        cout<<c2[i]<<s2<<endl;\n        string q;\n        cin>>q;\n        if(q[0]=='e') return 0;\n        if(q[0]=='T'){\n          s1=c1[i]+s1;\n          s2=c2[i]+s2;\n          break;\n        }\n      }\n    }\n  }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//諸機能\n#pragma region MACRO \n#define putans(x)  std::cerr << \"answer: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"answer: \"; cout << setprecision(13) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //ファイルからテストデータを読み込む\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //ジャッジシステムでいい感じにやる\n#define put cin >>\n#endif\n#pragma endregion\n\n//デバッグなどの支援\n#pragma region CODING_SUPPORT\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#ifndef _DEBUG\n#define dbg1 {}\n#define dbg2 {}\n#define dbg3 {}\n#define dbgArray {}\n#endif \n#pragma endregion \n//typedef（書き換える、書き足す可能性ある）\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//諸々の定数(書き換える可能性ある)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-9)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(1e9)\n#pragma endregion\n//\n//class Point {//幾何上のべクトル\n//public:\n//\tdouble x, y;\n//\tPoint(double x = 0, double y = 0) : x(x), y(y) {}\n//\n//\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n//\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n//\tPoint operator * (double a) { return Point(x * a, y * a); }\n//\tdouble operator * (Point p) { return dot(p); }\n//\tPoint operator / (double a) { return Point(x / a, y / a); }\n//\n//\tdouble abs() { return sqrt(norm()); }\n//\tdouble norm() { return x*x + y*y; }\n//\n//\tbool operator < (const Point &p) const {return  x != p.x ? x < p.x : y < p.y;}\n//\tbool operator == (const Point &p) const {return  fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;}\n//\t//内積、外積\n//\tdouble dot(Point p) {return x * p.x + y * p.y;}\n//\tdouble cross(Point p) { return x * p.y - y * p.x; }\n//\n//\n//};\n//\n//double abs(Vector p) { return norm(p); }\n//double norm(Vector p) { return p.x * p.x + p.y * p.y; }\n//double dot(Point p, Point q) { return p.x * q.x + p.y * q.y; }\n//double cross(Point p, Point q) { return q.x * p.y - p.y * p.x; }\n//\n//class Circle {\n//public:\n//\tPoint c;\n//\tdouble r;\n//\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n//};\n//struct Segment {//線分\n//\tPoint p1, p2;\n//};\n//\n//typedef Point Vector;\n//typedef Segment Line;//直線\n//typedef vector<Point> Polygon;\n//\n////直行、並行\n//bool isOrthogonal(Vector a, Vector b) { return equals(a*b, 0.0); }\n//bool isParallel(Vector a, Vector b) { return equals(cross(a,b), 0.0); }\n//\n////線分sに対する点pの射影\n//Point projection(Segment s, Point p) {\n//\tVector base = s.p2 - s.p1;\n//\tdouble r = dot((p - s.p1),base) / norm(base);\n//\treturn s.p1 + base*r;\n//}\n////線分sに対する点pの反射\n//Point reflection(Segment s, Point p) {return p + ( projection(s, p) - p ) * 2;}\n//\n//\n\n//\n//double getDistance(Point a, Point b) {return ( a - b ).abs;}\n//double getDistanceLP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1)); }\n//double getDistanceSP(Segment s, Point p) {\n//\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n//\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n//}\n//\n//double getDistance(Segment s1, Segment s2) {\n//\tif (intersect(s1, s2)) return 0;\n//\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2))\n//\t         , min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2));\n//}\n//\n////p1-p0を基準として p2-p0 の2ベクトルについて\n//static const int COUNTER_CLOCKWISE = 1;//反時計回り\n//static const int CLOCKWISE = -1;//時計回り\n//static const int ONLINE_BACK = 2;//同一直線状p2,p0,p1の順\n//static const int ONLINE_FRONT = 1;//同一直線上p0,p1,p2の順\n//static const int ON_SEGMENT = 0;//p2がp0,p1上にある場合\n//int ccw(Point p0, Point p1, Point p2) {//上記の分類関数\n//\tVector a = p1 - p0;\n//\tVector b = p2 - p0;\n//\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n//\tif (cross(a, b) < EPS) return CLOCKWISE;\n//\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n//\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n//\treturn ON_SEGMENT;\n//}\n////線分p1p2とp3p4の交差判定\n//bool intersect(Point p1, Point p2, Point p3, Point p4) {return ( (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0) && (ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0));}\n//bool intersect(Segment s1, Segment s2) {return intersect(s1.p1 , s1.p1, s2.p1, s2.p2);}\n//\n//Point getCrossPoint(Segment s1, Segment s2) {\n//\tVector base = s2.p2 - s2.p1;\n//\tdouble d1 = abs(cross(base , s1.p1 - s2.p1));\n//\tdouble d2 = abs(cross(base , s1.p2 - s2.p1));\n//\tdouble t = d1 / ( d1 + d2 );\n//\treturn s1.p1 + (s1.p2 - s1.p1 ) * t;\n//}\n//\n////直線と円の交点を調べる\n//pair<Point, Point> getCrossPoints(Circle c, Line l) {\n//\t//assert(intersect(c, i)); 交差しない場合についてのはず\n//\tVector pr = projection(c, l);\n//\tVector e = ( l.p2 - l.p1 ) / abs(l.p2 - l.p1);\n//\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n//\treturn mp(pr + e * base, pr - e * base);\n//}\n//\n////点の内包を調べる\n//static const int IN_POLYGON = 2;//多角形の内部\n//static const int OUT_POLYGON = 1;//多角形の外部\n//static const int ON_POLYGON = 0;//多角形の線分上\n//int contains(Polygon g, Point p) {\n//\tint n = g.size();\n//\tbool x = false;\n//\trep(i, n) {\n//\t\tPoint a = g[i] - p, b = g[( i + 1 ) % n] - p;\n//\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return OUT_POLYGON;\n//\t\tif (a.y > b.y) swap(a, b);\n//\t\tif (a.y < EPS && EPS < b.y && cross(a, b)) x = !x;\n//\t}\n//\treturn ( x ? IN_POLYGON : ON_POLYGON );\n//}\n\n//凸包\n\n\n/*\n#define i(x) int x; scanf(\"%d\",&x);\n#define l(x) ll x; scanf(\"%lld\",&x);\n#define d(x) double  x; scanf(\"%lf\",&x);\n*/\n//今度実装がんばる\n//https://www23.atwiki.jp/akitaicpc/pages/65.html\n\n\nint main() {\n\t/*double xp1, yp1, xp2, yp2; put xp1 >> yp1 >> xp2 >> yp2;\n\tSegment s;\n\ts.p1 = Point(xp1, yp1);\n\ts.p2 = Point(xp2, yp2);\n\n\tint n; put n;\n\trep(i, n) {\n\t\tPoint p;\n\t\tput p.x >> p.y;\n\t\tPoint prj =reflection(s, p);\n\t\tcout << setprecision(13) << prj.x << \" \" << prj.y << endl;\n\t}*/\n\t//テンプレート化を来世に考える\n\tauto getI = [&]()->auto { int tmp; put tmp; return tmp; };\n\tauto getLL = [&]()->auto { ll tmp; put tmp; return tmp; };\n\tauto getS = [&]()->auto { string tmp; put tmp; return tmp; };\n\n\tint n; put n;\n\tstring s1, s2;\n\tstring r;\n\tstring patan1[4] = { \".\",\"#\",\".\",\"#\" };\n\tstring patan2[4] = { \".\",\".\",\"#\",\"#\" };\n\tbool front = true;\n\trep(j, 420 / 4) {\n\t\tif (front) {\n\t\t\trep(i, 4) {\n\t\t\t\tcout << s1 + patan1[i] + \"\\n\" << s2 + patan2[i] << endl;\n\t\t\t\tcin >> r;\n\t\t\t\tif (r == \"T\") {\n\t\t\t\t\ts1 += patan1[i];\n\t\t\t\t\ts2 += patan2[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (r == \"F\" && i == 3) {\n\t\t\t\t\tfront = !front;\n\t\t\t\t}\n\t\t\t\tif (r == \"end\")goto END;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trep(i, 4) {\n\t\t\t\tcout << patan1[i] + s1 + \"\\n\" << patan2[i] + s2 << endl;\n\t\t\t\tcin >> r;\n\t\t\t\tif (r == \"T\") {\n\t\t\t\t\ts1 = patan1[i] + s1;\n\t\t\t\t\ts2 = patan2[i] + s2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (r == \"F\" && i == 3) {\n\t\t\t\t\tfront = !front;\n\t\t\t\t}\n\t\t\t\tif (r == \"end\")goto END;\n\t\t\t}\n\t\t}\n\n\t}\nEND:\n\tcout << endl;\n\treturn 0;\n}\n\n//\n//int n, a, b; put n >> a >> b;\n//\tvi t;\n//\trep(i, n) {\n//\t\tt.push_back(get());\n//\t}\n//\tint count = 0;\n//\trep(i, n) {\n//\t\tif (t[i] < a || b <= t[i])count++;\n//\t}\n//\tputans(count);\n\n//\n//\tset<string> list;\n//\tint ans = 0;\n//\tint n; put n;\n//\tint k; put k;\n//\tint numAlphabet[26];\n//\tfill(all(numAlphabet), 0);\n//\trep(i, n) {\n//\t\tstring s; put s;\n//\t\tif (exist(list, s))continue;\n//\t\tlist.insert(s);\n//\t\tnumAlphabet[s[0] - 'A']++;\n//\t}\n//\tsort(all(numAlphabet),greater<int>());\n//\twhile (true) {\n//\t\trep(i, k) {\n//\t\t\tif (numAlphabet[i] == 0) goto END;\n//\t\t\telse numAlphabet[i]--;\n//\t\t}\n//\t\tsort(all(numAlphabet), greater<int>());\n//\t\tans++;\n//\t}\n//END:\n//\tputans(ans);\n\n\n\t//int t; put t;\n\t//rep(i, t) {\n\t//\tint n, d; put n >> d;\n\t//\tif (n == 1) {\n\t//\t\tputans(d);\n\t//\t\tcontinue;\n\t//\t}\n\t//\tputans(n % 2 != 0 ? ( n - 1 ) * 127 + d : ( n - 1 ) * 127 + ( 127 ^ d ));\n\t//}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nchar str[10];\n\nbool ask(std::string row[], bool left) {\n    std::string tmpRow[2];\n    for(int i = 0; i < 4; ++ i) {\n        tmpRow[0] = row[0];\n        tmpRow[1] = row[1];\n        if(left) {\n            tmpRow[0] = ((i & 1) ? \".\" : \"#\") + row[0];\n            tmpRow[1] = ((i & 2) ? \".\" : \"#\") + row[1];\n        } else {\n            tmpRow[0] = row[0] + ((i & 1) ? \".\" : \"#\");\n            tmpRow[1] = row[1] + ((i & 2) ? \".\" : \"#\");\n        }\n        printf(\"%s\\n%s\\n\", tmpRow[0].c_str(), tmpRow[1].c_str());\n        fflush(stdout);\n        scanf(\"%s\", str);\n        if(str[0] == 'T') {\n            row[0] = tmpRow[0];\n            row[1] = tmpRow[1];\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid MAIN() {\n    int n;\n    scanf(\"%d\", &n);\n    bool left = true;\n    std::string row[2] = { \"\", \"\" };\n    for(int i = 0; i < n; ++ i) {\n        if(ask(row, left)) {\n            continue;\n        } else {\n            left = !left;\n            ask(row, left);\n        }\n    }\n    printf(\"%s\\n%s\\n\", row[0].c_str(), row[1].c_str());\n}\n\nint main() {\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nvoid solve(int N) {\n  string s1, s2;\n  while(1) {\n    REP(i,4) {\n      string tmp1 = s1, tmp2 = s2;\n      tmp1 += (i / 2 == 1) ? \"#\" : \".\";\n      tmp2 += (i % 2 == 1) ? \"#\" : \".\";\n      printf(\"%s\\n%s\\n\", tmp1.c_str(), tmp2.c_str()); fflush(stdout);\n      string r;\n      cin >> r;\n      if(r == \"end\"){\n        return;\n      }else if(r == \"T\") {\n        s1 = tmp1;\n        s2 = tmp2;\n        break;\n      }\n    }\n  }\n}\n\nint main(){\n  int N;\n  cin >> N;\n  solve(N);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid MV(char a[1001]){\n  for(int i=200;i>=0;i--)a[i+1]=a[i];\n}\n\nint main(){\n  int n;\n  cin>>n;\n  int idx=0;\n  char s[2]={'.','#'};\n  char a[1001],b[1001];\n  int flg=1;\n  while(1){\n\n    string ans=\"F\";\n    a[idx+1]=b[idx+1]=0;\n    for(int i=0;i<(1<<2)&&ans==\"F\"&&flg;i++){\n      a[idx]=s[i%2],b[idx]=s[i>>1];\n      printf(\"%s\\n%s\\n\",a,b);fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n    }\n    \n    if(ans==\"F\")MV(a),MV(b),flg=0;;\n    a[idx+1]=b[idx+1]=0;\n    for(int i=0;i<(1<<2)&&ans==\"F\";i++){\n      a[0]=s[i%2],b[0]=s[i>>1];\n      printf(\"%s\\n%s\\n\",a,b);fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n    }\n    idx++;\n    if(idx==n)break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//1列(4通り)を質問 -> 当たったら1列（右側に）追加して(4通り)質問 -> …を繰り返すと400回以内で当たらなくなる（かendが返る）\n//このとき、質問した列は黒板の右端にある。あとは、同様にして左側を特定すればよい。\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring reverse(string str) {\n\tstring ret;\n\tfor (int i = (int)str.length() - 1; i >= 0; i--) ret += str[i];\n\treturn ret;\n}\n\nint n;\nstring query[2];\n\nvoid addCharRight(int type) {\n\tchar c0 = ((type / 2) % 2 ? '#' : '.');\n\tchar c1 = (type % 2 ? '#' : '.');\n\tquery[0] += c0;\n\tquery[1] += c1;\n}\n\nvoid addCharLeft(int type) {\n\tchar c0 = ((type / 2) % 2 ? '#' : '.');\n\tchar c1 = (type % 2 ? '#' : '.');\n\treverse(query[0]);\n\treverse(query[1]);\n\tquery[0] += c0;\n\tquery[1] += c1;\n\treverse(query[0]);\n\treverse(query[1]);\n}\n\nvoid delCharRight() {\n\tstring s[2];\n\tfor (int i = 0; i < (int)query[0].size() - 1; i++) s[0] += query[0][i];\n\tfor (int i = 0; i < (int)query[1].size() - 1; i++) s[1] += query[1][i];\n\tquery[0] = s[0];\n\tquery[1] = s[1];\n}\n\nvoid delCharLeft() {\n\tstring s[2];\n\tfor (int i = 1; i < (int)query[0].size(); i++) s[0] += query[0][i];\n\tfor (int i = 1; i < (int)query[1].size(); i++) s[1] += query[1][i];\n\tquery[0] = s[0];\n\tquery[1] = s[1];\n}\n\n//return : {T, F, end}\nchar getQuery() {\n\tcout << query[0] << endl;\n\tcout << query[1] << endl;\n\tcout.flush();\n\tstring ret;\n\tcin >> ret;\n\treturn ret[0];\n}\n\n//return : {T, F, e}\nchar addQueryRight(int type) {\n\taddCharRight(type);\n\tchar res = getQuery();\n\tif (res == 'e' || res == 'T') return res;\n\tdelCharRight();\n\treturn res;\n}\n\nchar addQueryLeft(int type) {\n\taddCharLeft(type);\n\tchar res = getQuery();\n\tif (res == 'e' || res == 'T') return res;\n\tdelCharLeft();\n\treturn res;\n}\n\nsigned main() {\n\tcin >> n;\n\t\n\tint j;\n\t\n\twhile (true) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tchar res = addQueryRight(j);\n\t\t\tif (res == 'e') return 0;\n\t\t\tif (res == 'T') break;\n\t\t}\n\t\tif (j == 4) break;\n\t}\n\t\n\twhile (true) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tchar res = addQueryLeft(j);\n\t\t\tif (res == 'e') return 0;\n\t\t\tif (res == 'T') break;\n\t\t}\n\t\tif (j == 4) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<string> res(2);\nint ok=0;\nstring up=\".##.\",down=\"##..\";\nbool lr=0;\n\nbool lft()\n{\n    for(int i=0;i<4;++i)\n    {\n        cout<<res[0]+up[i]<<'\\n';\n        cout<<res[1]+down[i]<<'\\n';\n        cout.flush();\n        char c;\n        cin>>c;\n        if(c=='T')\n        {\n            res[0]+=up[i];\n            res[1]+=down[i];\n            return 1;\n        }\n    }\n    return 0;\n}\n\nbool rgt()\n{\n    for(int i=0;i<4;++i)\n    {\n        cout<<up[i]+res[0]<<'\\n';\n        cout<<down[i]+res[1]<<'\\n';\n        cout.flush();\n        char c;\n        cin>>c;\n        if(c=='T')\n        {\n            res[0]=up[i]+res[0];\n            res[1]=down[i]+res[1];\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid thing()\n{\n    if(!lr&&!lft())\n        lr=1;\n    if(lr&&!rgt())\n        lr=0;\n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    getchar();\n    bool yee=0;\n    for(int i=0;i<n;++i)\n        thing();\n    cout<<res[0]<<'\\n';\n    cout<<res[1]<<'\\n';\n    cout.flush();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<algorithm>\n#include<list>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<climits>\n#include<iterator>\n#include<unordered_set>\n#include<unordered_map>\n#include<map>\n#include<set>\n#include<typeinfo>\nusing namespace std;\n\nconst double pi=4*atan(1.0);\n\nconstexpr long long mod=static_cast<long long>(1e9+7);\n\nusing cWeightEdges=vector<vector<pair<int,int>>>;\nusing cEdges=vector<vector<int>>;\n\nbool check(string s1,string s2,int num){\n\tfor(int i=0;i<num;++i){\n\t\tcout<<s1;\n\t}\n\tcout<<\"\\n\";\n\tfor(int i=0;i<num;++i){\n\t\tcout<<s2;\n\t}\n\tcout<<endl;\n\tfflush(stdout);\n\tstring str;\n\tcin>>str;\n\tif(str==\"F\")return false;\n\telse return true;\n}\n\nint getMaxLength(int N,string s1,string s2){\n\tint Min=1,Max=N+1,Mid=0;\n\twhile(1){\n\t\tMid=(Max-Min)/2+Min;\n\t\tbool ans=check(s1,s2,Mid);\n\t\tif(ans){\n\t\t\tif(Min==Mid){\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tMin=Mid;\n\t\t}\n\t\telse{\n\t\t\tif(Min==Mid){\n\t\t\t\tif(Min==1)return 0;\n\t\t\t\telse{\n\t\t\t\t\treturn Max;\n\t\t\t\t}\n\t\t\t}\n\t\t\tMax=Mid;\n\t\t}\n\t}\n}\n\nbool check1(const deque<pair<char,char>>& deq,string s1,string s2){\n\tfor(const auto& val:deq)\n\t\tcout<<val.first;\n\tcout<<s1;\n\tcout<<\"\\n\";\n\tfor(const auto& val:deq)\n\t\tcout<<val.second;\n\tcout<<s2;\n\tcout<<endl;\n\tfflush(stdout);\n\tstring str;\n\tcin>>str;\n\tif(str==\"F\")return false;\n\telse return true;\n}\n\nbool check2(const deque<pair<char,char>>& deq,string s1,string s2){\n\tcout<<s1;\n\tfor(const auto& val:deq)\n\t\tcout<<val.first;\n\tcout<<\"\\n\";\n\tcout<<s2;\n\tfor(const auto& val:deq)\n\t\tcout<<val.second;\n\tcout<<endl;\n\tfflush(stdout);\n\tstring str;\n\tcin>>str;\n\tif(str==\"F\")return false;\n\telse return true;\n}\n\nint main(){\n\tint N;\n\tcin>>N;\n\tint BB=0,WW=0,WB=0,BW=0;\n\tBB=getMaxLength(N,\"#\",\"#\");\n\tif(BB==N)return 0;\n\tWW=getMaxLength(N,\".\",\".\");\n\tif(WW==N)return 0;\n\tWB=getMaxLength(N,\".\",\"#\");\n\tif(WB==N)return 0;\n\tBW=getMaxLength(N,\"#\",\".\");\n\tif(BW==N)return 0;\n\n\tarray<pair<int,string>,4> a;\n\ta[0]=make_pair(BB,\"##\");\n\ta[1]=make_pair(WW,\"..\");\n\ta[2]=make_pair(WB,\".#\");\n\ta[3]=make_pair(BW,\"#.\");\n\tsort(begin(a),end(a),[](auto x,auto y)->bool{return x.first>y.first;});\n\tint length=a.front().first;\n\tdeque<pair<char,char>> deq(length,make_pair(a.front().second[0],a.front().second[1]));\n\n\twhile(length<N){\n\t\tif(check1(deq,\".\",\".\")){\n\t\t\t++length;\n\t\t\tdeq.push_back(make_pair('.','.'));\n\t\t}\n\t\telse{\n\t\t\tif(check1(deq,\"#\",\"#\")){\n\t\t\t\t++length;\n\t\t\t\tdeq.push_back(make_pair('#','#'));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(check1(deq,\".\",\"#\")){\n\t\t\t\t\t++length;\n\t\t\t\t\tdeq.push_back(make_pair('.','#'));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(check1(deq,\"#\",\".\")){\n\t\t\t\t\t\t++length;\n\t\t\t\t\t\tdeq.push_back(make_pair('#','.'));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(length<N){\n\t\tif(check2(deq,\".\",\".\")){\n\t\t\t++length;\n\t\t\tdeq.push_front(make_pair('.','.'));\n\t\t}\n\t\telse{\n\t\t\tif(check2(deq,\"#\",\"#\")){\n\t\t\t\t++length;\n\t\t\t\tdeq.push_front(make_pair('#','#'));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(check2(deq,\".\",\"#\")){\n\t\t\t\t\t++length;\n\t\t\t\t\tdeq.push_front(make_pair('.','#'));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(check2(deq,\"#\",\".\")){\n\t\t\t\t\t\t++length;\n\t\t\t\t\t\tdeq.push_front(make_pair('#','.'));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n    int N;\n    string r,s1=\"\",s2=\"\";\n    cin>>N;\n    bool flag=true;\n    while(s1.size()<N){\n        if(flag)\n        for(int k=0;k<4;k++){\n            cout<<s1<<(k&1?'#':'.')<<endl<<flush;\n            cout<<s2<<(k&2?'#':'.')<<endl<<flush;\n            cin>>r;\n            if(r==\"end\") return 0;\n            if(r==\"T\"){\n                s1+=(k&1?'#':'.');\n                s2+=(k&2?'#':'.');\n                continue;\n            }else if(k==3){\n                flag=false;\n                break;\n            }\n        }\n        if(!flag)\n        for(int k=0;k<4;k++){\n            cout<<(k&1?'#':'.')<<s1<<endl<<flush;\n            cout<<(k&2?'#':'.')<<s2<<endl<<flush;\n            cin>>r;\n            if(r==\"end\") return 0;\n            if(r==\"T\"){\n                s1=(k&1?'#':'.')+s1;\n                s2=(k&2?'#':'.')+s2;\n                continue;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"cycle\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 405;\n\nchar s[2][MAXN];\n\nchar ans[10];\n\nchar cc[4][2];\n\nvoid solve(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, 0, 4){\n\t\tcc[i][0] = ((i & 1) ? '#' : '.');\n\t\tcc[i][1] = ((i & 2) ? '#' : '.');\n\t}\n\tint fl = 0;\n\tint st = 0;\n\twhile(1){\n\t\tint fl1 = 0;\n\t\tREP(i, 0, 4){\n\t\t\tREP(j, 0, 2){\n\t\t\t\ts[j][st] = cc[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\", s[0], s[1]);\n\t\t\tfflush(stdout);\n\t\t\tscanf(\"%s\", &ans[0]);\n\t\t\tif (ans[0] == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ans[0] == 'T'){\n\t\t\t\tfl1 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fl1){\n\t\t\tst++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(1){\n\t\tint fl1 = 0;\n\t\tREP(i, 0, 2){\n\t\t\tfor(int j = st; j > 0; j--){\n\t\t\t\ts[i][j] = s[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tREP(i, 0, 4){\n\t\t\tREP(j, 0, 2){\n\t\t\t\ts[j][0] = cc[i][j];\n\t\t\t}\n\t\t\tprintf(\"%s\\n%s\\n\", s[0], s[1]);\n\t\t\tfflush(stdout);\n\t\t\tscanf(\"%s\", &ans[0]);\n\t\t\tif (ans[0] == 'e'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ans[0] == 'T'){\n\t\t\t\tfl1 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tst++;\n\t\tassert(st <= n);\n\t}\n}\t\n\nint main(){\n/*#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif*/\n\t//freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n\tint t = 1;\n\t//cin >> t;\n\twhile(t--){\n\t\tsolve();\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nbool ask(string &s1, string &s2, int i, bool rev) {\n    if (rev) cout << \".#\"[i & 1];\n    cout << s1;\n    if (!rev) cout << \".#\"[i & 1];\n    cout << '\\n';\n    if (rev) cout << \".#\"[(i >> 1) & 1];\n    cout << s2;\n    if (!rev) cout << \".#\"[(i >> 1) & 1];\n    cout << endl;\n    string r; cin >> r;\n    if (r == \"T\") {\n        if (rev) {\n            s1 = \".#\"[i & 1] + s1;\n            s2 = \".#\"[(i >> 1) & 1] + s2;\n        } else {\n            s1.push_back(\".#\"[i & 1]);\n            s2.push_back(\".#\"[(i >> 1) & 1]);\n        }\n        return true;\n    } else if (r == \"F\") {\n        return false;\n    } else {\n        exit(0);\n    }\n}\nint main() {\n    int N; cin >> N;\n    string s1, s2;\n    bool rev = false;\n    while (s1.size() < N) {\n        bool ok = false;\n        for (int i = 0; i < 4; i++) {\n            if (ask(s1, s2, i, rev)) {\n                ok = true;\n                break;\n            }\n        }\n        if (!ok) {\n            rev = !rev;\n            continue;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar a[4] = {'.', '.', '#', '#'};\nchar b[4] = {'#', '.', '#', '.'};\n\nvector<char> vec1;\nvector<char> vec2;\n\nint main() {\n    int cnt = 0;\n    bool check = true;\n    while(true) {\n        string str;\n        cin >> str;\n        if(str == \"end\") break;\n        else if(str == \"T\") {\n            cnt = 0;\n            if(check) {\n                vec1.push_back(a[cnt]);\n                vec2.push_back(b[cnt]);\n                cnt++;\n            }\n            else {\n                vec1.insert(vec1.begin(), a[cnt]);\n                vec2.insert(vec2.begin(), b[cnt]);\n                cnt++;\n            }\n        }\n        else if(str == \"F\"){\n            if(cnt == 4) {\n                cnt = 0;\n                check = false;\n                vec1.erase(vec1.end() - 1);\n                vec2.erase(vec2.end() - 1);\n            }\n            else if(check) {\n                vec1.erase(vec1.end() - 1);\n                vec2.erase(vec2.end() - 1);\n                vec1.push_back(a[cnt]);\n                vec2.push_back(b[cnt]);\n                cnt++;\n            }\n            else if(!check) {\n                vec1.erase(vec1.begin());\n                vec2.erase(vec2.begin());\n                vec1.insert(vec1.begin(), a[cnt]);\n                vec2.insert(vec2.begin(), b[cnt]);\n                cnt++;\n            }\n        }\n        else {\n            vec1.push_back(a[cnt]);\n            vec2.push_back(b[cnt]);\n            cnt++;\n        }\n        for(int i = 0; i < vec1.size(); i++) printf(\"%c\", vec1[i]);\n        printf(\"\\n\");\n        for(int i = 0; i < vec2.size(); i++) printf(\"%c\", vec2[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tchar in_buffer[10] = {};\n\t\n\tdeque<char> atas;\n\tdeque<char> bawah;\n\t\n\tdeque<char> printatas;\n\tdeque<char> printbawah;\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas.push_front('.');\n\t\tbawah.push_front('.');\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas.pop_front();\n\t\t\tbawah.pop_front();\n\t\t\tatas.push_front(tempatas[j]);\n\t\t\tbawah.push_front(tempbawah[j]);\n\t\t\t\n\t\t\tprintatas = atas;\n\t\t\tprintbawah = bawah;\n\t\t\t\n\t\t\twhile(!printatas.empty()) {\n\t\t\t\tprintf(\"%c\", printatas.front());\n\t\t\t\tprintatas.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\twhile(!printbawah.empty()) {\n\t\t\t\tprintf(\"%c\", printbawah.front());\n\t\t\t\tprintbawah.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tatas.pop_front();\n\tbawah.pop_front();\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas.push_back('.');\n\t\tbawah.push_back('.');\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas.pop_back();\n\t\t\tbawah.pop_back();\n\t\t\tatas.push_back(tempatas[j]);\n\t\t\tbawah.push_back(tempbawah[j]);\n\t\t\t\n\t\t\tprintatas = atas;\n\t\t\tprintbawah = bawah;\n\t\t\t\n\t\t\twhile(!printatas.empty()) {\n\t\t\t\tprintf(\"%c\", printatas.front());\n\t\t\t\tprintatas.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\twhile(!printbawah.empty()) {\n\t\t\t\tprintf(\"%c\", printbawah.front());\n\t\t\t\tprintbawah.pop_front();\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst char s1[4] = { '.', '#', '.', '#'};\nconst char s2[4] = { '.', '.', '#', '#'};\n\nbool found;\n\nvoid dfs(int depth, string t1, string t2){\n\tif (depth >= 110) return;\n\tif (found) return;\n\n\trep (i, 4){\n\t\tstring u1 = t1 + s1[i];\n\t\tstring u2 = t2 + s2[i];\n\t\tcout << u1 << endl;\n\t\tcout << u2 << endl;\n\t\tfflush(stdout);\n\t\tstring ans; cin >> ans;\n\t\tif (ans[0] == 'F') continue;\n\t\tif (ans == \"end\"){\n\t\t\tfound = true;\n\t\t\treturn;\n\t\t} // end if\n\t\t// if (ans[0] == T)\n\t\tdfs(depth + 1, u1, u2);\n\t} // end rep \n}\n \nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N; cin >> N;\n\tfound = false;\n\tdfs(0, \"\", \"\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nstring f=\"\";\nstring s=\"\";\nstring df=\".#.#\";\nstring ds=\"..##\";\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tint i=0;\n\twhile(i<n){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tstring ff=f+df[j];\n\t\t\tstring ss=s+ds[j];\n\t\t\tcout << ff << endl;\n\t\t\tcout << ss << endl;\n\t\t\tstring b;\n\t\t\tcin >> b;\n\t\t\tif(b==\"T\" || b==\"end\"){\n\t\t\t\tf=ff;\n\t\t\t\ts=ss;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twhile(i<n){\n\t\tfor(int j=0;j<4;j++){\n\t\t\tstring ff=df[j]+f;\n\t\t\tstring ss=ds[j]+s;\n\t\t\tcout << ff << endl;\n\t\t\tcout << ss << endl;\n\t\t\tstring b;\n\t\t\tcin >> b;\n\t\t\tif(b==\"T\" || b==\"end\"){\n\t\t\t\tf=ff;\n\t\t\t\ts=ss;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst char s1[4] = { '.', '#', '.', '#'};\nconst char s2[4] = { '.', '.', '#', '#'};\n\nbool used[4];\nbool found;\nset<string> exclusion;\n\nvoid dfs(int depth, string t1, string t2){\n\tif (depth >= 110) return;\n\tif (found) return;\n\n\trep (i, 4){\n\t\tif (!used[i]) continue;\n\t\tstring u1 = t1 + s1[i];\n\t\tstring u2 = t2 + s2[i];\n\t\tif (exclusion.count(u1+u2)) continue;\n\t\tcout << u1 << endl;\n\t\tcout << u2 << endl;\n\t\tfflush(stdout);\n\t\tstring ans; cin >> ans;\n\t\tif (ans[0] == 'F'){\n\t\t\tif (depth == 0) used[i] = false;\n\t\t\texclusion.insert(u1+u2);\n\t\t\tcontinue;\n\t\t} // end if\n\n\t\tif (ans == \"end\"){\n\t\t\tfound = true;\n\t\t\treturn;\n\t\t} // end if\n\t\t// if (ans[0] == 'T')\n\t\tdfs(depth + 1, u1, u2);\n\t} // end rep \n}\n \nint main()\n{\n\tmemset(used, false, sizeof(used));\n\trep (i, 4) used[i] = true;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint N; cin >> N;\n\texclusion.clear();\n\tfound = false;\n\tdfs(0, \"\", \"\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for (int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for (int (i) = (a) - 1; (i) >= (b); (i)--)\n#define PI acos(-1.0)\n#define DEBUG(C) cout<< C <<endl;\n#define VI vector <int>\n#define VII vector <VI>\n#define VL vector <LL>\n#define VLL vector <VL>\n#define VD vector <double>\n#define VDD vector <VD>\n#define PII pair <int, int>\n#define PDD pair <double, double>\n#define PLL pair <LL, LL>\n#define VPII vector <PII>\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define REVERSE(a) reverse(ALL(a))\n#define MP make_pair\n#define EB emplace_back\n#define FORE(a, b) for (auto &&a:b)\n#define FIND(s, n) (s.find(n) != s.end())\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int INF = 1e9;\nconst int MOD = INF + 7;\n\nstring cc[2];\n\nint main(void) {\n    cc[0] = \"..##\";\n    cc[1] = \".#.#\";\n    int N; cin >> N;\n    vector <string> S(2, \"\"), Sbuf(2);\n    int cnt = 0;\n    S[0] += cc[0][0];\n    S[1] += cc[1][0];\n    REP(_, 420) {\n        printf(\"%s\\n%s\\n\", S[0].c_str(), S[1].c_str());\n        string c; cin >> c;\n        if (c == \"T\") {\n            Sbuf = S;\n            cnt = 0;\n            REP(i, 2) {\n                S[i] += cc[i][cnt];\n            }\n        } else if (c == \"F\") {\n            S = Sbuf;\n            cnt++;\n            if (cnt >= 4) {\n                REP(i, 2) {\n                    S[i] = cc[i][cnt] + S[i];\n                }\n            } else {\n                REP(i, 2) {\n                    S[i] += cc[i][cnt % 4];\n                }\n            }\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <iostream>\n#include <ctime>\n#include <complex>\n\n#define enp \tprintf(\"**Entry Point**\\n\")\n#define A\t\tfirst\n#define B\t\tsecond\n#define MP\t\tmake_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 0x6fffffff;\nconst int MINF = 0x80000000;\nconst ll mod = 100003;\nconst int cons = 100001;\nconst double pi = 3.141592653589793;\n\nchar ch[2] = { '.', '#' };\nint nxt[4][2];\nchar s1[400];\nchar s2[400];\n\nint main()\n{\n\tnxt[0][0] = 0;\n\tnxt[0][1] = 1;\n\tnxt[1][0] = 1;\n\tnxt[1][1] = 0;\n\tnxt[2][0] = 1;\n\tnxt[2][1] = 1;\n\tnxt[3][0] = 0;\n\tnxt[3][1] = 0;\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint front = 200;\n\tint rear = 200;\n\tint i1 = 0, i2 = 0;\n\tbool flag = true;\n\tint cur = 0;\n\n\twhile (1)\n\t{\n\t\tif (flag)\n\t\t{\n\t\t\ts1[rear] = ch[i1];\n\t\t\ts2[rear++] = ch[i2];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts1[front - 1] = ch[i1];\n\t\t\ts2[front - 1] = ch[i2];\n\t\t\tfront--;\n\t\t}\n\n\t\tprintf(\"%s\\n%s\\n\", s1 + front, s2 + front); fflush(stdout);\n\n\t\tstring ans;\n\t\tcin >> ans;\n\t\tif (ans == \"end\")break;\n\n\t\tif (ans == \"F\")\n\t\t{\n\t\t\ti1 = nxt[cur][0];\n\t\t\ti2 = nxt[cur][1];\n\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\trear--;\n\t\t\t\ts1[rear] = 0;\n\t\t\t\ts2[rear] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfront++;\n\t\t\t}\n\n\t\t\tcur++;\n\t\t\tcur %= 4;\n\t\t\tif (cur == 0)\n\t\t\t{\n\t\t\t\tflag ^= true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur = 0;\n\t\t\ti1 = 0;\n\t\t\ti2 = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tstring a=\"\";\n\tstring b=\"\";\n\tstring aa=\"..##\";\n\tstring bb=\".#.#\";\n\tint n;\n\tcin>>n;\n\twhile(1){\n\t\tbool ok = false;\n\t\trep(i,4){\n\t\t\tstring na = a + aa[i];\n\t\t\tstring nb = b + bb[i];\n\t\t\tcout<<na<<endl<<nb<<endl;\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(t==\"end\") return;\n\t\t\tif(t==\"T\"){\n\t\t\t\tok=true;\n\t\t\t\ta=na;\n\t\t\t\tb=nb;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) break;\n\t}\n\twhile(1){\n\t\tbool ok = false;\n\t\trep(i,4){\n\t\t\tstring na = aa[i] + a;\n\t\t\tstring nb = bb[i] + b;\n\t\t\tcout<<na<<endl<<nb<<endl;\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(t==\"end\") return;\n\t\t\tif(t==\"T\"){\n\t\t\t\tok=true;\n\t\t\t\ta=na;\n\t\t\t\tb=nb;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok) break;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nbool check(int l, int r, int k) {\n\tstring s(n, '.');\n\tstring t(n, '.');\n\tfor (int i = l; i <= r; i++) {\n\t\tif (k == 0) {\n\t\t\ts[i] = '#';\n\t\t} else {\n\t\t\tt[i] = '#';\n\t\t}\n\t}\n\tcout << s << endl;\n\tcout << t << endl;\n\tstring res;\n\tcin >> res;\n\tif (res == \"end\") exit(0);\n\treturn res == \"T\";\n}\n\nint main() {\n\tcin >> n;\n\n\tstring ans[2];\n\tans[0] = string(n, '.');\n\tans[1] = string(n, '.');\n\n\tstring s(n, '.');\n\tfor (int i = 0; i < n; i++) ans[0][i] = ans[1][i] = '.';\n\n\tfor (int ii = 0; ii < 2; ii++) {\n\t\tint i = 0;\n\t\twhile (i < n) {\n\t\t\tif (!check(i, i, ii)) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint j = i;\n\t\t\ti++;\n\t\t\twhile (i < n && check(j, i, ii)) i++;\n\t\t\tfor (int k = j; k < i; k++) {\n\t\t\t\tans[ii][k] = '#';\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans[0] << endl;\n\tcout << ans[1] << endl;\n\tstring tmp;\n\tcin >> tmp;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n;\n    cin >> n;\n    string s1, s2;\n    int flag = 0;\n    string t1 = \"..##\";\n    string t2 = \".#.#\";\n    string c;\n    rep(i,n){\n        if(flag == 0){\n            rep(j,4){\n                cout << s1 << t1[j] << endl;\n                cout << s2 << t2[j] << endl;\n                fflush(stdout);\n                cin >> c;\n                if(c[0] == 'T'){\n                    s1 += t1[j];\n                    s2 += t2[j]; \n                    break;\n                }\n            }\n        }\n        if(s1.size() == i)flag = 1;\n        if(flag){\n            rep(j,4){\n                cout << t1[j] << s1 << endl;\n                cout << t2[j] << s2 << endl;\n                fflush(stdout);\n                cin >> c;\n                if(c[0] == 'T'){\n                    s1 = t1[j] + s1;\n                    s2 = t2[j] + s2; \n                    break;\n                }\n            }\n        }\n    }\n\n    cout << s1 << endl << s2 << endl;\n\n    return 0;\n}\n\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nbool query(VS& vs){\n  cout << vs[0] << endl << vs[1] << endl;\n  char c; cin >> c;\n  return c == 'T';\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  int len = 0;\n  string ch = \".#\";\n  VS vs(2);\n  bool up = true;\n  while(up && len < N){\n\tup = false;\n\tVS qs = vs;\n\tqs[0] += \"x\";\n\tqs[1] += \"x\";\n\tREP(i,2) REP(j,2){\n\t  qs[0][len] = ch[i];\n\t  qs[1][len] = ch[j];\n\t  if(query(qs)){\n\t\ti = j = 2;\n\t\tvs = qs;\n\t\t++len;\n\t\tup = true;\n\t  }\n\t}\n  }\n\n  up = true;\n  while(up && len < N){\n\tup = false;\n\tVS qs(2);\n\tqs[0] = \"x\" + vs[0];\n\tqs[1] = \"x\" + vs[1];\n\tREP(i,2) REP(j,2){\n\t  qs[0][len] = ch[i];\n\t  qs[1][len] = ch[j];\n\t  if(query(qs)){\n\t\ti = j = 2;\n\t\tvs = qs;\n\t\t++len;\n\t\tup = true;\n\t  }\n\t}\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate <typename T>\nvoid print_line(const T& x){\n\tfor(const auto c : x){ cout << c; }\n\tcout << endl;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tdeque<char> cur[2];\n\tstring response;\n\twhile(cur[0].size() < n){\n\t\tbool found = false;\n\t\tfor(int x = 0; !found && x < 4; ++x){\n\t\t\tcur[0].push_back((x & 1) ? '#' : '.');\n\t\t\tcur[1].push_back((x & 2) ? '#' : '.');\n\t\t\tprint_line(cur[0]);\n\t\t\tprint_line(cur[1]);\n\t\t\tcout << flush;\n\t\t\tcin >> response;\n\t\t\tif(response == \"end\"){ return 0; }\n\t\t\tif(response == \"T\"){\n\t\t\t\tfound = true;\n\t\t\t}else{\n\t\t\t\tcur[0].pop_back();\n\t\t\t\tcur[1].pop_back();\n\t\t\t}\n\t\t}\n\t\tif(!found){ break; }\n\t}\n\twhile(cur[0].size() < n){\n\t\tfor(int x = 0; x < 4; ++x){\n\t\t\tcur[0].push_front((x & 1) ? '#' : '.');\n\t\t\tcur[1].push_front((x & 2) ? '#' : '.');\n\t\t\tprint_line(cur[0]);\n\t\t\tprint_line(cur[1]);\n\t\t\tcout << flush;\n\t\t\tcin >> response;\n\t\t\tif(response == \"end\"){ return 0; }\n\t\t\tif(response == \"T\"){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tcur[0].pop_front();\n\t\t\t\tcur[1].pop_front();\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size() \n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst static int INF = 1e8;\nconst static D EPS = 1e-8;\n\nint main(){\n  size_t n;\n  cin >> n;\n\n  string s1,s2;\n  bool addRight = true;\n  while(s1.size() < n){\n    bool f = false;\n    rep(i,4){\n      if(addRight){\n\tif(i==0) s1 += '.', s2 += '.';\n\telse if(i==1) s1 += '.', s2 += '#';\n\telse if(i==2) s1 += '#', s2 += '.';\n\telse s1 += '#', s2 += '#';\n      }else{\n\tif(i==0) s1 = '.' + s1, s2 = '.' + s2;\n\telse if(i==1) s1 = '.' + s1, s2 = '#' + s2;\n\telse if(i==2) s1 = '#' + s1, s2 = '.' + s2;\n\telse s1 = '#' + s1, s2 = '#' + s2;\n      }\n\n      cout << s1 << '\\n' << s2 << endl;\n      string r; cin >> r;\n      if(r == \"end\"){\n\treturn 0;\n      }else if(r == \"T\"){\n\tf = true; break;\n      }\n      if(addRight){\n\ts1.pop_back(); s2.pop_back();\n      }else{\n\ts1 = s1.substr(1); s2 = s2.substr(1);\n      }\n    }\n\n    if(!f){\n      addRight = false;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n\n\nint n;\nstring c, rx, ry, lx, ly, x[] = {\".\", \".\", \"#\", \"#\"}, y[] = {\".\", \"#\", \".\", \"#\"}, t;\nbool re;\n\nsigned main() {\n\tcin >> n;\n\twhile (1) {\n\t\tif (!re) {\n\t\t\trep(i,4) {\n\t\t\t\tcout << rx+x[i] << endl << ry+y[i] << endl << flush;\n\t\t\t\tcin >> t;\n\t\t\t\tif (t==\"end\") return 0;\n\t\t\t\tif (t==\"T\") {\n\t\t\t\t\trx += x[i], ry += y[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i==3) re = 1;\n\t\t\t}\n\t\t} else {\n\t\t\trep(i,4) {\n\t\t\t\tcout << x[i]+rx << endl << y[i]+ry << endl << flush;\n\t\t\t\tcin >> t;\n\t\t\t\tif (t==\"end\") return 0;\n\t\t\t\tif (t==\"T\") {\n\t\t\t\t\trx = x[i]+rx, ry = y[i]+ry;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=2001;\nchar x[]{'.','.','#','#'},y[]{'.','#','.','#'};\nint main(){\n\tint N;\n\tcin >> N;\n\tstring s1,s2;\n\tstring ret;\n\tbool last=false;\n\tREP(i,N){\n\t\tif(!last)\n\t\t\tREP(j,4){\n\t\t\t\tcout << s1+x[j] <<endl << s2+y[j] << endl;\n\t\t\t\tcin >> ret;\n\t\t\t\tif(ret==\"End\") return 0;\n\t\t\t\tif(ret==\"T\"){\n\t\t\t\t\ts1+=x[j];\n\t\t\t\t\ts2+=y[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ret==\"F\" && j==3){\n\t\t\t\t\tlast=true;\n\t\t\t\t}\n\t\t\t}\n\t\telse{\t\t\n\t\t\tREP(j,4){\n\t\t\t\tcout << x[j]+s1 <<endl << y[j]+s2 << endl;\n\t\t\t\tcin >> ret;\n\t\t\t\tif(ret==\"End\") return 0;\n\t\t\t\tif(ret==\"T\"){\n\t\t\t\t\ts1=x[j]+s1;\n\t\t\t\t\ts2=y[j]+s2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nint main() {\n\tint n;\n\n\tstd::cin >> n;\n\n\tstd::string upper = \"\", lower = \"\";\n\n\tstd::string uq = \"..##\", lq = \".#.#\";\n\tbool back = false;\n\twhile (true) {\n\t\tint before_length = upper.length();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tstd::string result;\n\n\t\t\tif (back) {\n\t\t\t\tstd::cout << uq[i] << upper << std::endl;\n\t\t\t\tstd::cout << lq[i] << lower << std::endl;\n\t\t\t\tstd::cin >> result;\n\t\t\t\tif (result == \"end\") return 0;\n\t\t\t\tif (result == \"T\") {\n\t\t\t\t\tupper = uq[i] + upper;\n\t\t\t\t\tlower = lq[i] + lower;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstd::cout << upper << uq[i] << std::endl;\n\t\t\t\tstd::cout << lower << lq[i] << std::endl;\n\t\t\t\tstd::cin >> result;\n\n\t\t\t\tif (result == \"end\") return 0;\n\t\t\t\tif (result == \"T\") {\n\t\t\t\t\tupper += uq[i];\n\t\t\t\t\tlower += lq[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (before_length == upper.length()) {\n\t\t\tback = true;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\n#define int long long\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(a) (a).begin(), (a).end()\n#define PB push_back\n#define MP make_pair\n#define FST first\n#define SND second\n#define SZ(a) (signed)((a).size())\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\nconst int MOD = 1000000007;\nconst char ENDL = '\\n';\n\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\"  << \" \" << __FILE__ << endl;\n\nsigned main(void) {\n//    ios::sync_with_stdio(false);\n//    cout.setf(ios::fixed, ios::floatfield);\n//    cout.precision(10);\n//    cin.tie(0);\n\n    int n;\n    cin >> n;\n    string s1,s2;\n\n    string r;\n    int state=0;\n    while(r!=\"end\"){\n        if(r==\"T\"){\n            if(state<=3){\n                state=0;\n            }else{\n                state=4;\n            }\n        }else if(r==\"F\"){\n            if(state==3){\n                s1.pop_back();\n                s2.pop_back();\n            }\n            state++;\n        }\n        switch (state){\n            case 0:\n                s1+=\".\";\n                s2+=\".\";\n                break;\n            case 1:\n                s1.back()='.';\n                s2.back()='#';\n                break;\n            case 2:\n                s1.back()='#';\n                s2.back()='.';\n                break;\n            case 3:\n                s1.back()='#';\n                s2.back()='#';\n                break;\n            case 4:\n                s1.insert(0,\".\");\n                s2.insert(0,\".\");\n                break;\n            case 5:\n                s1.front()='.';\n                s2.front()='#';\n                break;\n            case 6:\n                s1.front()='#';\n                s2.front()='.';\n                break;\n            case 7:\n                s1.front()='#';\n                s2.front()='#';\n                break;\n        }\n        printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str());\n        fflush(stdout);\n        cin >> r;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n;\nstring s[2];\nchar res;\nint main()\n{\n\tcin >> n;\n\tbool app=true;\n\ts[0]=\"\";\n\ts[1]=\"\";\n\twhile (s[0].size()<n)\n\t\tif (app)\n\t\t{\n\t\t\ts[0]+='.';\n\t\t\ts[1]+='.';\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\tif (res=='e')\n\t\t\t\treturn 0;\n\t\t\ts[0].erase(s[0].size()-1,1);\n\t\t\ts[1].erase(s[1].size()-1,1);\n\t\t\ts[0]+='.';\n\t\t\ts[1]+='#';\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\tif (res=='e')\n\t\t\t\treturn 0;\n\t\t\ts[0].erase(s[0].size()-1,1);\n\t\t\ts[1].erase(s[1].size()-1,1);\n\t\t\ts[0]+='#';\n\t\t\ts[1]+='.';\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\tif (res=='e')\n\t\t\t\treturn 0;\n\t\t\ts[0].erase(s[0].size()-1,1);\n\t\t\ts[1].erase(s[1].size()-1,1);\n\t\t\ts[0]+='#';\n\t\t\ts[1]+='#';\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\tif (res=='e')\n\t\t\t\treturn 0;\n\t\t\ts[0].erase(s[0].size()-1,1);\n\t\t\ts[1].erase(s[1].size()-1,1);\n\t\t\tapp=false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts[0]='.'+s[0];\n\t\t\ts[1]='.'+s[1];\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\tif (res=='e')\n\t\t\t\treturn 0;\n\t\t\ts[0].erase(0,1);\n\t\t\ts[1].erase(0,1);\n\t\t\ts[0]='.'+s[0];\n\t\t\ts[1]='#'+s[1];\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\tif (res=='e')\n\t\t\t\treturn 0;\n\t\t\ts[0].erase(0,1);\n\t\t\ts[1].erase(0,1);\n\t\t\ts[0]='#'+s[0];\n\t\t\ts[1]='.'+s[1];\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\tif (res=='e')\n\t\t\t\treturn 0;\n\t\t\ts[0].erase(0,1);\n\t\t\ts[1].erase(0,1);\n\t\t\ts[0]='#'+s[0];\n\t\t\ts[1]='#'+s[1];\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\tif (res=='e')\n\t\t\t\treturn 0;\n\t\t\ts[0].erase(0,1);\n\t\t\ts[1].erase(0,1);\n\t\t\tapp=true;\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar c1[] = { '#', '.', '#', '.' };\nchar c2[] = { '.', '#', '#', '.' };\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> s1, s2, rs1, rs2;\n    char resp[5];\n    bool rev = false;\n    for (int i = 0; i < n; ++i) {\n        if (!rev) {\n            bool ok = false;\n            for (int t = 0; t < 4; ++t) {\n                for (int k = 0; k < s1.size(); ++k) printf(\"%c\", s1[k]);\n                printf(\"%c\\n\", c1[t]);\n                for (int k = 0; k < s2.size(); ++k) printf(\"%c\", s2[k]);\n                printf(\"%c\\n\", c2[t]);\n                scanf(\"%s\", resp);\n                if (resp[0] == 'e') {\n                    return 0;\n                }\n                else if (resp[0] == 'T') {\n                    ok = true;\n                    s1.push_back(c1[t]), s2.push_back(c2[t]);\n                    break;\n                }\n            }\n            if (!ok) rev = true;\n        }\n        if (rev) {\n            for (int t = 0; t < 4; ++t) {\n                printf(\"%c\", c1[t]);\n                for (int k = rs1.size()-1; k >= 0; --k) printf(\"%c\", rs1[k]);\n                for (int k = 0; k < s1.size(); ++k) printf(\"%c\", s1[k]);\n                puts(\"\");\n                printf(\"%c\", c2[t]);\n                for (int k = rs2.size()-1; k >= 0; --k) printf(\"%c\", rs2[k]);\n                for (int k = 0; k < s2.size(); ++k) printf(\"%c\", s2[k]);\n                puts(\"\");\n                scanf(\"%s\", resp);\n                if (resp[0] == 'e') {\n                    return 0;\n                }\n                else if (resp[0] == 'T') {\n                    rs1.push_back(c1[t]), rs2.push_back(c2[t]);\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAX = 150;\nconst char board[2] = {'.', '#'};\n\nint main() {\n    int N;\n    cin >> N;\n    int dir = 0;\n    string ans1, ans2;\n    while (1) {\n        string up = ans1, bottom = ans2;\n        up += board[dir/2];\n        bottom += board[dir%2];\n        cout << up << endl;\n        cout << bottom << endl;\n        string input;\n        cin >> input;\n        if (input == \"end\") {\n            return 0;\n        } else if (input == \"T\") {\n            ans1 = up;\n            ans2 = bottom;\n            dir = 0;\n            continue;\n        } else {\n            dir++;\n            if (dir == 4) {\n                dir = 0;\n                break;\n            }\n        }\n    }\n    while (1) {\n        string up = board[dir/2]+ans1, bottom = board[dir%2] + ans2;\n        cout << up << endl;\n        cout << bottom << endl;\n        string input;\n        cin >> input;\n        if (input == \"end\") return 0;\n        else if (input == \"T\") {\n            ans1 = up;\n            ans2 = bottom;\n            dir = 0;\n            continue;\n        } else {\n            dir++;\n            assert(dir < 4);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tstring s, t;\n\n\tvector<bool> F0(4), F1(4);\n\n\twhile (true) {\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (F0[i]) continue;\n\t\t\tstring ns = s + (\"#.\")[i >> 0 & 1];\n\t\t\tstring nt = t + (\"#.\")[i >> 1 & 1];\n\t\t\tcout << ns << endl;\n\t\t\tcout << nt << endl;\n\t\t\tstring res;\n\t\t\tcin >> res;\n\t\t\tif (res == \"end\") return 0;\n\t\t\tif (res == \"T\") {\n\t\t\t\tok = true;\n\t\t\t\ts = ns;\n\t\t\t\tt = nt;\n\t\t\t\tfor (int i = 0; i < 4; i++) F0[i] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tF0[i] = true;\n\t\t}\n\t\tif (ok) continue;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (F1[i]) continue;\n\t\t\tstring ns = (\"#.\")[i >> 0 & 1] + s;\n\t\t\tstring nt = (\"#.\")[i >> 1 & 1] + t;\n\t\t\tcout << ns << endl;\n\t\t\tcout << nt << endl;\n\t\t\tstring res;\n\t\t\tcin >> res;\n\t\t\tif (res == \"end\") return 0;\n\t\t\tif (res == \"T\") {\n\t\t\t\tok = true;\n\t\t\t\ts = ns;\n\t\t\t\tt = nt;\n\t\t\t\tfor (int i = 0; i < 4; i++) F1[i] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tF1[i] = true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n#else\n\t// #define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { cout << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RBP(i,a) for(auto& i : a)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\n#define rangej(a,b,c) ((a) <= (c) and (c) < (b))\n#define rrangej(b,c) rangej(0,b,c)\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nconst string chs = \".#\";\n\nint main()\n{\n\t// ios_init();\n\tint n;\n\tcin >> n;\n\tstring s1, s2;\n\tbool f = false;\n\twhile(SZ(s1) < n){\n\t\t[&](){\n\t\t\tREP(i,2) REP(j,2){\n\t\t\t\tstring ns1 = s1+chs[i];\n\t\t\t\tstring ns2 = s2+chs[j]; \n\t\t\t\tcout << ns1 << endl << ns2 << endl;\n\t\t\t\tstring r;\n\t\t\t\tcin >> r;\n\t\t\t\tif(r == \"T\"){\n\t\t\t\t\ts1 = ns1;\n\t\t\t\t\ts2 = ns2;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(r == \"end\"){\n\t\t\t\t\tf = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t}();\n\t\tif(f) return 0;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n//#define long long ll\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s1, s2;\n\ts1 = \"\";\n\ts2 = \"\";\n\tbool rev = false;\n\twhile (true) {\n\t\tstring n1, n2;\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (i & 1)\n\t\t\t\tn1 = (rev ? '#' + s1 : s1 + '#');\n\t\t\telse\n\t\t\t\tn1 = (rev ? '.' + s1 : s1 + '.');\n\t\t\tif (i & 2)\n\t\t\t\tn2 = (rev ? '#' + s2 : s2 + '#');\n\t\t\telse\n\t\t\t\tn2 = (rev ? '.' + s2 : s2 + '.');\n\t\t\tcout << n1 << '\\n' << n2 << '\\n';\n\t\t\tcout.flush();\n\t\t\tstring res;\n\t\t\tcin >> res;\n\t\t\tif (res == \"end\")\n\t\t\t\treturn 0;\n\t\t\tif (res == \"T\") {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok)\n\t\t\trev = true;\n\t\telse {\n\t\t\ts1 = n1;\n\t\t\ts2 = n2;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for (int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for (int (i) = (a) - 1; (i) >= (b); (i)--)\n#define PI acos(-1.0)\n#define DEBUG(C) cout<< C <<endl;\n#define VI vector <int>\n#define VII vector <VI>\n#define VL vector <LL>\n#define VLL vector <VL>\n#define VD vector <double>\n#define VDD vector <VD>\n#define PII pair <int, int>\n#define PDD pair <double, double>\n#define PLL pair <LL, LL>\n#define VPII vector <PII>\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define REVERSE(a) reverse(ALL(a))\n#define MP make_pair\n#define EB emplace_back\n#define FORE(a, b) for (auto &&a:b)\n#define FIND(s, n) (s.find(n) != s.end())\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int INF = 1e9;\nconst int MOD = INF + 7;\n\nstring cc[2];\n\nint main(void) {\n    cc[0] = \"..##\";\n    cc[1] = \".#.#\";\n    set <vector <string>> nai;\n    int N; cin >> N;\n    vector <string> S(2, \"\"), Sbuf(2);\n    int cnt = 0;\n    S[0] += cc[0][0];\n    S[1] += cc[1][0];\n    REP(_, 420) {\n        printf(\"%s\\n%s\\n\", S[0].c_str(), S[1].c_str());\n        string c; cin >> c;\n        if (c == \"T\") {\n            Sbuf = S;\n            cnt = 0;\n            REP(i, 2) {\n                S[i] += cc[i][cnt];\n            }\n        } else if (c == \"F\") {\n            nai.insert(S);\n            label:\n            S = Sbuf;\n            cnt++;\n            if (cnt >= 4) {\n                REP(i, 2) {\n                    S[i] = cc[i][cnt % 4] + S[i];\n                }\n            } else {\n                REP(i, 2) {\n                    S[i] += cc[i][cnt % 4];\n                }\n            }\n            if (FIND(nai, S)) {\n                goto label;\n            }\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int n;\n  std::cin >> n;\n  string s = \"\", ss = \"\", r;\n  string ds[] = {\".\", \"#\"};\n  bool back = true;\n  for (int i = 0; i < 111; i++) {\n    for (int j = 0; j < 4; j++) {\n      string ts, tss; \n      if(back){\n        ts = s + ds[j/2], tss = ss + ds[j%2];\n      }else{\n        ts = ds[j/2] + s, tss = ds[j%2] + ss;\n      }\n      std::cout << ts << std::endl;\n      std::cout << tss << std::endl;\n      fflush(stdout);\n      std::cin >> r;\n      if(r == \"T\"){\n        s  = ts;\n        ss = tss;\n        break;\n      }else if(r == \"F\" and j == 3){\n        back = false;\n      }else if(r == \"end\"){\n        i = 1e9, j = 1e9;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nchar up[]={'.','#','.','#'}, down[]={'.','#','#','.'};\nstring judge, nowup, nowdown;\n\nint main()\n{\n    cin >> n;\n    while(true) {\n        bool start = false;\n        for(int i=0; i<4; i++) {\n            if(start) continue;\n            cout << nowup+up[i] << endl << nowdown+down[i] << endl;\n            cin >> judge;\n            if(judge==\"T\") {\n                nowup+=up[i];\n                nowdown+=down[i];\n                start = true;\n            }\n            else if(judge==\"F\") continue;\n            else return 0;\n        }\n        if(!start) break;\n    }\n    while(true) {\n        bool start = false;\n        for(int i=0; i<4; i++) {\n            if(start) continue;\n            cout << up[i]+nowup << endl << down[i]+nowdown << endl;\n            cin >> judge;\n            if(judge==\"T\") {\n                nowup=up[i]+nowup;\n                nowdown=down[i]+nowdown;\n                start = true;\n            }\n            else if(judge==\"F\") continue;\n            else return 0;\n        }\n        if(!start) break;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for (int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for (int (i) = (a) - 1; (i) >= (b); (i)--)\n#define PI acos(-1.0)\n#define DEBUG(C) cout<< C <<endl;\n#define VI vector <int>\n#define VII vector <VI>\n#define VL vector <LL>\n#define VLL vector <VL>\n#define VD vector <double>\n#define VDD vector <VD>\n#define PII pair <int, int>\n#define PDD pair <double, double>\n#define PLL pair <LL, LL>\n#define VPII vector <PII>\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define REVERSE(a) reverse(ALL(a))\n#define MP make_pair\n#define EB emplace_back\n#define FORE(a, b) for (auto &&a:b)\n#define FIND(s, n) (s.find(n) != s.end())\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int INF = 1e9;\nconst int MOD = INF + 7;\n\nstring cc[2];\n\nint main(void) {\n    cc[0] = \"..##\";\n    cc[1] = \".#.#\";\n    unordered_set <string> nai[2];\n    int N; cin >> N;\n    vector <string> S(2, \"\"), Sbuf(2);\n    int cnt = 0;\n    S[0] += cc[0][0];\n    S[1] += cc[1][0];\n    REP(_, 420) {\n        printf(\"%s\\n%s\\n\", S[0].c_str(), S[1].c_str());\n        string c; cin >> c;\n        if (c == \"T\") {\n            Sbuf = S;\n            cnt = 0;\n            REP(i, 2) {\n                S[i] += cc[i][cnt];\n            }\n        } else if (c == \"F\") {\n            REP(i, 2) nai[i].insert(S[i]);\n            label:\n            S = Sbuf;\n            cnt++;\n            if (cnt >= 4) {\n                REP(i, 2) {\n                    S[i] = cc[i][cnt % 4] + S[i];\n                }\n            } else {\n                REP(i, 2) {\n                    S[i] += cc[i][cnt % 4];\n                }\n            }\n            bool f = false;\n            REP(i, 2) f = FIND(nai[i], S[i]);\n            if (f) {\n                goto label;\n            }\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tstring a, b;\n\tint flag = 1;\n\twhile (a.size() < N) {\n\t\tif (flag) {\n\t\t\ta.push_back('#');\n\t\t\tb.push_back('#');\n\t\t\tcout << a << endl;\n\t\t\tcout << b << endl;\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t\ta.push_back('#');\n\t\t\tb.push_back('.');\n\t\t\tcout << a << endl;\n\t\t\tcout << b << endl;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t\ta.push_back('.');\n\t\t\tb.push_back('#');\n\t\t\tcout << a << endl;\n\t\t\tcout << b << endl;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t\ta.push_back('.');\n\t\t\tb.push_back('.');\n\t\t\tcout << a << endl;\n\t\t\tcout << b << endl;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t\tflag = false;\n\t\t}\n\t\telse {\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\ta.push_back('#');\n\t\t\tb.push_back('#');\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\tcout << a << endl;\n\t\t\tcout << b << endl;\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t\ta.push_back('#');\n\t\t\tb.push_back('.');\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\tcout << a << endl;\n\t\t\tcout << b << endl;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t\ta.push_back('.');\n\t\t\tb.push_back('#');\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\tcout << a << endl;\n\t\t\tcout << b << endl;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t\ta.push_back('.');\n\t\t\tb.push_back('.');\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\tcout << a << endl;\n\t\t\tcout << b << endl;\n\t\t\tcin >> c;\n\t\t\tif (c == 'T') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t}\n\t}\n\tcout << a << endl;\n\tcout << b << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//1列(4通り)を質問 -> 当たったら1列（右側に）追加して(4通り)質問 -> …を繰り返すと400回以内で当たらなくなる（かendが返る）\n//このとき、質問した列は黒板の右端にある。あとは、同様にして左側を特定すればよい。\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring reverse(string str) {\n\tstring ret;\n\tfor (int i = (int)str.length() - 1; i >= 0; i--) ret += str[i];\n\treturn ret;\n}\n\nint n;\nstring query[2];\n\nvoid addCharRight(int type) {\n\tchar c0 = ((type / 2) % 2 ? '#' : '.');\n\tchar c1 = (type % 2 ? '#' : '.');\n\tquery[0] += c0;\n\tquery[1] += c1;\n}\n\nvoid addCharLeft(int type) {\n\tchar c0 = ((type / 2) % 2 ? '#' : '.');\n\tchar c1 = (type % 2 ? '#' : '.');\n\treverse(query[0]);\n\treverse(query[1]);\n\tquery[0] += c0;\n\tquery[1] += c1;\n\treverse(query[0]);\n\treverse(query[1]);\n}\n\nvoid delCharRight() {\n\tstring s[2];\n\tfor (int i = 0; i < (int)query[0].size() - 1; i++) s[0] += query[0][i];\n\tfor (int i = 0; i < (int)query[1].size() - 1; i++) s[1] += query[1][i];\n\tquery[0] = s[0];\n\tquery[1] = s[1];\n}\n\nvoid delCharLeft() {\n\tstring s[2];\n\tfor (int i = 1; i < (int)query[0].size(); i++) s[0] += query[0][i];\n\tfor (int i = 1; i < (int)query[1].size(); i++) s[1] += query[1][i];\n\tquery[0] = s[0];\n\tquery[1] = s[1];\n}\n\n//return : {T, F, end}\nchar getQuery() {\n\tcout << query[0] << endl;\n\tcout << query[1] << endl;\n\tcout.flush();\n\tstring ret[3];\n\tcin >> ret;\n\treturn ret[0];\n}\n\n//return : {T, F, e}\nchar addQueryRight(int type) {\n\taddCharRight(type);\n\tchar res = getQuery();\n\tif (res == 'e' || res == 'T') return res;\n\tdelCharRight(type);\n\treturn res;\n}\n\nchar addQueryLeft(int type) {\n\taddCharLeft(type);\n\tchar res = getQuery();\n\tif (res == 'e' || res == 'T') return res;\n\tdelCharLeft(type);\n\treturn res;\n}\n\nsigned main() {\n\tcin >> n;\n\t\n\tint j;\n\t\n\twhile (true) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tchar res = addQueryRight(j);\n\t\t\tif (res == 'e') return 0;\n\t\t\tif (res == 'T') break;\n\t\t}\n\t\tif (j == 4) break;\n\t}\n\t\n\twhile (true) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tchar res = addQueryLeft(j);\n\t\t\tif (res == 'e') return 0;\n\t\t\tif (res == 'T') break;\n\t\t}\n\t\tif (j == 4) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ここからテンプレート\n//#define PLASMA_NO_BOOST\n#if 1\n\n#include<iostream>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<type_traits>\n#include<tuple>\n#include<memory>\n#include<iterator>\n#include<string>\n#include<functional>\n#include<list>\n#include<array>\n#include<complex>\n#include<numeric>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<random>\n#include<map>\n#include<chrono>\n#include<stack>\n#include<set>\n\n#ifndef PLASMA_NO_BOOST\n#include<boost/optional.hpp>\n#include<boost/optional/optional_io.hpp>\n#include<boost/variant.hpp>\n#include<boost/range/adaptor/transformed.hpp>\n#include<boost/range/adaptor/indexed.hpp>\n#include<boost/range/adaptor/filtered.hpp>\n#include<boost/range/algorithm.hpp>\n#include<boost/range/irange.hpp>\n#include<boost/multi_array.hpp>\n#include<boost/preprocessor.hpp>\n#endif\n\ntypedef long long int int64;\ntypedef unsigned long long uint64;\ntypedef long double double64;\n\n#ifdef PLASMA_NO_BOOST\nstruct none_t {};\nconstexpr none_t none{};\ntemplate<class T>class optional\n{\n\tunion inside_t\n\t{\n\t\tT value;\n\t\tnone_t ignore;\n\t\tconstexpr inside_t(T const& v) :value(v) {}\n\t\tconstexpr inside_t(T&& v) : value(std::move(v)) {}\n\t\tconstexpr inside_t(none_t) : ignore(none) {}\n\t\tconstexpr inside_t() : ignore(none) {}\n\t\tconstexpr inside_t(inside_t const&) = default;\n\t\tinside_t(inside_t&&) = default;\n\t\tinside_t& operator=(inside_t const&) = default;\n\t\tinside_t& operator=(inside_t&&) = default;\n\t\t~inside_t() = default;\n\t};\n\tinside_t inside;\n\tbool flag;\npublic:\n\tvoid swap(optional&& v)\n\t{\n\t\tstd::swap(this->inside, v.inside);\n\t\tstd::swap(this->flag, v.flag);\n\t}\n\tvoid reset()\n\t{\n\t\tif (flag)\n\t\t{\n\t\t\tinside.value.~T();\n\t\t\tinside.ignore = none;\n\t\t\tflag = false;\n\t\t}\n\t}\n\n\tconstexpr optional(T const& v) :inside(v), flag(true) {}\n\tconstexpr optional(T&& v) : inside(std::move(v)), flag(true) {}\n\tconstexpr optional(none_t) : inside(), flag(false) {}\n\tconstexpr optional() : inside(), flag(false) {}\n\tconstexpr optional(optional const& v) : inside(v.inside), flag(v.flag) {}\n\toptional(optional&& v) : optional()\n\t{\n\t\tswap(std::move(v));\n\t}\n\toptional& operator=(optional const& v)\n\t{\n\t\tthis->inside = v.inside;\n\t\tthis->flag = v.flag;\n\t\treturn *this;\n\t}\n\toptional& operator=(optional&& v)\n\t{\n\t\tswap(std::move(v));\n\t\tv.reset();\n\t\treturn *this;\n\t}\n\toptional& operator=(T const& v)\n\t{\n\t\treset();\n\t\tinside.value = v;\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(T&& v)\n\t{\n\t\treset();\n\t\tinside.value = std::move(v);\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(none_t)\n\t{\n\t\treset();\n\t\treturn *this;\n\t}\n\n\tconstexpr operator bool()const\n\t{\n\t\treturn flag;\n\t}\n\tconstexpr T const& operator*()const\n\t{\n\t\treturn flag ? inside.value : throw std::domain_error(\"optional error: dont have value\");\n\t}\n};\ntemplate<class T>constexpr optional<typename std::remove_reference<typename std::remove_const<T>::type>::type>make_optional(T&& v)\n{\n\treturn optional<std::remove_reference_t<std::remove_const_t<T>>>(std::forward<T>(v));\n}\n#else\nusing boost::optional;\nusing boost::none_t;\nusing boost::none;\n#endif\n\n#ifndef PLASMA_NO_BOOST\nnamespace adaptor\n{\n\tusing namespace boost::adaptors;\n}\nnamespace algorithm\n{\n\tusing namespace boost::range;\n\ttemplate<class SinglePassRange, class Pred>bool any_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::any_of(std::begin(range), std::end(range), pred);\n\t}\n\ttemplate<class SinglePassRange, class Pred>bool all_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::all_of(std::begin(range), std::end(range), pred);\n\t}\n}\n#endif\nnamespace math\n{\n\ttemplate<class T>constexpr T pow(T p, int n)\n\t{\n\t\treturn n == 0 ? T(1) : n == 1 ? p : n == 2 ? p*p : n % 2 == 0 ? pow(pow(p, n / 2), 2) : pow(pow(p, n / 2), 2)*p;\n\t}\n\n\tint log(long long int p, int n)\n\t{\n\t\tint64 t = n;\n\t\tfor (int i = 0;;++i)\n\t\t{\n\t\t\tif (t > p)\n\t\t\t\treturn i;\n\t\t\tt *= n;\n\t\t}\n\t}\n\n\tconstexpr double pi = 3.141592653589793;\n\n\tnamespace detail\n\t{\n\t\tint gcd(int larger, int less)\n\t\t{\n\t\t\treturn less == 0 ? larger : gcd(less, larger%less);\n\t\t}\n\t}\n\n\tint gcd(int lhs, int rhs)\n\t{\n\t\treturn lhs < rhs ? detail::gcd(rhs, lhs) : detail::gcd(lhs, rhs);\n\t}\n\n\tvoid fourier_transform(\n\t\tstd::vector<std::complex<double>>& vec, std::size_t N)\n\t{\n\t\tstd::vector<std::complex<double>> butterfly;\n\t\tvec.resize(N);\n\t\tbutterfly.resize(N);\n\n\t\tstd::complex<double> half(std::cos(pi), std::sin(pi));\n\t\tfor (uint64 i = 1, k = N / 2;i < N;[&]() {i *= 2;k /= 2;}())//i*k == N/4\n\t\t{\n\t\t\tstd::complex<double> circle(std::cos(pi / i), std::sin(pi / i));\n\t\t\tstd::complex<double> c(1.0, 0);\n\t\t\tfor (auto count = 0ull; count < i;++count)\n\t\t\t{\n\t\t\t\tfor (auto j = 0ull;j < k;++j)\n\t\t\t\t{\n\t\t\t\t\tbutterfly[count*k + j] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c;\n\t\t\t\t\tbutterfly[count*k + j + N / 2] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c*half;\n\t\t\t\t}\n\t\t\t\tc *= circle;\n\t\t\t}\n\t\t\tstd::swap(vec, butterfly);\n\t\t}\n\t}\n\n\tclass polynomial\n\t{\n\t\tstd::vector<std::complex<double>> value;\n\t\tvoid swap(polynomial&& p)\n\t\t{\n\t\t\tstd::swap(value, p.value);\n\t\t}\n\tpublic:\n\t\tpolynomial() :value{ 0.0 } {}\n\t\tpolynomial(polynomial const&) = default;\n\t\tpolynomial(std::vector<std::complex<double>>&& vec) :value(std::move(vec)) {}\n\t\tpolynomial(polynomial&& p) :polynomial()\n\t\t{\n\t\t\tswap(std::move(p));\n\t\t}\n\t\tpolynomial(std::initializer_list<std::complex<double>> lis) :value(lis) {}\n\t\tpolynomial(std::complex<double> c) :polynomial({ c }) {}\n\n\t\tpolynomial& operator=(polynomial const&) = default;\n\t\tpolynomial& operator=(polynomial&& p)\n\t\t{\n\t\t\tvalue = std::vector<std::complex<double>>{ 0.0 };\n\t\t\tswap(std::move(p));\n\t\t\treturn *this;\n\t\t}\n\n\t\t~polynomial() = default;\n\t\tstd::complex<double> operator[](std::size_t deg)const\n\t\t{\n\t\t\treturn deg >= value.size() ? 0.0 : value[deg];\n\t\t}\n\t\tstd::size_t degree()const\n\t\t{\n\t\t\treturn value.size() - 1;\n\t\t}\n\t\tvoid strict_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tif (value[N] != 0.0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\t\tvoid integer_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tstd::cout << value[N] << \" \" << (std::norm(value[N]) > (1.0e-20)) << std::endl;\n\t\t\t\tif (std::norm(value[N]) > (1.0e-20))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\n\t\tfriend polynomial operator*(polynomial const& lhs, polynomial const& rhs)\n\t\t{\n\t\t\tstd::size_t N = 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tN *= 2;\n\t\t\t\tif (N > (lhs.degree() + rhs.degree()))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto lhs_ = lhs.value;\n\t\t\tauto rhs_ = rhs.value;\n\t\t\tfourier_transform(lhs_, N);\n\t\t\tfourier_transform(rhs_, N);\n\t\t\tstd::vector<std::complex<double>> vec;\n\t\t\tvec.reserve(N);\n\t\t\tfor (std::size_t i = 0;i < N;++i)\n\t\t\t{\n\t\t\t\tvec.push_back(lhs_[i] * rhs_[i]);\n\t\t\t}\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = 2 * v.real() - v;\n\t\t\t}\n\t\t\tfourier_transform(vec, N);\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = (2 * v.real() - v)*(1.0 / N);\n\t\t\t}\n\t\t\tstd::size_t k = N;\n\t\t\tfor (;k > 0;--k)\n\t\t\t{\n\t\t\t\tif (std::norm(vec[k]) > 1.0e-23)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec.resize(k + 1);\n\t\t\treturn polynomial(std::move(vec));\n\t\t}\n\t};\n\n\tint real_integer(std::complex<double> c)\n\t{\n\t\tint v = static_cast<int>(c.real());\n\t\tdouble u = c.real() - v;\n\t\treturn v + static_cast<int>(2 * u);\n\t}\n\n\ttemplate<class T>polynomial make_poly(std::vector<T> const& vec)\n\t{\n\t\tauto range = vec | adaptor::transformed([](T const& v) {return static_cast<std::complex<double>>(v);});\n\t\tstd::vector<std::complex<double>> ret(std::begin(range), std::end(range));\n\t\treturn polynomial(std::move(ret));\n\t}\n\tpolynomial make_poly(std::initializer_list<double>init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\tpolynomial make_poly(std::initializer_list<int> init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\ttemplate<class T>class infinite_value\n\t{\n\t\toptional<T> val;\n\tpublic:\n\t\tinfinite_value(T const& v) :val(v) {}\n\t\tinfinite_value(T&& v) :val(std::move(v)) {}\n\t\tinfinite_value(none_t = none) :val() {}\n\t\tinfinite_value(infinite_value const&) = default;\n\t\tinfinite_value(infinite_value&&) = default;\n\t\t~infinite_value() = default;\n\n\t\tinfinite_value& operator=(T const& v)\n\t\t{\n\t\t\tval = v;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(T&& v)\n\t\t{\n\t\t\tval = std::move(v);\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(none_t)\n\t\t{\n\t\t\tval = boost::none;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(infinite_value const&) = default;\n\t\tinfinite_value& operator=(infinite_value&&) = default;\n\n\t\toperator bool()const\n\t\t{\n\t\t\treturn static_cast<bool>(val);\n\t\t}\n\t\tT const& operator*()const\n\t\t{\n\t\t\treturn *val;\n\t\t}\n\n\t\tfriend infinite_value operator+(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs ? infinite_value<T>(*lhs + rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\n\t\tfriend bool operator==(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (!lhs && !rhs) || (lhs&&rhs && (*lhs == *rhs));\n\t\t}\n\t\tfriend bool operator==(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs && (*lhs == rhs);\n\t\t}\n\t\tfriend bool operator==(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn rhs && (lhs == *rhs);\n\t\t}\n\n\n\t\tfriend bool operator<(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : !rhs ? true : *lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : *lhs < rhs;\n\t\t}\n\t\tfriend bool operator<(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? true : lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\n\n\t\tfriend bool operator>(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn  !rhs ? false : !lhs ? true : *lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? true : *lhs > rhs;\n\t\t}\n\t\tfriend bool operator>(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? false : lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\n\t};\n\ttemplate<std::size_t Mod>class modulo_number\n\t{\n\t\tuint64 val = {};\n\t\tstatic constexpr uint64 abs(int64 n)\n\t\t{\n\t\t\treturn n <= -1 ? n + Mod : n;\n\t\t}\n\tpublic:\n\t\tmodulo_number(modulo_number const&) = default;\n\t\tmodulo_number(modulo_number&&) = default;\n\t\tmodulo_number& operator=(modulo_number const&) = default;\n\t\tmodulo_number& operator=(modulo_number&&) = default;\n\t\t~modulo_number() = default;\n\n\t\tconstexpr modulo_number(uint64 num = {}) : val(num%Mod) {}\n\t\tconstexpr modulo_number(unsigned int num) : val(num%Mod) {}\n\t\tconstexpr modulo_number(int64 num) : val(abs(num%Mod)) {}\n\t\tconstexpr modulo_number(int num) : val(abs(num%Mod)) {}\n\n\t\tmodulo_number& operator=(uint64 num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int64 num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(unsigned int num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn val;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + Mod - rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val*rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn lhs*math::pow(rhs, Mod - 2);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\n\t\ttemplate<class Rhs>decltype(auto) operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator/=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this / rhs;\n\t\t}\n\t};\n\n\ttemplate<class T>constexpr T factorial(std::size_t n, std::size_t goal = 1)\n\t{\n\t\treturn n == goal ? T(n) : n == 0 ? T(1) : factorial<T>(n, (n + goal) / 2 + 1)*factorial<T>((n + goal) / 2, goal);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr uint64 integral_sqrt_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? start :\n\t\t\t\tpow((start + end) / 2 + 1, 2) <= v ?\n\t\t\t\tintegral_sqrt_i(v, (start + end) / 2 + 1, end) :\n\t\t\t\tintegral_sqrt_i(v, start, (start + end) / 2);\n\t\t}\n\t}\n\n\tconstexpr uint64 integral_sqrt(uint64 v)\n\t{\n\t\treturn v == 0 ? 0 :\n\t\t\tv == 1 ? 1 :\n\t\t\tdetail::integral_sqrt_i(v, 1, 0b100000000000000000000000000000000ull);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr bool is_prime_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? v%end != 0 :\n\t\t\t\tis_prime_i(v, start, (start + end) / 2) &&\n\t\t\t\tis_prime_i(v, (start + end) / 2 + 1, end);\n\t\t}\n\t}\n\n\tconstexpr bool is_prime(uint64 v)\n\t{\n\t\treturn v == 0 ? false :\n\t\t\tv == 1 ? false :\n\t\t\tv == 2 ? true :\n\t\t\tv == 3 ? true : detail::is_prime_i(v, 2, integral_sqrt(v));\n\t}\n\n\tclass dynamic_modulo\n\t{\n\t\tuint64 value;\n\t\tuint64 mod;\n\t\tstatic constexpr uint64 abs(int64 v, uint64 mod)\n\t\t{\n\t\t\treturn v <= -1 ? v + mod : v;\n\t\t}\n\tpublic:\n\t\tconstexpr dynamic_modulo() :value(), mod(2) {}\n\t\tconstexpr dynamic_modulo(uint64 v, uint64 m) : value(v), mod(m) {}\n\t\tdynamic_modulo(dynamic_modulo const&) = default;\n\t\tdynamic_modulo(dynamic_modulo&&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo const&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo&&) = default;\n\t\t~dynamic_modulo() = default;\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value + rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value * rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo(abs((lhs.value - rhs.value) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\ttemplate<class Rhs>dynamic_modulo& operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t};\n}\nnamespace geometry\n{\n\ttemplate<class Type>struct point\n\t{\n\t\tType x, y;\n\t};\n\ttemplate<class Type>auto make_point(Type x, Type y)\n\t{\n\t\treturn point<Type>{x, y};\n\t}\n\ttemplate<class Type>auto operator+(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x + rhs.x, lhs.y + rhs.y);\n\t}\n\ttemplate<class Type>auto operator-(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x - rhs.x, lhs.y - rhs.y);\n\t}\n\ttemplate<class Point>struct box\n\t{\n\t\tPoint small, large;\n\t};\n\ttemplate<class Point>auto make_box(Point a, Point b)\n\t{\n\t\treturn box<Point>{\n\t\t\tmake_point(std::min(a.x, b.x), std::min(a.y, b.y)),\n\t\t\t\tmake_point(std::max(a.x, b.x), std::max(a.y, b.y))};\n\t}\n#ifndef  PLASMA_NO_BOOST\n\ttemplate<class Point>boost::optional<box<Point>> hit_check(box<Point> a, box<Point> b)\n\t{\n\t\tif (a.small.x > b.small.x)\n\t\t\tstd::swap(a, b);\n\t\tif (a.large.x < b.small.x)\n\t\t\treturn boost::none;\n\t\tauto small_x = b.small.x;\n\t\tauto large_x = std::min(b.large.x, a.large.x);\n\t\tif (a.small.y < b.small.y)\n\t\t{\n\t\t\tif (b.small.y < a.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, b.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a.small.y < b.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, a.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t}\n#endif\n}\nnamespace graph_traits\n{\n\tclass graph\n\t{\n\t\tstd::vector<int64> node_data;\n\t\tstd::vector<std::vector<std::pair<int, int64>>> edge_data;\n\tpublic:\n\t\tgraph() = default;\n\t\tgraph(std::vector<int64>&& n) :node_data(std::move(n)), edge_data{}\n\t\t{\n\t\t\tedge_data.resize(node_data.size());\n\t\t}\n\t\tgraph(std::size_t size) :node_data(size), edge_data{}\n\t\t{\n\n\t\t}\n\n\t\tvoid resize(int size)\n\t\t{\n\t\t\tnode_data.resize(size);\n\t\t\tedge_data.resize(size);\n\t\t}\n\t\tvoid edge_reserve(int size)\n\t\t{\n\t\t\tfor (auto& v : edge_data)\n\t\t\t{\n\t\t\t\tv.reserve(size);\n\t\t\t}\n\t\t}\n\n\t\tvoid add_node(int64 data)\n\t\t{\n\t\t\tnode_data.emplace_back(data);\n\t\t\tedge_data.emplace_back();\n\t\t}\n\t\tvoid add_edge(int from, int to, int64 data)\n\t\t{\n\t\t\tedge_data[from].emplace_back(to, data);\n\t\t}\n\t\tstd::vector<math::infinite_value<int64>> dijkstra(int from)const\n\t\t{\n\t\t\tstruct compare\n\t\t\t{\n\t\t\t\tbool operator()(\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& lhs,\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& rhs)const\n\t\t\t\t{\n\t\t\t\t\treturn lhs.second > rhs.second;\n\t\t\t\t}\n\t\t\t};\n\t\t\tstd::priority_queue<\n\t\t\t\tstd::pair<int, math::infinite_value<int64>>,\n\t\t\t\tstd::vector<std::pair<int, math::infinite_value<int64>>>,\n\t\t\t\tcompare>nodes;\n\t\t\tstd::vector<math::infinite_value<int64>> ret(node_data.size());\n\t\t\tfor (int i{};i < node_data.size();++i)\n\t\t\t{\n\t\t\t\tnodes.emplace(i, math::infinite_value<int64>());\n\t\t\t}\n\t\t\tnodes.emplace(from, int());\n\n\t\t\twhile (nodes.size())\n\t\t\t{\n\t\t\t\tauto p = nodes.top();\n\t\t\t\tnodes.pop();\n\t\t\t\tif (ret[p.first] <= p.second)\n\t\t\t\t\tcontinue;\n\t\t\t\tret[p.first] = p.second;\n\t\t\t\tfor (auto const& d : edge_data[p.first])\n\t\t\t\t{\n\t\t\t\t\tnodes.emplace(d.first, std::min(ret[d.first], ret[p.first] + d.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint64 operator[](int n)const\n\t\t{\n\t\t\treturn node_data[n];\n\t\t}\n\t};\n}\nnamespace container\n{\n\ttemplate<class T>using p_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n}\n\nvoid Main();\n#endif//テンプレートここまで\n//ここを書き換える\n#define PROBLEM 4\n\n//ここは書き換えない\nint main()\n{\n\tstd::cin.sync_with_stdio(false);\n\tstd::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1);\n\tMain();\n}\n\n#if BOOST_PP_EQUAL(PROBLEM, 1)\n\nvoid Main()\n{\n\tint N, A, B;\n\tstd::cin >> N >> A >> B;\n\tcontainer::p_queue<int> t;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint x;\n\t\tstd::cin >> x;\n\t\tt.emplace(x);\n\t}\n\tint size{};\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t\telse if (x >= A)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t++size;\n\t}\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tstd::cout << size << std::endl;\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 2)\n\nvoid Main()\n{\n\tint N, K;\n\tstd::cin >> N >> K;\n\tstd::array<int, 26>count = {};\n\tfor (int i{};i < N;++i)\n\t{\n\t\tstd::string str;\n\t\tstd::cin >> str;\n\t\t++count[str.front() - 'A'];\n\t}\n\tint loop{};\n\twhile (true)\n\t{\n\t\talgorithm::sort(count, std::greater<>());\n\t\tfor (int i{};i < K;++i)\n\t\t{\n\t\t\tif (count[i])\n\t\t\t{\n\t\t\t\t--count[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::cout << loop << std::endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t++loop;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 3)\n\nvoid Main()\n{\n\tstd::vector<std::pair<int,int>> table;\n\tfor (int i{};i < 128;++i)\n\t{\n\t\tint max{};\n\t\tint y{};\n\t\tfor (int j{};j < 128;++j)\n\t\t{\n\t\t\tif (max <= (i^j) + j - i)\n\t\t\t{\n\t\t\t\tmax = (i^j) + j - i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\ttable.emplace_back(std::make_pair(y, max));\n\t}\n\talgorithm::sort(table, std::greater<>());\n\tint N;\n\tstd::cin >> N;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint C, D;\n\t\tstd::cin >> C >> D;\n\t\tstd::vector<int> cookie = { D };\n\t\tint now = D;\n\t\tfor (int x = 1;x < C;++x)\n\t\t{\n\t\t\tint target{};\n\t\t\tint max{};\n\t\t\tfor (int index{};index < cookie.size();++index)\n\t\t\t{\n\t\t\t\tif (max < table[cookie[index]].second)\n\t\t\t\t{\n\t\t\t\t\tmax = table[cookie[index]].second;\n\t\t\t\t\ttarget = index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow += max;\n\t\t\tcookie.emplace_back(table[cookie[target]].first);\n\t\t\tcookie[target] ^= table[cookie[target]].first;\n\t\t}\n\t\tstd::cout << now << std::endl;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 4)\n\ntemplate<class Lhs,class Rhs>auto add(Lhs const& lhs, Rhs const& rhs)\n{\n\treturn std::make_pair(lhs.first + rhs.first, lhs.second + rhs.second);\n}\n\ntemplate<class T>int query(T const& t)\n{\n\tstatic std::string str;\n\tstd::cout << t.first << \"\\n\" << t.second << std::endl;\n\tstd::cin >> str;\n\tif (str == \"T\")\n\t\treturn 1;\n\tif (str == \"F\")\n\t\treturn 0;\n\treturn -1;\n}\n\nvoid Main()\n{\n\tint N;\n\tconst std::pair<char, char> basic[] ={\n\t\tstd::make_pair('.','.'),\n\t\tstd::make_pair('.','#'),\n\t\tstd::make_pair('#','.'),\n\t\tstd::make_pair('#','#')\n\t};\n\tstd::cin >> N;\n\tstd::array<std::vector<std::pair<std::string, std::string>>, 4> ar{};\n\tbool flags[4] = {};\n\tfor (int i{};i < 4;++i)\n\t{\n\t\tstd::pair<std::string, std::string> a;\n\t\twhile (true)\n\t\t{\n\t\t\ta = add(a, basic[i]);\n\t\t\tif (query(a) == 1) \n\t\t\t{\n\t\t\t\tar[i].emplace_back(a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tstd::pair<std::string, std::string> x;\n\tint rest{};\n\tint last{};\n\tint prev{};\n\t{\n\t\tint target, max{};\n\t\tfor (int i{};i < 4;++i)\n\t\t{\n\t\t\tif (max < ar[i].size())\n\t\t\t{\n\t\t\t\ttarget = i;\n\t\t\t\tmax = ar[i].size();\n\t\t\t}\n\t\t\telse if (ar[i].size() == 0)\n\t\t\t{\n\t\t\t\tflags[i] = true;\n\t\t\t}\n\t\t\trest += ar[i].size();\n\t\t}\n\t\tx = ar[target].back();\n\t\trest -= ar[target].size();\n\t\tflags[target] = true;\n\t\tlast = target;\n\t\tprev = target;\n\t}\n\n\twhile (true)\n\t{\n\t\tfor (int i{};i < 4;++i)\n\t\t{\n\t\t\tif (last == i)\n\t\t\t\tcontinue;\n\t\t\tif (!flags[i])\n\t\t\t{\n\t\t\t\tauto y = add(x, ar[i].back());\n\t\t\t\tint result = query(y);\n\t\t\t\tif (result == 1)\n\t\t\t\t{\n\t\t\t\t\tflags[i] = true;\n\t\t\t\t\tstd::swap(x, y);\n\t\t\t\t\trest -= ar[i].size();\n\t\t\t\t\tlast = i;\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\telse if (result == -1)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = ar[i].size() - 1;j >= 0;--j)\n\t\t\t{\n\t\t\t\tif (j + 1 + x.first.size() + rest > N)\n\t\t\t\t\tcontinue;\n\t\t\t\tauto y = add(x, ar[i][j]);\n\t\t\t\tint result = query(y);\n\t\t\t\tif (result == 1)\n\t\t\t\t{\n\t\t\t\t\tstd::swap(x, y);\n\t\t\t\t\tlast = i;\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\telse if (result == -1)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tnext:;\n\t}\n\twhile (true)\n\t{\n\t\tfor (int i{};i < 4;++i)\n\t\t{\n\t\t\tif (prev == i)\n\t\t\t\tcontinue;\n\t\t\tif (!flags[i])\n\t\t\t{\n\t\t\t\tauto y = add(ar[i].back(), x);\n\t\t\t\tint result = query(y);\n\t\t\t\tif (result == 1)\n\t\t\t\t{\n\t\t\t\t\tflags[i] = true;\n\t\t\t\t\tstd::swap(x, y);\n\t\t\t\t\trest -= ar[i].size();\n\t\t\t\t\tprev = i;\n\t\t\t\t\tgoto next2;\n\t\t\t\t}\n\t\t\t\telse if (result == -1)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n}\n\t\t\tfor (int j = ar[i].size() - 1;j >= 0;--j)\n\t\t\t{\n\t\t\t\tif (j + 1 + x.first.size() + rest > N)\n\t\t\t\t\tcontinue;\n\t\t\t\tauto y = add(ar[i][j], x);\n\t\t\t\tint result = query(y);\n\t\t\t\tif (result == 1)\n\t\t\t\t{\n\t\t\t\t\tstd::swap(x, y);\n\t\t\t\t\tprev = i;\n\t\t\t\t\tgoto next2;\n\t\t\t\t}\n\t\t\t\telse if (result == -1)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tnext2:;\n\t}\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 5)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 6)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 7)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 8)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 9)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 10)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 11)\n\nvoid Main()\n{\n\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nchar dx[]{'#','#','.','.'},dy[]{'#','.','#','.'};\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tstring s1,s2;\n\tbool flag=true;\n\twhile(1){\n\t\tif(flag){\n\t\t\tflag=false;\n\t\t\trep(i,4){\n\t\t\t\tstring s3=s1+dx[i],s4=s2+dy[i];\n\t\t\t\tcout<<s3<<endl<<s4<<endl;\n\t\t\t\tstring res;cin>>res;\n\t\t\t\tif(res==\"end\")return 0;\n\t\t\t\tif(res==\"T\"){\n\t\t\t\t\ts1=s3;s2=s4;\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\trep(i,4){\n\t\t\t\tstring s3=dx[i]+s1,s4=dy[i]+s2;\n\t\t\t\tcout<<s3<<endl<<s4<<endl;\n\t\t\t\tstring res;cin>>res;\n\t\t\t\tif(res==\"end\")return 0;\n\t\t\t\tif(res==\"T\"){\n\t\t\t\t\ts1=s3;s2=s4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<string.h>\n#include<iostream>\n\nusing namespace std;\n\nchar str1[] = {'.','#','.','#'};\nchar str2[] = {'.','.','#','#'};\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n//\tcin >> n;\n\t\n\tstring s1,s2;\n\t\n\tint toright = 1;\n\t\n\twhile(1)\n\t{\n\t\t\n\t\tint f = 0;\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\t\n\t\t\tstring temp1 = s1;\n\t\t\tstring temp2 = s2;\n\t\t\t\n\t\t\tif (toright)\n\t\t\t{\n\t\t\t\ttemp1 += str1[i];\n\t\t\t\ttemp2 += str2[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp1 = str1[i] + temp1;\n\t\t\t\ttemp2 = str2[i] + temp2;\n\t\t\t}\n\t\t\t\n\t\t\tcout << temp1 << \"\\n\" << temp2 << \"\\n\" << flush;\n\t\t\tchar s[6];\n\t\t\tscanf(\"%s\",s);\n\t\t\t\n\t\t\tif (!strcmp(s,\"end\"))\n\t\t\t\treturn 0;\n\t\t\t\n\t\t\tif (!strcmp(s,\"T\"))\n\t\t\t{\n\t\t\t\tf = 1;\n\t\t\t\ts1 = temp1;\n\t\t\t\ts2 = temp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n//\t\t\tstring s;\n//\t\t\tcin >> s;\n//\t\t\t\n//\t\t\tif (s == \"end\")\n//\t\t\t\treturn 0;\n//\t\t\t\n//\t\t\tif (s == \"T\")\n//\t\t\t{\n//\t\t\t\tf = 1;\n//\t\t\t\ts1 = temp1;\n//\t\t\t\ts2 = temp2;\n//\t\t\t\tbreak;\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif (!f)\n\t\t \ttoright = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n;\nstring s[2];\nchar res;\nint main()\n{\n\tcin >> n;\n\tbool app=true;\n\ts[0]=\"\";\n\ts[1]=\"\";\n\twhile (s[0].size()<n)\n\t\tif (app)\n\t\t{\n\t\t\ts[0]+='.';\n\t\t\ts[1]+='.';\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\ts[0].erase(s[0].size()-1,1);\n\t\t\ts[1].erase(s[1].size()-1,1);\n\t\t\ts[0]+='.';\n\t\t\ts[1]+='#';\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\ts[0].erase(s[0].size()-1,1);\n\t\t\ts[1].erase(s[1].size()-1,1);\n\t\t\ts[0]+='#';\n\t\t\ts[1]+='.';\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\ts[0].erase(s[0].size()-1,1);\n\t\t\ts[1].erase(s[1].size()-1,1);\n\t\t\ts[0]+='#';\n\t\t\ts[1]+='#';\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\ts[0].erase(s[0].size()-1,1);\n\t\t\ts[1].erase(s[1].size()-1,1);\n\t\t\tapp=false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts[0]='.'+s[0];\n\t\t\ts[1]='.'+s[1];\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\ts[0].erase(0,1);\n\t\t\ts[1].erase(0,1);\n\t\t\ts[0]='.'+s[0];\n\t\t\ts[1]='#'+s[1];\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\ts[0].erase(0,1);\n\t\t\ts[1].erase(0,1);\n\t\t\ts[0]='#'+s[0];\n\t\t\ts[1]='.'+s[1];\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tcin >> res;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\ts[0].erase(0,1);\n\t\t\ts[1].erase(0,1);\n\t\t\ts[0]='#'+s[0];\n\t\t\ts[1]='#'+s[1];\n\t\t\tcout << s[0] << '\\n';\n\t\t\tcout << s[1] << endl;\n\t\t\tif (res=='T')\n\t\t\t\tcontinue;\n\t\t\ts[0].erase(0,1);\n\t\t\ts[1].erase(0,1);\n\t\t\tapp=true;\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint main(){\n\tsrand(time(NULL));\n\tint N;\n\tcin >> N;\n\tset<vector<string> > used;\n\n\tstring c[2];\n\twhile(true){\n\t\tvector<vector<string>> lst;\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] += (k>>0&1?\".\":\"#\");\n\t\t\tb[1] += (k>>1&1?\".\":\"#\");\n\t\t\tlst.push_back(b);\n\t\t}\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\tvector<string> b = {c[0],c[1]};\n\t\t\tb[0] = (k>>0&1?\".\":\"#\") + b[0];\n\t\t\tb[1] = (k>>1&1?\".\":\"#\") + b[1];\n\t\t\tlst.push_back(b);\n\t\t}\n\t\trandom_shuffle(lst.begin(),lst.end());\n\t\tfor(int i = 0 ; i < 8 ; i++){\n\t\t\tvector<string> b = lst[i];\n\t\t\tif( i == 7 ){\n\n\t\t\t\tc[0] = b[0];\n\t\t\t\tc[1] = b[1];\n\t\t\t\tif( c[0].size() == N ){\n\t\t\t\t\tcout << c[0] << endl;\n\t\t\t\t\tcout << c[1] << endl;\t\n\t\t\t\t\tstring res;\n\t\t\t\t\tcin >> res;\t\t\t\n\t\t\t\t\tassert(res==\"end\");\n\t\t\t\t\treturn 0;\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif( used.count(b) ) continue;\n\t\t\t\tused.insert(b);\n\t\t\t\tcout << b[0] << endl;\n\t\t\t\tcout << b[1] << endl;\n\t\t\t\tstring res;\n\t\t\t\tcin >> res;\n\t\t\t\tif( res == \"T\" ){\n\t\t\t\t\tc[0] = b[0];\n\t\t\t\t\tc[1] = b[1];\n\t\t\t\t\tbreak;\t \n\t\t\t\t}\n\t\t\t\tif( res == \"end\"){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, c[26]; string s;\nint main() {\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s;\n\t\tc[s[0] - 65]++;\n\t}\n\tint ret = 0;\n\twhile(true) {\n\t\tsort(c, c + 26, greater<int>());\n\t\tint z = *min_element(c, c + m);\n\t\tif(z == 0) break;\n\t\tfor(int i = 0; i < m; i++) c[i]--;\n\t\tret++;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nstring ds = \".#\";\n\n\nint main(){\n  cin >> N;\n\n  string s1 = \"\", s2 = \"\";\n  bool LR = false;\n  while( true ){\n\n    string ns1 = s1, ns2 = s2;\n    bool ok = false;\n    for( char c1 : ds ){\n      for( char c2 : ds ){\n        if( LR ) {\n          ns1 = c1 + s1; ns2 = c2 + s2;\n        } else {\n          ns1 = s1 + c1; ns2 = s2 + c2;\n        }\n        cout << ns1 << endl;\n        cout << ns2 << endl;\n\n        string res; cin >> res;\n        if( res == \"end\" ) return 0;\n        else if( res == \"T\" ) {\n          ok = true;\n          s1 = ns1; s2 = ns2;\n          goto loop;\n        }         \n      }\n    }\n\n\n  loop:;\n    if( !ok ) LR = true;\n  }\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint N;\nconst char x[4][2][2] = {{\".\" , \".\"} , {\".\" , \"#\"} , {\"#\" , \".\"} , {\"#\" , \"#\"}};\nstring s[2];\nchar c[7];\nbool b = 1;\n\nint main(){\n\tscanf(\"%d\" , &N);\n\tfor(int i = 0 ; i < 4 ; ++i){\n\t\tprintf(\"%s\\n%s\\n\" , x[i][0] , x[i][1]);\n\t\tfflush(stdout);\n\t\tscanf(\" %s\" , c);\n\t\tif(c[0] == 'e') return 0;\n\t\tif(c[0] == 'T'){\n\t\t\ts[0] += x[i][0];\n\t\t\ts[1] += x[i][1];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 2 ; i <= N ; ++i){\n\t\tfor(int j = 0 ; j < 4 ; ++j){\n\t\t\tif(b){\n\t\t\t\tprintf(\"%s%s\\n%s%s\\n\" , s[0].c_str() , x[j][0] , s[1].c_str() , x[j][1]);\n\t\t\t\tfflush(stdout);\n\t\t\t\tscanf(\" %s\" , c);\n\t\t\t\tif(c[0] == 'e') return 0;\n\t\t\t\tif(c[0] == 'T'){\n\t\t\t\t\ts[0] += x[i][0];\n\t\t\t\t\ts[1] += x[i][1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintf(\"%s%s\\n%s%s\\n\" , x[j][0] , s[0].c_str() , x[j][1] , s[1].c_str());\n\t\t\t\tfflush(stdout);\n\t\t\t\tscanf(\" %s\" , c);\n\t\t\t\tif(c[0] == 'e') return 0;\n\t\t\t\tif(c[0] == 'T'){\n\t\t\t\t\ts[0].insert(0 , x[j][0]);\n\t\t\t\t\ts[1].insert(0 , x[j][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j == 3){\n\t\t\t\tb = 0;\n\t\t\t\tj = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nvoid solve(int N) {\n  string s1, s2;\n  bool to_right = true;\n  while(1) {\n    bool right = false;\n    REP(i,4) {\n      string tmp1, tmp2;\n      if(to_right) {\n        tmp1 = s1 + ((i / 2 == 1) ? \"#\" : \".\");\n        tmp2 = s2 + ((i % 2 == 1) ? \"#\" : \".\");\n      }else{\n        tmp1 = ((i / 2 == 1) ? \"#\" : \".\") + s1;\n        tmp2 = ((i % 2 == 1) ? \"#\" : \".\") + s2;\n      }\n      printf(\"%s\\n%s\\n\", tmp1.c_str(), tmp2.c_str()); fflush(stdout);\n      string r;\n      cin >> r;\n      if(r == \"end\"){\n        return;\n      }else if(r == \"T\") {\n        s1 = tmp1;\n        s2 = tmp2;\n        if(to_right) right = true;\n        break;\n      }\n    }\n    if(!right) {\n      to_right = false;\n    }\n  }\n}\n\nint main(){\n  int N;\n  cin >> N;\n  solve(N);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint main(){\n\tint N;\n\tcin >> N;\n\tstring c[2];\n\twhile(c[0].size() < N - 1 ){\n\t\tfor(int k = 0 ; k < 4 ; k++){\n\n\t\t\tstring b[2] = {c[0],c[1]};\n\t\t\tb[0] += (k>>0&1?\".\":\"#\");\n\t\t\tb[1] += (k>>1&1?\".\":\"#\");\n\t\t\tcout << b[0] << endl;\n\t\t\tcout << b[1] << endl;\n\t\t\tstring res;\n\t\t\tcin >> res;\n\t\t\tif( res == \"T\" ){\n\t\t\t\tc[0] = b[0];\n\t\t\t\tc[1] = b[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( res == \"end\"){ return 0; }\n\t\t}\n\t}\n\n\tfor(int k = 0 ; k < 4 ; k++){\n\n\t\tstring b[2] = {c[0],c[1]};\n\t\tb[0] += (k>>0&1?\".\":\"#\");\n\t\tb[1] += (k>>1&1?\".\":\"#\");\n\t\tcout << b[0] << endl;\n\t\tcout << b[1] << endl;\n\t\tstring res;\n\t\tcin >> res;\n\t\tif( res == \"T\" ){\n\t\t\tc[0] = b[0];\n\t\t\tc[1] = b[1];\n\t\t\tbreak;\n\t\t}\n\t\tif( res == \"end\"){ return 0; }\n\t}\n\tfor(int k = 0 ; k < 4 ; k++){\n\n\t\tstring b[2] = {c[0],c[1]};\n\t\tb[0] = (k>>0&1?\".\":\"#\") + b[0];\n\t\tb[1] = (k>>1&1?\".\":\"#\") + b[1];\n\t\tcout << b[0] << endl;\n\t\tcout << b[1] << endl;\n\t\tstring res;\n\t\tcin >> res;\n\t\tif( res == \"T\" ){\n\t\t\tc[0] = b[0];\n\t\t\tc[1] = b[1];\n\t\t\tbreak;\n\t\t}\n\t\tif( res == \"end\"){ return 0; }\n\t}\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n#else\n\t// #define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { cout << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RBP(i,a) for(auto& i : a)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\n#define rangej(a,b,c) ((a) <= (c) and (c) < (b))\n#define rrangej(b,c) rangej(0,b,c)\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nconst string chs = \".#\";\n\nint main()\n{\n\t// ios_init();\n\tint n;\n\tcin >> n;\n\tstring s1, s2;\n\tbool f = false;\n\tbool di = true;\n\twhile(SZ(s1) < n){\n\t\t[&](){\n\t\t\tREP(i,2) REP(j,2){\n\t\t\t\tstring ns1, ns2;\n\t\t\t\tif(di){\n\t\t\t\t\tns1 = s1+chs[i];\n\t\t\t\t\tns2 = s2+chs[j]; \n\t\t\t\t}else{\n\t\t\t\t\tns1 = chs.substr(i,1)+s1;\n\t\t\t\t\tns2 = chs.substr(j,1)+s2;\n\t\t\t\t}\n\t\t\t\tcout << ns1 << endl << ns2 << endl;\n\t\t\t\tstring r;\n\t\t\t\tcin >> r;\n\t\t\t\tif(r == \"T\"){\n\t\t\t\t\ts1 = ns1;\n\t\t\t\t\ts2 = ns2;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(r == \"end\"){\n\t\t\t\t\tf = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdi = false;\n\t\t}();\n\t\tif(f) return 0;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint N;\n\tcin >> N;\n\tstring s[2];\n\ts[0] = string(\".\");\n\ts[1] = string(\".\");\n\tstring tmp;\n\tbool result;\n\tint k = 0, dir = 1, last = 1;\n\twhile(1) {\n\t\tcout << s[0] << '\\n' << s[1] << endl;\n\t\tcout << \"~~~\" << endl;\n\t\tcin >> tmp;\n\t\tif(tmp == \"end\") return 0;\n\t\tresult = tmp == \"T\";\n\t\tif(result) {\n\t\t\tif(dir > 0) {\n\t\t\t\ts[0] = s[0] + \".\";\n\t\t\t\ts[1] = s[1] + \".\";\n\t\t\t} else {\n\t\t\t\ts[0] = \".\" + s[0];\n\t\t\t\ts[1] = \".\" + s[1];\n\t\t\t}\n\t\t\tlast++;\n\t\t} else {\n\t\t\tk++;\n\t\t\tif(k > 3) {\n\t\t\t\ts[0].erase((dir > 0 ? s[0].end() - 1 : s[0].begin()));\n\t\t\t\ts[1].erase((dir > 0 ? s[1].end() - 1 : s[1].begin()));\n\t\t\t\tif(dir > 0) {\n\t\t\t\t\ts[0] = s[0] + \".\";\n\t\t\t\t\ts[1] = s[1] + \".\";\n\t\t\t\t} else {\n\t\t\t\t\ts[0] = \".\" + s[0];\n\t\t\t\t\ts[1] = \".\" + s[1];\n\t\t\t\t}\n\t\t\t\tdir *= -1;\n\t\t\t\tk = 0;\n\t\t\t\tlast--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts[0][(dir > 0 ? last - 1 : 0)] = (k & 2 ? '#' : '.');\n\t\t\ts[1][(dir > 0 ? last - 1 : 0)] = (k & 1 ? '#' : '.');\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main()\n{\n  int n;\n  string s1;\n  string s2;\n  string ans;\n  char add[4][2]={{'.','.'},{'#','.'},{'.','#'},{'#','#'}};\n  int i;\n\n  cin>>n;\n\n  printf(\".\\n.\\n\");\n  fflush(stdout);\n  cin>>ans;\n  if(ans==\"end\")return 0;\n  if(ans==\"T\"){\n    s1=\".\";\n    s2=\".\";\n  }else{\n    printf(\"#\\n.\\n\");\n    fflush(stdout);\n    cin>>ans;\n    if(ans==\"end\")return 0;\n    if(ans==\"T\"){\n      s1=\"#\";\n      s2=\".\";\n    }else{\n      printf(\".\\n#\\n\");\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n      if(ans==\"T\"){\n\ts1=\".\";\n\ts2=\"#\";\n      }else{\n\ts1=\"#\";\n\ts2=\"#\";\n      }\n    }\n  }\n\n  while(1){\n    rep(i,4){\n      cout<<s1<<add[i][0]<<endl;\n      cout<<s2<<add[i][1]<<endl;\n      fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n      if(ans==\"T\"){\n\ts1=s1+add[i][0];\n\ts2=s2+add[i][1];\n\tbreak;\n      }\n    }\n    if(i==4){\n      rep(i,4){\n\tcout<<add[i][0]<<s1<<endl;\n\tcout<<add[i][1]<<s2<<endl;\n\tfflush(stdout);\n\tcin>>ans;\n\tif(ans==\"end\")return 0;\n\tif(ans==\"T\"){\n\t  s1=add[i][0]+s1;\n\t  s2=add[i][1]+s2;\n\t  break;\n\t}\n      }\n    }\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#include<string.h>\n#include<stack>\n#include<functional>\nusing namespace std;\n\nstring a = \"#.\";\nsigned main() {\n\tint b; cin >> b;\n\tstring c, d;\n\twhile (1) {\n\tl:;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tc += a[i]; d += a[j];\n\t\t\t\tcout << c << endl;\n\t\t\t\tcout << d << endl;\n\t\t\t\tstring e; cin >> e;\n\t\t\t\tif (e == \"T\") {\n\t\t\t\t\tgoto l;\n\t\t\t\t}\n\t\t\t\telse if(e==\"end\"){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc.erase(--c.end());\n\t\t\t\td.erase(--d.end());\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\twhile (1) {\n\tr:;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tc = a[i] + c; d = a[j] + d;\n\t\t\t\tcout << c << endl;\n\t\t\t\tcout << d << endl;\n\t\t\t\tstring e; cin >> e;\n\t\t\t\tif (e == \"T\") {\n\t\t\t\t\tgoto r;\n\t\t\t\t}\n\t\t\t\telse if (e == \"end\") {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc.erase(c.begin());\n\t\t\t\td.erase(d.begin());\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint main() {\n\tint N;\n\tcin >> N;\n\tbool turn = false;\n\tstring curtop, curbottom;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (!turn) {\n\t\t\tbool found = false;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tcout << (j & 2 ? \"#\" : \".\") + curtop << endl;\n\t\t\t\tcout << (j & 1 ? \"#\" : \".\") + curbottom << endl;\n\t\t\t\tstring res;\n\t\t\t\tcin >> res;\n\t\t\t\tif (res == \"T\") {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tcurtop = (j & 2 ? \"#\" : \".\") + curtop;\n\t\t\t\t\tcurbottom = (j & 1 ? \"#\" : \".\") + curbottom;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tturn = true;\n\t\t\t}\n\t\t}\n\t\tif (turn) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tcout << curtop + (j & 2 ? \"#\" : \".\") << endl;\n\t\t\t\tcout << curbottom + (j & 1 ? \"#\" : \".\") << endl;\n\t\t\t\tstring res;\n\t\t\t\tcin >> res;\n\t\t\t\tif (res == \"T\") {\n\t\t\t\t\tcurtop += (j & 2 ? \"#\" : \".\");\n\t\t\t\t\tcurbottom += (j & 1 ? \"#\" : \".\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst char c[] = {'.', '#'};\n\nbool ok(string &s1, string &s2) {\n\tprintf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n\tstring reply; cin >> reply;\n\tif (reply[0] == 'e') exit(0);\n\treturn reply[0] == 'T';\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tstring s[2];\n\ts[0] = s[1] = \"\";\n\n\tbool en = false;\n\n\tfor (int i = 1; i <= n; ) {\n\t\tbool found = false;\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\tif (found) break;\n\n\t\t\t\tauto guess = [&](int j, int k) {\n\t\t\t\t\tif (!en) {\n\t\t\t\t\t\ts[0] += c[j]; s[1] += c[k];\n\t\t\t\t\t\tif (ok(s[0], s[1])) return true;\n\t\t\t\t\t\ts[0].pop_back(); s[1].pop_back();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\telse {\n\t\t\t\t\t\ts[0] = c[j] + s[0]; s[1] = c[k] + s[1];\n\t\t\t\t\t\tif (ok(s[0], s[1])) return true;\n\t\t\t\t\t\ts[0].erase(s[0].begin()); s[1].erase(s[1].begin());\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (guess(j, k)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!found) en = true;\n\t\telse ++i;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nbool owari = false;\n\nbool f(vector<int> a) {\n\tstring s, t;\n\tfor (int x: a) {\n\t\ts.pb(\".#\"[x>>0 & 1]);\n\t\tt.pb(\".#\"[x>>1 & 1]);\n\t}\n\tcout << s << endl;\n\tcout << t << endl;\n\tstring ans; cin >> ans;\n\tif (ans == \"end\") owari = true;\n\treturn ans == \"T\";\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> a;\n\tbool unko = false;\n\tfor (;;) {\n\t\tint x;\n\t\tfor (x = 0; x < 4; x++) {\n\t\t\tif (unko) a.insert(a.begin(), x);\n\t\t\telse a.pb(x);\n\t\t\tbool ans = f(a);\n\t\t\tif (owari) return 0;\n\t\t\tif (ans) break;\n\t\t\tif (unko) a.erase(a.begin());\n\t\t\telse a.pop_back();\n\t\t}\n\t\tif (x == 4) unko = true;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef pair<string, string>P;\ntypedef long long ll;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\nint main() {\n\tint n; cin >> n;\n\tdeque<P>po;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po.push_back(P(s1, s2));\n\t}\n\tdeque<P>po1 = po;\n\twhile (1) {\n\t\tif (n & 1) {\n\t\t\tint size = po1.size();\n\t\t\tfor (int p = 0; p < size; p++) {\n\t\t\t\tfor (int l = 0; l < po.size(); l++) {\n\t\t\t\t\tP j = po1[p], i = po[l];\n\t\t\t\t\tcout << j.first + i.first << endl << j.second + i.second << endl;\n\t\t\t\t\tcin >> res;\n\t\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\t\tif (res == \"T\")po1.push_back(P(j.first + i.first, j.second + i.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, size)po1.pop_front();\n\t\t}\n\t\telse {\n\t\t\tint size = po1.size();\n\t\t\tfor (P i : po1)for (P j : po1) {\n\t\t\t\tcout << i.first + j.first << endl << i.second + j.second << endl;\n\t\t\t\tcin >> res;\n\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\tif (res == \"T\")po1.push_back(P(i.first + j.first, i.second + j.second));\n\t\t\t}\n\t\t\trep(i, size)po1.pop_front();\n\t\t}\n\t\tn >>= 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\n\nstring query(pair<string,string> p1,pair<string,string> p2){\n  string s1,s2;\n  s1 = p1.first + p2.first;\n  s2 = p1.second + p2.second;\n  printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str()); fflush(stdout);\n  string str;\n  cin >> str;\n  return str;\n}\n\nint main(){\n  int N;\n  cin >> N;\n\n  set<pair<string,string> >st;\n  for(int i = 0 ; i < 2 ; i++){\n    string str1;\n    string str2;\n    for(int j = 0 ; j < 4 ; j++){\n      str1 += (j%2?\".\":\"#\");\n      str2 += ((j >> 1)%2?\".\":\"#\");\n    }\n    st.insert(make_pair(str1,str2));\n  }\n\n  pair<string,string>rp;\n  \n  while(1){\n    vector<pair<string,string> >vec(st.begin(),st.end());\n    for(int i = 0 ; i < vec.size() ; i++){\n      for(int k = 0 ; k < 2 ; k++){\n\tstring r;\n\tpair<string,string>p;\n\tif(k % 2){\n\t  r = query(rp,vec[j]);\n\t  p = make_pair(rp.first + vec[j].first,rp.second + vec[j].second);\n\t}\n\telse {\n\t  r = query(vec[j],rp);\n\t  p = make_pair(vec[j].first + rp.first,vec[j].second + rp.second);\n\t}\n\t// in\n\tif(r == \"T\"){\n\t  if(rp.first.size() > p.first.size())rp = p;\n\t  st.insert(p);\n\t}\n\telse if(r == \"end\"){\n\t  return 0;\n\t}\n      }\n    }\n  }\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n\", u.c_str());\n  printf(\"%s\\n\", d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  int sw = 0;\n  while (true) {\n    int j = 0;\n    for (j = 0; j < 4; ++j) {\n      string r = (sw == 0 ? ask(u + du[j], d + dd[j]) : ask(du[j] + u, dd[j] + d));\n      if (r == \"end\") {\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    if (j == 5) {\n      sw = 1 - sw;\n      continue;\n    }\n    if (sw == 0) {\n      u += du[j];\n      d += dd[j];\n    } else {\n      u = du[j] + u;\n      d = dd[j] + d;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int, int>\n#define vii vector<pii>\n#define ll long long\n#define mp(x, y) make_pair(x, y)\n#define pb(x) push_back(x)\n\n\n// template\nchar tempatas[] = {'.', '.', '#', '#'};\nchar tempbawah[] = {'.', '#', '.', '#'};\n\n\nint main() {\n//\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\t\n\tint n;\n\tscanf(\"%d\", &n);\n\tstring atas = \"\";\n\tstring bawah = \"\";\n\t\n\tchar in_buffer[10] = {};\n\t\n\tfor(int i = 0; i < n; i++) {\n\t\t\n\t\tatas = '.' + atas;\n\t\tbawah = '.' + bawah;\n\t\t\n\t\tbool check = false;\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[0] = tempatas[j];\n\t\t\tbawah[0] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tcheck = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!check) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint len = atas.length();\n\tfor(len++; len <= n; len++) {\n\t\tatas = atas + '.';\n\t\tbawah = bawah + '.';\n\t\t\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\n\t\t\tatas[len-1] = tempatas[j];\n\t\t\tbawah[len-1] = tempbawah[j];\n\t\t\t\n\t\t\tprintf(\"%s\\n%s\\n\\n\\n\", atas.c_str(), bawah.c_str());\n\t\t\t\n\t\t\tscanf(\"%s\", in_buffer);\n\t\t\tif(strcmp(in_buffer, \"end\") == 0) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\treturn 0;\n\t\t\t} else if(strcmp(in_buffer, \"T\") == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\nusing namespace std;\n\nint main(){\n  int N;\n  cin >> N;\n\n  string table[2];\n  for(int i = 0 ; i < 2 ; i++){\n    for(int j = 0 ; j < N ; j++){\n      table[i] += '.';\n    }\n  }\n  \n  while(1){\n    // query\n    string n_table[2];\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n\tn_table[j] = table[j];\n      }\n\n      n_table[0] += (i%2?'#':'.');\n      n_table[1] += ((i >> 1)%2?'#':'.');\n      \n      printf(\"%s\\n%s\\n\", n_table[0].c_str(), n_table[1].c_str()); fflush(stdout);\n      // in\n      string str;\n      cin >> str;\n      if(str == \"T\"){\n\tfor(int j = 0 ; j < 2 ; j++){\n\t  table[j] = n_table[j];\n\t}\n\tbreak;\n      }\n      else if(str == \"end\"){\n\treturn 0;\n      }\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nint first = 0;\nint last = 0;\n\n\nstring ans = \"F\";\n\nbool isRight = true;\n\nint main(){\n\n\tchar dumup[201];\n\tchar *up;\n\tup = dumup + 100;\n\n\tchar dumdown[201];\n\tchar *down;\n\tdown = dumdown + 100;\n\t\n\tcin >> N;\n\tmemset(dumup,'.',sizeof(dumup));\n\tmemset(dumdown,'.',sizeof(dumdown));\n\t\n\twhile(1){\n\t\t\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[last] = intup;\n\t\t\t\tdown[last] = intdown;\n\t\t\t\tlast++;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"F\" && i == 3){\n\t\t\t\tisRight = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!isRight) break;\n\t}\n\twhile(last - first != N){\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\t\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[first-1] = intup;\n\t\t\t\tdown[first-1] = intdown;\n\t\t\t\tfirst--;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"end\"){\n\t\t\t\tisRight = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(isRight) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8101145141919364364;\n\nint main(){\n\tint n; cin>>n;\n\tstring r,s1,s2;\n\tstring eins[]={\".\",\".\",\"#\",\"#\"};\n\tstring zwei[]={\".\",\"#\",\".\",\"#\"};\n\twhile(1){\n\t\trep(i,4){\n\t\t\tstring tmp1=eins[i]+s1;\n\t\t\tstring tmp2=zwei[i]+s2;\n\t\t\tcout<<tmp1<<\"\\n\"<<tmp2<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>r;\n\t\t\tif(r==\"end\") return 0;\n\t\t\tif(r==\"T\"){\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(i==2){\n\t\t\t\ttmp1=eins[3]+s1;\n\t\t\t\ttmp2=zwei[3]+s2;\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint x=s1.size();\n\t\tif(x==n){\n\t\t\tcout<<s1<<\"\\n\"<<s2<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>r;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n \n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n \n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n \ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n \ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n \nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n \nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n \nchar xx[] = {'.', '#', '.', '#'};\nchar yy[] = {'.', '.', '#', '#'};\n \nint main() {\n    int n; cin.ignore();\n    string s1 = \"\", s2 = \"\", q;\n    string t1 = \"\", t2 = \"\";\n    bool back = false;\n    while(1) {\n        rep(i,0,4) {\n            t1 = s1; t2 = s2;\n            if(back) {\n                t1 = xx[i] + t1;\n                t2 = yy[i] + t2;\n            }\n            else {\n                t1 += xx[i];\n                t2 += yy[i];\n            }\n            cout << t1 << endl << t2 << endl; fflush(stdout);\n            cin >> q;\n            if(q == \"end\") return 0;\n            else if(q == \"T\") {\n                s1 = t1;\n                s2 = t2;\n                break;\n            }\n        }\n       back = true;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n//#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\ndeque<char> d[2];\n\nvoid hora(int tc) {\n\tint n;\n\tcin>>n;\n\twhile(1) {\n\t\tbool ada = false;\n\t\tfor(int i = 0;i < 4;i++) {\n\t\t\tada = true;\n\t\t\tfor(auto x: d[0]) cout<<x;\n\t\t\tif(i == 0 || i == 2) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tcout<<endl;\n\t\t\tfor(auto x: d[1]) cout<<x;\n\t\t\tif(i == 0 || i == 1) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tcout<<endl;\n\t\t\tstring c;\n\t\t\tcin>>c;\n\t\t\tif(c == \"T\") {\n\t\t\t\tada = true;\n\t\t\t\tif(i == 0 || i == 2) d[0].PB('.');\n\t\t\t\telse d[0].PB('#');\n\t\t\t\tif(i == 0 || i == 1) d[1].PB('.');\n\t\t\t\telse d[1].PB('#');\n\t\t\t\tbreak;\n\t\t\t} else if(c == \"end\") return ;\n\t\t}\n\t\tif(ada == false) break;\t\n\t}\n\twhile(1) {\n\t\tbool ada = false;\n\t\tfor(int i = 0;i < 4;i++) {\n\t\t\tada = true;\n\t\t\tfor(auto x: d[0]) cout<<x;\n\t\t\tif(i == 0 || i == 2) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tcout<<endl;\n\t\t\tfor(auto x: d[1]) cout<<x;\n\t\t\tif(i == 0 || i == 1) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tcout<<endl;\n\t\t\tstring c;\n\t\t\tcin>>c;\n\t\t\tif(c == \"T\") {\n\t\t\t\tada = true;\n\t\t\t\tif(i == 0 || i == 2) d[0].PF('.');\n\t\t\t\telse d[0].PF('#');\n\t\t\t\tif(i == 0 || i == 1) d[1].PF('.');\n\t\t\t\telse d[1].PF('#');\n\t\t\t\tbreak;\n\t\t\t} else if(c == \"end\") return ;\n\t\t}\n\t\tif(ada == false) break;\t\n\t}\n}\n\nint main(){\n//\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(X) X.begin(), X.end()\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\ntypedef std::pair<LL,LL> PLL;//\ntypedef std::pair<int,int> PII;//\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18+20;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\nbool END = false;\nint ENDcount = 0;\nvector< vector< vector<int> > > word(7);\n\nbool check(vector<int> v){\n\t++ENDcount;\n\tif( ENDcount > 420 ){\n\t\tEND = true;\n\t\treturn true;\n\t}\n\tint size = v.size();\n\tstring A,B;\n\tfor(int i=0;i<size;++i){\n\t\tif( v[i]&1 ){\n\t\t\tA += '#';\n\t\t}else{\n\t\t\tA += '.';\n\t\t}\n\t\tif( v[i]&2 ){\n\t\t\tB += '#';\n\t\t}else{\n\t\t\tB += '.';\n\t\t}\n\t}\n\tcout << A << '\\n' << B << endl;\n\tstring res;\n\tcin >> res;\n\tif( res[0] == 'T' ){\n\t\treturn true;\n\t}else if( res[0] == 'F' ){\n\t\treturn false;\n\t}\n\tEND = true;\n\treturn true;\n}\n\nvoid make(int POW ){\n\tif( POW == 0 ){\n\t\tvector<int> temp(1);\n\t\tfor(int i=0;i<4;++i){\n\t\t\ttemp[0] = i;\n\t\t\tif( check( temp ) ){\n\t\t\t\tword[POW].push_back( temp );\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tvector< vector<int> >::iterator itrA,itrB,begin,end;\n\tbegin = word[POW-1].begin();\n\tend = word[POW-1].end();\n\tfor(itrA=begin;itrA != end;++itrA){\n\t\tfor(itrB=begin;itrB != end;++itrB){\n\t\t\tvector<int> temp;\n\t\t\ttemp.reserve( 1<<POW );\n\t\t\ttemp.insert( temp.end(), itrA->begin(),itrA->end() );\n\t\t\ttemp.insert( temp.end(), itrB->begin(),itrB->end() );\n\t\t\tif( check( temp ) ){\n\t\t\t\tword[POW].push_back( temp );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid f(int N,int POW){\n\tint LEN = (1<<POW);\n\tint over =2*LEN-N;\n\tvector< vector<int> >::iterator itrA,itrB,begin,end;\n\tbegin = word[POW].begin();\n\tend = word[POW].end();\n\tvector<int> temp(N);\n\tfor(itrA=begin;itrA != end;++itrA){\n\t\tfor(itrB=begin;itrB != end;++itrB){\n\t\t\tbool flag = true;\n\t\t\tfor(int i=0;i<over;++i){\n\t\t\t\tif( (*itrA)[LEN-1-i] != (*itrB)[over-1-i] ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( flag == false ) continue;\n\t\t\tfor(int i=0;i<N;++i){\n\t\t\t\tif( i < LEN ){\n\t\t\t\t\ttemp[i] = (*itrA)[i];\n\t\t\t\t}else{\n\t\t\t\t\ttemp[i] = (*itrB)[i-(N-LEN)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( check( temp ) ){\n\t\t\t\tif( END ){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve(){\n\tint N;\n\tcin >> N;\n\t\n\tint POW = 0;\n\tfor(POW=0;(1<<POW)<=N;++POW){\n\t\tmake(POW);\n\t\tif( END ){\n\t\t\treturn;\n\t\t}\n\t}\n\t--POW;\n\tf(N,POW);\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstring dS=\"..##\";\nstring dT=\".#.#\";\n\nsigned main(){\n    int N;\n    cin>>N;\n\n    string S=\"\",T=\"\";\n    bool flag=false;\n    rep(i,N){\n        bool ok=false;\n        if(!flag){\n            rep(j,4){\n                string SS=S+dS[j];\n                string TT=T+dT[j];\n                cout<<SS<<endl<<TT<<endl;\n                string ret;\n                cin>>ret;\n                if(ret==\"F\")continue;\n\n                ok=true;\n                S=SS;\n                T=TT;\n                break;\n            }\n        }\n        if(ok)continue;\n        flag=true;\n        rep(j,4){\n            string SS=dS[j]+S;\n            string TT=dT[j]+T;\n            cout<<SS<<endl<<TT<<endl;\n            string ret;\n            cin>>ret;\n            if(ret==\"F\")continue;\n            ok=true;\n            S=SS;T=TT;\n            break;\n        }\n        assert(ok);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    int n;\n    fi>>n;\n    int op = 0;\n    string s1 = \"\";\n    string s2 = \"\";\n    while (s1.length() != n)\n    {\n        int ok = 0;\n        for (int a = 0;a < 2 && !ok;++a)\n            for (int b = 0;b < 2 && !ok;++b)\n            {\n                char cnta = !a ? '.' : '#';\n                char cntb = !b ? '.' : '#';\n                string ns1 = (op ? s1 + cnta : cnta + s1);\n                string ns2 = (op ? s2 + cntb : cntb + s2);\n                fo << ns1 << '\\n' << ns2 << '\\n';\n                fflush(stdout);\n                char ans;\n                fi>>ans;\n                if (ans == 'T')\n                {\n                    ok = 1;\n                    s1 = ns1;\n                    s2 = ns2;\n                }\n            }\n        op += !ok;\n    }\n    fo << s1 << '\\n' << s2 << '\\n';\n    fflush(stdout);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define _p(...) (void)printf(__VA_ARGS__)\n#define forr(x,arr) for(auto&& x:arr)\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2,)(__VA_ARGS__)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2,)(__VA_ARGS__)\n#define ALL(x) (x).begin(), (x).end()\n#define BIT(n) (1LL<<(n))\n#define SZ(x) ((int)(x).size())\n#define fst first\n#define snd second\nusing ll=long long;using pii=pair<int,int>;using vb=vector<bool>;\nusing vi=vector<int>;using vvi=vector<vi>;using vvvi=vector<vvi>;\nusing vl=vector<ll>;using vvl=vector<vl>;using vvvl=vector<vvl>;\nusing vd=vector<double>;using vvd=vector<vd>;using vvvd=vector<vvd>;\nusing vpii=vector<pii>;using vvpii=vector<vpii>;using vvvpii=vector<vvpii>;\n\nchar b(int x) { return x ? '#' : '.'; }\n\nbool query(string& x, string& y) {\n  cout << x << endl << y << endl;\n  fflush(stdout);\n  string res;\n  cin >> res;\n  if (res == \"end\") {\n    exit(0);\n  }\n  return res == \"T\";\n}\n\nvoid Main() {\n  int N;\n  cin >> N;\n\n  string s1, s2;\n\n  rep(i, 4) {\n    s1 = b(i & 1);\n    s2 = b(i & 2);\n    if (query(s1, s2)) {\n      break;\n    }\n  }\n\n  while (1) {\n    bool ok = 0;\n    rep(i, 4) {\n      string q1 = s1 + b(i & 1);\n      string q2 = s2 + b(i & 2);\n      if (query(q1, q2)) {\n        ok = 1;\n        s1 = q1;\n        s2 = q2;\n        break;\n      }\n    }\n    if (!ok) break;\n  }\n\n  while (1) {\n    bool ok = 0;\n    rep(i, 4) {\n      string q1 = b(i & 1) + s1;\n      string q2 = b(i & 2) + s2;\n      if (query(q1, q2)) {\n        ok = 1;\n        s1 = q1;\n        s2 = q2;\n        break;\n      }\n    }\n    if (!ok) break;\n  }\n}\n\nint main() {\n  //cin.tie(0); ios::sync_with_stdio(false);\n  Main();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8101145141919364364;\n\nint main(){\n\tint n; cin>>n;\n\tstring r,s1,s2;\n\tstring eins[]={\".\",\".\",\"#\",\"#\"};\n\tstring zwei[]={\".\",\"#\",\".\",\"#\"};\n\twhile(1){\n\t\trep(i,3){\n\t\t\tstring tmp1=s1+eins[i];\n\t\t\tstring tmp2=s2+zwei[i];\n\t\t\tcout<<tmp1<<\"\\n\"<<tmp2<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>r;\n\t\t\tif(r==\"end\") return 0;\n\t\t\tif(r==\"T\"){\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tbreak;\n\t\t\t}else if(i==2){\n\t\t\t\ttmp1=s1+eins[3];\n\t\t\t\ttmp2=s2+zwei[3];\n\t\t\t\ts1=tmp1;\n\t\t\t\ts2=tmp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint x=s1.size();\n\t\tif(x==n){\n\t\t\tcout<<s1<<\"\\n\"<<s2<<\"\\n\"; fflush(stdout);\n\t\t\tcin>>r;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MEM(a,b) memset((a),(b),sizeof(a))\nconst LL INF = 1e9 + 7;\nconst int N = 1e3 + 10;\nstring x = \"..##\";\nstring y = \".#.#\";\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tstring s1, s2;\n\tint n;\n\tcin >> n;\n\tint len = 0;\n\tint flag = 1;\n\tchar c;\n\twhile (1)\n\t{\n\t\tif (flag)\n\t\t{\n\t\t\tint key = -1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tcout << s1 << x[i] << '\\n';\n\t\t\t\tcout << s2 << y[i] << endl;\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == 'T')\n\t\t\t\t{\n\t\t\t\t\tkey == i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif (key == -1) flag = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\ts1.push_back(x[key]);\n\t\t\t\ts2.push_back(y[key]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint key = -1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tcout << x[i] << s1 << '\\n';\n\t\t\t\tcout << y[i] << s2 << endl;\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == 'T')\n\t\t\t\t{\n\t\t\t\t\tkey = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts1 = x[key] + s1;\n\t\t\ts2 = y[key] + s2;\n\t\t}\n\t}\n\tcout << s1 << endl;\n\tcout << s2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nchar xx[] = {'.', '#', '.', '#'};\nchar yy[] = {'.', '.', '#', '#'};\n\nint main() {\n    int n; cin >> n; cin.ignore();\n    string s1 = \"\", s2 = \"\", q;\n    string t1 = \"\", t2 = \"\";\n    bool back = true;\n    while(1) {\n        rep(i,0,4) {\n            t1 = s1; t2 = s2;\n            if(back) {t1 += xx[i]; t2 += yy[i];}\n            else {t1 = xx[i] + t1; t2 = yy[i] + t2;}\n            cout << t1 << endl << t2 << endl; fflush(stdout);\n            cin >> q;\n            if(q == \"end\") return 0;\n            else if(q == \"T\") {\n                s1 = t1;\n                s2 = t2;\n                break;\n            }\n            else if(i == 3) back = false;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nusing vs=vector<string>;\n\nconst char status[]={'.', '#'};\n\nint send_query(vs &query, bool rightward) {\n    for (size_t i=0; i<4; ++i) {\n        if (rightward) {\n            printf(\"%s%c\\n\", query[0].c_str(), status[i&1]);\n            printf(\"%s%c\\n\", query[1].c_str(), status[i>>1]);\n        } else {\n            printf(\"%c%s\\n\", status[i&1], query[0].c_str());\n            printf(\"%c%s\\n\", status[i>>1], query[1].c_str());\n        }\n\n        char buf[1<<2];\n        scanf(\"%s\", buf);\n        string ans=buf;\n\n        if (ans == \"end\") {\n            return -1;\n        } else if (ans == \"T\") {\n            if (rightward) {\n                query[0] += status[i&1];\n                query[1] += status[i>>1];\n            } else {\n                query[0] = status[i&1] + query[0];\n                query[1] = status[i>>1] + query[1];\n            }\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    size_t N;\n    scanf(\"%zu\", &N);\n\n    vs query(2);\n    for (int i=0; i<2;) {\n        int ans=send_query(query, i);\n        if (ans == -1) {\n            return 0;\n        } else if (ans == 0) {\n            ++i;\n        }\n        fflush(stdout);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Macro Tools /////////////////////////////////////////////////////////////////\n#define GET_MACRO_09(A0, A1, A2, A3, A4, A5, A6, A7, A8, NAME, ...) NAME\n\n#define EXPAND_01(MACRO, A0, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) \n#define EXPAND_02(MACRO, A0, A1, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) \n#define EXPAND_03(MACRO, A0, A1, A2, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__) \n#define EXPAND_04(MACRO, A0, A1, A2, A3, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) \n#define EXPAND_05(MACRO, A0, A1, A2, A3, A4, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) \n#define EXPAND_06(MACRO, A0, A1, A2, A3, A4, A5, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__) \n#define EXPAND_07(MACRO, A0, A1, A2, A3, A4, A5, A6, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) \n#define EXPAND_08(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) \n#define EXPAND_09(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, A8, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) MACRO(A8, ##__VA_ARGS__) \n\n#define GET_EXPAND(...) GET_MACRO_09(__VA_ARGS__, EXPAND_09, EXPAND_08, \\\n\tEXPAND_07, EXPAND_06, EXPAND_05, EXPAND_04, EXPAND_03, EXPAND_02, EXPAND_01)\n#define EXPAND_ARG_0(MACRO, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__)\n#define EXPAND_ARG_1(MACRO, A0, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__, A0)\n\n#define EXPAND(MACRO, ...) EXPAND_ARG_0(MACRO, __VA_ARGS__)\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n// Input ///////////////////////////////////////////////////////////////////////\n#define SCANF_INT(a) scanf(\"%d\", &(a));\n#define ID(...) int __VA_ARGS__;\n#define IR(...) {EXPAND(SCANF_INT, __VA_ARGS__)}\n#define I(...) ID(__VA_ARGS__) IR(__VA_ARGS__)\n\n// #define DEFINE_INT_ARRAY(a, n) int a[n];\n// #define INT_ITH_ARRAY(a, i) a[i]\n// #define IAD(N, ...) EXPAND_ARG_1(DEFINE_INT_ARRAY, N, __VA_ARGS__)\n// #define IAR(N, ...) REP(array_reader_i, N){ \n\n#define SCANF_LL(a) scanf(\"%lld\", &(a));\n#define LD(...) ll __VA_ARGS__;\n#define LR(...) {EXPAND(SCANF_LL, __VA_ARGS__)}\n#define L(...) LD(__VA_ARGS__) LR(__VA_ARGS__)\n\n#define DEFINE_STR(a, n) char a[n];\n#define SCANF_STR(a) scanf(\"%s\", a);\n#define SD(N, ...) EXPAND_ARG_1(DEFINE_STR, N, __VA_ARGS__)\n#define SR(...) EXPAND(SCANF_STR, __VA_ARGS__)\n#define S(N, ...) SD(N, __VA_ARGS__) SR(__VA_ARGS__)\n\n// Output //////////////////////////////////////////////////////////////////////\n#define LN printf(\"\\n\");\n\n#define IP(a, ...) printf(\"%d\", a); \n\n// Types ///////////////////////////////////////////////////////////////////////\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef set<int> si;\ntypedef set<ll> sll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii> vpii;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef map<int, int> mii;\ntypedef map<int, ll> mil;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\n\n// Loop & Iteration ////////////////////////////////////////////////////////////\n#define FORT(t, i, a, b) \\\n\tfor(t i = (a), loop_end_##i=(b); i < (loop_end_##i); i++)\n#define FORL(i, a, b) FORT(ll, i, a, b)\n#define FOR(i, a, b) FORT(int, i, a, b)\n#define REPT(t, i, n) FORT(t, i, 0, n)\n#define REPL(i, n) FORL(i, 0, n)\n#define REP(i, n) FOR(i, 0, n)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define SORTA(a, n) sort(a, a+n)\n\n#define PB push_back\n#define MP make_pair\n#define itr iterator\n\n// Range ///////////////////////////////////////////////////////////////////////\n#define IN(x, a, b) (a<=x && x<b)\n#define INC(x, a, b) (a<=x && x<=b)\nint dx[8] = { 1, 0, 0,-1, 1, 1,-1,-1};\nint dy[8] = { 0,-1, 1, 0,-1, 1,-1, 1};\n\n#define LAR(a, b) ((a)=max((a), (b)))\n#define SML(a, b) ((a)=min((a), (b)))\n\n// Debug ///////////////////////////////////////////////////////////////////////\n#define println(...) {printf(__VA_ARGS__); printf(\"\\n\");}\n#ifdef LOCAL\n#define debug(...) printf(__VA_ARGS__)\n#define debugln(...) println(__VA_ARGS__)\n#else\n#define debug(...) {}\n#define debugln(...) {}\n#endif\n\n// Numbers /////////////////////////////////////////////////////////////////////\nll gcd(ll a, ll b){\n\tif(b==0) return a;\n\telse return gcd(b, a%b);\n}\n\n#define PRIME_MAX 1000000\nbool isprime[PRIME_MAX+5];\nvoid init_prime(){\n\tfill(isprime, isprime+PRIME_MAX+5, true);\n\tisprime[0]=isprime[1]=false;\n\tREP(i, PRIME_MAX+5){\n\t\tif(isprime[i]){\n\t\t\tfor(int j=i*2; j<PRIME_MAX; j+=i){\n\t\t\t\tisprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvll factors(ll n){\n\tvll v;\n\tREPL(i, PRIME_MAX){\n\t\tif(!isprime[i]) continue;\n\t\twhile(n%i==0){\n\t\t\tv.PB(i);\n\t\t\tn/=i;\n\t\t}\n\t}\n\tif(n>1){\n\t\tv.PB(n);\n\t}\n\treturn v;\n}\n\n// BIT /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int\n>\nclass bit{\npublic:\n\tT *bit_arr;\n\tint size;\n\n\tbit(int n){\n\t\tsize = n;\n\t\tbit_arr = new T[n];\n\t\tfill(bit_arr, bit_arr+n, 0);\n\t}\n\n\t~bit(){\n\t\tdelete bit_arr;\n\t}\n\n\tT sum(int a){\n\t\tT ret = 0;\n\t\twhile(a){\n\t\t\tret+=bit_arr[a];\n\t\t\ta-=a&-a;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tT sum(int a, int b){\n\t\treturn sum(b)-sum(a);\n\t}\n\n\tT get(int a){\n\t\treturn sum(a, a+1);\n\t}\n\n\tvoid add(int a, T x){\n\t\ta++;\n\t\twhile(a<size){\n\t\t\tbit_arr[a]+=x;\n\t\t\ta+=a&-a;\n\t\t}\n\t}\n\n\tvoid set(int a, T x){\n\t\tadd(a, get(a)-x);\n\t}\n};\ntypedef bit<ll> bll;\n\n// RMQ /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int,\n\tclass Compare=less<T>\n>\nclass rmq{\npublic:\n\tint size;\n\tCompare comp;\n\tint *dat;\n\tT init;\n\t\n\trmq(int n, int init_=INT_MAX){\n\t\tinit=init_;\n\t\tsize = 1;\n\t\twhile(size<n) size*=2;\n\t\tdat = new int[2*size-1];\n\t\tfill(dat, dat+(2*size-1), init);\n\t}\n\n\t~rmq(){\n\t\tdelete dat;\n\t}\n\n\tvoid set(int k, T a){\n\t\tk+=size-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1], dat[k*2+2], comp);\n\t\t}\n\t}\n\n\tT get(int a, int b, int k, int l, int r){\n\t\tif(r<=a || b<=l) return init;\n\t\tif(a<=l && r<=b) return dat[k];\n\t\telse{\n\t\t\tint vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\t\tint vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\t\treturn min(vl, vr, comp);\n\t\t}\n\t}\n\n\tT get(int a, int b){\n\t\treturn get(a, b, 0, 0, size);\n\t}\n};\n\n// Others //////////////////////////////////////////////////////////////////////\n#define MOD 1000000007\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n\n////////////////////////////////////////////////////////////////////////////////\n\n#define DEB(...) printf(__VA_ARGS__)\n// #define DEB(...) \n#define LNDEB printf(\"\\n\")\n// #define LNDEB \n\n#ifdef LOCAL\nint n_;\nint brd_[100];\nint init(){\n\tIR(n_);\n\tfill(brd_, brd_+n_, 0);\n\tREP(j, 2){\n\t\tREP(i, n_) brd_[i]*=2;\n\t\tS(105, s);\n\t\tREP(i, n_){\n\t\t\tbrd_[i]+=(s[i]=='#');\n\t\t}\n\t}\n\tDEB(\"input : \");\n\tREP(i, n_) DEB(\"%d\", brd_[i]); LNDEB;\n\treturn n_;\n}\n\nbool query(int *q, int len){\n\tDEB(\"query : \"); REP(i, len) DEB(\"%d\", q[i]); printf(\"(len=%d)\", len); LNDEB;\n\tif(len>n_){\n\t\tprintf(\"end   : query limit exceeded\\n\");\n\t\texit(0);\n\t}else if(len==n_){\n\t\tREP(i, len){\n\t\t\tif(q[i]!=brd_[i]){\n\t\t\t\tprintf(\"end   : WA\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tprintf(\"end   : AC\\n\");\n\t\texit(0);\n\t}else{\n\t\tREP(i, n_-len+1){\n\t\t\tbool ok = true;\n\t\t\tREP(j, len){\n\t\t\t\tif(q[j]!=brd_[i+j]){\n\t\t\t\t\tok = false;\n\t\t\t\t\t// printf(\"Not match at brd[%d->%d]:q[%d]\\n\", i, i+j, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tDEB(\" T\\n\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tDEB(\" F\\n\");\n\t\treturn false;\n\t}\n}\n#else\nint init(){\n\tI(n__);\n\treturn n__;\n}\n\nbool query(int *q, int len){\n\tREP(j, 2){\n\t\tREP(i, len){\n\t\t\tif((q[i]&(1<<j))){\n\t\t\t\tprintf(\"#\");\n\t\t\t}else{\n\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t}\n\t\tLN;\n\t}\n\tfflush(stdout);\n\tS(3, s);\n\tif(s[0]=='e'){\n\t\texit(0);\n\t}\n\treturn s[0]=='T';\n}\n#endif\n\nint main(){\n\tint n = init();\n\tint bbuf[1000];\n\tint *board = bbuf + 500;\n\tint known = 0;\n\twhile(1){\n\t\tREP(i, 4){\n\t\t\tboard[known]=i;\n\t\t\tbool res = query(board, known+1);\n\t\t\tif(res){\n\t\t\t\tknown++;\n\t\t\t\tgoto nxt;\n\t\t\t}\n\t\t}\n\t\tbreak;\nnxt:;\n\t\t/*\n\t\tif(known==n-1){\n\t\t\tboard++;\n\t\t\tknown--;\n\t\t\tREP(i, 4){\n\t\t\t\tboard[known]=i;\n\t\t\t\tbool res = query(board, known+1);\n\t\t\t\tif(res){\n\t\t\t\t\tquery(board-1, n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n\tknown--;\n\twhile(1){\n\t\tboard--;\n\t\tREP(i, 4){\n\t\t\tboard[0]=i;\n\t\t\tbool res = query(board, known+1);\n\t\t\tif(res){\n\t\t\t\tknown++;\n\t\t\t\tgoto nxt2;\n\t\t\t}\n\t\t}\n\t\tbreak;\nnxt2:;\n\t if(known==n-1){\n\t\t break;\n\t }\n\t}\n\tquery(board, n);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef pair<string, string>P;\ntypedef long long ll;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\nint main() {\n\tint n; cin >> n;\n\tdeque<P>po;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po.push_back(P(s1, s2));\n\t}\n\tdeque<P>po1 = po;\n\tint cnt = 1;\n\twhile (1) {\n\t\tif ((cnt << 1) > n) {\n\t\t\tint size = po1.size();\n\t\t\tfor (int p = 0; p < size; p++) {\n\t\t\t\tfor (int l = 0; l < po.size(); l++) {\n\t\t\t\t\tP j = po1[p], i = po[l];\n\t\t\t\t\tcout << j.first + i.first << endl << j.second + i.second << endl;\n\t\t\t\t\tcin >> res;\n\t\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\t\tif (res == \"T\")po1.push_back(P(j.first + i.first, j.second + i.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, size)po1.pop_front();\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tint size = po1.size();\n\t\t\trep(l, size) {\n\t\t\t\trep(k, size) {\n\t\t\t\t\tP i = po1[l], j = po1[k];\n\t\t\t\t\tcout << i.first + j.first << endl << i.second + j.second << endl;\n\t\t\t\t\tcin >> res;\n\t\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\t\tif (res == \"T\")po1.push_back(P(i.first + j.first, i.second + j.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, size)po1.pop_front();\n\t\t\tcnt <<= 1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n\", u.c_str());\n  printf(\"%s\\n\", d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  int sw = 0;\n  while (true) {\n    int j = 0;\n    for (j = 0; j < 4; ++j) {\n      string r = (sw == 0 ? ask(u + du[j], d + dd[j]) : ask(du[j] + u, dd[j] + d));\n      if (r == \"end\") {\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    if (j == 5) {\n      sw = 1 - sw;\n      continue;\n    }\n    u += du[j];\n    d += dd[j];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\nusing namespace std;\n\nstring t[2] = {\"..##\", \".#.#\"};\n\nsigned main(){\n    int n;\n    cin >> n;\n    bool f = false;\n    string s[2] = {\"\", \"\"};\n    rep(i, 0, 420){\n        int cnt = 0;\n        if(!f){\n            rep(j, 0, 4){\n                rep(k, 0, 2){\n                    cout << s[k] << t[k][j] << endl;\n                }\n                fflush(stdout);\n                string in;\n                cin >> in;\n                if(in == \"end\") return 0;\n                else if(in == \"T\"){\n                    rep(k, 0, 2){\n                        s[k] += t[k][j];\n                    }\n                    break;\n                }else if(in == \"F\"){\n                    cnt++;\n                    if(cnt == 4) f = true;\n                }\n            }\n        }else{\n            rep(j, 0, 4){\n                rep(k, 0, 2){\n                    cout << t[k][j] << s[k] << endl;\n                }\n                fflush(stdout);\n                string in;\n                cin >> in;\n                if(in == \"end\") return 0;\n                else if(in == \"T\"){\n                    rep(k, 0, 2){\n                        s[k] = t[k][j] + s[k];\n                    }\n                    break;\n                }else if(in == \"F\"){\n                    cnt++;\n                    if(cnt == 4) f = true;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[2][200];\nchar in[3];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tint dir=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(dir==0){\n\t\t\tstr[0][i+1]=str[1][i+1]=0;\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tif(j&(1<<k))str[k][i]='#';\n\t\t\t\t\telse str[k][i]='.';\n\t\t\t\t}\n\t\t\t\tprintf(\"%s\\n\",str[0]);\n\t\t\t\tprintf(\"%s\\n\",str[1]);\n\t\t\t\tfflush(stdout);\n\t\t\t\tscanf(\"%s\",in);\n\t\t\t\tif(in[0]=='T'){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok)dir=1;\n\t\t}\n\n\t\tif(dir){\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tstr[0][j+1]=str[0][j];\n\t\t\t\tstr[1][j+1]=str[1][j];\n\t\t\t}\n\t\t\tstr[0][i+1]=str[1][i+1]=0;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tif(j&(1<<k))str[k][0]='#';\n\t\t\t\t\telse str[k][0]='.';\n\t\t\t\t}\n\t\t\t\tprintf(\"%s\\n\",str[0]);\n\t\t\t\tprintf(\"%s\\n\",str[1]);\n\t\t\t\tfflush(stdout);\n\t\t\t\tscanf(\"%s\",in);\n\t\t\t\tif(in[0]=='T'){\n\t\t\t\t//\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%s\\n%s\\n\",str[0],str[1]);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar c1[] = { '#', '.', '#', '.' };\nchar c2[] = { '.', '#', '#', '.' };\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> s1, s2, rs1, rs2;\n    char resp[5];\n    bool rev = false;\n    for (int i = 0; i < n; ++i) {\n        if (!rev) {\n            bool ok = false;\n            for (int t = 0; t < 4; ++t) {\n                for (int k = 0; k < s1.size(); ++k) printf(\"%c\", s1[k]);\n                printf(\"%c\\n\", c1[t]);\n                for (int k = 0; k < s2.size(); ++k) printf(\"%c\", s2[k]);\n                printf(\"%c\\n\", c2[t]);\n                fflush(stdout);\n                scanf(\"%s\", resp);\n                if (resp[0] == 'e') {\n                    return 0;\n                }\n                else if (resp[0] == 'T') {\n                    ok = true;\n                    s1.push_back(c1[t]), s2.push_back(c2[t]);\n                    break;\n                }\n            }\n            if (!ok) rev = true;\n        }\n        if (rev) {\n            for (int t = 0; t < 4; ++t) {\n                printf(\"%c\", c1[t]);\n                for (int k = rs1.size()-1; k >= 0; --k) printf(\"%c\", rs1[k]);\n                for (int k = 0; k < s1.size(); ++k) printf(\"%c\", s1[k]);\n                puts(\"\");\n                printf(\"%c\", c2[t]);\n                for (int k = rs2.size()-1; k >= 0; --k) printf(\"%c\", rs2[k]);\n                for (int k = 0; k < s2.size(); ++k) printf(\"%c\", s2[k]);\n                puts(\"\");\n                fflush(stdout);\n                scanf(\"%s\", resp);\n                if (resp[0] == 'e') {\n                    return 0;\n                }\n                else if (resp[0] == 'T') {\n                    rs1.push_back(c1[t]), rs2.push_back(c2[t]);\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s1 = \"\";\n\tstring s2 = \"\";\n\tstring r = \"\";\n\t\n\twhile(r != \"end\"){\n\t\tif(r == \"F\"){\n\t\t\tif(s1[s1.length() - 1] == '.' && s2[s2.length() - 1] == '.'){\n\t\t\t\ts1[s1.length() - 1] = '#';\n\t\t\t}else if(s1[s1.length() - 1] == '#' && s2[s2.length() - 1] == '.'){\n\t\t\t\ts1[s1.length() - 1] = '.';\n\t\t\t\ts2[s2.length() - 1] = '#';\n\t\t\t}else if(s1[s1.length() - 1] == '.' && s2[s2.length() - 1] == '#'){\n\t\t\t\ts1[s1.length() - 1] = '#';\n\t\t\t\ts1 += \".\";\n\t\t\t\ts2 += \".\";\n\t\t\t}\n\t\t}else{\n\t\t\ts1 += \".\";\n\t\t\ts2 += \".\";\n\t\t}\n\t\t\n\t\tcout << s1 << endl;\n\t\tcout << s2 << endl;\n\t\tfflush(stdout);\n\n\t\tcin >> r;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[1000000000];\n\nvoid output(const deque<int>& dq) {\n  for (int i = 0; i < dq.size(); ++i) {\n    cout << \".#\"[dq[i] / 2];\n  }\n  cout << endl;\n  for (int i = 0; i < dq.size(); ++i) {\n    cout << \".#\"[dq[i] % 2];\n  }\n  cout << endl;\n}\n\nbool read() {\n  string s; cin >> s;\n  if (s == \"end\") exit(0);\n  return s == \"T\";\n}\n\nint main() {\n  srand(time(0));\n  a[rand()] = rand();\n  int N; cin >> N;\n  deque<int> dq;\n  bool test = false;\n  do {\n    test = false;\n    for (int i = 0; i < 4; ++i) {\n      dq.push_back(i);\n      output(dq);\n      if (read()) {\n        test = true;\n        break;\n      }\n      else dq.pop_back();\n    }\n  } while (test);\n  do {\n    test = false;\n    for (int i = 0; i < 4; ++i) {\n      dq.push_front(i);\n      output(dq);\n      if (read()) {\n        test = true;\n        break;\n      }\n      else dq.pop_front();\n    }\n  } while (test);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef pair<string, string>P;\ntypedef long long ll;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\nint main() {\n\tint n; cin >> n;\n\tdeque<P>po{ {\"\",\"\"} };\n\tstring res;\n\twhile (1) {\n\t\tint size = po.size();\n\t\trep(j, size) {\n\t\t\trep(i, 4) {\n\t\t\t\tP p = po[j];\n\t\t\t\tif (dx[i])p.first += '#';\n\t\t\t\telse p.first += '.';\n\t\t\t\tif (dy[i])p.second += '#';\n\t\t\t\telse p.second += '.';\n\t\t\t\tcout << p.first << endl << p.second << endl;\n\t\t\t\tcin >> res;\n\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\tif (res == \"T\")po.push_back(p);\n\t\t\t}\n\t\t}\n\t\trep(j, size) {\n\t\t\tpo.pop_front();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for (int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for (int (i) = (a) - 1; (i) >= (b); (i)--)\n#define PI acos(-1.0)\n#define DEBUG(C) cout<< C <<endl;\n#define VI vector <int>\n#define VII vector <VI>\n#define VL vector <LL>\n#define VLL vector <VL>\n#define VD vector <double>\n#define VDD vector <VD>\n#define PII pair <int, int>\n#define PDD pair <double, double>\n#define PLL pair <LL, LL>\n#define VPII vector <PII>\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define REVERSE(a) reverse(ALL(a))\n#define MP make_pair\n#define EB emplace_back\n#define FORE(a, b) for (auto &&a:b)\n#define FIND(s, n) (s.find(n) != s.end())\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst int INF = 1e9;\nconst int MOD = INF + 7;\n\nstring cc[2];\n\nint main(void) {\n    cc[0] = \"..##\";\n    cc[1] = \".#.#\";\n    set <string> nai[2];\n    int N; cin >> N;\n    vector <string> S(2, \"\"), Sbuf(2);\n    int cnt = 0;\n    S[0] += cc[0][0];\n    S[1] += cc[1][0];\n    REP(_, 420) {\n        printf(\"%s\\n%s\\n\", S[0].c_str(), S[1].c_str());\n        string c; cin >> c;\n        if (c == \"T\") {\n            Sbuf = S;\n            cnt = 0;\n            REP(i, 2) {\n                S[i] += cc[i][cnt];\n            }\n        } else if (c == \"F\") {\n            REP(i, 2) nai[i].insert(S[i]);\n            label:\n            S = Sbuf;\n            cnt++;\n            if (cnt >= 4) {\n                REP(i, 2) {\n                    S[i] = cc[i][cnt % 4] + S[i];\n                }\n            } else {\n                REP(i, 2) {\n                    S[i] += cc[i][cnt % 4];\n                }\n            }\n            bool f = false;\n            REP(i, 2) f = FIND(nai[i], S[i]);\n            if (f) {\n                goto label;\n            }\n        } else {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\nint main()\n{\n\tint num;\n\tscanf(\"%d\",&num);\n\tstring s1,s2;\n\tfor(;;)\n\t{\n\t\tbool f=false;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tif(i&1)s1.push_back('#');\n\t\t\telse s1.push_back('.');\n\t\t\tif(i&2)s2.push_back('#');\n\t\t\telse s2.push_back('.');\n\t\t\tcout<<s1<<endl<<s2<<endl;\n\t\t\tfflush(stdout);\n\t\t\tstring z;\n\t\t\tcin>>z;\n\t\t\tif(z==\"end\")return 0;\n\t\t\tif(z==\"T\")\n\t\t\t{\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts1.pop_back();\n\t\t\ts2.pop_back();\n\t\t}\n\t\tif(!f)break;\n\t}\n\tfor(;;)\n\t{\n\t\tbool f=false;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\treverse(s1.begin(),s1.end());\n\t\t\treverse(s2.begin(),s2.end());\n\t\t\tif(i&1)s1.push_back('#');\n\t\t\telse s1.push_back('.');\n\t\t\tif(i&2)s2.push_back('#');\n\t\t\telse s2.push_back('.');\n\t\t\treverse(s1.begin(),s1.end());\n\t\t\treverse(s2.begin(),s2.end());\n\t\t\tcout<<s1<<endl<<s2<<endl;\n\t\t\tfflush(stdout);\n\t\t\tstring z;\n\t\t\tcin>>z;\n\t\t\tif(z==\"end\")return 0;\n\t\t\tif(z==\"T\")\n\t\t\t{\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treverse(s1.begin(),s1.end());\n\t\t\treverse(s2.begin(),s2.end());\n\t\t\ts1.pop_back();\n\t\t\ts2.pop_back();\n\t\t\treverse(s1.begin(),s1.end());\n\t\t\treverse(s2.begin(),s2.end());\n\t\t}\n\t\tif(!f)break;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#include<string.h>\n#include<stack>\n#include<functional>\nusing namespace std;\n\nstring a = \"#.\";\nsigned main() {\n\tint b; cin >> b;\n\tstring c, d;\n\twhile (1) {\n\tl:;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tc += a[i]; d += a[j];\n\t\t\t\tcout << c << endl;\n\t\t\t\tcout << d << endl;\n\t\t\t\tstring e; cin >> e;\n\t\t\t\tif (e == \"T\") {\n\t\t\t\t\tgoto l;\n\t\t\t\t}\n\t\t\t\telse if(e==\"end\"){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc.erase(--c.end());\n\t\t\t\td.erase(--d.end());\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\twhile (1) {\n\tr:;\n\t\tbool S = false;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tc = a[i] + c; d = a[j] + d;\n\t\t\t\tstring e; cin >> e;\n\t\t\t\tif (e == \"T\") {\n\t\t\t\t\tgoto r;\n\t\t\t\t}\n\t\t\t\telse if (e == \"end\") {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc.erase(c.begin());\n\t\t\t\td.erase(d.begin());\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=1e9+7;\nconst llint big=1e15+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\nint main(void){\n\t//端に追加することで行ける\n\tint n;cin>>n;\n\tstring ue;\n\tstring st;\n\tstring emp=\".\",use=\"#\";\n\tstring c;\n\twhile(-1){\n\t\tcout<<'.'<<ue<<endl;\n\t\tcout<<'.'<<st<<endl;\n\t\tcin>>c;if(c==\"T\"){ue=emp+ue;st=emp+st;continue;}\n\t\tif(c==\"end\"){RE;}\n\t\tcout<<'.'<<ue<<endl;\n\t\tcout<<'#'<<st<<endl;\n\t\tcin>>c;if(c==\"T\"){ue=emp+ue;st=use+st;continue;}\n\t\tif(c==\"end\"){RE;}\n\t\tcout<<'#'<<ue<<endl;\n\t\tcout<<'.'<<st<<endl;\n\t\tcin>>c;if(c==\"T\"){ue=use+ue;st=emp+st;continue;}\n\t\tif(c==\"end\"){RE;}\n\t\tcout<<'#'<<ue<<endl;\n\t\tcout<<'#'<<st<<endl;\n\t\tcin>>c;if(c==\"T\"){ue=use+ue;st=use+st;continue;}\n\t\tif(c==\"end\"){RE;}\n\t\tbreak;\n\t}\n\twhile(-1){\n\t\tcout<<ue<<'.'<<endl;\n\t\tcout<<st<<'.'<<endl;\n\t\tcin>>c;if(c==\"T\"){ue=ue+emp;st=st+emp;continue;}\n\t\tif(c==\"end\"){RE;}\n\t\tcout<<ue<<'.'<<endl;\n\t\tcout<<st<<'#'<<endl;\n\t\tcin>>c;if(c==\"T\"){ue=ue+emp;st=st+use;continue;}\n\t\tif(c==\"end\"){RE;}\n\t\tcout<<ue<<'#'<<endl;\n\t\tcout<<st<<'.'<<endl;\n\t\tcin>>c;if(c==\"T\"){ue=ue+use;st=st+emp;continue;}\n\t\tif(c==\"end\"){RE;}\n\t\tcout<<ue<<'#'<<endl;\n\t\tcout<<st<<'#'<<endl;\n\t\tcin>>c;if(c==\"T\"){ue=ue+use;st=st+use;continue;}\n\t\tif(c==\"end\"){RE;}\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { cout << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define RBP(i,a) for(auto& i : a)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\n#define rangej(a,b,c) ((a) <= (c) and (c) < (b))\n#define rrangej(b,c) rangej(0,b,c)\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nconst string chs = \".#\";\n\nint main()\n{\n\t// ios_init();\n\tint n;\n\tcin >> n;\n\tstring s1, s2;\n\tbool f = false;\n\twhile(SZ(s1) < n){\n\t\t[&](){REP(i,2) REP(j,2){\n\t\t\tstring ns1 = s1+chs[i];\n\t\t\tstring ns2 = s2+chs[j]; \n\t\t\tcout << ns1 << endl << ns2 << endl;\n\t\t\tstring r;\n\t\t\tcin >> r;\n\t\t\tif(r == \"T\"){\n\t\t\t\ts1 = ns1;\n\t\t\t\ts2 = ns2;\n\t\t\t\treturn;\n\t\t\t}else if(r == \"end\"){\n\t\t\t\tf = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}}();\n\t\tif(f) return 0;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\nusing namespace std;\n\nint main(){\n  int N;\n  cin >> N;\n  string table[2];\n  \n  while(1){\n    // query\n    string n_table[2];\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n\tn_table[j] = table[j];\n      }\n\n      n_table[0] += (i%2?'#':'.');\n      n_table[1] += ((i >> 1)%2?'#':'.');\n      \n      printf(\"%s\\n%s\\n\", n_table[0].c_str(), n_table[1].c_str()); fflush(stdout);\n      // in\n      string str;\n      cin >> str;\n      if(str == \"T\"){\n\tfor(int j = 0 ; j < 2 ; j++){\n\t  table[j] = n_table[j];\n\t}\n\tbreak;\n      }\n      else if(str == \"end\"){\n\treturn 0;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst int mod=1e9+7;\nconst vi emp;\nconst int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nconst int DX[8]={-1,-1,-1,0,0,1,1,1},DY[8]={1,0,-1,1,-1,1,0,-1};\n\nstring func(string s,bool t,bool I){\n\tif(I) s=s+((t)?\"#\":\".\");\n\telse s=((t)?\"#\":\".\")+s;\n\treturn s;\n}\n\nint n;\n\nint main(){\n\tcin>>n;\n\tstring s,t;\n\tbool flag=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tstring cs=func(s,i/2,flag),ct=func(t,i%2,flag);\n\t\t\tprintf(\"%s\\n%s\\n\",cs.c_str(),ct.c_str());\n\t\t\tfflush(stdout);\n\t\t\tstring c;\n\t\t\tcin>>c;\n\t\t\tif(c==\"T\"){\n\t\t\t\ts=cs;\n\t\t\t\tt=ct;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c==\"end\") return 0;\n\t\t}\n\t\tif(s.size()!=i+1){\n\t\t\tflag=0;\n\t\t\ti--;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define RG register\nusing namespace std;\nint n,flg=1;\nstring upp[4]={\".\",\".\",\"#\",\"#\"}, dwn[4]={\".\",\"#\",\"#\",\".\"}, lst[2],nw[2];\nchar ss[4];\ntemplate<typename I> inline void read(I &ot){\n\tI ch=getchar(), x=0, f=1;\n\twhile(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();\t}\n\twhile(ch>='0' && ch<='9'){x=x*10+ch-'0'; ch=getchar();\t}\n\tot=x*f;}\ntemplate<typename I, typename... U> inline void read(I &x,U&... y){read(x); read(y...);}\nint main()\n{\n\t//freopen(\"Long Blackboard.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tread(n);\n\twhile( true )\n\t{\n\t\tfor(RG int i=0;i<4;i++)\n\t\t{\n\t\t\tnw[0]= flg ? lst[0]+upp[i] : upp[i]+lst[0];\n\t\t\tnw[1]= flg ? lst[1]+dwn[i] : dwn[i]+lst[1];\n\t\t\tcout<<nw[0]<<endl<<nw[1]<<endl;\n\t\t\tscanf(\"%s\",ss);\n\t\t\tif(ss[0]=='T')\n\t\t\t{\n\t\t\t\tlst[0]=nw[0];\n\t\t\t\tlst[1]=nw[1];\n\t\t\t\tif(lst[0].size()==n) return 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i==3) flg=0;\n\t\t}\n\t}\n\t//fclose(stdin); fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[1000000000];\n\nvoid output(const deque<int>& dq) {\n  for (int i = 0; i < dq.size(); ++i) {\n    cout << \".#\"[dq[i] / 2];\n  }\n  cout << endl;\n  for (int i = 0; i < dq.size(); ++i) {\n    cout << \".#\"[dq[i] % 2];\n  }\n  cout << endl;\n}\n\nbool read() {\n  string s; cin >> s;\n  if (s == \"end\") exit(0);\n  return s == \"T\";\n}\n\nint main() {\n  srand(time(0));\n  int N; cin >> N;\n  deque<int> dq;\n  bool test = false;\n  do {\n    test = false;\n    for (int i = 0; i < 4; ++i) {\n      dq.push_back(i);\n      output(dq);\n      if (read()) {\n        test = true;\n        break;\n      }\n      else dq.pop_back();\n    }\n  } while (test);\n  do {\n    test = false;\n    for (int i = 0; i < 4; ++i) {\n      dq.push_front(i);\n      output(dq);\n      if (read()) {\n        test = true;\n        break;\n      }\n      else dq.pop_front();\n    }\n  } while (test);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n\", u.c_str());\n  printf(\"%s\\n\", d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  while (true) {\n    int j = 0;\n    for (j = 0; j < 3; ++j) {\n      string r = ask(u + du[j], d + dd[j]);\n      if (r == \"end\") {\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    u += du[j];\n    d += dd[j];\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nbool ok(const string &a,const string &b){\n  cout<<a<<endl<<b<<endl<<flush;\n  string s;\n  cin>>s;\n  if(s==\"end\") exit(0);\n  if(s==\"F\") return 0;\n  return 1;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n  cin>>n;\n  string cs=\".#\";\n  string a,b;\n  while(a.size()<n){\n    int f=1;\n    rep(i,2*f)rep(j,2){\n      if(ok(a+cs[i],b+cs[j])){\n\tf=0;\n\ta+=cs[i];\n\tb+=cs[j];\n\tbreak;\n      }\n    }\n    if(f || a.size()==n) break;\n  }\n  while(a.size()<n){\n    int f=1;\n    rep(i,2*f)rep(j,2){\n      if(ok(cs[i]+a,cs[j]+b)){\n\tf=0;\n\ta=cs[i]+a;\n\tb=cs[j]+b;\n\tbreak;\n      }\n    }\n    if(f || a.size()==n) break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nint query(const string &s1, const string &s2) {\n\tcout << s1 << endl << s2 << endl;\n\tfflush(stdout);\n\tstring r;\n\tcin >> r;\n\tif (r == \"end\")return -1;\n\treturn r[0] == 'T' ? 1 : 0;\n}\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t\n\tint N;\n\tcin >> N;\n\tvector<pair<string, string>>unit;\n\tint exist[4] = { 1,1,1,1 };\n\tbool flag = true;\n\tpair<string, string>ans;\n\trep(i, 4) {\n\t\texist[i] = query(i % 2 ? \"#\" : \".\", i / 2 ? \"#\" : \".\");\n\t\tif (exist[i] == -1)return 0;\n\t\tif (!exist[i])continue;\n\t\tunit.push_back(make_pair(i % 2 ? \"#\" : \".\", i / 2 ? \"#\" : \".\"));\n\t\tif (flag)ans = unit[0];\n\t\tflag = false;\n\t}\n\n\tif (unit.size() == 1) {\n\t\trep(i, N)cout << unit[0].first;\n\t\tcout << endl;\n\t\trep(i, N)cout << unit[0].second;\n\t\tcout << endl;\n\t\treturn 0;\n\t}\n\n\tbool right = true;\n\twhile (ans.first.size() < N) {\n\t\tif (right) {\n\t\t\tbool ok = false;\n\t\t\tfor (auto x : unit) {\n\t\t\t\tint i = query(ans.first + x.first, ans.second + x.second);\n\t\t\t\tif (i == -1)return 0;\n\t\t\t\tif (i == 1) {\n\t\t\t\t\tans.first += x.first;\n\t\t\t\t\tans.second += x.second;\n\t\t\t\t\tok = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok)continue;\n\t\t\tright = false;\n\t\t}\n\t\tfor (auto x : unit) {\n\t\t\tint i = query(x.first + ans.first, x.second + ans.second);\n\t\t\tif (i == -1)return 0;\n\t\t\tif (i == 1) {\n\t\t\t\tans.first = x.first+ans.first;\n\t\t\t\tans.second = x.second+ans.second;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans.first << endl << ans.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//\n/*==========================================================*/\n/*    Template ver 2017-0720    |    Created by JollyBee    */\n/* DOMINUS pascit me, et nihil mihi deerit (Psalmorum 23:1) */\n/*==========================================================*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<pii> vii;\nconst double EPS=(double)1e-9;\nconst double PI=(double)acos(-1.0);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define FOR(i,n) for(int i=0;i<n;i++)\n#define REPP(i,l,r,c) for(int i=l;i<=r;i+=c)\n#define REP(i,l,r) REPP(i,l,r,1)\n#define FORD(i,n) for(int i=n-1;i>=0;i--)\n#define REVV(i,l,r,c) for(int i=l;i>=r;i-=c)\n#define REV(i,l,r) REVV(i,l,r,1)\n//random\nint irand(int lo, int hi){\n    return (((double)rand())/(RAND_MAX+1.0)) * (hi-lo+1) + lo;\n}\n//ll to string\nstring toString(ll x) {\n    stringstream ss;\n    ss << x;\n    return ss.str();\n}\n//string to ll\nll toNumber(string S) {\n    ll ret;\n    sscanf(S.c_str(),\"%lld\",&ret);\n    return ret;\n}\n// std::fill(start, end, value);\n// for(auto it: DS){}\n\nconst int INF=(int)2e9;\nconst ll MOD=(ll)1e9+7;\n/*==========================================================*/\n/*                     END OF TEMPLATE                      */\n/* DOMINUS pascit me, et nihil mihi deerit (Psalmorum 23:1) */\n/*==========================================================*/\n\nint ask(const string& sa, const string& sb){\n    puts(sa.c_str()); puts(sb.c_str()); fflush(stdout);\n    char response[5]; scanf(\"%s\", response);\n    if(response[0] == 'e') exit(0);\n    return response[0] == 'T';\n}\n\nint solve(string& sa, string& sb, int& is_from_back){\n    FOR(i,4){\n        string ta,tb;\n        if(is_from_back){\n            ta = sa + \".#\"[i&1?1:0];\n            tb = sb + \".#\"[i&2?1:0];\n        } else {\n            ta = \".#\"[i&1?1:0] + sa;\n            tb = \".#\"[i&2?1:0] + sb;\n        }\n        if(ask(ta,tb) == 1){\n            sa = ta;\n            sb = tb;\n            return 0;\n        }\n    }\n    // fail\n    return is_from_back = 0;\n}\n\nint main(){\n    scanf(\"%*d\");\n    string sa=\"\", sb=\"\";\n    int is_from_back = 1;\n    while(1) solve(sa,sb, is_from_back);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef pair<string, string>P;\ntypedef long long ll;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\ndeque<P>po[200];\nint main() {\n\tint n; cin >> n;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po[1].push_back(P(s1, s2));\n\t}\n\tint cnt = 1;\n\twhile (1) {\n\t\tint c = min(cnt, n - cnt);\n\t\tfor (; !po[c].size(); c--);\n\t\tfor (P p1 : po[cnt]) {\n\t\t\tfor (P p2 : po[c]) {\n\t\t\t\tcout << p1.first + p2.first << endl << p1.second + p2.second << endl;\n\t\t\t\tcin >> res;\n\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\tif (res == \"T\")po[cnt + c].push_back(P(p1.first + p2.first, p1.second + p2.second));\n\t\t\t}\n\t\t}\n\t\tcnt += c;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n%s\\n\", u.c_str(), d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  int cnt = 0;\n  int sw = 0;\n  while (true) {\n    int j;\n    for (j = 0; j < 4; ++j) {\n      ++cnt;\n      string r = (sw == 0 ? ask(u + du[j], d + dd[j]) : ask(du[j] + u, dd[j] + d));\n      if (r == \"end\") {\n        assert(false);\n\n        //assert(cnt <= 420);\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    if (j == 5) {\n      assert(sw == 0);\n      sw = 1 - sw;\n      continue;\n    }\n    if (sw == 0) {\n      u += du[j];\n      d += dd[j];\n    } else {\n      u = du[j] + u;\n      d = dd[j] + d;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  4*100+8 ?\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(c) begin(c), end(c)\nusing ll = long long;\n\nstring convert(deque<int> &a){\n    string s,t;\n    rep(i,a.size()){\n        s += \"#.\"[a[i]>>0&1];\n        t += \"#.\"[a[i]>>1&1];\n    }\n    return s + \"\\n\" + t;\n}\n\nchar ask(deque<int> &a){\n    cout << convert(a) << endl;\n    string s;\n    cin >> s;\n    char c = s[0];\n    if(c == 'e') exit(0);\n    return c;\n}\n\nint main(){\n    int N;\n    while(cin >> N){\n        deque<int> X;\n        while(1){\n            int f = -1;\n            rep(i,4){\n                X.push_back(i);\n                char c = ask(X);\n                if(c == 'T'){\n                    f = i;\n                    break;\n                }\n                X.pop_back();\n            }\n            if((int)X.size() == N || f == -1) break;\n        }\n        while(1){\n            int f = -1;\n            rep(i,4){\n                X.push_front(i);\n                char c = ask(X);\n                if(c == 'T'){\n                    f = i;\n                    break;\n                }\n                X.pop_front();\n            }\n            assert(f != -1);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=2001;\nchar x[]{'.','.','#','#'},y[]{'.','#','.','#'};\nint main(){\n\tint N;\n\tcin >> N;\n\tstring s1,s2;\n\tstring ret;\n\tbool last=false;\n\tREP(i,N){\n\t\tif(!last)\n\t\t\tREP(j,4){\n\t\t\t\tcout << s1+x[j] <<endl << s2+y[j] << endl;\n\t\t\t\tcin >> ret;\n\t\t\t\tif(ret==\"End\") return 0;\n\t\t\t\tif(ret==\"T\"){\n\t\t\t\t\ts1+=x[j];\n\t\t\t\t\ts2+=y[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ret==\"F\" && j==3){\n\t\t\t\t\tlast=true;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\telse{\t\t\n\t\t\tREP(j,4){\n\t\t\t\tcout << x[j]+s1 <<endl << y[j]+s2 << endl;\n\t\t\t\tcin >> ret;\n\t\t\t\tif(ret==\"End\") return 0;\n\t\t\t\tif(ret==\"T\"){\n\t\t\t\t\ts1=x[j]+s1;\n\t\t\t\t\ts2=y[j]+s2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////////\n///                                      ///\n///         Template ver. 1 rapel        ///\n/// Fear is Temporary, Regret is Forever ///\n///          Must Try and Get AC         ///\n///                                      ///\n////////////////////////////////////////////\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <utility>\n\n#include <math.h>\n#include <complex>\n\n#include <assert.h>\n#include <time.h>\n//#include <chrono>\n//#include <random>\n\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <list>\n#include <bitset>\n\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n//#define endl '\\n'\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nvoid desperate_optimization(int precision){\n  \tios_base::sync_with_stdio(false);\n  \tcin.tie(0);\n  \tcout.tie(0);\n  \tcout.setf(ios::fixed);\n  \tcout.setf(ios::showpoint);\n  \tcout.precision(precision);\n}\n\ndeque<char> d[2];\n\nvoid hora(int tc) {\n\tint n;\n\tcin>>n;\n\twhile(1) {\n\t\tbool ada = false;\n\t\tfor(int i = 0;i < 4;i++) {\n\t\t\tfor(auto x: d[0]) cout<<x;\n\t\t\tif(i == 0 || i == 2) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tcout<<endl;\n\t\t\tfor(auto x: d[1]) cout<<x;\n\t\t\tif(i == 0 || i == 1) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tcout<<endl;\n\t\t\tstring c;\n\t\t\tcin>>c;\n\t\t\tif(c == \"T\") {\n\t\t\t\tada = true;\n\t\t\t\tif(i == 0 || i == 2) d[0].PB('.');\n\t\t\t\telse d[0].PB('#');\n\t\t\t\tif(i == 0 || i == 1) d[1].PB('.');\n\t\t\t\telse d[1].PB('#');\n\t\t\t\tbreak;\n\t\t\t} else if(c == \"end\") return ;\n\t\t}\n\t\tif(ada == false) break;\t\n\t}\n\twhile(1) {\n\t\tbool ada = false;\n\t\tfor(int i = 0;i < 4;i++) {\n\t\t\tif(i == 0 || i == 2) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tfor(auto x: d[0]) cout<<x;\n\t\t\tcout<<endl;\n\t\t\tif(i == 0 || i == 1) cout<<'.';\n\t\t\telse cout<<'#';\n\t\t\tfor(auto x: d[1]) cout<<x;\n\t\t\tcout<<endl;\n\t\t\tstring c;\n\t\t\tcin>>c;\n\t\t\tif(c == \"T\") {\n\t\t\t\tada = true;\n\t\t\t\tif(i == 0 || i == 2) d[0].PF('.');\n\t\t\t\telse d[0].PF('#');\n\t\t\t\tif(i == 0 || i == 1) d[1].PF('.');\n\t\t\t\telse d[1].PF('#');\n\t\t\t\tbreak;\n\t\t\t} else if(c == \"end\") return ;\n\t\t}\t\n\t}\n}\n\nint main(){\n//\tdesperate_optimization(10);\n\tint ntc = 1;\n\t//cin>>ntc;\n\tfor(int tc = 1;tc <= ntc;tc++) hora(tc);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n\tll n;\n\tcin>>n;\n\tstring input =\"\";\n\tstring s1 =\"..##\";\n\tstring s2 =\"#..#\";\n\tstring ans1 = \"\" , ans2=\"\";\n\twhile(input != \"end\")\n\t{\n\t\tbool balik = 1;\n\t\tfor(int i = 0; i  < 4;  i++)\n\t\t{\n\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\ttemp1 += s1[i];\n\t\t\ttemp2 += s2[i];\n\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\tcin>>input;\n\t\t\tif(input == \"T\" || input == \"end\")\n\t\t\t{\n\t\t\t\tans1 = temp1;\n\t\t\t\tans2 = temp2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( i == 3)\n\t\t\t\t{\n\t\t\t\t\tbalik = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(balik == 0)\n\t\t{\n\t\t\tfor(int i = 0; i  < 4;  i++)\n\t\t\t{\n\t\t\t\tstring temp1 = ans1 , temp2 = ans2;\n\t\t\t\ttemp1 = s1[i] + ans1;\n\t\t\t\ttemp2 = s2[i] + ans2;\n\t\t\t\tcout<<temp1<<endl<<temp2<<endl;\n\t\t\t\tcin>>input;\n\t\t\t\tif(input == \"T\" || input == \"end\")\n\t\t\t\t{\n\t\t\t\t\tans1 = temp1;\n\t\t\t\t\tans2 = temp2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif( i == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tbalik = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint a[100];\nchar s[101];\n\nint main(){\n  int n;\n  char s1[501],s2[501];\n  scanf(\"%d\",&n);\n  int x = 200;\n  while(true){\n    bool flag = true;\n    for(int i=0;i<4;i++){\n      char res[3];\n      if(i==0){\n        s1[x] = '.';\n        s2[x] = '.';\n      }else if(i==1){\n        s1[x] = '#';\n        s2[x] = '.';\n      }else if(i==2){\n        s1[x] = '.';\n        s2[x] = '#';\n      }else if(i==3){\n        s1[x] = '#';\n        s2[x] = '#';\n      }\n      s1[x+1] = '\\0';\n      s2[x+1] = '\\0';\n      printf(\"%s\\n%s\\n\", s1+200, s2+200); fflush(stdout);\n      scanf(\"%s\",res);\n      if(res[0]=='T'){\n        flag = false;\n        x++;\n        break;\n      }\n    }\n    if(flag) break;\n  }\n  x = 199;\n  while(true){\n    bool flag = true;\n    for(int i=0;i<4;i++){\n      char res[3];\n      if(i==0){\n        s1[x] = '.';\n        s2[x] = '.';\n      }else if(i==1){\n        s1[x] = '#';\n        s2[x] = '.';\n      }else if(i==2){\n        s1[x] = '.';\n        s2[x] = '#';\n      }else if(i==3){\n        s1[x] = '#';\n        s2[x] = '#';\n      }\n      printf(\"%s\\n%s\\n\", s1+x, s2+x); fflush(stdout);\n      scanf(\"%s\",res);\n      if(res[0]=='T'){\n        flag = false;\n        x--;\n        break;\n      }\n    }\n    if(flag) break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nchar up[]={'.','#','.','#'}, down[]={'.','#','#','.'};\nstring judge, nowup, nowdown;\n\nint main()\n{\n    cin >> n;\n    for(int j=1; j<=420; j++) {\n        for(int i=0; i<4; i++) {\n            cout << nowup+up[i] << endl << nowdown+down[i] << endl;\n            cin >> judge;\n            if(judge==\"T\") {\n                nowup+=up[i];\n                nowdown+=down[i];\n            }\n            else if(judge==\"F\") continue;\n            else return 0;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\nconst int INT_INF = 500000000;\nconst long long LONG_LONG_INF = (long long)pow(10, 18);\nconst int MOD = pow(10, 9) + 7;\n/* contest template */\nint N, cnt;\nstring s1, s2, r;\n\nint main() {\n  cin >> N;\n  while (true) {\n    cnt = 0;\n    r = \"F\";\n    while (r == \"F\" && cnt < 5) {\n      cnt++;\n      if (cnt == 1) {\n        cout << s1 << \".\" << endl;\n        cout << s2 << \".\" << endl;\n      } else if (cnt == 2) {\n        cout << s1 << \"#\" << endl;\n        cout << s2 << \".\" << endl;\n      } else if (cnt == 3) {\n        cout << s1 << \".\" << endl;\n        cout << s2 << \"#\" << endl;\n      } else if (cnt == 4) {\n        cout << s1 << \"#\" << endl;\n        cout << s2 << \"#\" << endl;\n      }\n      cin >> r;\n    }\n    if (r == \"end\") {\n      return 0;\n    } else if (r == \"T\") {\n      if (cnt == 1) {\n        s1 = s1 + \".\";\n        s2 = s2 + \".\";\n      } else if (cnt == 2) {\n        s1 = s1 + \"#\";\n        s2 = s2 + \".\";\n      } else if (cnt == 3) {\n        s1 = s1 + \".\";\n        s2 = s2 + \"#\";\n      } else if (cnt == 4) {\n        s1 = s1 + \"#\";\n        s2 = s2 + \"#\";\n      }\n    } else if (r == \"F\") {\n      break;\n    }\n  }\n  while (true) {\n    cnt = 0;\n    r = \"F\";\n    while (r == \"F\" && cnt < 5) {\n      cnt++;\n      if (cnt == 1) {\n        cout << \".\" << s1 << endl;\n        cout << \".\" << s2 << endl;\n      } else if (cnt == 2) {\n        cout << \"#\" << s1 << endl;\n        cout << \".\" << s2 << endl;\n      } else if (cnt == 3) {\n        cout << \".\" << s1 << endl;\n        cout << \"#\" << s2 << endl;\n      } else if (cnt == 4) {\n        cout << \"#\" << s1 << endl;\n        cout << \"#\" << s2 << endl;\n      }\n      cin >> r;\n    }\n    if (r == \"end\") {\n      return 0;\n    } else if (r == \"T\") {\n      if (cnt == 1) {\n        s1 = \".\" + s1;\n        s2 = \".\" + s2;\n      } else if (cnt == 2) {\n        s1 = \"#\" + s1;\n        s2 = \".\" + s2;\n      } else if (cnt == 3) {\n        s1 = \".\" + s1;\n        s2 = \"#\" + s2;\n      } else if (cnt == 4) {\n        s1 = \"#\" + s1;\n        s2 = \"#\" + s2;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring tmp[2] = {\"##..\", \"#.#.\"};\nstring rets, rett;\nbool r, l;\n\nbool query(string s, string t) {\n  cout << s << endl << t << endl;\n  string ans;\n  cin >> ans;\n  if(ans == \"end\") return true;\n  if(ans == \"T\") return true;\n  return false;\n}\n\nvoid rdfs(string s, string t) {\n  if(r) return;\n  REP(i, 4) {\n    if(query(s+tmp[0][i], t+tmp[1][i])) {\n      rdfs(s+tmp[0][i], t+tmp[1][i]);\n    }\n    if(r) return;\n  }\n  rets = s, rett = t;\n  r = true;\n}\n\nvoid ldfs(string s, string t) {\n  if(l) return;\n  REP(i, 4) {\n    if(query(tmp[0][i]+s, tmp[1][i]+t)) {\n      ldfs(tmp[0][i]+s, tmp[1][i]+t);\n    }\n    if(l) return;\n  }\n  rets = s, rett = t;\n  l = true;\n}\n\nsigned main(void)\n{\n  int n;\n  cin >> n;\n\n  rdfs(\"\",\"\");\n  ldfs(rets, rett);\n\n  query(rets, rett);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint now = 0;\n\tstring s1 = \"\";\n\tstring s2 = \"\";\n\tstring r = \"\";\n\t\n\twhile(r != \"end\"){\n\t\tif(r == \"F\"){\n\t\t\tif(s1[s1.length() - 1] == '.' && s2[s2.length() - 1] == '.'){\n\t\t\t\ts1[s1.length() - 1] = '#';\n\t\t\t}else if(s1[s1.length() - 1] == '#' && s2[s2.length() - 1] == '.'){\n\t\t\t\ts1[s1.length() - 1] = '.';\n\t\t\t\ts2[s2.length() - 1] = '#';\n\t\t\t}else if(s1[s1.length() - 1] == '.' && s2[s2.length() - 1] == '#'){\n\t\t\t\ts1[s1.length() - 1] = '#';\n\t\t\t\tif(now < n){\n\t\t\t\t\ts1 += \".\";\n\t\t\t\t\ts2 += \".\";\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\ts1 += \".\";\n\t\t\ts2 += \".\";\n\t\t\tnow++;\n\t\t}\n\t\t\n\t\tcout << s1 << endl;\n\t\tcout << s2 << endl;\n\t\tfflush(stdout);\n\n\t\tcin >> r;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef pair<string, string>P;\ntypedef long long ll;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\nmap<pair<int, int>, bool>mp;\nint main() {\n\tint n; cin >> n;\n\tdeque<P>po;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po.push_back(P(s1, s2));\n\t}\n\twhile (1) {\n\t\trep(i, po.size()) {\n\t\t\trep(j, po.size()) {\n\t\t\t\tif (mp[{i, j}])continue;\n\t\t\t\tmp[{i, j}] = true;\n\t\t\t\tP p1 = po[i], p2 = po[j];\n\t\t\t\tif (p1.first.size() + p2.first.size() == p1.second.size() + p2.second.size() && p1.first.size() + p2.second.size() <= n) {\n\t\t\t\t\tcout << p1.first + p2.first << endl << p1.second + p2.second << endl;\n\t\t\t\t\tcin >> res;\n\t\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\t\tif (res == \"T\")po.push_back(P(p1.first + p2.first, p1.second + p2.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <complex>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n \ntypedef tuple<ll,ll,ll> T;\n\n\nstring a=\"\";\nstring b=\"\";\n\t\nstring check(string x, string y){\n\tstring r;\n\tprintf(\"%s\\n%s\\n\", a+x, b+y); fflush(stdout);\n\tcin >> r;\n\tif(r==\"end\")\n\t\treturn r;\n\telse if(r==\"T\"){\n\t\ta=a+x;\n\t\tb=b+y;\n\t}\n\treturn r;\n}\n\nstring check2(string x, string y){\n\tstring r;\n\tprintf(\"%s\\n%s\\n\", x+a, y+b); fflush(stdout);\n\tcin >> r;\n\tif(r==\"end\")\n\t\treturn r;\n\telse if(r==\"T\"){\n\t\ta=x+a;\n\t\tb=y+b;\n\t}\n\treturn r;\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\twhile(1){\n\t\twhile(1){\n\t\t\tstring r=check(\".\",\".\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\n\t\t\tr=check(\"#\",\".\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tr=check(\".\",\"#\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tr=check(\"#\",\"#\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\twhile(1){\n\t\t\tstring r=check2(\".\",\".\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\n\t\t\tr=check2(\"#\",\".\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tr=check2(\".\",\"#\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tr=check2(\"#\",\"#\");\n\t\t\tif(r==\"end\")\n\t\t\t\treturn 0;\n\t\t\telse if(r==\"T\")\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <unordered_map>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\nusing namespace std;\n\nint n;\nstring up = \"\";\nstring down = \"\";\nstring upAdd = \"..##\";\nstring downAdd = \".#.#\";\n\nint MAIN()\n{\n\tcin >> n;\n\n\twhile(true)\n\t{\n\t\tbool findIt = false;\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tstring qUp = up;\n\t\t\tstring qDown = down;\n\t\t\tqUp += upAdd[i];\n\t\t\tqDown += downAdd[i];\n\t\t\tcout << qUp << endl;\n\t\t\tcout << qDown << endl;\n\t\t\tcout << flush;\n\t\t\tstring rev;\n\t\t\tcin >> rev;\n\t\t\tif(rev == \"end\") return 0;\n\t\t\tif(rev == \"T\")\n\t\t\t{\n\t\t\t\tup = qUp;\n\t\t\t\tdown = qDown;\n\t\t\t\tfindIt = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!findIt)\n\t\t\tbreak;\n\t}\n\n\twhile(true)\n\t{\n\t\tbool findIt = false;\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tstring qUp = \"\";\n\t\t\tstring qDown = \"\";\n\t\t\tqUp += upAdd[i];\n\t\t\tqDown += downAdd[i];\n\t\t\tqUp += up;\n\t\t\tqDown += down;\n\t\t\tcout << qUp << endl;\n\t\t\tcout << qDown << endl;\n\t\t\tcout << flush;\n\t\t\tstring rev;\n\t\t\tcin >> rev;\n\t\t\tif(rev == \"end\") return 0;\n\t\t\tif(rev == \"T\")\n\t\t\t{\n\t\t\t\tup = qUp;\n\t\t\t\tdown = qDown;\n\t\t\t\tfindIt = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!findIt)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint start = clock();\n\t#ifdef LOCAL_TEST\n\t\tfreopen(\"in.txt\", \"r\", stdin);\n\t\tfreopen(\"out2.txt\", \"w\", stdout);\n\t#endif\n\tios :: sync_with_stdio(false);\n\tcout << fixed << setprecision(16);\n\tint ret = MAIN();\n\t#ifdef LOCAL_TEST\n\t\tcout << \"[Finished in \" << clock() - start << \" ms]\" << endl;\n\t#endif\n\treturn ret;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef pair<string, string>P;\ntypedef long long ll;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\nint main() {\n\tint n; cin >> n;\n\tdeque<P>po;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po.push_back(P(s1, s2));\n\t}\n\tqueue<P>que;\n\tfor (P i : po)que.push(i);\n\twhile (1) {\n\t\tP p = que.front(); que.pop();\n\t\tfor (P i : po) {\n\t\t\tcout << p.first + i.first << endl << p.second + i.second << endl;\n\t\t\tcin >> res;\n\t\t\tif (res == \"end\")return 0;\n\t\t\tif (res == \"T\")que.push(P(p.first + i.first, p.second + i.second));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<string, string>P;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\ndeque<P>po[200];\nint main() {\n\tint n; cin >> n;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po[1].push_back(P(s1, s2));\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\tfor (int k = 1; j + k <= n; k++) {\n\t\t\t\tfor (P p1 : po[j]) {\n\t\t\t\t\tfor (P p2 : po[k]) {\n\t\t\t\t\t\tcout << p1.first + p2.first << endl << p1.second + p2.second << endl;\n\t\t\t\t\t\tcin >> res;\n\t\t\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\t\t\tif (res == \"T\")po[i].push_back(P(p1.first + p2.first, p1.second + p2.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define mod 1000000007\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\nstring str[2];\nstring X[] = {\".\",\"#\",\".\",\"#\"};\nstring Y[] = {\"#\",\".\",\".\",\"#\"};\n\nchar A[] = {'.','#','.','#'};\nchar B[] = {'#','.','.','#'};\n\nint main() {\n\n\tint i, j;\n\tint N;\n\n\tcin >> N;\n\n\tint ind;\n\tbool flag = 1;\n\n\tstring ans;\n\n\twhile(1)\n\t{\n\t\tbool done = 0;\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tstr[0].push_back(A[i]);\n\t\t\t\tstr[1].push_back(B[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr[0].insert(0,X[i]);\n\t\t\t\tstr[1].insert(0,Y[i]);\n\t\t\t}\n\t\t\tcout << str[0] << \"\\n\" << str[1] << \"\\n\";\n\t\t\tfflush(stdout);\n\t\t\tcin >> ans;\n\t\t\tif(ans == \"T\")\n\t\t\t{\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(ans == \"F\")\n\t\t\t{\n\t\t\t\tif(flag)\n\t\t\t\t{\n\t\t\t\t\tstr[0].pop_back();\n\t\t\t\t\tstr[1].pop_back();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstr[0].erase(0,1);\n\t\t\t\t\tstr[1].erase(0,1);\n\t\t\t\t}\n\t\t\t\tdone = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\tif(!done)\n\t\t{\n\t\t\tflag ^= 1;\n\t\t}\n\t}\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nbool stop = false;\nvoid dfs(string s1, string s2) {\n    if(s1.size() == N + 1) return;\n    if (stop) return;\n    string res;\n    rep(i, 2) rep(j, 2) {\n        if (stop) return;\n        char c1 = i == 0 ? '.' : '#';\n        char c2 = j == 0 ? '.' : '#';\n        auto t1 = s1 + c1;\n        auto t2 = s2 + c2;\n        printf(\"%s\\n%s\\n\", t1.c_str(), t2.c_str()); fflush(stdout);\n        cin >> res;\n        if (res == \"end\") {\n            stop = true;\n            break;\n        }\n        if (res == \"T\") {\n            dfs(t1, t2);\n        }\n        if (stop) return;\n    }\n}\nint main() {\n    cin >> N;\n    dfs(\"\", \"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n\n\nint n;\nstring c, sx, sy, x[] = {\".\", \".\", \"#\", \"#\"}, y[] = {\".\", \"#\", \".\", \"#\"}, t, lx, ly;\nbool re;\n\nsigned main() {\n\tcin >> n;\n\twhile (1) {\n\t\tif (!re) {\n\t\t\trep(i,4) {\n\t\t\t\tcout << sx+x[i] << endl << sy+y[i] << endl << flush;\n\t\t\t\tcin >> t;\n\t\t\t\tif (t==\"end\") return 0;\n\t\t\t\tif (t==\"T\") {\n\t\t\t\t\tsx += x[i], sy += y[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i==3) re = 1;\n\t\t\t}\n\t\t} else {\n\t\t\trep(i,4) {\n\t\t\t\tcout << lx+x[i]+sx << endl << ly+y[i]+sy << endl << flush;\n\t\t\t\tcin >> t;\n\t\t\t\tif (t==\"end\") return 0;\n\t\t\t\tif (t==\"T\") {\n\t\t\t\t\tlx += x[i], ly += y[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nstring u=\"##..\";\nstring v=\"#.#.\";\n\nsigned main(){\n    int N;\n    cin>>N;\n\n    string S,T;\n    string ret;\n    while(true){\n       bool update=false;\n       rep(i,4){\n            string SS=S+u[i];\n            string TT=T+v[i];\n            cout<<SS<<endl<<TT<<endl;\n            cin>>ret;\n            if(ret==\"end\")return 0;\n            if(ret==\"T\"){\n                S=SS;T=TT;\n                update=true;\n                break;\n            }\n       }\n       if(!update)break;\n    }\n\n    while(true){\n       bool update=false;\n       rep(i,4){\n            string SS=u[i]+S;\n            string TT=v[i]+T;\n            cout<<SS<<endl<<TT<<endl;\n            cin>>ret;\n            if(ret==\"end\")return 0;\n            if(ret==\"T\"){\n                S=SS;T=TT;\n                update=true;\n                break;\n            }\n       }\n       if(!update)break;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#ifndef err\n#define err(...)(void)0\n#endif\nusing namespace std;\nusing ll = long long;\nusing ull = decltype(1ull);\ntemplate<class T>int size(T&&a) { return a.size(); }\n#define REP(t,a)for(make_signed<decltype(a.second)>::type t=a.first,_l##t=a.second;t<_l##t;t++)\n#define RREP(t,a)for(make_signed<decltype(a.second)>::type t=a.second-1,_l##t=a.first;t>=_l##t;t--)\ntemplate<class B>pair<int, B>make_pair(B b) { return{ 0,b }; }\n#define rep(t,...)REP(t,make_pair(__VA_ARGS__))\n#define rrep(t,...)RREP(t,make_pair(__VA_ARGS__))\n#define all(a)begin(a),end(a)\n#define rall(a)a.rbegin(),a.rend()\n\nvoid Calc();\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0); cin.exceptions(istream::failbit | istream::badbit);\n  cout << fixed << setprecision(15); Calc(); cout.flush(); return 0;\n}\ntemplate<class A>void amax(A&a, A b) { a = max(a, b); }\ntemplate<class A>void amin(A&a, A b) { a = min(a, b); }\nstruct Scanner {\n  template<class A = string>A Next() { A a; cin >> a; return a; }\n  template<class A = int>vector<A>Array(int n) { vector<A>a(n); for (A&i : a) cin >> i; return a; }\n  string Line() { string s; getline(cin, s); return s; }\n  template<class A>Scanner&operator,(A&a) { a = Next<A>(); return *this; }\n  template<class A>operator A() { return Next<A>(); }\n}in;\n\n/*---------------------------------------------------------------------*/\n\nvoid Calc() {\n  int n = in;\n  string s1, s2;\n  char tmp, tmp2;\n  char c[] = { '.', '#' };\n  bool isRight = true;\n\n  for (;;) {\n    bool ok = false;\n    rep(i, 2)rep(j, 2) {\n      tmp = c[i], tmp2 = c[j];\n      if (isRight) {\n        cout << (s1) << tmp << endl;\n        cout << (s2) << tmp2 << endl;\n      } else {\n        cout << tmp << (s1) << endl;\n        cout << tmp2 << (s2) << endl;\n      }\n      string res = in;\n      if (res == \"end\")return;\n      if (res[0] == 'T') {\n        ok = true;\n        if (isRight) {\n          s1 += tmp;\n          s2 += tmp2;\n        } else {\n          s1.insert(s1.begin(), tmp);\n          s2.insert(s2.begin(), tmp2);\n        }\n        break;\n      }\n    }\n    if (ok == false) {\n      isRight = false;\n    }\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring f(string s,char c){\n\tstring ret = \"\";\n\tret += c;\n\trep(i,s.size()){\n\t\tret += s[i];\n\t}\n\treturn ret;\n}\nstring b(string s,char c){\n\ts += c;\n\treturn s;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tstring s[2] = { \"\" , \"\" };\n\t\n\tconst char c[4][2] = { {'.','.'},{'.','#'},{'#','.'},{'#','#'} };\n\t\n\tchar R;\n\tbool t = false;\n\twhile(1){\n\t\tif(!t){\n\t\t\trep(i,4){\n\t\t\t\tcout << b(s[0],c[i][0]) << \"\\n\" << b(s[1],c[i][1]) << \"\\n\";\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin >> R;\n\t\t\t\tif(R == 'T'){\n\t\t\t\t\ts[0] = b(s[0],c[i][0]);\n\t\t\t\t\ts[1] = b(s[1],c[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i == 3)t = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trep(i,4){\n\t\t\t\tcout << f(s[0],c[i][0]) << \"\\n\" << f(s[1],c[i][1]) << \"\\n\";\n\t\t\t\tfflush(stdout);\n\t\t\t\tcin >> R;\n\t\t\t\tif(R == 'T'){\n\t\t\t\t\ts[0] = f(s[0],c[i][0]);\n\t\t\t\t\ts[1] = f(s[1],c[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#include<string.h>\n#include<stack>\n#include<functional>\nusing namespace std;\n\nstring a = \"#.\";\nsigned main() {\n\tint b; cin >> b;\n\tstring c, d;\n\twhile (1) {\n\tl:;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tc += a[i]; d += a[j];\n\t\t\t\tcout << c << endl;\n\t\t\t\tcout << d << endl;\n\t\t\t\tstring e; cin >> e;\n\t\t\t\tif (e == \"T\") {\n\t\t\t\t\tgoto l;\n\t\t\t\t}\n\t\t\t\telse if(e==\"end\"){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc.erase(--c.end());\n\t\t\t\td.erase(--d.end());\n\t\t\t}\n\t\t}\n\t\tputs(\"YES\");\n\t\tbreak;\n\t}\n\twhile (1) {\n\tr:;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tc = a[i] + c; d = a[j] + d;\n\t\t\t\tcout << c << endl;\n\t\t\t\tcout << d << endl;\n\t\t\t\tstring e; cin >> e;\n\t\t\t\tif (e == \"T\") {\n\t\t\t\t\tgoto r;\n\t\t\t\t}\n\t\t\t\telse if (e == \"end\") {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc.erase(c.begin());\n\t\t\t\td.erase(d.begin());\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    string s1 = \"\", s2 = \"\";\n    while (true)\n    {\n        if ((int)s1.size() == n)\n            break;\n        string ret;\n        string t1 = s1 + \".\", t2 = s2 + \".\";\n        cout << t1 << endl;\n        cout << t2 << endl;\n        cin >> ret;\n        if (ret == \"T\" || ret == \"end\")\n        {\n            s1 = t1;\n            s2 = t2;\n            continue;\n        }\n        t1 = s1 + \".\", t2 = s2 + \"#\";\n        cout << t1 << endl;\n        cout << t2 << endl;\n        cin >> ret;\n        if (ret == \"T\" || ret == \"end\")\n        {\n            s1 = t1;\n            s2 = t2;\n            continue;\n        }\n        t1 = s1 + \"#\", t2 = s2 + \".\";\n        cout << t1 << endl;\n        cout << t2 << endl;\n        cin >> ret;\n        if (ret == \"T\" || ret == \"end\")\n        {\n            s1 = t1;\n            s2 = t2;\n            continue;\n        }\n        t1 = s1 + \"#\", t2 = s2 + \"#\";\n        cout << t1 << endl;\n        cout << t2 << endl;\n        cin >> ret;\n        if (ret == \"T\" || ret == \"end\")\n        {\n            s1 = t1;\n            s2 = t2;\n            continue;\n        }\n        break;\n    }\n    while (true)\n    {\n        if ((int)s1.size() == n)\n            break;\n        string ret;\n        string t1 = \".\" + s1, t2 = \".\" + s2;\n        cout << t1 << endl;\n        cout << t2 << endl;\n        cin >> ret;\n        if (ret == \"T\" || ret == \"end\")\n        {\n            s1 = t1;\n            s2 = t2;\n            continue;\n        }\n        t1 = \".\" + s1, t2 = \"#\" + s2;\n        cout << t1 << endl;\n        cout << t2 << endl;\n        cin >> ret;\n        if (ret == \"T\" || ret == \"end\")\n        {\n            s1 = t1;\n            s2 = t2;\n            continue;\n        }\n        t1 = \"#\" + s1, t2 = \".\" + s2;\n        cout << t1 << endl;\n        cout << t2 << endl;\n        cin >> ret;\n        if (ret == \"T\" || ret == \"end\")\n        {\n            s1 = t1;\n            s2 = t2;\n            continue;\n        }\n        t1 = \"#\" + s1, t2 = \"#\" + s2;\n        cout << t1 << endl;\n        cout << t2 << endl;\n        cin >> ret;\n        if (ret == \"T\" || ret == \"end\")\n        {\n            s1 = t1;\n            s2 = t2;\n            continue;\n        }\n        break;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\n#define int long long\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(a) (a).begin(), (a).end()\n#define PB push_back\n#define MP make_pair\n#define FST first\n#define SND second\n#define SZ(a) (signed)((a).size())\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\nconst int MOD = 1000000007;\nconst char ENDL = '\\n';\n\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\"  << \" \" << __FILE__ << endl;\n\nsigned main(void) {\n//    ios::sync_with_stdio(false);\n//    cout.setf(ios::fixed, ios::floatfield);\n//    cout.precision(10);\n//    cin.tie(0);\n\n    int n;\n    cin >> n;\n    string s1,s2;\n\n    string r;\n    int state=0;\n    while(r!=\"end\"){\n        if(r==\"T\"){\n            if(state<=3){\n                state=0;\n            }else{\n                state=4;\n            }\n        }else if(r==\"F\"){\n            if(state==3){\n                s1.erase(s1.end());\n                s2.erase(s1.end());\n            }\n            state++;\n        }\n        switch (state){\n            case 0:\n                s1+=\".\";\n                s2+=\".\";\n                break;\n            case 1:\n                s1.back()='.';\n                s2.back()='#';\n                break;\n            case 2:\n                s1.back()='#';\n                s2.back()='.';\n                break;\n            case 3:\n                s1.back()='#';\n                s2.back()='#';\n                break;\n            case 4:\n                s1.insert(0,\".\");\n                s2.insert(0,\".\");\n                break;\n            case 5:\n                s1.front()='.';\n                s2.front()='#';\n                break;\n            case 6:\n                s1.front()='#';\n                s2.front()='.';\n                break;\n            case 7:\n                s1.front()='#';\n                s2.front()='#';\n                break;\n        }\n        printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str());\n        fflush(stdout);\n        cin >> r;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nchar a[3] = {'.','#'};\n\nstring answer() {\n    string s; cin >> s;\n\n    if (s == \"end\") {\n        exit(0);\n    }\n\n    return s;\n}\n\nsigned main()\n{ // #define int long long をしてるのでscanfを使うと意味不明な値が入力され死にます\n    int N; cin >> N;\n\n    string S[2];\n\n    bool r = true; // 右に伸ばしているか\n\n    while (true) {\n        if (r) {\n            bool f = true;\n\n            S[0] += ' ';\n            S[1] += ' ';\n\n            int pos = S[0].size() - 1;\n\n            rep(i, 2) rep(j, 2) {\n                S[0][pos] = a[i];\n                S[1][pos] = a[j];\n\n                cout << S[0] << endl;\n                cout << S[1] << endl;\n\n                string ans = answer();\n\n                if (ans == \"T\") {\n                    goto nxt1;\n                }\n            }\n\n            S[0] = S[0].substr(0, S[0].size() - 1);\n            S[1] = S[1].substr(0, S[1].size() - 1);\n\n            r = false;\nnxt1:;\n        } else {\n            bool f = true;\n\n            string T[2];\n\n            T[0] += ' ';\n            T[0] += S[0];\n            T[1] += ' ';\n            T[1] += S[1];\n\n            rep(i, 2) rep(j, 2) {\n                T[0][0] = a[i];\n                T[1][0] = a[j];\n\n                cout << T[0] << endl;\n                cout << T[1] << endl;\n\n                string ans = answer();\n\n                if (ans == \"T\") {\n                    goto nxt2;\n                }\n            }\n\n            break;\nnxt2:;\n            S[0] = T[0];\n            S[1] = T[1];\n        }\n    }\n\n    cout << S[0] << endl;\n    cout << S[1] << endl;\n\n    string s; cin >> s;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nchar a[3] = {'.','#'};\n\nstring answer() {\n    string s; cin >> s;\n\n    if (s == \"end\") {\n        exit(0);\n    }\n\n    return s;\n}\n\nsigned main()\n{ // #define int long long をしてるのでscanfを使うと意味不明な値が入力され死にます\n    int N; cin >> N;\n\n    string S[2];\n\n    bool r = true; // 右に伸ばしているか\n\n    while (true) {\n        if (r) {\n            bool f = true;\n\n            S[0] += ' ';\n            S[1] += ' ';\n\n            int pos = S[0].size() - 1;\n\n            rep(i, 2) rep(j, 2) {\n                S[0][pos] = a[i];\n                S[1][pos] = a[j];\n\n                cout << S[0] << endl;\n                cout << S[1] << endl;\n\n                string ans = answer();\n\n                if (ans == \"T\") {\n                    f = false;\n                    goto nxt1;\n                }\n            }\n\n            if (f) {\n                r = false;\n            }\n\nnxt1:;\n        } else {\n            bool f = true;\n\n            string T[2];\n\n            T[0] += ' ';\n            T[0] += S[0];\n            T[1] += ' ';\n            T[1] += S[1];\n\n            rep(i, 2) rep(j, 2) {\n                T[0][0] = a[i];\n                T[1][0] = a[j];\n\n                cout << T[0] << endl;\n                cout << T[1] << endl;\n\n                string ans = answer();\n\n                if (ans == \"T\") {\n                    f = false;\n                    goto nxt2;\n                }\n            }\n\n            if (f) {\n                break;\n            }\nnxt2:;\n            S[0] = T[0];\n            S[1] = T[1];\n        }\n    }\n\n    cout << S[0] << endl;\n    cout << S[1] << endl;\n\n    string s; cin >> s;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n\nusing namespace std;\n\nchar s[3] = \".#\";\nchar c[4];\n\nint main() {\n    int n, i, j;\n    string s1 = \"\", s2 = \"\";\n    \n    scanf(\"%d\", &n);\n    \n    while (1) {\n        int f = 0;\n        \n        for (i = 0; i < 2 && f == 0; i++) {\n            for (j = 0; j < 2 && f == 0; j++) {\n                string ss1 = s1 + s[i];\n                string ss2 = s2 + s[j];\n                \n                printf(\"%s\\n\", ss1.c_str());\n                printf(\"%s\\n\", ss2.c_str());\n                fflush(stdout);\n                \n                scanf(\"%s\", c);\n                \n                if (c[0] == 'e') {\n                    return 0;\n                } else if (c[0] == 'T') {\n                    f = 1;\n                    \n                    s1 = ss1;\n                    s2 = ss2;\n                }\n            }\n        }\n        \n        if (f == 0) break;\n    }\n    \n    while (1) {\n        int f = 0;\n        \n        for (i = 0; i < 2 && f == 0; i++) {\n            for (j = 0; j < 2 && f == 0; j++) {\n                string ss1 = s[i] + s1;\n                string ss2 = s[j] + s2;\n                \n                printf(\"%s\\n\", ss1.c_str());\n                printf(\"%s\\n\", ss2.c_str());\n                fflush(stdout);\n                \n                scanf(\"%s\", c);\n                \n                if (c[0] == 'e') {\n                    return 0;\n                } else if (c[0] == 'T') {\n                    f = 1;\n                    \n                    s1 = ss1;\n                    s2 = ss2;\n                }\n            }\n        }\n        \n        if (f == 0) break;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<string, string>P;\n\nint dx[]{ 1,1,0,0 }, dy[]{ 1,0,1,0 };\ndeque<P>po[200];\nint main() {\n\tint n; cin >> n;\n\tstring res;\n\trep(i, 4) {\n\t\tstring s1, s2;\n\t\tif (dx[i])s1 = \"#\";\n\t\telse s1 = \".\";\n\t\tif (dy[i])s2 = \"#\";\n\t\telse s2 = \".\";\n\t\tcout << s1 << endl << s2 << endl;\n\t\tcin >> res;\n\t\tif (res == \"end\")return 0;\n\t\tif (res == \"T\")po[1].push_back(P(s1, s2));\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\tfor (int k = 0; j + k <= n; k++) {\n\t\t\t\tfor (P p1 : po[j]) {\n\t\t\t\t\tfor (P p2 : po[k]) {\n\t\t\t\t\t\tcout << p1.first + p2.first << endl << p1.second + p2.second << endl;\n\t\t\t\t\t\tcin >> res;\n\t\t\t\t\t\tif (res == \"end\")return 0;\n\t\t\t\t\t\tif (res == \"T\")po[i].push_back(P(p1.first + p2.first, p1.second + p2.second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tdeque<char> aBener,bBener;\n\tint t = 1;\n\t\n\tchar atas[4] = {'.','#','.','#'};\n\t char bwh[4] = {'.','.','#','#'};\n\tstring s;\n\tint idx = 0,ct = 0;\n\tdo{\n\t\tif(idx>=7) idx = 0;\n\t\tif(aBener.size()>=n){\n\t\t\tbreak;\n\t\t}\n\t\tct++;\n\t\tif(s == \"end\") break;\n\t\tif(s == \"F\") idx++;\n\t\tif(s == \"T\" ) {\n\t\t\tif(idx <= 3){\n\t\t\t\taBener.push_back(atas[idx]);\n\t\t\t\tbBener.push_back(bwh[idx]);\t\n\t\t\t}else{\n\t\t\t\taBener.push_front(atas[idx-4]);\n\t\t\t\tbBener.push_front(bwh[idx-4]);\n\t\t\t}\n\t\t\tidx = 0;\n\t\t}\n\t\tif(idx >3){\n\t\t\t//maka coba masukin di blkgnya\n\t\t\tint tidx = idx-4;\n\t\t\tprintf(\"%c\",atas[tidx]);\n\t\t\tfor(int i = 0;i<aBener.size();i++){\n\t\t\t\tprintf(\"%c\",aBener[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"%c\",bwh[tidx]);\n\t\t\tfor(int i = 0;i<bBener.size();i++){\n\t\t\t\tprintf(\"%c\",bBener[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0;i<aBener.size();i++){\n\t\t\tprintf(\"%c\",aBener[i]);\n\t\t}\n\t\t\n\t\t//coba\n\t\tprintf(\"%c\",atas[idx]);\n\t\tprintf(\"\\n\");\n\t\tfor(int i = 0;i<bBener.size();i++){\n\t\t\tprintf(\"%c\",bBener[i]);\n\t\t}\n\t\tprintf(\"%c\",bwh[idx]);\n\t\tprintf(\"\\n\");\n\t}while(cin>>s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>//min/max/sort(rand-access it)/merge\n#include <array>\n#include <bitset>\n#include <climits>//INT_MAX/INT_MIN/ULLONG_MAX\n#include <cmath>//fmin/fmax/fabs/sin(h)/cos(h)/tan(h)/exp/log/pow/sqrt/cbrt/ceil/floor/round/trunc\n#include <cstdlib>//abs/atof/atoi/atol/atoll/strtod/strtof/..., srand/rand, calloc/malloc, exit, qsort\n#include <iomanip>//setfill/setw\n#include <iostream>//cin/cout/wcin/wcout/left/right/internal/dec/hex/oct/fixed/scientific\n#include <iterator>\n#include <list>\n#include <queue>\n#include <string>//stoi/stol/stoul/stoll/stoull/stof/stod/stold/to_string/getline\n#include <tuple>\n#include <utility>//pair\n#include <valarray>\n#include <vector>\n\n#define PRIME_SHORT 10007\n#define PRIME 1000000007\n\nusing namespace std;\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> plli;\ntypedef pair<ull, int> puli;\ntypedef pair<double, int> pdi;\ntypedef pair<ll, ll> pllll;\ntypedef pair<ull, ull> pulul;\ntypedef pair<double, double> pdd;\ntypedef tuple<int, int, int> ti3;\ntypedef tuple<int, int, int, int> ti4;\n\nconst bool debug = false;\n\nvoid rar(int n, int* a);\nvoid rar2(int n, int m, int** a);\n\nint ipow(int base, int exp);\nint left(int current, bool swap);\nint right(int current, bool swap);\nint griddist(int x, int y, int s, int t);\nint griddist(pii one, pii two);\ndouble sqeucldist(double x, double y, double s, double t);\ndouble sqeucldist(pii one, pii two);\null modadd(ull a, ull b, int mod);\null modmult(ull a, ull b, int mod);\n\nvoid set(string top, string bot, bool up, bool down)\n{\n    top += up?\".\":\"#\";\n    bot += down?\".\":\"#\";\n}\n\nvoid set_front(string top, string bot, deque<char> ttop, deque<char> bbot, bool up, bool down)\n{\n    ttop.push_front(up?'.':'#');\n    bbot.push_front(down?'.':'#');\n    size_t n = ttop.size();\n    char* ctop = new char[n];\n    char* cbot = new char[n];\n    for (size_t i = 0; i < n; ++i)\n    {\n        ctop[i] = ttop[i];\n        cbot[i] = bbot[i];\n    }\n    top = string(ctop, n);\n    bot = string(cbot, n);\n}\n\nvoid pop(string top, string bot)\n{\n    top.pop_back();\n    bot.pop_back();\n}\n\nvoid pop_front(string top, string bot, deque<char> ttop, deque<char> bbot)\n{\n    ttop.pop_front();\n    bbot.pop_front();\n    size_t n = ttop.size();\n    char* ctop = new char[n];\n    char* cbot = new char[n];\n    for (size_t i = 0; i < n; ++i)\n    {\n        ctop[i] = ttop[i];\n        cbot[i] = bbot[i];\n    }\n    top = string(ctop, n);\n    bot = string(cbot, n);\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n\n    pair< deque<char>, deque<char> > backend;\n\n    //.. .# #. ##\n    bool possible[4] = {true, true, true, true};\n    pair<bool, bool> comb[4];\n    comb.push_back(true, true);\n    comb.push_back(true, false);\n    comb.push_back(false, true);\n    comb.push_back(false, false);\n\n    string status;\n\n    string top = \"\";\n    string bot = \"\";\n\n    for (int i = 0; i < 4; ++i)\n    {\n        set(top, bot, comb[i].first, comb[i].second);\n        cout << top + \"\\n\" + bot << endl;\n        cin >> status;\n        if (status == \"T\") {\n            pop(top, bot);\n        } else if (status == \"F\") {\n            possible[i] = false;\n            pop(top, bot);\n        } else if (status == \"end\") {\n            return 0;\n        }\n    }\n\n    std::vector<int> good;\n\n    for (int i = 0; i < 4; ++i)\n    {\n        if (possible[i])\n        {\n            good.push_back(i);\n        }\n    }\n\n    int wid = 1;\n    bool btof = false;\n    while (wid <= n) {\n\n        //debug output\n        if (debug)\n        {\n            cout << top << endl;\n            cout << bot << endl;\n        }\n\n        bool found = false;\n        if (!btof)\n        {\n            for (int i = 0; i < good.size(); ++i)\n            {\n                set_front(top, bot, backend.first, backend.second, comb[good[i]].first, comb[good[i]].second);\n                cout << top + \"\\n\" + bot << endl;\n                cin >> status;\n                if (status == \"T\")\n                {\n                    found = true;\n                    break;\n                } else if (status == \"F\") {\n                    pop_front(top, bot, backend.first, backend.second);\n                    continue;\n                } else if (status == \"end\") {\n                    return 0;\n                }\n            }\n            if (!found)\n            {\n                if (debug)\n                {\n                    cout << \"error\" << endl;\n                }\n                return 1;\n            }\n        } else {\n            for (int i = 0; i < good.size(); ++i)\n            {\n                set(top, bot, comb[good[i]].first, comb[good[i]].second);\n                cout << top + \"\\n\" + bot << endl;\n                cin >> status;\n                if (status == \"T\")\n                {\n                    found = true;\n                    break;\n                } else if (status == \"F\") {\n                    pop(top, bot);\n                    continue;\n                } else if (status == \"end\") {\n                    return 0;\n                }\n            }       \n            if (!found)\n            {\n                deque<char> ttop, bbot;\n                for (int i = 0; i < top.size(); ++i)\n                {\n                    ttop.push_back(top[i]);\n                    bbot.push_back(bot[i]);\n                }\n                backend = make_pair(ttop, bbot);\n                btof = true;\n            }     \n        }\n    }\n\n    return 0;\n}\n\nvoid rar(int n, int* a)\n{\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> a[i];\n    }\n    return;\n}\n\nvoid rar2(int n, int m, int** a)\n{\n    for (int i = 0; i < n; ++i)\n    {\n        a[i] = new int[m];\n        for (int j = 0; j < m; ++j)\n        {\n            cin >> a[i][j];\n        }\n    }\n    return;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint ipow(int base, int exp) {\n    int result = 1;\n    while (exp)\n    {\n        if (exp & 1)\n            result *= base;\n        exp >>= 1;\n        base *= base;\n    }\n\n    return result;\n}\nint left(int current, bool swap = false) {\n    if(swap){\n        return right(current, false);\n    } else {\n        return 2*current + 1;\n    }\n}\nint right(int current, bool swap = false) {\n    if(swap){\n        return left(current, false);\n    } else {\n        return 2*(current+1);\n    }\n}\nint griddist(int x, int y, int s, int t) {\n    return abs(x-s) + abs(y-t);\n}\nint griddist(pii one, pii two) {\n    return abs(one.first - two.first) + abs(one.second - two.second);\n}\ndouble sqeucldist(double x, double y, double s, double t) {\n    double a = x-s;\n    double b = y-t;\n    return a*a+b*b;\n}\ndouble sqeucldist(pii one, pii two) {\n    double a = one.first - two.first;\n    double b = one.second - two.second;\n    return a*a+b*b;\n}\n\null modadd(ull a, ull b, int mod) {\n    return (a%mod + b%mod)%mod;\n}\null modmult(ull a, ull b, int mod) {\n    return ((a%mod)*(b%mod))%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\n\nint ask(string a,string b) {\n\tcout<<a<<endl;\n\tcout<<b<<endl;\n\tstring s;\n\tcin>>s;\n\tif(s==\"end\") exit(0);\n\treturn s==\"T\";\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\tcin>>N;\n\t\n\tstring a=\"\";\n\tstring b=\"\";\n\twhile(1) {\n\t\tFOR(i,4) {\n\t\t\ta+=\".#\"[i/2];\n\t\t\tb+=\".#\"[i%2];\n\t\t\tif(ask(a,b)) break;\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t}\n\t\tif(i==4) break;\n\t}\n\twhile(1) {\n\t\tFOR(i,4) {\n\t\t\ta=\".#\"[i/2] + a;\n\t\t\tb=\".#\"[i/2] + b;\n\t\t\tif(ask(a,b)) break;\n\t\t\ta.erase(a.begin());\n\t\t\tb.erase(b.begin());\n\t\t}\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nint first = 100;\nint last = 100;\n\n\nstring ans = \"F\";\n\nbool isRight = true;\n\nint main(){\n\n\t/*char dumup[201];\n\tchar *up;\n\tup = dumup + 100;\n\n\tchar dumdown[201];\n\tchar *down;\n\tdown = dumdown + 100;\n\t\n\tcin >> N;\n\tmemset(dumup,'.',sizeof(dumup));\n\tmemset(dumdown,'.',sizeof(dumdown));*/\n\n\tchar up[201];\n\tchar down[201];\n\tmemset(up,'.',sizeof(up));\n\tmemset(down,'.',sizeof(down));\n\t\n\tcin >> N;\n\t\n\twhile(1){\n\t\t\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << intup << endl;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\tcout << intdown << endl;\n\t\t\t\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[last] = intup;\n\t\t\t\tdown[last] = intdown;\n\t\t\t\tlast++;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"F\" && i == 3){\n\t\t\t\tisRight = false;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"end\"){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(!isRight) break;\n\t}\n\twhile(last - first != N){\n\t\tchar intup = '.';\n\t\tchar intdown = '.';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==1){\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '.';\n\t\t\t}else if(i==2){\n\t\t\t\tintup = '.';\n\t\t\t\tintdown = '#';\n\t\t\t}else{\n\t\t\t\tintup = '#';\n\t\t\t\tintdown = '#';\n\t\t\t}\n\t\t\t\n\t\t\tcout << intup;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << up[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << intdown;\n\t\t\tfor(int j=first;j<last;j++){\n\t\t\t\tcout << down[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tfflush(stdout);\n\t\t\t\n\t\t\tcin >> ans;\n\t\t\t\n\t\t\tif(ans == \"T\"){\n\t\t\t\tup[first-1] = intup;\n\t\t\t\tdown[first-1] = intdown;\n\t\t\t\tfirst--;\n\t\t\t\tbreak;\n\t\t\t}else if(ans == \"end\"){\n\t\t\t\tisRight = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(isRight) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n#define next _next\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 50010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\n\n\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nstring a=\"\",b=\"\",g[2]={\".\",\"#\"};\nint out(string &s,string &t){\n\tcout<<s<<\"\\n\"<<t<<\"\\n\";fflush(stdout);\n\tstring x;\n\tcin>>x;\n\tif(x[0]=='e')exit(0);\n\treturn x[0]=='T';\n}\nint main(){\n    int T,i,j,k,ca=0,m,n,K;\n    //cout<<setprecision(10)<<fixed;\n    cin>>n;\n    int x,v[4]={0};\n    rep(i,0,4){\n    \ta=g[i&1],b=g[i>>1&1];\n    \tk=out(a,b);\n    \tif(k)v[i]=1,x=i;\n    }\n    a=g[x&1],b=g[x>>1&1];\n    rep(i,1,n){\n    \trep(j,0,4)if(v[j]){\n    \t\tstring aa=a+g[j&1],bb=b+g[j>>1&1];\n    \t\tk=out(aa,bb);\n    \t\tif(k){a=aa,b=bb;break;}\n    \t\taa=g[j&1]+a,bb=g[j>>1&1]+b;\n    \t\tk=out(aa,bb);\n    \t\tif(k){a=aa,b=bb;break;}\n    \t}\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 7;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tstring s1, s2;\n\tbool found = true;\n\twhile (found)\n\t{\n\t\tfound = false;\n\t\tfor (int i=0; i<2; i++)\n\t\t{\n\t\t\tfor (int j=0; j<2; j++)\n\t\t\t{\n\t\t\t\tcout << (i == 0 ? '.' : '#') << s1 << \"\\n\";\n\t\t\t\tcout << (j == 0 ? '.' : '#') << s2 << \"\\n\";\n\t\t\t\tcout << flush;\n\t\t\t\tchar res;\n\t\t\t\tcin >> res;\n\t\t\t\tif (res == 'T')\n\t\t\t\t{\n\t\t\t\t\tfound = true;\n\t\t\t\t\ts1 = (i == 0 ? '.' : '#') + s1;\n\t\t\t\t\ts2 = (j == 0 ? '.' : '#') + s2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfound = true;\n\twhile (found)\n\t{\n\t\tfound = false;\n\t\tfor (int i=0; i<2; i++)\n\t\t{\n\t\t\tfor (int j=0; j<2; j++)\n\t\t\t{\n\t\t\t\tcout << s1 << (i == 0 ? '.' : '#') << \"\\n\";\n\t\t\t\tcout << s2 << (j == 0 ? '.' : '#') << \"\\n\";\n\t\t\t\tcout << flush;\n\t\t\t\tchar res;\n\t\t\t\tcin >> res;\n\t\t\t\tif (res == 'T')\n\t\t\t\t{\n\t\t\t\t\tfound = true;\n\t\t\t\t\ts1 += (i == 0 ? '.' : '#');\n\t\t\t\t\ts2 += (j == 0 ? '.' : '#');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DBG(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nstring str = \".\\n.\\n\";\n\nvoid fuck(string &str) {\n    string up, down;\n    int cnt = 0;\n    for(auto c : str) {\n        if(c != '\\n') {\n            if(cnt & 1) down.push_back(c);\n            else up.push_back(c);\n            ++cnt;\n        }\n    }\n    cout << up << endl;\n    cout << down << endl;\n}\n\nint main(int argc, char **argv) {\n    int n;\n    cin >> n;\n    int cnt = 1;\n    bool toRight = true;\n    while(true) {\n        fuck(str);\n        fflush(stdout);\n        string st;\n        cin >> st;\n        if(st == \"end\") break;\n        if(st == \"F\") {\n            if(cnt == 4) {\n                if(toRight) {\n                    toRight = !toRight;\n                    str.erase(str.size() - 4, 4);\n                    str = \".\\n.\\n\" + str;\n                } else {\n                    toRight = !toRight;\n                    str.erase(0, 4);\n                    str += \".\\n.\\n\";\n                }\n                cnt = 1;\n            } else {\n                if(toRight) {\n                    str.erase(str.size() - 4, 4);\n                    string add;\n                    if(cnt & (1 << 0)) add += '#'; else add += '.'; add += '\\n';\n                    if(cnt & (1 << 1)) add += '#'; else add += '.'; add += '\\n';\n                    str += add;\n                    ++cnt;\n                } else {\n                    str.erase(0, 4);\n                    string add;\n                    if(cnt & (1 << 0)) add += '#'; else add += '.'; add += '\\n';\n                    if(cnt & (1 << 1)) add += '#'; else add += '.'; add += '\\n';\n                    str += add;\n                    ++cnt;\n                }\n            }\n        } else if(st == \"T\") {\n            cnt = 1;\n            if(toRight) str += \".\\n.\\n\";\n            else str = \".\\n.\\n\" + str;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ut i=(a);i<(ut)(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define ALL(c) c.begin(),c.end()\n#define PB push_back\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ut,VI> PQ;\nconst ut INF=1LL<<30;\nconst int SIZE=2001;\nchar x[]{'.','.','#','#'},y[]{'.','#','.','#'};\nint main(){\n\tint N;\n\tcin >> N;\n\tstring s1,s2;\n\tstring ret;\n\tbool last=false;\n\tREP(i,N){\n\t\tif(!last)\n\t\t\tREP(j,4){\n\t\t\t\tcout << s1+x[j] <<endl << s2+y[j] << endl;\n\t\t\t\tcin >> ret;\n\t\t\t\tif(ret==\"End\") return 0;\n\t\t\t\tif(ret==\"T\"){\n\t\t\t\t\ts1+=x[j];\n\t\t\t\t\ts2+=y[j];\n\t\t\t\t\tN--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ret==\"F\" && j==3){\n\t\t\t\t\tlast=true;\n\t\t\t\t}\n\t\t\t}\n\t\telse{\t\t\n\t\t\tREP(j,4){\n\t\t\t\tcout << x[j]+s1 <<endl << y[j]+s2 << endl;\n\t\t\t\tcin >> ret;\n\t\t\t\tif(ret==\"End\") return 0;\n\t\t\t\tif(ret==\"T\"){\n\t\t\t\t\ts1=x[j]+s1;\n\t\t\t\t\ts2=y[j]+s2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tint H,W;\n\tcin >> H >> W;\n\tint sx=INF,sy=INF,ex=-INF,ey=-INF;\n\tREP(i,H){\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j,W){\n\t\t\tif(s[j]=='X'){\n\t\t\t\tsx=min(sx,j);\n\t\t\t\tsy=min(sy,i);\n\t\t\t\tex=min(ex,j);\n\t\t\t\tey=min(ey,j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ey-sy+1)*2+(ex-sx+1)*2 << endl;\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <map>\n#include <string>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nstring s1,s2;\nchar str[5];\n\nbool query(string A,string B)\n{\n\tprintf(\"%s\\n%s\\n\",A.c_str(),B.c_str()); fflush(stdout);\n\tscanf(\"%s\",&str);\n\treturn str[0]=='T'||str[0]=='e';\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tbool up=true;\n\tstring T=\"..##\",S=\"#.#.\";\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(up)\n\t\t{\n\t\t\tbool nxt=false;\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tstring a=s1,b=s2;\n\t\t\t\ta+=T[j],b+=S[j];\n\t\t\t\tif(query(a,b))\n\t\t\t\t{\n\t\t\t\t\ts1=a,s2=b;\n\t\t\t\t\tnxt=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tup=nxt;\n\t\t}\n\t\tif(!up)\n\t\t{\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tstring a=\"\",b=\"\";\n\t\t\t\ta+=T[j],b+=S[j];\n\t\t\t\ta+=s1,b+=s2;\n\t\t\t\tif(query(a,b))\n\t\t\t\t{\n\t\t\t\t\ts1=a,s2=b;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//四則演算 #pragma GCC target(\"avx\")\n//並列計算 #pragma GCC optimize(\"O3\")\n//条件分岐を減らす #pragma GCC optimize(\"unroll-loops\")\n//浮動小数点演算 #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)\n#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)\n#define each(i, a) for(auto &i : a)\n#define SORT(a) sort(a.begin(),a.end())\n#define rSORT(a) sort(a.rbegin(),a.rend())\n#define fSORT(a,f) sort(a.begin(),a.end(),f)\n#define all(a) a.begin(),a.end()\n#define out(y,x) ((y)<0||h<=(y)||(x)<0||w<=(x))\n#define tp(a,i) get<i>(a)\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n#define stop system(\"pause\")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\ntemplate<class T>inline void print(const T& a) { cout << a << \"\\n\"; }\ntemplate<class T, class... Ts>inline void print(const T& a, const Ts&... ts) { cout << a << \" \"; print(ts...); }\ntemplate<class T>inline void print(const vector<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? \"\\n\" : \" \"); }\ntemplate<class T>inline void print(const vector<vector<T>>& v) { for (auto& a : v)print(a); }\ninline string reversed(const string& s) { string t = s; reverse(all(t)); return t; }\n\nint main() {\n    init();\n\n    int w; cin >> w;\n    string u = \"\", d = \"\";\n    string chars = \".#\";\n    bool type = true;//true:右に伸ばす false:左に伸ばす\n    FOR(i, 0, w) {\n        bool decided = false;\n        FOR(j, 0, 2) {\n            FOR(k, 0, 2) {\n                if (type) {\n                    cout << u << chars[j] << \"\\n\";\n                    cout << d << chars[k] << endl;\n                }\n                else {\n                    cout << chars[j] << u << \"\\n\";\n                    cout << chars[k] << d << endl;\n                }\n                char r; cin >> r;\n                if (decided |= r == 'T') {\n                    if (type) {\n                        u += chars[j];\n                        d += chars[k];\n                    }\n                    else {\n                        u = chars[j] + u;\n                        d = chars[k] + d;\n                    }\n                    break;\n                }\n            }\n            if (decided)break;\n        }\n        if (!decided) {\n            type = false;\n            --i;\n        }\n    }\n    cout << u << \"\\n\" << d << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repq(i,a,n) for(int i=a; i<=n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nchar xx[] = {'.', '#', '.', '#'};\nchar yy[] = {'.', '.', '#', '#'};\n\nint main() {\n    int n; cin.ignore();\n    string s1 = \"\", s2 = \"\", q;\n    string t1 = \"\", t2 = \"\";\n    while(1) {\n        rep(i,0,4) {\n            t1 = s1; t2 = s2;\n            t1 += xx[i];\n            t2 += yy[i];\n            printf(\"%s\\n%s\\n\", t1, t2); fflush(stdout);\n            cin >> q;\n            if(q == \"end\") return 0;\n            else if(q == \"T\") {\n                s1 = t1;\n                s2 = t2;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) begin(a),end(a)\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX (int)1e6 + 5\n\nint N;\n\nsigned main() {\n\tcout << setprecision(20) << fixed;\n\tcin >> N;\n\tstring s1_ans, s2_ans;\n\tstring s1, s2;\n\tstring res;\n\tchar a[] = \".#\";\n\tsrand(time(NULL));\n\tint mode = 0;\n\twhile (1) {\n\t\trep(i, 2) rep(j, 2) {\n\t\t\tif (mode == 0) {\n\t\t\t\ts1 = s1_ans + a[i];\n\t\t\t\ts2 = s2_ans + a[j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts1 = a[i] + s1_ans;\n\t\t\t\ts2 = a[j] + s2_ans;\n\t\t\t}\n\t\t\tcout << s1 << endl;\n\t\t\tcout << s2 << endl;\n\t\t\tcin >> res;\n\t\t\tif (res == \"end\") return 0;\n\t\t\tif (res == \"T\") {\n\t\t\t\ts1_ans = s1;\n\t\t\t\ts2_ans = s2;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tmode++;\n\tnext:;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nstring s[2], t[2], b, v[] = { \"..\", \".#\", \"#.\", \"##\" };\nint n;\nint main() {\n\tcin >> n;\n\tbool ok = false;\n\twhile (!ok) {\n\t\tbool found = false;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tt[0] = v[i][0] + s[0]; t[1] = v[i][1] + s[1];\n\t\t\tcout << t[0] << endl << t[1] << endl;\n\t\t\tcin >> b;\n\t\t\tif (b == \"T\" || b == \"end\") {\n\t\t\t\ts[0] = t[0]; s[1] = t[1];\n\t\t\t\tfound = true;\n\t\t\t\tif (b == \"end\") ok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) break;\n\t}\n\twhile (!ok) {\n\t\tbool found = false;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tt[0] = s[0] + v[i][0]; t[1] = s[1] + v[i][1];\n\t\t\tcout << t[0] << endl << t[1] << endl;\n\t\t\tcin >> b;\n\t\t\tif (b == \"T\" || b == \"end\") {\n\t\t\t\ts[0] = t[0]; s[1] = t[1];\n\t\t\t\tfound = true;\n\t\t\t\tif (b == \"end\") ok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\n\nint ask(string a,string b) {\n\tcout<<a<<endl;\n\tcout<<b<<endl;\n\tstring s;\n\tcin>>s;\n\tif(s==\"end\") exit(0);\n\treturn s==\"T\";\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\tcin>>N;\n\t\n\tstring a=\"\";\n\tstring b=\"\";\n\twhile(1) {\n\t\tFOR(i,4) {\n\t\t\ta+=\".#\"[i/2];\n\t\t\tb+=\".#\"[i%2];\n\t\t\tif(ask(a,b)) break;\n\t\t\ta.pop_back();\n\t\t\tb.pop_back();\n\t\t}\n\t}\n\twhile(1) {\n\t\tFOR(i,4) {\n\t\t\ta=\".#\"[i/2] + a;\n\t\t\tb=\".#\"[i/2] + b;\n\t\t\tif(ask(a,b)) break;\n\t\t\ta.erase(a.begin());\n\t\t\tb.erase(b.begin());\n\t\t}\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n    int N;\n    string r,s1=\"\",s2=\"\";\n    cin>>N;\n    int i;\n    for(i=0;i<N;i++){\n        for(int k=0;k<4;k++){\n            cout<<s1<<(k&1?'#':'.')<<endl;\n            cout<<s2<<(k&2?'#':'.')<<endl;\n            cin>>r;\n            if(r==\"end\") return 0;\n            if(r==\"T\"){\n                s1+=(k&1?'#':'.');\n                s2+=(k&2?'#':'.');\n                continue;\n            }else if(k==3){\n                break;\n            }\n        }\n    }\n    for(;i<N;i++){\n        for(int k=0;k<4;k++){\n            cout<<(k&1?'#':'.')<<s1<<endl;\n            cout<<(k&2?'#':'.')<<s2<<endl;\n            cin>>r;\n            if(r==\"end\") return 0;\n            if(r==\"T\"){\n                s1=(k&1?'#':'.')+s1;\n                s2=(k&2?'#':'.')+s2;\n                continue;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  int idx=0;\n  char s[2]={'.','#'};\n  char a[1001],b[1001];\n  while(1){\n    a[idx+1]=b[idx+1]=0;\n    char ans='F';\n    for(int i=0;i<2&&ans=='F';i++)\n      for(int j=0;j<2&&ans=='F';j++){\n\ta[idx]=s[i],b[idx]=s[j];\n\tprintf(\"%s\\n%s\\n\",a,b);fflush(stdout);\n\tif(!(cin>>ans))return 0;\n      }\n    idx++;\n    if(idx==n)break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MEM(a,b) memset((a),(b),sizeof(a))\nconst LL INF = 1e9 + 7;\nconst int N = 1e3 + 10;\nstring x = \"..##\";\nstring y = \".#.#\";\nclass AbstactSolver\n{\npublic:\n\tvirtual void outputGuess() = 0;\n\tvirtual void getResult() = 0;\n\tvirtual void outputFinalResult() = 0;\n\tvoid solve()\n\t{\n\t\tstring s1, s2;\n\t\tcin >> n;\n\t\tint len = 0;\n\t\tint flag = 1;\n\t\tchar c;\n\t\twhile (1)\n\t\t{\n\t\t\tif (s1.length() == n) break;\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tint key = -1;\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tgx = s1 + x[i];\n\t\t\t\t\tgy = s2 + y[i];\n\t\t\t\t\toutputGuess();\n\t\t\t\t\tgetResult();\n\t\t\t\t\tc = response;\n\t\t\t\t\tif (c == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tkey = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (key == -1) flag = 0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1 = gx;\n\t\t\t\t\ts2 = gy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint key = -1;\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tgx = x[i] + s1;\n\t\t\t\t\tgy = y[i] + s2;\n\t\t\t\t\toutputGuess();\n\t\t\t\t\tgetResult();\n\t\t\t\t\tc = response;\n\t\t\t\t\tif (c == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tkey = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (key == -1) break;\n\t\t\t\ts1 = gx;\n\t\t\t\ts2 = gy;\n\t\t\t}\n\t\t}\n\t\t// 这里输出最后认为正确的猜测\n\t\tgx = s1;\n\t\tgy = s2;\n\t\toutputFinalResult();\n\t}\npublic:\n\tstring gx, gy; // \n\tchar response; // 反馈的结果\n\tint n;\n};\n\n// LocalSolve用于解决本地调试的情况\nclass LocalSolver : public AbstactSolver\n{\npublic:\n\tstring cx, cy; // 这里是提供给我们要猜的数字\n\tint guessCount; // 记录猜测次数\n\tLL pre;\npublic:\n\tLocalSolver()\n\t{\n\t\tguessCount = 0;\n\t\t// 这里放入正确的结果，也就是我们要去猜的数\n\t\tcx = \".#.\";\n\t\tcy = \"...\";\n\t}\n\tvoid outputGuess()\n\t{\n\t\t// 这里之前已经把要猜测的东西保存下来了，只记录猜测次数\n\t\tprintf(\"the %d round, you guess the number is: %s %s\\n\", ++guessCount, gx.c_str(), gy.c_str());\n\t}\n\n\n\tvoid getResult()\n\t{\n\t\t// 这里写本地调试器，不要在意细节\n\t\tint k = gx.length();\n\t\tresponse = 'F';\n\t\tfor (int i = 0; i + k <= n; i++)\n\t\t{\n\t\t\tif (gx == cx.substr(i, k) && gy == cy.substr(i, k)) response = 'T';\n\t\t}\n\t\tprintf(\"the %d round, the feedback is:\\n%c\\n\\n\", guessCount, response);\n\t}\n\n\tbool isGuessCorrect()\n\t{\n\t\treturn gx == cx &&\n\t\t\tgy == cy;\n\t}\n\tvoid outputFinalResult()\n\t{\n\n\t\tprintf(\"\\nYou guess the number is: %s %s\\n,\", gx.c_str(), gy.c_str());\n\t\tprintf(\"The correct Number is: %s %s\\n\", cx.c_str(), cy.c_str());\n\t\tprintf(\"your guess is %s\\n\", isGuessCorrect() ? \"TRUE\" : \"FALSE\");\n\t\tprintf(\"total guess count is: %d\\n\", guessCount);\n\t}\n\n};\n\nclass RemoteSolver : public AbstactSolver\n{\npublic:\n\tvoid outputGuess()\n\t{\n\t\tprintf(\"%s\\n%s\\n\", gx.c_str(), gy.c_str());\n\t\tfflush(stdout);\n\t}\n\tvoid getResult()\n\t{\n\t\tscanf(\"%c\", &response);\n\t}\n\tvoid outputFinalResult()\n\t{\n\t\tprintf(\"%s\\n%s\\n\", gx.c_str(), gy.c_str());\n\t\tfflush(stdout);\n\t}\n};\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//#ifdef ONLINE\n\tRemoteSolver solver;\n\t//#else\n\t//\tLocalSolver solver;\n\t//#endif\n\n\tsolver.solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s1 = \"\";\n\tstring s2 = \"\";\n\tstring r = \"\";\n\t\n\twhile(r != \"end\"){\n\t\tif(r == \"F\"){\n\t\t\tif(s1[s1.length() - 1] == '.' && s2[s2.length() - 1] == '.'){\n\t\t\t\ts1[s1.length() - 1] = '#';\n\t\t\t}else if(s1[s1.length() - 1] == '#' && s2[s2.length() - 1] == '.'){\n\t\t\t\ts1[s1.length() - 1] = '.';\n\t\t\t\ts2[s2.length() - 1] = '#';\n\t\t\t}else if(s1[s1.length() - 1] == '.' && s2[s2.length() - 1] == '#'){\n\t\t\t\ts1[s1.length() - 1] = '#';\n\t\t\t}\n\t\t}else{\n\t\t\ts1 += \".\";\n\t\t\ts2 += \".\";\n\t\t}\n\t\t\n\t\tcout << s1 << endl;\n\t\tcout << s2 << endl;\n\t\tfflush(stdout);\n\n\t\tcin >> r;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<char> vec;\ntypedef vector<vec> mat;\nmat A( 2 , vec(0) );\n\nvoid  pr(){\n  for(int i=0;i<(int)A.size();i++){\n    for(int j=0;j<(int)A[i].size();j++){\n      printf(\"%c\",A[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  fflush(stdout);\n}\n\nint N;\n\nbool check(){\n\n  if( (int) A[0].size() > N )return false;\n  \n  char str[100];\n  pr();\n  scanf(\"%s\",str);\n  if(str[0]=='T')return true;\n  else return false;\n}\n\nstring strx=\"..##\";\nstring stry=\".#.#\";\n\n\n\nint main(){\n\n  bool bk=true;\n  \n\n  scanf(\"%d\",&N);\n  while(1){\n    bool flag=false;\n    for(int i=0;i<4;i++){\n      mat tmp=A;\n      if(bk){\n        A[0].push_back( strx[i] );\n        A[1].push_back( stry[i] );\n        if( check() ){\n          flag=true;\n          break;\n        }\n      }else{\n        A[0].insert(A[0].begin(), strx[i] );\n        A[1].insert(A[1].begin(), stry[i] );\n        if( check() ){\n          flag=true;\n          break;\n        }\n      }\n      A=tmp;\n    }\n    if(!flag){\n      if(bk)bk=false;\n      else break;\n    }\n  }\n  pr();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007; // 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\n/*-------------------------------------------------*/\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  // freopen(\"input.txt\", \"r\", stdin);\n\n  vector<pair<char, char> > ku{\n    {'.', '.'}, {'.', '#'}, {'#', '.'}, {'#', '#'}\n  };\n  int n; cin >> n;\n  string s1 = \"\", s2 = \"\";\n  bool nx = false;\n  while (!nx && s1.length() < n) {\n    REP(i, 4) {\n      s1 += ku[i].first;\n      s2 += ku[i].second;\n      cout << s1 << '\\n' << s2 << endl;\n      string r; cin >> r;\n      if (r == \"F\") {\n        s1.pop_back();\n        s2.pop_back();\n      } else if (r == \"T\") {\n        break;\n      } else if (r == \"end\") {\n        return 0;\n      }\n      if (i + 1 == 4) {\n        nx = true;\n        break;\n      }\n    }\n  }\n  while (s1.length() < n) {\n    REP(i, 4) {\n      s1.insert(s1.begin(), ku[i].first);\n      s2.insert(s2.begin(), ku[i].second);\n      cout << s1 << '\\n' << s2 << endl;\n      string r; cin >> r;\n      if (r == \"F\") {\n        s1.erase(s1.begin());\n        s2.erase(s2.begin());\n      } else if (r == \"T\") {\n        break;\n      } else if (r == \"end\") {\n        return 0;\n      }\n      if (i + 1 == 4) break;\n    }\n  }\n  assert(false);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string du[] = {\".\", \".\", \"#\", \"#\"};\nconst string dd[] = {\".\", \"#\", \".\", \"#\"};\n\nchar s[77];\n\nstring ask(string u, string d) {\n  printf(\"%s\\n%s\\n\", u.c_str(), d.c_str());\n  fflush(stdout);\n  scanf(\"%s\", s);\n  return s;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  string u = \"\", d = \"\";\n  int sw = 0;\n  while (true) {\n    int j = 0;\n    for (j = 0; j < 4; ++j) {\n      string r = (sw == 0 ? ask(u + du[j], d + dd[j]) : ask(du[j] + u, dd[j] + d));\n      if (r == \"end\") {\n        return 0;\n      }\n      if (r == \"T\") {\n        break;\n      }\n    }\n    if (j == 5) {\n      sw = 1 - sw;\n      continue;\n    }\n    if (sw == 0) {\n      u += du[j];\n      d += dd[j];\n    } else {\n      u = du[j] + u;\n      d = dd[j] + d;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid MV(char a[1001]){\n  for(int i=200;i>=0;i--)a[i+1]=a[i];\n}\n\nint main(){\n  int n;\n  cin>>n;\n  int idx=0;\n  char s[2]={'.','#'};\n  char a[1001],b[1001];\n  while(1){\n\n    string ans=\"F\";\n    a[idx+1]=b[idx+1]=0;\n    for(int i=0;i<(1<<2)&&ans==\"F\";i++){\n      a[idx]=s[i%2],b[idx]=s[i>>1];\n      printf(\"%s\\n%s\\n\",a,b);fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n    }\n\n    if(ans==\"F\")MV(a),MV(b);\n    a[idx+1]=b[idx+1]=0;\n    for(int i=0;i<(1<<2)&&ans==\"F\";i++){\n      a[0]=s[i%2],b[0]=s[i>>1];\n      printf(\"%s\\n%s\\n\",a,b);fflush(stdout);\n      cin>>ans;\n      if(ans==\"end\")return 0;\n    }\n    idx++;\n    if(idx==n)break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\n \n#define REP(i,n) for(int(i)=0;(i)<(int)(n);(i)++)\n\n#include <vector>\n#include <utility>\n\n\n#include <algorithm>\n\n\nchar reps[] = {'.', '#'};\nchar knowup[320];\nchar knowdown[320];\nchar response[320];\n\nbool query(int u, int d, bool after) {\n\tif (!after) printf(\"%c\", reps[u]);\n\tprintf(\"%s\", knowup);\n\tif (after) printf(\"%c\", reps[u]);\n\tprintf(\"\\n\");\n\n\tif (!after) printf(\"%c\", reps[d]);\n\tprintf(\"%s\", knowdown);\n\tif (after) printf(\"%c\", reps[d]);\n\tprintf(\"\\n\");\n\n\tfflush(stdout);\n\n\tscanf(\"%s\", response);\n\treturn !(response[0] == 'F');\n}\n\nvoid solve() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint total = 0;\n\n\twhile (total != n) {\n\t\tbool found = false;\n\t\tREP(up, 2) {\n\t\t\tREP(down, 2) {\n\t\t\t\tif (query(up, down, true)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\t\n\t\t\t\t\tknowup[total] = reps[up];\n\t\t\t\t\tknowdown[total] = reps[down];\n\t\t\t\t\ttotal++;\n\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t\tout: continue;\n\t}\n\n\twhile (total != n) {\n\t\tbool found = false;\n\t\tREP(up, 2) {\n\t\t\tREP(down, 2) {\n\t\t\t\tif (query(up, down, false)) {\n\t\t\t\t\tfound = true;\n\n\t\t\t\t\tfor (int i = total-1; i >= 0; i--) {\n\t\t\t\t\t\tknowup[i+1] = knowup[i];\n\t\t\t\t\t\tknowdown[i+1] = knowdown[i];\n\t\t\t\t\t}\n\t\t\t\t\tknowup[0] = reps[up];\n\t\t\t\t\tknowdown[0] = reps[down];\n\t\t\t\t\ttotal++;\n\n\t\t\t\t\tgoto out2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout2: continue;\n\t}\n\n\n}\n\n\nint main() {\n    solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stdio.h>\nusing namespace std;\nstring ans[3],tmp[3],r;\nchar atas[4]={'#','.','#','.'},bawah[4] = {'.','.','#','#'};\nint n;\nbool cek;\nint main()\n{\n    scanf(\"%d\",&n);\n    while(1)\n    {\n        for(int i=0;i<4;i++)\n        {\n            if(cek)\n            {\n                tmp[0] = ans[0]+atas[i];\n                tmp[1] = ans[1]+bawah[i];\n            }\n            else\n            {\n                tmp[0] = atas[i]+ans[0];\n                tmp[1] = bawah[i]+ans[1];\n            }\n            for(int i=0;i<2;i++) cout<<tmp[i]<<endl;\n            cin>>r;\n            cout<<\"r : \"<<r<<endl;\n            if(r==\"end\")\n            {\n                break;\n            }\n            if(r==\"T\")\n            {\n                ans[0] = tmp[0];\n                ans[1] = tmp[1];\n                break;\n            }\n            if(i==3)\n            {\n                cek = 1;\n            }\n        }\n        if(r==end) break;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    #include <iomanip>\n    #include <cstdio>\n    #include <string>\n    #include <cstring>\n    #include <deque>\n    #include <list>\n    #include <queue>\n    #include <stack>\n    #include <vector>\n    #include <utility>\n    #include <algorithm>\n    #include <map>\n    #include <set>\n    #include <complex>\n    #include <cmath>\n    #include <limits>\n    #include <climits>\n    #include <ctime>\n    #include <cassert>\n    using namespace std;\n     \n    #define rep(i,a,n) for(int i=a; i<n; i++)\n    #define repq(i,a,n) for(int i=a; i<=n; i++)\n    #define repr(i,a,n) for(int i=a; i>=n; i--)\n    #define pb(a) push_back(a)\n    #define fr first\n    #define sc second\n    #define INF 2000000000\n     \n    #define X real()\n    #define Y imag()\n    #define EPS (1e-10)\n    #define EQ(a,b) (abs((a) - (b)) < EPS)\n    #define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n    #define LE(n, m) ((n) < (m) + EPS)\n    #define LEQ(n, m) ((n) <= (m) + EPS)\n    #define GE(n, m) ((n) + EPS > (m))\n    #define GEQ(n, m) ((n) + EPS >= (m))\n     \n    typedef vector<int> VI;\n    typedef vector<VI> MAT;\n    typedef pair<int, int> pii;\n    typedef long long int ll;\n     \n    typedef complex<double> P;\n    typedef pair<P, P> L;\n    typedef pair<P, double> C;\n     \n    int dy[]={0, 0, 1, -1};\n    int dx[]={1, -1, 0, 0};\n    int const MOD = 1000000007;\n     \n    namespace std {\n        bool operator<(const P& a, const P& b) {\n            return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n        }\n    }\n     \n    char xx[] = {'.', '#', '.', '#'};\n    char yy[] = {'.', '.', '#', '#'};\n     \n    int main() {\n        int n; cin.ignore();\n        string s1 = \"\", s2 = \"\", q;\n        string t1 = \"\", t2 = \"\";\n        bool back = false;\n        while(1) {\n            rep(i,0,4) {\n                t1 = s1; t2 = s2;\n                if(back) {\n                    t1 = xx[i] + t1;\n                    t2 = yy[i] + t2;\n                }\n                else {\n                    t1 += xx[i];\n                    t2 += yy[i];\n                }\n                cout << t1 << endl << t2 << endl; fflush(stdout);\n                cin >> q;\n                if(q == \"end\") return 0;\n                else if(q == \"T\") {\n                    s1 = t1;\n                    s2 = t2;\n                    break;\n                }\n                else if(i == 3) back = true;\n            }\n        }\n        return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "// Kyoto University Programming Contest 2016\n// D - 長い黒板 / Long Blackboard\n\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <set>\n#include <queue>\n#define MAX_N 100\n#define R 2\nusing namespace std;\n\n\nclass Board {\npublic:\n  vector<bool> row[R];\n  int end_base;\n  bool operator<(Board brd);\n  void clear();\n  string to_s() const;\n};\n\nstring Board::to_s() const {\n  string str;\n  for (int j = 0; j < R; j++) {\n    for (int i = 0; i < (int)row[j].size(); i++) {\n      str += row[j][i] ? '#' : '.';\n    }\n    str += '\\n';\n  }\n  return str;\n}\n\nvoid Board::clear() {\n  for (int j = 0; j < R; j++) {\n    row[j].clear();\n  }\n}\n\nbool operator<(Board b1, Board b2) {\n  if (b1.row[0] == b2.row[0]) {\n    return b1.row[1] < b2.row[1];\n  }\n  return b1.row[0] < b2.row[0];\n}\n\nint N;\nbool mat[MAX_N][MAX_N];\nvector<Board> cands_base;\nqueue<Board> pre_q, q;\n\nbool query() {\n  char buff[256];\n  string search_result;\n\n  cands_base.clear();\n  while (!pre_q.empty()) {\n    cands_base.push_back(pre_q.front());\n    pre_q.pop();\n  }\n\n  for (auto itr = cands_base.begin(); itr != cands_base.end(); ) {\n    printf(\"%s\", itr->to_s().c_str()); fflush(stdout);\n    scanf(\"%s\", buff);\n    search_result = string(buff);\n    if (search_result == \"T\") {\n      itr++;\n    } else if (search_result == \"F\") {\n      itr = cands_base.erase(itr);\n    } else {\n      return false;\n    }\n  }\n\n  for (int s = 0; s < (int)cands_base.size(); s++) {\n    cands_base[s].end_base = s;\n    pre_q.push(cands_base[s]);\n    for (int t = 0; t < (int)cands_base.size(); t++) {\n      mat[s][t] = true;\n      for (int j = 0; j < R; j++) {\n        for (int i = 0; i < (int)cands_base[s].row[j].size() - 1; i++) {\n          if (cands_base[s].row[j][i + 1] != cands_base[t].row[j][i]) {\n            mat[s][t] = false;\n          }\n        }\n      }\n    }\n  }\n\n  return true;\n\n}\n\nint main() {\n\n  Board b;\n  int pre_cands_size = 0;\n  int base_len, len;\n  bool query_result;\n\n  scanf(\"%d\", &N);\n  for (int pat = 0; pat < (1 << R); pat++) {\n    b.clear();\n    for (int j = 0; j < R; j++) {\n      b.row[j].push_back((pat & (1 << j)) > 0);\n    }\n    q.push(b);\n  }\n\n  base_len = 0;\n  while (true) {\n    if (pre_cands_size < (int)q.size()) {\n      if (!((int)q.front().row[0].size() > base_len + 1)) {\n        pre_q = q;\n      }\n      query_result = query();\n      base_len = pre_q.front().row[0].size();\n      if (!query_result) {\n        return 0;\n      }\n    } else {\n      pre_q = q;\n    }\n    pre_cands_size = q.size();\n    len = pre_q.front().row[0].size();\n    if (len >= N) {\n      break;\n    }\n\n    while (!q.empty()) {\n      q.pop();\n    }\n    for (int c = 0; c < (int)pre_q.size(); c++) {\n      int s = pre_q.front().end_base;\n      for (int t = 0; t < (int)cands_base.size(); t++) {\n        if (!mat[s][t]) {\n          continue;\n        }\n        b = pre_q.front();\n        for (int j = 0; j < R; j++) {\n          int row_size = cands_base[t].row[j].size();\n          b.row[j].push_back(cands_base[t].row[j][row_size - 1]);\n        }\n        b.end_base = t;\n        q.push(b);\n      }\n      pre_q.push(pre_q.front());\n      pre_q.pop();\n    }\n  }\n\n  query();\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int n;\n  std::cin >> n;\n  string s = \"\", ss = \"\", r;\n  string ds[] = {\".\", \"#\"};\n  bool back = true;\n  for (int i = 0; i < 111; i++) {\n    for (int j = 0; j < 4; j++) {\n      string ts, tss; \n      if(back){\n        ts = s + ds[j/2], tss = ss + ds[j%2];\n      }else{\n        ts = ds[j/2] + s, tss = ds[j%2] + ss;\n      }\n      printf(\"%s\\n%s\\n\", ts, tss); fflush(stdout);\n      std::cin >> r;\n      if(r == \"T\"){\n        s  = ts;\n        ss = tss;\n        break;\n      }else if(r == \"F\" and j == 3){\n        back = false;\n      }else if(r == \"end\"){\n        i = 1e9, j = 1e9;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>//min/max/sort(rand-access it)/merge\n#include <array>\n#include <bitset>\n#include <climits>//INT_MAX/INT_MIN/ULLONG_MAX\n#include <cmath>//fmin/fmax/fabs/sin(h)/cos(h)/tan(h)/exp/log/pow/sqrt/cbrt/ceil/floor/round/trunc\n#include <cstdlib>//abs/atof/atoi/atol/atoll/strtod/strtof/..., srand/rand, calloc/malloc, exit, qsort\n#include <iomanip>//setfill/setw\n#include <iostream>//cin/cout/wcin/wcout/left/right/internal/dec/hex/oct/fixed/scientific\n#include <iterator>\n#include <list>\n#include <queue>\n#include <string>//stoi/stol/stoul/stoll/stoull/stof/stod/stold/to_string/getline\n#include <tuple>\n#include <utility>//pair\n#include <valarray>\n#include <vector>\n\n#define PRIME_SHORT 10007\n#define PRIME 1000000007\n\nusing namespace std;\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> plli;\ntypedef pair<ull, int> puli;\ntypedef pair<double, int> pdi;\ntypedef pair<ll, ll> pllll;\ntypedef pair<ull, ull> pulul;\ntypedef pair<double, double> pdd;\ntypedef tuple<int, int, int> ti3;\ntypedef tuple<int, int, int, int> ti4;\n\nconst bool debug = false;\n\nvoid rar(int n, int* a);\nvoid rar2(int n, int m, int** a);\n\nint ipow(int base, int exp);\nint left(int current, bool swap);\nint right(int current, bool swap);\nint griddist(int x, int y, int s, int t);\nint griddist(pii one, pii two);\ndouble sqeucldist(double x, double y, double s, double t);\ndouble sqeucldist(pii one, pii two);\null modadd(ull a, ull b, int mod);\null modmult(ull a, ull b, int mod);\n\nvoid set(string top, string bot, bool up, bool down)\n{\n    top += up?\".\":\"#\";\n    bot += down?\".\":\"#\";\n}\n\nvoid set_front(string top, string bot, deque<char> ttop, deque<char> bbot, bool up, bool down)\n{\n    ttop.push_front(up?'.':'#');\n    bbot.push_front(down?'.':'#');\n    size_t n = ttop.size();\n    char* ctop = new char[n];\n    char* cbot = new char[n];\n    for (size_t i = 0; i < n; ++i)\n    {\n        ctop[i] = ttop[i];\n        cbot[i] = bbot[i];\n    }\n    top = string(ctop, n);\n    bot = string(cbot, n);\n}\n\nvoid pop(string top, string bot)\n{\n    top.pop_back();\n    bot.pop_back();\n}\n\nvoid pop_front(string top, string bot, deque<char> ttop, deque<char> bbot)\n{\n    ttop.pop_front();\n    bbot.pop_front();\n    size_t n = ttop.size();\n    char* ctop = new char[n];\n    char* cbot = new char[n];\n    for (size_t i = 0; i < n; ++i)\n    {\n        ctop[i] = ttop[i];\n        cbot[i] = bbot[i];\n    }\n    top = string(ctop, n);\n    bot = string(cbot, n);\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n\n    pair< deque<char>, deque<char> > backend;\n\n    //.. .# #. ##\n    bool possible[4] = {true, true, true, true};\n    pair<bool, bool> comb[4];\n    comb[0] = make_pair(true, true);\n    comb[1] = make_pair(true, false);\n    comb[2] = make_pair(false, true);\n    comb[3] = make_pair(false, false);\n\n    string status;\n\n    string top = \"\";\n    string bot = \"\";\n\n    for (int i = 0; i < 4; ++i)\n    {\n        set(top, bot, comb[i].first, comb[i].second);\n        cout << top + \"\\n\" + bot << endl;\n        cin >> status;\n        if (status == \"T\") {\n            pop(top, bot);\n        } else if (status == \"F\") {\n            possible[i] = false;\n            pop(top, bot);\n        } else if (status == \"end\") {\n            return 0;\n        }\n    }\n\n    std::vector<int> good;\n\n    for (int i = 0; i < 4; ++i)\n    {\n        if (possible[i])\n        {\n            good.push_back(i);\n        }\n    }\n\n    int wid = 1;\n    bool btof = false;\n    while (wid <= n) {\n\n        //debug output\n        if (debug)\n        {\n            cout << top << endl;\n            cout << bot << endl;\n        }\n\n        bool found = false;\n        if (!btof)\n        {\n            for (int i = 0; i < good.size(); ++i)\n            {\n                set_front(top, bot, backend.first, backend.second, comb[good[i]].first, comb[good[i]].second);\n                cout << top + \"\\n\" + bot << endl;\n                cin >> status;\n                if (status == \"T\")\n                {\n                    found = true;\n                    break;\n                } else if (status == \"F\") {\n                    pop_front(top, bot, backend.first, backend.second);\n                    continue;\n                } else if (status == \"end\") {\n                    return 0;\n                }\n            }\n            if (!found)\n            {\n                if (debug)\n                {\n                    cout << \"error\" << endl;\n                }\n                return 1;\n            }\n        } else {\n            for (int i = 0; i < good.size(); ++i)\n            {\n                set(top, bot, comb[good[i]].first, comb[good[i]].second);\n                cout << top + \"\\n\" + bot << endl;\n                cin >> status;\n                if (status == \"T\")\n                {\n                    found = true;\n                    break;\n                } else if (status == \"F\") {\n                    pop(top, bot);\n                    continue;\n                } else if (status == \"end\") {\n                    return 0;\n                }\n            }       \n            if (!found)\n            {\n                deque<char> ttop, bbot;\n                for (int i = 0; i < top.size(); ++i)\n                {\n                    ttop.push_back(top[i]);\n                    bbot.push_back(bot[i]);\n                }\n                backend = make_pair(ttop, bbot);\n                btof = true;\n            }     \n        }\n    }\n\n    return 0;\n}\n\nvoid rar(int n, int* a)\n{\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> a[i];\n    }\n    return;\n}\n\nvoid rar2(int n, int m, int** a)\n{\n    for (int i = 0; i < n; ++i)\n    {\n        a[i] = new int[m];\n        for (int j = 0; j < m; ++j)\n        {\n            cin >> a[i][j];\n        }\n    }\n    return;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint ipow(int base, int exp) {\n    int result = 1;\n    while (exp)\n    {\n        if (exp & 1)\n            result *= base;\n        exp >>= 1;\n        base *= base;\n    }\n\n    return result;\n}\nint left(int current, bool swap = false) {\n    if(swap){\n        return right(current, false);\n    } else {\n        return 2*current + 1;\n    }\n}\nint right(int current, bool swap = false) {\n    if(swap){\n        return left(current, false);\n    } else {\n        return 2*(current+1);\n    }\n}\nint griddist(int x, int y, int s, int t) {\n    return abs(x-s) + abs(y-t);\n}\nint griddist(pii one, pii two) {\n    return abs(one.first - two.first) + abs(one.second - two.second);\n}\ndouble sqeucldist(double x, double y, double s, double t) {\n    double a = x-s;\n    double b = y-t;\n    return a*a+b*b;\n}\ndouble sqeucldist(pii one, pii two) {\n    double a = one.first - two.first;\n    double b = one.second - two.second;\n    return a*a+b*b;\n}\n\null modadd(ull a, ull b, int mod) {\n    return (a%mod + b%mod)%mod;\n}\null modmult(ull a, ull b, int mod) {\n    return ((a%mod)*(b%mod))%mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstring f(string s,char c){\n\tstring ret = \"\";\n\tret += c;\n\trep(i,s.size()){\n\t\tret += s[i];\n\t}\n\treturn ret;\n}\nstring b(string s,char c){\n\ts += c;\n\treturn s;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tstring s[2] = { \"\" , \"\" };\n\t\n\tconst char c[4][2] = { {'.','.'},{'.','#'},{'#','.'},{'#','#'} };\n\t\n\tchar R;\n\tbool t = false;\n\twhile(1){\n\t\tif(!t){\n\t\t\trep(i,4){\n\t\t\t\tcout << b(s[0],c[i][0]) << \"\\n\" << b(s[1],c[i][1]) << endl;\n\t\t\t\tcin >> R;\n\t\t\t\tif(R == 'T'){\n\t\t\t\t\ts[0] = b(s[0],c[i][0]);\n\t\t\t\t\ts[1] = b(s[1],c[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i == 3)t = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trep(i,4){\n\t\t\t\tcout << f(s[0],c[i][0]) << \"\\n\" << f(s[1],c[i][1]) << endl;\n\t\t\t\tcin >> R;\n\t\t\t\tif(R == 'T'){\n\t\t\t\t\ts[0] = f(s[0],c[i][0]);\n\t\t\t\t\ts[1] = f(s[1],c[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <math.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nstruct edge {\n\tint to, cost;\n\tedge(int t,int c):to(t),cost(c) {}\n};\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\n//-----------------------------------------------------------------------------\n\nint n;\nstring s[2]={\"..##\",\".#.#\"};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin>>n;\n\tstring t[2];\n\tREP(i,4) {\n\t\tchar res;\n\t\tcout<<s[0][i]<<endl<<s[1][i]<<endl;\n\t\tcin>>res;\n\t\tif(res=='T') {\n\t\t\tt[0]=s[0][i],t[1]=s[1][i];\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (true) {\n\t\tbool flg=false;\n\t\tREP(j,4) {\n\t\t\tREP(i,2) {\n\t\t\t\tcout<<t[i]<<s[i][j]<<endl;\n\t\t\t}\n\t\t\tchar res;\n\t\t\tcin>>res;\n\t\t\tif(res=='T') {\n\t\t\t\tREP(k,2) t[k]+=s[k][j];\n\t\t\t\tflg=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flg||t.size()==n) break;\n\t}\n\twhile (true) {\n\t\tbool flg=false;\n\t\tREP(j,4) {\n\t\t\tREP(i,2) {\n\t\t\t\tcout<<s[i][j]<<t[i]<<endl;\n\t\t\t}\n\t\t\tchar res;\n\t\t\tcin>>res;\n\t\t\tif(res=='T') {\n\t\t\t\tREP(k,2) t[k]=s[k][j]+t[k];\n\t\t\t\tflg=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flg||t.size()==n) break;\n\t}\n\tREP(i,2) cout<<t[i]<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nll MOD = 1e9 + 7;\n\nstring sUp = \"..##\";\nstring sDown = \".#.#\";\n\nstring throwQuery(string query)\n{\n    string bbUp, bbDown;\n    for (int i = 0; i < query.size(); i++)\n    {\n        if (i % 2 == 0) bbUp += query[i];\n        else bbDown += query[i];\n    }\n    cout << bbUp << endl;\n    cout << bbDown << endl;\n    string ret;\n    cin >> ret;\n    return ret;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    int cur = 0;\n    int len = 0;\n    set<string> blackBoardSet = { \"..\",\".#\",\"##\",\"#.\" };\n    auto comp = [](string s, string t) { return s.size() < t.size(); };\n    priority_queue<string, vector<string>, decltype(comp)> q(comp);\n    for (auto& bb : blackBoardSet)\n    {\n        q.push(bb);\n    }\n    while (!q.empty())\n    {\n        auto query = q.top(); q.pop();\n        auto ret = throwQuery(query);\n        if (ret == \"F\")\n        {\n            blackBoardSet.erase(query);\n            continue;\n        }\n        if (ret == \"T\") blackBoardSet.insert(query);\n        if (ret == \"end\") break;\n        for (auto& bb : blackBoardSet)\n        {\n            if (query.size() + bb.size() <= n * 2)\n            {\n                q.push(query + bb);\n                if (bb != query) q.push(bb + query);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ここからテンプレート\n//#define PLASMA_NO_BOOST\n#if 1\n\n#include<iostream>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<type_traits>\n#include<tuple>\n#include<memory>\n#include<iterator>\n#include<string>\n#include<functional>\n#include<list>\n#include<array>\n#include<complex>\n#include<numeric>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<random>\n#include<map>\n#include<chrono>\n#include<stack>\n#include<set>\n\n#ifndef PLASMA_NO_BOOST\n#include<boost/optional.hpp>\n#include<boost/optional/optional_io.hpp>\n#include<boost/variant.hpp>\n#include<boost/range/adaptor/transformed.hpp>\n#include<boost/range/adaptor/indexed.hpp>\n#include<boost/range/adaptor/filtered.hpp>\n#include<boost/range/algorithm.hpp>\n#include<boost/range/irange.hpp>\n#include<boost/multi_array.hpp>\n#include<boost/preprocessor.hpp>\n#endif\n\ntypedef long long int int64;\ntypedef unsigned long long uint64;\ntypedef long double double64;\n\n#ifdef PLASMA_NO_BOOST\nstruct none_t {};\nconstexpr none_t none{};\ntemplate<class T>class optional\n{\n\tunion inside_t\n\t{\n\t\tT value;\n\t\tnone_t ignore;\n\t\tconstexpr inside_t(T const& v) :value(v) {}\n\t\tconstexpr inside_t(T&& v) : value(std::move(v)) {}\n\t\tconstexpr inside_t(none_t) : ignore(none) {}\n\t\tconstexpr inside_t() : ignore(none) {}\n\t\tconstexpr inside_t(inside_t const&) = default;\n\t\tinside_t(inside_t&&) = default;\n\t\tinside_t& operator=(inside_t const&) = default;\n\t\tinside_t& operator=(inside_t&&) = default;\n\t\t~inside_t() = default;\n\t};\n\tinside_t inside;\n\tbool flag;\npublic:\n\tvoid swap(optional&& v)\n\t{\n\t\tstd::swap(this->inside, v.inside);\n\t\tstd::swap(this->flag, v.flag);\n\t}\n\tvoid reset()\n\t{\n\t\tif (flag)\n\t\t{\n\t\t\tinside.value.~T();\n\t\t\tinside.ignore = none;\n\t\t\tflag = false;\n\t\t}\n\t}\n\n\tconstexpr optional(T const& v) :inside(v), flag(true) {}\n\tconstexpr optional(T&& v) : inside(std::move(v)), flag(true) {}\n\tconstexpr optional(none_t) : inside(), flag(false) {}\n\tconstexpr optional() : inside(), flag(false) {}\n\tconstexpr optional(optional const& v) : inside(v.inside), flag(v.flag) {}\n\toptional(optional&& v) : optional()\n\t{\n\t\tswap(std::move(v));\n\t}\n\toptional& operator=(optional const& v)\n\t{\n\t\tthis->inside = v.inside;\n\t\tthis->flag = v.flag;\n\t\treturn *this;\n\t}\n\toptional& operator=(optional&& v)\n\t{\n\t\tswap(std::move(v));\n\t\tv.reset();\n\t\treturn *this;\n\t}\n\toptional& operator=(T const& v)\n\t{\n\t\treset();\n\t\tinside.value = v;\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(T&& v)\n\t{\n\t\treset();\n\t\tinside.value = std::move(v);\n\t\tflag = true;\n\t\treturn *this;\n\t}\n\toptional& operator=(none_t)\n\t{\n\t\treset();\n\t\treturn *this;\n\t}\n\n\tconstexpr operator bool()const\n\t{\n\t\treturn flag;\n\t}\n\tconstexpr T const& operator*()const\n\t{\n\t\treturn flag ? inside.value : throw std::domain_error(\"optional error: dont have value\");\n\t}\n};\ntemplate<class T>constexpr optional<typename std::remove_reference<typename std::remove_const<T>::type>::type>make_optional(T&& v)\n{\n\treturn optional<std::remove_reference_t<std::remove_const_t<T>>>(std::forward<T>(v));\n}\n#else\nusing boost::optional;\nusing boost::none_t;\nusing boost::none;\n#endif\n\n#ifndef PLASMA_NO_BOOST\nnamespace adaptor\n{\n\tusing namespace boost::adaptors;\n}\nnamespace algorithm\n{\n\tusing namespace boost::range;\n\ttemplate<class SinglePassRange, class Pred>bool any_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::any_of(std::begin(range), std::end(range), pred);\n\t}\n\ttemplate<class SinglePassRange, class Pred>bool all_of(SinglePassRange const& range, Pred pred)\n\t{\n\t\treturn std::all_of(std::begin(range), std::end(range), pred);\n\t}\n}\n#endif\nnamespace math\n{\n\ttemplate<class T>constexpr T pow(T p, int n)\n\t{\n\t\treturn n == 0 ? T(1) : n == 1 ? p : n == 2 ? p*p : n % 2 == 0 ? pow(pow(p, n / 2), 2) : pow(pow(p, n / 2), 2)*p;\n\t}\n\n\tint log(long long int p, int n)\n\t{\n\t\tint64 t = n;\n\t\tfor (int i = 0;;++i)\n\t\t{\n\t\t\tif (t > p)\n\t\t\t\treturn i;\n\t\t\tt *= n;\n\t\t}\n\t}\n\n\tconstexpr double pi = 3.141592653589793;\n\n\tnamespace detail\n\t{\n\t\tint gcd(int larger, int less)\n\t\t{\n\t\t\treturn less == 0 ? larger : gcd(less, larger%less);\n\t\t}\n\t}\n\n\tint gcd(int lhs, int rhs)\n\t{\n\t\treturn lhs < rhs ? detail::gcd(rhs, lhs) : detail::gcd(lhs, rhs);\n\t}\n\n\tvoid fourier_transform(\n\t\tstd::vector<std::complex<double>>& vec, std::size_t N)\n\t{\n\t\tstd::vector<std::complex<double>> butterfly;\n\t\tvec.resize(N);\n\t\tbutterfly.resize(N);\n\n\t\tstd::complex<double> half(std::cos(pi), std::sin(pi));\n\t\tfor (uint64 i = 1, k = N / 2;i < N;[&]() {i *= 2;k /= 2;}())//i*k == N/4\n\t\t{\n\t\t\tstd::complex<double> circle(std::cos(pi / i), std::sin(pi / i));\n\t\t\tstd::complex<double> c(1.0, 0);\n\t\t\tfor (auto count = 0ull; count < i;++count)\n\t\t\t{\n\t\t\t\tfor (auto j = 0ull;j < k;++j)\n\t\t\t\t{\n\t\t\t\t\tbutterfly[count*k + j] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c;\n\t\t\t\t\tbutterfly[count*k + j + N / 2] =\n\t\t\t\t\t\tvec[2 * count*k + j] + vec[2 * count*k + j + k] * c*half;\n\t\t\t\t}\n\t\t\t\tc *= circle;\n\t\t\t}\n\t\t\tstd::swap(vec, butterfly);\n\t\t}\n\t}\n\n\tclass polynomial\n\t{\n\t\tstd::vector<std::complex<double>> value;\n\t\tvoid swap(polynomial&& p)\n\t\t{\n\t\t\tstd::swap(value, p.value);\n\t\t}\n\tpublic:\n\t\tpolynomial() :value{ 0.0 } {}\n\t\tpolynomial(polynomial const&) = default;\n\t\tpolynomial(std::vector<std::complex<double>>&& vec) :value(std::move(vec)) {}\n\t\tpolynomial(polynomial&& p) :polynomial()\n\t\t{\n\t\t\tswap(std::move(p));\n\t\t}\n\t\tpolynomial(std::initializer_list<std::complex<double>> lis) :value(lis) {}\n\t\tpolynomial(std::complex<double> c) :polynomial({ c }) {}\n\n\t\tpolynomial& operator=(polynomial const&) = default;\n\t\tpolynomial& operator=(polynomial&& p)\n\t\t{\n\t\t\tvalue = std::vector<std::complex<double>>{ 0.0 };\n\t\t\tswap(std::move(p));\n\t\t\treturn *this;\n\t\t}\n\n\t\t~polynomial() = default;\n\t\tstd::complex<double> operator[](std::size_t deg)const\n\t\t{\n\t\t\treturn deg >= value.size() ? 0.0 : value[deg];\n\t\t}\n\t\tstd::size_t degree()const\n\t\t{\n\t\t\treturn value.size() - 1;\n\t\t}\n\t\tvoid strict_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tif (value[N] != 0.0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\t\tvoid integer_degree_set()\n\t\t{\n\t\t\tstd::size_t N = degree();\n\t\t\tfor (;N > 0;--N)\n\t\t\t{\n\t\t\t\tstd::cout << value[N] << \" \" << (std::norm(value[N]) > (1.0e-20)) << std::endl;\n\t\t\t\tif (std::norm(value[N]) > (1.0e-20))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue.resize(N + 1);\n\t\t}\n\n\t\tfriend polynomial operator*(polynomial const& lhs, polynomial const& rhs)\n\t\t{\n\t\t\tstd::size_t N = 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tN *= 2;\n\t\t\t\tif (N > (lhs.degree() + rhs.degree()))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto lhs_ = lhs.value;\n\t\t\tauto rhs_ = rhs.value;\n\t\t\tfourier_transform(lhs_, N);\n\t\t\tfourier_transform(rhs_, N);\n\t\t\tstd::vector<std::complex<double>> vec;\n\t\t\tvec.reserve(N);\n\t\t\tfor (std::size_t i = 0;i < N;++i)\n\t\t\t{\n\t\t\t\tvec.push_back(lhs_[i] * rhs_[i]);\n\t\t\t}\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = 2 * v.real() - v;\n\t\t\t}\n\t\t\tfourier_transform(vec, N);\n\t\t\tfor (auto& v : vec)\n\t\t\t{\n\t\t\t\tv = (2 * v.real() - v)*(1.0 / N);\n\t\t\t}\n\t\t\tstd::size_t k = N;\n\t\t\tfor (;k > 0;--k)\n\t\t\t{\n\t\t\t\tif (std::norm(vec[k]) > 1.0e-23)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec.resize(k + 1);\n\t\t\treturn polynomial(std::move(vec));\n\t\t}\n\t};\n\n\tint real_integer(std::complex<double> c)\n\t{\n\t\tint v = static_cast<int>(c.real());\n\t\tdouble u = c.real() - v;\n\t\treturn v + static_cast<int>(2 * u);\n\t}\n\n\ttemplate<class T>polynomial make_poly(std::vector<T> const& vec)\n\t{\n\t\tauto range = vec | adaptor::transformed([](T const& v) {return static_cast<std::complex<double>>(v);});\n\t\tstd::vector<std::complex<double>> ret(std::begin(range), std::end(range));\n\t\treturn polynomial(std::move(ret));\n\t}\n\tpolynomial make_poly(std::initializer_list<double>init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\tpolynomial make_poly(std::initializer_list<int> init)\n\t{\n\t\tstd::vector<std::complex<double>> vec;\n\t\tfor (auto v : init)\n\t\t{\n\t\t\tvec.emplace_back(v);\n\t\t}\n\t\treturn polynomial(std::move(vec));\n\t}\n\ttemplate<class T>class infinite_value\n\t{\n\t\toptional<T> val;\n\tpublic:\n\t\tinfinite_value(T const& v) :val(v) {}\n\t\tinfinite_value(T&& v) :val(std::move(v)) {}\n\t\tinfinite_value(none_t = none) :val() {}\n\t\tinfinite_value(infinite_value const&) = default;\n\t\tinfinite_value(infinite_value&&) = default;\n\t\t~infinite_value() = default;\n\n\t\tinfinite_value& operator=(T const& v)\n\t\t{\n\t\t\tval = v;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(T&& v)\n\t\t{\n\t\t\tval = std::move(v);\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(none_t)\n\t\t{\n\t\t\tval = boost::none;\n\t\t\treturn *this;\n\t\t}\n\t\tinfinite_value& operator=(infinite_value const&) = default;\n\t\tinfinite_value& operator=(infinite_value&&) = default;\n\n\t\toperator bool()const\n\t\t{\n\t\t\treturn static_cast<bool>(val);\n\t\t}\n\t\tT const& operator*()const\n\t\t{\n\t\t\treturn *val;\n\t\t}\n\n\t\tfriend infinite_value operator+(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs ? infinite_value<T>(*lhs + rhs) : infinite_value<T>(none);\n\t\t}\n\t\tfriend infinite_value operator+(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn lhs&&rhs ? infinite_value<T>(*lhs + *rhs) : infinite_value<T>(none);\n\t\t}\n\n\t\tfriend bool operator==(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (!lhs && !rhs) || (lhs&&rhs && (*lhs == *rhs));\n\t\t}\n\t\tfriend bool operator==(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn lhs && (*lhs == rhs);\n\t\t}\n\t\tfriend bool operator==(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn rhs && (lhs == *rhs);\n\t\t}\n\n\n\t\tfriend bool operator<(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : !rhs ? true : *lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? false : *lhs < rhs;\n\t\t}\n\t\tfriend bool operator<(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? true : lhs < *rhs;\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator<=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs < rhs) || (lhs == rhs);\n\t\t}\n\n\n\t\tfriend bool operator>(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn  !rhs ? false : !lhs ? true : *lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn !lhs ? true : *lhs > rhs;\n\t\t}\n\t\tfriend bool operator>(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn !rhs ? false : lhs > *rhs;\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(infinite_value const& lhs, T const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\t\tfriend bool operator>=(T const& lhs, infinite_value const& rhs)\n\t\t{\n\t\t\treturn (lhs > rhs) || (lhs == rhs);\n\t\t}\n\n\t};\n\ttemplate<std::size_t Mod>class modulo_number\n\t{\n\t\tuint64 val = {};\n\t\tstatic constexpr uint64 abs(int64 n)\n\t\t{\n\t\t\treturn n <= -1 ? n + Mod : n;\n\t\t}\n\tpublic:\n\t\tmodulo_number(modulo_number const&) = default;\n\t\tmodulo_number(modulo_number&&) = default;\n\t\tmodulo_number& operator=(modulo_number const&) = default;\n\t\tmodulo_number& operator=(modulo_number&&) = default;\n\t\t~modulo_number() = default;\n\n\t\tconstexpr modulo_number(uint64 num = {}) : val(num%Mod) {}\n\t\tconstexpr modulo_number(unsigned int num) : val(num%Mod) {}\n\t\tconstexpr modulo_number(int64 num) : val(abs(num%Mod)) {}\n\t\tconstexpr modulo_number(int num) : val(abs(num%Mod)) {}\n\n\t\tmodulo_number& operator=(uint64 num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int64 num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(unsigned int num)\n\t\t{\n\t\t\tval = num%Mod;\n\t\t\treturn *this;\n\t\t}\n\t\tmodulo_number& operator=(int num)\n\t\t{\n\t\t\tval = abs(num%Mod);\n\t\t\treturn *this;\n\t\t}\n\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn val;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs + modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator+(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) + rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val + Mod - rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs - modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator-(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) - rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>((lhs.val*rhs.val) % Mod);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs * modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator*(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) * rhs;\n\t\t}\n\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn lhs*math::pow(rhs, Mod - 2);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(modulo_number<Mod>const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn lhs / modulo_number<Mod>(rhs);\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(unsigned int const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(int64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\t\tfriend constexpr modulo_number<Mod> operator/(uint64 const& lhs, modulo_number<Mod>const& rhs)\n\t\t{\n\t\t\treturn modulo_number<Mod>(lhs) / rhs;\n\t\t}\n\n\t\ttemplate<class Rhs>decltype(auto) operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>decltype(auto) operator/=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this / rhs;\n\t\t}\n\t};\n\n\ttemplate<class T>constexpr T factorial(std::size_t n, std::size_t goal = 1)\n\t{\n\t\treturn n == goal ? T(n) : n == 0 ? T(1) : factorial<T>(n, (n + goal) / 2 + 1)*factorial<T>((n + goal) / 2, goal);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr uint64 integral_sqrt_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? start :\n\t\t\t\tpow((start + end) / 2 + 1, 2) <= v ?\n\t\t\t\tintegral_sqrt_i(v, (start + end) / 2 + 1, end) :\n\t\t\t\tintegral_sqrt_i(v, start, (start + end) / 2);\n\t\t}\n\t}\n\n\tconstexpr uint64 integral_sqrt(uint64 v)\n\t{\n\t\treturn v == 0 ? 0 :\n\t\t\tv == 1 ? 1 :\n\t\t\tdetail::integral_sqrt_i(v, 1, 0b100000000000000000000000000000000ull);\n\t}\n\n\tnamespace detail\n\t{\n\t\tconstexpr bool is_prime_i(uint64 v, uint64 start, uint64 end)\n\t\t{\n\t\t\treturn start == end ? v%end != 0 :\n\t\t\t\tis_prime_i(v, start, (start + end) / 2) &&\n\t\t\t\tis_prime_i(v, (start + end) / 2 + 1, end);\n\t\t}\n\t}\n\n\tconstexpr bool is_prime(uint64 v)\n\t{\n\t\treturn v == 0 ? false :\n\t\t\tv == 1 ? false :\n\t\t\tv == 2 ? true :\n\t\t\tv == 3 ? true : detail::is_prime_i(v, 2, integral_sqrt(v));\n\t}\n\n\tclass dynamic_modulo\n\t{\n\t\tuint64 value;\n\t\tuint64 mod;\n\t\tstatic constexpr uint64 abs(int64 v, uint64 mod)\n\t\t{\n\t\t\treturn v <= -1 ? v + mod : v;\n\t\t}\n\tpublic:\n\t\tconstexpr dynamic_modulo() :value(), mod(2) {}\n\t\tconstexpr dynamic_modulo(uint64 v, uint64 m) : value(v), mod(m) {}\n\t\tdynamic_modulo(dynamic_modulo const&) = default;\n\t\tdynamic_modulo(dynamic_modulo&&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo const&) = default;\n\t\tdynamic_modulo& operator=(dynamic_modulo&&) = default;\n\t\t~dynamic_modulo() = default;\n\n\t\tconstexpr uint64 get()const\n\t\t{\n\t\t\treturn value;\n\t\t}\n\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value + rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value + rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator+(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value + rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo((lhs.value * rhs.value) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo((lhs.value * rhs) % lhs.mod, lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator*(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value * rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, dynamic_modulo const& rhs)\n\t\t{\n\t\t\treturn lhs.mod != rhs.mod ?\n\t\t\t\tthrow std::logic_error(\"math::dynamic_modulo mod number error\") :\n\t\t\t\tdynamic_modulo(abs((lhs.value - rhs.value) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, uint64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int64 const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, unsigned int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(dynamic_modulo const& lhs, int const& rhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(uint64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int64 const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(unsigned int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\t\tconstexpr friend auto operator-(int const& rhs, dynamic_modulo const& lhs)\n\t\t{\n\t\t\treturn dynamic_modulo(abs((lhs.value - rhs) % lhs.mod, lhs.mod), lhs.mod);\n\t\t}\n\n\t\ttemplate<class Rhs>dynamic_modulo& operator+=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this + rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator-=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this - rhs;\n\t\t}\n\t\ttemplate<class Rhs>dynamic_modulo& operator*=(Rhs const& rhs)\n\t\t{\n\t\t\treturn *this = *this * rhs;\n\t\t}\n\t};\n}\nnamespace geometry\n{\n\ttemplate<class Type>struct point\n\t{\n\t\tType x, y;\n\t};\n\ttemplate<class Type>auto make_point(Type x, Type y)\n\t{\n\t\treturn point<Type>{x, y};\n\t}\n\ttemplate<class Type>auto operator+(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x + rhs.x, lhs.y + rhs.y);\n\t}\n\ttemplate<class Type>auto operator-(point<Type>const& lhs, point<Type>const& rhs)\n\t{\n\t\treturn make_point(lhs.x - rhs.x, lhs.y - rhs.y);\n\t}\n\ttemplate<class Point>struct box\n\t{\n\t\tPoint small, large;\n\t};\n\ttemplate<class Point>auto make_box(Point a, Point b)\n\t{\n\t\treturn box<Point>{\n\t\t\tmake_point(std::min(a.x, b.x), std::min(a.y, b.y)),\n\t\t\t\tmake_point(std::max(a.x, b.x), std::max(a.y, b.y))};\n\t}\n#ifndef  PLASMA_NO_BOOST\n\ttemplate<class Point>boost::optional<box<Point>> hit_check(box<Point> a, box<Point> b)\n\t{\n\t\tif (a.small.x > b.small.x)\n\t\t\tstd::swap(a, b);\n\t\tif (a.large.x < b.small.x)\n\t\t\treturn boost::none;\n\t\tauto small_x = b.small.x;\n\t\tauto large_x = std::min(b.large.x, a.large.x);\n\t\tif (a.small.y < b.small.y)\n\t\t{\n\t\t\tif (b.small.y < a.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, b.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a.small.y < b.large.y)\n\t\t\t\treturn make_box(\n\t\t\t\t\tmake_point(small_x, a.small.y),\n\t\t\t\t\tmake_point(large_x, std::min(a.large.y, b.large.y)));\n\t\t\telse\n\t\t\t\treturn boost::none;\n\t\t}\n\t}\n#endif\n}\nnamespace graph_traits\n{\n\tclass graph\n\t{\n\t\tstd::vector<int64> node_data;\n\t\tstd::vector<std::vector<std::pair<int, int64>>> edge_data;\n\tpublic:\n\t\tgraph() = default;\n\t\tgraph(std::vector<int64>&& n) :node_data(std::move(n)), edge_data{}\n\t\t{\n\t\t\tedge_data.resize(node_data.size());\n\t\t}\n\t\tgraph(std::size_t size) :node_data(size), edge_data{}\n\t\t{\n\n\t\t}\n\n\t\tvoid resize(int size)\n\t\t{\n\t\t\tnode_data.resize(size);\n\t\t\tedge_data.resize(size);\n\t\t}\n\t\tvoid edge_reserve(int size)\n\t\t{\n\t\t\tfor (auto& v : edge_data)\n\t\t\t{\n\t\t\t\tv.reserve(size);\n\t\t\t}\n\t\t}\n\n\t\tvoid add_node(int64 data)\n\t\t{\n\t\t\tnode_data.emplace_back(data);\n\t\t\tedge_data.emplace_back();\n\t\t}\n\t\tvoid add_edge(int from, int to, int64 data)\n\t\t{\n\t\t\tedge_data[from].emplace_back(to, data);\n\t\t}\n\t\tstd::vector<math::infinite_value<int64>> dijkstra(int from)const\n\t\t{\n\t\t\tstruct compare\n\t\t\t{\n\t\t\t\tbool operator()(\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& lhs,\n\t\t\t\t\tstd::pair<int, math::infinite_value<int64>>const& rhs)const\n\t\t\t\t{\n\t\t\t\t\treturn lhs.second > rhs.second;\n\t\t\t\t}\n\t\t\t};\n\t\t\tstd::priority_queue<\n\t\t\t\tstd::pair<int, math::infinite_value<int64>>,\n\t\t\t\tstd::vector<std::pair<int, math::infinite_value<int64>>>,\n\t\t\t\tcompare>nodes;\n\t\t\tstd::vector<math::infinite_value<int64>> ret(node_data.size());\n\t\t\tfor (int i{};i < node_data.size();++i)\n\t\t\t{\n\t\t\t\tnodes.emplace(i, math::infinite_value<int64>());\n\t\t\t}\n\t\t\tnodes.emplace(from, int());\n\n\t\t\twhile (nodes.size())\n\t\t\t{\n\t\t\t\tauto p = nodes.top();\n\t\t\t\tnodes.pop();\n\t\t\t\tif (ret[p.first] <= p.second)\n\t\t\t\t\tcontinue;\n\t\t\t\tret[p.first] = p.second;\n\t\t\t\tfor (auto const& d : edge_data[p.first])\n\t\t\t\t{\n\t\t\t\t\tnodes.emplace(d.first, std::min(ret[d.first], ret[p.first] + d.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint64 operator[](int n)const\n\t\t{\n\t\t\treturn node_data[n];\n\t\t}\n\t};\n}\nnamespace container\n{\n\ttemplate<class T>using p_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n}\n\nvoid Main();\n#endif//テンプレートここまで\n//ここを書き換える\n#define PROBLEM 4\n\n//ここは書き換えない\nint main()\n{\n\tstd::cin.sync_with_stdio(false);\n\tstd::cout << std::setprecision(std::numeric_limits<long double>::digits10 + 1);\n\tMain();\n}\n\n#if BOOST_PP_EQUAL(PROBLEM, 1)\n\nvoid Main()\n{\n\tint N, A, B;\n\tstd::cin >> N >> A >> B;\n\tcontainer::p_queue<int> t;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint x;\n\t\tstd::cin >> x;\n\t\tt.emplace(x);\n\t}\n\tint size{};\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t\telse if (x >= A)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t++size;\n\t}\n\twhile (t.size())\n\t{\n\t\tauto x = t.top();\n\t\tt.pop();\n\t\tif (x >= B)\n\t\t{\n\t\t\tstd::cout << size + t.size() + 1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tstd::cout << size << std::endl;\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 2)\n\nvoid Main()\n{\n\tint N, K;\n\tstd::cin >> N >> K;\n\tstd::array<int, 26>count = {};\n\tfor (int i{};i < N;++i)\n\t{\n\t\tstd::string str;\n\t\tstd::cin >> str;\n\t\t++count[str.front() - 'A'];\n\t}\n\tint loop{};\n\twhile (true)\n\t{\n\t\talgorithm::sort(count, std::greater<>());\n\t\tfor (int i{};i < K;++i)\n\t\t{\n\t\t\tif (count[i])\n\t\t\t{\n\t\t\t\t--count[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstd::cout << loop << std::endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t++loop;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 3)\n\nvoid Main()\n{\n\tstd::vector<std::pair<int,int>> table;\n\tfor (int i{};i < 128;++i)\n\t{\n\t\tint max{};\n\t\tint y{};\n\t\tfor (int j{};j < 128;++j)\n\t\t{\n\t\t\tif (max <= (i^j) + j - i)\n\t\t\t{\n\t\t\t\tmax = (i^j) + j - i;\n\t\t\t\ty = j;\n\t\t\t}\n\t\t}\n\t\ttable.emplace_back(std::make_pair(y, max));\n\t}\n\talgorithm::sort(table, std::greater<>());\n\tint N;\n\tstd::cin >> N;\n\tfor (int i{};i < N;++i)\n\t{\n\t\tint C, D;\n\t\tstd::cin >> C >> D;\n\t\tstd::vector<int> cookie = { D };\n\t\tint now = D;\n\t\tfor (int x = 1;x < C;++x)\n\t\t{\n\t\t\tint target{};\n\t\t\tint max{};\n\t\t\tfor (int index{};index < cookie.size();++index)\n\t\t\t{\n\t\t\t\tif (max < table[cookie[index]].second)\n\t\t\t\t{\n\t\t\t\t\tmax = table[cookie[index]].second;\n\t\t\t\t\ttarget = index;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow += max;\n\t\t\tcookie.emplace_back(table[cookie[target]].first);\n\t\t\tcookie[target] ^= table[cookie[target]].first;\n\t\t}\n\t\tstd::cout << now << std::endl;\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 4)\n\ntypedef std::pair<std::string, std::string> data_t;\ntemplate<class Lhs,class Rhs>auto add(Lhs const& lhs, Rhs const& rhs)\n{\n\treturn std::make_pair(lhs.first + rhs.first, lhs.second + rhs.second);\n}\n\ntemplate<class T>auto size(T const& t)\n{\n\treturn t.first.size();\n}\n\ntemplate<class T>int query(T const& t)\n{\n\tstatic std::string str;\n\tstd::cout << t.first << \"\\n\" << t.second << std::endl;\n\tstd::cin >> str;\n\tif (str == \"T\")\n\t\treturn 1;\n\tif (str == \"F\")\n\t\treturn 0;\n\treturn -1;\n}\n\nvoid Main()\n{\n\tint N;\n\tconst std::pair<char, char> basic[] ={\n\t\tstd::make_pair('.','.'),\n\t\tstd::make_pair('.','#'),\n\t\tstd::make_pair('#','.'),\n\t\tstd::make_pair('#','#')\n\t};\n\tstd::cin >> N;\n\tstd::vector<data_t> data;\n\tfor (auto const& b : basic)\n\t{\n\t\tauto v = add(b, data_t());\n\t\tauto result = query(v);\n\t\tif (result == 1)\n\t\t{\n\t\t\tdata.emplace_back(v);\n\t\t}\n\t\telse if (result == -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\twhile (true)\n\t{\n\t\tfor (int i{};i < data.size();++i)\n\t\t{\n\t\t\tfor (int j{};j < data.size();++j)\n\t\t\t{\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tauto v = add(data[i], data[j]);\n\t\t\t\tauto result = query(v);\n\t\t\t\tif (result == 1)\n\t\t\t\t{\n\t\t\t\t\tstd::swap(data[i], v);\n\t\t\t\t\tdata.erase(data.begin() + j);\n\t\t\t\t\tif (j < i)\n\t\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\telse if (result == -1)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto const& b : basic)\n\t\t\t{\n\t\t\t\tauto v = add(data[i], b);\n\t\t\t\tauto result = query(v);\n\t\t\t\tif (result == 1)\n\t\t\t\t{\n\t\t\t\t\tstd::swap(data[i], v);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (result == -1)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 5)\n\nvoid Main()\n{\n\tint H, W;\n\tstd::cin >> H >> W;\n\tstd::vector<std::string> grid;\n\tstd::string str;\n\tstd::cin >> str;\n\tif (algorithm::count(str, 'X'))\n\t{\n\t\tstd::cout << -1 << std::endl;\n\t\treturn;\n\t}\n\tgrid.emplace_back(std::move(str));\n\tfor (int i = 1;i < H;++i)\n\t{\n\t\tstd::cin >> str;\n\t\tif (str[0] == 'X' || str[W - 1] == 'X')\n\t\t{\n\t\t\tstd::cout << -1 << std::endl;\n\t\t\treturn;\n\t\t}\n\t\tgrid.emplace_back(std::move(str));\n\t}\n\tstd::cin >> str;\n\tif (algorithm::count(str, 'X'))\n\t{\n\t\tstd::cout << -1 << std::endl;\n\t\treturn;\n\t}\n\tgrid.emplace_back(std::move(str));\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 6)\n\ntypedef std::string::iterator iterator;\nenum class func_type\n{\n\tmax, min\n};\n\nstruct tree\n{\n\titerator first, last;\n\tstd::shared_ptr<tree> lhs;\n\tstd::shared_ptr<tree> rhs;\n\tfunc_type func;\n\toptional<int> num;\n};\ntree parse(iterator first, iterator last)\n{\n\tfunc_type f;\n\tif (*first == '^')\n\t{\n\t\tf = func_type::max;\n\t}\n\telse if (*first == '_')\n\t{\n\t\tf = func_type::min;\n\t}\n\n}\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 7)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 8)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 9)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 10)\n\nvoid Main()\n{\n\n}\n\n#elif BOOST_PP_EQUAL(PROBLEM, 11)\n\nvoid Main()\n{\n\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint N;\nconst char x[4][2][2] = {{\".\" , \".\"} , {\".\" , \"#\"} , {\"#\" , \".\"} , {\"#\" , \"#\"}};\nstring s[2];\nchar c[7];\nbool b = 1;\n\nint main(){\n\tscanf(\"%d\" , &N);\n\tfor(int i = 0 ; i < 4 ; ++i){\n\t\tprintf(\"%s\\n%s\\n\" , x[i][0] , x[i][1]);\n\t\tfflush(stdout);\n\t\tscanf(\" %s\" , c);\n\t\tif(c[0] == 'e') return 0;\n\t\tif(c[0] == 'T'){\n\t\t\ts[0] += x[i][0];\n\t\t\ts[1] += x[i][1];\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(1){\n\t\tfor(int j = 0 ; j < 4 ; ++j){\n\t\t\tif(b){\n\t\t\t\tprintf(\"%s%s\\n%s%s\\n\" , s[0].c_str() , x[j][0] , s[1].c_str() , x[j][1]);\n\t\t\t\tfflush(stdout);\n\t\t\t\tscanf(\" %s\" , c);\n\t\t\t\tif(c[0] == 'e') return 0;\n\t\t\t\tif(c[0] == 'T'){\n\t\t\t\t\ts[0] += x[j][0];\n\t\t\t\t\ts[1] += x[j][1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintf(\"%s%s\\n%s%s\\n\" , x[j][0] , s[0].c_str() , x[j][1] , s[1].c_str());\n\t\t\t\tfflush(stdout);\n\t\t\t\tscanf(\" %s\" , c);\n\t\t\t\tif(c[0] == 'e') return 0;\n\t\t\t\tif(c[0] == 'T'){\n\t\t\t\t\ts[0].insert(0 , x[j][0]);\n\t\t\t\t\ts[1].insert(0 , x[j][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j == 3){\n\t\t\t\tb = 0;\n\t\t\t\tj = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  int idx=0;\n  char s[2]={'.','#'},t[2]={'.','#'};\n  char a[1001],b[1001];\n  while(1){\n    a[idx+1]=b[idx+1]=0;\n    for(int i=0;i<(1<<2);i++){\n      a[idx]=s[i%2];\n      b[idx]=s[i>>1];\n      printf(\"%s\\n%s\\n\",a,b);fflush(stdout);\n      char ans;\n      cin>>ans;\n      if(ans=='T')break;\n    }\n    idx++;\n    if(idx==n)break;\n  }\n  /*a[idx]=b[idx]=0;\n    printf(\"%s\\n%s\\n\",a,b);fflush(stdout);*/\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <unordered_set>\nusing namespace std;\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cout<<\" \"<<v[i]; cout<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\nconst int inf = 1000000001;\nconst ll INF = 1e16;\n#define MOD 1000000007\n#define mod 1000000009\n#define pi 3.14159265358979323846\n#define Sp(p) cout<<setprecision(15)<<fixed<<p<<endl;\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n/*\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tvector<string> s(4);\n\ts[0] = \"##\";\n\ts[1] = \"#.\";\n\ts[2] = \".#\";\n\ts[3] = \"..\";\n\tbool right = false;\n\tstring r = \"F\";\n\tint cnt = 0;\n\tstring s1, s2;\n\twhile (r != \"end\") {\n\t\tif (r == \"T\") {\n\t\t\tif (!right) {\n\t\t\t\ts1 += s[cnt][0];\n\t\t\t\ts2 += s[cnt][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts1 = s[cnt][0] + s1;\n\t\t\t\ts2 = s[cnt][1] + s2;\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t}\n\t\telse {\n\t\t\tcnt++;\n\t\t\tif (cnt == 4) {\n\t\t\t\tright = true;\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t\tif (!right) {\n\t\t\tcout << s1 << s[cnt][0] << endl;\n\t\t\tcout << s2 << s[cnt][1] << endl;\n\t\t\tfflush(stdout);\n\t\t}\n\t\telse {\n\t\t\tcout << s[cnt][0] << s1 << endl;\n\t\t\tcout << s[cnt][1] << s2 << endl;\n\t\t\tfflush(stdout);\n\t\t}\n\t\tcin >> r;\n\t\tif (r == \"end\") {\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Haskell",
    "code": "import System.IO\nleft s1 s2 = [(c1:s1,c2:s2)| c1<-\".#\",c2<-\".#\"]\nright s1 s2 = [(s1++[c1],s2++[c2])| c1<-\".#\",c2<-\".#\"]\nouter f s1 s2 = do\n  let inner [] = outer right s1 s2\n      inner ((s1,s2):ss) = do\n        putStrLn s1\n        putStrLn s2\n        hFlush stdout\n        r <- getLine\n        case r of\n          \"end\" -> return ()\n          \"T\" -> outer f s1 s2\n          \"F\" -> inner ss\n  inner $ f s1 s2\nmain = do\n  getLine\n  outer left \"\" \"\""
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n\nimport           Control.Applicative\nimport           Control.Monad\nimport           Control.Monad.Primitive\nimport           Control.Monad.ST\nimport           Control.Monad.State.Strict\nimport           Data.Bool\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\nimport           Data.Char\nimport           Data.Function\nimport qualified Data.IntMap.Strict          as IM\nimport qualified Data.IntSet                 as IS\nimport           Data.List\nimport qualified Data.Map.Strict             as M\nimport           Data.Monoid\nimport           Data.Ord\nimport           Data.Primitive.MutVar\nimport qualified Data.Set                    as S\nimport           Data.Tuple\nimport qualified Data.Vector                 as V\nimport qualified Data.Vector.Generic         as G\nimport qualified Data.Vector.Generic.Mutable as GM\nimport qualified Data.Vector.Unboxed         as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport           Debug.Trace\nimport           Foreign                     hiding (void)\nimport           Unsafe.Coerce\n\nimport           System.IO\n\nmain :: IO ()\nmain = do\n    n <- readLn :: IO Int\n    solve n\n\n(x,y) # (z, w) = (x ++ z, y ++ w)\n\nsolve :: Int -> IO ()\nsolve n = do\n    res0 <- queries [(s1, s2) | s1<-[\"#\", \".\"], s2 <- [\"#\", \".\"]]\n    case res0 of\n        Nothing -> return ()\n        Just cands@(cand:_) -> do\n            let goL q = do\n                res <- queryFirst $ map (#q) cands\n                case res of\n                    Nothing -> return ()\n                    Just Nothing -> undefined\n                    Just (Just l) -> goL l\n            let goR q = do\n                res <- queryFirst $ map (q#) cands\n                case res of\n                    Nothing -> return ()\n                    Just Nothing -> goL q\n                    Just (Just r) -> goR r\n\n            goR cand\n\ntype Request = (String, String)\ntype Response = Maybe Bool\n\nqueryFirst :: [Request] -> IO (Maybe (Maybe Request))\nqueryFirst = go\n  where\n    go (q:qs) = do\n      res <- query q\n      case res of\n          Just True -> return $ Just (Just q)\n          Just False -> go qs\n          Nothing -> return Nothing\n    go [] = return $ Just Nothing\n\nqueries :: [Request] -> IO (Maybe [Request])\nqueries = go []\n  where\n    go acc (q:qs) = do\n      res <- query q\n      case res of\n          Just True -> go (q:acc) qs\n          Just False -> go acc qs\n          Nothing -> return Nothing\n    go acc [] = return $ Just $ reverse acc\n\nquery :: Request -> IO Response\nquery (s1, s2) = do\n    putStrLn s1\n    putStrLn s2\n    hFlush stdout\n    res <- getLine\n    case res of\n        \"T\" -> return $ Just True\n        \"F\" -> return $ Just False\n        \"end\" -> return $ Nothing\n"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# LANGUAGE CPP               #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE TupleSections     #-}\n\nimport           Control.Applicative\nimport           Control.Monad\nimport           Control.Monad.Primitive\nimport           Control.Monad.ST\nimport           Control.Monad.State.Strict\nimport           Data.Bool\nimport qualified Data.ByteString.Char8       as B\nimport qualified Data.ByteString.Unsafe      as B\nimport           Data.Char\nimport           Data.Function\nimport qualified Data.IntMap.Strict          as IM\nimport qualified Data.IntSet                 as IS\nimport           Data.List\nimport qualified Data.Map.Strict             as M\nimport           Data.Monoid\nimport           Data.Ord\nimport           Data.Primitive.MutVar\nimport qualified Data.Set                    as S\nimport           Data.Tuple\nimport qualified Data.Vector                 as V\nimport qualified Data.Vector.Generic         as G\nimport qualified Data.Vector.Generic.Mutable as GM\nimport qualified Data.Vector.Unboxed         as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport           Debug.Trace\nimport           Foreign                     hiding (void)\nimport           Unsafe.Coerce\n\nimport           System.IO\n\nmain :: IO ()\nmain = do\n    n <- readLn :: IO Int\n    solve n\n\nsolve :: Int -> IO ()\nsolve n = go [(s1, s2) | s1<-[\"#\", \".\"], s2 <- [\"#\", \".\"]]\n  where\n    go ss = do\n        ress <- queries ss\n        if elem Nothing ress then return ()\n        else do\n            let ts = map snd . filter fst $ zip [b | Just b<-ress] ss\n            go [(take n $ x1++x2, take n $ y1++y2)|(x1,y1)<-ts,(x2,y2)<-ts]\n\n\n\ntype Request = (String, String)\ntype Response = Maybe Bool\n\nqueries :: [Request] -> IO [Response]\nqueries qs = go qs\n  where\n    go (q:qs) = do\n        res <- query q\n        case res of\n            Just b -> (Just b:) <$> go qs\n            Nothing -> return [Nothing]\n    go [] = return []\n\n\nquery :: Request -> IO Response\nquery (s1, s2) = do\n    putStrLn s1\n    putStrLn s2\n    hFlush stdout\n    res <- getLine\n    case res of\n        \"T\" -> return $ Just True\n        \"F\" -> return $ Just False\n        \"end\" -> return $ Nothing"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int n,i;\n  scanf(\"%d\",&n);\n  char c[2][2]={\"#\",\".\"};\n  char s[2][110]={0};\n  char t[110],w[10];\n  for(i=0;i<4;i++){\n    printf(\"%s%s\\n%s%s\\n\",s[0],c[i/2],s[1],c[i%2]);\n    fflush(stdout);\n    scanf(\"%s\",w);\n    if(w[0]=='e')return 0;\n    if(w[0]=='T'){\n      strcat(s[0],c[i/2]);\n      strcat(s[1],c[i%2]);\n      i=-1;\n    }\n  }\n  for(i=0;i<4;i++){\n    printf(\"%s%s\\n%s%s\\n\",c[i/2],s[0],c[i%2],s[1]);\n    fflush(stdout);\n    scanf(\"%s\",w);\n    if(w[0]=='e')return 0;\n    if(w[0]=='T'){\n      strcpy(t,c[i%2]);\n      strcat(t,s[0]);\n      strcpy(s[0],t);\n      strcpy(t,c[i/2]);\n      strcat(t,s[1]);\n      strcpy(s[1],t);\n      i=-1;\n    }\n  }\n}\n   "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int n,i;\n  scanf(\"%d\",&n);\n  const char c[2][2]={\"#\",\".\"};\n  char s[2][110]={0};\n  char t[110],w[10];\n  for(i=0;i<4;i++){\n    printf(\"%s%s\\n%s%s\\n\",s[0],c[i/2],s[1],c[i%2]);\n    fflush(stdout);\n    scanf(\"%s\",w);\n    if(w[0]=='e')return 0;\n    if(w[0]=='T'){\n      strcat(s[0],c[i/2]);\n      strcat(s[1],c[i%2]);\n      i=-1;\n    }\n  }\n  for(i=0;i<4;i++){\n    printf(\"%s%s\\n%s%s\\n\",c[i/2],s[0],c[i%2],s[1]);\n    fflush(stdout);\n    scanf(\"%s\",w);\n    if(w[0]=='e')return 0;\n    if(w[0]=='T'){\n      strcpy(t,c[i/2]);\n      strcat(t,s[0]);\n      strcpy(s[0],t);\n      strcpy(t,c[i%2]);\n      strcat(t,s[1]);\n      strcpy(s[1],t);\n      i=-1;\n    }\n  }\n}\n   \n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int n,i;\n  scanf(\"%d\",&n);\n  char c[2][2]={\"#\",\".\"};\n  char s[2][110]={0};\n  char t[110],w[10];\n  while(1){\n    for(i=0;i<4;i++){\n      printf(\"%s%s\\n%s%s\\n\",s[0],c[i/2],s[1],c[i%2]);\n      fflush(stdout);\n      scanf(\"%s\",w);\n      if(w[0]=='e')return 0;\n      if(w[0]=='T'){\n\tstrcat(s[0],c[i/2]);\n\tstrcat(s[1],c[i%2]);\n\ti=-1;\n      }\n    }\n    for(i=0;i<4;i++){\n      printf(\"%s%s\\n%s%s\\n\",c[i/2],s[0],c[i%2],s[1]);\n      fflush(stdout);\n      scanf(\"%s\",w);\n      if(w[0]=='e')return 0;\n      if(w[0]=='T'){\n\tstrcpy(t,c[i%2]);\n\tstrcat(t,s[0]);\n\tstrcpy(s[0],t);\n\tstrcpy(t,c[i/2]);\n\tstrcat(t,s[1]);\n\tstrcpy(s[1],t);\n\ti=-1;\n      }\n    }\n  }\n}\n   \n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\nchar s1[N_MAX], s2[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tull beg = 500, len = 0;\n\twhile (len < n) {\n\t\ts1[beg + len] = '.';\n\t\ts2[beg + len] = '.';\n\t\tputs(s1 + beg);\n\t\tputs(s2 + beg);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", s);\n\t\tif (s[0] != 'F') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ts1[beg + len] = '.';\n\t\ts2[beg + len] = '#';\n\t\tputs(s1 + beg);\n\t\tputs(s2 + beg);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", s);\n\t\tif (s[0] != 'F') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ts1[beg + len] = '#';\n\t\ts2[beg + len] = '.';\n\t\tputs(s1 + beg);\n\t\tputs(s2 + beg);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", s);\n\t\tif (s[0] != 'F') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ts1[beg + len] = '#';\n\t\ts2[beg + len] = '#';\n\t\tputs(s1 + beg);\n\t\tputs(s2 + beg);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", s);\n\t\tif (s[0] != 'F') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ts1[beg + len] = '\\0';\n\t\ts2[beg + len] = '\\0';\n\t\tbreak;\n\t}\n\n\twhile (len < n) {\n\t\tbeg--;\n\n\t\ts1[beg] = '.';\n\t\ts2[beg] = '.';\n\t\tputs(s1 + beg);\n\t\tputs(s2 + beg);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", s);\n\t\tif (s[0] != 'F') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ts1[beg] = '.';\n\t\ts2[beg] = '#';\n\t\tputs(s1 + beg);\n\t\tputs(s2 + beg);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", s);\n\t\tif (s[0] != 'F') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ts1[beg] = '#';\n\t\ts2[beg] = '.';\n\t\tputs(s1 + beg);\n\t\tputs(s2 + beg);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", s);\n\t\tif (s[0] != 'F') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ts1[beg] = '#';\n\t\ts2[beg] = '#';\n\t\tputs(s1 + beg);\n\t\tputs(s2 + beg);\n\t\tfflush(stdout);\n\t\tscanf(\"%s\", s);\n\t\tif (s[0] != 'F') {\n\t\t\tlen++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint N = io.nextInt();\n\n\t\t\tchar[] cs1 = new char[N * 4];\n\t\t\tchar[] cs2 = new char[N * 4];\n\t\t\tint l = 2 * N, r = l;\n\t\t\twhile(true) {\n\t\t\t\tboolean find = false;\n\t\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\t\tcs1[r] = \"#.\".charAt(j>>1);\n\t\t\t\t\tcs2[r] = \"#.\".charAt(j&1);\n\t\t\t\t\tio.out.println(new String(cs1, l, r - l + 1));\n\t\t\t\t\tio.out.println(new String(cs2, l, r - l + 1));\n\t\t\t\t\tio.out.flush();\n\t\t\t\t\tchar[] res = io.next();\n\t\t\t\t\tif(res[0] == 'e') return;\n\t\t\t\t\tif(res[0] == 'T') {\n\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\tr++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!find) break;\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tboolean find = false;\n\t\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\t\tcs1[l-1] = \"#.\".charAt(j>>1);\n\t\t\t\t\tcs2[l-1] = \"#.\".charAt(j&1);\n\t\t\t\t\tio.out.println(new String(cs1, l-1, r - l + 1));\n\t\t\t\t\tio.out.println(new String(cs2, l-1, r - l + 1));\n\t\t\t\t\tio.out.flush();\n\t\t\t\t\tchar[] res = io.next();\n\t\t\t\t\tif(res[0] == 'e') return;\n\t\t\t\t\tif(res[0] == 'T') {\n\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\tl--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!find) break;\n\t\t\t}\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile (N-- > 0) {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tString t1 = s1;\n\t\t\t\tString t2 = s2;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tt1 += \".\";\n\t\t\t\t\tt2 += \".\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tt1 += \".\";\n\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\tt2 += \".\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tout.println(t1);\n\t\t\t\tout.println(t2);\n\t\t\t\tout.flush();\n\n\t\t\t\tString res = sc.next();\n\t\t\t\tif (res.equals(\"T\")) {\n\t\t\t\t\ts1 = t1;\n\t\t\t\t\ts2 = t2;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (res.equals(\"F\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner in;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic String F = \".#\";\n\t\n\tstatic boolean trial(int l, int r, int t, char[][] map)\n\t{\n\t\tfor(int i = 0;i < 2;i++){\n\t\t\tfor(int j = 0;j < 2;j++){\n\t\t\t\tmap[0][t] = F.charAt(i);\n\t\t\t\tmap[1][t] = F.charAt(j);\n\t\t\t\tfor(int k = l;k < r;k++){\n\t\t\t\t\tout.print(map[0][k]);\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t\tfor(int k = l;k < r;k++){\n\t\t\t\t\tout.print(map[1][k]);\n\t\t\t\t}\n\t\t\t\tout.println();\n\t\t\t\tout.flush();\n\t\t\t\tchar res = in.next().charAt(0);\n\t\t\t\tif(res == 'T'){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tchar[][] map =  new char[2][400];\n\t\tint l = 200, r = 201;\n\t\ttrial(l, r, l, map);\n\t\twhile(true){\n\t\t\tif(!trial(l, r+1, r, map))break;\n\t\t\tr++;\n\t\t}\n\t\twhile(true){\n\t\t\tif(!trial(l-1, r, l-1, map))break;\n\t\t\tl--;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tin = INPUT.isEmpty() ? new Scanner(System.in) : new Scanner(INPUT);\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t}\n\t\n\tstatic int ni() { return Integer.parseInt(in.next()); }\n\tstatic long nl() { return Long.parseLong(in.next()); }\n\tstatic double nd() { return Double.parseDouble(in.next()); }\n\tstatic void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\"\\t\");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tList<Integer>[]randomTree(int n,Random r){List<Integer>[]g=graph(n);\n\tfor(int i=1;i<n;i++){int p=r.nextInt(i);g[p].add(i);g[i].add(p);}return g;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tboolean toR = true;\n\t\tString r1 = \"\";\n\t\tString r2 = \"\";\n\t\twhile(true){\n\t\t\tString n1 = \".\";\n\t\t\tString n2 = \".\";\n\t\t\tboolean ok = false;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tif((i&1)==1) n1 = \"#\";\n\t\t\t\tif((i&2)==2) n2 = \"#\";\n\t\t\t\tif(toR){\n\t\t\t\t\tSystem.out.println(r1 = s1+n1);\n\t\t\t\t\tSystem.out.println(r2 = s2+n2);\n\t\t\t\t\tSystem.out.flush();\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(r1 = n1+s1);\n\t\t\t\t\tSystem.out.println(r2 = n2+s2);\n\t\t\t\t\tSystem.out.flush();\n\t\t\t\t}\n\t\t\t\tString res = in.nextToken();\n\t\t\t\tif(res.equals(\"T\")){\n\t\t\t\t\ts1 = r1;\n\t\t\t\t\ts2 = r2;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(res.equals(\"end\")){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok){\n\t\t\t\ttoR = !toR;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n \nimport java.util.*;\npublic class Main {\n\t\n\tint N,cnt,direct;\n\tString s1,s2;\n\tString[][] append = new String[][]{{\".\",\".\"},{\".\",\"#\"},{\"#\",\".\"},{\"#\",\"#\"}};\n\tHashSet<String> set;\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\ts1 = \".\";\n\t\ts2 = \".\";\n\t\tset = new HashSet<String>();\n\t\twhile(true){\n\t\t\tout.println(s1+\"\\n\"+s2);\n\t\t\tout.flush();\n\t\t\tString res = next();\n\t\t\t\n\t\t\tif(res.equals(\"end\"))break;\n\t\t\t\n\t\t\tif(res.equals(\"T\")){\n\t\t\t\tcnt = 0;\n\t\t\t\tif(direct == 0){\n\t\t\t\t\ts1 = s1 + append[cnt][0];\n\t\t\t\t\ts2 = s2 + append[cnt][1];\n\t\t\t\t}else{\n\t\t\t\t\ts1 = append[cnt][0] + s1;\n\t\t\t\t\ts2 = append[cnt][1] + s2;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\n\t\t\t\tset.add(s1 + \"\\n\" + s2);\n\t\t\t\tboolean flag = false;\n\t\t\t\twhile(true){\n\t\t\t\t\tflag = false;\n\t\t\t\t\t\n\t\t\t\t\tif(cnt == 4){\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\tdirect = direct == 0 ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(direct == 0){\n\t\t\t\t\t\tString ss1 = s1.substring(0,s1.length() - 1);\n\t\t\t\t\t\tString ss2 = s2.substring(0,s2.length() - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\ts1 = ss1 + append[cnt][0];\n\t\t\t\t\t\ts2 = ss2 + append[cnt][1];\n\t\t\t\t\t\t//out.println(\"degug \" + s1 + \" \"+  s2 );\n\t\t\t\t\t\tfor(int j = 0;j < s1.length();j++){\n\t\t\t\t\t\t\tString sss1 = s1.substring(j);\n\t\t\t\t\t\t\tString sss2 = s2.substring(j);\n\t\t\t\t\t\t\t//out.println(\"debug2 \" + sss1 + \" \" + sss2);\n\t\t\t\t\t\t\tif(set.contains(sss1 + \"\\n\" + sss2)){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!flag)break;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tString ss1 = s1.substring(1);\n\t\t\t\t\t\tString ss2 = s2.substring(1);\n\t\t\t\t\t\t\n\t\t\t\t\t\ts1 = append[cnt][0] + ss1;\n\t\t\t\t\t\ts2 = append[cnt][1] + ss2;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j =01;j < s1.length();j++){\n\t\t\t\t\t\t\tString sss1 = s1.substring(j);\n\t\t\t\t\t\t\tString sss2 = s2.substring(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(set.contains(sss1 + \"\\n\" + sss2)){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!flag)break;\n\t\t\t\t\t}\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n \n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n \n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n \n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n \n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n \n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n \n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n \n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n \n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n \n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\nclass Main {\n    static MyScanner sc;\n    static String[] app(String[]q,int v,boolean right){\n        char c1=v/2==1?'#':'.';\n        char c2=v%2==1?'#':'.';\n        return new String[]{q[0]+c1,q[1]+c2};\n    }\n    static boolean ask(String[]p){\n        System.out.println(p[0]);\n        System.out.println(p[1]);\n        String res=sc.next();\n        return res.equals(\"T\");\n    }\n    public static void main(String[] args) {\n        sc = new MyScanner();\n        int n=sc.nextInt();\n        int len=0;\n        String[] q=new String[]{\"\",\"\"};\n        while(len<n){\n            boolean ok=false;\n            for(int i=0;i<4;++i){\n                String[]nn=app(q,i,false);\n                if(ask(nn)){\n                    q=nn;\n                    ok=true;\n                    break;\n                }\n            }\n            if(!ok)break;\n            len++;\n        }\n        while(len<n){\n            boolean ok=false;\n            for(int i=0;i<4;++i){\n                String[]nn=app(q,i,true);\n                if(ask(nn)){\n                    q=nn;\n                    ok=true;\n                    break;\n                }\n            }\n            if(!ok)break;\n            len++;\n        }\n        if(len<n)throw new Error();\n    }\n    // http://codeforces.com/blog/entry/7018\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int[] nextIntArray(int n){\n            int[]r=new int[n];\n            for(int i=0;i<n;++i)r[i]=nextInt();\n            return r;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[] cs = { '.', '#' };\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tString upper = \"\";\n\t\tString lower = \"\";\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (queryAppend(upper, lower, i)) {\n\t\t\t\tupper += cs[i >> 1];\n\t\t\t\tlower += cs[i & 1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (queryAppend(upper, lower, i)) {\n\t\t\t\t\tupper += cs[i >> 1];\n\t\t\t\t\tlower += cs[i & 1];\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) break;\n\t\t}\n\t\twhile (true) {\n\t\t\tboolean ok = false;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (queryPretend(upper, lower, i)) {\n\t\t\t\t\tupper = cs[i >> 1] + upper;\n\t\t\t\t\tlower = cs[i & 1] + lower;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) break;\n\t\t}\n\t}\n\n\tstatic boolean queryAppend(String u, String l, int idx) {\n\t\treturn query(u + cs[idx >> 1], l + cs[idx & 1]);\n\t}\n\n\tstatic boolean queryPretend(String u, String l, int idx) {\n\t\treturn query(cs[idx >> 1] + u, cs[idx & 1] + l);\n\t}\n\n\tstatic boolean query(String u, String l) {\n\t\tSystem.out.println(u);\n\t\tSystem.out.println(l);\n\t\tSystem.out.flush();\n\t\tString res = sc.next();\n\t\tif (res.equals(\"end\")) System.exit(0);\n\t\treturn res.equals(\"T\");\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n\n    StringBuilder builder1 = new StringBuilder();\n    StringBuilder builder2 = new StringBuilder();\n    char[] up = new char[]{'.', '.', '#', '#'};\n    char[] dw = new char[]{'.', '#', '.', '#'};\n    void solve(FastScanner in) throws Exception {\n      int N = in.nextInt();\n      while (true) {\n        boolean tail = false;\n        for (int i = 0; i < 4; i++) {\n          addRight(i);\n          print();\n          String response = in.next();\n          if (response.equals(\"T\")) break;\n          if (response.equals(\"end\")) return;\n          removeRight();\n          if (i == 3) tail = true;\n        }\n        if (tail) break;\n      }\n      while (true) {\n        for (int i = 0; i < 4; i++) {\n          addLeft(i);\n          print();\n          String response = in.next();\n          if (response.equals(\"T\")) break;\n          if (response.equals(\"end\")) return;\n          removeLeft();\n        }\n      }\n    }\n\n    void print() {\n      System.out.println(builder1.toString());\n      System.out.println(builder2.toString());\n    }\n\n    void addRight(int i) {\n      builder1.append(up[i]);\n      builder2.append(dw[i]);\n    }\n\n    void addLeft(int i) {\n      builder1.insert(0, up[i]);\n      builder2.insert(0, dw[i]);\n    }\n\n    void removeLeft() {\n      builder1.deleteCharAt(0);\n      builder2.deleteCharAt(0);\n    }\n\n    void removeRight() {\n      builder1.deleteCharAt(builder1.length() - 1);\n      builder2.deleteCharAt(builder2.length() - 1);\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    FastScanner in = new FastScanner();\n    Task solver = new Task();\n    solver.solve(in);\n  }\n\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n \nimport java.util.*;\npublic class Main {\n\t\n\tint N,cnt,direct;\n\tString s1,s2;\n\tString[][] append = new String[][]{{\".\",\".\"},{\".\",\"#\"},{\"#\",\".\"},{\"#\",\"#\"}};\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\ts1 = \".\";\n\t\ts2 = \".\";\n\t\twhile(true){\n\t\t\tout.println(s1+\"\\n\"+s2);\n\t\t\tout.flush();\n\t\t\tString res = next();\n\t\t\t\n\t\t\tif(res.equals(\"end\"))break;\n\t\t\t\n\t\t\tif(res.equals(\"T\")){\n\t\t\t\tcnt = 0;\n\t\t\t\tif(direct == 0){\n\t\t\t\t\ts1 = s1 + append[cnt][0];\n\t\t\t\t\ts2 = s2 + append[cnt][1];\n\t\t\t\t}else{\n\t\t\t\t\ts1 = append[cnt][0] + s1;\n\t\t\t\t\ts2 = append[cnt][1] + s2;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\t\n\t\t\t\tif(cnt >= 4){\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tdirect = direct == 0 ? 1 : 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(direct == 0){\n\t\t\t\t\tString ss1 = s1.substring(0,s1.length() - 1);\n\t\t\t\t\tString ss2 = s2.substring(0,s2.length() - 1);\n\t\t\t\t\t\n\t\t\t\t\ts1 = ss1 + append[cnt][0];\n\t\t\t\t\ts2 = ss2 + append[cnt][1];\n\t\t\t\t}else{\n\t\t\t\t\tString ss1 = s1.substring(1);\n\t\t\t\t\tString ss2 = s2.substring(1);\n\t\t\t\t\t\n\t\t\t\t\ts1 = append[cnt][0] + ss1;\n\t\t\t\t\ts2 = append[cnt][1] + ss2;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n \n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n \n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n \n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n \n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n \n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n \n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n \n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n \n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n \n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n \n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    \n    char[][] now = new char[2][0];\n\n    boolean flg = false;\n    while (true) {\n      boolean updated = false;\n      for (int i = 0; i < 4; i ++) {\n        char[][] next = flg ? catl(now, i) : catr(now, i);\n        if (query(next)) {\n          if (next[0].length == n) {\n            return;\n          }\n          updated = true;\n          now = next;\n          break;\n        }\n      }\n      if (!updated) flg = true;\n    }\n  }\n\n  private static char[][] catl(char[][] src, int v) {\n    int n = src[0].length;\n    char[][] ret = new char[2][n + 1];\n    for (int i = 0; i < 2; i ++) {\n      System.arraycopy(src[i], 0, ret[i], 1, n);\n    }\n    char[] now = dec(v);\n    ret[0][0] = now[0];\n    ret[1][0] = now[1];\n    return ret;\n  }\n\n  private static char[][] catr(char[][] src, int v) {\n    int n = src[0].length;\n    char[][] ret = new char[2][n + 1];\n    for (int i = 0; i < 2; i ++) {\n      System.arraycopy(src[i], 0, ret[i], 0, n);\n    }\n    char[] now = dec(v);\n    ret[0][n] = now[0];\n    ret[1][n] = now[1];\n    return ret;\n  }\n\n  private static char[] dec(int v) {\n    char[] ret = new char[2];\n    for (int i = 0; i < 2; i ++) {\n      ret[i] = ((v >> i) & 1) != 1 ? '#' : '.';\n    }\n    return ret;\n  }\n\n  private static boolean query(char[][] q) {\n    for (char[] s : q) {\n      out.println(s);\n    }\n    out.flush();\n    \n    String ret = next();\n    return ret.equals(\"T\") || ret.equals(\"end\");\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tni();\n    \tStringBuffer q1 = new StringBuffer(\"\");\n    \tStringBuffer q2 = new StringBuffer(\"\");\n\n    \tint state = 0;\n\n    \tfor (int i=0; i<420; i++) {\n    \t\tint x = state / 2;\n    \t\tint y = state % 2;\n\n    \t\tout.println(q1 + (x == 0 ? \".\" : \"#\"));\n    \t\tout.println(q2 + (y == 0 ? \".\" : \"#\"));\n    \t\tout.flush();\n\n    \t\tString s = ns();\n\n    \t\tif (s.equals(\"end\")) {\n    \t\t\treturn;\n    \t\t} else if (s.equals(\"T\")) {\n    \t\t\tq1.append(x == 0 ? \".\" : \"#\");\n    \t\t\tq2.append(y == 0 ? \".\" : \"#\");\n    \t\t\tstate = 0;\n    \t\t} else {\n    \t\t\tstate++;\n    \t\t}\n    \t}\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Random;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\"\\t\");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tList<Integer>[]randomTree(int n,Random r){List<Integer>[]g=graph(n);\n\tfor(int i=1;i<n;i++){int p=r.nextInt(i);g[p].add(i);g[i].add(p);}return g;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tboolean toR = true;\n\t\tString r1 = \"\";\n\t\tString r2 = \"\";\n\t\twhile(true){\n\t\t\tString n1 = \".\";\n\t\t\tString n2 = \".\";\n\t\t\tboolean ok = false;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tif((i&1)==1) n1 = \"#\";\n\t\t\t\telse n1 = \".\";\n\t\t\t\tif((i&2)==2) n2 = \"#\";\n\t\t\t\telse n2 = \".\";\n\t\t\t\tif(toR){\n\t\t\t\t\tSystem.out.println(r1 = s1+n1);\n\t\t\t\t\tSystem.out.println(r2 = s2+n2);\n\t\t\t\t\tSystem.out.flush();\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(r1 = n1+s1);\n\t\t\t\t\tSystem.out.println(r2 = n2+s2);\n\t\t\t\t\tSystem.out.flush();\n\t\t\t\t}\n\t\t\t\tString res = in.nextToken();\n\t\t\t\tif(res.equals(\"T\")){\n\t\t\t\t\ts1 = r1;\n\t\t\t\t\ts2 = r2;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(res.equals(\"end\")){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok){\n\t\t\t\ttoR = !toR;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static long N, A;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextLong();\n\n        solve((values) -> {\n            StringBuilder s1 = new StringBuilder();\n            StringBuilder s2 = new StringBuilder();\n            for (Integer i : values) {\n                if( (i & 1) == 1 ) {\n                    s1.append(\"#\");\n                } else {\n                    s1.append(\".\");\n                }\n\n                if( (i & 2) == 2 ) {\n                    s2.append(\"#\");\n                } else {\n                    s2.append(\".\");\n                }\n            }\n            System.out.println(s1);\n            System.out.println(s2);\n            System.out.flush();\n\n            switch (sc.next()) {\n                case \"T\":\n                    return 1;\n                case \"F\":\n                    return 0;\n                default:\n                    return -1;\n            }\n        });\n    }\n\n    interface Query {\n        int send(ArrayDeque<Integer> values);\n    }\n\n    static void solve(Query q) {\n        ArrayDeque<Integer> current = new ArrayDeque<>();\n        boolean left = true;\n\n        lo:\n        while(true) {\n            for (int j = 0; j < 4; j++) {\n                ArrayDeque<Integer> next = new ArrayDeque<>(current);\n                if( left ) {\n                    next.addFirst(j);\n                } else {\n                    next.addLast(j);\n                }\n                int result = q.send(next);\n                if( result == -1 ) return;\n\n                if( result == 1 ) {\n                    current = next;\n                    continue lo;\n                }\n            }\n            if( left ) {\n                left = false;\n            } else {\n                throw new IllegalArgumentException(\"wtf\");\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\nclass Main {\n    static MyScanner sc;\n    static String[] app(String[]q,int v,boolean right){\n        char c1=v/2==1?'#':'.';\n        char c2=v%2==1?'#':'.';\n        return new String[]{right?q[0]+c1:c1+q[0],right?q[1]+c2:c2+q[1]};\n    }\n    static boolean ask(String[]p){\n        System.out.println(p[0]);\n        System.out.println(p[1]);\n        String res=sc.next();\n        return res.equals(\"T\");\n    }\n    public static void main(String[] args) {\n        sc = new MyScanner();\n        int n=sc.nextInt();\n        int len=0;\n        String[] q=new String[]{\"\",\"\"};\n        while(len<n){\n            boolean ok=false;\n            for(int i=0;i<4;++i){\n                String[]nn=app(q,i,false);\n                if(ask(nn)){\n                    q=nn;\n                    ok=true;\n                    break;\n                }\n            }\n            if(!ok)break;\n            len++;\n        }\n        while(len<n){\n            boolean ok=false;\n            for(int i=0;i<4;++i){\n                String[]nn=app(q,i,true);\n                if(ask(nn)){\n                    q=nn;\n                    ok=true;\n                    break;\n                }\n            }\n            if(!ok)break;\n            len++;\n        }\n        if(len<n)throw new Error();\n    }\n    // http://codeforces.com/blog/entry/7018\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int[] nextIntArray(int n){\n            int[]r=new int[n];\n            for(int i=0;i<n;++i)r[i]=nextInt();\n            return r;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic static String toUpper(int i){\n\t\tswitch(i){\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\treturn \".\";\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\treturn \"#\";\n\t\t\tdefault:\n\t\t\t    return \"?\";\n\t\t}\n\t}//0,1->\".\" 2,3->\"#\"\n\tpublic static String toLower(int i){\n\t\tswitch(i){\n\t\t\tcase 0:\n\t\t\tcase 2:\n\t\t\t\treturn \".\";\n\t\t\tcase 1:\n\t\t\tcase 3:\n\t\t\t\treturn \"#\";\n\t\t\tdefault:\n\t\t\t    return \"?\";\n\t\t}\n\t}//0,2->\".\" 1,3->\"#\"\n\t\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        String upper = \"\",\n               lower = \"\";\n        boolean end = false;\n        int next = 0;\n        while(!end && next<4){\n        \tSystem.out.println(upper + toUpper(next));\n        \tSystem.out.println(lower + toLower(next));\n        \tString result = br.readLine();\n        \tif(result.equals(\"end\")){\n        \t\tupper = upper + toUpper(next);\n        \t\tlower = lower + toLower(next);\n        \t\tend = true;\n        \t}\n        \telse if(result.equals(\"T\")){\n        \t\tupper = upper + toUpper(next);\n        \t\tlower = lower + toLower(next);\n        \t\tnext = 0;\n        \t}\n        \telse next++;\n        }//upper and lower is the right edge\n        next = 0;\n        while(!end){\n        \tSystem.out.println(toUpper(next) + upper);\n        \tSystem.out.println(toLower(next) + lower);\n        \tString result = br.readLine();\n        \tif(result.equals(\"end\")){\n        \t\tupper = toUpper(next) + upper;\n        \t\tlower = toLower(next) + lower;\n        \t\tend = true;\n        \t}\n        \telse if(result.equals(\"T\")){\n        \t\tupper = toUpper(next) + upper;\n        \t\tlower = toLower(next) + lower;\n        \t\tnext = 0;\n        \t}\n        \telse next++;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tboolean f = false;\n\t\twhile (true) {\n\t\t\tL :for (int i = 0; i <= 4; i++) {\n\t\t\t\tString t1 = s1;\n\t\t\t\tString t2 = s2;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \".\";\n\t\t\t\t\t\tt2 += \".\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \".\" + t1;\n\t\t\t\t\t\tt2 = \".\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \".\";\n\t\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \".\" + t1;\n\t\t\t\t\t\tt2 = \"#\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\t\tt2 += \".\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \"#\" + t1;\n\t\t\t\t\t\tt2 = \".\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \"#\" + t1;\n\t\t\t\t\t\tt2 = \"#\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tf = true;\n\t\t\t\t\tbreak L;\n\t\t\t\t}\n\t\t\t\tout.println(t1);\n\t\t\t\tout.println(t2);\n\t\t\t\tout.flush();\n\n\t\t\t\tString res = sc.next();\n\t\t\t\tif (res.equals(\"T\")) {\n\t\t\t\t\ts1 = t1;\n\t\t\t\t\ts2 = t2;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (res.equals(\"F\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tboolean f = false;\n\t\tF : while (true) {\n\t\t\tL :for (int i = 0; i <= 4; i++) {\n\t\t\t\tString t1 = s1;\n\t\t\t\tString t2 = s2;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \".\";\n\t\t\t\t\t\tt2 += \".\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \".\" + t1;\n\t\t\t\t\t\tt2 = \".\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \".\";\n\t\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \".\" + t1;\n\t\t\t\t\t\tt2 = \"#\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\t\tt2 += \".\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \"#\" + t1;\n\t\t\t\t\t\tt2 = \".\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \"#\" + t1;\n\t\t\t\t\t\tt2 = \"#\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tf = true;\n\t\t\t\t\tbreak L;\n\t\t\t\t}\n\t\t\t\tout.println(t1);\n\t\t\t\tout.println(t2);\n\t\t\t\tout.flush();\n\n\t\t\t\tString res = sc.next();\n\t\t\t\tif (res.equals(\"T\")) {\n\t\t\t\t\ts1 = t1;\n\t\t\t\t\ts2 = t2;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (res.equals(\"F\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak F;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tni();\n    \tStringBuffer q1 = new StringBuffer(\"\");\n    \tStringBuffer q2 = new StringBuffer(\"\");\n\n    \tint state = 0;\n\n    \tfor (int i=0; i<420; i++) {\n    \t\tint x = state / 2;\n    \t\tint y = state % 2;\n\n    \t\tout.println(q1 + (x == 0 ? \".\" : \"#\"));\n    \t\tout.println(q2 + (y == 0 ? \".\" : \"#\"));\n\n    \t\tString s = ns();\n\n    \t\tif (s.equals(\"end\")) {\n    \t\t\tbreak;\n    \t\t} else if (s.equals(\"T\")) {\n    \t\t\tq1.append(x == 0 ? \".\" : \"#\");\n    \t\t\tq2.append(y == 0 ? \".\" : \"#\");\n    \t\t\tstate = 0;\n    \t\t} else {\n    \t\t\tstate++;\n    \t\t}\n    \t}\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n \nimport java.util.*;\npublic class Main {\n\t\n\tint N,cnt,direct;\n\tString s1,s2;\n\tString[][] append = new String[][]{{\".\",\".\"},{\".\",\"#\"},{\"#\",\".\"},{\"#\",\"#\"}};\n\tHashSet<String> set;\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\ts1 = \".\";\n\t\ts2 = \".\";\n\t\tset = new HashSet<String>();\n\t\twhile(true){\n\t\t\tout.println(s1+\"\\n\"+s2);\n\t\t\tout.flush();\n\t\t\tString res = next();\n\t\t\t\n\t\t\tif(res.equals(\"end\"))break;\n\t\t\t\n\t\t\tif(res.equals(\"T\")){\n\t\t\t\tcnt = 0;\n\t\t\t\tif(direct == 0){\n\t\t\t\t\ts1 = s1 + append[cnt][0];\n\t\t\t\t\ts2 = s2 + append[cnt][1];\n\t\t\t\t}else{\n\t\t\t\t\ts1 = append[cnt][0] + s1;\n\t\t\t\t\ts2 = append[cnt][1] + s2;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tset.add(s1 + \"\\n\" + s2);\n\t\t\t\tif(cnt >= 4){\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tdirect = direct == 0 ? 1 : 0;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\tboolean flag = false;\n\t\t\t\t\tif(direct == 0){\n\t\t\t\t\t\tString ss1 = s1.substring(0,s1.length() - 1);\n\t\t\t\t\t\tString ss2 = s2.substring(0,s2.length() - 1);\n\t\t\t\t\t\n\t\t\t\t\t\ts1 = ss1 + append[cnt][0];\n\t\t\t\t\t\ts2 = ss2 + append[cnt][1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j = 1;j < s1.length();j++){\n\t\t\t\t\t\t\tString sss1 = s1.substring(j);\n\t\t\t\t\t\t\tString sss2 = s2.substring(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(set.contains(sss1 + \"\\n\" + sss2)){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!flag)break;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tString ss1 = s1.substring(1);\n\t\t\t\t\t\tString ss2 = s2.substring(1);\n\t\t\t\t\t\t\n\t\t\t\t\t\ts1 = append[cnt][0] + ss1;\n\t\t\t\t\t\ts2 = append[cnt][1] + ss2;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j = 1;j < s2.length();j++){\n\t\t\t\t\t\t\tString sss1 = s1.substring(j);\n\t\t\t\t\t\t\tString sss2 = s2.substring(j);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(set.contains(sss1 + \"\\n\" + sss2)){\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!flag)break;\n\t\t\t\t\t}\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n \n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n \n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n \n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n \n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n \n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n \n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n \n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n \n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n \n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n \n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tboolean f = false;\n\t\twhile (N-- > 0) {\n\t\t\tfor (int i = 0; i <= 4; i++) {\n\t\t\t\tString t1 = s1;\n\t\t\t\tString t2 = s2;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \".\";\n\t\t\t\t\t\tt2 += \".\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \".\" + t1;\n\t\t\t\t\t\tt2 = \".\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \".\";\n\t\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \".\" + t1;\n\t\t\t\t\t\tt2 = \"#\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\t\tt2 += \".\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \"#\" + t1;\n\t\t\t\t\t\tt2 = \".\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tif (!f) {\n\t\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt1 = \"#\" + t1;\n\t\t\t\t\t\tt2 = \"#\" + t2;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tf = true;\n\t\t\t\t\ti = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tout.println(t1);\n\t\t\t\tout.println(t2);\n\t\t\t\tout.flush();\n\n\t\t\t\tString res = sc.next();\n\t\t\t\tif (res.equals(\"T\")) {\n\t\t\t\t\ts1 = t1;\n\t\t\t\t\ts2 = t2;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (res.equals(\"F\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass D {\n    static final char[] bs = {'.', '#'};\n\n    public static void main(String... args) {\n        final Scanner sc = new Scanner(System.in);\n        final int N = Integer.parseInt(sc.nextLine());\n        final char[] up = new char[N];\n        final char[] lo = new char[N];\n        int cols = 0;\n        loop1:\n        for (; cols < N; cols++) {\n            for (int i = 0; i < 2; i++)\n                for (int j = 0; j < 2; j++) {\n                    up[cols] = bs[i];\n                    lo[cols] = bs[j];\n                    System.out.println(new String(up, 0, cols + 1));\n                    System.out.println(new String(lo, 0, cols + 1));\n                    switch (sc.nextLine()) {\n                        case \"end\":\n                            return;\n                        case \"T\":\n                            continue loop1;\n                        case \"F\":\n                            break;\n                        default:\n                            throw null;\n                    }\n                }\n            break;\n        }\n        for(int i = 1; i <= cols; i++) {\n            up[N - i] = up[cols - i];\n            lo[N - i] = lo[cols - i];\n        }\n        loop2:\n        for (; cols < N; cols++) {\n            for (int i = 0; i < 2; i++)\n                for (int j = 0; j < 2; j++) {\n                    up[N - cols - 1] = bs[i];\n                    lo[N - cols - 1] = bs[j];\n                    System.out.println(new String(up, N - cols - 1, cols + 1));\n                    System.out.println(new String(lo, N - cols - 1, cols + 1));\n                    switch (sc.nextLine()) {\n                        case \"end\":\n                            return;\n                        case \"T\":\n                            continue loop2;\n                        case \"F\":\n                            break;\n                        default:\n                            throw null;\n                    }\n                }\n            break;\n        }\n    }\n}\npublic class Main {\n    public static void main(String... args) {\n        D.main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tint N = sc.nextInt();\n\t\tint cnt = 0;\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tL: while (true) {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tString t1 = s1;\n\t\t\t\tString t2 = s2;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tt1 += \".\";\n\t\t\t\t\tt2 += \".\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tt1 += \".\";\n\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\tt2 += \".\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tt1 += \"#\";\n\t\t\t\t\tt2 += \"#\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(t1);\n\t\t\t\tSystem.out.println(t2);\n\n\t\t\t\tString res = sc.next();\n\t\t\t\tif (res.equals(\"T\")) {\n\t\t\t\t\ts1 = t1;\n\t\t\t\t\ts2 = t2;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (res.equals(\"F\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak L;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (cnt > 420) break;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.other2016.kupc2016;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n\n        char[][] board = new char[2][201];\n        Arrays.fill(board[0], '~');\n        Arrays.fill(board[1], '~');\n\n        // make scaffold\n        for (int p = 0 ; p < 4 ; p++) {\n            fill(board, 100, p);\n            if (query(board, 100, 101, in, out)) {\n                break;\n            }\n        }\n        if (n == 1) {\n            in.nextToken();\n            return;\n        }\n\n        // go right\n        int len = 1;\n        int right = 0;\n        for (int x = 101 ; x <= 199 ; x++) {\n            boolean found = false;\n            for (int p = 0; p < 4 ; p++) {\n                fill(board, x, p);\n                if (query(board, 100, x+1, in, out)) {\n                    right = x;\n                    len++;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                break;\n            }\n            if (len == n) {\n                in.nextToken();\n                return;\n            }\n        }\n\n        for (int x = 99 ; x >= 0 ; x--) {\n            for (int p = 0; p < 4 ; p++) {\n                fill(board, x, p);\n                if (query(board, x, right+1, in, out)) {\n                    len++;\n                    break;\n                }\n            }\n            if (len == n) {\n                in.nextToken();\n                return;\n            }\n        }\n        out.flush();\n    }\n\n    static void fill(char[][] board, int x, int ptn) {\n        board[0][x] = (ptn & 1) == 1 ? '#' : '.';\n        board[1][x] = (ptn & 2) == 2 ? '#' : '.';\n    }\n\n    static boolean query(char[][] board, int f, int t, InputReader in, PrintWriter out) {\n        out.println(String.valueOf(board[0]).substring(f, t));\n        out.println(String.valueOf(board[1]).substring(f, t));\n        out.flush();\n        return in.nextToken().toCharArray()[0] == 'T';\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n \nimport java.util.*;\npublic class Main {\n\t\n\tint N,cnt,direct;\n\tString s1,s2;\n\tString[][] append = new String[][]{{\".\",\".\"},{\".\",\"#\"},{\"#\",\".\"},{\"#\",\"#\"}};\n\tHashSet<String> set;\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\ts1 = \".\";\n\t\ts2 = \".\";\n\t\tset = new HashSet<String>();\n\t\twhile(true){\n\t\t\tout.println(s1+\"\\n\"+s2);\n\t\t\tout.flush();\n\t\t\tString res = next();\n\t\t\t\n\t\t\tif(res.equals(\"end\"))break;\n\t\t\t\n\t\t\tif(res.equals(\"T\")){\n\t\t\t\tcnt = 0;\n\t\t\t\tif(direct == 0){\n\t\t\t\t\ts1 = s1 + append[cnt][0];\n\t\t\t\t\ts2 = s2 + append[cnt][1];\n\t\t\t\t}else{\n\t\t\t\t\ts1 = append[cnt][0] + s1;\n\t\t\t\t\ts2 = append[cnt][1] + s2;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tset.add(s1 + \"\\n\" + s2);\n\t\t\t\tif(cnt >= 4){\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tdirect = direct == 0 ? 1 : 0;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\tif(direct == 0){\n\t\t\t\t\t\tString ss1 = s1.substring(0,s1.length() - 1);\n\t\t\t\t\t\tString ss2 = s2.substring(0,s2.length() - 1);\n\t\t\t\t\t\n\t\t\t\t\t\ts1 = ss1 + append[cnt][0];\n\t\t\t\t\t\ts2 = ss2 + append[cnt][1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!set.contains(s1 + \"\\n\" + s2))break;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tString ss1 = s1.substring(1);\n\t\t\t\t\t\tString ss2 = s2.substring(1);\n\t\t\t\t\t\t\n\t\t\t\t\t\ts1 = append[cnt][0] + ss1;\n\t\t\t\t\t\ts2 = append[cnt][1] + ss2;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!set.contains(s1 + \"\\n\" + s2))break;\n\t\t\t\t\t}\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n \n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n \n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n \n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n \n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n \n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n \n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n \n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n \n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n \n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic PrintStream out = System.out;\n\n\tpublic static void main(String args[]) {\n\t\tint N = ni();\n\t\tint flg[] = new int[N*2+1];\n\t\tint l = N-1, r = N;\n\n\t\twhile(true) {\n\t\t\tboolean isCheck = false;\n\t\t\tfor (int i=0;i<4;i++) {\n\t\t\t\tflg[r] = i;\n\t\t\t\toutput(flg, l+1, r+1);\n\n\t\t\t\tString ret = next();\n\t\t\t\tif (ret.equals(\"T\")) {\n\t\t\t\t\tisCheck = true;\n\t\t\t\t\tr++;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (ret.equals(\"end\")) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isCheck == false) break;\n\t\t}\n\n\n\t\twhile(true) {\n\t\t\tboolean isCheck = false;\n\t\t\tfor (int i=0;i<4;i++) {\n\t\t\t\tflg[l] = i;\n\t\t\t\toutput(flg, l, r);\n\n\t\t\t\tString ret = next();\n\t\t\t\tif (ret.equals(\"T\")) {\n\t\t\t\t\tisCheck = true;\n\t\t\t\t\tl--;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (ret.equals(\"end\")) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isCheck == false) break;\n\t\t}\n}\n\n\tpublic static void output(int flg[], int l, int r) {\n\t\tfor (int i=l;i<r;i++) {\n\t\t\tint s = flg[i];\n\t\t\tswitch(s) {\n\t\t\tcase 0: case 2: out.printf(\".\"); break;\n\t\t\tcase 1: case 3: out.printf(\"#\"); break;\n\t\t\t}\n\t\t}\n\t\tout.println();\n\n\t\tfor (int i=l;i<r;i++) {\n\t\t\tint s = flg[i];\n\t\t\tswitch(s) {\n\t\t\tcase 0: case 1: out.printf(\".\"); break;\n\t\t\tcase 2: case 3: out.printf(\"#\"); break;\n\t\t\t}\n\t\t}\n\t\tout.println();\n\t\tout.flush();\n\t}\n\n\tprivate static String next() {\n\t\treturn sc.next();\n\t}\n\n\tprivate static int ni() {\n\t\treturn sc.nextInt();\n\t}\n\n\tprivate static long nl() {\n\t\treturn sc.nextLong();\n\t}\n\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++) a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static long[] nal(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++) a[i] = ni();\n\t\treturn a;\n\t}\n\n    private static double nd() {\n        return Double.parseDouble( next() );\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public int nextInt() {\n        if (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\n\nimport java.io.*;\n\npublic class Main {\n\t\n\tvoid solve(int N) {\n\t\t\n\t\tRandom rand = new Random();\n\t\trand.setSeed(System.nanoTime());\n\t\t\n\t\tfinal int MAX_STEP = 420;\n\t\t\n\t\tchar[] as1 = \"..##\".toCharArray();\n\t\tchar[] as2 = \".#.#\".toCharArray();\n\t\t\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\t\n\t\tint[] order = {0, 1, 2, 3};\n\t\tint phase = 0;\n\t\t\n\t\touter:\n\t\tfor (int step = 0; step < MAX_STEP; step++){\n\t\t\tshuffle(order, rand);\n\t\t\tfor (int i = 0; i < order.length; i++) { \n\t\t\t\tString ns1, ns2;\n\t\t\t\tif (phase == 0) {\n\t\t\t\t\tns1 = s1 + as1[order[i]];\n\t\t\t\t\tns2 = s2 + as2[order[i]];\n\t\t\t\t} else {\n\t\t\t\t\tns1 = as1[order[i]] + s1;\n\t\t\t\t\tns2 = as2[order[i]] + s2;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tSystem.out.println(ns1);\n\t\t\t\tSystem.out.println(ns2);\n\t\t\t\tSystem.out.flush();\n\t\t\t\n\t\t\t\tString response = sc.next();\n\t\t\t\tif (response.charAt(0) == 'T') {\n\t\t\t\t\ts1 = ns1;\n\t\t\t\t\ts2 = ns2;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (response.charAt(0) == 'F') {\n\t\t\t\t\tif (i + 1 == order.length) {\n\t\t\t\t\t\tphase++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\tvoid shuffle(int[] a, Random random) {\n\t\tint n = a.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = i + random.nextInt(n - i);\n\t\t\tint t = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = t;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tScanner sc = null;\n\tpublic void run() throws Exception {\n\t\tsc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tsolve(N);\n\t\tSystem.out.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n \nimport java.util.*;\npublic class Main {\n\t\n\tint N,cnt,direct;\n\tString s1,s2;\n\tString[][] append = new String[][]{{\".\",\".\"},{\".\",\"#\"},{\"#\",\".\"},{\"#\",\"#\"}};\n\tHashSet<String> set;\n\tpublic void solve(){\n\t\tN = nextInt();\n\t\ts1 = \".\";\n\t\ts2 = \".\";\n\t\tset = new HashSet<String>();\n\t\twhile(true){\n\t\t\tboolean flag = false;\n\t\t\twhile(true){\n\t\t\t\tflag = false;\n\t\t\t\t\n\t\t\t\tif(cnt == 4){\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tdirect = direct == 0 ? 1 : 0;\n\t\t\t\t}\n\t\t\t\tif(direct == 0){\n\t\t\t\t\tString ss1 = s1.substring(0,s1.length() - 1);\n\t\t\t\t\tString ss2 = s2.substring(0,s2.length() - 1);\n\t\t\t\t\t\n\t\t\t\t\ts1 = ss1 + append[cnt][0];\n\t\t\t\t\ts2 = ss2 + append[cnt][1];\n\t\t\t\t\t//out.println(\"degug \" + s1 + \" \"+  s2 );\n\t\t\t\t\tfor(int j = 0;j < s1.length();j++){\n\t\t\t\t\t\tString sss1 = s1.substring(j);\n\t\t\t\t\t\tString sss2 = s2.substring(j);\n\t\t\t\t\t\t//out.println(\"debug2 \" + sss1 + \" \" + sss2);\n\t\t\t\t\t\tif(set.contains(sss1 + \"\\n\" + sss2)){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tout.println(s1 + \"\\n\" + s2);\n\t\t\t\t\tout.flush();\n\t\t\t\t\tString res = next();\n\t\t\t\t\t\n\t\t\t\t\tif(res.equals(\"end\"))return;\n\t\t\t\t\tif(res.equals(\"T\"))break;\n\t\t\t\t\tset.add(s1 + \"\\n\" + s2);\n\t\t\t\t}else{\n\t\t\t\t\tString ss1 = s1.substring(1);\n\t\t\t\t\tString ss2 = s2.substring(1);\n\t\t\t\t\t\n\t\t\t\t\ts1 = append[cnt][0] + ss1;\n\t\t\t\t\ts2 = append[cnt][1] + ss2;\n\t\t\t\t\t\n\t\t\t\t\tfor(int j =01;j < s1.length();j++){\n\t\t\t\t\t\tString sss1 = s1.substring(j);\n\t\t\t\t\t\tString sss2 = s2.substring(j);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(set.contains(sss1 + \"\\n\" + sss2)){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tout.println(s1 + \"\\n\" + s2);\n\t\t\t\t\tout.flush();\n\t\t\t\t\tString res = next();\n\t\t\t\t\t\n\t\t\t\t\tif(res.equals(\"end\"))return;\n\t\t\t\t\tif(res.equals(\"T\"))break;\n\t\t\t\t\tset.add(s1 + \"\\n\" + s2);\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\tif(direct == 0){\n\t\t\t\ts1 = s1 + append[cnt][0];\n\t\t\t\ts2 = s2 + append[cnt][1];\n\t\t\t}else{\n\t\t\t\ts1 = append[cnt][0] + s1;\n\t\t\t\ts2 = append[cnt][1] + s2;\n\t\t\t}\n\t\t}\n\t}\n \n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n \n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n \n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n \n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n \n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n \n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n \n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n \n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n \n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n \n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.TreeSet;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/B3\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tString[] TEMPLATE = {\"..\", \".#\", \"#.\", \"##\"};\n\t\n\tString query(String up, String down) {\n\t\tSystem.out.println(up);\n\t\tSystem.out.println(down);\n\t\treturn in.next();\n\t}\n\t\n\tpublic void solve() {\n\t\tint N = in.nextInt();\n\t\t\n\t\tString up = \"\", down = \"\";\n\t\t// construct lefts\n\t\t{\n\t\t\tboolean leftMore = true;\n\t\t\twhile (leftMore) {\n\t\t\t\tleftMore = false;\n\t\t\t\tfor (String t : TEMPLATE) {\n\t\t\t\t\tString nextUp = t.charAt(0) + up;\n\t\t\t\t\tString nextDown = t.charAt(1) + down;\n\t\t\t\t\tString res = query(nextUp, nextDown);\n\t\t\t\t\tif (res.matches(\"end\")) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (res.matches(\"T\")) {\n\t\t\t\t\t\tup = nextUp;\n\t\t\t\t\t\tdown = nextDown;\n\t\t\t\t\t\tleftMore = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// construct rights\n\t\t{\n\t\t\tboolean rightMore = true;\n\t\t\twhile (rightMore) {\n\t\t\t\trightMore = false;\n\t\t\t\tfor (String t : TEMPLATE) {\n\t\t\t\t\tString nextUp = up + t.charAt(0);\n\t\t\t\t\tString nextDown = down + t.charAt(1);\n\t\t\t\t\tString res = query(nextUp, nextDown);\n\t\t\t\t\tif (res.matches(\"end\")) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (res.matches(\"T\")) {\n\t\t\t\t\t\tup = nextUp;\n\t\t\t\t\t\tdown = nextDown;\n\t\t\t\t\t\trightMore = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\tthrow new RuntimeException();\n\t}\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tThread t = new Thread(null, new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}, \"lul\", 1 << 30);\n\t\tt.start();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tni();\n    \tString q1 = \"\";\n    \tString q2 = \"\";\n\n    \tint state = 0;\n    \tint mode = 1;\n\n    \tfor (int i=0; i<420; i++) {\n    \t\tint x = state / 2;\n    \t\tint y = state % 2;\n\n    \t\tout.println(mode == 1 ? q1 + (x == 0 ? \".\" : \"#\") : (x == 0 ? \".\" : \"#\") + q1);\n    \t\tout.println(mode == 1 ? q2 + (y == 0 ? \".\" : \"#\") : (y == 0 ? \".\" : \"#\") + q2);\n    \t\tout.flush();\n\n    \t\tString s = ns();\n\n    \t\tif (s.equals(\"end\")) {\n    \t\t\treturn;\n    \t\t} else if (s.equals(\"T\")) {\n    \t\t\tq1 = mode == 1 ? q1 + (x == 0 ? \".\" : \"#\") : (x == 0 ? \".\" : \"#\") + q1;\n    \t\t\tq2 = mode == 1 ? q2 + (y == 0 ? \".\" : \"#\") : (y == 0 ? \".\" : \"#\") + q2;\n    \t\t\tstate = 0;\n    \t\t} else {\n    \t\t\tstate++;\n    \t\t\tif (state == 4) {\n    \t\t\t\tmode = 2;\n    \t\t\t\tstate = 0;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tni();\n    \tStringBuffer q1 = new StringBuffer(\"\");\n    \tStringBuffer q2 = new StringBuffer(\"\");\n\n    \tint state = 0;\n\n    \tfor (int i=0; i<420; i++) {\n    \t\tint x = state / 2;\n    \t\tint y = state % 2;\n\n            out = new PrintWriter(System.out);\n    \t\tout.println(q1 + (x == 0 ? \".\" : \"#\"));\n    \t\tout.println(q2 + (y == 0 ? \".\" : \"#\"));\n            out.close();\n\n    \t\tString s = ns();\n\n    \t\tif (s.equals(\"end\")) {\n    \t\t\treturn;\n    \t\t} else if (s.equals(\"T\")) {\n    \t\t\tq1.append(x == 0 ? \".\" : \"#\");\n    \t\t\tq2.append(y == 0 ? \".\" : \"#\");\n    \t\t\tstate = 0;\n    \t\t} else {\n    \t\t\tstate++;\n    \t\t}\n    \t}\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size { get { return 1; } }\n\t\t//public const long Mod = 1000000007;\n\t\tpublic const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N);\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tvar board = new Deque<int>(N);\n\t\t\tvar done = new HashSet<int>();\n\t\t\tvar r = true;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (done.Count == 4) { done.Clear(); r = false; }\n\t\t\t\tvar x = rand.Next(0, 4);\n\t\t\t\tif (done.Contains(x)) continue;\n\t\t\t\telse done.Add(x);\n\t\t\t\tif (r) board.PushBack(x);\n\t\t\t\telse board.PushFront(x);\n\t\t\t\tif (!Contains(board))\n\t\t\t\t{\n\t\t\t\t\tif (r) board.PopBack();\n\t\t\t\t\telse board.PopFront();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdone.Clear();\n\t\t\t\t\tif (board.Count == N) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool Contains(Deque<int> board)\n\t\t{\n\t\t\tConsole.WriteLine(ToString(board));\n\t\t\tvar ans = Console.ReadLine();\n\t\t\treturn ans == \"T\" || ans == \"end\";\n\t\t}\n\t\tstring ToString(Deque<int> board)\n\t\t{\n\t\t\tvar N = board.Count;\n\t\t\tvar sb = new StringBuilder(2 * N + 1);\n\t\t\tfor (var i = 0; i < N; i++) sb.Append(board[i] / 2 == 0 ? '.' : '#');\n\t\t\tsb.AppendLine();\n\t\t\tfor (var i = 0; i < N; i++) sb.Append(board[i] % 2 == 0 ? '.' : '#');\n\t\t\treturn sb.ToString();\n\t\t}\n\t}\n}\nclass Tree2\n{\n\tpublic TreeNode2 head;\n\tpublic List<TreeNode2> tails;\n\tpublic Tree2() { head = new TreeNode2(null); tails = new List<TreeNode2>(); }\n\tpublic void Add(IEnumerable<char> S, int i)\n\t{\n\t\tvar node = head;\n\t\tforeach (var c in S)\n\t\t{\n\t\t\tif (!node.children.ContainsKey(c)) node.children[c] = new TreeNode2(node);\n\t\t\tnode = node.children[c];\n\t\t}\n\t\tif (!node.children.ContainsKey('`')) node.children['`'] = new TreeNode2(node);\n\t\tnode = node.children['`'];\n\t\tnode.elements = new HashSet<int>();\n\t\tnode.elements.Add(i);\n\t\ttails.Add(node);\n\t}\n\tpublic void Compress()\n\t{\n\t\tforeach (var tmp in tails)\n\t\t{\n\t\t\tTreeNode2 t = tmp, p = t;\n\t\t\twhile (t != null)\n\t\t\t{\n\t\t\t\tvar c = t.children.Count;\n\t\t\t\tif (c == 1) t.elements = p.elements;\n\t\t\t\telse if (c > 1)\n\t\t\t\t{\n\t\t\t\t\tif (t.elements == null) t.elements = new HashSet<int>();\n\t\t\t\t\tt.elements.UnionWith(p.elements);\n\t\t\t\t}\n\t\t\t\tp = t; t = t.parent;\n\t\t\t}\n\t\t}\n\t}\n\tpublic TreeNode2 Search(IEnumerable<char> S)\n\t{\n\t\tvar node = head;\n\t\tforeach (var c in S) node = node.children[c];\n\t\treturn node.children['`'];\n\t}\n}\nclass TreeNode2\n{\n\tpublic TreeNode2 parent;\n\tpublic Dictionary<int, TreeNode2> children = new Dictionary<int, TreeNode2>();\n\tpublic HashSet<int> elements;\n\tpublic TreeNode2(TreeNode2 p) { parent = p; }\n}\nclass Tree\n{\n\tpublic TreeNode head;\n\tpublic Tree() { head = new TreeNode(); }\n\tpublic void Add(IEnumerable<char> S)\n\t{\n\t\tvar node = head;\n\t\thead.size++;\n\t\tforeach (var c in S)\n\t\t{\n\t\t\tvar x = c - '`';\n\t\t\tif (node.children[x] == null) node.children[x] = new TreeNode();\n\t\t\tnode = node.children[x];\n\t\t\tnode.size++;\n\t\t}\n\t\tif (node.children[0] == null) node.children[0] = new TreeNode();\n\t\tnode = node.children[0];\n\t\tnode.size++;\n\t}\n\tpublic int Sum(IEnumerable<char> S, string order)\n\t{\n\t\tvar node = head;\n\t\tvar sum = 0;\n\t\tforeach (var c in S)\n\t\t{\n\t\t\tif (c != '`')\n\t\t\t{\n\t\t\t\tsum += node.Size(0);\n\t\t\t\tfor (var i = 0; i < 26; i++)\n\t\t\t\t{\n\t\t\t\t\tif (order[i] != c) sum += node.Size(order[i] - '`');\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.size == 1) break;\n\t\t\tnode = node.children[c - '`'];\n\t\t}\n\t\treturn sum;\n\t}\n}\nclass TreeNode\n{\n\tpublic TreeNode[] children = new TreeNode[27];\n\tpublic int size;\n\tpublic TreeNode() { }\n\tpublic int Size(int i) { return children[i] == null ? 0 : children[i].size; }\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\n/*class MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) { return mult[item]; }\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) { Add(item, 1); }\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) { return keys.Overlaps(other); }\n\tpublic bool IsSupersetOf(IEnumerable<T> other) { return keys.IsSupersetOf(other); }\n\tpublic bool IsSubsetOf(IEnumerable<T> other) { return keys.IsSubsetOf(other); }\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) { return keys.IsProperSubsetOf(other); }\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) { return keys.IsProperSupersetOf(other); }\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) { CopyTo(array, 0); }\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) { return keys.Contains(item); }\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }\n\tpublic T Max { get { return keys.Max; } }\n\tpublic T Min { get { return keys.Min; } }\n\tpublic bool IsReadOnly { get { return false; } }\n}*/\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tint size = 0;\n\t\t\tdecimal time = 0;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; this.comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() { return Value.ToString(); }\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n)));\n\t\tprimes.Add(2);\n\t\tvar composites = new bool[m];\n\t\tcomposites[0] = false;\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1l;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tint s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new System.Diagnostics.Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / System.Diagnostics.Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--)\n\t\t\t\tdp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = Func.FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = Func.FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) Func.SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tfor (var n = 0; n < N; n++) memo[n] = Inf;\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = Func.FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn Func.FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length <= 1) return; QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (int i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void gen_rand_all()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; uint[] p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid period_certification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { gen_rand_all(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace d\n{\n    class Program\n    {\n        static string[][] c = new string[2][];\n        static void Main(string[] args)\n        {\n            c[0] = new string[] { \"#\", \"#\", \".\", \".\" };\n            c[1] = new string[] { \"#\", \".\", \"#\", \".\" };\n            int n = int.Parse(Console.ReadLine());\n            string[] s = new string[2];\n            for (int i = 0; i < 2; i++)\n            {\n                s[i] = \"\";\n            }\n            bool afterMode = true;\n            while (s[0].Length < n)\n            {\n                if (afterMode)//ato ni ireru\n                {\n                    afterMode = false;\n                    for (int ccnt = 0; ccnt < 4; ccnt++)\n                    {\n                        for (int scnt = 0; scnt < 2; scnt++)\n                        {\n                            Console.WriteLine(\"{0}{1}\", s[scnt], c[scnt][ccnt]);\n                        }\n                        string r = Console.ReadLine();\n                        if (r == \"T\")\n                        {\n                            for (int scnt = 0; scnt < 2; scnt++)\n                            {\n                                s[scnt] = s[scnt] + c[scnt][ccnt];\n                            }\n                            afterMode = true;\n                            break;\n                        }\n                        else if (r == \"end\") return;\n                    }\n                }\n                else//mae ni ireru\n                {\n                    for (int ccnt = 0; ccnt < 4; ccnt++)\n                    {\n                        for (int scnt = 0; scnt < 2; scnt++)\n                        {\n                            Console.WriteLine(\"{0}{1}\", c[scnt][ccnt], s[scnt]);\n                        }\n                        string r = Console.ReadLine();\n                        if (r == \"T\")\n                        {\n                            for (int scnt = 0; scnt < 2; scnt++)\n                            {\n                                s[scnt] = c[scnt][ccnt] + s[scnt];\n                            }\n                            break;\n                        }\n                        else if (r == \"end\") return;\n                    }\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\n//using static System.Math;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    readonly string ALFA = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    int N;\n\n\n    void solve()\n    {\n        N = cin.nextint;\n        var s1 = \"\";\n        var s2 = \"\";\n        var x = new[] { '.', '#', '.', '#' };\n        var y = new[] { '.', '.', '#', '#' };\n        for (int i = 0; i < N; i++)\n        {\n            bool flag = false;\n            for (int r = 0; r < 4; r++)\n            {\n                WriteLine(s1 + x[r]);\n                WriteLine(s2 + y[r]);\n                var c = ReadLine();\n                if (c == \"end\") return;\n                if (c == \"T\")\n                {\n                    flag = true;\n                    s1 += x[r];\n                    s2 += y[r];\n                    break;\n                }\n            }\n            if (flag) continue;\n            for (int r = 0; r < 4; r++)\n            {\n                WriteLine(x[r] + s1);\n                WriteLine(y[r] + s2);\n                var c = ReadLine();\n                if (c == \"end\") return;\n                if (c == \"T\")\n                {\n                    s1 = x[r] + s1;\n                    s2 = y[r] + s2;\n                    break;\n                }\n            }\n        }\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tList<String> L1 = new List<String>();\n\t\tList<String> L2 = new List<String>();\n\t\tString[] A = new String[]{ \"..\",\".#\",\"##\",\"#.\"};\n\t\tforeach(var s in A){\n\t\t\tvar res = Query(s);\n\t\t\tif(res ==\"T\"){\n\t\t\t\tL1.Add(s.Substring(0,1));\n\t\t\t\tL2.Add(s.Substring(1));\n\t\t\t}else if(res ==\"end\"){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar ans = L1[0]+L2[0];\n\t\tbool forward = true;\n\t\twhile(true){\n\t\t\tif(forward){\n\t\t\t\tbool chk = false;\n\t\t\t\tfor(int t=0;t<L1.Count;t++){\n\t\t\t\t\tint n = ans.Length/2;\n\t\t\t\t\tvar res = Query(L1[t]+ans.Substring(0,n)+L2[t]+ans.Substring(n));\n\t\t\t\t\tif(res == \"end\"){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else if(res == \"T\"){\n\t\t\t\t\t\tans = L1[t]+ans.Substring(0,n)+L2[t]+ans.Substring(n);\n\t\t\t\t\t\tchk = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!chk)forward = false;\n\t\t\t}else{\n\t\t\t\tfor(int t=0;t<L1.Count;t++){\n\t\t\t\t\tint n = ans.Length/2;\n\t\t\t\t\tvar res = Query(ans.Substring(0,n)+L1[t]+ans.Substring(n)+L2[t]);\n\t\t\t\t\tif(res == \"end\"){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else if(res == \"T\"){\n\t\t\t\t\t\tans = ans.Substring(0,n)+L1[t]+ans.Substring(n)+L2[t];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tString Query(String s){\n\t\tint n = s.Length/2;\n\t\tConsole.WriteLine(s.Substring(0,n) +\"\\n\" + s.Substring(n));\n\t\tConsole.Out.Flush();\n\t\treturn Console.ReadLine();\n\t}\n\t\n\tint N;\n\tpublic Sol(){\n\t\tN = ri();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size { get { return 1; } }\n\t\t//public const long Mod = 1000000007;\n\t\tpublic const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N);\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tvar board = new Deque<int>(N);\n\t\t\tvar done = new HashSet<int>();\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tvar x = rand.Next(0, 8);\n\t\t\t\tif (done.Contains(x)) continue;\n\t\t\t\telse done.Add(x);\n\t\t\t\tvar lr = x / 4 == 0;\n\t\t\t\tif (lr) board.PushBack(x & 3);\n\t\t\t\telse board.PushFront(x & 3);\n\t\t\t\tif (!Contains(board))\n\t\t\t\t{\n\t\t\t\t\tif (lr) board.PopBack();\n\t\t\t\t\telse board.PopFront();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdone.Clear();\n\t\t\t\t\tif (board.Count == N) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool Contains(Deque<int> board)\n\t\t{\n\t\t\tConsole.WriteLine(ToString(board));\n\t\t\tvar ans = Console.ReadLine();\n\t\t\treturn ans == \"T\" || ans == \"end\";\n\t\t}\n\t\tstring ToString(Deque<int> board)\n\t\t{\n\t\t\tvar N = board.Count;\n\t\t\tvar sb = new StringBuilder(2 * N + 1);\n\t\t\tfor (var i = 0; i < N; i++) sb.Append(board[i] / 2 == 0 ? '.' : '#');\n\t\t\tsb.AppendLine();\n\t\t\tfor (var i = 0; i < N; i++) sb.Append(board[i] % 2 == 0 ? '.' : '#');\n\t\t\treturn sb.ToString();\n\t\t}\n\t}\n}\nclass Tree2\n{\n\tpublic TreeNode2 head;\n\tpublic List<TreeNode2> tails;\n\tpublic Tree2() { head = new TreeNode2(null); tails = new List<TreeNode2>(); }\n\tpublic void Add(IEnumerable<char> S, int i)\n\t{\n\t\tvar node = head;\n\t\tforeach (var c in S)\n\t\t{\n\t\t\tif (!node.children.ContainsKey(c)) node.children[c] = new TreeNode2(node);\n\t\t\tnode = node.children[c];\n\t\t}\n\t\tif (!node.children.ContainsKey('`')) node.children['`'] = new TreeNode2(node);\n\t\tnode = node.children['`'];\n\t\tnode.elements = new HashSet<int>();\n\t\tnode.elements.Add(i);\n\t\ttails.Add(node);\n\t}\n\tpublic void Compress()\n\t{\n\t\tforeach (var tmp in tails)\n\t\t{\n\t\t\tTreeNode2 t = tmp, p = t;\n\t\t\twhile (t != null)\n\t\t\t{\n\t\t\t\tvar c = t.children.Count;\n\t\t\t\tif (c == 1) t.elements = p.elements;\n\t\t\t\telse if (c > 1)\n\t\t\t\t{\n\t\t\t\t\tif (t.elements == null) t.elements = new HashSet<int>();\n\t\t\t\t\tt.elements.UnionWith(p.elements);\n\t\t\t\t}\n\t\t\t\tp = t; t = t.parent;\n\t\t\t}\n\t\t}\n\t}\n\tpublic TreeNode2 Search(IEnumerable<char> S)\n\t{\n\t\tvar node = head;\n\t\tforeach (var c in S) node = node.children[c];\n\t\treturn node.children['`'];\n\t}\n}\nclass TreeNode2\n{\n\tpublic TreeNode2 parent;\n\tpublic Dictionary<int, TreeNode2> children = new Dictionary<int, TreeNode2>();\n\tpublic HashSet<int> elements;\n\tpublic TreeNode2(TreeNode2 p) { parent = p; }\n}\nclass Tree\n{\n\tpublic TreeNode head;\n\tpublic Tree() { head = new TreeNode(); }\n\tpublic void Add(IEnumerable<char> S)\n\t{\n\t\tvar node = head;\n\t\thead.size++;\n\t\tforeach (var c in S)\n\t\t{\n\t\t\tvar x = c - '`';\n\t\t\tif (node.children[x] == null) node.children[x] = new TreeNode();\n\t\t\tnode = node.children[x];\n\t\t\tnode.size++;\n\t\t}\n\t\tif (node.children[0] == null) node.children[0] = new TreeNode();\n\t\tnode = node.children[0];\n\t\tnode.size++;\n\t}\n\tpublic int Sum(IEnumerable<char> S, string order)\n\t{\n\t\tvar node = head;\n\t\tvar sum = 0;\n\t\tforeach (var c in S)\n\t\t{\n\t\t\tif (c != '`')\n\t\t\t{\n\t\t\t\tsum += node.Size(0);\n\t\t\t\tfor (var i = 0; i < 26; i++)\n\t\t\t\t{\n\t\t\t\t\tif (order[i] != c) sum += node.Size(order[i] - '`');\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.size == 1) break;\n\t\t\tnode = node.children[c - '`'];\n\t\t}\n\t\treturn sum;\n\t}\n}\nclass TreeNode\n{\n\tpublic TreeNode[] children = new TreeNode[27];\n\tpublic int size;\n\tpublic TreeNode() { }\n\tpublic int Size(int i) { return children[i] == null ? 0 : children[i].size; }\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\n/*class MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) { return mult[item]; }\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) { Add(item, 1); }\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) { return keys.Overlaps(other); }\n\tpublic bool IsSupersetOf(IEnumerable<T> other) { return keys.IsSupersetOf(other); }\n\tpublic bool IsSubsetOf(IEnumerable<T> other) { return keys.IsSubsetOf(other); }\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) { return keys.IsProperSubsetOf(other); }\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) { return keys.IsProperSupersetOf(other); }\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) { CopyTo(array, 0); }\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) { return keys.Contains(item); }\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }\n\tpublic T Max { get { return keys.Max; } }\n\tpublic T Min { get { return keys.Min; } }\n\tpublic bool IsReadOnly { get { return false; } }\n}*/\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tint size = 0;\n\t\t\tdecimal time = 0;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; this.comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() { return Value.ToString(); }\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n)));\n\t\tprimes.Add(2);\n\t\tvar composites = new bool[m];\n\t\tcomposites[0] = false;\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1l;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tint s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new System.Diagnostics.Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / System.Diagnostics.Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--)\n\t\t\t\tdp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = Func.FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = Func.FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) Func.SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tfor (var n = 0; n < N; n++) memo[n] = Inf;\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = Func.FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn Func.FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length <= 1) return; QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (int i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void gen_rand_all()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; uint[] p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid period_certification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { gen_rand_all(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tList<String> L1 = new List<String>();\n\t\tList<String> L2 = new List<String>();\n\t\tString[] A = new String[]{ \"..\",\".#\",\"##\",\"#.\"};\n\t\tforeach(var s in A){\n\t\t\tvar res = Query(s);\n\t\t\tif(res ==\"T\"){\n\t\t\t\tL1.Add(s.Substring(0,1));\n\t\t\t\tL2.Add(s.Substring(1));\n\t\t\t}else if(res ==\"end\"){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar ans = L1[0]+L2[0];\n\t\tbool forward = true;\n\t\twhile(true){\n\t\t\tif(forward){\n\t\t\t\tfor(int t=0;t<L1.Count;t++){\n\t\t\t\t\tint n = ans.Length/2;\n\t\t\t\t\tvar res = Query(L1[t]+ans.Substring(0,n)+L2[t]+ans.Substring(n));\n\t\t\t\t\tif(res == \"end\"){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else if(res == \"T\"){\n\t\t\t\t\t\tans = L1[t]+ans.Substring(0,n)+L2[t]+ans.Substring(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tforward = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int t=0;t<L1.Count;t++){\n\t\t\t\t\tint n = ans.Length/2;\n\t\t\t\t\tvar res = Query(ans.Substring(0,n)+L1[t]+ans.Substring(n)+L2[t]);\n\t\t\t\t\tif(res == \"end\"){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else if(res == \"T\"){\n\t\t\t\t\t\tans = ans.Substring(0,n)+L1[t]+ans.Substring(n)+L2[t];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tString Query(String s){\n\t\tint n = s.Length/2;\n\t\tConsole.WriteLine(s.Substring(0,n) +\"\\n\" + s.Substring(n));\n\t\tConsole.Out.Flush();\n\t\treturn Console.ReadLine();\n\t}\n\t\n\tint N;\n\tpublic Sol(){\n\t\tN = ri();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tList<String> L1 = new List<String>();\n\t\tList<String> L2 = new List<String>();\n\t\tString[] A = new String[]{ \"..\",\".#\",\"##\",\"#.\"};\n\t\tforeach(var s in A){\n\t\t\tvar res = Query(s);\n\t\t\tif(res ==\"T\"){\n\t\t\t\tL1.Add(s.Substring(0,1));\n\t\t\t\tL2.Add(s.Substring(1));\n\t\t\t}else if(res ==\"end\"){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar ans = L1[0]+L2[0];\n\t\tbool forward = true;\n\t\twhile(true){\n\t\t\tif(forward){\n\t\t\t\tfor(int t=0;t<L1.Count;t++){\n\t\t\t\t\tint n = ans.Length/2;\n\t\t\t\t\tvar res = Query(L1[t]+ans.Substring(0,n)+L2[t]+ans.Substring(n));\n\t\t\t\t\tif(res == \"end\"){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else if(res == \"T\"){\n\t\t\t\t\t\tans = L1[t]+ans.Substring(0,n)+L2[t]+ans.Substring(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tforward = false;\n\t\t\t}else{\n\t\t\t\tfor(int t=0;t<L1.Count;t++){\n\t\t\t\t\tint n = ans.Length/2;\n\t\t\t\t\tvar res = Query(ans.Substring(0,n)+L1[t]+ans.Substring(n)+L2[t]);\n\t\t\t\t\tif(res == \"end\"){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else if(res == \"T\"){\n\t\t\t\t\t\tans = ans.Substring(0,n)+L1[t]+ans.Substring(n)+L2[t];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tString Query(String s){\n\t\tint n = s.Length/2;\n\t\tConsole.WriteLine(s.Substring(0,n) +\"\\n\" + s.Substring(n));\n\t\tConsole.Out.Flush();\n\t\treturn Console.ReadLine();\n\t}\n\t\n\tint N;\n\tpublic Sol(){\n\t\tN = ri();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace d\n{\n    class Program\n    {\n        static string[][] c = new string[2][];\n        static void Main(string[] args)\n        {\n            c[0] = new string[] { \"#\", \"#\", \".\", \".\" };\n            c[1] = new string[] { \"#\", \".\", \"#\", \".\" };\n            int n = int.Parse(Console.ReadLine());\n            string[] s = new string[2];\n            for (int i = 0; i < 2; i++)\n            {\n                s[i] = \"\";\n            }\n            bool afterMode = true;\n            while (s[0].Length < n)\n            {\n                if (afterMode)//ato ni ireru\n                {\n                    for (int ccnt = 0; ccnt < 4; ccnt++)\n                    {\n                        for (int scnt = 0; scnt < 2; scnt++)\n                        {\n                            Console.WriteLine(\"{0}{1}\", s[scnt], c[scnt][ccnt]);\n                        }\n                        string r = Console.ReadLine();\n                        if (r == \"T\")\n                        {\n                            for (int scnt = 0; scnt < 2; scnt++)\n                            {\n                                s[scnt] = s[scnt] + c[scnt][ccnt];\n                            }\n                            break;\n                        }\n                        else if (r == \"end\") return;\n                    }\n                    afterMode = false;\n                }\n                else//mae ni ireru\n                {\n                    for (int ccnt = 0; ccnt < 4; ccnt++)\n                    {\n                        for (int scnt = 0; scnt < 2; scnt++)\n                        {\n                            Console.WriteLine(\"{0}{1}\", c[scnt][ccnt], s[scnt]);\n                        }\n                        string r = Console.ReadLine();\n                        if (r == \"T\")\n                        {\n                            for (int scnt = 0; scnt < 2; scnt++)\n                            {\n                                s[scnt] = c[scnt][ccnt] + s[scnt];\n                            }\n                            break;\n                        }\n                        else if (r == \"end\") return;\n                    }\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tList<String> L1 = new List<String>();\n\t\tList<String> L2 = new List<String>();\n\t\tString[] A = new String[]{ \"..\",\".#\",\"##\",\"#.\"};\n\t\tforeach(var s in A){\n\t\t\tvar res = Query(s);\n\t\t\tif(res ==\"T\"){\n\t\t\t\tL1.Add(s.Substring(0,1));\n\t\t\t\tL2.Add(s.Substring(1));\n\t\t\t}else if(res ==\"end\"){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar ans = L1[0]+L2[0];\n\t\twhile(true){\n\t\t\t\n\t\t\tfor(int t=0;t<L1.Count;t++){\n\t\t\t\tint n = ans.Length/2;\n\t\t\t\tvar res = Query(L1[t]+ans.Substring(0,n)+L2[t]+ans.Substring(n));\n\t\t\t\tif(res == \"end\"){\n\t\t\t\t\treturn;\n\t\t\t\t}else if(res == \"T\"){\n\t\t\t\t\tans = L1[t]+ans.Substring(0,n)+L2[t]+ans.Substring(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres = Query(ans.Substring(0,n)+L1[t]+ans.Substring(n)+L2[t]);\n\t\t\t\tif(res == \"end\"){\n\t\t\t\t\treturn;\n\t\t\t\t}else if(res == \"T\"){\n\t\t\t\t\tans = ans.Substring(0,n)+L1[t]+ans.Substring(n)+L2[t];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tString Query(String s){\n\t\tint n = s.Length/2;\n\t\tConsole.WriteLine(s.Substring(0,n) +\"\\n\" + s.Substring(n));\n\t\tConsole.Out.Flush();\n\t\treturn Console.ReadLine();\n\t}\n\t\n\tint N;\n\tpublic Sol(){\n\t\tN = ri();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tList<String> L1 = new List<String>();\n\t\tList<String> L2 = new List<String>();\n\t\tString[] A = new String[]{ \"..\",\".#\",\"##\",\"#.\"};\n\t\tforeach(var s in A){\n\t\t\tvar res = Query(s);\n\t\t\tif(res ==\"T\"){\n\t\t\t\tL1.Add(s.Substring(0,1));\n\t\t\t\tL2.Add(s.Substring(1));\n\t\t\t}else if(res ==\"end\"){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tHashSet<String> H = new HashSet<String>();\n\t\tfor(int k=0;k<L1.Count;k++)H.Add(L1[k]+L2[k]);\n\t\t\n\t\tfor(int i=1;i<N;i++){\n\t\t\tHashSet<String> nxt = new HashSet<String>();\n\t\t\tforeach(var s in H){\n\t\t\t\tint n = s.Length/2;\n\t\t\t\tfor(int k=0;k<L1.Count;k++){\n\t\t\t\t\tvar res = Query(s.Substring(n) + L1[k] + s.Substring(n) + L2[k]);\n\t\t\t\t\tif(res == \"T\"){\n\t\t\t\t\t\tnxt.Add(s.Substring(n) + L1[k] + s.Substring(n) + L2[k]);\n\t\t\t\t\t}else if(res == \"end\"){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tH = nxt;\n\t\t}\n\t\t\n\t}\n\t\n\tString Query(String s){\n\t\tint n = s.Length/2;\n\t\tConsole.WriteLine(s.Substring(0,n) +\"\\n\" + s.Substring(n));\n\t\treturn Console.ReadLine();\n\t}\n\t\n\tint N;\n\tpublic Sol(){\n\t\tN = ri();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n//using System.Numerics;\n//using static System.Math;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 };\n    readonly int mod = 1000000007;\n    readonly string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    readonly string ALFA = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    int N;\n\n\n    void solve()\n    {\n        N = cin.nextint;\n        var s1 = \"\";\n        var s2 = \"\";\n        var x = new[] { '.', '#', '.', '#' };\n        var y = new[] { '.', '.', '#', '#' };\n        bool flag = true;\n\n        for (int i = 0; i < N; i++)\n        {\n            if (flag)\n            {\n                flag = false;\n                for (int r = 0; r < 4; r++)\n                {\n                    WriteLine(s1 + x[r]);\n                    WriteLine(s2 + y[r]);\n                    var c = ReadLine();\n                    if (c == \"end\") return;\n                    if (c == \"T\")\n                    {\n                        flag = true;\n                        s1 += x[r];\n                        s2 += y[r];\n                        break;\n                    }\n                }\n            }\n            if (flag) continue;\n\n            for (int r = 0; r < 4; r++)\n            {\n                WriteLine(x[r] + s1);\n                WriteLine(y[r] + s2);\n                var c = ReadLine();\n                if (c == \"end\") return;\n                if (c == \"T\")\n                {\n                    s1 = x[r] + s1;\n                    s2 = y[r] + s2;\n                    break;\n                }\n            }\n        }\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace d\n{\n    class Program\n    {\n        static string[][] c = new string[2][]; \n        static void Main(string[] args)\n        {\n            c[0] = new string[] { \"#\", \"#\", \".\", \".\" };\n            c[1] = new string[] { \"#\", \".\", \"#\", \".\" };\n            int n = int.Parse(Console.ReadLine());\n            string[] s = new string[2];\n            for (int i = 0; i < 2; i++)\n            {\n                s[i] = \"\";\n            }\n            bool afterMode = true;\n            while(s[0].Length < n)\n            {\n                if(afterMode)//ato ni ireru\n                {\n                    for (int ccnt = 0; ccnt < 4; ccnt++)\n                    {\n                        for (int scnt = 0; scnt < 2; scnt++)\n                        {\n                            Console.WriteLine(\"{0}{1}\",s[scnt],c[scnt][ccnt]);\n                        }\n                        string r = Console.ReadLine();\n                        if (r == \"T\")\n                        {\n                            for (int scnt = 0; scnt < 2; scnt++)\n                            {\n                                s[scnt] = s[scnt] + c[scnt][ccnt];\n                            }\n                            continue;\n                        }\n                        else if (r == \"end\") return;\n                    }\n                    afterMode = false;\n                }\n                else//mae ni ireru\n                {\n                    for (int ccnt = 0; ccnt < 4; ccnt++)\n                    {\n                        for (int scnt = 0; scnt < 2; scnt++)\n                        {\n                            Console.WriteLine(\"{0}{1}\",c[scnt][ccnt] , s[scnt]);\n                        }\n                        string r = Console.ReadLine();\n                        if (r == \"T\")\n                        {\n                            for (int scnt = 0; scnt < 2; scnt++)\n                            {\n                                s[scnt] = c[scnt][ccnt] + s[scnt];\n                            }\n                            continue;\n                        }\n                        else if (r == \"end\") return;\n\n                    }\n                }\n            }\n            /*\n            for (int scnt = 0; scnt < 2; scnt++)\n            {\n                Console.WriteLine(s[scnt]);\n            }\n            */\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tif(N<4){\n\t\t\tfor(int i=0;i<(1<<(2*N));i++){\n\t\t\t\tchar[] ca = new char[2*N];\n\t\t\t\tfor(int k=0;k<2*N;k++){\n\t\t\t\t\tif(((i>>k)&1) == 1){\n\t\t\t\t\t\tca[k] = '#';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tca[k] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar res = Query(new String(ca));\n\t\t\t\tif(res ==\"end\"){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int  j=0;j<500;j++){\n\t\t\tQuery(\"##\");\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tString Query(String s){\n\t\tint n = s.Length/2;\n\t\tConsole.WriteLine(s.Substring(0,n) +\"\\n\" + s.Substring(n));\n\t\tConsole.Out.Flush();\n\t\treturn Console.ReadLine();\n\t}\n\t\n\tint N;\n\tpublic Sol(){\n\t\tN = ri();\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace d\n{\n    class Program\n    {\n        static string[][] c = new string[2][]; \n        static void Main(string[] args)\n        {\n            c[0] = new string[] { \"#\", \"#\", \".\", \".\" };\n            c[1] = new string[] { \"#\", \".\", \"#\", \".\" };\n            int n = int.Parse(Console.ReadLine());\n            string[] s = new string[2];\n            for (int i = 0; i < 2; i++)\n            {\n                s[i] = \"\";\n            }\n            bool afterMode = true;\n            while(s[0].Length < n)\n            {\n                if(afterMode)//ato ni ireru\n                {\n                    for (int ccnt = 0; ccnt < 4; ccnt++)\n                    {\n                        for (int scnt = 0; scnt < 2; scnt++)\n                        {\n                            Console.WriteLine(\"{0}{1}\",s[scnt],c[scnt][ccnt]);\n                        }\n                        string r = Console.ReadLine();\n                        if(r == \"T\")\n                        {\n                            for (int scnt = 0; scnt < 2; scnt++)\n                            {\n                                s[scnt] = s[scnt] + c[scnt][ccnt];\n                            }\n                            continue;\n                        }\n                    }\n                    afterMode = false;\n                }\n                else//mae ni ireru\n                {\n                    for (int ccnt = 0; ccnt < 4; ccnt++)\n                    {\n                        for (int scnt = 0; scnt < 2; scnt++)\n                        {\n                            Console.WriteLine(\"{0}{1}\",c[scnt][ccnt] , s[scnt]);\n                        }\n                        string r = Console.ReadLine();\n                        if (r == \"T\")\n                        {\n                            for (int scnt = 0; scnt < 2; scnt++)\n                            {\n                                s[scnt] = c[scnt][ccnt] + s[scnt];\n                            }\n                            continue;\n                        }\n                    }\n                }\n            }\n            for (int scnt = 0; scnt < 2; scnt++)\n            {\n                Console.WriteLine(s[scnt]);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "class Kokuban\n\n  attr_accessor :ary\n\n  def add_column(b, num)\n    tmp = Marshal.load(Marshal.dump(ary))\n    if (b)\n      # puts tmp\n      tmp << num\n    else\n      tmp.unshift(num)\n    end\n    return tmp\n  end\n\n  def Kokuban.flush(ary)\n    ans = [[], []]\n    ary.each{ |x|\n      if x == 0\n        ans[0] << '.'\n        ans[1] << '.'\n      elsif x == 1\n        ans[0] << '.'\n        ans[1] << '#'\n      elsif x == 2\n        ans[0] << '#'\n        ans[1] << '.'\n      else\n        ans[0] << '#'\n        ans[1] << '#'\n      end\n    }\n    puts ans[0].join(\"\")\n    puts ans[1].join(\"\")\n  end\n  \nend\n\nn = gets.to_i\nkokuban = Kokuban.new\nkokuban.ary = []\n\nbol = false\n\nwhile true\n  added = false\n  for i in 0..3\n    tmp = kokuban.add_column(bol, i)\n    Kokuban.flush(tmp)\n    r = gets.chomp\n    if r == \"end\"\n      exit\n    elsif r == 'T'\n      kokuban.ary = tmp\n      added = true\n      break\n    else\n      #\n    end\n  end\n  if added\n    #\n  else\n    # puts \"next state\"\n    bol = true\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class Kokuban\n\n  attr_accessor :ary\n\n  def add_column(b, num)\n    tmp = Marshal.load(Marshal.dump(ary))\n    if (b)\n      # puts tmp\n      tmp << num\n    else\n      tmp.unshift(num)\n    end\n    return tmp\n  end\n\n  def Kokuban.flush(ary)\n    ans = [[], []]\n    ary.each{ |x|\n      if x == 0\n        ans[0] << '.'\n        ans[1] << '.'\n      elsif x == 1\n        ans[0] << '.'\n        ans[1] << '#'\n      elsif x == 2\n        ans[0] << '#'\n        ans[1] << '.'\n      else\n        ans[0] << '#'\n        ans[1] << '#'\n      end\n    }\n    puts ans[0].join(\"\")\n    puts ans[1].join(\"\")\n    STDOUT.flush\n  end\n  \nend\n\nn = gets.to_i\nkokuban = Kokuban.new\nkokuban.ary = []\n\nbol = false\n\nwhile true\n  added = false\n  for i in 0..3\n    tmp = kokuban.add_column(bol, i)\n    Kokuban.flush(tmp)\n    r = gets.chomp\n    if r == \"end\"\n      exit\n    elsif r == 'T'\n      kokuban.ary = tmp\n      added = true\n      break\n    else\n      #\n    end\n  end\n  if added\n    #\n  else\n    # puts \"next state\"\n    bol = true\n  end\nend\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfscanf(STDIN, '%d', $N);\n$s1 = ['.', '.', '#', '#'];\n$s2 = ['.', '#', '.', '#'];\n$resS1 = '';\n$resS2 = '';\n$right = true;\nwhile ($N) {\n\t$idx = 0;\n\twhile ($idx < 4) {\n\t\tif ($right) {\n\t\t\techo $resS1.$s1[$idx].\"\\n\".$resS2.$s2[$idx].\"\\n\";\n\t\t} else {\n\t\t\techo $s1[$idx].$resS1.\"\\n\".$s2[$idx].$resS2.\"\\n\";\n\t\t}\n\t\tfscanf(STDIN, '%s', $R);\n\t\tif ($R === 'T') {\n\t\t\tif ($right) {\n\t\t\t\t$resS1 .= $s1[$idx];\n\t\t\t\t$resS2 .= $s2[$idx];\n\t\t\t} else {\n\t\t\t\t$resS1 = $s1[$idx].$resS1;\n\t\t\t\t$resS2 = $s2[$idx].$resS2;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t$idx++;\n\t}\n\tif ($idx === 4) {\n\t\t$right = !$right;\n\t} else {\n\t\t$N--;\n\t}\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\nfscanf(STDIN, '%d', $N);\n$s1 = ['.', '.', '#', '#'];\n$s2 = ['.', '#', '.', '#'];\n$resS1 = '';\n$resS2 = '';\n$right = true;\nwhile ($N) {\n\t$idx = 0;\n\twhile ($idx < 4) {\n\t\t$_resS1 = ($right) ? $resS1.$s1[$idx] : $s1[$idx].$resS1;\n\t\t$_resS2 = ($right) ? $resS2.$s2[$idx] : $s2[$idx].$resS2;\n\t\techo $_resS1.\"\\n\".$_resS2.\"\\n\";\n\t\tfscanf(STDIN, '%s', $R);\n\t\tif ($R === 'T') {\n\t\t\t$resS1 = $_resS1;\n\t\t\t$resS2 = $_resS2;\n\t\t\tbreak;\n\t\t}\n\t\t$idx++;\n\t}\n\tif ($idx === 4) {\n\t\t$right = !$right;\n\t} else {\n\t\t$N--;\n\t}\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\nfscanf(STDIN, '%d', $N);\n$s = ['.', '#'];\n$r1 = '';\n$r2 = '';\n$right = true;\nwhile ($N) {\n\t$idx = 0;\n\twhile ($idx < 4) {\n\t\t$_r1 = ($right) ? $r1.$s[floor($idx/2)] : $s[floor($idx/2)].$r1;\n\t\t$_r2 = ($right) ? $r2.$s[$idx%2] : $s[$idx%2].$r2;\n\t\techo $_r1.\"\\n\".$_r2.\"\\n\";\n\t\tfscanf(STDIN, '%s', $R);\n\t\tif ($R === 'T') {\n\t\t\t$r1 = $_r1;\n\t\t\t$r2 = $_r2;\n\t\t\tbreak;\n\t\t}\n\t\t$idx++;\n\t}\n\tif ($idx === 4) {\n\t\t$right = !$right;\n\t} else {\n\t\t$N--;\n\t}\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n\n    string d1 = \"..##\";\n    string d2 = \".#.#\";\n    string r1 = \"\";\n    string r2 = \"\";\n    bool right_end = false;\n    \n    while (true) {\n        bool t = false;\n        foreach (k; 0..4) {\n            if (right_end) {\n                r1 = d1[k] ~ r1;\n                r2 = d2[k] ~ r2;\n            }\n            else {\n                r1 = r1 ~ d1[k];\n                r2 = r2 ~ d2[k];\n            }\n            writeln(r1);\n            writeln(r2);\n            stdout.flush;\n            string tf = readln.chomp;\n            if (tf == \"T\") {\n                t = true;\n                break;\n            }\n            else if (tf == \"end\")\n                return;\n            \n            if (right_end) {\n                r1 = r1[1..$];\n                r2 = r2[1..$];\n            }\n            else {\n                r1 = r1[0..$-1];\n                r2 = r2[0..$-1];\n            }\n        }\n\n        if (!t) {\n            right_end = true;\n            N += 1;\n        }\n        \n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\n\n\nvoid main() {\n    auto N = readln.chomp.to!int;\n\n    string d1 = \"..##\";\n    string d2 = \".#.#\";\n    string r1 = \"\";\n    string r2 = \"\";\n    bool right_end = false;\n    \n    foreach (i; 0..N) {\n        bool t = false;\n        foreach (k; 0..4) {\n            if (right_end) {\n                r1 = d1[k] ~ r1;\n                r2 = d2[k] ~ r2;\n            }\n            else {\n                r1 = r1 ~ d1[k];\n                r2 = r2 ~ d2[k];\n            }\n            writeln(r1);\n            writeln(r2);\n            stdout.flush;\n            string tf = readln.chomp;\n            if (tf == \"T\" || tf == \"end\") {\n                t = true;\n                break;\n            }\n            if (right_end) {\n                r1 = r1[1..$];\n                r2 = r2[1..$];\n            }\n            else {\n                r1 = r1[0..$-1];\n                r2 = r2[0..$-1];\n            }\n        }\n\n        if (!t)\n            right_end = true;\n        \n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"C\"\n    dependency \"dcomp\" version=\">=0.3.2\"\n    lflags \"-stack_size\" \"100000000\"\n+/\n \nimport std.algorithm, std.conv, std.range, std.stdio;\nimport core.sys.posix.stdlib;\n\n// import dcomp.scanner;\n\nint n;\nScanner sc;\nstatic this(){\n    sc = new Scanner();\n}\n\nbool que(string[2] s) {\n    writeln(s[0]);\n    writeln(s[1]);\n    stdout.flush;\n    string buf;\n    sc.read(buf);\n    if (buf == \"end\") {\n        exit(0);\n    }\n    return buf == \"T\";\n}\n\nint main(string[] argv) {\n    sc.read(n);\n    string[2] s;\n    while (true) {\n        auto rng = iota(4).find!((i){\n            string s0 = s[0] ~ (i%2 ? \".\" : \"#\");\n            string s1 = s[1] ~ (i/2 ? \".\" : \"#\");\n            return que([s0, s1]);\n        });\n        if (rng.empty) break;\n        auto i = rng.front;\n        string s0 = s[0] ~ (i%2 ? \".\" : \"#\");\n        string s1 = s[1] ~ (i/2 ? \".\" : \"#\");\n        s = [s0, s1];\n    }\n    while (true) {\n        auto rng = iota(4).find!((i){\n            string s0 = (i%2 ? \".\" : \"#\") ~ s[0];\n            string s1 = (i/2 ? \".\" : \"#\") ~ s[1];\n            return que([s0, s1]);\n        });\n        if (rng.empty) break;\n        auto i = rng.front;\n        string s0 = (i%2 ? \".\" : \"#\") ~ s[0];\n        string s1 = (i/2 ? \".\" : \"#\") ~ s[1];\n        s = [s0, s1];\n    }\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File, stdin;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f = stdin) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\ns1=''\ns2=''\nptn=[('.','.'),('.','#'),('#','.'),('#','#')]\nfor i in range(n):\n    for j in range(4):\n        print(s1+ptn[j][0],flush=True)\n        print(s2+ptn[j][1],flush=True)\n        r = input()\n        if r=='T':\n            s1+=ptn[j][0]\n            s2+=ptn[j][1]\n            break\n        elif r=='end':\n            exit(0)\n    else:\n        break\nfor i in range(n):\n    for j in range(4):\n        print(ptn[j][0]+s1,flush=True)\n        print(ptn[j][1]+s2,flush=True)\n        r = input()\n        if r=='T':\n            s1=ptn[j][0]+s1\n            s2=ptn[j][1]+s2\n            break\n        elif r=='end':\n            exit(0)\n    else:\n        break\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef solve():\n\tdss = [(\".\",\".\"),(\".\",\"#\"),(\"#\",\".\"),(\"#\",\"#\")]\n\ttmp_dss = []\n\tN = map(int,raw_input().split())\n\tfor ds in dss:\n\t\tprint \"{0}\\n{1}\".format(*ds)\n\t\tsys.stdout.flush()\n\t\tif raw_input() == \"T\":\n\t\t\ttmp_dss.append(ds)\n\tans = list(dss[0])\n\tdss = tmp_dss\n\tr_b = l_b = True\n\twhile True:\n\t\tif r_b:\n\t\t\tfor ds in dss:\n\t\t\t\ttmp = (ans[0] + ds[0],ans[1]+ds[1])\n\t\t\t\tprint \"{0}\\n{1}\".format(*tmp)\n\t\t\t\tsys.stdout.flush()\n\t\t\t\tres = raw_input()\n\t\t\t\tif res == \"end\": return\n\t\t\t\tif res == \"T\":\n\t\t\t\t\tans = tmp\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tr_b = False\n\t\tif l_b:\n\t\t\tfor ds in dss:\n\t\t\t\ttmp = (ds[0] + ans[0],ds[1] + ans[1])\n\t\t\t\tprint \"{0}\\n{1}\".format(*tmp)\n\t\t\t\tsys.stdout.flush()\n\t\t\t\tres = raw_input()\n\t\t\t\tif res == \"end\": return\n\t\t\t\tif res == \"T\":\n\t\t\t\t\tans = tmp\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tl_b = False\nsolve()"
  },
  {
    "language": "Python",
    "code": "import sys\nN = int(input())\n\ns1 = \"\"\ns2 = \"\"\n\nsgn1 = \"..##\"\nsgn2 = \".#.#\"\n\nflag = False\nwhile True:\n    if flag == False:\n        flag = True\n        for i in range(4):\n            s1 += sgn1[i]\n            s2 += sgn2[i]\n            print(s1 + \"\\n\" + s2)\n            r = input()\n            if r == \"end\":\n                sys.exit(0)\n            elif r == \"T\":\n                flag = False\n                break\n            else:\n                s1 = s1[:-1]\n                s2 = s2[:-1]\n\n    if flag == True:\n        for i in range(4):\n            s1 = sgn1[i] + s1\n            s2 = sgn2[i] + s2\n            print(s1 + \"\\n\" + s2)\n            r = input()\n            if r == \"end\":\n                sys.exit(0)\n            elif r == \"T\":\n                break\n            else:\n                s1 = s1[1:]\n                s2 = s2[1:]"
  },
  {
    "language": "Python",
    "code": "def read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split(sep)))\n\ndef main():\n    n = read()\n    d = ['..', '.#', '#.', '##']\n    s1 = s2 = ''\n    flag = True\n    i = 0\n    while True:\n        if flag:\n            print(s1 + d[i%4][0], flush=True)\n            print(s2 + d[i%4][1], flush=True)\n        else:\n            print(d[i%4][0] + s1, flush=True)\n            print(d[i%4][1] + s2, flush=True)\n        r = input()\n        if r == 'T':\n            if flag:\n                s1 = s1 + d[i%4][0]\n                s2 = s2 + d[i%4][1]\n            else:\n                s1 = d[i%4][0] + s1\n                s2 = d[i%4][1] + s2\n            i = -1\n        elif r == 'F':\n            if i == 3:\n                i = -1\n                flag = False\n        else:\n            return\n        i += 1\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split(sep)))\n\ndef main():\n    n = read()\n    d = ['..', '.#', '#.', '##']\n    s1 = s2 = ''\n    i = 0\n    while i<n*4:\n        print(s1 + d[i%4][0], flush=True)\n        print(s2 + d[i%4][1], flush=True)\n        r = input()\n        if r == 'T':\n            s1 += d[i%4][0]\n            s2 += d[i%4][1]\n            i = -1\n        elif r == 'F':\n            pass\n        else:\n            return\n        i += 1\n\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\nflush = sys.stdout.flush\nwrite = sys.stdout.write\n\nN = int(input())\n\nbb_1,bb_2 = \"..##\",\".#.#\"\nres_1,res_2 = \"\",\"\"\n\ndef ask(s1,s2):\n    write(res_1)\n    write(res_2)\n    result = input()\n    flush()\n    if result==\"end\":\n        exit()\n    return result==\"T\"\n\n# 右側に伸ばしていく\nwhile 1:\n    for i in range(4):\n        if ask(res_1+bb_1[i],res_2+bb_2[i]):\n            res_1 += bb_1[i]\n            res_2 += bb_2[i]\n            break\n    else:\n        break\n\n# 左側に伸ばしていく\nwhile 1:\n    for i in range(4):\n        if ask(bb_1[i]+res_1,bb_2[i]+res_2):\n            res_1 = bb_1[i] + res_1\n            res_2 = bb_2[i] + res_2\n            break\n    else:\n        break\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\ns1=\"\"\ns2=\"\"\ndamy=\"\"\nflag=False\n\nfor i in range(N):\n\tfor j in range(4):\n\t\tif j==0:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(damy+\".\",flush=True)\n\t\telif j==1:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(damy+\"#\",flush=True)\n\t\telif j==2:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(damy+\".\",flush=True)\n\t\telif j==3:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(damy+\"#\",flush=True)\n\t\t\n\t\ttemp=input()\n\t\tif temp==\"T\":\n\t\t\tif j==0:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==1:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\"#\"\n\t\t\telif j==2:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==3:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\"#\"\n\t\t\tdamy=\"\"\n\t\t\tfor i in s2[:-1]:\n\t\t\t\tif i==\".\":\n\t\t\t\t\tdamy+=\"#\"\n\t\t\t\telse:\n\t\t\t\t\tdamy+=\".\"\n\t\t\tdamy+=s2[-1]\n\t\t\tbreak\n\t\telif temp==\"end\":\n\t\t\tflag=True\n\t\t\tbreak\n\tif flag==True:\n\t\tbreak\nif not flag:\n\tprint(s1)\n\tprint(s2,flush=True)\n\ttemp=input()"
  },
  {
    "language": "Python",
    "code": "N=int(input())\ns1=\"\"\ns2=\"\"\ndamy=\"\"\nflag=False\n\nfor i in range(N):\n\tfor j in range(4):\n\t\tif j==0:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(damy+\".\",flush=True)\n\t\telif j==1:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(damy+\"#\",flush=True)\n\t\telif j==2:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(damy+\".\",flush=True)\n\t\telif j==3:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(damy+\"#\",flush=True)\n\t\t\n\t\ttemp=input()\n\t\tif temp==\"T\":\n\t\t\tif j==0:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==1:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\"#\"\n\t\t\telif j==2:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==3:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\"#\"\n\t\t\tdamy=\"\"\n\t\t\tfor i in s2:\n\t\t\t\tif i==\".\":\n\t\t\t\t\tdamy+=\"#\"\n\t\t\t\telse:\n\t\t\t\t\tdamy+=\".\"\n\t\t\tbreak\n\t\telif temp==\"end\":\n\t\t\tflag=True\n\t\t\tbreak\n\tif flag==True:\n\t\tbreak\nprint(s1)\nprint(s2,flush=True)\ntemp=input()"
  },
  {
    "language": "Python",
    "code": "import sys\nflush = sys.stdout.flush\nwrite = sys.stdout.write\n\nN = int(input())\n\nbb_1,bb_2 = \"..##\",\".#.#\"\nres_1,res_2 = \"\",\"\"\n\ndef ask(s1,s2):\n    write(s1+'\\n'+s2+'\\n')\n    result = input()\n    flush()\n    if result==\"end\":\n        exit()\n    return result==\"T\"\n\n# 右側に伸ばしていく\nwhile 1:\n    for i in range(4):\n        if ask(res_1+bb_1[i],res_2+bb_2[i]):\n            res_1 += bb_1[i]\n            res_2 += bb_2[i]\n            break\n    else:\n        break\n\n# 左側に伸ばしていく\nwhile 1:\n    for i in range(4):\n        if ask(bb_1[i]+res_1,bb_2[i]+res_2):\n            res_1 = bb_1[i] + res_1\n            res_2 = bb_2[i] + res_2\n            break\n    else:\n        break\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef solve():\n\tdss = [(\".\",\".\"),(\".\",\"#\"),(\"#\",\".\"),(\"#\",\"#\")]\n\ttmp_dss = []\n\tN = map(int,raw_input().split())\n\tfor ds in dss:\n\t\tprint \"{0}\\n{1}\\n\".format(*ds)\n\t\tsys.stdout.flush()\n\t\tif raw_input() == \"T\":\n\t\t\ttmp_dss.append(ds)\n\tans = list(dss[0])\n\tdss = tmp_dss\n\tr_b = l_b = True\n\twhile True:\n\t\tif r_b:\n\t\t\tfor ds in dss:\n\t\t\t\ttmp = (ans[0] + ds[0],ans[1]+ds[1])\n\t\t\t\tprint \"{0}\\n{1}\\n\".format(*tmp)\n\t\t\t\tsys.stdout.flush()\n\t\t\t\tres = raw_input()\n\t\t\t\tif res == \"end\": return\n\t\t\t\tif res == \"T\":\n\t\t\t\t\tans = tmp\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tr_b = False\n\t\tif l_b:\n\t\t\tfor ds in dss:\n\t\t\t\ttmp = (ds[0] + ans[0],ds[1] + ans[1])\n\t\t\t\tprint \"{0}\\n{1}\\n\".format(*tmp)\n\t\t\t\tsys.stdout.flush()\n\t\t\t\tres = raw_input()\n\t\t\t\tif res == \"end\": return\n\t\t\t\tif res == \"T\":\n\t\t\t\t\tans = tmp\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tl_b = False\nsolve()"
  },
  {
    "language": "Python",
    "code": "import sys\nN = int(raw_input())\nupper = list()\nlower = list()\n\nright_end = 0\nsearch_end = 0 \nwhile True:\n    if right_end == 0:\n        for q in [['.', '.'], ['.', '#'], ['#', '.'], ['#', '#']]:\n            print \"\".join(upper + [q[0]])\n            print \"\".join(lower + [q[1]])\n            sys.stdout.flush()\n\n            r = raw_input()\n            if r == 'T':\n                upper.append(q[0])\n                lower.append(q[1])\n                break\n            elif r == 'end':\n                search_end = 1\n                break\n            if r == 'F' and q == ['#', '#']:\n                right_end = 1\n    else:\n        for q in [['.', '.'], ['.', '#'], ['#', '.'], ['#', '#']]:\n            print \"\".join([q[0]] + upper)\n            print \"\".join([q[1]] + lower)\n            sys.stdout.flush()\n            \n            r = raw_input()\n            if r == 'T':\n                upper.insert(0,q[0])\n                lower.insert(0,q[1])\n                break\n            elif r == 'end':\n                search_end = 1\n                break\n    if search_end == 1:\n        break\n\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdout\nn = int(raw_input())\ndef req(b):\n    print b[0]\n    print b[1]\n    stdout.flush()\n    return raw_input().strip()\ns = ['..', '.#', '#.', '##']\na = ['', '']\nwhile 1:\n    for t in s:\n        b = [a[0] + t[0], a[1] + t[1]]\n        r = req(b)\n        if r == 'end':\n            quit()\n        if r == 'T':\n            a = b\n            break\n    else:\n        break\nwhile 1:\n    for t in s:\n        b = [t[0] + a[0], t[1] + a[1]]\n        r = req(b)\n        if r == 'end':\n            quit()\n        if r == 'T':\n            a - b\n            break\n    else:\n        break\nfrom sys import stdout\nn = int(raw_input())\ndef req(b):\n    print b[0]\n    print b[1]\n    stdout.flush()\n    return raw_input().strip()\ns = ['..', '.#', '#.', '##']\na = ['', '']\nwhile 1:\n    for t in s:\n        b = [a[0] + t[0], a[1] + t[1]]\n        r = req(b)\n        if r == 'end':\n            quit()\n        if r == 'T':\n            a = b\n            break\n    else:\n        break\nwhile 1:\n    for t in s:\n        b = [t[0] + a[0], t[1] + a[1]]\n        r = req(b)\n        if r == 'end':\n            quit()\n        if r == 'T':\n            a - b\n            break\n    else:\n        break\n"
  },
  {
    "language": "Python",
    "code": "import sys\nflush = sys.stdout.flush\nwrite = sys.stdout.write\nreadline = sys.stdin.readline\nN = int(readline())\nQ0 = \"\"\nQ1 = \"\"\n\nq0 = \"..##\"\nq1 = \".#.#\"\n\ndef query(Q0, Q1):\n    write(\"%s\\n%s\\n\" % (Q0, Q1))\n    flush()\n    r = readline()\n    if r == \"end\\n\":\n        exit(0)\n    return r == \"T\\n\"\n\nwhile len(Q0) < N:\n    for i in range(4):\n        if query(Q0+q0[i], Q1+q1[i]):\n            Q0 += q0[i]\n            Q1 += q1[i]\n            break\n    else:\n        break\nwhile len(Q0) < N:\n    for i in range(4):\n        if query(q0[i]+Q0, q1[i]+Q1):\n            Q0 = q0[i] + Q0\n            Q1 = q1[i] + Q1\n            break\n    else:\n        break\nexit(1)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nimport itertools\n\n# DEBUG = True\nDEBUG = False\n\nN = int(readline())\n\nclass Interactive:\n    def __init__(self):\n        self.ques_cnt = 0\n        self.create_data()\n        \n    def create_data(self):\n        import random\n        self.upper = ''.join(random.choice('.#') for _ in range(N))\n        self.lower = ''.join(random.choice('.#') for _ in range(N))\n        print('created upper:', self.upper)\n        print('created lower:', self.lower)\n        \n    def resp_ques(self, *args):\n        self.ques_cnt += 1\n        if len(args) != 1:\n            raise ValueError('不正な質問', args)\n        S,T = args[0].split()\n        L = len(S)\n        for i in range(N):\n            if S == self.lower[i:i+L] and T == self.upper[i:i+L]:\n                if len(S) == N:\n                    return 'end\\n'\n                else:\n                    return 'T\\n'\n        return 'F\\n'\n            \n    def resp_ans(self, *args):\n        pass\n            \nif DEBUG:\n    interactive = Interactive()\n    \ndef question(*args, offset=None):\n    if offset is None:\n        print(*args, flush=True)\n    else:\n        print(offset, *args, flush=True)\n    if DEBUG:\n        resp = interactive.resp_ques(*args)\n        print(resp)\n        return resp\n    else:\n        return readline()\n    \ndef answer(*args, offset=None):\n    if offset is None:\n        print(*args, flush=True)\n    else:\n        print(offset, *args, flush=True)\n    if DEBUG:\n        interactive.resp_ans(*args)\n    else:\n        exit()\n\ncol_patterns = tuple(itertools.product('.#', repeat=2))\n\ndef find_some_col():\n    for S,T in col_patterns:\n        resp = question(S + '\\n' + T).rstrip()\n        if resp == 'T':\n            return S,T\n        if resp == 'end':\n            exit()\n\ndef extend_left(S,T):\n    while True:\n        flag = False\n        for s,t in col_patterns:\n            resp = question(s + S + '\\n' + t + T).rstrip()\n            if resp == 'T':\n                flag = True\n                S = s + S\n                T = t + T\n                break\n            elif resp == 'end':\n                exit()\n        if not flag:\n            return S,T\n\ndef extend_right(S,T):\n    while True:\n        flag = False\n        for s,t in col_patterns:\n            resp = question(S + s + '\\n' + T + t).rstrip()\n            if resp == 'T':\n                flag = True\n                S = S + s\n                T = T + t\n                break\n            elif resp == 'end':\n                exit()\n        if not flag:\n            return S,T\n\nS,T = find_some_col()\nS,T = extend_left(S,T)\nS,T = extend_right(S,T)"
  },
  {
    "language": "Python",
    "code": "def read():\n    return int(input())\n\ndef reads(sep=None):\n    return list(map(int, input().split(sep)))\n\ndef main():\n    n = read()\n    d = ['..', '.#', '#.', '##']\n    s1 = s2 = ''\n    i = 0\n    while True:\n        print(s1 + d[i%4][0], flush=True)\n        print(s2 + d[i%4][1], flush=True)\n        r = input()\n        if r == 'T':\n            s1 += d[i%4][0]\n            s2 += d[i%4][1]\n            i = -1\n        elif r == 'F':\n            pass\n        else:\n            return\n        i += 1\n\nmain()"
  },
  {
    "language": "Python",
    "code": "N=int(input())\ns1=\"\"\ns2=\"\"\ndamy=\"\"\nflag=False\n\nfor i in range(N):\n\tfor j in range(4):\n\t\tif j==0:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(damy+\".\",flush=True)\n\t\telif j==1:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(damy+\"#\",flush=True)\n\t\telif j==2:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(damy+\".\",flush=True)\n\t\telif j==3:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(damy+\"#\",flush=True)\n\t\t\n\t\ttemp=input()\n\t\tif temp==\"T\":\n\t\t\tif j==0:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==1:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\"#\"\n\t\t\telif j==2:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==3:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\"#\"\n\t\t\tdamy=\"\"\n\t\t\tfor i in s2:\n\t\t\t\tif i==\".\":\n\t\t\t\t\tdamy+=\"#\"\n\t\t\t\telse:\n\t\t\t\t\tdamy+=\".\"\n\t\t\tbreak\n\t\telif temp==\"end\":\n\t\t\tflag=True\n\t\t\tbreak\n\tif flag==True:\n\t\tbreak"
  },
  {
    "language": "Python",
    "code": "N=int(input())\ns1=\"\"\ns2=\"\"\nflag=False\n\nfor i in range(N):\n\tfor j in range(4):\n\t\tif j==0:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(s2+\".\",flush=True)\n\t\telif j==1:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(s2+\"#\",flush=True)\n\t\telif j==2:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(s2+\".\",flush=True)\n\t\telif j==3:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(s2+\"#\",flush=True)\n\t\t\n\t\ttemp=input()\n\t\tif temp==\"T\":\n\t\t\tif j==0:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==1:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\"#\"\n\t\t\telif j==2:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==3:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\"#\"\n\t\telif temp==\"end\":\n\t\t\tflag=True\n\t\t\tbreak\n\tif flag==True:\n\t\tbreak"
  },
  {
    "language": "Python",
    "code": "import sys\nN = int(input())\n\ns1 = \"\"\ns2 = \"\"\n\nsgn1 = \"..##\"\nsgn2 = \".#.#\"\n\nflag = False\nwhile True:\n    if flag == False:\n        flag = True\n        for i in range(4):\n            s1 += sgn1[i]\n            s2 += sgn2[i]\n            print(s1 + \"\\n\" + s2)\n            r = input()\n            if r == \"end\":\n                sys.exit(0)\n            elif r == \"T\":\n                flag = False\n                break\n            else:\n                s1 = s1[:-1]\n                s2 = s2[:-1]\n\n    if flag == True:\n        for i in range(4):\n            s1 = sgn1[i] + s1\n            s2 = sgn2[i] + s2\n            print(s1 + \"\\n\" + s2)\n            r = input()\n            if r == \"end\":\n                sys.exit(0)\n            elif r == \"T\":\n                flag = False\n                break\n            else:\n                s1 = s1[1:]\n                s2 = s2[1:]"
  },
  {
    "language": "Python",
    "code": "N = input()\nempty = [\"\" for _ in range(2)]\n\ndef searchright(knowledge):\n    for u in [\".\", \"#\"]:\n        for l in [\".\", \"#\"]:\n            hypothesis = [knowledge[0] + u, knowledge[1] + l]\n            print(\"\\n\".join(hypothesis))\n            p = input()\n            if p == \"T\":\n                return searchright(hypothesis)\n            elif p==\"end\":\n                exit()\n    return knowledge\n\ndef searchleft(knowledge):\n    for u in [\".\", \"#\"]:\n        for l in [\".\", \"#\"]:\n            hypothesis = [u + knowledge[0], l + knowledge[1]]\n            print(\"\\n\".join(hypothesis))\n            p = input()\n            if p == \"T\":\n                return searchleft(hypothesis)\n            elif p==\"end\":\n                exit()\n    return knowledge\n\nprint(searchleft(searchright(empty)))"
  },
  {
    "language": "Python",
    "code": "N = int(raw_input())\n\nupper = list()\nlower = list()\n\nright_end = 0\nsearch_end = 0 \nwhile True:\n    if right_end == 0:\n        for q in [['.', '.'], ['.', '#'], ['#', '.'], ['#', '#']]:\n            print \"\".join(upper + [q[0]])\n            print \"\".join(lower + [q[1]])\n\n            r = raw_input()\n            if r == 'T':\n                upper.append(q[0])\n                lower.append(q[1])\n                break\n            elif r == 'end':\n                search_end = 1\n                break\n            if r == 'F' and q == ['#', '#']:\n                right_end = 1\n    else:\n        for q in [['.', '.'], ['.', '#'], ['#', '.'], ['#', '#']]:\n            print \"\".join([q[0]] + upper)\n            print \"\".join([q[1]] + lower)\n            \n            r = raw_input()\n            if r == 'T':\n                upper.insert(0,q[0])\n                lower.insert(0,q[1])\n                break\n            elif r == 'end':\n                search_end = 1\n                break\n    if search_end == 1:\n        break\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef solve():\n\tdss = [(\".\",\".\"),(\".\",\"#\"),(\"#\",\".\"),(\"#\",\"#\")]\n\ttmp_dss = []\n\tN = map(int,raw_input().split())\n\tfor ds in dss:\n\t\tprint \"{0}\\n{1}\".format(*ds)\n\t\tsys.stdout.flush()\n\t\tif raw_input() == \"T\":\n\t\t\ttmp_dss.append(ds)\n\tans = list(dss[0])\n\tdss = tmp_dss\n\tr_b = l_b = True\n\twhile True:\n\t\tif r_b:\n\t\t\tfor ds in dss:\n\t\t\t\ttmp = (ans[0] + ds[0],ans[1]+ds[1])\n\t\t\t\tprint \"{0}\\n{1}\".format(*tmp)\n\t\t\t\tsys.stdout.flush()\n\t\t\t\tres = raw_input()\n\t\t\t\tif res == \"end\": return\n\t\t\t\tif res == \"T\":\n\t\t\t\t\tans = tmp\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tr_b = False\n\t\tif l_b:\n\t\t\tfor ds in dss:\n\t\t\t\ttmp = (ds[0] + ans[0],ds[1] + ans[1])\n\t\t\t\tprint \"{0}\\n{1}\".format(*tmp)\n\t\t\t\tsys.stdout.flush()\n\t\t\t\tres = raw_input()\n\t\t\t\tif res == \"end\": return\n\t\t\t\tif res == \"T\":\n\t\t\t\t\tans = tmp\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tl_b = False\nsolve()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys,copy,math,heapq,itertools as it,fractions,re,bisect,collections as coll\nimport random\n\nN = int(raw_input())\nt = [[\".\",\".\"], [\".\", \"#\"], [\"#\", \".\"], [\"#\", \"#\"]]\ns1, s2 = \"\", \"\"\n\nleft = True\nfor loop in xrange(421):\n    random.shuffle(t)\n    if left:\n        for t1, t2 in t: \n            print \"\\n\".join([s1 + t1, s2 + t2])\n            sys.stdout.flush()\n            res = raw_input()\n            if res == \"T\":\n                s1 += t1\n                s2 += t2\n                break\n            if res == \"end\":\n                exit()\n        else:\n            left = False\n\n    if not left:\n        for t1, t2 in t:\n            print \"\\n\".join([t1 + s1, t2 + s2])\n            sys.stdout.flush()\n            res = raw_input()\n            if res == \"T\":\n                s1 = t1 + s1\n                s2 = t2 + s2\n                break\n            if res == \"end\":\n                exit()\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdout\nn = int(raw_input())\ndef req(b):\n    print b[0]\n    print b[1]\n    stdout.flush()\n    return raw_input().strip()\ns = ['..', '.#', '#.', '##']\na = ['', '']\nwhile 1:\n    for t in s:\n        b = [a[0] + t[0], a[1] + t[1]]\n        r = req(b)\n        if r == 'end':\n            quit()\n        if r == 'T':\n            a = b\n            break\n    else:\n        break\nwhile 1:\n    for t in s:\n        b = [t[0] + a[0], t[1] + a[1]]\n        r = req(b)\n        if r == 'end':\n            quit()\n        if r == 'T':\n            a = b\n            break\n    else:\n        break\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\ndef query(s1,s2):\n\tprint \"{0}\\n{1}\".format(\"\".join(s1),\"\".join(s2))\n\tsys.stdout.flush()\n\treturn raw_input()\ndef solve():\n\tdss = [(\".\",\".\"),(\".\",\"#\"),(\"#\",\".\"),(\"#\",\"#\")]\n\ttmp_dss = []\n\tN = map(int,raw_input().split())\n\tfor ds in dss:\n\t\tres = query([ds[0]],[ds[1]])\n\t\tif res == \"T\": tmp_dss.append(ds)\n\tdss = tmp_dss\n\ts1 = deque(dss[0][0]); s2 = deque(dss[0][1]) \n\tfor _ in xrange(420):\n\t\t#right\n\t\tfor ds1,ds2 in dss:\n\t\t\ts1.append(ds1); s2.append(ds2)\n\t\t\tres = query(s1,s2)\n\t\t\tif res == \"end\": return\n\t\t\tif res == \"T\": break\n\t\t\ts1.pop();s2.pop()\n\t\telse:\n\t\t\tbreak\n\tfor _ in xrange(420):\n\t\t#left\n\t\tfor ds1,ds2 in dss:\n\t\t\ts1.appendleft(ds1); s2.appendleft(ds2)\n\t\t\tres = query(s1,s2)\n\t\t\tif res == \"end\": return\n\t\t\tif res == \"T\": break\n\t\t\ts1.popleft();s2.popleft()\nsolve()"
  },
  {
    "language": "Python",
    "code": "N = int(raw_input())\n\nupper = list()\nlower = list()\n\nright_end = 0\nsearch_end = 0 \nwhile True:\n    if right_end == 0:\n        for q in [['.', '.'], ['.', '#'], ['#', '.'], ['#', '#']]:\n            print \"\".join(upper + [q[0]])\n            print \"\".join(lower + [q[1]])\n\n            r = raw_input()\n            if r == 'T':\n                upper.append(q[0])\n                lower.append(q[1])\n                if len(upper) == N:\n                    search_end = 1\n                break\n            if r == 'F' and q == ['#', '#']:\n                right_end = 1\n    else:\n        for q in [['.', '.'], ['.', '#'], ['#', '.'], ['#', '#']]:\n            print \"\".join([q[0]] + upper)\n            print \"\".join([q[1]] + lower)\n            \n            r = raw_input()\n            if r == 'T':\n                upper.insert(0,q[0])\n                lower.insert(0,q[1])\n                if len(upper) == N:\n                    search_end = 1\n                break\n    if search_end == 1:\n        break\n\n\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\ns1=\"\"\ns2=\"\"\nflag=False\n\nfor i in range(N):\n\tfor j in range(4):\n\t\tif j==0:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(s2+\".\",flush=True)\n\t\telif j==1:\n\t\t\tprint(s1+\".\")\n\t\t\tprint(s2+\"#\",flush=True)\n\t\telif j==2:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(s2+\".\",flush=True)\n\t\telif j==3:\n\t\t\tprint(s1+\"#\")\n\t\t\tprint(s2+\"#\",flush=True)\n\t\t\n\t\ttemp=input()\n\t\tif temp==\"T\":\n\t\t\tif j==0:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==1:\n\t\t\t\ts1+=\".\"\n\t\t\t\ts2+=\"#\"\n\t\t\telif j==2:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\".\"\n\t\t\telif j==3:\n\t\t\t\ts1+=\"#\"\n\t\t\t\ts2+=\"#\"\n\t\t\tbreak\n\t\telif temp==\"end\":\n\t\t\tflag=True\n\t\t\tbreak\n\tif flag==True:\n\t\tbreak"
  }
]