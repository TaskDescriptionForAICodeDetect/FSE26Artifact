[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_SIZE 20\n\ntypedef struct {\n    int x, y;\n    char dir;\n} Tank;\n\nvoid moveTank(char map[MAX_SIZE][MAX_SIZE], Tank *tank, int H, int W) {\n    int dx = 0, dy = 0;\n    switch (tank->dir) {\n        case 'U': dx = -1; break;\n        case 'D': dx = 1; break;\n        case 'L': dy = -1; break;\n        case 'R': dy = 1; break;\n    }\n    int nx = tank->x + dx;\n    int ny = tank->y + dy;\n    if (nx >= 0 && nx < H && ny >= 0 && ny < W && map[nx][ny] == '.') {\n        map[tank->x][tank->y] = '.';\n        tank->x = nx;\n        tank->y = ny;\n        map[tank->x][tank->y] = tank->dir == 'U' ? '^' :\n                                tank->dir == 'D' ? 'v' :\n                                tank->dir == 'L' ? '<' : '>';\n    }\n}\n\nvoid shoot(char map[MAX_SIZE][MAX_SIZE], Tank *tank, int H, int W) {\n    int dx = 0, dy = 0;\n    switch (tank->dir) {\n        case 'U': dx = -1; break;\n        case 'D': dx = 1; break;\n        case 'L': dy = -1; break;\n        case 'R': dy = 1; break;\n    }\n    int x = tank->x + dx;\n    int y = tank->y + dy;\n    while (x >= 0 && x < H && y >= 0 && y < W) {\n        if (map[x][y] == '*' || map[x][y] == '#') {\n            if (map[x][y] == '*') map[x][y] = '.';\n            break;\n        }\n        x += dx;\n        y += dy;\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    for (int t = 1; t <= T; t++) {\n        int H, W;\n        scanf(\"%d %d\", &H, &W);\n        char map[MAX_SIZE][MAX_SIZE];\n        Tank tank;\n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", map[i]);\n            for (int j = 0; j < W; j++) {\n                if (map[i][j] == '^' || map[i][j] == 'v' || map[i][j] == '<' || map[i][j] == '>') {\n                    tank.x = i;\n                    tank.y = j;\n                    tank.dir = map[i][j] == '^' ? 'U' :\n                               map[i][j] == 'v' ? 'D' :\n                               map[i][j] == '<' ? 'L' : 'R';\n                }\n            }\n        }\n        int N;\n        scanf(\"%d\", &N);\n        char commands[101];\n        scanf(\"%s\", commands);\n        for (int i = 0; i < N; i++) {\n            char cmd = commands[i];\n            if (cmd == 'S') {\n                shoot(map, &tank, H, W);\n            } else {\n                tank.dir = cmd;\n                moveTank(map, &tank, H, W);\n            }\n            map[tank.x][tank.y] = tank.dir == 'U' ? '^' :\n                                  tank.dir == 'D' ? 'v' :\n                                  tank.dir == 'L' ? '<' : '>';\n        }\n        printf(\"#%d \", t);\n        for (int i = 0; i < H; i++) {\n            printf(\"%s\", map[i]);\n            if (i != H - 1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:09:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int H, W, N;\n    cin >> H >> W;\n    vector<string> map(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> map[i];\n    }\n    cin >> N;\n    string operations;\n    cin >> operations;\n\n    int x = -1, y = -1;\n    char dir;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (map[i][j] == '^' || map[i][j] == 'v' || map[i][j] == '<' || map[i][j] == '>') {\n                y = i;\n                x = j;\n                dir = map[i][j];\n                map[i][j] = '.';\n                break;\n            }\n        }\n        if (x != -1) break;\n    }\n\n    for (char op : operations) {\n        if (op == 'U') {\n            dir = '^';\n            if (y - 1 >= 0 && map[y - 1][x] == '.') {\n                y--;\n            }\n        } else if (op == 'D') {\n            dir = 'v';\n            if (y + 1 < H && map[y + 1][x] == '.') {\n                y++;\n            }\n        } else if (op == 'L') {\n            dir = '<';\n            if (x - 1 >= 0 && map[y][x - 1] == '.') {\n                x--;\n            }\n        } else if (op == 'R') {\n            dir = '>';\n            if (x + 1 < W && map[y][x + 1] == '.') {\n                x++;\n            }\n        } else if (op == 'S') {\n            int dx = 0, dy = 0;\n            if (dir == '^') dy = -1;\n            else if (dir == 'v') dy = 1;\n            else if (dir == '<') dx = -1;\n            else if (dir == '>') dx = 1;\n\n            int nx = x + dx;\n            int ny = y + dy;\n            while (nx >= 0 && nx < W && ny >= 0 && ny < H) {\n                if (map[ny][nx] == '*') {\n                    map[ny][nx] = '.';\n                    break;\n                } else if (map[ny][nx] == '#') {\n                    break;\n                }\n                nx += dx;\n                ny += dy;\n            }\n        }\n    }\n\n    map[y][x] = dir;\n    for (const string& row : map) {\n        cout << row << '\\n';\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class BattleTown {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n        \n        for (int t = 0; t < T; t++) {\n            int H = scanner.nextInt();\n            int W = scanner.nextInt();\n            scanner.nextLine(); // consume newline\n            \n            char[][] map = new char[H][W];\n            int tankX = -1, tankY = -1;\n            char tankDir = '^';\n            \n            for (int i = 0; i < H; i++) {\n                String line = scanner.nextLine();\n                for (int j = 0; j < W; j++) {\n                    map[i][j] = line.charAt(j);\n                    if (map[i][j] == '^' || map[i][j] == 'v' || map[i][j] == '<' || map[i][j] == '>') {\n                        tankX = i;\n                        tankY = j;\n                        tankDir = map[i][j];\n                    }\n                }\n            }\n            \n            int N = scanner.nextInt();\n            scanner.nextLine(); // consume newline\n            String commands = scanner.nextLine();\n            \n            for (int i = 0; i < N; i++) {\n                char cmd = commands.charAt(i);\n                if (cmd == 'S') {\n                    int dx = 0, dy = 0;\n                    switch (tankDir) {\n                        case '^': dx = -1; break;\n                        case 'v': dx = 1; break;\n                        case '<': dy = -1; break;\n                        case '>': dy = 1; break;\n                    }\n                    int bulletX = tankX + dx;\n                    int bulletY = tankY + dy;\n                    while (bulletX >= 0 && bulletX < H && bulletY >= 0 && bulletY < W) {\n                        if (map[bulletX][bulletY] == '*') {\n                            map[bulletX][bulletY] = '.';\n                            break;\n                        } else if (map[bulletX][bulletY] == '#') {\n                            break;\n                        }\n                        bulletX += dx;\n                        bulletY += dy;\n                    }\n                } else {\n                    char newDir = '^';\n                    switch (cmd) {\n                        case 'U': newDir = '^'; break;\n                        case 'D': newDir = 'v'; break;\n                        case 'L': newDir = '<'; break;\n                        case 'R': newDir = '>'; break;\n                    }\n                    tankDir = newDir;\n                    map[tankX][tankY] = newDir;\n                    \n                    int newX = tankX;\n                    int newY = tankY;\n                    switch (cmd) {\n                        case 'U': newX = tankX - 1; break;\n                        case 'D': newX = tankX + 1; break;\n                        case 'L': newY = tankY - 1; break;\n                        case 'R': newY = tankY + 1; break;\n                    }\n                    \n                    if (newX >= 0 && newX < H && newY >= 0 && newY < W && map[newX][newY] == '.') {\n                        map[tankX][tankY] = '.';\n                        tankX = newX;\n                        tankY = newY;\n                        map[tankX][tankY] = tankDir;\n                    }\n                }\n            }\n            \n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    System.out.print(map[i][j]);\n                }\n                System.out.println();\n            }\n            if (t < T - 1) {\n                System.out.println();\n            }\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:10:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BattleTown {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read map dimensions\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        scanner.nextLine();\n        \n        // Read map\n        char[][] map = new char[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            map[i] = scanner.nextLine().toCharArray();\n        }\n        \n        // Read initial tank position\n        int tankRow = scanner.nextInt();\n        int tankCol = scanner.nextInt();\n        scanner.nextLine();\n        \n        // Read tank direction\n        char tankDirection = scanner.nextLine().charAt(0);\n        \n        // Read sequence of commands\n        String commands = scanner.nextLine();\n        \n        // Process commands\n        for (char command : commands.toCharArray()) {\n            if (command == 'M') {\n                // Move tank based on current direction\n                switch (tankDirection) {\n                    case 'N':\n                        if (tankRow > 0 && map[tankRow-1][tankCol] == '.') {\n                            tankRow--;\n                        }\n                        break;\n                    case 'S':\n                        if (tankRow < rows-1 && map[tankRow+1][tankCol] == '.') {\n                            tankRow++;\n                        }\n                        break;\n                    case 'W':\n                        if (tankCol > 0 && map[tankRow][tankCol-1] == '.') {\n                            tankCol--;\n                        }\n                        break;\n                    case 'E':\n                        if (tankCol < cols-1 && map[tankRow][tankCol+1] == '.') {\n                            tankCol++;\n                        }\n                        break;\n                }\n            } else {\n                // Change tank direction\n                tankDirection = command;\n            }\n        }\n        \n        // Print final map\n        map[tankRow][tankCol] = 'T';\n        for (char[] row : map) {\n            System.out.println(new String(row));\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:10:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_MAP_SIZE 100\n\n// Function to simulate tank movement based on input sequence\nvoid moveTank(char map[MAX_MAP_SIZE][MAX_MAP_SIZE], int rows, int cols, char* commands) {\n    int tankRow = -1, tankCol = -1;\n    \n    // Find initial tank position\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (map[i][j] == '^' || map[i][j] == 'v' || map[i][j] == '<' || map[i][j] == '>') {\n                tankRow = i;\n                tankCol = j;\n                break;\n            }\n            if (tankRow != -1) break;\n        }\n    }\n\n    // Process each command\n    for (int i = 0; i < strlen(commands); i++) {\n        char currentDirection = map[tankRow][tankCol];\n        \n        switch(commands[i]) {\n            case 'U':\n                if (currentDirection == '^') {\n                    if (tankRow > 0 && map[tankRow-1][tankCol] == '.') {\n                        map[tankRow][tankCol] = '.';\n                        tankRow--;\n                        map[tankRow][tankCol] = '^';\n                    }\n                } else {\n                    map[tankRow][tankCol] = '^';\n                }\n                break;\n            \n            case 'D':\n                if (currentDirection == 'v') {\n                    if (tankRow < rows-1 && map[tankRow+1][tankCol] == '.') {\n                        map[tankRow][tankCol] = '.';\n                        tankRow++;\n                        map[tankRow][tankCol] = 'v';\n                    }\n                } else {\n                    map[tankRow][tankCol] = 'v';\n                }\n                break;\n            \n            case 'L':\n                if (currentDirection == '<') {\n                    if (tankCol > 0 && map[tankRow][tankCol-1] == '.') {\n                        map[tankRow][tankCol] = '.';\n                        tankCol--;\n                        map[tankRow][tankCol] = '<';\n                    }\n                } else {\n                    map[tankRow][tankCol] = '<';\n                }\n                break;\n            \n            case 'R':\n                if (currentDirection == '>') {\n                    if (tankCol < cols-1 && map[tankRow][tankCol+1] == '.') {\n                        map[tankRow][tankCol] = '.';\n                        tankCol++;\n                        map[tankRow][tankCol] = '>';\n                    }\n                } else {\n                    map[tankRow][tankCol] = '>';\n                }\n                break;\n        }\n    }\n}\n\nint main() {\n    int rows, cols;\n    char map[MAX_MAP_SIZE][MAX_MAP_SIZE];\n    char commands[MAX_MAP_SIZE];\n\n    // Read map dimensions\n    scanf(\"%d %d\", &rows, &cols);\n    \n    // Read map\n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", map[i]);\n    }\n\n    // Read commands\n    scanf(\"%s\", commands);\n\n    // Move tank\n    moveTank(map, rows, cols, commands);\n\n    // Print final map\n    for (int i = 0; i < rows; i++) {\n        printf(\"%s\\n\", map[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<vector<int>> map(N, vector<int>(M));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> map[i][j];\n        }\n    }\n    \n    int x, y, direction;\n    cin >> x >> y >> direction;\n    \n    string commands;\n    cin >> commands;\n    \n    for (char cmd : commands) {\n        if (cmd == 'F') {\n            if (direction == 0 && x > 0 && map[x-1][y] == 1) x--;\n            else if (direction == 1 && y < M-1 && map[x][y+1] == 1) y++;\n            else if (direction == 2 && x < N-1 && map[x+1][y] == 1) x++;\n            else if (direction == 3 && y > 0 && map[x][y-1] == 1) y--;\n        }\n        else if (cmd == 'R') {\n            direction = (direction + 1) % 4;\n        }\n        else if (cmd == 'L') {\n            direction = (direction - 1 + 4) % 4;\n        }\n    }\n    \n    cout << x << \" \" << y << \" \" << direction << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def print_map(map_state):\n    for line in map_state:\n        print(''.join(line))\n\ndef move_tank(initial_map, operations):\n    # Directions are in order: UP, RIGHT, DOWN, LEFT\n    direction_deltas = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    direction_indices = {'U': 0, 'R': 1, 'D': 2, 'L': 3}\n    \n    # Find the initial position of the tank\n    for r, row in enumerate(initial_map):\n        for c, cell in enumerate(row):\n            if cell == 'T':\n                tank_pos = [r, c]\n                break\n    \n    for operation in operations:\n        if operation in direction_indices:\n            # Calculate the new position\n            new_r = tank_pos[0] + direction_deltas[direction_indices[operation]][0]\n            new_c = tank_pos[1] + direction_deltas[direction_indices[operation]][1]\n            # Check if the new position is within map boundaries and is flat land '.'\n            if 0 <= new_r < len(initial_map) and 0 <= new_c < len(initial_map[0]) and initial_map[new_r][new_c] == '.':\n                # Move the tank\n                initial_map[tank_pos[0]][tank_pos[1]] = '.'\n                tank_pos = [new_r, new_c]\n                initial_map[new_r][new_c] = 'T'\n\n    return initial_map\n\n# Example of usage\ninitial_map = [\n    ['.', '.', '.'],\n    ['.', 'T', '.'],\n    ['.', '.', '.']\n]\noperations = \"RDDRUL\"\nresult_map = move_tank(initial_map, operations)\nprint_map(result_map)",
    "timestamp": "2025-08-13 05:12:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class BattleTown {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read map dimensions\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        scanner.nextLine(); // Consume newline\n        \n        // Read the map\n        char[][] map = new char[rows][cols];\n        int tankRow = -1;\n        int tankCol = -1;\n        \n        for (int i = 0; i < rows; i++) {\n            String line = scanner.nextLine();\n            map[i] = line.toCharArray();\n            \n            // Find the tank's initial position\n            if (tankRow == -1) {\n                int tankColIndex = line.indexOf('T');\n                if (tankColIndex != -1) {\n                    tankRow = i;\n                    tankCol = tankColIndex;\n                }\n            }\n        }\n        \n        // Read actions\n        String actions = scanner.nextLine();\n        scanner.close();\n        \n        // Perform actions\n        for (char action : actions.toCharArray()) {\n            switch (action) {\n                case 'U': // Move Up\n                    if (tankRow > 0 && map[tankRow - 1][tankCol] == '.') {\n                        map[tankRow][tankCol] = '.';\n                        tankRow--;\n                        map[tankRow][tankCol] = 'T';\n                    }\n                    break;\n                case 'D': // Move Down\n                    if (tankRow < rows - 1 && map[tankRow + 1][tankCol] == '.') {\n                        map[tankRow][tankCol] = '.';\n                        tankRow++;\n                        map[tankRow][tankCol] = 'T';\n                    }\n                    break;\n                case 'L': // Move Left\n                    if (tankCol > 0 && map[tankRow][tankCol - 1] == '.') {\n                        map[tankRow][tankCol] = '.';\n                        tankCol--;\n                        map[tankRow][tankCol] = 'T';\n                    }\n                    break;\n                case 'R': // Move Right\n                    if (tankCol < cols - 1 && map[tankRow][tankCol + 1] == '.') {\n                        map[tankRow][tankCol] = '.';\n                        tankCol++;\n                        map[tankRow][tankCol] = 'T';\n                    }\n                    break;\n            }\n        }\n        \n        // Print final map\n        for (char[] row : map) {\n            System.out.println(new String(row));\n        }\n    }\n}",
    "timestamp": "2025-08-13 05:13:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 5 // Map height\n#define M 5 // Map width\n\nvoid printMap(char map[N][M]) {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            printf(\"%c \", map[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid moveTank(char map[N][M], char commands[]) {\n    int x = -1, y = -1;\n    \n    // Find initial tank position\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            if (map[i][j] == 'T') {\n                x = i;\n                y = j;\n                break;\n            }\n        }\n        if (x != -1) break;\n    }\n    \n    // Execute commands\n    for (int i = 0; i < strlen(commands); ++i) {\n        char command = commands[i];\n        if (command == 'U' && x > 0 && map[x-1][y] == '.') {\n            map[x][y] = '.';\n            map[--x][y] = 'T';\n        } else if (command == 'D' && x < N-1 && map[x+1][y] == '.') {\n            map[x][y] = '.';\n            map[++x][y] = 'T';\n        } else if (command == 'L' && y > 0 && map[x][y-1] == '.') {\n            map[x][y] = '.';\n            map[x][--y] = 'T';\n        } else if (command == 'R' && y < M-1 && map[x][y+1] == '.') {\n            map[x][y] = '.';\n            map[x][++y] = 'T';\n        }\n    }\n}\n\nint main() {\n    char map[N][M] = {\n        {'.', '.', '.', '.', '.'},\n        {'.', '.', '.', 'T', '.'},\n        {'.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.'}\n    };\n    \n    char commands[] = \"URULDRDD\"; // Sample commands\n\n    moveTank(map, commands);\n    printMap(map);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:13:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solution(map_info, moves):\n    # Parse map dimensions and initial tank position\n    rows, cols = map_info[0].split()\n    rows, cols = int(rows), int(cols)\n    \n    # Create map grid\n    grid = [list(map_info[i+1]) for i in range(rows)]\n    \n    # Find initial tank position\n    tank_row, tank_col = None, None\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '^' or grid[r][c] == 'v' or grid[r][c] == '<' or grid[r][c] == '>':\n                tank_row, tank_col = r, c\n                tank_dir = grid[r][c]\n                break\n        if tank_row is not None:\n            break\n    \n    # Directions mapping\n    directions = {\n        '^': (-1, 0),\n        'v': (1, 0),\n        '<': (0, -1),\n        '>': (0, 1)\n    }\n    \n    # Rotation and move mappings\n    rotate_left = {'^': '<', '<': 'v', 'v': '>', '>': '^'}\n    rotate_right = {'^': '>', '>': 'v', 'v': '<', '<': '^'}\n    \n    # Process moves\n    for move in moves:\n        if move == 'L':\n            tank_dir = rotate_left[tank_dir]\n            grid[tank_row][tank_col] = tank_dir\n        elif move == 'R':\n            tank_dir = rotate_right[tank_dir]\n            grid[tank_row][tank_col] = tank_dir\n        elif move == 'M':\n            dr, dc = directions[tank_dir]\n            new_row, new_col = tank_row + dr, tank_col + dc\n            \n            # Check if move is valid\n            if (0 <= new_row < rows and \n                0 <= new_col < cols and \n                grid[new_row][new_col] == '.'):\n                grid[tank_row][tank_col] = '.'\n                tank_row, tank_col = new_row, new_col\n                grid[tank_row][tank_col] = tank_dir\n    \n    # Convert grid back to string representation\n    result = [''.join(row) for row in grid]\n    return result",
    "timestamp": "2025-08-13 05:13:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def process_commands(map_data, commands):\n    # Find initial position and direction of the tank\n    directions = ['^', '>', 'v', '<']\n    for i in range(len(map_data)):\n        for j in range(len(map_data[i])):\n            if map_data[i][j] in directions:\n                x, y = i, j\n                direction = map_data[i][j]\n                break\n    \n    # Direction vectors: ^, >, v, <\n    dx = [-1, 0, 1, 0]\n    dy = [0, 1, 0, -1]\n    dir_idx = directions.index(direction)\n    \n    for cmd in commands:\n        if cmd == 'U':\n            new_dir = '^'\n            dir_idx = 0\n            map_data[x] = map_data[x][:y] + new_dir + map_data[x][y+1:]\n        elif cmd == 'D':\n            new_dir = 'v'\n            dir_idx = 2\n            map_data[x] = map_data[x][:y] + new_dir + map_data[x][y+1:]\n        elif cmd == 'L':\n            new_dir = '<'\n            dir_idx = 3\n            map_data[x] = map_data[x][:y] + new_dir + map_data[x][y+1:]\n        elif cmd == 'R':\n            new_dir = '>'\n            dir_idx = 1\n            map_data[x] = map_data[x][:y] + new_dir + map_data[x][y+1:]\n        elif cmd == 'S':\n            # Shoot in the current direction\n            nx, ny = x, y\n            while True:\n                nx += dx[dir_idx]\n                ny += dy[dir_idx]\n                if nx < 0 or nx >= len(map_data) or ny < 0 or ny >= len(map_data[nx]):\n                    break\n                if map_data[nx][ny] == '#':\n                    break\n                if map_data[nx][ny] == '*':\n                    map_data[nx] = map_data[nx][:ny] + '.' + map_data[nx][ny+1:]\n                    break\n        elif cmd == 'M':\n            nx = x + dx[dir_idx]\n            ny = y + dy[dir_idx]\n            if 0 <= nx < len(map_data) and 0 <= ny < len(map_data[nx]):\n                if map_data[nx][ny] == '.':\n                    # Move the tank\n                    map_data[x] = map_data[x][:y] + '.'\n                    if y+1 < len(map_data[x]):\n                        map_data[x] = map_data[x][:y] + '.' + map_data[x][y+1:]\n                    else:\n                        map_data[x] = map_data[x][:y] + '.'\n                    x, y = nx, ny\n                    map_data[x] = map_data[x][:ny] + directions[dir_idx] + map_data[x][ny+1:]\n    \n    return map_data\n\n# Read input\nH, W = map(int, input().split())\nmap_data = [input().strip() for _ in range(H)]\nN = int(input())\ncommands = input().strip()\n\n# Process commands\nresult = process_commands(map_data, commands)\n\n# Output the result\nfor line in result:\n    print(line)",
    "timestamp": "2025-08-13 05:13:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Direction vectors for 'W', 'A', 'S', 'D'\nint dx[] = {-1, 0, 1, 0}; // W, A, S, D\nint dy[] = {0, -1, 0, 1}; // W, A, S, D\n\nvoid updateMap(vector<string>& map, const string& operations) {\n    int rows = map.size();\n    int cols = map[0].size();\n\n    // Find the initial position of the tank 'T'\n    int tankX = -1, tankY = -1;\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            if (map[i][j] == 'T') {\n                tankX = i;\n                tankY = j;\n            }\n        }\n    }\n\n    // Process operations\n    for (char op : operations) {\n        int dir = -1;\n        switch (op) {\n            case 'W': dir = 0; break;\n            case 'A': dir = 1; break;\n            case 'S': dir = 2; break;\n            case 'D': dir = 3; break;\n        }\n        int newX = tankX + dx[dir];\n        int newY = tankY + dy[dir];\n\n        if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && map[newX][newY] == '.') {\n            map[tankX][tankY] = '.';\n            map[newX][newY] = 'T';\n            tankX = newX;\n            tankY = newY;\n        }\n    }\n}\n\nvoid printMap(const vector<string>& map) {\n    for (const string& row : map) {\n        cout << row << endl;\n    }\n}\n\nint main() {\n    // Example input\n    vector<string> map = {\n        \".....\",\n        \"..T..\",\n        \".....\"\n    };\n    string operations = \"WASD\";\n\n    updateMap(map, operations);\n    printMap(map);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:23:42"
  }
]