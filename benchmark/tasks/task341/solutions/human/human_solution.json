[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint t, h, w, n, i, j, k, l, x, y, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar field[20][21], c, dir[5] = {\"^>v<\"};\n\tscanf(\"%d\",&t);\n\tfor(i = 0;i < t;i++){\n\t\tscanf(\"%d%d%*c\",&h,&w);\n\t\tfor(j = 0;j < h;j++){\n\t\t\tfor(k = 0;k < w;k++){\n\t\t\t\tfield[j][k] = getchar();\n\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\tif(dir[l] == field[j][k]){\n\t\t\t\t\t\ty = j, x = k;\n\t\t\t\t\t\td = l;\n\t\t\t\t\t\tfield[j][k] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[j][k] = '\\0';\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d%*c\",&n);\n\t\tfor(k = 0;k < n;k++){\n\t\t\tc = getchar();\n\t\t\tif(c == 'U'){\n\t\t\t\tif(y - 1 >= 0 && field[y - 1][x] == '.')\n\t\t\t\t\ty--;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(c == 'D'){\n\t\t\t\tif(y + 1 < h && field[y + 1][x] == '.')\n\t\t\t\t\ty++;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse if(c == 'L'){\n\t\t\t\tif(x - 1 >= 0 && field[y][x - 1] == '.')\n\t\t\t\t\tx--;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(c == 'R'){\n\t\t\t\tif(x + 1 < w && field[y][x + 1] == '.')\n\t\t\t\t\tx++;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse if(c == 'S'){\n\t\t\t\tfor(j = 1;y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && (field[y + dy[d] * j][x + dx[d] * j] == '.' || field[y + dy[d] * j][x + dx[d] * j] == '-');j++);\n\t\t\t\tif(y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && field[y + dy[d] * j][x + dx[d] * j] == '*')\n\t\t\t\t\tfield[y + dy[d] * j][x + dx[d] * j] = '.';\n\t\t\t}\n\t\t}\n\t\tfield[y][x] = dir[d];\n\t\tfor(j = 0;j < h;j++)\n\t\t\tputs(field[j]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef vector<string> vstring;\ntypedef pair<int, int> pint;\ntypedef pair<pint, int> ppint;\ntypedef pair<int, pint> pintp;\ntypedef unsigned int uint;\ntypedef long long llint;\ntypedef unsigned long long int ullint;\n\n//container util\n//------------------------------------------\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define EXIST(v,i) (find((v).begin(), (v).end(), i) != (v).end())\n#define ERASE(v,i) (v).erase(remove((v).begin(),(v).end(),i),(v).end())\n#define me (*this)\n\n//repetition\n//------------------------------------------\n#define rep(i,s) for(int i=0; i<(int)(s); i++)\n\n//constant\n//--------------------------------------------\nconst int INF = 100000000;\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLEAR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define debug(x)  cerr << #x << \" = \" << (x) << endl\n\nstruct POS {\n\tint x, y;\n};\n\nPOS vec[4] = {\n\t{1, 0},\n\t{0, -1},\n\t{-1, 0},\n\t{0, 1}\n};\n\nint main() {\n\tstatic int n;\n\tcin >> n;\n\trep(game,n) {\n\t\tif(game)\n\t\t\tprintf(\"\\n\");\n\t\tstatic int w, h;\n\t\tcin >> h >> w;\n\t\tchar mapd[22][22];\n\t\trep(i,h) {\n\t\t\t\tscanf(\" %s\", mapd[i]);\n\t\t}\n\t\tstatic int move;\n\t\tcin >> move;\n\t\tchar action[110];\n\t\tscanf(\" %s\", action);\n\t\tPOS cur;\n\t\tPOS dir;\n\t\trep(y,h) {\n\t\t\trep(x,w) {\n\t\t\t\tif(mapd[y][x] == '^') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[1];\n\t\t\t\t} else if(mapd[y][x] == '<') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[2];\n\t\t\t\t} else if(mapd[y][x] == 'v') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[3];\n\t\t\t\t} else if(mapd[y][x] == '>') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,move) {\n\t\t\tswitch(action[i]) {\n\t\t\tcase 'U': {\n\t\t\t\tdir = vec[1];\n\t\t\t\tmapd[cur.y][cur.x] = '^';\n\t\t\t\tif(mapd[cur.y - 1][cur.x] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[1].y;\n\t\t\t\t\tcur.x += vec[1].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = '^';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'D': {\n\t\t\t\tdir = vec[3];\n\t\t\t\tmapd[cur.y][cur.x] = 'v';\n\t\t\t\tif(mapd[cur.y + 1][cur.x] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[3].y;\n\t\t\t\t\tcur.x += vec[3].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = 'v';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'L': {\n\t\t\t\tdir = vec[2];\n\t\t\t\tmapd[cur.y][cur.x] = '<';\n\t\t\t\tif(mapd[cur.y][cur.x - 1] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[2].y;\n\t\t\t\t\tcur.x += vec[2].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = '<';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'R': {\n\t\t\t\tdir = vec[0];\n\t\t\t\tmapd[cur.y][cur.x] = '>';\n\t\t\t\tif(mapd[cur.y][cur.x + 1] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[0].y;\n\t\t\t\t\tcur.x += vec[0].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = '>';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'S': {\n\t\t\t\tPOS s = cur;\n\t\t\t\twhile(0 <= s.x && s.x < w && 0 <= s.y && s.y < h) {\n\t\t\t\t\tif(mapd[s.y][s.x] == '#')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(mapd[s.y][s.x] == '*') {\n\t\t\t\t\t\tmapd[s.y][s.x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ts.x += dir.x;\n\t\t\t\t\ts.y += dir.y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,h) {\n\t\t\tprintf(\"%s\\n\", mapd[i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint h, w;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint main(){\n    int t;\n    cin >> t;\n    for(int q=0; q < t; q++){\n        if(q) cout << endl;\n        string s = \"^><v\";\n        int direction, mx, my;\n        int dx[4] = {1, 0, 0, -1};\n        int dy[4] = {0, 1, -1, 0};\n        cin >> h >> w;\n        string field[h];\n        for(int i=0; i < h; i++){\n            cin >> field[i];\n            for(int j=0; j < field[i].size(); j++) if(s.find(field[i][j]) != -1){mx = i; my = j, direction = s.find(field[i][j]); field[i][j] = '.';}\n        }\n        int n; cin >> n;\n        string c; cin >> c;\n\n        for(int i=0; i < c.size(); i++){\n            if(c[i] == 'U'){\n                direction = 0;\n                if(isIn(mx-1, my) && field[mx-1][my] == '.')mx--;\n            }\n            if(c[i] == 'D'){\n                direction = 3;\n                if(isIn(mx+1, my) && field[mx+1][my] == '.')mx++;\n            }\n            if(c[i] == 'L'){\n                direction = 2;\n                if(isIn(mx, my-1) && field[mx][my-1] == '.')my--;\n            }\n            if(c[i] == 'R'){\n                direction = 1;\n                if(isIn(mx, my+1) && field[mx][my+1] == '.')my++;\n            }\n            if(c[i] == 'S'){\n                for(int j=1; ; j++){\n                    if(!isIn(mx-j*dx[direction], my+j*dy[direction])) break;\n                    if(field[mx-j*dx[direction]][my+j*dy[direction]] == '#') break;\n                    if(field[mx-j*dx[direction]][my+j*dy[direction]] == '*'){\n                        field[mx-j*dx[direction]][my+j*dy[direction]] = '.';\n                        break;\n                    }\n                }\n            }\n        }\n        field[mx][my] = s[direction];\n        for(int i=0; i< h; i++) cout << field[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<cstring>\n#include<iostream>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> pin;\ntypedef std::pair<int,std::pair<int, int> > ppin;\n\nusing namespace std;\n\nchar ma[22][22];\n\nint main(){\n    \n    int n;\n    cin>>n;\n    while(n--){\n        int a,b;\n        cin>>a>>b;\n        int x=0,y=0,d=0;\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cin>>ma[i][j];\n                if(ma[i][j]=='^'){\n                    y=i; x=j; d=0;\n                }\n                if(ma[i][j]=='v'){\n                    y=i; x=j; d=1;\n                }\n                if(ma[i][j]=='<'){\n                    y=i; x=j; d=2;\n                }\n                if(ma[i][j]=='>'){\n                    y=i; x=j; d=3;\n                }\n            }\n        }\n        \n        int str;\n        cin>>str;\n        string s;\n        cin>>s;\n        for(int k=0;k<s.length();k++){\n            switch(s[k]){\n                case 'U':\n                    \n                    d=0;\n                    if(ma[y-1][x]!='.'||y==0)\n                        continue;\n                    y--;\n                    ma[y+1][x]='.';\n                    ma[y][x]='^';\n                    break;\n                case 'D':\n                    d=1;\n                    if(ma[y+1][x]!='.'||y+1==a)\n                        continue;\n                    \n                    y++;\n                    ma[y-1][x]='.';\n                    ma[y][x]='v';\n                    break;\n                case 'L':\n                    d=2;\n                    if(ma[y][x-1]!='.'||x==0)\n                        continue;\n                    \n                    x--;\n                    ma[y][x+1]='.';\n                    ma[y][x]='<';\n                    break;\n                case 'R':\n                    d=3;\n                    if(ma[y][x+1]!='.'||x+1==b)\n                        continue;\n                    \n                    x++;\n                    ma[y][x-1]='.';\n                    ma[y][x]='>';\n                    break;\n                case 'S':\n                    switch(d){\n                        case 0:\n                            for(int i=y-1;i>=0;i--){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 1:\n                            for(int i=y+1;i<a;i++){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 2:\n                            for(int i=x-1;i>=0;i--){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 3:\n                            for(int i=x+1;i<b;i++){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                    }\n//                    for(int i=0;i<a;i++){\n//                        for(int j=0;j<b;j++){\n//                            cout<<ma[i][j];\n//                        }\n//                        cout<<endl;\n//                    }\n//                    cout<<endl;\n                    break;\n            }\n        }\n        switch(d){\n            case 0:\n                ma[y][x]='^';\n                break;\n            case 1:\n                ma[y][x]='v';\n                break;\n            case 2:\n                ma[y][x]='<';\n                break;\n            case 3:\n                ma[y][x]='>';\n                break;\n        }\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cout<<ma[i][j];\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef vector<string> vstring;\ntypedef pair<int, int> pint;\ntypedef pair<pint, int> ppint;\ntypedef pair<int, pint> pintp;\ntypedef unsigned int uint;\ntypedef long long llint;\ntypedef unsigned long long int ullint;\n\n//container util\n//------------------------------------------\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define EXIST(v,i) (find((v).begin(), (v).end(), i) != (v).end())\n#define ERASE(v,i) (v).erase(remove((v).begin(),(v).end(),i),(v).end())\n#define me (*this)\n\n//repetition\n//------------------------------------------\n#define rep(i,s) for(int i=0; i<(int)(s); i++)\n\n//constant\n//--------------------------------------------\nconst int INF = 100000000;\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLEAR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define debug(x)  cerr << #x << \" = \" << (x) << endl\n\nstruct POS {\n\tint x, y;\n};\n\nPOS vec[4] = {\n\t{1, 0},\n\t{0, -1},\n\t{-1, 0},\n\t{0, 1}\n};\n\nint main() {\n\tstatic int n;\n\tcin >> n;\n\trep(game,n) {\n\t\tstatic int w, h;\n\t\tcin >> h >> w;\n\t\tchar mapd[22][22];\n\t\trep(i,h) {\n\t\t\t\tscanf(\" %s\", mapd[i]);\n\t\t}\n\t\tstatic int move;\n\t\tcin >> move;\n\t\tchar action[110];\n\t\tscanf(\" %s\", action);\n\t\tPOS cur;\n\t\tPOS dir;\n\t\trep(y,h) {\n\t\t\trep(x,w) {\n\t\t\t\tif(mapd[y][x] == '^') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[1];\n\t\t\t\t} else if(mapd[y][x] == '<') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[2];\n\t\t\t\t} else if(mapd[y][x] == 'v') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[3];\n\t\t\t\t} else if(mapd[y][x] == '>') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,move) {\n\t\t\tswitch(action[i]) {\n\t\t\tcase 'U': {\n\t\t\t\tdir = vec[1];\n\t\t\t\tmapd[cur.y][cur.x] = '^';\n\t\t\t\tif(mapd[cur.y - 1][cur.x] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[1].y;\n\t\t\t\t\tcur.x += vec[1].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = '^';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'D': {\n\t\t\t\tdir = vec[3];\n\t\t\t\tmapd[cur.y][cur.x] = 'v';\n\t\t\t\tif(mapd[cur.y + 1][cur.x] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[3].y;\n\t\t\t\t\tcur.x += vec[3].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = 'v';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'L': {\n\t\t\t\tdir = vec[2];\n\t\t\t\tmapd[cur.y][cur.x] = '<';\n\t\t\t\tif(mapd[cur.y][cur.x - 1] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[2].y;\n\t\t\t\t\tcur.x += vec[2].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = '<';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'R': {\n\t\t\t\tdir = vec[0];\n\t\t\t\tmapd[cur.y][cur.x] = '>';\n\t\t\t\tif(mapd[cur.y][cur.x + 1] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[0].y;\n\t\t\t\t\tcur.x += vec[0].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = '>';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'S': {\n\t\t\t\tPOS s = cur;\n\t\t\t\twhile(0 <= s.x && s.x < w && 0 <= s.y && s.y < h) {\n\t\t\t\t\tif(mapd[s.y][s.x] == '#')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(mapd[s.y][s.x] == '*') {\n\t\t\t\t\t\tmapd[s.y][s.x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ts.x += dir.x;\n\t\t\t\t\ts.y += dir.y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,h) {\n\t\t\tprintf(\"%s\\n\", mapd[i]);\n\t\t}\n\t\t#if 1\n\t\tif(!(game == n - 1)) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar dd[5] = \">v<^\";\n\nint main(){\n    int rep;\n    cin >> rep;\n    for(int r=0; r<rep; r++){\n        int h,w;\n        cin >> h >> w;\n        vector<vector<char> > field(h+2, vector<char>(w+2, '#'));\n        int x, y, dir;\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                char in;\n                cin >> in;\n                field[i][j] = in;\n                if(in=='^' || in=='<' || in=='>' || in=='v'){\n                    y = i;\n                    x = j;\n                    for(int k=0; k<4; k++){\n                        if(in == dd[k]) dir=k;\n                    }\n                }\n            }\n        }\n\n        int m;\n        string manip;\n        cin >> m >> manip;\n        for(int i=0; i<m; i++){\n            switch(manip[i]){\n            case 'U':\n                dir = 3;\n                goto move;\n            case 'D':\n                dir = 1;\n                goto move;\n            case 'L':\n                dir = 2;\n                goto move;\n            case 'R':\n                dir = 0;\n            move:\n                if(field[y+dy[dir]][x+dx[dir]] == '.'){\n                    field[y][x] = '.';\n                    y += dy[dir];\n                    x += dx[dir];\n                    field[y][x] = dd[dir];\n                }\n                break;\n            case 'S':\n                int nx=x, ny=y;\n                while(field[ny][nx] != '#' && field[ny][nx] != '*'){\n                    ny += dy[dir];\n                    nx += dx[dir];\n                }\n                if(field[ny][nx] == '*'){\n                    field[ny][nx] = '.';\n                }\n            }\n        }\n\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                cout << field[i][j];\n            }\n            cout << endl;\n        }\n        if(r<rep-1) cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint H, W, N, T, I, x, y, dx, dy;\nstring field[20];\n\nvoid show() {\n  // cout << \"---------\" << endl;\n  // cout << x << ' ' << y << endl;\n  for (int i = 0; i < H; i++)\n    cout << field[i] << endl;\n  if (I != T-1) cout << endl;\n}\n\nvoid solve() {\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> field[i];\n  for (int j = 0; j < H; j++)\n    for (int i = 0; i < W; i++)\n      if (field[j][i] == '^' || field[j][i] == 'v' ||\n          field[j][i] == '<' || field[j][i] == '>') {\n        x = i; y = j;\n        goto escape;\n      }\nescape:\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    char c;\n    cin >> c;\n    switch (c) {\n    case 'S':\n      switch (field[y][x]) {\n      case '^':\n        dx = 0; dy = -1; break;\n      case 'v':\n        dx = 0; dy = 1; break;\n      case '<':\n        dx = -1; dy = 0; break;\n      case '>':\n        dx = 1; dy = 0; break;\n      default:\n        break;\n      }\n      break;\n    case 'U':\n      dx = 0; dy = -1; field[y][x] = '^'; break;\n    case 'D':\n      dx = 0; dy = 1; field[y][x] = 'v'; break;\n    case 'L':\n      dx = -1; dy = 0; field[y][x] = '<'; break;\n    case 'R':\n      dx = 1; dy = 0; field[y][x] = '>'; break;\n    default:\n      break;\n    }\n    if (c == 'S') {\n      int p = x, q = y;\n      for (;;) {\n        p += dx; q += dy;\n        if (p < 0 || p >= W || q < 0 || q >= H) break;\n        if (field[q][p] == '*') {\n          field[q][p] = '.';\n          break;\n        }\n        if (field[q][p] == '#') break;\n      }\n    } else {\n      int p = x + dx, q = y + dy;\n      if (0 <= p && p < W && 0 <= q && q < H && field[q][p] == '.') {\n        field[q][p] = field[y][x];\n        field[y][x] = '.';\n        x = p; y = q;\n      }\n    }\n    // show();\n  }\n  show();\n}\n\nint main() {\n  cin >> T;\n  for (I = 0; I < T; I++)\n    solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nchar s[25][25],c[110],box[]={'^','>','v','<'};\nint n,w,h;\n\n\n\n\nvoid func(int y,int x,int now,int pre){\n\ts[y][x]=box[pre];\n\tif(now==n)\n\treturn;\n\ts[y][x]='.';\n\tif(c[now]=='U'){\n\t\tif(x>=0&&x<w&&y-1>=0&&y-1<h&&s[y-1][x]=='.')\n\t\ty--;pre=0;\n\t}else if(c[now]=='R'){\n\t\tif(x+1>=0&&x+1<w&&y>=0&&y<h&&s[y][x+1]=='.')\n\t\tx++;pre=1;\n\t}else if(c[now]=='D'){\n\t\tif(x>=0&&x<w&&y+1>=0&&y+1<h&&s[y+1][x]=='.')\n\t\ty++;pre=2;\n\t}else if(c[now]=='L'){\n\t\tif(x-1>=0&&x-1<w&&y>=0&&y<h&&s[y][x-1]=='.')\n\t\tx--;pre=3;\n\t}else if(c[now]=='S'){\n\t\tif(box[pre]=='>'){\n\t\t\tfor(int i=x;i<w;i++)\n\t\t\tif(s[y][i]=='*'){\n\t\t\t\ts[y][i]='.';\n\t\t\t\tbreak;\n\t\t\t}else if(s[y][i]=='#')\n\t\t\tbreak;\n\t\t}else if(box[pre]=='^'){\n\t\t\tfor(int i=y;i>=0;i--)\n\t\t\tif(s[i][x]=='*'){\n\t\t\t\ts[i][x]='.';\n\t\t\t\tbreak;\n\t\t\t}else if(s[i][x]=='#')\n\t\t\tbreak;\n\t\t}else if(box[pre]=='<'){\n\t\t\tfor(int i=x;i>=0;i--)\n\t\t\tif(s[y][i]=='*'){\n\t\t\t\ts[y][i]='.';\n\t\t\t\tbreak;\n\t\t\t}else if(s[y][i]=='#')\n\t\t\tbreak;\n\t\t}else\n\t\tif(box[pre]=='v'){\n\t\t\tfor(int i=y;i<h;i++)\n\t\t\tif(s[i][x]=='*'){\n\t\t\t\ts[i][x]='.';\n\t\t\t\tbreak;\n\t\t\t}else if(s[i][x]=='#')\n\t\t\tbreak;\n\t\t}\n\t}\n\tfunc(y,x,now+1,pre);\n}\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>h>>w;\n\t\trep(i,h)\n\t\t\tcin>>s[i];\n\t\tcin>>n;\n\t\tcin>>c;\n\t\trep(i,h)\n\t\trep(j,w){\n\t\t\tif(s[i][j]=='>'){\n\t\t\t\tfunc(i,j,0,1);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif(s[i][j]=='^'){\n\t\t\t\tfunc(i,j,0,0);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif(s[i][j]=='<'){\n\t\t\t\tfunc(i,j,0,3);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif(s[i][j]=='v'){\n\t\t\t\tfunc(i,j,0,2);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tend:\n\t\trep(i,h)\n\t\tcout<<s[i]<<endl;\n\t\tif(t>0)\n\t\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef vector<string> vstring;\ntypedef pair<int, int> pint;\ntypedef pair<pint, int> ppint;\ntypedef pair<int, pint> pintp;\ntypedef unsigned int uint;\ntypedef long long llint;\ntypedef unsigned long long int ullint;\n\n//container util\n//------------------------------------------\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define mp make_pair\n#define EXIST(v,i) (find((v).begin(), (v).end(), i) != (v).end())\n#define ERASE(v,i) (v).erase(remove((v).begin(),(v).end(),i),(v).end())\n#define me (*this)\n\n//repetition\n//------------------------------------------\n#define rep(i,s) for(int i=0; i<(int)(s); i++)\n\n//constant\n//--------------------------------------------\nconst int INF = 100000000;\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLEAR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define debug(x)  cerr << #x << \" = \" << (x) << endl\n\nstruct POS {\n\tint x, y;\n};\n\nPOS vec[4] = {\n\t{1, 0},\n\t{0, -1},\n\t{-1, 0},\n\t{0, 1}\n};\n\nint main() {\n\tstatic int n;\n\tcin >> n;\n\trep(game,n) {\n\t\tif(game)\n\t\t\tprintf(\"\\n\\n\");\n\t\tstatic int w, h;\n\t\tcin >> h >> w;\n\t\tchar mapd[22][22];\n\t\trep(i,h) {\n\t\t\t\tscanf(\" %s\", mapd[i]);\n\t\t}\n\t\tstatic int move;\n\t\tcin >> move;\n\t\tchar action[110];\n\t\tscanf(\" %s\", action);\n\t\tPOS cur;\n\t\tPOS dir;\n\t\trep(y,h) {\n\t\t\trep(x,w) {\n\t\t\t\tif(mapd[y][x] == '^') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[1];\n\t\t\t\t} else if(mapd[y][x] == '<') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[2];\n\t\t\t\t} else if(mapd[y][x] == 'v') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[3];\n\t\t\t\t} else if(mapd[y][x] == '>') {\n\t\t\t\t\tcur.x = x;\n\t\t\t\t\tcur.y = y;\n\t\t\t\t\tdir = vec[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,move) {\n\t\t\tswitch(action[i]) {\n\t\t\tcase 'U': {\n\t\t\t\tdir = vec[1];\n\t\t\t\tmapd[cur.y][cur.x] = '^';\n\t\t\t\tif(mapd[cur.y - 1][cur.x] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[1].y;\n\t\t\t\t\tcur.x += vec[1].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = '^';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'D': {\n\t\t\t\tdir = vec[3];\n\t\t\t\tmapd[cur.y][cur.x] = 'v';\n\t\t\t\tif(mapd[cur.y + 1][cur.x] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[3].y;\n\t\t\t\t\tcur.x += vec[3].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = 'v';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'L': {\n\t\t\t\tdir = vec[2];\n\t\t\t\tmapd[cur.y][cur.x] = '<';\n\t\t\t\tif(mapd[cur.y][cur.x - 1] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[2].y;\n\t\t\t\t\tcur.x += vec[2].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = '<';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'R': {\n\t\t\t\tdir = vec[0];\n\t\t\t\tmapd[cur.y][cur.x] = '>';\n\t\t\t\tif(mapd[cur.y][cur.x + 1] == '.') {\n\t\t\t\t\tmapd[cur.y][cur.x] = '.';\n\t\t\t\t\tcur.y += vec[0].y;\n\t\t\t\t\tcur.x += vec[0].x;\n\t\t\t\t\tmapd[cur.y][cur.x] = '>';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t  }\n\t\t\tcase 'S': {\n\t\t\t\tPOS s = cur;\n\t\t\t\twhile(0 <= s.x && s.x < w && 0 <= s.y && s.y < h) {\n\t\t\t\t\tif(mapd[s.y][s.x] == '#')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(mapd[s.y][s.x] == '*') {\n\t\t\t\t\t\tmapd[s.y][s.x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ts.x += dir.x;\n\t\t\t\t\ts.y += dir.y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,h) {\n\t\t\tprintf(\"%s\", mapd[i]);\n\t\t\tif(i < h - 1) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(){\n  int i,j,n,t,h,w,a[20][20],p,m,ni,nj;\n  string str;\n  cin >> n;\n  for(t=0;t<n;t++){\n    if(t != 0) cout << endl;\n    cin >> h >> w;\n    for(i=0;i<h;i++){\n      cin >> str;\n      for(j=0;j<w;j++){\n\tif(str[j] == '^'){\n\t  a[i][j] = 0;\n\t  ni = i;\n\t  nj = j;\n\t  p = 0;\n\t}\n\telse if(str[j] == '<'){\n\t  a[i][j] = 0;\n\t  ni = i;\n\t  nj = j;\n\t  p = 1;\n\t}\n\telse if(str[j] == 'v'){\n\t  a[i][j] = 0;\n\t  ni = i;\n\t  nj = j;\n\t  p = 2;\n\t}\n\telse if(str[j] == '>'){\n\t  a[i][j] = 0;\n\t  ni = i;\n\t  nj = j;\n\t  p = 3;\n\t}\n\telse if(str[j] == '-') a[i][j] = 1;\n\telse if(str[j] == '*') a[i][j] = 2;\n\telse if(str[j] == '#') a[i][j] = 3;\n\telse a[i][j] = 0;\n      }\n    }\n\n    cin >> m;\n    cin >> str;\n    for(i=0;i<m;i++){\n      if(str[i] == 'U'){\n\tp = 0;\n\tif(ni > 0 && a[ni-1][nj] == 0) ni--;\n      }\n      else if(str[i] == 'D'){\n\tp = 2;\n\tif(ni < h - 1 && a[ni+1][nj] == 0) ni++;\n      }\n      else if(str[i] == 'L'){\n\tp = 1;\n\tif(nj > 0 && a[ni][nj-1] == 0) nj--;\n      }\n      else if(str[i] == 'R'){\n\tp = 3;\n\tif(nj < w - 1 && a[ni][nj+1] == 0) nj++;\n      }\n      else if(str[i] == 'S'){\n\tif(p == 0){\n\t  for(j=ni;j>=0;j--){\n\t    if(a[j][nj] == 2){\n\t      a[j][nj] = 0;\n\t      break;\n\t    }\n\t    else if(a[j][nj] == 3) break;\n\t  }\n\t}\n\telse if(p == 2){\n\t  for(j=ni;j<h;j++){\n\t    if(a[j][nj] == 2){\n\t      a[j][nj] = 0;\n\t      break;\n\t    }\n\t    else if(a[j][nj] == 3) break;\n\t  }\n\t}\n\telse if(p == 1){\n\t  for(j=nj;j>=0;j--){\n\t    if(a[ni][j] == 2){\n\t      a[ni][j] = 0;\n\t      break;\n\t    }\n\t    else if(a[ni][j] == 3) break;\n\t  }\n\t}\n\telse if(p == 3){\n\t  for(j=nj;j<w;j++){\n\t    if(a[ni][j] == 2){\n\t      a[ni][j] = 0;\n\t      break;\n\t    }\n\t    else if(a[ni][j] == 3) break;\n\t  }\n\t}\n      }\n    }\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(ni == i && nj == j){\n\t  if(p == 0) cout << \"^\";\n\t  else if(p == 1) cout << \"<\";\n\t  else if(p == 2) cout << \"v\";\n\t  else if(p == 3) cout << \">\";\n\t}\n\telse if(a[i][j] == 1) cout << \"-\";\n\telse if(a[i][j] == 2) cout << \"*\";\n\telse if(a[i][j] == 3) cout << \"#\";\n\telse cout << \".\";\n      }\n      cout << endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nenum Mapchip{BLANK='.',BRICK='*',STEAL='#',WATER='-',UP='^',DOWN='v',LEFT='<',RIGHT='>'};\nstruct Tank{int x,y;char dir;};\n\nint T,H,W,N;\nstring manip;\nvector<string>field;\nTank me;\n\nvoid move(char dir){\n  Tank next;\n  next.y = me.y + (dir==DOWN)-(dir==UP);\n  next.x = me.x + (dir==RIGHT)-(dir==LEFT);\n  next.dir = dir;\n  if(next.x<0 || W<=next.x || next.y<0 || H<=next.y || field[next.y][next.x]!=BLANK){\n    me.dir=dir;\n    return;\n  }else{\n    field[me.y][me.x]=BLANK;\n    field[next.y][next.x]=next.dir;\n    me=next;\n    return;\n  }\n  return;\n}\n\nvoid shoot(){\n  Tank next;\n  int dx,dy,x,y;\n  dy = (me.dir==DOWN)-(me.dir==UP);\n  dx = (me.dir==RIGHT)-(me.dir==LEFT);\n  y = me.y + dy;\n  x = me.x + dx;\n  while(0<=x && x<W && 0<=y && y<H){\n    if(field[y][x]==STEAL){\n      break;\n    }else if(field[y][x]==BRICK){\n      field[y][x]=BLANK;\n      break;\n    }\n    y+=dy;\n    x+=dx;\n  }\n  return;\n}\n\nint main()\n{\n  int i,j;\n  cin>>T;\n  while(T-->0){\n    cin>>H>>W;\n    field.resize(H);\n    for(i=0;i<H;i++){\n      cin>>field[i];\n      string tanks=\"^v<>\";\n      for(j=0;j<W;j++){\n\tif(tanks.find(field[i][j])!=string::npos){\n\t  me.x=j;\n\t  me.y=i;\n\t  me.dir=field[i][j];\n\t}\n      }\n    }\n    cin>>N>>manip;\n\n    for(i=0;i<N;i++){\n      switch(manip[i]){\n      case 'U':\n\tmove(UP);\n\tbreak;\n      case 'D':\n\tmove(DOWN);\n\tbreak;\n      case 'L':\n\tmove(LEFT);\n\tbreak;\n      case 'R':\n\tmove(RIGHT);\n\tbreak;\n      case 'S':\n\tshoot();\n\tbreak;\n      default:\n\tcout<<\"error\"<<endl;\n\tbreak;\n      }\n      continue;\n    }\n\n    for(i=0;i<H;i++)cout<<field[i]<<endl;\n    if(T!=0)puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint t, h, w, n, i, j, k, l, x, y, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar field[20][21], c, dir[5] = {\"^>v<\"};/*　鉄壁　レンガ壁　水　平地 */;\n\tscanf(\"%d\",&t);\n\tfor(i = 0;i < t;i++){\n\t\tscanf(\"%d%d%*c\",&h,&w);\n\t\tfor(j = 0;j < h;j++){\n\t\t\tfor(k = 0;k < w;k++){\n\t\t\t\tfield[j][k] = getchar();\n\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\tif(dir[l] == field[j][k]){\n\t\t\t\t\t\ty = j, x = k;\n\t\t\t\t\t\td = l;\n\t\t\t\t\t\tfield[j][k] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[j][k] = '\\0';\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d%*c\",&n);\n\t\tfor(k = 0;k < n;k++){\n\t\t\tc = getchar();\n\t\t\tif(c == 'U'){\n\t\t\t\tif(y - 1 >= 0 && field[y - 1][x] == '.')\n\t\t\t\t\ty--;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(c == 'D'){\n\t\t\t\tif(y + 1 < h && field[y + 1][x] == '.')\n\t\t\t\t\ty++;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse if(c == 'L'){\n\t\t\t\tif(x - 1 >= 0 && field[y][x - 1] == '.')\n\t\t\t\t\tx--;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(c == 'R'){\n\t\t\t\tif(x + 1 < w && field[y][x + 1] == '.')\n\t\t\t\t\tx++;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse if(c == 'S'){\n\t\t\t\tfor(j = 1;y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && (field[y + dy[d] * j][x + dx[d] * j] == '.' || field[y + dy[d] * j][x + dx[d] * j] == '-');j++);\n\t\t\t\tif(y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && field[y + dy[d] * j][x + dx[d] * j] == '*')\n\t\t\t\t\tfield[y + dy[d] * j][x + dx[d] * j] = '.';\n\t\t\t}\n\t\t}\n\t\tfield[y][x] = dir[d];\n\t\tfor(j = 0;j < h;j++)\n\t\t\tputs(field[j]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define loop for(;;)\n#define trace(var) cerr<<\">>> \"<<#var<<\" = \"<<var<<endl;\n#define inf (1e9)\n#define eps (1e-9)\n\ntemplate<class S, class T> inline\nostream& operator<<(ostream&os, pair<S,T> p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\n\ntemplate<class S, class T, class U> inline\nostream& operator<<(ostream&os, tuple<S,T,U> t) {\n  return os << '('\n    << get<0>(t) << \", \"\n    << get<1>(t) << \", \"\n    << get<2>(t) << ')';\n}\n\ntemplate<class T> inline\nostream& operator<<(ostream&os, vector<T> v) {\n  if (v.size() == 0) { return os << \"(empty)\"; }\n  os << v[0];\n  for (int i=1, len=v.size(); i<len; ++i) os << ' ' << v[i];\n  return os;\n}\n\ntemplate<class T> inline\nistream& operator>>(istream&is, vector<T>&v) {\n  rep (i, v.size()) is >> v[i];\n  return is;\n}\n\n//           ^   >  v   <\nint dx[] = { -1, 0, 1,  0 };\nint dy[] = {  0, 1, 0, -1 };\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nenum {\n  HIRA, RENGA, TETSU, MIZU\n};\n\ninline\nvoid display(const vvi&f, int x, int y, int d) {\n  int h = f.size();\n  int w = f[0].size();\n  rep (i, h) {\n    rep (j, w) {\n      if (i == x and j == y) {\n        if (d == 0) cout << '^';\n        else if (d == 1) cout << '>';\n        else if (d == 2) cout << 'v';\n        else cout << '<';\n      }\n      else if (f[i][j] == HIRA) cout << '.';\n      else if (f[i][j] == RENGA) cout << '*';\n      else if (f[i][j] == TETSU) cout << '#';\n      else if (f[i][j] == MIZU) cout << '-';\n      else assert(false);\n    }\n    cout << endl;\n  }\n}\n\nvoid solve(bool of) {\n  if (of) cout << endl;\n  int h, w; cin >> h >> w;\n\n  vvi f(h, vi(w, 0));\n  int x, y, d;\n\n  rep (i, h) {\n    string s; cin >> s;\n    rep (j, w) {\n      char c = s[j];\n      if (c == '#') f[i][j] = TETSU;\n      else if (c == '*') f[i][j] = RENGA;\n      else if (c == '-') f[i][j] = MIZU;\n      else f[i][j] = HIRA;\n      if (c == '^') { x = i; y = j; d = 0; }\n      else if (c == '>') { x = i; y = j; d = 1; }\n      else if (c == 'v') { x = i; y = j; d = 2; }\n      else if (c == '<') { x = i; y = j; d = 3; }\n    }\n  }\n\n  int k; cin >> k;\n  string com; cin >> com;\n  for (char c: com) {\n    if (c == 'U') {\n      d = 0;\n      if (x > 0 and f[x-1][y] == HIRA) --x;\n    }\n    else if (c == 'R') {\n      d = 1;\n      if (y < w-1 and f[x][y+1] == HIRA) ++y;\n    }\n    else if (c == 'D') {\n      d = 2;\n      if (x < h-1 and f[x+1][y] == HIRA) ++x;\n    }\n    else if (c == 'L') {\n      d = 3;\n      if (y > 0 and f[x][y-1] == HIRA) --y;\n    }\n    else {\n      int x2 = x, y2 = y;\n      loop {\n        x2 += dx[d]; y2 += dy[d];\n        if (x2 < 0 or x2 >= h or y2 < 0 or y2 >= w) break;\n        if (f[x2][y2] == RENGA) {\n          f[x2][y2] = HIRA;\n          break;\n        }\n        else if (f[x2][y2] == TETSU) {\n          break;\n        }\n      }\n    }\n  }\n\n  display(f, x, y, d);\n\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout.setf(ios::fixed);\n  cout.precision(10);\n  random_device dev;\n  mt19937 rand(dev());\n\n  int m; cin >> m;\n  rep (_, m) solve(_>0);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nsize_t di[]={size_t(-1), 0, 1, 0};\nsize_t dj[]={0, size_t(-1), 0, 1};\nchar t[]={'^', '<', 'v', '>'};\nchar dir[]={'U', 'L', 'D', 'R'};\n\nvoid simulate(std::vector<std::string> &s, \n    size_t &si, size_t &sj, size_t &me, char ch) {\n\n  size_t H=s.size(), W=s[0].length();\n\n  if (ch == 'S') {\n    // shoot\n    size_t i=si+di[me], j=sj+dj[me];\n    while (i < H && j < W) {\n      if (s[i][j] == '*') {\n        s[i][j] = '.';\n        return;\n      } else if (s[i][j] == '#') {\n        return;\n      }\n      i += di[me];\n      j += dj[me];\n    }\n    return;\n  }\n\n  // move\n  size_t k;\n  for (k=0; k<4; ++k) \n    if (dir[k] == ch) break;\n\n  size_t ni=si+di[k], nj=sj+dj[k];\n  me = k;\n  if (!(ni < H && nj < W) || s[ni][nj] != '.') {\n    // cannot move\n    s[si][sj] = t[me];\n    return;\n  }\n  s[si][sj] = '.';\n  s[ni][nj] = t[me];\n  si = ni;\n  sj = nj;\n}\n\nint solve_testcase() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  std::vector<std::string> S(H);\n  size_t si=-1, sj=-1;\n  size_t me=-1;\n  for (size_t i=0; i<H; ++i) {\n    char buf[32];\n    scanf(\"%s\", buf);\n    S[i] = buf;\n\n    for (size_t j=0; j<W; ++j) {\n      for (size_t k=0; k<4; ++k) {\n        if (S[i][j] == t[k]) {\n          si = i;\n          sj = j;\n          me = k;\n        }\n      }\n    }\n  }\n\n  size_t N;\n  char buf[128];\n  scanf(\"%zu %s\", &N, buf);\n  std::string T=buf;\n  for (size_t i=0; i<N; ++i) {\n    simulate(S, si, sj, me, T[i]);\n  }\n\n  for (size_t i=0; i<H; ++i)\n    printf(\"%s\\n\", S[i].c_str());\n\n  return 0;\n}\n\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  for (int i=0; i<T; ++i) {\n    if (i > 0) printf(\"\\n\");\n    solve_testcase();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int a[22][22],m,n,w,h,x,y,vx,vy;\n  char c;\n  cin>>n;\n  for(i=0;i<n;i++){\n    cin>>h>>w;\n    memset(a,-1,sizeof(a));\n    for(j=1;j<h+1;j++){\n      for(k=1;k<w+1;k++){\n\tcin>>c;\n\tif(0){\n\t}else if(c=='.'){\n\t  a[k][j]=0;\n\t}else if(c=='*'){\n\t  a[k][j]=-2;\n\t}else if(c=='#'){\n\t  a[k][j]=-1;\n\t}else if(c=='-'){\n\t  a[k][j]=-3;\n\t}else if(c=='^'){\n\t  a[k][j]=0;\n\t  x=k;\n\t  y=j;\n\t  vx=0;\n\t  vy=-1;\n\t}else if(c=='v'){\n\t  a[k][j]=0;\n\t  x=k;\n\t  y=j;\n\t  vx=0;\n\t  vy=1;\n\t}else if(c=='<'){\n\t  a[k][j]=0;\n\t  x=k;\n\t  y=j;\n\t  vx=-1;\n\t  vy=0;\n\t}else if(c=='>'){\n\t  a[k][j]=0;\n\t  x=k;\n\t  y=j;\n\t  vx=1;\n\t  vy=0;\n\t}\n      }\n    }\n    cin>>m;\n    for(j=0;j<m;j++){\n      cin>>c;\n      if(0){\n      }else if(c=='U'){\n\tvx=0;\n\tvy=-1;\n\tif(a[x+vx][y+vy]==0){\n\t  x+=vx;\n\t  y+=vy;\n\t}\n      }else if(c=='D'){\n\tvx=0;\n\tvy=1;\n\tif(a[x+vx][y+vy]==0){\n\t  x+=vx;\n\t  y+=vy;\n\t}\n      }else if(c=='L'){\n\tvx=-1;\n\tvy=0;\n\tif(a[x+vx][y+vy]==0){\n\t  x+=vx;\n\t  y+=vy;\n\t}\n      }else if(c=='R'){\n\tvx=1;\n\tvy=0;\n\tif(a[x+vx][y+vy]==0){\n\t  x+=vx;\n\t  y+=vy;\n\t}\n      }else if(c=='S'){\n\tfor(k=1;;k++){\n\t  if(0){\n\t  }else if(a[x+vx*k][y+vy*k]==-1){\n\t    break;\n\t  }else if(a[x+vx*k][y+vy*k]==-2){\n\t    a[x+vx*k][y+vy*k]=0;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    cout<<endl;\n    for(j=1;j<h+1;j++){\n      for(k=1;k<w+1;k++){\n\tif(0){\n\t}else if(k==x&&j==y){\n\t  if(0){\n\t  }else if(vx==-1&&vy==0){\n\t    cout<<'<';\n\t  }else if(vx==0&&vy==-1){\n\t    cout<<'^';\n\t  }else if(vx==1&&vy==0){\n\t    cout<<'>';\n\t  }else if(vx==0&&vy==1){\n\t    cout<<'v';\n\t  }\n\t}else if(a[k][j]==0){\n\t  cout<<'.';\n\t}else if(a[k][j]==-2){\n\t  cout<<'*';\n\t}else if(a[k][j]==-1){\n\t  cout<<'#';\n\t}else if(a[k][j]==-3){\n\t  cout<<'-';\n\t}\n      }\n      cout<<endl;\n    }\n    if(i!=n-1)\n      cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Sensha{\npublic:\n  int x;\n  int y;\n  int dir;\n};\n\nint main() {\n  int T;\n  cin >> T;\n  for(int t = 0; t < T; t++) {\n    if(t != 0) cout << endl;\n    int H, W;\n    cin >> H >> W;\n    char data[H][W];\n    Sensha s;\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n\tcin >> data[i][j];\n\tswitch(data[i][j]) {\n\tcase '^':\n\t  data[i][j] = '.';\n\t  s.x = j;\n\t  s.y = i;\n\t  s.dir = 3;\n\t  break;\n\tcase '>':\n\t  data[i][j] = '.';\n\t  s.x = j;\n\t  s.y = i;\n\t  s.dir = 0;\n\t  break;\n\tcase 'v':\n\t  data[i][j] = '.';\n\t  s.x = j;\n\t  s.y = i;\n\t  s.dir = 1;\n\t  break;\n\tcase '<':\n\t  data[i][j] = '.';\n\t  s.x = j;\n\t  s.y = i;\n\t  s.dir = 2;\n\t  break;\n\t}\n      }\n    }\n\n    int N;\n    cin >> N;\n    int d[4][2] = {{1,0}, {0,1},{-1,0},{0,-1}};\n    for(int i = 0; i < N; i++) {\n      char c;\n      cin >> c;\n      bool zenshin = false;\n      switch(c) {\n      case 'U':\n\ts.dir = 3;\n\tzenshin = true;\n\tbreak;\n      case 'D':\n\ts.dir = 1;\n\tzenshin = true;\n\tbreak;\n      case 'L':\n\ts.dir = 2;\n\tzenshin = true;\n\tbreak;\n      case 'R':\n\ts.dir = 0;\n\tzenshin = true;\n\tbreak;\n      case 'S':\n\tfor(int l = 1; ; l++) {\n\t  int bx = s.x + l*d[s.dir][0];\n\t  int by = s.y + l*d[s.dir][1];\n\t  if(bx < 0 || bx >= W) break;\n\t  if(by < 0 || by >= H) break;\n\t  if(data[by][bx] == '*') {\n\t    data[by][bx] = '.';\n\t    break;\n\t  }\n\t  if(data[by][bx] == '#') break;\n\t}\n\tbreak;\n      }\n      if(zenshin) {\n\tint nx = s.x + d[s.dir][0];\n\tint ny = s.y + d[s.dir][1];\n\tif(nx < 0 || nx >= W) continue;\n\tif(ny < 0 || ny >= H) continue;\n\tif(data[ny][nx] == '.') {\n\t  s.x = nx;\n\t  s.y = ny;\n\t}\n      }\n    }\n\n    switch(s.dir) {\n    case 0:\n      data[s.y][s.x] = '>';\n      break;\n    case 1:\n      data[s.y][s.x] = 'v';\n      break;\n    case 2:\n      data[s.y][s.x] = '<';\n      break;\n    case 3:\n      data[s.y][s.x] = '^';\n      break;\n    }\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n\tcout << data[i][j];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint di[4] = {-1, 0, 1, 0};\nint dj[4] = {0, 1, 0, -1};\n\nint main(){\n\n    int q; cin >> q;\n    for(int nn = 0; nn < q; nn++){\n        if(nn != 0) cout << endl;\n        \n        int h, w; cin >> h >> w;\n        if(!h) break;\n\n        int nowi, nowj, k;\n        vector<vector<char> > s(h + 2, vector<char> (w + 2, '#'));\n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                cin >> s[i][j];\n                if(s[i][j] == '^'){\n                    nowi = i;\n                    nowj = j;\n                    k = 0; \n                }else if(s[i][j] == '>'){\n                    nowi = i;\n                    nowj = j;\n                    k = 1;\n                }else if(s[i][j] == 'v'){\n                    nowi = i;\n                    nowj = j;\n                    k = 2;\n                }else if(s[i][j] == '<'){\n                    nowi = i;\n                    nowj = j;\n                    k = 3;\n                }\n            }\n        }\n\n        int n; cin >> n;\n        string op; cin >> op;\n        for(int i = 0; i < n; i++){\n\n            if(op[i] == 'U'){\n                k = 0;\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n                if(s[nexti][nextj] == '.'){\n                    char tmp = s[nowi][nowj];\n                    s[nowi][nowj] = s[nexti][nextj];\n                    s[nexti][nextj] = tmp;\n                    nowi = nexti;\n                    nowj = nextj;\n                }\n            }\n\n            if(op[i] == 'R'){\n                k = 1;\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n                if(s[nexti][nextj] == '.'){\n                    char tmp = s[nowi][nowj];\n                    s[nowi][nowj] = s[nexti][nextj];\n                    s[nexti][nextj] = tmp;\n                    nowi = nexti;\n                    nowj = nextj;\n                }\n            }\n\n            if(op[i] == 'D'){\n                k = 2;\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n                if(s[nexti][nextj] == '.'){\n                    char tmp = s[nowi][nowj];\n                    s[nowi][nowj] = s[nexti][nextj];\n                    s[nexti][nextj] = tmp;\n                    nowi = nexti;\n                    nowj = nextj;\n                }\n            }\n\n            if(op[i] == 'L'){\n                k = 3;\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n                if(s[nexti][nextj] == '.'){\n                    char tmp = s[nowi][nowj];\n                    s[nowi][nowj] = s[nexti][nextj];\n                    s[nexti][nextj] = tmp;\n                    nowi = nexti;\n                    nowj = nextj;\n                }\n            }\n\n\n            if(op[i] == 'S'){\n                int bi = nowi + di[k];\n                int bj = nowj + dj[k];\n\n                while(1){\n                    if(s[bi][bj] == '#') break;\n                    else if(s[bi][bj] == '*'){\n                        s[bi][bj] = '.';\n                        break;\n                    }\n\n                    bi += di[k];\n                    bj += dj[k];\n                }\n            }\n\n            /*for(int i = 1; i <= h; i++){\n                for(int j = 1; j <= w; j++){\n                    cout << s[i][j];\n                }\n                cout << endl;\n            }\n\n            cout << endl;*/\n        }\n        \n        if(k == 0){\n            s[nowi][nowj] = '^';\n        }else if(k == 1){\n            s[nowi][nowj] = '>';            \n        }else if(k == 2){\n            s[nowi][nowj] = 'v';\n        }else{\n            s[nowi][nowj] = '<';\n        }\n        \n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                cout << s[i][j];\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n;\n  cin >> n;\n  int dx[] = {0,1,0,-1};\n  int dy[] = {-1,0,1,0};\n  while(n--) {\n    int h,w;\n    cin >> h >> w;\n    char ba[w][h];\n    int nx, ny, d;\n    REP(i,h)\n      REP(j,w) {\n      cin >> ba[j][i];\n      if (ba[j][i]=='^') {\n        nx = j;\n        ny = i;\n        d = 0;\n      } else if  (ba[j][i]=='>') {\n        nx = j;\n        ny = i;\n        d = 1;\n      } else if  (ba[j][i]=='v') {\n        nx = j;\n        ny = i;\n        d = 2;\n      } else if  (ba[j][i]=='<') {\n        nx = j;\n        ny = i;\n        d = 3;\n      }\n    }\n    ba[nx][ny] = '.';\n    int m;\n    cin >> m;\n    REP(i,m) {\n      char c;\n      cin >> c;\n      if (c=='S') {\n        int sx=nx, sy=ny;\n        while(1) {\n          sx+=dx[d];\n          sy+=dy[d];\n\n          if (sx<0||sx>=w||sy<0||sy>=h) break;\n          if (ba[sx][sy]=='*') {\n            ba[sx][sy] = '.';\n            break;\n          } else if (ba[sx][sy] == '#') break;\n        }\n      } else {\n        if (c=='U') {\n          d = 0;\n        }else if (c=='D')\n          d=2;\n        else if (c=='L')\n          d = 3;\n        else\n          d=1;\n        int nnx = nx+dx[d];\n        int nny = ny+dy[d];\n        if (nnx>=0&&nnx<w&&nny>=0&&nny<h && ba[nx+dx[d]][ny+dy[d]] == '.') {\n          nx += dx[d];\n          ny += dy[d];\n        }\n      }\n    }\n    string hoge=\"^>v<\";\n    ba[nx][ny] = hoge[d];\n    REP(y,h) {\n      REP(x,w)\n        cout << ba[x][y];\n      cout << endl;\n    }\n    if (n)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nchar field[21][22];\nint h, w;\nint dy[] = {-1, 0, 1, 0, };\nint dx[] = {0, 1, 0, -1, };\nint y, x, d;\n\nvoid findTank();\nvoid move();\nvoid shot();\n\nint main() {\n    bool enterNewLine = false;\n    int t;\n    cin >> t;\n    while (t--) {\n        if (enterNewLine == true) {\n            cout << endl;\n        } else {\n            enterNewLine = true;\n        }\n        cin >> h >> w;\n        memset(field, 0, sizeof(field));\n        for (int i = 0; i < h; i++) {\n            cin >> field[i];\n        }\n        int n;\n        cin >> n;\n        string command;\n        cin >> command;\n        findTank();\n        for (string::iterator it = command.begin(); it != command.end(); it++) {\n            switch (*it) {\n            case 'U':\n                d = 0; move(); break;\n            case 'R':\n                d = 1; move(); break;\n            case 'D':\n                d = 2; move(); break;\n            case 'L':\n                d = 3; move(); break;\n            case 'S':\n                shot(); break;\n            }\n        }\n        for (int i = 0; i < h; i++) {\n            cout << field[i] << endl;\n        }\n    }\n}\n\nvoid findTank() {\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            switch (field[i][j]) {\n            case '^':\n                y = i; x = j; d = 0; return;\n            case '>':\n                y = i; x = j; d = 1; return;\n            case 'v':\n                y = i; x = j; d = 2; return;\n            case '<':\n                y = i; x = j; d = 3; return;\n            }\n        }\n    }\n}\n\nvoid move() {\n    int ny = y + dy[d], nx = x + dx[d];\n    if (0 <= ny && ny <= h && 0 <= nx && nx <= w && field[ny][nx] == '.') {\n        field[y][x] = '.';\n        y = ny;\n        x = nx;\n    }\n    char tank;\n    switch (d) {\n    case 0:\n        tank = '^'; break;\n    case 1:\n        tank = '>'; break;\n    case 2:\n        tank = 'v'; break;\n    case 3:\n        tank = '<'; break;\n    }\n    field[y][x] = tank;\n}\n\nvoid shot() {\n    int ny = y, nx = x;\n    for (int i = 0; i < 9; i++) {\n        ny += dy[d];\n        nx += dx[d];\n        if (ny < 0 || h < ny || nx < 0 || w < nx) {\n            return;\n        }\n        switch (field[ny][nx]) {\n        case '*':\n            field[ny][nx] = '.';\n            return;\n        case '#':\n            return;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n;\nint h, w;\nchar str[1000];\nchar field[100][100];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nvoid Move(int &px, int &py, int dir) {\n  int nx = px + dx[dir];\n  int ny = py + dy[dir];\n  if (nx < 0 || nx >= w || ny < 0 || ny >= h || field[ny][nx] != '.') { return; }\n  px = nx;\n  py = ny;\n}\n\nvoid Shoot(int x, int y, int dir) {\n  while (true) {\n    int nx = x + dx[dir];\n    int ny = y + dy[dir];\n    if (nx < 0 || nx >= w || ny < 0 || ny >= h || field[ny][nx] == '#') { break; }\n    if (field[ny][nx] == '*') {\n      field[ny][nx] = '.';\n      break;\n    }\n    x = nx;\n    y = ny;\n  }\n}\n\nint main() {\n  int test;\n  scanf(\"%d\", &test);\n  while (test--) {\n    scanf(\"%d %d\", &h, &w);\n    int dir = 0xdeadbeaf;\n    int px = -1;\n    int py= -1;\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        char c = field[y][x];\n        if (c == '>') { px = x; py = y; dir = 0; }\n        if (c == 'v') { px = x; py = y; dir = 1; }\n        if (c == '<') { px = x; py = y; dir = 2; }\n        if (c == '^') { px = x; py = y; dir = 3; }\n      }\n    }\n    scanf(\"%d %s\", &n, str);\n    REP(i, n) {\n      field[py][px] = '.';\n      if (str[i] == 'R') { dir = 0; Move(px, py, dir); }\n      if (str[i] == 'D') { dir = 1; Move(px, py, dir); }\n      if (str[i] == 'L') { dir = 2; Move(px, py, dir); }\n      if (str[i] == 'U') { dir = 3; Move(px, py, dir); }\n      if (str[i] == 'S') { Shoot(px, py, dir); }\n      if (dir == 0) { field[py][px] = '>'; }\n      if (dir == 1) { field[py][px] = 'v'; }\n      if (dir == 2) { field[py][px] = '<'; }\n      if (dir == 3) { field[py][px] = '^'; }\n    }\n    REP(y, h) {\n      printf(\"%s\\n\", field[y]);\n    }\n    if (test != 0) { puts(\"\"); }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 21;\nP pos;\nchar m[MAX][MAX];\nint r,c;\n\nvoid input(){\n  for(int i = 0; i < r; i++)\n    for(int j = 0; j < c; j++){\n      cin >> m[i][j];\n      if(m[i][j] == '<' || m[i][j] == '>' || \n\t m[i][j] == '^' || m[i][j] == 'v') pos = P(i,j);\n    }\n}\n\nbool inside(P p){\n  return (0 <= p.first && p.first < r && 0 <= p.second && p.second < c);\n}\n\nvoid shoot(char c){\n\n  int x = 0, y = 0;\n  P p = pos;\n  if(c == '^') y = -1;\n  if(c == 'v') y = 1;\n  if(c == '>') x = 1;\n  if(c == '<') x = -1;\n\n  while(1){\n    p.first += y;\n    p.second += x;\n    if(!inside(p)) break;\n    if(m[p.first][p.second] == '#') break;\n    if(m[p.first][p.second] == '*'){\n      m[p.first][p.second] = '.';\n      break;\n    }\n  }\n}\n\nvoid move(char c, int x, int y){\n  if(inside(P(pos.first+y,pos.second+x)) && m[pos.first+y][pos.second+x] == '.'){\n    m[pos.first][pos.second] = '.';\n    m[pos.first+y][pos.second+x] = c;\n    pos.first += y;\n    pos.second += x;\n  }else{\n    m[pos.first][pos.second] = c;\n  }\n}\n\nint main(){\n  bool flag = false;\n  int X;\n  cin >> X;\n  while(X--){\n    if(flag) cout << endl;\n    flag = true;\n\n    cin >> r >> c;\n    input();\n    int num;\n    cin >> num;\n    for(int i = 0; i < num; i++){\n      char c;\n      cin >> c;\n      if(c == 'S') shoot(m[pos.first][pos.second]);\n      if(c == 'U') move('^',0,-1);\n      if(c == 'D') move('v',0,1);\n      if(c == 'L') move('<',-1,0);\n      if(c == 'R') move('>',1,0);\n    }\n\n    for(int i = 0; i < r; i++){\n      for(int j = 0; j < c; j++)\n\tcout << m[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main () {\n\n  char map[21][20];\n  char com[101];\n\n  char tank[4] = {'^','>','v','<'};\n  int num;\n\n  int dx[4] = { 0, 1, 0, -1};\n  int dy[4] = { -1, 0, 1, 0};\n   \n  cin >> num;\n\n  for ( int n=0; n<num; n++ )\n\t{\n\t  int h,w;\n\t  cin >> h >> w;\n\t  for ( int i=0; i<h; i++ )\n\t\t{\n\t\t  cin >> map[i];\n\t\t}\n\n\t  //for ( int i=0; i<h; i++ )\n\t  //cout << map[i] << endl;\n\t  \n\t  int comlen;\n\t  \n\t  cin >> comlen;\n\t  cin >> com;\n\n\t  int direct = -1;\n\t  int px, py;\n\t  int mx, my;\n\t  int bx, by;\n\t  bool move;\n\t  \n\t  //cout << com << endl;\n\n\t  for ( int i=0; i<h; i++ )\n\t\t{\n\t\t  for ( int j=0; j<w; j++ )\n\t\t\t{\n\t\t\t  switch ( map[i][j] )\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t  direct = 0;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\tcase '>':\n\t\t\t\t  direct = 1;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\tcase 'v':\n\t\t\t\t  direct = 2;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\tcase '<':\n\t\t\t\t  direct = 3;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t  for ( int j=0; j<comlen; j++ )\n\t\t{\n\t\t  move = false;\n\n\t\t  \n\t\t  //cout << j << endl;\n\t\t  //cout << j << \" \" << com[j] << endl;\n\t\t  switch(com[j]) {\n\t\t\t\n\t\t  case 'U':\n\t\t\tdirect = 0;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  case 'R':\n\t\t\tdirect = 1;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  case 'D':\n\t\t\tdirect = 2;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  case 'L':\n\t\t\tdirect = 3;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  }\n\t\t  \n\t\t  bool pass = false;\n\t\t  if ( move ) {\n\t\t\tif ( py + dy[direct] >= h || py + dy[direct] < 0 || px + dx[direct] >= w || px + dx[direct] < 0 )\n\t\t\t\tmap[py][px] = tank[direct];\n\t\t\telse if ( map[py+dy[direct]][px+dx[direct]] == '.')\n\t\t\t  {\n\t\t\t\tmap[py+dy[direct]][px+dx[direct]] = tank[direct];\n\t\t\t\tmap[py][px] = '.';\n\t\t\t\tpx += dx[direct];\n\t\t\t\tpy += dy[direct];\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t\tmap[py][px] = tank[direct];\n\t\t\t  }\n\t\t  } else {\n\t\t\tif ( com[j] == 'S' )\n\t\t\t  {\n\t\t\t\t//cout << \"in\" << endl;\n\t\t\t\t//cout << tank[direct] << endl;\n\t\t\t\tmx = px + dx[direct];\n\t\t\t\tmy = py + dy[direct];\n\t\t\t\t//cout << mx << \" \" << my << endl;//\" \" << map[my][mx] << endl;\n\n\t\t\t\tif ( my < h || my >= 0 || mx < w || mx >= 0 )\n\t\t\t\t  {\t\t\t\t\n\t\t\t\t\twhile ( map[my][mx] == '.' || map[my][mx] == '-' )\n\t\t\t\t\t  {\n\t\t\t\t\t\tmy += dy[direct];\n\t\t\t\t\t\tmx += dx[direct];\n\t\t\t\t\t\tif ( my >= h || my < 0 || mx >= w || mx < 0 )\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\tpass = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t\t  if ( !pass ) {\n\t\t\t\t\tif ( map[my][mx] == '*')\n\t\t\t\t\t  {\n\t\t\t\t\t\tmap[my][mx] = '.';\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\n\t\t\t//cout << mx << \" \" << my << endl;\n\t\t  }\n\t\t}\n\t    for ( int i=0; i<h; i++ )\n\t\t  cout << map[i] << endl;\n\t\tif ( !(n == num -1) )\n\t\t  cout << endl;\n  \n\n\t}\n  \n}\n\t\t  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {-1, 0, 1, 0};\n    int dx[] = {0, 1, 0, -1};\n    char dirF[] = {'^', '>', 'v', '<'};\n    char dirC[] = {'U', 'R', 'D', 'L'};\n\n    int t;\n    cin >> t;\n    while(--t >= 0){\n        int h, w, n;\n        cin >> h >> w;\n        vector<string> field(h);\n        for(int i=0; i<h; ++i)\n            cin >> field[i];\n        string command;\n        cin >> n >> command;\n\n        int y, x, dir;\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                int d = find(dirF, dirF+4, field[i][j]) - dirF;\n                if(d != 4){\n                    y = i;\n                    x = j;\n                    dir = d;\n                    field[y][x] = '.';\n                }\n            }\n        }\n\n        for(int i=0; i<n; ++i){\n            int d = find(dirC, dirC+4, command[i]) - dirC;\n            if(d < 4){\n                int y1 = y + dy[d];\n                int x1 = x + dx[d];\n                if(0 <= y1 && y1 < h && 0 <= x1 && x1 < w && field[y1][x1] == '.'){\n                    y = y1;\n                    x = x1;\n                }\n                dir = d;\n            }else{\n                int y1 = y;\n                int x1 = x;\n                for(;;){\n                    y1 += dy[dir];\n                    x1 += dx[dir];\n                    if(y1 < 0 || y1 >= h || x1 < 0 || x1 >= w)\n                        break;\n                    if(field[y1][x1] == '*'){\n                        field[y1][x1] = '.';\n                        break;\n                    }\n                    if(field[y1][x1] == '#')\n                        break;\n                }\n            }\n        }\n\n        field[y][x] = dirF[dir];\n        for(int i=0; i<h; ++i)\n            cout << field[i] << endl;\n        if(t > 0)\n            cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\nint main(){\n\tint h,w;\n\tint t;\n\tcin>>t;\n\tfor(int l = 0; l < t; l++){\n\t\tchar field[21][21];\n\t\tmemset(field,0,sizeof(field));\n\t\tif(l!=0)\n\t\t\tcout<<endl;\n\t\tchar angle;\n\t\tcin>>h>>w;\n\t\tint sy,sx;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tswitch(field[i][j]){\n\t\t\t\tcase '^':\n\t\t\t\t\tangle='u';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tangle='d';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tangle='r';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tangle='l';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint num;\n\t\tcin>>num;\n\t\tstring order;\n\t\tcin>>order;\n\t\tint cx=sx;\n\t\tint cy=sy;\n\t\tfor(int j = 0; j < order.size(); j++){\n\t\t\tchar o=order[j];\n\t\t\tif(o=='U'){\n\t\t\t\tangle='u';\n\t\t\t\tint ny=cy-1;\n\t\t\t\tint nx=cx;\n\t\t\t\tfield[cy][cx]='^';\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='^';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='D'){\n\t\t\t\tangle='d';\n\t\t\t\tint ny=cy+1;\n\t\t\t\tint nx=cx;\n\t\t\t\tfield[cy][cx]='v';\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='v';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='L'){\n\t\t\t\tangle='l';\n\t\t\t\tint ny=cy;\n\t\t\t\tint nx=cx-1;\n\t\t\t\tfield[cy][cx]='<';\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='<';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='R'){\n\t\t\t\tangle='r';\n\t\t\t\tint ny=cy;\n\t\t\t\tint nx=cx+1;\n\t\t\t\tfield[cy][cx]='>';\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='S'){\n\t\t\t\tif(angle=='r'){\n\t\t\t\t\tfor(int i = cx+1; i < w; i++){\n\t\t\t\t\t\tif(field[cy][i]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[cy][i]=='*'){\n\t\t\t\t\t\t\tfield[cy][i]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='l'){\n\t\t\t\t\tfor(int i = cx-1; i >= 0; i--){\n\t\t\t\t\t\tif(field[cy][i]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[cy][i]=='*'){\n\t\t\t\t\t\t\tfield[cy][i]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='u'){\n\t\t\t\t\tfor(int i = cy-1; i >= 0; i--){\n\t\t\t\t\t\tif(field[i][cx]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[i][cx]=='*'){\n\t\t\t\t\t\t\tfield[i][cx]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='d'){\n\t\t\t\t\tfor(int i = cy+1; i < h; i++){\n\t\t\t\t\t\tif(field[i][cx]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[i][cx]=='*'){\n\t\t\t\t\t\t\tfield[i][cx]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcout<<field[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nchar field[30][30];\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nconst char dir1[] = {'^', '<', 'v', '>'};\nconst char dir2[] = {'U', 'L', 'D', 'R'};\n\nint main() {\n  int T; scanf(\"%d\", &T);\n  while (T--) {\n    int W, H;\n    scanf(\"%d%d\", &H, &W);\n    memset(field, '#', sizeof(field));\n    int ty, tx, td;\n    for (int y = 1; y <= H; ++y) {\n      for (int x = 1; x <= W; ++x) {\n        scanf(\" %c\", &field[y][x]);\n        for (int k = 0; k < 4; ++k) {\n          if (field[y][x] == dir1[k]) {\n            ty = y; tx = x; td = k;\n            field[y][x] = '.';\n            break;\n          }\n        }\n      }\n    }\n\n    int N; scanf(\"%d\", &N);\n    for (int i = 0; i < N; ++i) {\n      char op; scanf(\" %c\", &op);\n      for (int k = 0; k < 4; ++k) {\n        if (op == dir2[k]) {\n          td = k;\n          int ny = ty+dy[k], nx = tx+dx[k];\n          if (field[ny][nx] == '.') { ty = ny; tx = nx; }\n          break;\n        }\n      }\n      if (op == 'S') {\n        int by = ty, bx = tx;\n        while (field[by][bx] == '.' || field[by][bx] == '-') {\n          by += dy[td]; bx += dx[td];\n        }\n        if (field[by][bx] == '*') {\n          field[by][bx] = '.';\n        }\n      }\n    }\n\n    for (int y = 1; y <= H; ++y) {\n      for (int x = 1; x <= W; ++x) {\n        if (ty == y && tx == x) {\n          printf(\"%c\", dir1[td]);\n        } else {\n          printf(\"%c\", field[y][x]);\n        }\n      }\n      puts(\"\");\n    }\n    if (T > 0) { puts(\"\"); }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring mp[20],str;\nint dir[256],h,w,m;\nchar ch[4]={'^','>','v','<'};\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\nint get_d(char a){\n  if(a=='U') return 0;\n  if(a=='R') return 1;\n  if(a=='D') return 2;\n  if(a=='L') return 3;\n  return -1;\n}\n\nvoid shoot(int x,int y,int d){\n  while(1){\n    x+=dx[d],y+=dy[d];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')return;\n    if(mp[y][x]=='*'){\n      mp[y][x]='.';\n      return;\n    }\n  }\n\n}\n\nvoid update(int x,int y,int d){\n  mp[y][x]='.';\n  for(int i=0;i<m;i++){\n    cout <<i<<endl;\n    int pd=d,nx,ny;\n    d=get_d(str[i]);\n    if(d==-1){d=pd,shoot(x,y,d);continue;}\n\n    nx=x+dx[d],ny=y+dy[d];\n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]!='.')nx=x,ny=y;\n    y=ny,x=nx;\n  }\n  mp[y][x]=ch[d];\n}\n\nint main(){\n  memset(dir,-1,sizeof(dir));\n  dir['^']=0,dir['>']=1,dir['v']=2,dir['<']=3;\n\n  int q;\n  cin>>q;\n  while(q--){\n    cin>>h>>w;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    cin>>m>> str;\n\n    for(int i=0;i<h;i++){\n      int f=0;\n      for(int j=0;j<w;j++) \n\tif(dir[mp[i][j]]!=-1) {\n\t  update(j,i,dir[mp[i][j]]);\n\t  f=1;\n\t  break;\n\t}\n      if(f)break\n    }\n\n    for(int i=0;i<h;i++)cout <<mp[i]<<endl;\n    if(q) cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nvoid Search(vector<string>&, int&, int&);\nvoid GoUp(vector<string>&, int&, int&);\nvoid GoDown(vector<string>&, int&, int&);\nvoid GoLeft(vector<string>&, int&, int&);\nvoid GoRight(vector<string>&, int&, int&);\nvoid ShootUp(vector<string>&, int&, int&);\nvoid ShootDown(vector<string>&, int&, int&);\nvoid ShootLeft(vector<string>&, int&, int&);\nvoid ShootRight(vector<string>&, int&, int&);\n\nint main(){\n  int i, j, n, m, h, w, x, y;\n  string s;\n  vector<string> str;\n\n  cin >> n;\n\n  for(i=0; i<n; ++i){\n    cin >> h >> w;\n\n    for(j=0; j<h; ++j){\n      cin >> s;\n      str.push_back(s);\n    }\n\n    Search(str, x, y);\n    cin >> m >> s;\n\n    for(j=0; j<s.size(); ++j){\n      if(s[j] == 'U') GoUp(str, x, y);\n      else if(s[j] == 'D') GoDown(str, x, y);\n      else if(s[j] == 'L') GoLeft(str, x, y);\n      else if(s[j] == 'R') GoRight(str, x, y);\n      else if(s[j] == 'S' && str[x][y] == '^') ShootUp(str, x, y);\n      else if(s[j] == 'S' && str[x][y] == 'v') ShootDown(str, x, y);\n      else if(s[j] == 'S' && str[x][y] == '<') ShootLeft(str, x, y);\n      else if(s[j] == 'S' && str[x][y] == '>') ShootRight(str, x, y);\n    }\n\n    for(j=0; j<h; ++j)\n      cout << str[j] << endl;\n\n    str.clear();\n  }\n  return 0;\n}\n\nvoid Search(vector<string>& str, int& x, int& y){\n  int i, j;\n  for(i=0, x=-1, y=-1; i<str.size(); ++i){\n    for(j=0; j<str[i].size(); ++j){\n      if(str[i][j] == '^' || str[i][j] == 'v' || str[i][j] == '<' || str[i][j] == '>'){\n\tx = i;\n\ty = j;\n\tbreak;\n      }\n    }\n    if(x != -1 && y != -1) break;\n  }\n}\n\nvoid GoUp(vector<string>& str, int& x, int& y){\n  if(x > 0 && str[x-1][y] == '.'){\n    str[x-1][y] = '^';\n    str[x][y] = '.';\n    --x;\n  }else{\n    str[x][y] = '^';\n  }\n}\n\nvoid GoDown(vector<string>& str, int& x, int& y){\n  if(x < str.size()-1 && str[x+1][y] == '.'){\n    str[x+1][y] = 'v';\n    str[x][y] = '.';\n    ++x;\n  }else{\n    str[x][y] = 'v';\n  }\n}\n\nvoid GoLeft(vector<string>& str, int& x, int& y){\n  if(y > 0 && str[x][y-1] == '.'){\n    str[x][y-1] = '<';\n    str[x][y] = '.';\n    --y;\n  }else{\n    str[x][y] = '<';\n  }\n}\n\nvoid GoRight(vector<string>& str, int& x, int& y){\n  if(y < str[x].size()-1 && str[x][y+1] == '.'){\n    str[x][y+1] = '>';\n    str[x][y] = '.';\n    ++y;\n  }else{\n    str[x][y] = '>';\n  }\n}\n\nvoid ShootUp(vector<string>& str, int& x, int& y){\n  int i;\n  for(i=x-1; i>-1; --i){\n    if(str[i][y] == '*'){\n      str[i][y] = '.';\n      break;\n    }else if(str[i][y] == '#'){\n      break;\n    }\n  }\n}\n\nvoid ShootDown(vector<string>& str, int& x, int& y){\n  int i;\n  for(i=x+1; i<str.size(); ++i){\n    if(str[i][y] == '*'){\n      str[i][y] = '.';\n      break;\n    }else if(str[i][y] == '#'){\n      break;\n    }\n  }\n}\n\nvoid ShootLeft(vector<string>& str, int& x, int& y){\n  int i;\n  for(i=y-1; i>-1; --i){\n    if(str[x][i] == '*'){\n      str[x][i] = '.';\n      break;\n    }else if(str[x][i] == '#'){\n      break;\n    }\n  }\n}\n\nvoid ShootRight(vector<string>& str, int& x, int& y){\n  int i;\n  for(i=y+1; i<str[x].size(); ++i){\n    if(str[x][i] == '*'){\n      str[x][i] = '.';\n      break;\n    }else if(str[x][i] == '#'){\n      break;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[20][21], t[4]={'^','>','v','<'};\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\t//ã0 E1 º2 ¶3\nint T, H, W, N;\nstruct {int x, y, a;} p;\t//íÔÌ éÀW,íÔÌü«\nvoid shoot(int x, int y, int a)\n{\n\twhile (0 <= x+dx[a] && x+dx[a] < W && 0 <= y+dy[a] && y+dy[a] < H)\n\t{\n\t\tx+=dx[a], y+=dy[a];\n\t\tif (m[y][x]=='*')\n\t\t{\n\t\t\tm[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t\telse if (m[y][x]=='#')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar o[101]=\"\";\n\tint i, j, nx, ny;\n\tcin >> T;\n\tfor (; T > 0; T--)\n\t{\n\t\tcin >> H >> W;\n\t\tfor (i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tswitch (m[i][j])\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t\tp.x=j, p.y=i, p.a=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tp.x=j, p.y=i, p.a=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tp.x=j, p.y=i, p.a=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tp.x=j, p.y=i, p.a=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[i][j]='\\0';\n\t\t}\n\t\tcin >> N >> o;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tswitch (o[i])\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\tp.a=0;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tp.a=2;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tp.a=3;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tp.a=1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshoot(p.x, p.y, p.a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx=p.x+dx[p.a], ny=p.y+dy[p.a];\n\t\t\tif (o[i] != 'S')\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\tif (0 <= nx && nx < W && 0 <= ny && ny < H && m[ny][nx]=='.')\n\t\t\t{\n\t\t\t\tm[p.y][p.x]='.';\n\t\t\t\tp.x=nx, p.y=ny;\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < H; i++)\n\t\t\tcout << m[i] << endl;\n\t\tif (T > 1)\n\t\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint h,w;\nchar map[25][25];\nchar dir;\n\nbool check( int i,int j ){\n  switch( map[i][j] ){\n  case '*': map[i][j]='.';\n  case '#': return true;\n  }\n  return false;\n}\n\nvoid shot(int y,int x){\n  //  cout << \"shot \" << y <<\" , \"<< x << \" \"<< dir << endl;\n  switch( dir ){\n  case 'u': for( int i=y-1;i>=0;i-- )  if( check(i,x) ) break;\n    break;\n  case 'd': for( int i=y+1;i<h;i++ ) if( check(i,x) ) break;\n    break;\n  case 'l': for( int i=x-1;i>=0;i-- ) if( check(y,i) ) break;\n    break;\n  case 'r': for( int i=x+1;i<w;i++ ) if( check(y,i) ) break;\n    break;\n  }\n}\n\nvoid show(int y,int x){\n  char cmd;\n  for( int i=0;i<h;i++ ){\n    for( int j=0;j<w;j++ ){\n      if( i==y && j== x){\n\tswitch( dir ){\n\tcase 'u': cmd='^'; break;\n\tcase 'd': cmd='v'; break;\n\tcase 'l': cmd='<'; break;\n\tcase 'r': cmd='>'; break;\n\t}\n      }else\tcmd=map[i][j];\n      cout << cmd;\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nint main(){\n  int datasetN,n, x,y;\n  char cmd;\n\n  cin >> datasetN;\n  while( datasetN-- ){\n    cin >> h >> w;\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> map[i][j];\n\tswitch( map[i][j] ){\n\tcase '^': map[i][j]='.';y=i;x=j; dir='u'; break;\n\tcase 'v': map[i][j]='.';y=i;x=j; dir='d'; break;\n\tcase '<': map[i][j]='.';y=i;x=j; dir='l'; break;\n\tcase '>': map[i][j]='.';y=i;x=j; dir='r'; break;\n\t}\n      }\n\n    cin >> n;\n    for( int lp=0;lp<n;lp++ ){\n      cin >> cmd;\n      switch( cmd ){\n      case 'U':\tdir='u';if( y-1>=0 && map[y-1][x]=='.' ) y--;\tbreak;\n      case 'D':\tdir='d';if( y+1<h  && map[y+1][x]=='.' ) y++;\tbreak;\n      case 'L': dir='l';if( x-1>=0 && map[y][x-1]=='.' ) x--;\tbreak;\n      case 'R':\tdir='r';if( x+1<w  && map[y][x+1]=='.' ) x++;\tbreak;\n      case 'S':\tshot(y,x);\tbreak;\n      }\n      /*\n      cout << \"CMD = \"<< cmd << endl;\n      show(y,x);\n      */\n    }    \n    show(y,x);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n\n\nint dy[]={0,1,0,-1};\nint dx[]={-1,0,1,0};\nchar dirs[]=\"<v>^\";\n\nchar field[20][20];\nint h,w;\n\nbool in(int y,int x){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nint main(){\n\tbool first=true;\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tstring com;\n\t\tint ty,tx,dir;\n\t\tcin>>h>>w;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tchar *p=find(dirs,dirs+4,field[i][j]);\n\t\t\t\tif(p!=dirs+4){\n\t\t\t\t\tty=i;\n\t\t\t\t\ttx=j;\n\t\t\t\t\tdir=p-dirs;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>com>>com;\n\t\tfor(int i=0;i<com.size();i++){\n\t\t\tif(com[i]=='S'){\n\t\t\t\tint y=ty,x=tx;\n\t\t\t\twhile(in(y,x)&&field[y][x]!='*'&&field[y][x]!='#'){\n\t\t\t\t\ty+=dy[dir];\n\t\t\t\t\tx+=dx[dir];\n\t\t\t\t}\n\t\t\t\tif(in(y,x)&&field[y][x]=='*'){\n\t\t\t\t\tfield[y][x]='.';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(com[i]=='U')dir=3;\n\t\t\t\telse if(com[i]=='D')dir=1;\n\t\t\t\telse if(com[i]=='L')dir=0;\n\t\t\t\telse if(com[i]=='R')dir=2;\n\t\t\t\tif(in(ty+dy[dir],tx+dx[dir])&&field[ty+dy[dir]][tx+dx[dir]]=='.'){\n\t\t\t\t\tty+=dy[dir];\n\t\t\t\t\ttx+=dx[dir];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfield[ty][tx]=dirs[dir];\n\t\tif(!first)cout<<'\\n';\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcout<<field[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tfirst=false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w, h;\nint dx[] = {0,0,1,-1};\nint dy[] = {-1,1,0,0};\n\nint main(){\n\tint t, n, tx, ty, d;\n\tstring f[21], s;\n\tchar dir[256];\n\tdir['U'] = '^';\n\tdir['D'] = 'v';\n\tdir['R'] = '>';\n\tdir['L'] = '<';\n\tdir['^'] = 0;\n\tdir['v'] = 1;\n\tdir['>'] = 2;\n\tdir['<'] = 3;\n\t\n\tcin >> t;\n\tfor(int i=0 ; i < t ; i++ ){\n\t\tcin >> h >> w;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> f[y];\n\t\t}\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tchar c = f[y][x];\n\t\t\t\tif( c == '>' || c == '<' || c == '^' || c == 'v' ){\n\t\t\t\t\ttx = x;\n\t\t\t\t\tty = y;\n\t\t\t\t\td = c;\n\t\t\t\t\tf[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tcin >> s;\n\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\tchar c = s[j];\n\t\t\tif( c == 'S' ){\n\t\t\t\tint sx = tx;\n\t\t\t\tint sy = ty;\n\t\t\t\tfor(;;){\n\t\t\t\t\tint mx = sx + dx[ dir[d] ];\n\t\t\t\t\tint my = sy + dy[ dir[d] ];\n\t\t\t\t\tif( mx < 0 || my < 0 || mx > w || my > h ) break;\n\t\t\t\t\tif( f[my][mx] == '.' || f[my][mx] == '-' ){\n\t\t\t\t\t\tsx = mx;\n\t\t\t\t\t\tsy = my;\n\t\t\t\t\t}else if( f[my][mx] == '*' ){\n\t\t\t\t\t\tf[my][mx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( f[my][mx] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\td = dir[c];\n\t\t\t\tint mx = tx + dx[ dir[d] ];\n\t\t\t\tint my = ty + dy[ dir[d] ];\n\t\t\t\tif( mx < 0 || my < 0 || mx > w || my > h ) continue;\n\t\t\t\tif( f[my][mx] == '.' ){\n\t\t\t\t\ttx = mx;\n\t\t\t\t\tty = my;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ty][tx] = d;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcout << f[y] << endl;\n\t\t}\n\t\tif( i != t-1 ) cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nint H,W;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\tscanf(\"%d %d\",&H,&W);\n\n\tchar table[H][W+1],order[101];\n\n\tint current_row = -1,current_col = -1;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",table[i]);\n\t\tif(current_row == -1){\n\t\t\tfor(int k = 0; table[i][k] != '\\0';k++){\n\t\t\t\tif(table[i][k] == '^'||table[i][k] == 'v' || table[i][k] == '<' || table[i][k] == '>'){\n\t\t\t\t\tcurrent_row = i;\n\t\t\t\t\tcurrent_col = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\tscanf(\"%d\",&N);\n\tscanf(\"%s\",order);\n\n\tfor(int i = 0; i < N; i++){\n\t\tswitch(order[i]){\n\t\tcase 'U':\n\t\t\tif(rangeCheck(current_row-1,current_col) == true && table[current_row-1][current_col] == '.'){ //?§?????????\\??????????????°\n\t\t\t\ttable[current_row-1][current_col] = '^';\n\t\t\t\ttable[current_row][current_col] = '.';\n\t\t\t\tcurrent_row--;\n\t\t\t}else{\n\t\t\t\ttable[current_row][current_col] = '^';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif(rangeCheck(current_row+1,current_col) == true && table[current_row+1][current_col] == '.'){ //?§?????????\\??????????????°\n\t\t\t\ttable[current_row+1][current_col] = 'v';\n\t\t\t\ttable[current_row][current_col] = '.';\n\t\t\t\tcurrent_row++;\n\t\t\t}else{\n\t\t\t\ttable[current_row][current_col] = 'v';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif(rangeCheck(current_row,current_col-1) == true && table[current_row][current_col-1] == '.'){ //?§?????????\\??????????????°\n\t\t\t\ttable[current_row][current_col-1] = '<';\n\t\t\t\ttable[current_row][current_col] = '.';\n\t\t\t\tcurrent_col--;\n\t\t\t}else{\n\t\t\t\ttable[current_row][current_col] = '<';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif(rangeCheck(current_row,current_col+1) == true && table[current_row][current_col+1] == '.'){ //?§?????????\\??????????????°\n\t\t\t\ttable[current_row][current_col+1] = '>';\n\t\t\t\ttable[current_row][current_col] = '.';\n\t\t\t\tcurrent_col++;\n\t\t\t}else{\n\t\t\t\ttable[current_row][current_col] = '>';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tswitch(table[current_row][current_col]){\n\t\t\tcase '^':\n\t\t\t\tfor(int row = current_row-1; row >= 0; row--){\n\t\t\t\t\tif(table[row][current_col] == '*'){\n\t\t\t\t\t\ttable[row][current_col] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(table[row][current_col] == '#'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tfor(int col = current_col-1; col >= 0; col--){\n\t\t\t\t\tif(table[current_row][col] == '*'){\n\t\t\t\t\t\ttable[current_row][col] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(table[current_row][col] == '#'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tfor(int col = current_col+1; col <= W-1; col++){\n\t\t\t\t\tif(table[current_row][col] == '*'){\n\t\t\t\t\t\ttable[current_row][col] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(table[current_row][col] == '#'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tfor(int row = current_row+1; row <= H-1; row++){\n\t\t\t\t\tif(table[row][current_col] == '*'){\n\t\t\t\t\t\ttable[row][current_col] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(table[row][current_col] == '#'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tprintf(\"%s\\n\",table[i]);\n\t}\n}\n\nint main(){\n\n\tint T;\n\tscanf(\"%d\",&T);\n\n\tfor(int i = 0; i < T; i++){\n\t\tif(i != 0){\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tfunc();\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n \n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<(b))\nusing namespace std;\nint t, h, w, n;\nchar town[32][32], cmd[128];\n \nvoid shot(int y, int x){\n   int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0}; // U D L R\n  int d;\n  switch(town[y][x]){\n  case '^': d = 0; break;\n  case 'v': d = 1; break;\n  case '<': d = 2; break;\n  case '>': d = 3; break;\n  }\n  //  printf(\"%d\\n\", d);\n  while(true){\n    if(between(0,y+dy[d], h) && between(0, x+dx[d], w)){\n      y+=dy[d]; x+=dx[d];\n      if(town[y][x] == '*'){\n    town[y][x] = '.';\n    break;\n      }else if(town[y][x] == '#'){\n    break;\n      }\n    }else break;\n  }\n  return;\n}\n \nint main(){\n  scanf(\"%d\", &t);\n  bool f = false;\n  while(t--){\n    scanf(\"%d%d\", &h, &w);\n    rep(i, h) scanf(\"%s\", town[i]);\n  \n    scanf(\"%d\", &n);\n    scanf(\"%s\", cmd);\n    int x, y;\n    rep(i, h) rep(j, w) \n      if(town[i][j]=='^' || town[i][j]=='v' || town[i][j]=='<' || town[i][j]=='>')x=j,y=i;\n    rep(i, n){\n      //      printf(\"%d %d\\n\", y, x);\n      switch(cmd[i]){\n      case 'U':\n    if(y-1 >= 0 && town[y-1][x] == '.'){ town[y][x] = '.'; town[--y][x] = '^';}\n    else town[y][x] = '^';\n    break;\n       case 'D':\n    if(y+1 < h && town[y+1][x] == '.'){ town[y][x] = '.'; town[++y][x] = 'v';}\n    else town[y][x] = 'v';\n    break;\n      case 'L':\n    if(x-1 >= 0 && town[y][x-1] == '.'){ town[y][x] = '.'; town[y][--x] = '<';}\n    else town[y][x] = '<';\n    break;\n      case 'R':\n    if(x+1 < w && town[y][x+1] == '.'){ town[y][x] = '.'; town[y][++x] = '>';}\n    else town[y][x] = '>';\n    break;\n      case 'S':\n    shot(y, x);\n    break;\n      }\n    }      \n    if(f) puts(\"\");\n    rep(i, h){\n      rep(j, w) printf(\"%c\", town[i][j]);\n      puts(\"\");\n    }\n     \n    f = 1;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tint t;\tscanf(\"%d\",&t);\n\tfor(int k=0;k<t;k++){\n\t\tint w,h;\tscanf(\"%d%d\",&h,&w);\n\t\tchar field[20][21];\n\t\tint x,y,dir;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tscanf(\"%s\",field[i]);\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(field[i][j]=='^')\tx=j,y=i,dir=1;\n\t\t\t\tif(field[i][j]=='v')\tx=j,y=i,dir=3;\n\t\t\t\tif(field[i][j]=='<')\tx=j,y=i,dir=2;\n\t\t\t\tif(field[i][j]=='>')\tx=j,y=i,dir=0;\n\t\t\t}\n\t\t}\n\n\t\tint n;\tscanf(\"%d \",&n);\n\t\twhile(n--){\n\t\t\tchar c=getchar();\n\t\t\tif(c=='U' || c=='D' || c=='L' || c=='R'){\n\t\t\t\tif(c=='U')\tdir=1,field[y][x]='^';\n\t\t\t\tif(c=='D')\tdir=3,field[y][x]='v';\n\t\t\t\tif(c=='L')\tdir=2,field[y][x]='<';\n\t\t\t\tif(c=='R')\tdir=0,field[y][x]='>';\n\t\t\t\tint xx=x+dx[dir],yy=y+dy[dir];\n\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h && field[yy][xx]=='.'){\n\t\t\t\t\tfield[yy][xx]=field[y][x];\n\t\t\t\t\tfield[y][x]='.';\n\t\t\t\t\tx=xx,y=yy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint sx=x,sy=y;\n\t\t\t\twhile(0<=sx && sx<w && 0<=sy && sy<h){\n\t\t\t\t\tif(field[sy][sx]=='*'){ field[sy][sx]='.'; break; }\n\t\t\t\t\tif(field[sy][sx]=='#')\tbreak;\n\t\t\t\t\tsx+=dx[dir],sy+=dy[dir];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<h;i++)\tputs(field[i]);\n\t\tif(k<t-1)\tputchar('\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nchar field[30][30];\n\nint main(){\n  int n;\n  bool isSen[128] = {false};\n  int  direct[128] = {0};\n  int  toDirect[128] = {0};\n  char toStr[5] = \"^>v<\";\n  int cc = 0;\n  isSen['>'] = isSen['^'] = isSen['v'] = isSen['<'] = true;\n  direct['>'] = 1; direct['^'] = 0; direct['v'] = 2; direct['<'] = 3;\n  toDirect['R'] = 1; toDirect['U'] = 0; toDirect['D'] = 2; toDirect['L'] = 3;\n  toDirect['S'] = 4;\n\n  scanf(\"%d\",&n);\n  while(n --> 0){\n    int h,w;\n    char buff[128];\n    int c;\n    int sx, sy;\n    if(cc++ != 0) puts(\"\");\n    scanf(\"%d%d \",&h,&w);\n    REP(i,h) fgets(field[i],sizeof(field[i]),stdin);\n    scanf(\"%d \",&c);\n    fgets(buff,sizeof(buff),stdin);\n    REP(i,h) REP(j,w) if(isSen[field[i][j]]){\n      sx = j; sy = i;\n      break;\n    }\n    REP(i,c){\n      int d = toDirect[buff[i]];\n      //printf(\"d = %d:\\n\",d);\n      if(d == 4){\n        int dx = _dx[direct[field[sy][sx]]];\n        int dy = _dy[direct[field[sy][sx]]];\n        int tx = sx + dx;\n        int ty = sy + dy;\n        //printf(\"direct = %d, dx = %d, dy = %d\\n\", direct[field[sy][sx]], dx, dy);\n        while(ISIN(tx,ty,w,h) && (field[ty][tx] == '.' || field[ty][tx] == '-')){\n          tx += dx;\n          ty += dy;\n        }\n        if(ISIN(tx,ty,w,h)){\n          //printf(\"tx = %d, ty = %d, hit %c\\n\",tx,ty,field[ty][tx]);\n          if(field[ty][tx] == '*')\n            field[ty][tx] = '.';\n        }\n        //REP(i,h) printf(\"%s\",field[i]);\n      }else{\n        int xx = sx + _dx[d];\n        int yy = sy + _dy[d];\n\n        if(ISIN(xx,yy,w,h) && field[yy][xx] == '.'){\n          field[sy][sx] = '.';\n          sx = xx; sy = yy;\n        }\n\n        field[sy][sx] = toStr[d];\n      }\n    }\n    REP(i,h) printf(\"%s\",field[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 20;\nP pos;\nchar m[MAX][MAX];\nint r,c;\n\nvoid input(){\n  for(int i = 0; i < r; i++)\n    for(int j = 0; j < c; j++){\n      cin >> m[i][j];\n      if(m[i][j] == '<' || m[i][j] == '>' || \n\t m[i][j] == '^' || m[i][j] == 'v') pos = P(i,j);\n    }\n}\n\nbool inside(P p){\n  return (0 <= p.first && p.first < r && 0 <= p.second && p.second < c);\n}\n\nvoid shoot(char c){\n\n  int x = 0, y = 0;\n  P p = pos;\n  if(c == '^') y = -1;\n  if(c == 'v') y = 1;\n  if(c == '>') x = 1;\n  if(c == '<') x = -1;\n\n  while(1){\n    p.first += y;\n    p.second += x;\n    if(!inside(p)) break;\n    if(m[p.first][p.second] == '#') break;\n    if(m[p.first][p.second] == '*'){\n      m[p.first][p.second] = '.';\n      break;\n    }\n  }\n}\n\nvoid move(char c, int x, int y){\n  if(inside(P(pos.first+y,pos.second+x)) && m[pos.first+y][pos.second+x] == '.'){\n    m[pos.first][pos.second] = '.';\n    m[pos.first+y][pos.second+x] = c;\n    pos.first += y;\n    pos.second += x;\n  }else{\n    m[pos.first][pos.second] = c;\n  }\n}\n\nint main(){\n  bool flag = false;\n  int X;\n  cin >> X;\n  while(X--){\n    if(flag) cout << endl;\n    flag = true;\n\n    cin >> r >> c;\n    input();\n    int num;\n    cin >> num;\n    for(int i = 0; i < num; i++){\n      char c;\n      cin >> c;\n      if(c == 'S') shoot(m[pos.first][pos.second]);\n      if(c == 'U') move('^',0,-1);\n      if(c == 'D') move('v',0,1);\n      if(c == 'L') move('<',-1,0);\n      if(c == 'R') move('>',1,0);\n    }\n\n    for(int i = 0; i < r; i++){\n      for(int j = 0; j < c; j++)\n\tcout << m[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint t, h, w, n, i, j, k, l, x, y, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar field[20][21], c, dir[] = {\"^>v<\"};/*　鉄壁　レンガ壁　水　平地 */;\n\tscanf(\"%d\",&t);\n\tfor(i = 0;i < t;i++){\n\t\tscanf(\"%d%d%*c\",&h,&w);\n\t\tfor(j = 0;j < h;j++){\n\t\t\tfor(k = 0;k < w;k++){\n\t\t\t\tfield[j][k] = getchar();\n\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\tif(dir[l] == field[j][k]){\n\t\t\t\t\t\ty = j, x = k;\n\t\t\t\t\t\td = l;\n\t\t\t\t\t\tfield[j][k] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[j][k] = '\\0';\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d%*c\",&n);\n\t\tfor(k = 0;k < n;k++){\n\t\t\tc = getchar();\n\t\t\tif(c == 'U'){\n\t\t\t\tif(y - 1 >= 0 && field[y - 1][x] == '.')\n\t\t\t\t\ty--;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(c == 'D'){\n\t\t\t\tif(y + 1 < h && field[y + 1][x] == '.')\n\t\t\t\t\ty++;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse if(c == 'L'){\n\t\t\t\tif(x - 1 >= 0 && field[y][x - 1] == '.')\n\t\t\t\t\tx--;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(c == 'R'){\n\t\t\t\tif(x + 1 < w && field[y][x + 1] == '.')\n\t\t\t\t\tx++;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse if(c == 'S'){\n\t\t\t\tfor(j = 1;y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && (field[y + dy[d] * j][x + dx[d] * j] == '.' || field[y + dy[d] * j][x + dx[d] * j] == '-');j++);\n\t\t\t\tif(y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && field[y + dy[d] * j][x + dx[d] * j] == '*')\n\t\t\t\t\tfield[y + dy[d] * j][x + dx[d] * j] = '.';\n\t\t\t}\n\t\t}\n\t\tgetchar();\n\t\tfield[y][x] = dir[d];\n\t\tfor(j = 0;j < h;j++)\n\t\t\tputs(field[j]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint main(){\n\tint T,h,w;\n\tcin >> T;\n\twhile(T--){\n\t\tcin >> h >> w;\n\t\tchar map[22][22];\n\t\tmemset(map,'#',sizeof map);\n\t\tint t[2];\n\t\tint v[][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n\t\tint d = 0;\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tfor(int j = 1; j <= w; ++j){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tswitch(map[i][j]){\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\t++d;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\t++d;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t++d;\n\t\t\t\t\tcase '^':\n\t\t\t\t\t\tt[0] = i;\n\t\t\t\t\t\tt[1] = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n;\n\t\tcin >> n;\n\t\tchar c[101];\n\t\tcin >> c;\n\t\tchar *com = c;\n\t\twhile(*com){\n\t\t\tint _d = 4;\n\t\t\tswitch(*com){\n\t\t\t\tcase 'U':\n\t\t\t\t\t--_d;\n\t\t\t\tcase 'D':\n\t\t\t\t\t--_d;\n\t\t\t\tcase 'L':\n\t\t\t\t\t--_d;\n\t\t\t\tcase 'R':\n\t\t\t\t\t--_d;\n\t\t\t\t\td = _d;\n\t\t\t\t\tif(map[t[0]+v[d][0]][t[1]+v[d][1]] == '.'){\n\t\t\t\t\t\tt[0] += v[d][0];\n\t\t\t\t\t\tt[1] += v[d][1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tint b[] = {t[0],t[1]};\n\t\t\t\t\tbool f = true;\n\t\t\t\t\twhile(f){\n\t\t\t\t\t\tb[0] += v[d][0];\n\t\t\t\t\t\tb[1] += v[d][1];\n\t\t\t\t\t\tswitch(map[b[0]][b[1]]){\n\t\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\t\tmap[b[0]][b[1]] = '.';\n\t\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t++com;\n\t\t}\n\t\tchar td[] = {'^','v','<','>'};\n\t\tmap[t[0]][t[1]] = td[d];\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tfor(int j = 1; j <= w; ++j){\n\t\t\t\tcout << map[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tif(T) cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <string>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n#define fi first\n#define se second\nP2 p;\nint n,h,w;\nstring s[21],t;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nP2 get_tank(){\n  r(i,h)r(j,w){\n    if(s[i][j]=='^')return P2(0,P(i,j));\n    if(s[i][j]=='>')return P2(1,P(i,j));\n    if(s[i][j]=='v')return P2(2,P(i,j));\n    if(s[i][j]=='<')return P2(3,P(i,j));\n  }\n}\nvoid shoot(){\n  int y=p.se.fi;\n  int x=p.se.se;\n  while(1){\n    y+=dy[p.fi];\n    x+=dx[p.fi];\n    if(x<0||y<0||y>=h||x>=w)break;\n    if(s[y][x]=='#')break;\n    if(s[y][x]=='*'){\n      s[y][x]='.';\n      break;\n    }\n  }\n}\nvoid GGG(int po){\n  p.fi=po;\n  int y=p.se.fi+dy[po];\n  int x=p.se.se+dx[po];\n  if(x<0||y<0||y>=h||x>=w)return;\n  if(s[y][x]!='.')return;\n  p.se.fi=y;\n  p.se.se=x;\n}\nint main(){\n  cin>>n;\n  while(n--){\n    cin>>h>>w;\n    r(i,h)cin>>s[i];\n    p=get_tank();\n    s[p.se.fi][p.se.se]='.';\n    cin>>t>>t;\n    r(i,t.size()){\n      if(t[i]=='S')shoot();\n      else{\n\tint po;\n        if(t[i]=='U')po=0;\n        if(t[i]=='R')po=1;\n        if(t[i]=='D')po=2;\n        if(t[i]=='L')po=3;\n\tGGG(po);\n      }\n    }\n    if(p.fi==0)s[p.se.fi][p.se.se]='^';\n    if(p.fi==1)s[p.se.fi][p.se.se]='>';\n    if(p.fi==2)s[p.se.fi][p.se.se]='v';\n    if(p.fi==3)s[p.se.fi][p.se.se]='<';\n    r(i,h)cout<<s[i]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\n#define N 32\n#define PLANE '.'\n#define BLOCK '*'\n#define STEEL '#'\n#define WATER '-'\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\nconst char *tank_dir = \"^>v<\";\nint conv[256]={0,};\n\nusing namespace std;\n\nbool isinside(int i, int j, int h, int w){\n  return 0<=i&&i<h&&0<=j&&j<w;\n}\n\nvoid simulate(char M[][N], int h, int w, const string &v)\n{\n  int ti;\n  int tj;\n  int dir;\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j){\n      for(int k = 0; k < 4; ++k){\n\tif( tank_dir[k] == M[i][j] ){\n\t  ti = i;\n\t  tj = j;\n\t  dir = k;\n\t  M[i][j]=PLANE;\n\t}\n      }\n    }\n  }\n  conv['U']=0;\n  conv['R']=1;\n  conv['D']=2;\n  conv['L']=3;\n\n  for(int s=0;s<v.length();++s){\n    switch(v[s]){\n    case 'U':\n    case 'D':\n    case 'L':\n    case 'R':\n      {\n\tint ni = ti+di[conv[v[s]]];\n\tint nj = tj+dj[conv[v[s]]];\n\tdir = conv[v[s]];\n\tif( isinside(ni,nj,h,w) ){\n\t  if( M[ni][nj] == PLANE ){\n\t    ti = ni;\n\t    tj = nj;\n\t  }\n\t}\n      }\n      break;\n    case 'S':\n      {\n\tint ai=ti,aj=tj;\n\twhile(true){\n\t  ai += di[dir];\n\t  aj += dj[dir];\n\t  \n\t  if( isinside(ai,aj,h,w) ){\n\t    if( M[ai][aj] == PLANE || M[ai][aj] == WATER ) continue;\n\t    else break;\n\t  }else break;\n\t  \n\t}\n\tif( M[ai][aj] == BLOCK ){\n\t  M[ai][aj] = PLANE;\n\t}\n      }\n      break;\n    }\n  }\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j){\n      if( i == ti && j == tj ){\n\tputchar(tank_dir[ dir ]);\n      }else{\n\tputchar(M[i][j]);\n      }\n    }\n    putchar('\\n');\n  }\n  return ;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n    int h,w;\n    char M[N][N];\n    string cmd;\n    cin >> h >> w;\n    if( tc > 1 )putchar('\\n');\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n      }\n    }\n    int vlen;\n    cin >> vlen;\n    cin >> cmd;\n    \n    simulate( M, h, w, cmd );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[20][21], t[4]={'^','>','v','<'};\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\t//ã0 E1 º2 ¶3\nint T, H, W, N;\nstruct {int x, y, a;} p;\t//íÔÌ éÀW,íÔÌü«\nvoid shoot(int x, int y, int a)\n{\n\twhile (0 <= x+dx[a] && x+dx[a] < W && 0 <= y+dy[a] && y+dy[a] < H)\n\t{\n\t\tx+=dx[a], y+=dy[a];\n\t\tif (m[y][x]=='*')\n\t\t{\n\t\t\tm[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t\telse if (m[y][x]=='#')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar o[101]=\"\";\n\tint i, j, nx, ny;\n\tcin >> T;\n\tfor (; T > 0; T--)\n\t{\n\t\tcin >> H >> W;\n\t\tfor (i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tswitch (m[i][j])\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t\tp.x=j, p.y=i, p.a=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tp.x=j, p.y=i, p.a=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tp.x=j, p.y=i, p.a=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tp.x=j, p.y=i, p.a=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[i][j]='\\0';\n\t\t}\n\t\tcin >> N >> o;\n\t\tif (T > 1)\n\t\t\tcout << endl;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tswitch (o[i])\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\tp.a=0;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tp.a=2;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tp.a=3;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tp.a=1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshoot(p.x, p.y, p.a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx=p.x+dx[p.a], ny=p.y+dy[p.a];\n\t\t\tif (o[i] != 'S' && 0 <= nx && nx < W && 0 <= ny && ny < H && m[ny][nx]=='.')\n\t\t\t{\n\t\t\t\tm[p.y][p.x]='.';\n\t\t\t\tp.x=nx, p.y=ny;\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < H; i++)\n\t\t\tcout << m[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint w,h;\nint px,py,pa;\nchar f[22][22];\nint dx[] = {0,0,-1,1};\nint dy[] = {-1,1,0,0};\nint main(void){\n  int n;\n  cin >> n;\n  for(int k = 0; k < n; k++){\n    cin >> h >> w;\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n\tcin >> f[x][y];\n\tswitch(f[x][y]){\n\tcase '^': px = x; py = y; pa = 0; break;\n\tcase 'v': px = x; py = y; pa = 1; break;\n\tcase '<': px = x; py = y; pa = 2; break;\n\tcase '>': px = x; py = y; pa = 3; break;\n\t}\n      }\n    }\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      char c;\n      cin >> c;\n      if(c == 'S'){\n\tfor(int nx = px + dx[pa],ny = py + dy[pa];0 <= nx && nx < w && 0 <= ny && ny < h; nx+=dx[pa],ny+=dy[pa]){\n\t  if(f[nx][ny] == '*'){\n\t    f[nx][ny] = '.';\n\t    break;\n\t  }\n\t  if(f[nx][ny] == '#') break;\n\t}\n      }else{\n\tf[px][py] = '.';\n\tswitch(c){\n\tcase 'U': pa = 0; break;\n\tcase 'D': pa = 1; break;\n\tcase 'L': pa = 2; break;\n\tcase 'R': pa = 3; break;\n\t}\n\tint nx = px + dx[pa];\n\tint ny = py + dy[pa];\n\tif(0 <= nx && nx < w && 0 <= ny && ny < h && f[nx][ny] == '.'){\n\t  px = nx;\n\t  py = ny;\n\t}\n\tswitch(pa){\n\tcase 0: f[px][py]='^'; break;\n\tcase 1: f[px][py]='v'; break;\n\tcase 2: f[px][py]='<'; break;\n\tcase 3: f[px][py]='>'; break;\n\t}\n      }\n    }\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n\tcout << f[x][y];\n      }\n      cout << endl;\n    }\n      cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[20][21], t[4]={'^','>','v','<'};\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\t//ã0 E1 º2 ¶3\nint T, H, W, N;\nstruct {int x, y, a;} p;\t//íÔÌ éÀW,íÔÌü«\nvoid shoot(int x, int y, int a)\n{\n\twhile (0 <= x+dx[a] && x+dx[a] <= W && 0 <= y+dy[a] && y+dy[a] <= H)\n\t{\n\t\tx+=dx[a], y+=dy[a];\n\t\tif (m[y][x]=='*')\n\t\t{\n\t\t\tm[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t\telse if (m[y][x]=='#')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar o[101]=\"\";\n\tint i, j, nx, ny;\n\tcin >> T;\n\tfor (; T > 0; T--)\n\t{\n\t\tcin >> H >> W;\n\t\tfor (i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tswitch (m[i][j])\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t\tp.x=j, p.y=i, p.a=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tp.x=j, p.y=i, p.a=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tp.x=j, p.y=i, p.a=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tp.x=j, p.y=i, p.a=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[i][j]='\\0';\n\t\t}\n\t\tcin >> N >> o;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tswitch (o[i])\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\tp.a=0;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tp.a=2;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tp.a=3;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tp.a=1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshoot(p.x, p.y, p.a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx=p.x+dx[p.a], ny=p.y+dy[p.a];\n\t\t\tif (o[i] != 'S' && m[ny][nx]=='.')\n\t\t\t{\n\t\t\t\tm[p.y][p.x]='.';\n\t\t\t\tp.x=nx, p.y=ny;\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < H; i++)\n\t\t\tcout << m[i] << endl;\n\t\tif (T > 1)\n\t\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst string DIRS = \"URDL\", TANK = \"^>v<\";\nconst int dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nint dir(char c) { return DIRS.find(c); }\n\nint T, H, W, N, tx, ty;\nstring grid[22], operation;\n\nvoid move(int d) {\n\tgrid[ty][tx] = '.';\n\t\n\tint nx = tx + dx[d], ny = ty + dy[d];\n\t\n\tif (in_range(nx, ny, W, H) && grid[ny][nx] == '.') {\n\t\tgrid[ny][nx] = TANK[d];\n\t\tty = ny; tx = nx;\n\t} else {\n\t\tgrid[ty][tx] = TANK[d];\n\t}\n}\n\nvoid shoot() {\n\tint d = TANK.find(grid[ty][tx]);\n\tint x = tx + dx[d], y = ty + dy[d];\n\t\n\twhile (in_range(x, y, W, H) && grid[y][x] != '#' && grid[y][x] != '*') {\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\t\n\tif (in_range(x, y, W, H) && grid[y][x] == '*') grid[y][x] = '.';\n}\n\nvoid simulate() {\n\tfor_(i,0,N) {\n\t\tchar c = operation[i];\n\t\t\n\t\tif (c == 'S') {\n\t\t\tshoot();\n\t\t} else {\n\t\t\tmove(dir(c));\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> T;\n\t\n\tfor_(case_num,0,T) {\n\t\tcin >> H >> W;\n\t\t\n\t\tfor_(y,0,H) {\n\t\t\tcin >> grid[y];\n\t\t\tfor_(x,0,W) if (TANK.find(grid[y][x]) != TANK.npos) tx = x, ty = y;\n\t\t}\n\t\t\n\t\tcin >> N;\n\t\tcin >> operation;\n\t\t\n\t\tsimulate();\n\t\t\n\t\tfor_(y,0,H) cout << grid[y] << endl;\n\t\tif (case_num < T - 1) cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint T,H,W,N,dx[]={0,0,-1,1},dy[]={-1,1,0,0};\nchar f[20][20],c;\n\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>H>>W;\n\t\tint x,y,d;\n\t\trep(i,H)rep(j,W){\n\t\t\tcin>>f[i][j];\n\t\t\tif(f[i][j]=='^'){y=i;x=j;d=0;}\n\t\t\tif(f[i][j]=='v'){y=i;x=j;d=1;}\n\t\t\tif(f[i][j]=='<'){y=i;x=j;d=2;}\n\t\t\tif(f[i][j]=='>'){y=i;x=j;d=3;}\n\t\t}\n\t\tcin>>N;\n\t\trep(i,N){\n\t\t\tcin>>c;\n\t\t\tif(c=='U'){\n\t\t\t\td=0;f[y][x]='^';\n\t\t\t\tif(y>0&&f[y-1][x]=='.'){\n\t\t\t\t\ty--;\n\t\t\t\t\tf[y][x]='^';\n\t\t\t\t\tf[y+1][x]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\td=1;f[y][x]='v';\n\t\t\t\tif(y<H-1&&f[y+1][x]=='.'){\n\t\t\t\t\ty++;\n\t\t\t\t\tf[y][x]='v';\n\t\t\t\t\tf[y-1][x]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='L'){\n\t\t\t\td=2;f[y][x]='<';\n\t\t\t\tif(x>0&&f[y][x-1]=='.'){\n\t\t\t\t\tx--;\n\t\t\t\t\tf[y][x]='<';\n\t\t\t\t\tf[y][x+1]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\td=3;f[y][x]='>';\n\t\t\t\tif(x<W-1&&f[y][x+1]=='.'){\n\t\t\t\t\tx++;\n\t\t\t\t\tf[y][x]='>';\n\t\t\t\t\tf[y][x-1]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='S'){\n\t\t\t\tint bx=x,by=y;\n\t\t\t\twhile(bx>=0&&bx<=W-1&&by>=0&&by<=H-1){\n\t\t\t\t\tbx+=dx[d];by+=dy[d];\n\t\t\t\t\tif(f[by][bx]=='*'){f[by][bx]='.';break;}\n\t\t\t\t\tif(f[by][bx]=='#')break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,H)rep(j,W)cout<<f[i][j]<<(j<W-1?\"\":\"\\n\");\n\t\tif(T)cout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\nstring grid[100], s;\nint x, y;\nint w, h;\n\ntypedef pair<int, int> pii;\n\nvoid move(int dx, int dy, char c){\n  int nx = x + dx, ny = y + dy;\n  if(c == 'R'){\n    grid[y][x] = '>';\n  }else if(c == 'L'){\n    grid[y][x] = '<';\n  }else if(c == 'U'){\n    grid[y][x] = '^';\n  }else if(c == 'D'){\n    grid[y][x] = 'v';\n  }\n  if(0 <= nx && nx < w &&\n     0 <= ny && ny < h &&\n     grid[ny][nx] == '.'){\n    grid[y][x] = '.';\n    if(c == 'R'){\n      grid[ny][nx] = '>';\n    }else if(c == 'L'){\n      grid[ny][nx] = '<';\n    }else if(c == 'U'){\n      grid[ny][nx] = '^';\n    }else if(c == 'D'){\n      grid[ny][nx] = 'v';\n    }\n    x = nx , y = ny;\n  }\n}\n\nvoid shoot(char dist){\n  //cout << \"shoot\" << endl;\n\n  if(dist == 'v'){\n    for(int i = 0;i + y < h; i++){\n      if(grid[i + y][x] == '#' || grid[i + y][x] == '*'){\n\tif(grid[i + y][x] == '*')grid[i + y][x] = '.';\n\tbreak;\n      }\n    }\n  }else if(dist == '<'){\n    for(int i = 0;i + x >= 0; i--){\n      if(grid[y][x + i] == '#' || grid[y][x+i] =='*'){\n\tif(grid[y][x+i] == '*')grid[y][x+i] = '.';\n\tbreak;\n      }\n    } \n  }else if(dist == '>'){\n    for(int i = 0;i + x < w; i++){\n      if(grid[y][x + i] == '#' || grid[y][x+i] =='*'){\n\tif(grid[y][x+i] == '*')grid[y][x+i] = '.';\n\tbreak;\n      }\n    } \n  }else{\n    for(int i = 0;i + y >= 0; i--){\n      if(grid[i + y][x] == '#' || grid[i + y][x] == '*'){\n\tif(grid[i + y][x] == '*')grid[i + y][x] = '.';\n\tbreak;\n      }\n    }\n  }\n\t\n}\n\nint main(){\n  int n;\n  cin >> n;\n  for(int ite = 0; ite < n; ite++){\n\n    cin >> h >> w;\n    for(int i = 0;i < h; i++){\n      cin >> grid[i];\n    }\n\n    for(int i = 0;i < h; i++){\n      for(int j = 0;j < w; j++){\n\tif(grid[i][j] == 'v' || grid[i][j] == '<' ||\n\t   grid[i][j] == '>' || grid[i][j] == '^'){\n\t  x = j; y = i;\n\t}\n      }\n    }\n    map<char, pii> next_trun;\n    next_trun['R'] = mp(1, 0);\n    next_trun['U'] = mp(0, -1);\n    next_trun['L'] = mp(-1, 0);\n    next_trun['D'] = mp(0, 1);\n    next_trun['S'] = mp(0, 0);\n    int tmp;\n    cin >> tmp >> s;\n    for(int i = 0; i < s.length(); i++){\n      if(next_trun[s[i]].first == 0 && next_trun[s[i]].second == 0){\n\tshoot(grid[y][x]);\n      }else{\n\tmove(next_trun[s[i]].first, next_trun[s[i]].second, s[i]);\n      }\n      //cout << next_trun[s[i]].first << \" \" << next_trun[s[i]].second << endl;\n\n      //cout << s[i] << \" \" << x << \" \" << y << endl;\n    }\n    for(int i = 0; i < h; i++){\n      cout << grid[i] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int h,w,n,t,x,y;\n  string tmp,command;\n  vector<string> field;\n\n  cin >> t;\n\n  while(t--){\n    cin >> h >> w;\n\n    field.clear();\n    for(int i=0;i<h;i++){\n      cin >> tmp;\n      field.push_back(tmp);\n    }\n\n    cin >> n;\n    cin >> command;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(field[i][j] == '^' || field[i][j] == '>' || field[i][j] == 'v' || field[i][j] == '<'){\n\t  y = i;\n\t  x = j;\n\t}\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      if(command[i] == 'S'){\n\tint tmp = 1;\n\tif(field[y][x] == '^'){\n\t  while(y - tmp >= 0){\n\t    if(field[y-tmp][x] == '*'){\n\t      field[y-tmp][x] = '.';\n\t      break;\n\t    }\n\t    if(field[y-tmp][x] == '#')break;\n\t    tmp++;\n\t  }\n\t}\n\tif(field[y][x] == '>'){\n\t  while(x + tmp < w){\n\t    if(field[y][x+tmp] == '*'){\n\t      field[y][x+tmp] = '.';\n\t      break;\n\t    }\n\t    if(field[y][x+tmp] == '#')break;\n\t    tmp++;\n\t  }\n\t}\n\tif(field[y][x] == 'v'){\n\t  while(y + tmp < h){\n\t    if(field[y+tmp][x] == '*'){\n\t      field[y+tmp][x] = '.';\n\t      break;\n\t    }\n\t    if(field[y+tmp][x] == '#')break;\n\t    tmp++;\n\t  }\n\t}\n\tif(field[y][x] == '<'){\n\t  while(x - tmp >= 0){\n\t    if(field[y][x-tmp] == '*'){\n\t      field[y][x-tmp] = '.';\n\t      break;\n\t    }\n\t    if(field[y][x-tmp] == '#')break;\n\t    tmp++;\n\t  }\n\t}\n      }else{\n\tfield[y][x] = '.';\n\tif(command[i] == 'U'){\n\t  if(y > 0 && field[y-1][x] == '.')y--;\n\t  field[y][x] = '^';\n\t}\n      }\n      if(command[i] == 'R'){\n\tif(x < w-1 && field[y][x+1] == '.')x++;\n\tfield[y][x] = '>';\n\t}\n      if(command[i] == 'D'){\n\tif(y < h-1 && field[y+1][x] == '.')y++;\n\tfield[y][x] = 'v';\n      }\n      if(command[i] == 'L'){\n\tif(x > 0 && field[y][x-1] == '.')x--;\n\tfield[y][x] = '<';\n      } \n    }\n\n    for(int i=0;i<h;i++)cout << field[i] << endl;\n    if(t)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nstruct player{\n\tpublic:\n\t\tplayer(char a, int b, int c):dir(a), posX(b), posY(c){}\n\t\tvoid actU(vector<vector<char> > &table){\n\t\t\tif(posY-1<0){\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t\tdir = '^';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY-1][posX] == '.'){\n\t\t\t\ttable[posY--][posX] = '.';\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t}\n\t\t\telse table[posY][posX] = '^';\n\t\t\tdir = '^';\n\t\t}\n\t\tvoid actD(vector<vector<char> > &table){\n\t\t\tif(posY+1>=table.size()){\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t\tdir = 'v';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY+1][posX] == '.'){\n\t\t\t\ttable[posY++][posX] = '.';\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t}\n\t\t\telse table[posY][posX] = 'v';\n\t\t\tdir = 'v';\n\t\t}\n\t\tvoid actL(vector<vector<char> > &table){\n\t\t\tif(posX-1<0){\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t\tdir = '<';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX-1] == '.'){\n\t\t\t\ttable[posY][posX--] = '.';\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t}\n\t\t\telse table[posY][posX] = '<';\n\t\t\tdir = '<';\n\t\t}\n\t\tvoid actR(vector<vector<char> > &table){\n\t\t\tif(posX+1>=table[0].size()){\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t\tdir = '>';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX+1] == '.'){\n\t\t\t\ttable[posY][posX++] = '.';\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t}\n\t\t\telse table[posY][posX] = '>';\n\t\t\tdir = '>';\n\t\t}\n\t\tvoid actS(vector<vector<char> > &table){\n\t\t\tint progressX = 0;\n\t\t\tint progressY = 0;\n\t\t\tif(dir == '^') progressY = -1;\n\t\t\telse if(dir == 'v') progressY = 1;\n\t\t\telse if(dir == '<') progressX = -1;\n\t\t\telse if(dir == '>') progressX = 1;\n\t\t\tint sposX = posX+progressX, sposY = posY+progressY;\n\t\t\twhile((sposX>=0&&sposX<table[0].size())&&(sposY>=0&&sposY<table.size())){\n\t\t\t\tif(table[sposY][sposX] == '*' || table[sposY][sposX] == '#'){\n\t\t\t\t\tif(table[sposY][sposX] == '*') table[sposY][sposX] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsposX += progressX;\n\t\t\t\tsposY += progressY;\n\t\t\t}\n\t\t}\n\t\tchar dir;\n\t\tint posX;\n\t\tint posY;\n};\n\nvoid action(char act, player &p, vector<vector<char> > &table){\n\tswitch(act){\n\tcase 'U':\n\t\tp.actU(table);\n\t\tbreak;\n\tcase 'D':\n\t\tp.actD(table);\n\t\tbreak;\n\tcase 'L':\n\t\tp.actL(table);\n\t\tbreak;\n\tcase 'R':\n\t\tp.actR(table);\n\t\tbreak;\n\tcase 'S':\n\t\tp.actS(table);\n\t\tbreak;\n\tdefault:\n\t\t\tbreak;\n\t}\n\n}\n\nint main(){\n\tint n = 0;\n\tcin >> n;\n\twhile(n--){\n\t\tint h = 0, w = 0;\n\t\tcin >> h >> w;\n\t\tvector<vector<char> > table(h, vector<char>(w, ' '));\n\t\tplayer p(' ', -1, -1);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tif(table[i][j]=='^'||table[i][j]=='v'||table[i][j]=='<'||table[i][j]=='>'){\n\t\t\t\t\tp.dir = table[i][j];\n\t\t\t\t\tp.posX = j;\n\t\t\t\t\tp.posY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = 0;\n\t\tcin >> m;\n\t\tvector<char> act(m, ' ');\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> act[i];\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\taction(act[i], p, table);\n\t\t}\n\n\t\tfor(int i = 0; i < table.size(); i++){\n\t\t\tfor(int j = 0; j < table[0].size(); j++){\n\t\t\t\tcout << table[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <string.h>\nusing namespace std;\n\nchar str[]=\"^v<>\";\n\nvoid shot(vector<string> &m,int x,int y,int dir)\n{\n\tstatic int dx[]={0,0,-1,1};\n\tstatic int dy[]={-1,1,0,0};\n\t\n\twhile(true){\n\t\tx+=dx[dir];\n\t\ty+=dy[dir];\n\t\tif( x<0 || y<0 || x>=m[0].length() || y>=m.size()) break;\n\t\tif( m[y][x]=='*' ){\n\t\t\tm[y][x]='.';\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif( m[y][x]=='#' ){\n\t\t\tbreak;\n\t\t}\t\t\n\t}\n\treturn;\n}\n\nbool f(vector<string> &m,int x,int y)\n{\n\tif( x<0 || y<0 || x>= m[0].length() || y>=m.size()) return false;\n\treturn m[y][x]=='.';\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tfor(int i=0;i<N;i++){\n\t\tint H,W;\n\t\tcin >> H >> W;\n\t\tvector<string> m(H);\n\t\tfor(int h=0;h<H;h++){\n\t\t\tcin >> m[h];\n\t\t}\n\t\tint sx,sy,dir;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tchar c=m[y][x];\n\t\t\t\tchar *p=strchr(str,c);\n\t\t\t\tif(p){\n\t\t\t\t\tsx=x;\n\t\t\t\t\tsy=y;\n\t\t\t\t\tdir = p-str;\n\t\t\t\t\tm[y][x]='.';\n\t\t\t\t\t\n//\t\t\t\t\tcout << sx << \",\" << sy << \",\" << dir << endl;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tswitch(c){\n\t\t\t\tcase 'U':\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tif(f(m,sx,sy-1)){\n\t\t\t\t\t\tsy--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdir = 1;\n\t\t\t\t\tif(f(m,sx,sy+1)){\n\t\t\t\t\t\tsy++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tif(f(m,sx-1,sy)){\n\t\t\t\t\t\tsx--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tdir = 3;\n\t\t\t\t\tif(f(m,sx+1,sy)){\n\t\t\t\t\t\tsx++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tshot(m,sx,sy,dir);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i!=0){\n\t\t\tcout << endl;\n\t\t}\n\t\tm[sy][sx]=str[dir];\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tchar c=m[y][x];\n\t\t\t\tcout << c;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\n\nint main(){\n    int t;\n    cin >> t;\n\n    map<char,int> wj, wi;\n    wj['^'] = 0; wi['^'] = -1;\n    wj['U'] = 0; wi['U'] = -1;\n    wj['v'] = 0; wi['v'] = +1;\n    wj['D'] = 0; wi['D'] = +1;\n    wj['<'] = -1; wi['<'] = 0;\n    wj['L'] = -1; wi['L'] = 0;\n    wj['>'] = +1; wi['>'] = 0;\n    wj['R'] = +1; wi['R'] = 0;\n\n    map<char,char> enc;\n    enc['D'] = 'v';\n    enc['U'] = '^';\n    enc['L'] = '<';\n    enc['R'] = '>';\n\n    while(t-- > 0){\n        int h, w;\n        cin >> h >> w;\n\n        char mat[h][w];\n        int ri, rj, di, dj;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> mat[i][j];\n                if(wj.count(mat[i][j])) ri = i, rj = j, di = wi[mat[i][j]], dj = wj[mat[i][j]];\n            }\n        }\n\n        int n;\n        string s;\n        cin >> n >> s;\n\n        for(char op : s){\n            if(op != 'S'){\n                di = wi[op], dj = wj[op];\n                int ni = ri+di, nj = rj+dj;\n                if(inRange(ni, 0, h) && inRange(nj, 0, w) && mat[ni][nj] == '.'){\n                    mat[ri][rj] = '.';\n                    ri = ni, rj = nj;\n                    mat[ri][rj] = enc[op];\n                }else{\n                    mat[ri][rj] = enc[op];\n                }\n            }else{\n                int si = ri+di, sj = rj+dj;\n                while(inRange(si, 0, h) && inRange(sj, 0, w)){\n                    if(mat[si][sj] == '*'){\n                        mat[si][sj] = '.';\n                        break;\n                    }\n                    if(mat[si][sj] == '#'){\n                        break;\n                    }\n                    si += di, sj += dj;\n                }\n            }\n        }\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cout << mat[i][j];\n            }\n            cout << endl;\n        }\n\n        if(t)   cout << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n#define MAX 21\nchar map[MAX][MAX];\nenum Dir{UP,RIGHT,LEFT,DOWN};\nint w,h;\nclass Tank{\npublic:\n\tint dir;\n\tint x;\n\tint y;\n};\nTank tank;\n\nint judgeDir(char c){\n\tif(c=='^')return UP;\n\tif(c=='v')return DOWN;\n\tif(c=='>')return RIGHT;\n\tif(c=='<')return LEFT;\n}\nchar getCharDir(){\n\tif(tank.dir==UP)return '^';\n\tif(tank.dir==DOWN)return 'v';\n\tif(tank.dir==RIGHT)return '>';\n\tif(tank.dir==LEFT)return '<';\n}\n\nvoid init(){\n\tfor(int i=0;i<21;i++){\n\t\tfor(int j=0;j<21;j++)map[i][j]='N';\n\t}\n}\nvoid shoot(){\n\tint dy=0;\n\tint dx=0;\n\tif(tank.dir==UP)dy=-1;\n\tif(tank.dir==DOWN)dy=1;\n\tif(tank.dir==RIGHT)dx=1;\n\tif(tank.dir==LEFT)dx=-1;\n\tint x=tank.x;\n\tint y=tank.y;\n\tfor(;;){\n\t\tif(x+dx<0||x+dx>w||y+dy<0||y+dy>h||map[y+dy][x+dx]=='#')break;\n\t\tx+=dx;\n\t\ty+=dy;\n\t\tif(map[y][x]=='*'){\n\t\t\tmap[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ;\n}\nvoid next(char command){\n\tmap[tank.y][tank.x]='.';\n\tif(command=='U'){\n\t\ttank.dir=UP;\n\t\tif(tank.y-1>=0 && map[tank.y-1][tank.x]=='.'){\n\t\t\ttank.y=tank.y-1;\n\t\t}\n\t}\n\telse if(command=='D'){\n\t\ttank.dir=DOWN;\n\t\tif(tank.y+1<h && map[tank.y+1][tank.x]=='.'){\n\t\t\ttank.y=tank.y+1;\n\t\t}\n\t}\n\telse if(command=='L'){\n\t\ttank.dir=LEFT;\n\t\tif(tank.x-1>=0 && map[tank.y][tank.x-1]=='.'){\n\t\t\ttank.x=tank.x-1;\n\t\t}\n\t}\n\telse if(command=='R'){\n\t\ttank.dir=RIGHT;\n\t\tif(tank.x+1<w && map[tank.y][tank.x+1]=='.'){\n\t\t\ttank.x=tank.x+1;\n\t\t}\n\t}\n\telse if(command=='S'){\n\t\tshoot();\n\t}\n\tmap[tank.y][tank.x]='@';\n}\n\nint main(){\n\tint d;\n\tcin>>d;\n\tfor(int k=0;k<d;k++){\n\t\tif(k)cout<<endl;\n\t\t//cout<<\"----------\"<<endl;\n\t\tcin>>h>>w;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tif(map[i][j]=='^'||map[i][j]=='<'||map[i][j]=='>'||map[i][j]=='v'){\n\t\t\t\t\ttank.dir=judgeDir(map[i][j]);\n\t\t\t\t\ttank.x=j;\n\t\t\t\t\ttank.y=i;\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint commandNum;\n\t\tcin>>commandNum;\n\t\tfor(char command;commandNum--;){\n\t\t\tcin>>command;\n\t//\t\tcout<<\"command:\"<<command<<endl;\n\t\t\tnext(command);\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@')cout<<getCharDir();\n\t\t\t\telse cout<<map[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint main()\n{\n  int t;\n  cin>>t;\n  for(;t--;)\n    {\n      int h,w;\n      cin>>h>>w;\n      //      cout<<h<<\" \"<<w<<endl;\n      char map[h][w];\n      int x,y;\n      //      char move;     //^=0,>=1,v=2,<=3\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>map[i][j];\n\t    \n\t    if(map[i][j]=='^' ||map[i][j]=='>'\n\t       ||map[i][j]=='v'||map[i][j]=='<')\n\t      x=i,y=j;//move=map[i][j];\t    \n\t    \n\t  }\n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  char tmp;\n\t  cin>>tmp;\n\t  if(tmp=='U')\n\t    {\n\t      map[x][y]='^';\n\t      if(x>0&&map[x-1][y]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  x--;\n\t\t  map[x][y]='^';\n\t\t}\n\t    }\n\t  if(tmp=='D')\n\t    {\n\t      map[x][y]='v';\n\t      if(x<h-1&&map[x+1][y]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  x++;\n\t\t  map[x][y]='v';\n\t\t}\n\t    }\n\n\n\t  if(tmp=='L')\n\t    {\n\t      map[x][y]='<';\n\t      if(y>0&&map[x][y-1]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  y--;\n\t\t  map[x][y]='<';\n\t\t}\n\t    }\n\t  if(tmp=='R')\n\t    {\n\t      map[x][y]='>';\n\t      if(y<w-1&&map[x][y+1]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  y++;\n\t\t  map[x][y]='>';\n\t\t}\n\t    }\n\t  if(tmp=='S')\n\t    {\n\t      int dx=0,dy=0;\n\t      int tmpx=x,tmpy=y;\n\t      if(map[x][y]=='^')\n\t\tdx=-1;\n\t      else if(map[x][y]=='v')\n\t\tdx=1;\n\t      else if(map[x][y]=='<')\n\t\tdy=-1;\n\t      else\n\t\tdy=1;\n\t      while(tmpx<h&&tmpy<w)\n\t\t{\n\t\t  tmpx+=dx;\n\t\t  tmpy+=dy;\n\t\t  if(map[tmpx][tmpy]=='*')\n\t\t    {\n\t\t      map[tmpx][tmpy]='.';\n\t\t      break;\n\t\t    }\n\t\t  if(map[tmpx][tmpy]=='#')\n\t\t    {\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\t  \n\t}\n\t\n\t\n\tfor(int i=0;i<h;i++,cout<<endl)\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      cout<<map[i][j];\n\t    }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint h,w;\nchar map[25][25];\nchar dir;\n\nbool check( int i,int j ){\n  switch( map[i][j] ){\n  case '*': map[i][j]='.';\n  case '#': return true;\n  }\n  return false;\n}\n\nvoid shot(int y,int x){\n  //  cout << \"shot \" << y <<\" , \"<< x << \" \"<< dir << endl;\n  switch( dir ){\n  case 'u': for( int i=y-1;i>=0;i-- )  if( check(i,x) ) break;\n    break;\n  case 'd': for( int i=y+1;i<h;i++ ) if( check(i,x) ) break;\n    break;\n  case 'l': for( int i=x-1;i>=0;i-- ) if( check(y,i) ) break;\n    break;\n  case 'r': for( int i=x+1;i<w;i++ ) if( check(y,i) ) break;\n    break;\n  }\n}\n\nvoid show(int y,int x){\n  char cmd;\n  for( int i=0;i<h;i++ ){\n    for( int j=0;j<w;j++ ){\n      if( i==y && j== x){\n\tswitch( dir ){\n\tcase 'u': cmd='^'; break;\n\tcase 'd': cmd='v'; break;\n\tcase 'l': cmd='<'; break;\n\tcase 'r': cmd='>'; break;\n\t}\n      }else\tcmd=map[i][j];\n      cout << cmd;\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n  int datasetN,n, x,y;\n  char cmd;\n\n  cin >> datasetN;\n  while( datasetN-- ){\n    cin >> h >> w;\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> map[i][j];\n\tswitch( map[i][j] ){\n\tcase '^': map[i][j]='.';y=i;x=j; dir='u'; break;\n\tcase 'v': map[i][j]='.';y=i;x=j; dir='d'; break;\n\tcase '<': map[i][j]='.';y=i;x=j; dir='l'; break;\n\tcase '>': map[i][j]='.';y=i;x=j; dir='r'; break;\n\t}\n      }\n\n    cin >> n;\n    for( int lp=0;lp<n;lp++ ){\n      cin >> cmd;\n      switch( cmd ){\n      case 'U':\tdir='u';if( y-1>=0 && map[y-1][x]=='.' ) y--;\tbreak;\n      case 'D':\tdir='d';if( y+1<h  && map[y+1][x]=='.' ) y++;\tbreak;\n      case 'L': dir='l';if( x-1>=0 && map[y][x-1]=='.' ) x--;\tbreak;\n      case 'R':\tdir='r';if( x+1<w  && map[y][x+1]=='.' ) x++;\tbreak;\n      case 'S':\tshot(y,x);\tbreak;\n      }\n      /*\n      cout << \"CMD = \"<< cmd << endl;\n      show(y,x);\n      */\n    }    \n    show(y,x);\n    if( datasetN>0 )\n      cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nchar field[21][21];\nint w, h;\nP pos;\nint dir;\n\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\n\nvoid sim(char c){\n\tif(c != 'S'){\n\t\trep(i, 4){\n\t\t\tif(c == \"UDLR\"[i]){\n\t\t\t\tdir = i;\n\t\t\t\tint nx = pos.X + dx[dir], ny = pos.Y + dy[dir];\n\t\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) return;\n\t\t\t\tif(field[ny][nx] != '.') return;\n\t\t\t\tpos = MP(nx, ny);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tint nx = pos.X, ny = pos.Y;\n\t\twhile(1){\n\t\t\tnx += dx[dir], ny += dy[dir];\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) return;\n\t\t\tif(field[ny][nx] == '#') return;\n\t\t\tif(field[ny][nx] == '*'){\n\t\t\t\tfield[ny][nx] = '.';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\trep(sets, T){\n\t\tif(sets) cout << endl;\n\t\tcin >> h >> w;\n\t\trep(i, h) rep(j, w) cin >> field[i][j];\n\n\t\trep(i, h) rep(j, w){\n\t\t\trep(d, 4){\n\t\t\t\tif(field[i][j] == \"^v<>\"[d]){\n\t\t\t\t\tpos = MP(j, i);\n\t\t\t\t\tdir = d;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint n;\n\t\tcin >> n;\n\t\trep(i, n){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tsim(c);\n\t\t}\n\t\tfield[pos.Y][pos.X] = \"^v<>\"[dir];\n\n\t\trep(i, h){\n\t\t\trep(j, w) cout << field[i][j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring mp[20],str;\nint dir[256],h,w,m;\nchar ch[4]={'^','>','v','<'};\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\nint get_d(char a){\n  if(a=='U') return 0;\n  if(a=='R') return 1;\n  if(a=='D') return 2;\n  if(a=='L') return 3;\n  return -1;\n}\n\nvoid shoot(int x,int y,int d){\n  while(1){\n    x+=dx[d],y+=dy[d];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')return;\n    if(mp[y][x]=='*'){\n      mp[y][x]='.';\n      return;\n    }\n  }\n\n}\n\nvoid update(int x,int y,int d){\n  mp[y][x]='.';\n  for(int i=0;i<m;i++){\n    cout <<i<<endl;\n    int pd=d,nx,ny;\n    d=get_d(str[i]);\n    if(d==-1){d=pd,shoot(x,y,d);continue;}\n\n    nx=x+dx[d],ny=y+dy[d];\n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]!='.')nx=x,ny=y;\n    y=ny,x=nx;\n  }\n  mp[y][x]=ch[d];\n}\n\nint main(){\n  memset(dir,-1,sizeof(dir));\n  dir['^']=0,dir['>']=1,dir['v']=2,dir['<']=3;\n\n  int q;\n  cin>>q;\n  while(q--){\n    cin>>h>>w;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    cin>>m>> str;\n\n    for(int i=0;i<h;i++){\n      int f=0;\n      for(int j=0;j<w;j++) \n\tif(dir[mp[i][j]]!=-1) {\n\t  update(j,i,dir[mp[i][j]]);\n\t  f=1;\n\t  break;\n\t}\n      if(f)break;\n    }\n\n    for(int i=0;i<h;i++)cout <<mp[i]<<endl;\n    if(q) cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int a[22][22],m,n,w,h,x,y,vx,vy;\n  char c;\n  cin>>n;\n  for(i=0;i<n;i++){\n    cin>>h>>w;\n    memset(a,-1,sizeof(a));\n    for(j=1;j<h+1;j++){\n      for(k=1;k<w+1;k++){\n\tcin>>c;\n\tif(0){\n\t}else if(c=='.'){\n\t  a[k][j]=0;\n\t}else if(c=='*'){\n\t  a[k][j]=-2;\n\t}else if(c=='#'){\n\t  a[k][j]=-1;\n\t}else if(c=='-'){\n\t  a[k][j]=-3;\n\t}else if(c=='^'){\n\t  a[k][j]=0;\n\t  x=k;\n\t  y=j;\n\t  vx=0;\n\t  vy=-1;\n\t}else if(c=='v'){\n\t  a[k][j]=0;\n\t  x=k;\n\t  y=j;\n\t  vx=0;\n\t  vy=1;\n\t}else if(c=='<'){\n\t  a[k][j]=0;\n\t  x=k;\n\t  y=j;\n\t  vx=-1;\n\t  vy=0;\n\t}else if(c=='>'){\n\t  a[k][j]=0;\n\t  x=k;\n\t  y=j;\n\t  vx=1;\n\t  vy=0;\n\t}\n      }\n    }\n    cin>>m;\n    for(j=0;j<m;j++){\n      cin>>c;\n      if(0){\n      }else if(c=='U'){\n\tvx=0;\n\tvy=-1;\n\tif(a[x+vx][y+vy]==0){\n\t  x+=vx;\n\t  y+=vy;\n\t}\n      }else if(c=='D'){\n\tvx=0;\n\tvy=1;\n\tif(a[x+vx][y+vy]==0){\n\t  x+=vx;\n\t  y+=vy;\n\t}\n      }else if(c=='L'){\n\tvx=-1;\n\tvy=0;\n\tif(a[x+vx][y+vy]==0){\n\t  x+=vx;\n\t  y+=vy;\n\t}\n      }else if(c=='R'){\n\tvx=1;\n\tvy=0;\n\tif(a[x+vx][y+vy]==0){\n\t  x+=vx;\n\t  y+=vy;\n\t}\n      }else if(c=='S'){\n\tfor(k=1;;k++){\n\t  if(0){\n\t  }else if(a[x+vx*k][y+vy*k]==-1){\n\t    break;\n\t  }else if(a[x+vx*k][y+vy*k]==-2){\n\t    a[x+vx*k][y+vy*k]=0;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    for(j=1;j<h+1;j++){\n      for(k=1;k<w+1;k++){\n\tif(0){\n\t}else if(k==x&&j==y){\n\t  if(0){\n\t  }else if(vx==-1&&vy==0){\n\t    cout<<'<';\n\t  }else if(vx==0&&vy==-1){\n\t    cout<<'^';\n\t  }else if(vx==1&&vy==0){\n\t    cout<<'>';\n\t  }else if(vx==0&&vy==1){\n\t    cout<<'v';\n\t  }\n\t}else if(a[k][j]==0){\n\t  cout<<'.';\n\t}else if(a[k][j]==-2){\n\t  cout<<'*';\n\t}else if(a[k][j]==-1){\n\t  cout<<'#';\n\t}else if(a[k][j]==-3){\n\t  cout<<'-';\n\t}\n      }\n      cout<<endl;\n    }\n    if(i!=n-1)\n      cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nconst int dx[4] = { 0, 0, -1, 1 };\nconst int dy[4] = { -1, 1, 0, 0 };\nconst char mov[] = \"UDLR\";\nconst char tank[] = \"^v<>\";\n\nint h, w, d, x, y;\nstring map[22], command;\n\nint main()\n{\n\tint t, n;\n\tcin >> t;\n\tmap[0] = \"######################\";\n\n\tfor(int i = 1; ; ++i)\n\t{\n\t\tcin >> h; cin >> w;\n\t\tfor(int j = 1; j <= h; ++j) {\n\t\t\tcin >> map[j];\n\t\t\tmap[j] = \"#\" + map[j] + \"#\";\n\t\t}\n\t\tmap[h+1] = map[0];\n\t\tcin >> n; cin >> command;\n\n\t\tfor(int j = 1; j <= h; ++j)\n\t\t\tfor(int k = 1; k <= w; ++k)\n\t\t\t\tfor(int l = 0; l < 4; ++l)\n\t\t\t\t\tif(map[j][k] == tank[l])\n\t\t\t\t\t\ty = j, x = k, d = l, map[y][x] = '.';\n\n        for(int j = 0; j < n; ++j)\n        {\n\t\t\tfor(int k = 0; k < 4; ++k)\n\t\t\t\tif(command[j] == mov[k]) {\n\t\t\t\t\td = k;\n\t\t\t\t\tif(map[y+dy[d]][x+dx[d]] == '.')\n\t\t\t\t\t\tx += dx[d], y += dy[d];\n\t\t\t\t}\n\n\t\t\tif(command[j] == 'S')\n\t\t\t\tfor(int xx = x, yy = y; map[yy][xx] != '#'; xx += dx[d], yy += dy[d])\n\t\t\t\t\tif(map[yy][xx] == '*') { map[yy][xx] = '.'; break; }\n\t\t}\n\n\t\tmap[y][x] = tank[d];\n\n\t\tfor(int j = 1; j <= h; ++j)\n\t\t\tcout << map[j].substr(1, w) << endl;\n\n\t\tif(i == t) break;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main () {\n\n  char map[21][20];\n  char com[101];\n\n  char tank[4] = {'^','>','v','<'};\n  int num;\n\n  int dx[4] = { 0, 1, 0, -1};\n  int dy[4] = { -1, 0, 1, 0};\n   \n  cin >> num;\n\n  for ( int n=0; n<num; n++ )\n\t{\n\t  int h,w;\n\t  cin >> h >> w;\n\t  for ( int i=0; i<h; i++ )\n\t\t{\n\t\t  cin >> map[i];\n\t\t}\n\n\t  //for ( int i=0; i<h; i++ )\n\t  //cout << map[i] << endl;\n\t  \n\t  int comlen;\n\t  \n\t  cin >> comlen;\n\t  cin >> com;\n\n\t  int direct = -1;\n\t  int px, py;\n\t  int mx, my;\n\t  int bx, by;\n\t  bool move;\n\t  \n\t  //cout << com << endl;\n\n\t  for ( int i=0; i<h; i++ )\n\t\t{\n\t\t  for ( int j=0; j<w; j++ )\n\t\t\t{\n\t\t\t  switch ( map[i][j] )\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t  direct = 0;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\tcase '>':\n\t\t\t\t  direct = 1;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\tcase 'v':\n\t\t\t\t  direct = 2;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\tcase '<':\n\t\t\t\t  direct = 3;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t  for ( int j=0; j<comlen; j++ )\n\t\t{\n\t\t  move = false;\n\n\t\t  \n\t\t  //cout << j << endl;\n\t\t  cout << j << \" \" << com[j] << endl;\n\t\t  switch(com[j]) {\n\t\t\t\n\t\t  case 'U':\n\t\t\tdirect = 0;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  case 'R':\n\t\t\tdirect = 1;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  case 'D':\n\t\t\tdirect = 2;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  case 'L':\n\t\t\tdirect = 3;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  }\n\t\t  \n\t\t  bool pass = false;\n\t\t  if ( move ) {\n\t\t\tif ( py + dy[direct] >= h || py + dy[direct] < 0 || px + dx[direct] >= w || px + dx[direct] < 0 )\n\t\t\t  continue;\n\t\t\tif ( map[py+dy[direct]][px+dx[direct]] == '.')\n\t\t\t  {\n\t\t\t\tmap[py+dy[direct]][px+dx[direct]] = tank[direct];\n\t\t\t\tmap[py][px] = '.';\n\t\t\t\tpx += dx[direct];\n\t\t\t\tpy += dy[direct];\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t\tmap[py][px] = tank[direct];\n\t\t\t  }\n\t\t  } else {\n\t\t\tif ( com[j] == 'S' )\n\t\t\t  {\n\t\t\t\tcout << \"in\" << endl;\n\t\t\t\t//cout << tank[direct] << endl;\n\t\t\t\tmx = px + dx[direct];\n\t\t\t\tmy = py + dy[direct];\n\t\t\t\tcout << mx << \" \" << my << endl;//\" \" << map[my][mx] << endl;\n\n\t\t\t\tif ( my < h || my >= 0 || mx < w || mx >= 0 )\n\t\t\t\t  {\t\t\t\t\n\t\t\t\t\twhile ( map[my][mx] == '.' || map[my][mx] == '-' )\n\t\t\t\t\t  {\n\t\t\t\t\t\tmy += dy[direct];\n\t\t\t\t\t\tmx += dx[direct];\n\t\t\t\t\t\tif ( my >= h || my < 0 || mx >= w || mx < 0 )\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\tpass = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t\t  if ( !pass ) {\n\t\t\t\t\tif ( map[my][mx] == '*')\n\t\t\t\t\t  {\n\t\t\t\t\t\tmap[my][mx] = '.';\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\n\t\t\t//cout << mx << \" \" << my << endl;\n\t\t  }\n\t\t}\n\t    for ( int i=0; i<h; i++ )\n\t\t  cout << map[i] << endl;\n\t\tif ( n == num -1 )\n\t\t  cout << endl;\n  \n\n\t}\n  \n}\n\t\t  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<(b))\nusing namespace std;\nint t, h, w, n;\nchar town[32][32], cmd[128];\n\nvoid shot(int y, int x){\n   int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0}; // U D L R\n  int d;\n  switch(town[y][x]){\n  case '^': d = 0; break;\n  case 'v': d = 1; break;\n  case '<': d = 2; break;\n  case '>': d = 3; break;\n  }\n  //  printf(\"%d\\n\", d);\n  while(true){\n    if(between(0,y+dy[d], h) && between(0, x+dx[d], w)){\n      y+=dy[d]; x+=dx[d];\n      if(town[y][x] == '*'){\n\ttown[y][x] = '.';\n\tbreak;\n      }else if(town[y][x] == '#'){\n\tbreak;\n      }\n    }else break;\n  }\n  return;\n}\n\nint main(){\n  scanf(\"%d\", &t);\n  bool f = false;\n  while(t--){\n    scanf(\"%d%d\", &h, &w);\n    rep(i, h) scanf(\"%s\", town[i]);\n \n    scanf(\"%d\", &n);\n    scanf(\"%s\", cmd);\n    int x, y;\n    rep(i, h) rep(j, w) \n      if(town[i][j]=='^' || town[i][j]=='v' || town[i][j]=='<' || town[i][j]=='>')x=j,y=i;\n    rep(i, n){\n      //      printf(\"%d %d\\n\", y, x);\n      switch(cmd[i]){\n      case 'U':\n\tif(y-1 >= 0 && town[y-1][x] == '.'){ town[y][x] = '.'; town[--y][x] = '^';}\n\telse town[y][x] = '^';\n\tbreak;\n       case 'D':\n\tif(y+1 < h && town[y+1][x] == '.'){ town[y][x] = '.'; town[++y][x] = 'v';}\n\telse town[y][x] = 'v';\n\tbreak;\n      case 'L':\n\tif(x-1 >= 0 && town[y][x-1] == '.'){ town[y][x] = '.'; town[y][--x] = '<';}\n\telse town[y][x] = '<';\n\tbreak;\n      case 'R':\n\tif(x+1 < w && town[y][x+1] == '.'){ town[y][x] = '.'; town[y][++x] = '>';}\n\telse town[y][x] = '>';\n\tbreak;\n      case 'S':\n\tshot(y, x);\n\tbreak;\n      }\n    }      \n    if(f) puts(\"\");\n    rep(i, h){\n      rep(j, w) printf(\"%c\", town[i][j]);\n      puts(\"\");\n    }\n    \n    f = 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint T, H, W, N;\nchar m[22][32], q[110];\nconst char dir[] = { 'U', 'R', 'D', 'L' };\nconst char dir_c[] = { '^', '>', 'v', '<' };\nconst int di[] = { -1, 0, 1, 0 };\nconst int dj[] = { 0, 1, 0, -1 };\n\nbool is_tank(char c) { return c == '<' || c == '>' || c == '^' || c == 'v' ; }\n\nint get_dir(char c) {\n  int ret = -1;\n  rep(i,4) if (c == dir[i]) ret = i;\n  return ret;\n}\nchar get_dir_c(char c) {\n  char ret = -1;\n  rep(i,4) if (c == dir[i]) ret = dir_c[i];\n  return ret;\n}\n\nvoid do_shoot(int dir, int ci, int cj) {\n  while (0 <= ci && ci < H && 0 <= cj && cj < W) {\n    bool flag = false;\n    switch (m[ci][cj]) {\n      case '-':\n      case '.': break;\n      case '#': flag = true; break;\n      case '*': m[ci][cj] = '.'; flag = true; break;\n    }\n    if (flag) break;\n    ci += di[dir];\n    cj += dj[dir];\n  }\n}\n\nvoid f() {\n  int dir = -1, ci = -1, cj = -1;\n  rep(i,H) rep(j,W) if(is_tank(m[i][j])) {\n    switch (m[i][j]) {\n      case '^': dir = 0; break;\n      case '>': dir = 1; break;\n      case 'v': dir = 2; break;\n      case '<': dir = 3; break;\n    }\n    ci = i, cj = j;\n    break;\n  }\n  rep(i,N) {\n    if (q[i] == 'S') {\n      do_shoot(dir, ci, cj);\n    } else {\n      dir = get_dir(q[i]);\n      int ti = ci + di[dir], tj = cj + dj[dir];\n      if (0 <= ti && ti < H && 0 <= tj && tj <= W && (m[ti][tj] == '.')) {\n        m[ci][cj] = '.';\n        m[ti][tj] = get_dir_c(q[i]);\n        ci = ti, cj = tj;\n      } else {\n        m[ci][cj] = get_dir_c(q[i]);\n      }\n    }\n  }\n  rep(i,H) printf(\"%s\\n\", m[i]);\n}\n\nint main() {\n  scanf(\"%d\", &T);\n  rep(loop,T) {\n    if (loop) puts(\"\");\n    scanf(\"%d%d\", &H, &W);\n    rep(i,H) scanf(\"%s\", m[i]);\n    scanf(\"%d\", &N);\n    scanf(\"%s\", q);\n    f();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n//#pragma comment(linker, \"/STACK:400000000\")\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint T,H,W,N;\nchar map[22][22];\n\nint dy[]={-1,1,0,0}, dx[]={0,0,-1,1};\nstring tank=\"^v<>\",cmd=\"UDLR\";\n\nbool cango(int y,int x){\n    return 0<=y && y<H && 0<=x && x<W && map[y][x]=='.';\n}\n\nint main(){\n\tcin>>T;\n    rep(tc,T){\n        cin>>H>>W;\n        int y,x,dir;\n        \n        rep(i,H)rep(j,W){\n            cin>>map[i][j];\n            rep(k,4){\n                if(map[i][j]==tank[k]){\n                    y=i, x=j, dir=k;\n                    map[i][j]='.';\n                }\n            }\n        }\n        \n        cin>>N;\n        rep(i,N){\n            char c;\n            cin>>c;\n            rep(j,4){\n                if(c==cmd[j]){\n                    dir=j;\n                    if( cango(y+dy[j], x+dx[j]) ){\n                        y+=dy[j], x+=dx[j];\n                    }\n                }\n            }\n            if(c=='S'){\n                int Y=y, X=x;\n                while(1){\n                    Y+=dy[dir], X+=dx[dir];\n                    if( !(0<=Y && Y<H && 0<=X && X<W) )break;\n                    if(map[Y][X]=='*'){\n                        map[Y][X]='.';\n                        break;\n                    }\n                    if(map[Y][X]=='#')break;\n                }\n            }\n        }\n        \n        rep(i,H){\n            rep(j,W){\n                if(y==i && x==j) cout<<tank[dir];\n                else cout<<map[i][j];\n            }\n            cout<<endl;\n        }\n        if(tc!=T-1)cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint h, w;\nchar f[21][21];\npoint now;\nint nowdir;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nchar car[5]=\">^<v\";\n\nvoid move(char c){\n\t//????????¢???\n\tif(c=='R') nowdir=0;\n\telse if(c=='U') nowdir=1;\n\telse if(c=='L') nowdir=2;\n\telse if(c=='D') nowdir=3;\n\t\n\t//?¬????????????´???\n\tint nx=now.x+dx[nowdir];\n\tint ny=now.y+dy[nowdir];\n\t\n\t//?§?????????????????§????\n\tif(0<=nx && nx<w && 0<=ny && ny<h && f[ny][nx]=='.'){\n\t\tf[ny][nx]=car[nowdir];\n\t\tf[now.y][now.x]='.';\n\t\tnow.x=nx;\n\t\tnow.y=ny;\n\t}\n}\n\nvoid printField(){\n\tfor(int i=0; i<h; ++i){\n\t\tfor(int j=0; j<w; ++j){\n\t\t\tprintf(\"%c\", f[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\t\n}\n\nvoid shoot(){\n\tint t=1; //???????????????\n\n\twhile(1){\n\t\tint nx=t*dx[nowdir]+now.x;\t\n\t\tint ny=t*dy[nowdir]+now.y;\n\t\t\n\t\tif(nx<0 || w<=nx || ny<0 || h<ny) break;\n\t\t\n\t\tif(f[ny][nx]=='*'){\n\t\t\tf[ny][nx]='.';\n\t\t\tbreak;\t\n\t\t}\n\t\telse if(f[ny][nx]=='#') break;\t\n\t\t\t\n\t\tt++;\t\t\t\n\t}\n}\n\nint main(){\t\n\tint times;\n\tcin >> times;\n\tfor(int t=0; t<times; ++t){\n\t\tif(t!=0) printf(\"\\n\");\n\t\t\n\t\tscanf(\" %d %d\", &h, &w);\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\tfor(int j=0; j<w; ++j){\n\t\t\t\tscanf(\" %c\", &f[i][j]);\n\t\t\t\t\n\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\tif(f[i][j]==car[k]){\t\n\t\t\t\t\t\tnowdir=k;\n\t\t\t\t\t\tnow.x=j;\n\t\t\t\t\t\tnow.y=i;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n;\n\t\tstring order;\n\t\tscanf(\" %d\", &n);\n\t\tcin >> order;\n\t\t\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(order[i]=='S') shoot();\n\t\t\telse move(order[i]);\n\t\t\t/*\n\t\t\tprintf(\"nowdir=%d\\n\", nowdir);\n\t\t\tprintField();\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t}\n\t\t\n\t\tprintField();\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nconst int dx[4] = { 0, 0, -1, 1 };\nconst int dy[4] = { -1, 1, 0, 0 };\nconst char mov[] = \"UDLR\";\nconst char tank[] = \"^v<>\";\n\nint h, w, d, x, y;\nstring map[22], command;\n\nint main()\n{\n    int t, n;\n    cin >> t;\n    map[0] = \"######################\";\n\n    for(int i = 1; ; ++i)\n    {\n        cin >> h >> w;\n        for(int j = 1; j <= h; ++j) {\n            cin >> map[j];\n            map[j] = \"#\" + map[j] + \"#\";\n            for(int k = 0; k < 4; ++k)\n\t\t\t\tif(map[j].find(tank[k]) != string::npos)\n\t\t\t\t\ty = j, x = map[j].find(tank[k]), d = k, map[y][x] = '.';\n        }\n        map[h+1] = map[0];\n        cin >> n >> command;\n\n        for(int j = 0; j < n; ++j)\n        {\n            for(int k = 0; k < 4; ++k)\n                if(command[j] == mov[k]) {\n                    d = k;\n                    if(map[y+dy[d]][x+dx[d]] == '.')\n                        x += dx[d], y += dy[d];\n                }\n\n            if(command[j] == 'S')\n                for(int xx = x, yy = y; map[yy][xx] != '#'; xx += dx[d], yy += dy[d])\n                    if(map[yy][xx] == '*') { map[yy][xx] = '.'; break; }\n        }\n\n        map[y][x] = tank[d];\n\n        for(int j = 1; j <= h; ++j)\n            cout << map[j].substr(1, w) << endl;\n\n        if(i == t) break;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nstruct player{\n\tpublic:\n\t\tplayer(char a, int b, int c):dir(a), posX(b), posY(c){}\n\t\tvoid actU(vector<vector<char> > &table){\n\t\t\tif(posY-1<0){\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t\tdir = '^';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY-1][posX] == '.'){\n\t\t\t\ttable[posY--][posX] = '.';\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t}\n\t\t\telse table[posY][posX] = '^';\n\t\t\tdir = '^';\n\t\t}\n\t\tvoid actD(vector<vector<char> > &table){\n\t\t\tif(posY+1>=table.size()){\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t\tdir = 'v';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY+1][posX] == '.'){\n\t\t\t\ttable[posY++][posX] = '.';\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t}\n\t\t\telse table[posY][posX] = 'v';\n\t\t\tdir = 'v';\n\t\t}\n\t\tvoid actL(vector<vector<char> > &table){\n\t\t\tif(posX-1<0){\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t\tdir = '<';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX-1] == '.'){\n\t\t\t\ttable[posY][posX--] = '.';\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t}\n\t\t\telse table[posY][posX] = '<';\n\t\t\tdir = '<';\n\t\t}\n\t\tvoid actR(vector<vector<char> > &table){\n\t\t\tif(posX+1>=table[0].size()){\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t\tdir = '>';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX+1] == '.'){\n\t\t\t\ttable[posY][posX++] = '.';\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t}\n\t\t\telse table[posY][posX] = '>';\n\t\t\tdir = '>';\n\t\t}\n\t\tvoid actS(vector<vector<char> > &table){\n\t\t\tint progressX = 0;\n\t\t\tint progressY = 0;\n\t\t\tif(dir == '^') progressY = -1;\n\t\t\telse if(dir == 'v') progressY = 1;\n\t\t\telse if(dir == '<') progressX = -1;\n\t\t\telse if(dir == '>') progressX = 1;\n\t\t\tint sposX = posX+progressX, sposY = posY+progressY;\n\t\t\twhile((sposX>=0&&sposX<table[0].size())&&(sposY>=0&&sposY<table.size())){\n\t\t\t\tif(table[sposY][sposX] == '*' || table[sposY][sposX] == '#'){\n\t\t\t\t\tif(table[sposY][sposX] == '*') table[sposY][sposX] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsposX += progressX;\n\t\t\t\tsposY += progressY;\n\t\t\t}\n\t\t}\n\t\tchar dir;\n\t\tint posX;\n\t\tint posY;\n};\n\nvoid action(char act, player &p, vector<vector<char> > &table){\n\tswitch(act){\n\tcase 'U':\n\t\tp.actU(table);\n\t\tbreak;\n\tcase 'D':\n\t\tp.actD(table);\n\t\tbreak;\n\tcase 'L':\n\t\tp.actL(table);\n\t\tbreak;\n\tcase 'R':\n\t\tp.actR(table);\n\t\tbreak;\n\tcase 'S':\n\t\tp.actS(table);\n\t\tbreak;\n\tdefault:\n\t\t\tbreak;\n\t}\n\n}\n\nint main(){\n\tint n = 0;\n\tcin >> n;\n\twhile(n--){\n\t\tint h = 0, w = 0;\n\t\tcin >> h >> w;\n\t\tvector<vector<char> > table(h, vector<char>(w, ' '));\n\t\tplayer p(' ', -1, -1);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tif(table[i][j]=='^'||table[i][j]=='v'||table[i][j]=='<'||table[i][j]=='>'){\n\t\t\t\t\tp.dir = table[i][j];\n\t\t\t\t\tp.posX = j;\n\t\t\t\t\tp.posY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = 0;\n\t\tcin >> m;\n\t\tvector<char> act(m, ' ');\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> act[i];\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\taction(act[i], p, table);\n\t\t}\n\n\t\tfor(int i = 0; i < table.size(); i++){\n\t\t\tfor(int j = 0; j < table[0].size(); j++){\n\t\t\t\tcout << table[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tif(n)cout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 20;\n\nconst int dxs[] = { 1, 0, -1, 0 };\nconst int dys[] = { 0, -1, 0, 1 };\nconst char car[] = { '>', '^', '<', 'v' };\n\n/* typedef */\n\n/* global variables */\n\nstring flds[MAX_H];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int tn;\n  cin >> tn;\n\n  for (bool first = true; tn--; first = false) {\n    int h, w;\n    cin >> h >> w;\n\n    int sx, sy, sd;\n    \n    for (int y = 0; y < h; y++) {\n      cin >> flds[y];\n      for (int x = 0; x < w; x++)\n\tswitch (flds[y][x]) {\n\tcase '>': sx = x, sy = y, sd = 0; flds[y][x] = '.'; break;\n\tcase '^': sx = x, sy = y, sd = 1; flds[y][x] = '.'; break;\n\tcase '<': sx = x, sy = y, sd = 2; flds[y][x] = '.'; break;\n\tcase 'v': sx = x, sy = y, sd = 3; flds[y][x] = '.'; break;\n\t}\n    }\n\n    int on;\n    cin >> on;\n\n    string ops;\n    cin >> ops;\n\n    for (int oi = 0; oi < on; oi++) {\n      int op;\n      switch (ops[oi]) {\n      case 'R': op = 0; sd = 0; break;\n      case 'U': op = 0; sd = 1; break;\n      case 'L': op = 0; sd = 2; break;\n      case 'D': op = 0; sd = 3; break;\n      case 'S': op = 1; break;\n      }\n\n      if (op == 0) {\n\tint x0 = sx + dxs[sd], y0 = sy + dys[sd];\n\tif (x0 >= 0 && x0 < w && y0 >= 0 && y0 < h && flds[y0][x0] == '.')\n\t  sx = x0, sy = y0;\n      }\n      else {\n\tint dx = dxs[sd], dy = dys[sd], x = sx + dx, y = sy + dy;\n\twhile (x >= 0 && x < w && y >= 0 && y < h) {\n\t  if (flds[y][x] == '*') {\n\t    flds[y][x] = '.';\n\t    break;\n\t  }\n\t  else if (flds[y][x] == '#')\n\t    break;\n\n\t  x += dx, y += dy;\n\t}\n      }\n    }\n\n    flds[sy][sx] = car[sd];\n    \n    if (! first) cout << endl;\n\n    for (int y = 0; y < h; y++)\n      cout << flds[y] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint main(void){\n\tint T;\n\tcin>>T;\n\tfor(int i=0,H,W,N;i<T;++i){\n\t\tif(i!=0)cout<<endl;\n\t\tchar field[21][21];\n\t\tint x,y,a;\n\t\tcin>>H>>W;\n\t\tfor(int j=0;j<H;++j){\n\t\t\tstring line;\n\t\t\tcin>>line;\n\t\t\tfor(int k=0;k<=W;++k) field[j][k]=line[k];\n\t\t\t//scanf(\"%s\",field[j]);\n\t\t\tfor(int k=0;k<W;++k)\n\t\t\t\tif(field[j][k]=='^'||field[j][k]=='v'||field[j][k]=='<'||field[j][k]=='>')\n\t\t\t\t\t{\n\t\t\t\t\t\tx=k;y=j;\n\t\t\t\t\t\tif(field[j][k]=='^') a=0;\n\t\t\t\t\t\telse if(field[j][k]=='v') a=1;\n\t\t\t\t\t\telse if(field[j][k]=='<') a=2;\n\t\t\t\t\t\telse if(field[j][k]=='>') a=3;\n\t\t\t\t\t}\n\t\t}\n\t\tstring s;cin>>N;\n\t\tcin>>s;\n\t\tfor(int j=0;j<s.size();++j){\n\t\t\tint dx[]={0,0,-1,1},dy[]={-1,1,0,0};//UDLR\n\t\t\tchar pos[]={'^','v','<','>'};\n\t\t\tif(s[j]=='U'||s[j]=='D'||s[j]=='L'||s[j]=='R'){\n\t\t\t\tif(s[j]=='U') a=0;\n\t\t\t\telse if(s[j]=='D') a=1;\n\t\t\t\telse if(s[j]=='L') a=2;\n\t\t\t\telse if(s[j]=='R') a=3;\n\t\t\t\tfield[y][x]=pos[a];\n\t\t\t\tif(0<=x+dx[a] && x+dx[a]<W && 0<=y+dy[a] && y+dy[a]<H){\n\t\t\t\t\tif(field[y+dy[a]][x+dx[a]]=='.'){\n\t\t\t\t\t\tfield[y][x]='.';\n\t\t\t\t\t\tx+=dx[a];y+=dy[a];\n\t\t\t\t\t\tfield[y][x]=pos[a];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(s[j]=='S'){\n\t\t\t\tint sx=x+dx[a],sy=y+dy[a];\n\t\t\t\twhile(0<=sx && 0<=sy && sx<W && sy<H){\n\t\t\t\t\tif(field[sy][sx]=='#') break;\n\t\t\t\t\tif(field[sy][sx]=='*'){\n\t\t\t\t\t\tfield[sy][sx]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsx+=dx[a];sy+=dy[a];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<H;++j) printf(\"%s\\n\",field[j]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2103.cpp\n *\n *  Created on: 2012/07/08\n *      Author: shimomire\n */\n\n#include <iostream>\n#include<algorithm>\n#include <complex>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define REPr(i,b,n) for(int i=n-1;i>=b;i--)\n#define REPr0(i,n)   REPr(i,0,n)\n\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\n#define ALL(o) (o).begin(),(o).end()\n#define ARRSIZE(x) (sizeof(x)/sizeof(x[0]))\n#define ARRALL(x) x,x+ARRSIZE(x)\n\ntypedef complex<double> P;\nbool operator <(const P& a, const P& b) {\n\treturn make_pair(real(a), imag(a)) < make_pair(real(b), imag(b));\n}\n\nint N, H, W;\n\nchar map[30][30];\n\nint main() {\n\tcin >> N;\n\n\twhile (N-- != 0) {\n\t\tcin >> H >> W;\n\n\t\tpair<int, int> pos;\n\t\tREP0(h,H)REP0(w,W) {\n\t\t\tcin >>map[h][w];\n\t\t\tif (map[h][w] == '^' || map[h][w] == '<' || map[h][w] == '>'\n\t\t\t\t\t|| map[h][w] == 'v') {\n\t\t\t\tpos = make_pair(h, w);\n\t\t\t}\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\tREP0(m,M) {\n\t\t\tchar op;\n\t\t\tcin >> op;\n\t\t\tswitch (op) {\n\t\t\tcase 'S':\n\t\t\t\tswitch (map[pos.first][pos.second]) {\n\t\t\t\tcase '^':\n\t\t\t\t\tfor (int h = pos.first - 1; h >= 0; h--) {\n\t\t\t\t\t\tif (map[h][pos.second] == '*') {\n\t\t\t\t\t\t\tmap[h][pos.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[h][pos.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tfor (int h = pos.first + 1; h < H; h++) {\n\t\t\t\t\t\tif (map[h][pos.second] == '*') {\n\t\t\t\t\t\t\tmap[h][pos.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[h][pos.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tfor (int w = pos.second - 1; w >= 0; w--) {\n\t\t\t\t\t\tif (map[pos.first][w] == '*') {\n\t\t\t\t\t\t\tmap[pos.first][w] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[pos.first][w] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tfor (int w = pos.second + 1; w < W; w++) {\n\t\t\t\t\t\tif (map[pos.first][w] == '*') {\n\t\t\t\t\t\t\tmap[pos.first][w] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[pos.first][w] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tmap[pos.first][pos.second] = '^';\n\t\t\t\tif (pos.first >= 1 && map[pos.first - 1][pos.second] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first - 1][pos.second] = '^';\n\t\t\t\t\tpos.first--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tmap[pos.first][pos.second] = 'v';\n\t\t\t\tif (pos.first < H - 1\n\t\t\t\t\t\t&& map[pos.first + 1][pos.second] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first + 1][pos.second] = 'v';\n\t\t\t\t\tpos.first++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':\n\t\t\t\tmap[pos.first][pos.second] = '>';\n\t\t\t\tif (pos.second < W - 1\n\t\t\t\t\t\t&& map[pos.first][pos.second + 1] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first][pos.second + 1] = '>';\n\t\t\t\t\tpos.second++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tmap[pos.first][pos.second] = '<';\n\t\t\t\tif (pos.second >= 1 && map[pos.first][pos.second - 1] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first][pos.second - 1] = '<';\n\t\t\t\t\tpos.second--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tREP0(h,H) {\n\t\t\tcout << map[h]<< endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t,h,w,n;\n  cin>>t;\n  for(int i=0;i<t;++i){\n    char s[22][22],com[100];\n    int z,x,y; //z 0:up 1:down 2:left 3:right\n    cin>>h>>w;\n    for(int j=0;j<=h+1;++j){\n      for(int k=0;k<=w+1;++k){\n\tif(j==0||k==0||j==h+1||k==w+1) {\n\t  s[j][k]='A';\n\t}else{\n\t  cin>>s[j][k];\n\t  if(s[j][k]=='^'){ z=0; x=k; y=j;}\n\t  if(s[j][k]=='v'){ z=1; x=k; y=j;}\n\t  if(s[j][k]=='<'){ z=2; x=k; y=j;}\n\t  if(s[j][k]=='>'){ z=3; x=k; y=j;}\n\t}\n      }\n    }\n    cin>>n>>com;\n    for(int j=0;j<n;++j){\n      if(com[j]=='U'){\n\tz=0;\n\tif(s[y-1][x]=='.') {\n\t  s[y-1][x]='^';\n\t  s[y][x]='.';\n\t  y--;\n\t}else s[y][x]='^';\n      }\n      else if(com[j]=='D'){\n\tz=1;\n\tif(s[y+1][x]=='.') {\n\t  s[y+1][x]='v';\n\t  s[y][x]='.';\n\t  y++;\n\t}else s[y][x]='v';\n      }\n      else if(com[j]=='L'){\n\tz=2;\n\tif(s[y][x-1]=='.') {\n\t  s[y][x-1]='<';\n\t  s[y][x]='.';\n\t  x--;\n\t}else s[y][x]='<';\n      }\n      else if(com[j]=='R'){\n\tz=3;\n\tif(s[y][x+1]=='.') {\n\t  s[y][x+1]='>';\n\t  s[y][x]='.';\n\t  x++;\n\t}else s[y][x]='>';\n      }\n      else{\n\tif(z==0){\n\t  for(int j=y;j>=1;--j){\n\t    if(s[j][x]=='*'||s[j][x]=='#'){\n\t      if(s[j][x]=='*') s[j][x]='.';\n\t      break;\n\t    }\n\t  }\n\t}else if(z==1){\n\t  for(int j=y;j<=h;++j){\n\t    if(s[j][x]=='*'||s[j][x]=='#'){\n\t      if(s[j][x]=='*') s[j][x]='.';\n\t      break;\n\t    }\n\t  }\n\t}else if(z==2){\n\t  for(int j=x;j>=1;--j){\n\t    if(s[y][j]=='*'||s[y][j]=='#'){\n\t      if(s[y][j]=='*') s[y][j]='.';\n\t      break;\n\t    }\n\t  }\n\t}else{\n\t  for(int j=x;j<=w;++j){\n\t    if(s[y][j]=='*'||s[y][j]=='#'){\n\t      if(s[y][j]=='*') s[y][j]='.';\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(int j=1;j<=h;++j){\n      for(int k=1;k<=w;++k) cout<<s[j][k];\n      cout<<endl;\n    }\n    if(i!=t-1) cout<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nint t;\nint h, w, n;\nstring field[100];\nstring s;\nP pos;\n\nvoid solve(char c){\n\tint y = pos.first, x = pos.second;\n\tif (c == 'U'){\n\t\tif (y != 0){\n\t\t\tif (field[y - 1][x] == '.'){\n\t\t\t\tfield[y - 1][x] = '^';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\ty--;\n\t\t\t}\n\t\t\telse field[y][x] = '^';\n\t\t}\n\t\telse field[y][x] = '^';\n\t}\n\telse if (c == 'D'){\n\t\tif (y != h - 1){\n\t\t\tif (field[y + 1][x] == '.'){\n\t\t\t\tfield[y + 1][x] = 'v';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\ty++;\n\t\t\t}\n\t\t\telse field[y][x] = 'v';\n\t\t}\n\t\telse field[y][x] = 'v';\n\t}\n\telse if (c == 'L'){\n\t\tif (x != 0){\n\t\t\tif (field[y][x - 1] == '.'){\n\t\t\t\tfield[y][x - 1] = '<';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tx--;\n\t\t\t}\n\t\t\telse field[y][x] = '<';\n\t\t}\n\t\telse field[y][x] = '<';\n\t}\n\telse if (c == 'R'){\n\t\tif (x != w - 1){\n\t\t\tif (field[y][x + 1] == '.'){\n\t\t\t\tfield[y][x + 1] = '>';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse field[y][x] = '>';\n\t\t}\n\t\telse field[y][x] = '>';\n\t}\n\telse{\n\t\tint cy = y, cx = x;\n\t\tif (field[y][x] == '^'){\n\t\t\twhile (cy >= 0){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcy--;\n\t\t\t}\n\t\t}\n\t\telse if (field[y][x] == 'v'){\n\t\t\twhile (cy <= h - 1){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcy++;\n\t\t\t}\n\t\t}\n\t\telse if (field[y][x] == '<'){\n\t\t\twhile (cx >= 0){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcx--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (cx <= w - 1){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, h){\n\t\tREP(j, w){\n\t\t\tcout << field[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tpos = P(y, x);\n}\n\nint main(){\n\tcin >> t;\n\twhile (t--){\n\t\tcin >> h >> w;\n\t\tREP(i, h){\n\t\t\tcin >> field[i];\n\t\t\tREP(j, w){\n\t\t\t\tif (field[i][j] == '^' || field[i][j] == 'v' \n\t\t\t\t\t|| field[i][j] == '>' || field[i][j] == '<'){\n\t\t\t\t\tpos = P(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> n >> s;\n\t\tREP(i, n){\n\t\t\tsolve(s[i]);\n\t\t}\n\t\tREP(i, h){\n\t\t\tREP(j, w){\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint ziki(char ch){\n\tif(ch=='^'||ch=='U')return 1;\n\tif(ch=='v'||ch=='D')return 3;\n\tif(ch=='<'||ch=='L')return 4;\n\tif(ch=='>'||ch=='R')return 2;\n\treturn 0;\n}\nchar vec[]=\".^>v<\";\nint px[]={0,0,1,0,-1};\nint py[]={0,-1,0,1,0};\n\nint main(){\n\tint t;\n\tfor(cin>>t;t>0;t--){\n\t\t\n\t\t\n\t\tint h,w,n,v;\n\t\tint x,y;\n\t\tcin>>h>>w;\n\t\tchar map[22][22];\n\t\tfor(int i=0;i<22;i++)for(int j=0;j<22;j++)map[j][i]='#';\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcin>>map[j][i];\n\t\t\t\tif(ziki(map[j][i]))x=j,y=i,v=ziki(map[j][i]),map[j][i]='.';\n\t\t\t}\n\t\t}\n\t\tchar c;\n\t\tfor(cin>>n;n>0;n--){\n\t\t\tcin>>c;\n\t\t\tif(c=='U')if(y>1)if(map[x][y-1]=='.')y--;\n\t\t\tif(c=='D')if(y<h)if(map[x][y+1]=='.')y++;\n\t\t\tif(c=='L')if(x>1)if(map[x-1][y]=='.')x--;\n\t\t\tif(c=='R')if(x<w)if(map[x+1][y]=='.')x++;\n\t\t\t\n\t\t\tif(c=='S'){\n\t\t\t\tfor(int X=x+px[v],Y=y+py[v];1;X+=px[v],Y+=py[v]){\n\t\t\t\t\tif(map[X][Y]=='#')break;\n\t\t\t\t\tif(map[X][Y]=='*'){\n\t\t\t\t\t\tmap[X][Y]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse v=ziki(c);\n\t\t\t/*\n\t\t\tcout<<x<<\" \"<<y<<\" \"<<c<<endl;\n\t\t\tfor(int i=0;i<=h+1;i++){\n\t\t\t\tfor(int j=0;j<=w+1;j++){\n\t\t\t\t\tif(j==x&&i==y)cout<<vec[v]<<(j==w+1?\"\\n\":\"\");\n\t\t\t\t\telse cout<<map[j][i]<<(j==w+1?\"\\n\":\"\");\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(j==x&&i==y)cout<<vec[v]<<(j==w?\"\\n\":\"\");\n\t\t\t\telse cout<<map[j][i]<<(j==w?\"\\n\":\"\");\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(t!=1)cout<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int t;\n  cin>>t;\n  for(;t--;)\n    {\n      int h,w;\n      cin>>h>>w;\n      //      cout<<h<<\" \"<<w<<endl;\n      char maps[h][w];\n      int x,y;\n      //      char move;     //^=0,>=1,v=2,<=3\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>maps[i][j];\n\t    \n\t    if(maps[i][j]=='^' ||maps[i][j]=='>'\n\t       ||maps[i][j]=='v'||maps[i][j]=='<')\n\t      x=i,y=j;//move=maps[i][j];\t    \n\t    \n\t  }\n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  char tmp;\n\t  cin>>tmp;\n\t  if(tmp=='U')\n\t    {\n\t      maps[x][y]='^';\n\t      if(x>0&&maps[x-1][y]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  x--;\n\t\t  maps[x][y]='^';\n\t\t}\n\t    }\n\t  if(tmp=='D')\n\t    {\n\t      maps[x][y]='v';\n\t      if(x<h-1&&maps[x+1][y]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  x++;\n\t\t  maps[x][y]='v';\n\t\t}\n\t    }\n\n\n\t  if(tmp=='L')\n\t    {\n\t      maps[x][y]='<';\n\t      if(y>0&&maps[x][y-1]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  y--;\n\t\t  maps[x][y]='<';\n\t\t}\n\t    }\n\t  if(tmp=='R')\n\t    {\n\t      maps[x][y]='>';\n\t      if(y<w-1&&maps[x][y+1]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  y++;\n\t\t  maps[x][y]='>';\n\t\t}\n\t    }\n\t  if(tmp=='S')\n\t    {\n\t      int dx=0,dy=0;\n\t      int tmpx=x,tmpy=y;\n\t      if(maps[x][y]=='^')\n\t\tdx=-1;\n\t      else if(maps[x][y]=='v')\n\t\tdx=1;\n\t      else if(maps[x][y]=='<')\n\t\tdy=-1;\n\t      else\n\t\tdy=1;\n\t      while(tmpx+dx<h&&tmpy+dy<w)\n\t\t{\n\t\t  tmpx+=dx;\n\t\t  tmpy+=dy;\n\t\t  if(maps[tmpx][tmpy]=='*')\n\t\t    {\n\t\t      maps[tmpx][tmpy]='.';\n\t\t      break;\n\t\t    }\n\t\t  if(maps[tmpx][tmpy]=='#')\n\t\t    {\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\t  \n\t}\n\t\n\t\n\tfor(int i=0;i<h;i++,cout<<endl)\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      cout<<maps[i][j];\n\t    }\n\tif(t!=0)\n\t  cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<cstring>\n#include<iostream>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> pin;\ntypedef std::pair<int,std::pair<int, int> > ppin;\n\nusing namespace std;\n\nchar ma[22][22];\n\nint main(){\n    \n    int n;\n    cin>>n;\n    while(n--){\n        int a,b;\n        cin>>a>>b;\n        int x=0,y=0,d=0;\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cin>>ma[i][j];\n                if(ma[i][j]=='^'){\n                    y=i; x=j; d=0;\n                }\n                if(ma[i][j]=='v'){\n                    y=i; x=j; d=1;\n                }\n                if(ma[i][j]=='<'){\n                    y=i; x=j; d=2;\n                }\n                if(ma[i][j]=='>'){\n                    y=i; x=j; d=3;\n                }\n            }\n        }\n        \n        int str;\n        cin>>str;\n        string s;\n        cin>>s;\n        for(int k=0;k<s.length();k++){\n            switch(s[k]){\n                case 'U':\n                    \n                    d=0;\n                    if(ma[y-1][x]!='.'||y==0)\n                        continue;\n                    y--;\n                    ma[y+1][x]='.';\n                    ma[y][x]='^';\n                    break;\n                case 'D':\n                    d=1;\n                    if(ma[y+1][x]!='.'||y+1==a)\n                        continue;\n                    \n                    y++;\n                    ma[y-1][x]='.';\n                    ma[y][x]='v';\n                    break;\n                case 'L':\n                    d=2;\n                    if(ma[y][x-1]!='.'||x==0)\n                        continue;\n                    \n                    x--;\n                    ma[y][x+1]='.';\n                    ma[y][x]='<';\n                    break;\n                case 'R':\n                    d=3;\n                    if(ma[y][x+1]!='.'||x+1==b)\n                        continue;\n                    \n                    x++;\n                    ma[y][x-1]='.';\n                    ma[y][x]='>';\n                    break;\n                case 'S':\n                    switch(d){\n                        case 0:\n                            for(int i=y-1;i>=0;i--){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 1:\n                            for(int i=y+1;i<a;i++){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 2:\n                            for(int i=x-1;i>=0;i--){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 3:\n                            for(int i=x+1;i<b;i++){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                    }\n//                    for(int i=0;i<a;i++){\n//                        for(int j=0;j<b;j++){\n//                            cout<<ma[i][j];\n//                        }\n//                        cout<<endl;\n//                    }\n//                    cout<<endl;\n                    break;\n            }\n        }\n        switch(d){\n            case 0:\n                ma[y][x]='^';\n                break;\n            case 1:\n                ma[y][x]='v';\n                break;\n            case 2:\n                ma[y][x]='<';\n                break;\n            case 3:\n                ma[y][x]='>';\n                break;\n        }\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cout<<ma[i][j];\n            }\n            cout<<endl;\n        }\n        if(n>1)cout<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint H, W;\nvector<string> G;\nint N;\nstring S;\nint sy, sx, sd;\n\nstring const DIRS = \"LURD\";\nstring const CDIRS = \"<^>v\";\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nbool in_range(int y, int x) {\n  if(!(0<=y&&y<H && 0<=x&&x<W)) return false;\n  return true;\n}\n\nbool in_move_range(int y, int x) {\n  if(!(0<=y&&y<H && 0<=x&&x<W)) return false;\n  if(G[y][x] == '*') return false;\n  if(G[y][x] == '-') return false;\n  if(G[y][x] == '#') return false;\n  return true;\n}\n\nvoid solve() {\n\n  int y = sy, x = sx, dir = sd;\n  \n  rep(idx, N) {\n    if(DIRS.find(S[idx]) != string::npos) {\n      dir = (int)DIRS.find(S[idx]);\n      int ny = y + dy[dir], nx = x + dx[dir];\n      if(!in_move_range(ny, nx)) continue;\n      y = ny, x = nx;\n    }\n    else {\n      int by = y, bx = x;\n      while(1) {\n\tby += dy[dir], bx += dx[dir];\n\tif(!in_range(by, bx)) break;\n\tif(G[by][bx] == '*') {\n\t  G[by][bx] = '.';\n\t  break;\n\t}\n\tif(G[by][bx] == '#') {\n\t  break;\n\t}\n      }\n    }\n  }\n\n  rep(i, H) rep(j, W + 1) {\n    if(j == W) cout << endl;\n    else {\n      if(y == i && x == j) cout << CDIRS[dir];\n      else cout << G[i][j];\n    }\n  }\n  \n}\n\nint main() {\n\n  int T; cin >> T;\n  rep(_, T) {\n    if(_) cout << endl;\n    \n    cin >> H >> W;\n    G.clear();\n    G.resize(H);\n    rep(i, H) {\n      cin >> G[i];\n    }\n\n    rep(i, H) rep(j, W) {\n      if(CDIRS.find(G[i][j]) != string::npos) {\n\tsd = CDIRS.find(G[i][j]);\n\tsy = i, sx = j;\n\tG[sy][sx] = '.';\n      }\n    }\n\n    cin >> N;\n\n    cin >> S;\n\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar dd[5] = \">v<^\";\n\nint main(){\n    int rep;\n    cin >> rep;\n    for(int r=0; r<rep; r++){\n        int h,w;\n        cin >> h >> w;\n        vector<vector<char> > field(h+2, vector<char>(w+2, '#'));\n        int x, y, dir;\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                char in;\n                cin >> in;\n                field[i][j] = in;\n                if(in=='^' || in=='<' || in=='>' || in=='v'){\n                    y = i;\n                    x = j;\n                    for(int k=0; k<4; k++){\n                        if(in == dd[k]) dir=k;\n                    }\n                }\n            }\n        }\n\n        int m;\n        string manip;\n        cin >> m >> manip;\n        for(int i=0; i<m; i++){\n            switch(manip[i]){\n            case 'U':\n                dir = 3;\n                goto move;\n            case 'D':\n                dir = 1;\n                goto move;\n            case 'L':\n                dir = 2;\n                goto move;\n            case 'R':\n                dir = 0;\n            move:\n                if(field[y+dy[dir]][x+dx[dir]] == '.'){\n                    field[y][x] = '.';\n                    y += dy[dir];\n                    x += dx[dir];\n                    field[y][x] = dd[dir];\n                }else{\n                    field[y][x] = dd[dir];\n                }\n                break;\n            case 'S':\n                int nx=x, ny=y;\n                while(field[ny][nx] != '#' && field[ny][nx] != '*'){\n                    ny += dy[dir];\n                    nx += dx[dir];\n                }\n                if(field[ny][nx] == '*'){\n                    field[ny][nx] = '.';\n                }\n            }\n        }\n\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                cout << field[i][j];\n            }\n            cout << endl;\n        }\n        if(r<rep-1) cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nchar*p,m[22][22],s[128],B[]=\"v>^<\",c;\nint main()\n{\n\tint T,h,w,i,j,x,y,a,A[128]={0},dx[]={0,1,0,-1,0};\n\tA['D']=A['v']=1;\n\tA['R']=A['>']=2;\n\tA['^']=A['U']=3;\n\tA['L']=A['<']=4;\n\tscanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tscanf(\"%d%d\",&h,&w);\n\t\tfor(i=1;i<=h;++i)if(scanf(\"%s\",m[i]+1),p=strpbrk(m[i]+1,\"><^v\"))y=i,x=p-m[i],a=A[*p]-1,*p='.';\n\t\tfor(i=0;i<=h;++i)m[i][0]=m[i][w+1]='#';\n\t\tfor(j=0;j<=w;++j)m[0][j]=m[h+1][j]='#';\n\t\tscanf(\"%*d%s\",s);\n\t\tfor(p=s;*p;++p)\n\t\t{\n\t\t\tif(A[*p])\n\t\t\t{\n\t\t\t\ta=A[*p]-1;\n\t\t\t\tif(m[y+dx[a+1]][x+dx[a]]=='.')y+=dx[a+1],x+=dx[a];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(i=1;c=m[y+i*dx[a+1]][x+i*dx[a]],c!='#'&&c!='*';++i);\n\t\t\t\tif(c=='*')m[y+i*dx[a+1]][x+i*dx[a]]='.';\n\t\t\t}\n\t\t}\n\t\tm[y][x]=B[a];\n\t\tfor(i=1;i<=h;puts(\"\"),++i)for(j=1;j<=w;++j)putchar(m[i][j]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 20;\nP pos;\nchar m[MAX][MAX];\nint r,c;\nvoid input(){\n  for(int i = 0; i < r; i++)\n    for(int j = 0; j < c; j++){\n      cin >> m[i][j];\n      if(m[i][j] == '<' || m[i][j] == '>' || \n\t m[i][j] == '^' || m[i][j] == 'v') pos = P(i,j);\n    }\n  \n}\n\nbool inside(P p){\n  return (0 <= p.first && p.first < r && 0 <= p.second && p.second < c);\n}\n\nvoid shoot(char c){\n\n  int x = 0, y = 0;\n  P p = pos;\n  if(c == '^') y = -1;\n  if(c == 'v') y = 1;\n  if(c == '>') x = 1;\n  if(c == '<') x = -1;\n\n  while(1){\n    p.first += y;\n    p.second += x;\n    if(!inside(p)) break;\n    if(m[p.first][p.second] == '#') break;\n    if(m[p.first][p.second] == '*'){\n      m[p.first][p.second] = '.';\n      break;\n    }\n  }\n}\n\nbool movable(char c){\n  string s = \"\";\n\n  for(int i = 0; i < s.length(); i++)\n    if(c == s[i]) return false;\n\n  return true;\n}\n\n\nvoid move(char c, int x, int y){\n  if(0 <= pos.first+y && pos.first+y < r &&\n     0 <= pos.second+x && pos.second+x < c &&\n     m[pos.first+y][pos.second+x] == '.'){\n    m[pos.first][pos.second] = '.';\n    m[pos.first+y][pos.second+x] = c;\n    pos.first += y;\n    pos.second += x;\n  }else{\n    m[pos.first][pos.second] = c;\n  }\n}\n\nint main(){\n  bool flag = false;\n  int X;\n  cin >> X;\n  while(X--){\n    if(flag) cout << endl;\n    flag = true;\n\n    cin >> r >> c;\n    input();\n    int num;\n    cin >> num;\n    for(int i = 0; i < num; i++){\n      char c;\n      cin >> c;\n      if(c == 'S') shoot(m[pos.first][pos.second]);\n      if(c == 'U') move('^',0,-1);\n      if(c == 'D') move('v',0,1);\n      if(c == 'L') move('<',-1,0);\n      if(c == 'R') move('>',1,0);\n    }\n\n    for(int i = 0; i < r; i++){\n      for(int j = 0; j < c; j++)\n\tcout << m[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint W, H, x, y;\nvector<string> map;\n\nvoid Move(char c)\n{\n    if (c == 'U') {\n        map[y][x] = '^';\n        if (y - 1 >= 0 && map[y - 1][x] == '.') {\n            swap(map[y][x], map[y - 1][x]);\n            --y;\n        }\n    }\n    else if (c == 'D') {\n        map[y][x] = 'v';\n        if (y + 1 < H && map[y + 1][x] == '.') {\n            swap(map[y][x], map[y + 1][x]);\n            ++y;\n        }\n    }\n    else if (c == 'L') {\n        map[y][x] = '<';\n        if (x - 1 >= 0 && map[y][x - 1] == '.') {\n            swap(map[y][x], map[y][x - 1]);\n            --x;\n        }\n    }\n    else if (c == 'R') {\n        map[y][x] = '>';\n        if (x + 1 < W && map[y][x + 1] == '.') {\n            swap(map[y][x], map[y][x + 1]);\n            ++x;\n        }\n    }\n    else if (c == 'S') {\n        int dx = 0, dy = 0;\n        if (map[y][x] == '^')\n            dy = -1;\n        else if (map[y][x] == '>')\n            dx = 1;\n        else if (map[y][x] == 'v')\n            dy = 1;\n        else if (map[y][x] == '<')\n            dx = -1;\n\n        for (int i = 1; ; ++i) {\n            if (x + i * dx < 0 || x + i * dx >= W ||\n                y + i * dy < 0 || y + i * dy >= H)\n                break;\n            if (map[y + i * dy][x + i * dx] == '*') {\n                map[y + i * dy][x + i * dx] = '.';\n                break;\n            }\n            if (map[y + i * dy][x + i * dx] == '#')\n                break;\n        }\n    }\n}\n\nint main()\n{\n    int T;\n\n    cin >> T;\n    while (T--) {\n        cin >> H >> W;\n        map.assign(H, \"\");\n\n        for (int i = 0; i < H; ++i)\n            cin >> map[i];\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                if (map[i][j] == '^' || map[i][j] == '>' ||\n                    map[i][j] == 'v' || map[i][j] == '<')\n                    x = j, y = i;\n\n        string order;\n        int num;\n\n        cin >> num;\n        cin >> order;\n\n        for (int i = 0; i < num; ++i)\n            Move(order[i]);\n\n        // Output\n        for (int i = 0; i < H; ++i)\n            cout << map[i] << \"\\n\";\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<(b))\nusing namespace std;\nint t, h, w, n;\nchar town[32][32], cmd[128];\n\nvoid shot(int y, int x){\n  int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0}; // U D L R\n  int d;\n  switch(town[y][x]){\n  case '^': d = 0; break;\n  case 'v': d = 1; break;\n  case '<': d = 2; break;\n  case '>': d = 3; break;\n  }\n  //  printf(\"%d\\n\", d);\n  while(true){\n    if(between(0,y+dy[d], h) && between(0, x+dx[d], w)){\n      y+=dy[d]; x+=dx[d];\n      if(town[y][x] == '*'){\n\ttown[y][x] = '.';\n\tbreak;\n      }else if(town[y][x] == '#'){\n\tbreak;\n      }\n    }else break;\n  }\n  return;\n}\n\nint main(){\n  scanf(\"%d\", &t);\n  bool f = false;\n  while(t--){\n    scanf(\"%d%d\", &h, &w);\n    rep(i, h) scanf(\"%s\", town[i]);\n \n    scanf(\"%d\", &n);\n    scanf(\"%s\", cmd);\n    int x, y;\n    rep(i, h) rep(j, w) \n      if(town[i][j]=='^' || town[i][j]=='v' || town[i][j]=='<' || town[i][j]=='>')x=j,y=i;\n    rep(i, n){\n      //      printf(\"%d %d\\n\", y, x);\n      switch(cmd[i]){\n      case 'U':\n\tif(town[y-1][x] == '.'){ town[y][x] = '.'; town[--y][x] = '^';}\n\telse town[y][x] = '^';\n\tbreak;\n      case 'D':\n\tif(town[y+1][x] == '.'){ town[y][x] = '.'; town[++y][x] = 'v';}\n\telse town[y][x] = 'v';\n\tbreak;\n      case 'L':\n\tif(town[y][x-1] == '.'){ town[y][x] = '.'; town[y][--x] = '<';}\n\telse town[y][x] = '<';\n\tbreak;\n      case 'R':\n\tif(town[y][x+1] == '.'){ town[y][x] = '.'; town[y][++x] = '>';}\n\telse town[y][x] = '>';\n\tbreak;\n      case 'S':\n\tshot(y, x);\n\tbreak;\n      }\n    }      \n    if(f) puts(\"\");\n    rep(i, h){\n      rep(j, w) printf(\"%c\", town[i][j]);\n      puts(\"\");\n    }\n    \n    f = 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nchar dc[] = {'^', '>', 'v', '<'};\nchar field[100][100];\n\nvoid make_move(int &x, int &y, int &d, char c){\n  if(c == 'S'){\n    int sy = y;\n    int sx = x;\n    while(field[sy][sx] != '#' && field[sy][sx] != '*'){\n      sy += dy[d];\n      sx += dx[d];\n    }\n    if(field[sy][sx] == '*'){\n      field[sy][sx] = '.';\n    }\n  }else {\n    if(c == 'U') d = 0;\n    if(c == 'D') d = 2;\n    if(c == 'L') d = 3;\n    if(c == 'R') d = 1;\n    int y2 = y + dy[d];\n    int x2 = x + dx[d];\n    if(field[y2][x2] == '.') {\n      y = y2;\n      x = x2;\n    }\n  }\n}\n\n\n\nint main(){\n  int T;\n  int x, y, d;\n  int H, W, n;\n  string order; \n  cin >> T;\n  rep(t, T) {\n    if(t != 0) cout << endl;\n    fill(&field[0][0], &field[0][0] + 100 * 100, '#');\n    cin >> H >> W;\n    rep(i, H)rep(j, W){\n      cin >> field[i+1][j+1];\n      switch(field[i+1][j+1]){\n      case '^':\n\tfield[i+1][j+1] = '.';\n\tx = j + 1;\n\ty = i + 1;\n\td = 0;\n\tbreak;\n      case '>':\n\tfield[i+1][j+1] = '.';\n\tx = j + 1;\n\ty = i + 1;\n\td = 1;\n\tbreak;\n      case 'v':\n\tfield[i+1][j+1] = '.';\n\tx = j + 1;\n\ty = i + 1;\n\td = 2;\n\tbreak;\n      case '<':\n\tfield[i+1][j+1] = '.';\n\tx = j + 1;\n\ty = i + 1;\n\td = 3;\n\tbreak;\n      }\n    }\n    cin >> n;\n    cin >> order;\n    rep(i, (int)order.size()){\n      make_move(x, y, d, order[i]);\n    }\n    field[y][x] = dc[d];\n    rep(i, H){\n      rep(j, W) cout << field[i+1][j+1];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[]={-1,0,1,0};\nint dy[]={0,1,0,-1};\nvoid shot(const int ax,const int ay,vector<string>&field,int way){\n    int nextx=ax;\n    int nexty=ay;\n    while(true){\n        nextx+=dx[way];\n        nexty+=dy[way];\n        char& ch(field[nexty][nextx]);\n        if(ch=='.')continue;\n        else if(ch=='*'){\n            ch='.';\n            return;\n        }else if(ch=='#'){\n            return;\n        }else if(ch=='-')continue;\n        else{\n            assert(false);\n        }\n    }\n}\nint main(){\n    int T;cin>>T;\n    while(T--){\n        int H,W;cin>>H>>W;\n        H+=2;\n        W+=2;\n        vector<string>field(H);\n        field[0]=string(W,'#');\n        for(int i=0;i<H-2;++i){\n            string st;cin>>st;\n            field[i+1]=\"#\"+st+\"#\";\n        }\n        field[H-1]=string(W,'#');\n        int way;\n        int tank_x,tank_y;\n        string way_mp=\"<v>^\";\n        {\n            for(int y=0;y<H;++y){\n                for(int x=0;x<W;++x){\n                    char ch=field[y][x];\n                    if(way_mp.find(ch)!=-1){\n                        way=way_mp.find(ch);\n                        field[y][x]='.';\n                        tank_x=x;\n                        tank_y=y;\n                    }\n                }\n            }\n        }\n        int N;cin>>N;\n        string move_st;\n        cin>>move_st;\n\n        for(auto ch:move_st){\n            string move_mp(\"LDRUS\");\n            int k=move_mp.find(ch);\n            if(k==4){\n                shot(tank_x,tank_y,field,way);\n            }else{\n                way=k;\n                int next_tank_x=tank_x+dx[way];\n                int next_tank_y=tank_y+dy[way];\n                if(field[next_tank_y][next_tank_x]=='.'){\n                    tank_x=next_tank_x;\n                    tank_y=next_tank_y;\n                }\n            }\n        }\n        field[tank_y][tank_x]=way_mp[way];\n        for(int i=1;i<H-1;++i){\n            cout<<field[i].substr(1,W-2)<<endl;\n        }\n        cout<<endl;\n        \n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint main()\n{\n  int t;\n  cin>>t;\n  for(;t--;)\n    {\n      int h,w;\n      cin>>h>>w;\n      //      cout<<h<<\" \"<<w<<endl;\n      char map[h][w];\n      int x,y;\n      //      char move;     //^=0,>=1,v=2,<=3\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>map[i][j];\n\t    \n\t    if(map[i][j]=='^' ||map[i][j]=='>'\n\t       ||map[i][j]=='v'||map[i][j]=='<')\n\t      x=i,y=j;//move=map[i][j];\t    \n\t    \n\t  }\n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  char tmp;\n\t  cin>>tmp;\n\t  if(tmp=='U')\n\t    {\n\t      map[x][y]='^';\n\t      if(x>0&&map[x-1][y]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  x--;\n\t\t  map[x][y]='^';\n\t\t}\n\t    }\n\t  if(tmp=='D')\n\t    {\n\t      map[x][y]='v';\n\t      if(x<h-1&&map[x+1][y]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  x++;\n\t\t  map[x][y]='v';\n\t\t}\n\t    }\n\n\n\t  if(tmp=='L')\n\t    {\n\t      map[x][y]='<';\n\t      if(y>0&&map[x][y-1]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  y--;\n\t\t  map[x][y]='<';\n\t\t}\n\t    }\n\t  if(tmp=='R')\n\t    {\n\t      map[x][y]='>';\n\t      if(y<w-1&&map[x][y+1]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  y++;\n\t\t  map[x][y]='>';\n\t\t}\n\t    }\n\t  if(tmp=='S')\n\t    {\n\t      int dx=0,dy=0;\n\t      int tmpx=x,tmpy=y;\n\t      if(map[x][y]=='^')\n\t\tdx=-1;\n\t      else if(map[x][y]=='v')\n\t\tdx=1;\n\t      else if(map[x][y]=='<')\n\t\tdy=-1;\n\t      else\n\t\tdy=1;\n\t      while(tmpx+dx<h&&tmpy+dy<w)\n\t\t{\n\t\t  tmpx+=dx;\n\t\t  tmpy+=dy;\n\t\t  if(map[tmpx][tmpy]=='*')\n\t\t    {\n\t\t      map[tmpx][tmpy]='.';\n\t\t      break;\n\t\t    }\n\t\t  if(map[tmpx][tmpy]=='#')\n\t\t    {\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\t  \n\t}\n\t\n\t\n\tfor(int i=0;i<h;i++,cout<<endl)\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      cout<<map[i][j];\n\t    }\n\tif(t!=0)\n\t  cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nenum Dir { U, R, D, L };\nstruct Tank { char x, y; Dir dir; };\n\nconst char tank_code[4] = {'^', '>', 'v', '<'};\nconst pair<char, char> vd[4] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\nchar pool[22][21];\nchar (*f)[21] = (char (*)[21])pool[1];\n\nint main() {\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++) {\n    // load\n    Tank tank;\n    int h, w;\n    cin >> h >> w;\n    memset(pool, '#', sizeof(pool));\n    for (int y = 0; y < h; y++) {\n      for (int x = 0; x < w; x++) {\n        char v;\n        cin >> v;\n        const char* found = find(tank_code, tank_code + 4, v);\n        if (found == tank_code + 4) {\n          f[y][x] = v;\n        } else {\n          tank.x = x;\n          tank.y = y;\n          tank.dir = (Dir)(found - tank_code);\n          f[y][x] = '.';\n        }\n      }\n    }\n\n    // op\n    int n;\n    cin >> n;\n    for (int j = 0; j < n; j++) {\n      char op;\n      cin >> op;\n      if (op == 'S') {\n        // shoot\n        char x = tank.x;\n        char y = tank.y;\n        auto& v = vd[tank.dir];\n        while (f[y][x] != '#') {\n          if (f[y][x] == '*') {\n            f[y][x] = '.';\n            break;\n          }\n          x += v.second;\n          y += v.first;\n        }\n      } else {\n        // move\n        Dir dir = op == 'U' ? U : op == 'R' ? R : op == 'D' ? D : L;\n        tank.dir = dir;\n        char dest_x = tank.x + vd[tank.dir].second;\n        char dest_y = tank.y + vd[tank.dir].first;\n        if (f[dest_y][dest_x] == '.') {\n          tank.x = dest_x;\n          tank.y = dest_y;\n        }\n      }\n    }\n    f[tank.y][tank.x] = tank_code[tank.dir];\n\n    // draw\n    if (i != 0) cout << endl;\n    for (int y = 0; y < h; y++) {\n      for (int x = 0; x < w; x++) {\n        cout << f[y][x];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint W, H, x, y;\nchar map[21][21];\n\nvoid Move(char c)\n{\n    if (c == 'U') {\n        map[y][x] = '^';\n        if (y - 1 >= 0 && map[y - 1][x] == '.') {\n            swap(map[y][x], map[y - 1][x]);\n            --y;\n        }\n    }\n    else if (c == 'D') {\n        map[y][x] = 'v';\n        if (y + 1 < H && map[y + 1][x] == '.') {\n            swap(map[y][x], map[y + 1][x]);\n            ++y;\n        }\n    }\n    else if (c == 'L') {\n        map[y][x] = '<';\n        if (x - 1 >= 0 && map[y][x - 1] == '.') {\n            swap(map[y][x], map[y][x - 1]);\n            --x;\n        }\n    }\n    else if (c == 'R') {\n        map[y][x] = '>';\n        if (x + 1 < W && map[y][x + 1] == '.') {\n            swap(map[y][x], map[y][x + 1]);\n            ++x;\n        }\n    }\n    else if (c == 'S') {\n        int dx = 0, dy = 0;\n        if (map[y][x] == '^')\n            dy = -1;\n        else if (map[y][x] == '>')\n            dx = 1;\n        else if (map[y][x] == 'v')\n            dy = 1;\n        else if (map[y][x] == '<')\n            dx = -1;\n\n        for (int i = 1; ; ++i) {\n            if (x + i * dx < 0 || x + i * dx >= W ||\n                y + i * dy < 0 || y + i * dy >= H)\n                break;\n            if (map[y + i * dy][x + i * dx] == '*') {\n                map[y + i * dy][x + i * dx] = '.';\n                break;\n            }\n            if (map[y + i * dy][x + i * dx] == '#')\n                break;\n        }\n    }\n}\n\nint main()\n{\n    int T;\n\n    cin >> T;\n    while (T--) {\n        cin >> H >> W;\n\n        for (int i = 0; i < H; ++i)\n            cin >> map[i];\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                if (map[i][j] == '^' || map[i][j] == '>' ||\n                    map[i][j] == 'v' || map[i][j] == '<')\n                    x = j, y = i;\n\n        string order;\n        int num;\n\n        cin >> num;\n        cin >> order;\n\n        for (int i = 0; i < num; ++i)\n            Move(order[i]);\n\n        // Output\n        for (int i = 0; i < H; ++i)\n            cout << map[i] << \"\\n\";\n        if (T != 0)\n            cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring field[20];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\nstring dir_str = \">^<v\";\nstring dir_str2 = \"RULD\";\n\n#define DBG(x) cerr<<#x<<\": \"<<x<<endl;\n\nint main() {\n\tint N;\n\tcin >> N;\n\twhile(N--) {\n\t\tint H, W;\n\t\t\n\t\tcin >> H >> W;\n\t\t\n\t\tcin.ignore();\n\t\t\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tgetline(cin, field[y]);\n\t\t}\n\t\t\n\t\tint curX, curY, dir;\n\t\t\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(find(dir_str.begin(), dir_str.end(), field[y][x]) != dir_str.end()) {\n\t\t\t\t\tdir = find(dir_str.begin(), dir_str.end(), field[y][x]) - dir_str.begin();\n\t\t\t\t\tcurX = x;\n\t\t\t\t\tcurY = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tDBG(curX);\n\t\tDBG(curY);\n\t\tDBG(dir);\n\t\t*/\n\t\t\n\t\tint len_cmd; string cmd;\n\t\tcin >> len_cmd >> cmd;\n\t\t\n\t\tfor(int cn = 0; cn < len_cmd; cn++) {\n\t\t\tchar c = cmd[cn];\n\t\t\tif(find(dir_str2.begin(), dir_str2.end(), c) != dir_str2.end()) {\n\t\t\t\tint d = find(dir_str2.begin(), dir_str2.end(), c) - dir_str2.begin();\n\t\t\t\t\n\t\t\t\tdir = d;\n\t\t\t\t\n\t\t\t\tint nx = curX + dx[d];\n\t\t\t\tint ny = curY + dy[d];\n\t\t\t\t\n\t\t\t\tif(0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] == '.') {\n\t\t\t\t\tfield[curY][curX] = '.';\n\t\t\t\t\tfield[ny][nx] = dir_str[d];\n\t\t\t\t\tcurX = nx;\n\t\t\t\t\tcurY = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(c == 'S') {\n\t\t\t\tint nx = curX + dx[dir];\n\t\t\t\tint ny = curY + dy[dir];\n\t\t\t\t\n\t\t\t\twhile(0 <= nx && nx < W && 0 <= ny && ny < H) {\n\t\t\t\t\t\n\t\t\t\t\tif(field[ny][nx] == '*') {\n\t\t\t\t\t\tfield[ny][nx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(field[ny][nx] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tnx += dx[dir];\n\t\t\t\t\tny += dy[dir];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcerr << \"turn: \" << cn << endl;\n\t\t\tfor(int y = 0; y < H; y++) {\n\t\t\t\tcout << field[y] << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tcout << field[y] << endl;\n\t\t}\n\t\t\n\t\tif(N > 0) {\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint main(){\n\n\tchar field[21][21];\n\tint h,w;\n\tint t;\n\tcin>>t;\n\tfor(int l = 0; l < t; l++){\n\t\tif(l!=0)\n\t\t\tcout<<endl;\n\t\tchar angle;\n\t\tcin>>h>>w;\n\t\tint sy,sx;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tswitch(field[i][j]){\n\t\t\t\tcase '^':\n\t\t\t\t\tangle='u';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tangle='d';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tangle='r';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tangle='l';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint num;\n\t\tcin>>num;\n\t\tstring order;\n\t\tcin>>order;\n\t\tint cx=sx;\n\t\tint cy=sy;\n\t\tfor(int j = 0; j < order.size(); j++){\n\t\t\tchar o=order[j];\n\t\t\tif(o=='U'){\n\t\t\t\tangle='u';\n\t\t\t\tint ny=cy-1;\n\t\t\t\tint nx=cx;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='^';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='D'){\n\t\t\t\tangle='d';\n\t\t\t\tint ny=cy+1;\n\t\t\t\tint nx=cx;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='v';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='L'){\n\t\t\t\tangle='l';\n\t\t\t\tint ny=cy;\n\t\t\t\tint nx=cx-1;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='<';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='R'){\n\t\t\t\tangle='r';\n\t\t\t\tint ny=cy;\n\t\t\t\tint nx=cx+1;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='S'){\n\t\t\t\tif(angle=='r'){\n\t\t\t\t\tfor(int i = cx+1; i < w; i++){\n\t\t\t\t\t\tif(field[cy][i]=='#'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[cy][i]=='*'){\n\t\t\t\t\t\t\tfield[cy][i]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='l'){\n\t\t\t\t\tfor(int i = cx-1; i >= 0; i--){\n\t\t\t\t\t\tif(field[cy][i]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[cy][i]=='*'){\n\t\t\t\t\t\t\tfield[cy][i]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='u'){\n\t\t\t\t\tfor(int i = cy-1; i >= 0; i--){\n\t\t\t\t\t\tif(field[i][cx]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[i][cx]=='*'){\n\t\t\t\t\t\t\tfield[i][cx]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='d'){\n\t\t\t\t\tfor(int i = cy+1; i < h; i++){\n\t\t\t\t\t\tif(field[i][cx]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[i][cx]=='*'){\n\t\t\t\t\t\t\tfield[i][cx]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcout<<field[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint H,W,N,x,y,d;\nchar f[20][20],c;\nchar dir[]={'U','D','L','R'};\nchar m[]={'^','v','<','>'};\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid shoot(){\n  int tx = x, ty = y;\n  while(true){\n    int nx = tx + dx[d],ny = ty + dy[d];\n    if(!inField(ny,nx) || f[ny][nx] == '#') return;\n    if(f[ny][nx] == '*'){ f[ny][nx] = '.'; return; }\n    tx = nx, ty = ny;\n  }\n}\n\nvoid move(){\n  int nx = x + dx[d],ny = y + dy[d];\n  f[y][x] = m[d];\n  if(!inField(ny,nx) || f[ny][nx] == '-' ||\n     f[ny][nx] == '#' || f[ny][nx] == '*') return;\n  f[y][x] = '.'; f[ny][nx] = m[d];\n  y = ny, x = nx;\n}\n\nvoid print(){\n rep(i,H){\n   rep(j,W){\n     cout << f[i][j];\n   }\n   cout << endl;\n }\n cout << endl;\n}\n\nvoid solve(){\n  cin >> N;\n  rep(i,N){\n   \n    cin >> c;\n    if(c == 'S'){\n      rep(j,4){\n        if(m[j] == f[y][x]){\n          d = j;\n          break;\n        }\n      }\n      shoot();\n    }else{\n      rep(j,4){\n        if(dir[j] == c){\n          d = j;\n          break;\n        }\n      }\n      move();\n    }\n  }\n  print();\n}\n\nint main(){\n  int Tc;\n  cin >> Tc;\n  while(Tc--){\n    cin >> H >> W;\n    rep(i,H) rep(j,W){\n      cin >> f[i][j];\n      if(f[i][j] == '<' || f[i][j] == '>' ||\n         f[i][j] == '^' || f[i][j] == 'v'){\n        y = i; x = j;\n      }\n    }\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[30][30];\nint dx[]={1,-1,0,0};\nint dy[]={0,0,-1,1};\nchar dir[6]=\"DULR\";\nchar com[110];\nint main(){\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);for(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tint d=0;\n\t\tint row,col;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='^'){\n\t\t\t\td=1;row=i;col=j;\n\t\t\t}\n\t\t\tif(str[i][j]=='v'){\n\t\t\t\td=0;row=i;col=j;\n\t\t\t}\n\t\t\tif(str[i][j]=='<'){\n\t\t\t\td=2;row=i;col=j;\n\t\t\t}\n\t\t\tif(str[i][j]=='>'){\n\t\t\t\td=3;row=i;col=j;\n\t\t\t}\n\t\t}\n\t\tstr[row][col]='.';\n\t\tint c;scanf(\"%d\",&c);\n\t\tscanf(\"%s\",com);\n\t\tfor(int i=0;i<c;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(com[i]==dir[j]){\n\t\t\t\t\td=j;\n\t\t\t\t\tif(0<=row+dx[d]&&row+dx[d]<a&&0<=col+dy[d]&&col+dy[d]<b&&str[row+dx[d]][col+dy[d]]=='.'){\n\t\t\t\t\t\trow+=dx[d];\n\t\t\t\t\t\tcol+=dy[d];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(com[i]=='S'){\n\t\t\t\tint nr=row;int nc=col;\n\t\t\t\twhile(1){\n\t\t\t\t\tnr+=dx[d];\n\t\t\t\t\tnc+=dy[d];\n\t\t\t\t\tif(nr<0||nr>=a||nc<0||nc>=b||str[nr][nc]=='#')break;\n\t\t\t\t\tif(str[nr][nc]=='*'){\n\t\t\t\t\t\tstr[nr][nc]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d==0)str[row][col]='v';\n\t\tif(d==1)str[row][col]='^';\n\t\tif(d==2)str[row][col]='<';\n\t\tif(d==3)str[row][col]='>';\n\t\tfor(int i=0;i<a;i++)printf(\"%s\\n\",str[i]);\n\t\tif(T)printf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <string>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define dm(x) cerr << #x << \" = \" << x << endl;\nusing namespace std;\n\nchar map[20][21];\nint H,W,N;\n\nstruct po{\n  int x;\n  int y;\n  po operator+(po &p){\n    po t={x+p.x, y+p.y};\n    return t;\n  }\n  char &l(){return map[x][y];}\n  bool v(){return 0<=x && x<H && 0<=y && y<W;}\n  void d(){dm(x);dm(y);}\n};\n\npo mp(int x,int y){\n  po t={x, y};\n  return t;\n}\n\nint main()\n{\n  int T;\n  scanf(\"%d\", &T);\n  rep(datasetindex, T){\n    po p={0,0},d={0,0};\n    char c[101];\n    scanf(\"%d %d\", &H, &W);\n    rep(i,H) scanf(\"%s\", map[i]);\n    scanf(\"%d\", &N);\n    scanf(\"%s\", c);\n    dm(H);dm(W);\n    rep(j,W) rep(i,H){\n      switch(map[i][j]){\n      case '^':p=mp(i,j);d=mp(-1,0);break;\n      case '>':p=mp(i,j);d=mp(0,1);break;\n      case 'v':p=mp(i,j);d=mp(1,0);break;\n      case '<':p=mp(i,j);d=mp(0,-1);break;\n      }\n    }\n    rep(i,H) printf(\"%d : %s\\n\", i, map[i]);\n    p.d();d.d();\n    rep(i,N){\n      dm(c[i]);\n      switch(c[i]){\n      case 'S':{\n        po s=p;\n        do{s=s+d;}while(s.v() && s.l()!='*' && s.l()!='#');\n        if(s.v() && s.l()=='*')\n          s.l()='.';\n        break;\n      }\n      case 'U':\n        p.l()='.';\n        d=mp(-1,0);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='^';\n        break;\n      case 'R':\n        p.l()='.';\n        d=mp(0,1);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='>';\n        break;\n      case 'D':\n        p.l()='.';\n        d=mp(1,0);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='v';\n        break;\n      case 'L':\n        p.l()='.';\n        d=mp(0,-1);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='<';\n        break;\n      }\n      rep(i,H) printf(\"%d : %s\\n\", i, map[i]);\n    }\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n \nint H,W,N,x,y,d;\nchar f[20][20],c;\nchar dir[]={'U','D','L','R'};\nchar m[]={'^','v','<','>'};\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\nbool flg;\n \nbool inField(int y,int x){\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\n \nvoid shoot(){\n    int tx = x, ty = y;\n    while(true){\n\tint nx = tx + dx[d],ny = ty + dy[d];\n\tif(!inField(ny,nx) || f[ny][nx] == '#') return;\n\tif(f[ny][nx] == '*'){ f[ny][nx] = '.'; return; }\n\ttx = nx, ty = ny;\n    }\n}\n \nvoid move(){\n    int nx = x + dx[d],ny = y + dy[d];\n    f[y][x] = m[d];\n    if(!inField(ny,nx) || f[ny][nx] == '-' ||\n       f[ny][nx] == '#' || f[ny][nx] == '*') return;\n    f[y][x] = '.'; f[ny][nx] = m[d];\n    y = ny, x = nx;\n}\n \nvoid print(){\n    rep(i,H){\n\trep(j,W){\n\t    cout << f[i][j];\n\t}\n\tcout << endl;\n    }\n}\n \nvoid solve(){\n    cin >> N;\n    rep(i,N){\n    \n\tcin >> c;\n\tif(c == 'S'){\n\t    rep(j,4){\n\t\tif(m[j] == f[y][x]){\n\t\t    d = j;\n\t\t    break;\n\t\t}\n\t    }\n\t    shoot();\n\t}else{\n\t    rep(j,4){\n\t\tif(dir[j] == c){\n\t\t    d = j;\n\t\t    break;\n\t\t}\n\t    }\n\t    move();\n\t}\n    }\n    print();\n}\n \nint main(){\n    int Tc;\n    cin >> Tc;\n    while(Tc--){\n\tif(flg) cout << endl; flg = true;\n\tcin >> H >> W;\n\trep(i,H) rep(j,W){\n\t    cin >> f[i][j];\n\t    if(f[i][j] == '<' || f[i][j] == '>' ||\n\t       f[i][j] == '^' || f[i][j] == 'v'){\n\t\ty = i; x = j;\n\t    }\n\t}\n\tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nchar*p,m[22][22],s[128],B[]=\"v>^<\",c;\nint main()\n{\n\tint T,t,h,w,i,j,x,y,a,A[128]={0},dx[]={0,1,0,-1,0};\n\tA['D']=A['v']=1;\n\tA['R']=A['>']=2;\n\tA['^']=A['U']=3;\n\tA['L']=A['<']=4;\n\tscanf(\"%d\",&T);\n\tfor(t=0;t<T;++t)\n\t{\n\t\tscanf(\"%d%d\",&h,&w);\n\t\tfor(i=1;i<=h;++i)if(scanf(\"%s\",m[i]+1),p=strpbrk(m[i]+1,\"><^v\"))y=i,x=p-m[i],a=A[*p]-1,*p='.';\n\t\tfor(i=0;i<=h;++i)m[i][0]=m[i][w+1]='#';\n\t\tfor(j=0;j<=w;++j)m[0][j]=m[h+1][j]='#';\n\t\tscanf(\"%*d%s\",s);\n\t\tfor(p=s;*p;++p)\n\t\t{\n\t\t\tif(A[*p])\n\t\t\t{\n\t\t\t\ta=A[*p]-1;\n\t\t\t\tif(m[y+dx[a+1]][x+dx[a]]=='.')y+=dx[a+1],x+=dx[a];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(i=1;c=m[y+i*dx[a+1]][x+i*dx[a]],c!='#'&&c!='*';++i);\n\t\t\t\tif(c=='*')m[y+i*dx[a+1]][x+i*dx[a]]='.';\n\t\t\t}\n\t\t}\n\t\tm[y][x]=B[a];\n\t\tif(t)puts(\"\");\n\t\tfor(i=1;i<=h;puts(\"\"),++i)for(j=1;j<=w;++j)putchar(m[i][j]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nconst int dx[4] = { 0, 0, -1, 1 };\nconst int dy[4] = { -1, 1, 0, 0 };\nconst char mov[] = \"UDLR\";\nconst char tank[] = \"^v<>\";\n\nint h, w, d, x, y;\nstring map[22], command;\n\nint main()\n{\n    int t, n;\n    cin >> t;\n    map[0] = \"######################\";\n\n    for(int i = 0; i < t; ++i)\n    {\n        cin >> h >> w;\n        for(int j = 1; j <= h; ++j) {\n            cin >> map[j];\n            map[j] = \"#\" + map[j] + \"#\";\n            for(int k = 0; k < 4; ++k)\n                if(map[j].find(tank[k]) != string::npos)\n                    y = j, x = map[j].find(tank[k]), d = k, map[y][x] = '.';\n        }\n        map[h+1] = map[0];\n        cin >> n >> command;\n\n        for(int j = 0; j < n; ++j)\n        {\n            for(int k = 0; k < 4; ++k)\n                if(command[j] == mov[k]) {\n                    d = k;\n                    if(map[y+dy[d]][x+dx[d]] == '.')\n                        x += dx[d], y += dy[d];\n                }\n\n            if(command[j] == 'S')\n                for(int xx = x, yy = y; map[yy][xx] != '#'; xx += dx[d], yy += dy[d])\n                    if(map[yy][xx] == '*') { map[yy][xx] = '.'; break; }\n        }\n\n        map[y][x] = tank[d];\n\n        if(i) cout << endl;\n        for(int j = 1; j <= h; ++j)\n            cout << map[j].substr(1, w) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<list>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cmath>\nusing namespace std;\nint main() {\n\tint u, n, m;\n\tcin >> u;\n\tfor (int z = 0; z < u; z++) {\n\t\tcin >> n >> m;\n\t\tchar a[20][20];\n\t\tint b[2];\n\t\tstring t;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> t;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ta[i][j] = t[j];\n\t\t\t\tif (a[i][j] == '>' || a[i][j] == '<' || a[i][j] == '^' || a[i][j] == 'v') {\n\t\t\t\t\tb[0] = i;\n\t\t\t\t\tb[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s;\n\t\tcin >> s;\n\t\tcin >> t;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tchar d;\n\t\t\td=t[i];\n\t\t\tswitch (d)\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\ta[b[0]][b[1]] = '^';\n\t\t\t\tif (b[0] - 1 >= 0 && a[b[0] - 1][b[1]] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[0]--;\n\t\t\t\t\ta[b[0]][b[1]] = '^';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\ta[b[0]][b[1]] = 'v';\n\t\t\t\tif (b[0] + 1 < n && a[b[0] + 1][b[1]] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[0]++;\n\t\t\t\t\ta[b[0]][b[1]] = '^';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ta[b[0]][b[1]] = '<';\n\t\t\t\tif (b[1] - 1 >= 0 && a[b[0]][b[1] - 1] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[1]--;\n\t\t\t\t\ta[b[0]][b[1]] = '<';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\ta[b[0]][b[1]] = '>';\n\t\t\t\tif (b[1] + 1 < m && a[b[0]][b[1] + 1] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[1]++;\n\t\t\t\t\ta[b[0]][b[1]] = '>';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tint x=0, y=0;\n\t\t\t\tif (a[b[0]][b[1]] == '^') {\n\t\t\t\t\tx = -1;\n\t\t\t\t}\n\t\t\t\telse if (a[b[0]][b[1]] == 'v') {\n\t\t\t\t\tx = 1;\n\t\t\t\t}\n\t\t\t\telse if (a[b[0]][b[1]] == '>') {\n\t\t\t\t\ty = 1;\n\t\t\t\t}\n\t\t\t\telse if (a[b[0]][b[1]] == '<') {\n\t\t\t\t\ty = -1;\n\t\t\t\t}\n\t\t\t\tint k = b[0], l = b[1];\n\t\t\t\twhile (k < n&&k >= 0 && l < m&&l >= 0) {\n\t\t\t\t\tif (a[k][l] == '*') {\n\t\t\t\t\t\ta[k][l] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (a[k][l] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk += x;\n\t\t\t\t    l += y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcout << a[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n} "
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nchar s[25][25],c[110],box[]={'^','>','v','<'};\nint n,w,h;\n\n\n\n\nvoid func(int y,int x,int now,int pre){\n\ts[y][x]=box[pre];\n\tif(now==n)\n\treturn;\n\ts[y][x]='.';\n\tif(c[now]=='U'){\n\t\tif(x>=0&&x<w&&y-1>=0&&y-1<h&&s[y-1][x]=='.')\n\t\ty--;pre=0;\n\t}else if(c[now]=='R'){\n\t\tif(x+1>=0&&x+1<w&&y>=0&&y<h&&s[y][x+1]=='.')\n\t\tx++;pre=1;\n\t}else if(c[now]=='D'){\n\t\tif(x>=0&&x<w&&y+1>=0&&y+1<h&&s[y+1][x]=='.')\n\t\ty++;pre=2;\n\t}else if(c[now]=='L'){\n\t\tif(x-1>=0&&x-1<w&&y>=0&&y<h&&s[y][x-1]=='.')\n\t\tx--;pre=3;\n\t}else if(c[now]=='S'){\n\t\tif(box[pre]=='>'){\n\t\t\tfor(int i=x;i<w;i++)\n\t\t\tif(s[y][i]=='*'){\n\t\t\t\ts[y][i]='.';\n\t\t\t\tbreak;\n\t\t\t}else if(s[y][i]=='#')\n\t\t\tbreak;\n\t\t}else if(box[pre]=='^'){\n\t\t\tfor(int i=y;i>=0;i--)\n\t\t\tif(s[i][x]=='*'){\n\t\t\t\ts[i][x]='.';\n\t\t\t\tbreak;\n\t\t\t}else if(s[i][x]=='#')\n\t\t\tbreak;\n\t\t}else if(box[pre]=='<'){\n\t\t\tfor(int i=x;i>=0;i--)\n\t\t\tif(s[y][i]=='*'){\n\t\t\t\ts[y][i]='.';\n\t\t\t\tbreak;\n\t\t\t}else if(s[y][i]=='#')\n\t\t\tbreak;\n\t\t}else\n\t\tif(box[pre]=='v'){\n\t\t\tfor(int i=y;i<h;i++)\n\t\t\tif(s[i][x]=='*'){\n\t\t\t\ts[i][x]='.';\n\t\t\t\tbreak;\n\t\t\t}else if(s[i][x]=='#')\n\t\t\tbreak;\n\t\t}\n\t}\n\tfunc(y,x,now+1,pre);\n}\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>h>>w;\n\t\trep(i,h)\n\t\t\tcin>>s[i];\n\t\tcin>>n;\n\t\tcin>>c;\n\t\trep(i,h)\n\t\trep(j,w){\n\t\t\tif(s[i][j]=='>'){\n\t\t\t\tfunc(i,j,0,1);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif(s[i][j]=='^'){\n\t\t\t\tfunc(i,j,0,0);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif(s[i][j]=='<'){\n\t\t\t\tfunc(i,j,0,3);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif(s[i][j]=='v'){\n\t\t\t\tfunc(i,j,0,2);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tend:\n\t\trep(i,h)\n\t\tcout<<s[i]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst string DIRS = \"URDL\", TANK = \"^>v<\";\nconst int dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nint T, H, W, N, tx, ty;\nstring grid[22], opr;\n\nvoid move(int d) {\n\tint nx = tx + dx[d], ny = ty + dy[d];\n\tif (!in_range(nx, ny, W, H) || grid[ny][nx] != '.') nx = tx, ny = ty;\n\tgrid[ty][tx] = '.';\n\tgrid[ny][nx] = TANK[d];\n\tty = ny; tx = nx;\n}\n\nvoid shoot() {\n\tint d = TANK.find(grid[ty][tx]);\n\tint x = tx + dx[d], y = ty + dy[d];\n\t\n\twhile (in_range(x, y, W, H) && grid[y][x] != '#' && grid[y][x] != '*') {\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\t\n\tif (in_range(x, y, W, H) && grid[y][x] == '*') grid[y][x] = '.';\n}\n\nvoid simulate() {\n\tfor_(i,0,N) {\n\t\tchar c = opr[i];\n\t\tif (c == 'S') shoot();\n\t\telse move((int)DIRS.find(c));\n\t}\n}\n\nint main() {\n\tcin >> T;\n\t\n\tfor_(case_num,0,T) {\n\t\tcin >> H >> W;\n\t\t\n\t\tfor_(y,0,H) {\n\t\t\tcin >> grid[y];\n\t\t\tfor_(x,0,W) if (TANK.find(grid[y][x]) != TANK.npos) tx = x, ty = y;\n\t\t}\n\t\t\n\t\tcin >> N;\n\t\tcin >> opr;\n\t\t\n\t\tsimulate();\n\t\t\n\t\tfor_(y,0,H) cout << grid[y] << endl;\n\t\tif (case_num < T - 1) cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,1,0,0,1,-1,1,-1};\nconst int dx[] = {0,0,-1,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nconst string Dir = \"UDLR^v<>\";\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t;\n  cin >> t;\n  rep(z,t){\n    if(z) cout << endl;\n    ll h,w,x,y,dir;\n    cin >> h >> w;\n    vector<vector<char>> v(h,vector<char>(w));\n    rep(i,h){\n      rep(j,w){\n        cin >> v[i][j];\n        if(v[i][j] == '^'){\n          dir = 0;\n          x = j,y = i;\n        }\n        if(v[i][j] == 'v'){\n          dir = 1;\n          x = j,y = i;\n        }\n        if(v[i][j] == '<'){\n          dir = 2;\n          x = j,y = i;\n        }\n        if(v[i][j] == '>'){\n          dir = 3;\n          x = j,y = i;\n        }\n      }\n    }\n    ll n;\n    cin >> n;\n    string s;\n    cin >> s;\n    rep(i,n){\n      if(s[i] != 'S'){\n        rep(j,4){\n          if(s[i] == Dir[j]){\n            dir = j;\n            break;\n          }\n        }\n        ll nx = x + dx[dir],ny = y+dy[dir];\n        if(value(nx,ny,w,h)){\n          if(v[ny][nx] == '.'){\n            v[y][x] = '.';\n            x = nx,y = ny;\n            v[ny][nx] = Dir[dir+4];\n          }\n          else{\n            v[y][x] = Dir[dir+4];\n          }\n        }\n        else{\n          v[y][x] = Dir[dir+4];\n        }\n      }\n      else{\n        ll nx = x,ny = y;\n        while(1){\n          nx += dx[dir],ny += dy[dir];\n          if(!value(nx,ny,w,h)) break;\n          if(v[ny][nx] == '*'){\n            v[ny][nx] = '.';\n            break;\n          }\n          if(v[ny][nx] == '#'){\n            break;\n          }\n        }\n      }\n    }\n    rep(k,h){\n      rep(j,w){\n        cout << v[k][j] ;\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint H, W, N, x, y, dx, dy;\nstring field[20];\n\nvoid show() {\n  // cout << \"---------\" << endl;\n  // cout << x << ' ' << y << endl;\n  for (int i = 0; i < H; i++)\n    cout << field[i] << endl;\n  cout << endl;\n}\n\nvoid solve() {\n  cin >> H >> W;\n  for (int i = 0; i < H; i++)\n    cin >> field[i];\n  for (int j = 0; j < H; j++)\n    for (int i = 0; i < W; i++)\n      if (field[j][i] == '^' || field[j][i] == 'v' ||\n          field[j][i] == '<' || field[j][i] == '>') {\n        x = i; y = j;\n        goto escape;\n      }\nescape:\n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    char c;\n    cin >> c;\n    switch (c) {\n    case 'S':\n      switch (field[y][x]) {\n      case '^':\n        dx = 0; dy = -1; break;\n      case 'v':\n        dx = 0; dy = 1; break;\n      case '<':\n        dx = -1; dy = 0; break;\n      case '>':\n        dx = 1; dy = 0; break;\n      default:\n        break;\n      }\n      break;\n    case 'U':\n      dx = 0; dy = -1; field[y][x] = '^'; break;\n    case 'D':\n      dx = 0; dy = 1; field[y][x] = 'v'; break;\n    case 'L':\n      dx = -1; dy = 0; field[y][x] = '<'; break;\n    case 'R':\n      dx = 1; dy = 0; field[y][x] = '>'; break;\n    default:\n      break;\n    }\n    if (c == 'S') {\n      int p = x, q = y;\n      for (;;) {\n        p += dx; q += dy;\n        if (p < 0 || p >= W || q < 0 || q >= H) break;\n        if (field[q][p] == '*') {\n          field[q][p] = '.';\n          break;\n        }\n        if (field[q][p] == '#') break;\n      }\n    } else {\n      int p = x + dx, q = y + dy;\n      if (0 <= p && p < W && 0 <= q && q < H && field[q][p] == '.') {\n        field[q][p] = field[y][x];\n        field[y][x] = '.';\n        x = p; y = q;\n      }\n    }\n    // show();\n  }\n  show();\n}\n\nint main() {\n  int T;\n  cin >> T;\n  for (int i = 0; i < T; i++)\n    solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint T;\nint n, m, dammy;\nstring fi[51];\nstring str;\n\nint main() {\n    cin >> T;\n    for (int AAA = 0; AAA < T; ++AAA) {\n        cin >> n >> m;\n        for (int i = 0; i < n; ++i) cin >> fi[i];\n        cin >> dammy; cin >> str;\n        \n        int si = -1, sj = -1, sd = -1;\n        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {\n            if (fi[i][j] == '<') si = i, sj = j, sd = 3, fi[i][j] = '.';\n            if (fi[i][j] == '>') si = i, sj = j, sd = 1, fi[i][j] = '.';\n            if (fi[i][j] == '^') si = i, sj = j, sd = 2, fi[i][j] = '.';\n            if (fi[i][j] == 'v') si = i, sj = j, sd = 0, fi[i][j] = '.';\n        }\n        for (int i = 0; i < str.size(); ++i) {\n            if (str[i] == 'D') {\n                int ni = si + dx[0], nj = sj + dy[0]; sd = 0;\n                if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n                if (fi[ni][nj] != '.') continue;\n                si = ni, sj = nj;\n            }\n            else if (str[i] == 'R') {\n                int ni = si + dx[1], nj = sj + dy[1]; sd = 1;\n                if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n                if (fi[ni][nj] != '.') continue;\n                si = ni, sj = nj;\n            }\n            else if (str[i] == 'U') {\n                int ni = si + dx[2], nj = sj + dy[2]; sd = 2;\n                if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n                if (fi[ni][nj] != '.') continue;\n                si = ni, sj = nj;\n            }\n            else if (str[i] == 'L') {\n                int ni = si + dx[3], nj = sj + dy[3]; sd = 3;\n                if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;\n                if (fi[ni][nj] != '.') continue;\n                si = ni, sj = nj;\n            }\n            else {\n                int ni = si, nj = sj;\n                while (true) {\n                    ni += dx[sd], nj += dy[sd];\n                    if (ni < 0 || ni >= n || nj < 0 || nj >= m) break;\n                    if (fi[ni][nj] == '*') { fi[ni][nj] = '.'; break; }\n                    else if (fi[ni][nj] == '#') { break; }\n                }\n            }\n//            for (int i = 0; i < n; ++i) cout << fi[i] << endl;\n//            if (AAA != T-1) cout << endl;\n        }\n        if (sd == 0) fi[si][sj] = 'v';\n        if (sd == 1) fi[si][sj] = '>';\n        if (sd == 2) fi[si][sj] = '^';\n        if (sd == 3) fi[si][sj] = '<';\n        \n        for (int i = 0; i < n; ++i) cout << fi[i] << endl;\n        if (AAA != T-1) cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n\tint loop;\n\tconst int UP = 0;\n\tconst int DOWN = 1;\n\tconst int LEFT = 2;\n\tconst int RIGHT = 3;\n\tint shot[4][2] = {{0,-1},{0,1},{-1,0},{1,0}};\n\tcin >> loop;\n\tfor(int n=0;n<loop;n++){\n\t\tchar stage[22][22];\n\n\t\tfor(int i=0;i<22;i++){\n\t\t\tfor(int j=0;j<22;j++){\n\t\t\t\tstage[i][j]='#';\n\t\t\t}\n\t\t}\n\n\t\tint h,w;\n\t\tint commandlength;\n\t\tstring command;\n\t\tint playerX,playerY,playerDir;\n\t\t\n\t\tcin >> h >> w;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tstring buf;\n\t\t\tcin >> buf;\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tstage[i][j] = buf[j-1];\n\t\t\t\tif(buf[j-1] == '^' || buf[j-1] == 'v' || buf[j-1] == '<' || buf[j-1] == '>'){\n\t\t\t\t\tplayerX = j;\n\t\t\t\t\tplayerY = i;\n\t\t\t\t\tswitch(buf[j-1]){\n\t\t\t\t\tcase '^':\n\t\t\t\t\t\tplayerDir = UP;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tplayerDir = DOWN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tplayerDir = LEFT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\tplayerDir = RIGHT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> commandlength;\n\t\tcin >> command;\n\n\t\tfor(int i=0;i<commandlength;i++){\n\t\t\tswitch(command[i]){\n\t\t\tcase 'U':\n\t\t\t\tif(stage[playerY-1][playerX] == '.'){\n\t\t\t\t\tstage[playerY][playerX] = '.';\n\t\t\t\t\tplayerY--;\n\t\t\t\t}\n\t\t\t\tstage[playerY][playerX] = '^';\n\t\t\t\tplayerDir = UP;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tif(stage[playerY+1][playerX] == '.'){\n\t\t\t\t\tstage[playerY][playerX] = '.';\n\t\t\t\t\tplayerY++;\n\t\t\t\t}\n\t\t\t\tstage[playerY][playerX] = 'v';\n\t\t\t\tplayerDir = DOWN;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tif(stage[playerY][playerX-1] == '.'){\n\t\t\t\t\tstage[playerY][playerX] = '.';\n\t\t\t\t\tplayerX--;\n\t\t\t\t}\n\t\t\t\tstage[playerY][playerX] = '<';\n\t\t\t\tplayerDir = LEFT;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tif(stage[playerY][playerX+1] == '.'){\n\t\t\t\t\tstage[playerY][playerX] = '.';\n\t\t\t\t\tplayerX++;\n\t\t\t\t}\n\t\t\t\tstage[playerY][playerX] = '>';\n\t\t\t\tplayerDir = RIGHT;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\t\tif(stage[playerY+shot[playerDir][1]*j][playerX+shot[playerDir][0]*j] == '*'){\n\t\t\t\t\t\tstage[playerY+shot[playerDir][1]*j][playerX+shot[playerDir][0]*j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(stage[playerY+shot[playerDir][1]*j][playerX+shot[playerDir][0]*j] == '#'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcout<<stage[y][x];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tif(n+1 != loop){\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tint l;\n\tcin>>l;\n\tint h,w;\n\tint cnt = 0;\n\twhile(l--){\n\t\tif(cnt++!=0){\n\t\t\tcout <<endl;\n\t\t}\n\t\tint dir =-1;//1→2↑3←4↓\n\t\tcin>>h>>w;\n\t\tchar board[22][22];\n\t\tint px,py;\n\t\trep(i,22)rep(j, 22)board[i][j]='\\0';\n\t\tfor(int i =0;i < h;i++){\n\t\t\tfor(int j =0;j <w;j++){\n\t\t\t\tcin>>board[i][j];\n\t\t\t\tif(board[i][j]=='>'){\n\t\t\t\t\tdir =1;\n\t\t\t\t\tpx =j;\n\t\t\t\t\tpy =i;\n\t\t\t\t}\n\t\t\t\tif(board[i][j]=='^'){\n\t\t\t\t\tdir =2;\n\t\t\t\t\tpx =j;\n\t\t\t\t\tpy = i;\n\t\t\t\t}\n\t\t\t\tif(board[i][j]=='<'){\n\t\t\t\t\tdir =3;\n\t\t\t\t\tpx =j;\n\t\t\t\t\tpy = i;\n\t\t\t\t}\n\t\t\t\tif(board[i][j]=='v'){\n\t\t\t\t\tdir =4;\n\t\t\t\t\tpx =j;\n\t\t\t\t\tpy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n;\n\t\tcin>>n;\n\t\tboard[py][px]='.';\n\t\tfor(int i =0;i < n;i++){\n\t\t\tchar cad;\n\t\t\tcin>>cad;\n\t\t\tif(cad=='U'){\n\t\t\t\tdir =2;\n\t\t\t\tif(py-1>=0&&board[py-1][px]=='.'){\n\t\t\t\t\tpy =py-1;\n\t\t\t\t}\n\t\t\t}else if(cad=='D'){\n\t\t\t\tdir =4;\n\t\t\t\tif(py+1<h&&board[py+1][px]=='.'){\n\t\t\t\t\tpy =py+1;\n\t\t\t\t}\n\t\t\t}else if(cad=='L'){\n\t\t\t\tdir =3;\n\t\t\t\tif(px-1>=0&&board[py][px-1]=='.'){\n\t\t\t\t\tpx =px-1;\n\t\t\t\t}\n\t\t\t}else if(cad=='R'){\n\t\t\t\tdir = 1;\n\t\t\t\tif(px+1<w&&board[py][px+1]=='.'){\n\t\t\t\t\tpx =px+1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(dir==1){//→\n\t\t\t\t\tfor(int j =px+1;j<w;j++){\n\t\t\t\t\t\tif(board[py][j]=='#')break;\n\t\t\t\t\t\tif(board[py][j]=='*'){\n\t\t\t\t\t\t\tboard[py][j]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(dir==2){//↑\n\t\t\t\t\tfor(int j =py-1;j >=0;j--){\n\t\t\t\t\t\tif(board[j][px]=='#')break;\n\t\t\t\t\t\tif(board[j][px]=='*'){\n\t\t\t\t\t\t\tboard[j][px]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(dir==3){//←\n\t\t\t\t\tfor(int j =px-1;j >=0;j--){\n\t\t\t\t\t\tif(board[py][j]=='#')break;\n\t\t\t\t\t\tif(board[py][j]=='*'){\n\t\t\t\t\t\t\tboard[py][j]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(dir==4){//↓\n\t\t\t\t\tfor(int j =py+1;j <h;j++){\n\t\t\t\t\t\tif(board[j][px]=='#')break;\n\t\t\t\t\t\tif(board[j][px]=='*'){\n\t\t\t\t\t\t\tboard[j][px]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dir==1){\n\t\t\tboard[py][px]='>';\n\t\t}else if(dir==2){\n\t\t\tboard[py][px]='^';\n\t\t}else if(dir==3){\n\t\t\tboard[py][px]='<';\n\t\t}else if(dir==4){\n\t\t\tboard[py][px]='v';\n\t\t}\n\t\tfor(int i =0;i <h;i++){\n\t\t\tfor(int j =0;j <w;j++){\n\t\t\t\tcout <<board[i][j];\n\t\t\t}\n\t\t\tcout <<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\n#define N 32\n#define PLANE '.'\n#define BLOCK '*'\n#define STEEL '#'\n#define WATER '-'\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\nconst char *tank_dir = \"^>v<\";\nint conv[256]={0,};\n\nusing namespace std;\n\nbool isinside(int i, int j, int h, int w){\n  return 0<=i&&i<h&&0<=j&&j<w;\n}\n\nvoid simulate(char M[][N], int h, int w, const string &v)\n{\n  int ti;\n  int tj;\n  int dir;\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j){\n      for(int k = 0; k < 4; ++k){\n\tif( tank_dir[k] == M[i][j] ){\n\t  ti = i;\n\t  tj = j;\n\t  dir = k;\n\t  M[i][j]=PLANE;\n\t}\n      }\n    }\n  }\n  conv['U']=0;\n  conv['R']=1;\n  conv['D']=2;\n  conv['L']=3;\n\n  for(int s=0;s<v.length();++s){\n    switch(v[s]){\n    case 'U':case'D':case 'L':case 'R':\n      int ni = ti+di[conv[v[s]]];\n      int nj = tj+dj[conv[v[s]]];\n      dir = conv[v[s]];\n      if( isinside(ni,nj,h,w) ){\n\tif( M[ni][nj] == PLANE ){\n\t  ti = ni;\n\t  tj = nj;\n\t}\n      }\n      break;\n    case 'S':\n      {\n\tint ai=ti,aj=tj;\n\twhile(true){\n\t  ai += di[dir];\n\t  aj += dj[dir];\n\t  \n\t  if( isinside(ai,aj,h,w) ){\n\t    if( M[ai][aj] == PLANE || M[ai][aj] == WATER ) continue;\n\t    else break;\n\t  }else break;\n\t  \n\t}\n\tif( M[ai][aj] == BLOCK ){\n\t  M[ai][aj] = PLANE;\n\t}\n      }\n      break;\n    }\n  }\n  for(int i = 0; i < h; ++i){\n    for(int j = 0; j < w; ++j){\n      if( i == ti && j == tj ){\n\tputchar(tank_dir[ dir ]);\n      }else{\n\tputchar(M[i][j]);\n      }\n    }\n    putchar('\\n');\n  }\n  return ;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n    int h,w;\n    char M[N][N];\n    string cmd;\n    cin >> h >> w;\n    if( tc > 1 )putchar('\\n');\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tcin >> M[i][j];\n      }\n    }\n    int vlen;\n    cin >> vlen;\n    cin >> cmd;\n    \n    simulate( M, h, w, cmd );\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint main(){\n\n\tchar field[21][21];\n\tint h,w;\n\tint t;\n\tcin>>t;\n\tfor(int l = 0; l < t; l++){\n\t\tif(l!=0){\n\t\t\tcout<<endl;\n\t\t\tcout<<endl;\n\t\t}\n\t\tchar angle;\n\t\tcin>>h>>w;\n\t\tint sy,sx;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tswitch(field[i][j]){\n\t\t\t\tcase '^':\n\t\t\t\t\tangle='u';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tangle='d';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tangle='r';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tangle='l';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint num;\n\t\tcin>>num;\n\t\tstring order;\n\t\tcin>>order;\n\t\tint cx=sx;\n\t\tint cy=sy;\n\t\tfor(int j = 0; j < order.size(); j++){\n\t\t\tchar o=order[j];\n\t\t\tif(o=='U'){\n\t\t\t\tangle='u';\n\t\t\t\tint ny=cy-1;\n\t\t\t\tint nx=cx;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='^';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='D'){\n\t\t\t\tangle='d';\n\t\t\t\tint ny=cy+1;\n\t\t\t\tint nx=cx;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='v';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='L'){\n\t\t\t\tangle='l';\n\t\t\t\tint ny=cy;\n\t\t\t\tint nx=cx-1;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='<';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='R'){\n\t\t\t\tangle='r';\n\t\t\t\tint ny=cy;\n\t\t\t\tint nx=cx+1;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='S'){\n\t\t\t\tif(angle=='r'){\n\t\t\t\t\tfor(int i = cx+1; i < w; i++){\n\t\t\t\t\t\tif(field[cy][i]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[cy][i]=='*'){\n\t\t\t\t\t\t\tfield[cy][i]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='l'){\n\t\t\t\t\tfor(int i = cx-1; i >= 0; i--){\n\t\t\t\t\t\tif(field[cy][i]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[cy][i]=='*'){\n\t\t\t\t\t\t\tfield[cy][i]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='u'){\n\t\t\t\t\tfor(int i = cy-1; i >= 0; i--){\n\t\t\t\t\t\tif(field[i][cx]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[i][cx]=='*'){\n\t\t\t\t\t\t\tfield[i][cx]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='d'){\n\t\t\t\t\tfor(int i = cy+1; i < h; i++){\n\t\t\t\t\t\tif(field[i][cx]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[i][cx]=='*'){\n\t\t\t\t\t\t\tfield[i][cx]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcout<<field[i][j];\n\t\t\t}\n\t\t\tif(i!=h-1)\n\t\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\nint main(){\n    int n;\n    cin>>n;\n    rep(loop,n){\n        if(loop!=0)cout<<endl;\n        string data[30];\n        int h,w;\n        cin>>h>>w;\n        rep(i,h){\n            cin>>data[i];\n        }\n        int x;\n        cin>>x;\n        string s;\n        cin>>s;\n        \n        pii now;\n        char st=' ';\n        \n        rep(i,h){\n            rep(j,w){\n                if( data[i][j]=='>' || data[i][j]=='^' || data[i][j]=='<' || data[i][j]=='v' ){\n                    now=pii(i,j);\n                    st=data[i][j];\n                    data[i][j]='.';\n                    break;\n                }\n            }\n        }\n        rep(i,x){\n            if(s[i]=='R'){\n                if(now.second+1<w&&data[now.first][now.second+1]=='.'){\n                    now.second++;\n                }\n                st='>';\n            }\n            if(s[i]=='L'){\n                if(now.second-1>=0&&data[now.first][now.second-1]=='.'){\n                    now.second--;\n                }\n                st='<';\n            }\n            if(s[i]=='D'){\n                if(now.first+1<w&&data[now.first+1][now.second]=='.'){\n                    now.first++;\n                }\n                st='v';\n            }\n            if(s[i]=='U'){\n                if(now.first-1<w&&data[now.first-1][now.second]=='.'){\n                    now.first--;\n                }\n                st='^';\n            }\n            if(s[i]=='S'){\n                int y=now.first,x=now.second;\n                int dir=0;\n                int dx[]={0,1,0,-1};\n                int dy[]={1,0,-1,0};\n                if(st=='v')dir=0;\n                if(st=='>')dir=1;\n                if(st=='^')dir=2;\n                if(st=='<')dir=3;\n                while(1){\n                    y+=dy[dir];\n                    x+=dx[dir];\n                    if(y<0||y>=h||x<0||x>=w)break;\n                    if(data[y][x]=='#')break;\n                    if(data[y][x]=='*'){\n                        data[y][x]='.';\n                        break;\n                    }\n                }\n            }\n        }\n        data[now.first][now.second]=st;\n        rep(i,h){\n            rep(j,w){\n                cout<<data[i][j];\n            }\n            cout<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint H,W,N,x,y,d;\nchar f[20][20],c;\nchar dir[]={'U','D','L','R'};\nchar m[]={'^','v','<','>'};\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\nbool flg;\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid shoot(){\n  int tx = x, ty = y;\n  while(true){\n    int nx = tx + dx[d],ny = ty + dy[d];\n    if(!inField(ny,nx) || f[ny][nx] == '#') return;\n    if(f[ny][nx] == '*'){ f[ny][nx] = '.'; return; }\n    tx = nx, ty = ny;\n  }\n}\n\nvoid move(){\n  int nx = x + dx[d],ny = y + dy[d];\n  f[y][x] = m[d];\n  if(!inField(ny,nx) || f[ny][nx] == '-' ||\n     f[ny][nx] == '#' || f[ny][nx] == '*') return;\n  f[y][x] = '.'; f[ny][nx] = m[d];\n  y = ny, x = nx;\n}\n\nvoid print(){\n rep(i,H){\n   rep(j,W){\n     cout << f[i][j];\n   }\n   cout << endl;\n }\n}\n\nvoid solve(){\n  cin >> N;\n  rep(i,N){\n   \n    cin >> c;\n    if(c == 'S'){\n      rep(j,4){\n        if(m[j] == f[y][x]){\n          d = j;\n          break;\n        }\n      }\n      shoot();\n    }else{\n      rep(j,4){\n        if(dir[j] == c){\n          d = j;\n          break;\n        }\n      }\n      move();\n    }\n  }\n  print();\n}\n\nint main(){\n  int Tc;\n  cin >> Tc;\n  while(Tc--){\n    if(flg) cout << endl; flg = true;\n    cin >> H >> W;\n    rep(i,H) rep(j,W){\n      cin >> f[i][j];\n      if(f[i][j] == '<' || f[i][j] == '>' ||\n         f[i][j] == '^' || f[i][j] == 'v'){\n        y = i; x = j;\n      }\n    }\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\nint H, W;\nstring field[30];\n\nbool check(int y, int x){\n\tif(y < 0 || y >= H || x < 0 || x >= W){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid shoot(int y, int x, char dir){\n\tif(dir == '^'){\n\t\twhile(true){\n\t\t\ty--;\n\t\t\tif(!check(y, x)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(field[y][x] == '*'){\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(field[y][x] == '#'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}else if(dir == 'v'){\n\t\twhile(true){\n\t\t\ty++;\n\t\t\tif(!check(y, x)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(field[y][x] == '*'){\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(field[y][x] == '#'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}else if(dir == '<'){\n\t\twhile(true){\n\t\t\tx--;\n\t\t\tif(!check(y, x)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(field[y][x] == '*'){\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(field[y][x] == '#'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}else if(dir == '>'){\n\t\twhile(true){\n\t\t\tx++;\n\t\t\tif(!check(y, x)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(field[y][x] == '*'){\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(field[y][x] == '#'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint T;\n\tcin >> T;\n\t\n\tfor(int loop = 0; loop < T; loop++){\n\t\t\n\t\tif(loop != 0){\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t\tcin >> H >> W;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcin >> field[i];\n\t\t}\n\t\t\n\t\tchar dir;\n\t\tint pos_x, pos_y;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(field[i][j] == '^' || field[i][j] == 'v' || field[i][j] == '<' || field[i][j] == '>'){\n\t\t\t\t\tdir = field[i][j];\n\t\t\t\t\tpos_y = i;\n\t\t\t\t\tpos_x = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint hoge;\n\t\tcin >> hoge;\n\t\t\n\t\tstring ord;\n\t\t\n\t\tcin >> ord;\n\t\t\n\t\tfor(int i = 0; i < hoge; i++){\n\t\t\tif(ord[i] == 'U'){\n\t\t\t\tdir = '^';\n\t\t\t\tif(check(pos_y - 1, pos_x)){\n\t\t\t\t\tif(field[pos_y - 1][pos_x] == '.'){\n\t\t\t\t\t\tfield[pos_y][pos_x] = '.';\n\t\t\t\t\t\tpos_y -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord[i] == 'D'){\n\t\t\t\tdir = 'v';\n\t\t\t\tif(check(pos_y + 1, pos_x)){\n\t\t\t\t\tif(field[pos_y + 1][pos_x] == '.'){\n\t\t\t\t\t\tfield[pos_y][pos_x] = '.';\n\t\t\t\t\t\tpos_y += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord[i] == 'L'){\n\t\t\t\tdir = '<';\n\t\t\t\tif(check(pos_y, pos_x - 1)){\n\t\t\t\t\tif(field[pos_y][pos_x - 1] == '.'){\n\t\t\t\t\t\tfield[pos_y][pos_x] = '.';\n\t\t\t\t\t\tpos_x -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord[i] == 'R'){\n\t\t\t\tdir = '>';\n\t\t\t\tif(check(pos_y, pos_x + 1)){\n\t\t\t\t\tif(field[pos_y][pos_x + 1] == '.'){\n\t\t\t\t\t\tfield[pos_y][pos_x] = '.';\n\t\t\t\t\t\tpos_x += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord[i] == 'S'){\n\t\t\t\tshoot(pos_y, pos_x, dir);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tfield[pos_y][pos_x] = dir;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcout << field[i] << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint h,w;\npair<pii,int> foo1(vector<string> &v){\n\tstring vec=\">v<^\";\n\trep(i,v.size()){\n\t\trep(j,v[i].size()){\n\t\t\trep(k,4){\n\t\t\t\tif(v[i][j]==vec[k]){\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t\treturn mkp(pii(i,j),k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mkp(pii(-1,-1),-1);\n}\nbool check(int a,int b){\n\tif(0<=a&&a<h&&0<=b&&b<w) return true;\n\treturn false;\n}\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\trep(o,n){\n\t\tif(o) cout<<endl;\n\t\tcin>>h>>w;\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tstring s;\n\t\tint t;\n\t\tcin>>t>>s;\n\t\tint dd[]={0,1,0,-1,0};// >,v,<,^\n\t\tpair<pii,int> pos=foo1(v);\n\t\tstring DRUL=\"RDLU\";\n\t\t//SRSSRRUSSR\n\t\trep(i,s.size()){\n\t\t\t// cout<<pos.F.F<<\" \"<<pos.F.S<<\" \"<<pos.S<<endl;\n\t\t\t// rep(j,h) cout<<v[j]<<endl;\n\t\t\t// cout<<endl;\n\t\t\tif(s[i]=='S'){\n\t\t\t\tint y=pos.F.F;\n\t\t\t\tint x=pos.F.S;\n\t\t\t\ty+=dd[pos.S];\n\t\t\t\tx+=dd[pos.S+1];\n\t\t\t\twhile(check(y,x)){\n\t\t\t\t\tif(v[y][x]=='#') break;\n\t\t\t\t\tif(v[y][x]=='*'){\n\t\t\t\t\t\tv[y][x]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ty+=dd[pos.S];\n\t\t\t\t\tx+=dd[pos.S+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(j,4){\n\t\t\t\t\tif(\"RDLU\"[j]==s[i]){\n\t\t\t\t\t\tpos.S=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ny=pos.F.F+dd[pos.S];\n\t\t\t\tint nx=pos.F.S+dd[pos.S+1];\n\t\t\t\tif(check(ny,nx)&&v[ny][nx]=='.'){\n\t\t\t\t\tpos.F=pii(ny,nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv[pos.F.F][pos.F.S]=\">v<^\"[pos.S];\n\t\trep(i,h){\n\t\t\tcout<<v[i]<<endl;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(0);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int> P;\nstring m  = \">^<v\",s;\nchar mas[21][21];\nint w,h,muki,sx,sy,len;\nint dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint shoot(int i,int j){\n    if((!(i >= 0 && i < h && j >= 0 && j < w)) || (mas[i][j] == '#')) return 1;\n    if(mas[i][j] == '*'){\n        mas[i][j] = '.';\n        return 1;\n    }\n    return shoot(i+dy[muki],j+dx[muki]);\n}\n\nP search(){\n    int i = sy,j = sx;\n    for(int k=0;k<len;k++){\n        if(s[k] == 'R'){\n            muki = 0;\n            if(i >= 0 && i < h && j+1 >= 0 && j+1 < w && mas[i][j+1] == '.') j++;\n        }\n        if(s[k] == 'U'){\n            muki = 1;\n            if(i-1 >= 0 && i-1 < h && j >= 0 && j < w && mas[i-1][j] == '.') i--;\n        }\n        if(s[k] == 'L'){\n            muki = 2;\n            if(i >= 0 && i < h && j-1 >= 0 && j-1 < w && mas[i][j-1] == '.') j--;\n        }\n        if(s[k] == 'D'){\n            muki = 3;\n            if(i+1 >= 0 && i+1 < h && j >= 0 && j < w && mas[i+1][j] == '.') i++;\n        }\n        if(s[k] == 'S'){\n            shoot(i,j);\n        }\n    }\n    P p = P(i,j);\n    return p;\n}\n\nint main(){\n    int t;\n    bool judge = false;\n    cin >> t;\n    while(t--){\n        if(judge) cout << endl;\n        judge = true;\n        cin >> h >> w;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> mas[i][j];\n                if(mas[i][j] == '>'){\n                    muki = 0; mas[i][j] = '.';\n                    sx = j; sy = i;\n                }\n                if(mas[i][j] == '^'){\n                    muki = 1; mas[i][j] = '.';\n                    sx = j; sy = i;\n                }\n                if(mas[i][j] == '<'){\n                    muki = 2; mas[i][j] = '.';\n                    sx = j; sy = i;\n                }\n                if(mas[i][j] == 'v'){\n                    muki = 3; mas[i][j] = '.';\n                    sx = j; sy = i;\n                }\n            }\n        }\n        cin >> len >> s;\n        P p = search();\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(i == p.first && j == p.second) cout << m[muki];\n                else cout << mas[i][j];\n            }\n            cout << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint main()\n{\n  int t;\n  cin>>t;\n  for(;t--;)\n    {\n      int h,w;\n      cin>>h>>w;\n      //      cout<<h<<\" \"<<w<<endl;\n      char map[h][w];\n      int x,y;\n      //      char move;     //^=0,>=1,v=2,<=3\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>map[i][j];\n\t    \n\t    if(map[i][j]=='^' ||map[i][j]=='>'\n\t       ||map[i][j]=='v'||map[i][j]=='<')\n\t      x=i,y=j;//move=map[i][j];\t    \n\t    \n\t  }\n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  char tmp;\n\t  cin>>tmp;\n\t  if(tmp=='U')\n\t    {\n\t      map[x][y]='^';\n\t      if(x>0&&map[x-1][y]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  x--;\n\t\t  map[x][y]='^';\n\t\t}\n\t    }\n\t  if(tmp=='D')\n\t    {\n\t      map[x][y]='v';\n\t      if(x<h-1&&map[x+1][y]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  x++;\n\t\t  map[x][y]='v';\n\t\t}\n\t    }\n\n\n\t  if(tmp=='L')\n\t    {\n\t      map[x][y]='<';\n\t      if(y>0&&map[x][y-1]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  y--;\n\t\t  map[x][y]='<';\n\t\t}\n\t    }\n\t  if(tmp=='R')\n\t    {\n\t      map[x][y]='>';\n\t      if(y<w-1&&map[x][y+1]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  y++;\n\t\t  map[x][y]='>';\n\t\t}\n\t    }\n\t  if(tmp=='S')\n\t    {\n\t      int dx=0,dy=0;\n\t      int tmpx=x,tmpy=y;\n\t      if(map[x][y]=='^')\n\t\tdx=-1;\n\t      else if(map[x][y]=='v')\n\t\tdx=1;\n\t      else if(map[x][y]=='<')\n\t\tdy=-1;\n\t      else\n\t\tdy=1;\n\t      while(tmpx<h&&tmpy<h)\n\t\t{\n\t\t  tmpx+=dx;\n\t\t  tmpy+=dy;\n\t\t  if(map[tmpx][tmpy]=='*')\n\t\t    {\n\t\t      map[tmpx][tmpy]='.';\n\t\t      break;\n\t\t    }\n\t\t  if(map[tmpx][tmpy]=='#')\n\t\t    {\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\t  \n\t}\n\t\n\t\n\tfor(int i=0;i<h;i++,cout<<endl)\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      cout<<map[i][j];\n\t    }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Town\n{\n  public:\n    Town(int height, int width);\n    ~Town();\n    void tank_up();\n    void tank_down();\n    void tank_left();\n    void tank_right();\n    void shoot();\n    void show();\n    \n  private:\n    char** m_map;\n    int m_height;\n    int m_width;\n    int m_tank_i;\n    int m_tank_j;\n    bool can_move(int height, int width);\n    bool inside_map(int height, int width);\n    bool is_flat(int height, int width);\n};\n\nTown::Town(int height, int width)\n{\n  m_height = height;\n  m_width = width;\n  m_map = new char*[m_height];\n  for (int i = 0; i < m_height; i++)\n  {\n    m_map[i] = new char[m_width];\n  }\n  for (int i = 0; i < m_height; i++)\n  {\n    for (int j = 0; j < m_width; j++)\n    {\n      cin >> m_map[i][j];\n      switch (m_map[i][j])\n      {\n        case '<':\n        case '>':\n        case '^':\n        case 'v':\n          m_tank_i = i;\n          m_tank_j = j;\n          break;\n      }\n    }\n  }\n}\n\nTown::~Town()\n{\n  for (int i = 0; i < m_height; i++)\n  {\n    delete[] m_map[i];\n  }\n  delete[] m_map;\n}\n\nbool Town::can_move(int height, int width)\n{\n  return inside_map(height, width) && is_flat(height, width);\n}\n\nbool Town::is_flat(int height, int width)\n{\n  return m_map[height][width] == '.';\n}\n\nbool Town::inside_map(int height, int width)\n{\n  return ( 0 <= height && height < m_height ) && ( 0 <= width && width < m_width );\n}\n\nvoid Town::tank_up()\n{\n  if ( can_move(m_tank_i-1, m_tank_j) )\n  {\n    m_map[m_tank_i][m_tank_j] = '.';\n    m_tank_i--;\n  }\n  m_map[m_tank_i][m_tank_j] = '^';\n}\n\nvoid Town::tank_down()\n{\n  if ( can_move(m_tank_i+1, m_tank_j) )\n  {\n    m_map[m_tank_i][m_tank_j] = '.';\n    m_tank_i++;\n  }\n  m_map[m_tank_i][m_tank_j] = 'v';\n}\n\nvoid Town::tank_left()\n{\n  if ( can_move(m_tank_i, m_tank_j-1) )\n  {\n    m_map[m_tank_i][m_tank_j] = '.';\n    m_tank_j--;\n  }\n  m_map[m_tank_i][m_tank_j] = '<';\n}\n\nvoid Town::tank_right()\n{\n  if ( can_move(m_tank_i, m_tank_j+1) )\n  {\n    m_map[m_tank_i][m_tank_j] = '.';\n    m_tank_j++;\n  }\n  m_map[m_tank_i][m_tank_j] = '>';\n}\n\nvoid Town::shoot()\n{\n  int plus = 1;\n  switch (m_map[m_tank_i][m_tank_j])\n  {\n    case '^':\n      plus = -1;\n    case 'v':\n      for (int i = m_tank_i+ plus ; inside_map(i, m_tank_j); i += plus)\n      {\n        if ( m_map[i][m_tank_j] == '#' )\n        {\n          break;\n        }\n        else if ( m_map[i][m_tank_j] == '*' )\n        {\n          m_map[i][m_tank_j] = '.';\n          break;\n        }\n      }\n      break;\n    case '<':\n      plus = -1;\n    case '>':\n      for (int j = m_tank_j+ plus ; inside_map(m_tank_i, j); j += plus)\n      {\n        if ( m_map[m_tank_i][j] == '#' )\n        {\n          break;\n        }\n        else if ( m_map[m_tank_i][j] == '*' )\n        {\n          m_map[m_tank_i][j] = '.';\n          break;\n        }\n      }\n      break;\n  }\n}\n\nvoid Town::show()\n{\n  for (int i = 0; i < m_height; i++)\n  {\n    for (int j = 0; j < m_width; j++)\n    {\n      cout << m_map[i][j];\n    }\n    cout << endl;\n  }\n}\n\nint main(void)\n{\n  int t;\n  cin >> t;\n  for (int dataset = 0; dataset < t; dataset++)\n  {\n    int height, width;\n    cin >> height >> width;\n    Town town(height, width);\n\n    int n;\n    cin >> n;\n    for (int k = 0; k < n; k++)\n    {\n      char command;\n      cin >> command;\n      switch (command)\n      {\n        case 'U':\n          town.tank_up();\n          break;\n        case 'D':\n          town.tank_down();\n          break;\n        case 'L':\n          town.tank_left();\n          break;\n        case 'R':\n          town.tank_right();\n          break;\n        case 'S':\n          town.shoot();\n          break;\n      }\n    }\n    town.show();\n    if ( dataset != t - 1 ) cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin(); it!=(c).end(); it++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define pr(a) cout << (a) << endl\n#define PR(a,b) cout << (a) << \" \" << (b) << endl;\n#define F first\n#define S second\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int MAX=1000000001;\nconst ll MAXL=1000000000000000001LL;\nconst ll mod=1000000007;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint n,m;\nbool check(int x,int y) {\n  if(x<0 || x>=n) return false;\n  if(y<0 || y>=m) return false;\n  return true;\n}\n\nint news(char c) {\n  if(c=='U' || c=='^') return 0;\n  else if(c=='D' || c=='v') return 2;\n  else if(c=='L' || c=='<') return 1;\n  else return 3;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  rep(r,T) {\n    if(r) cout << endl;\n    cin >> n >> m;\n    string s[n];\n    P now;\n    int k;\n    rep(i,n) {\n      cin >> s[i];\n      rep(j,m) {\n\tif(s[i][j]=='v' || s[i][j]=='^' || s[i][j]=='<' || s[i][j]=='>') {\n\t  k=news(s[i][j]);\n\t  now.F=i;\n\t  now.S=j;\n\t  s[i][j]='.';\n\t}\n      }\n    }\n    int l;\n    cin >> l;\n    string t;\n    cin >> t;\n    rep(i,t.size()) {\n      if(t[i]=='S') {\n\tint x=now.F+dx[k],y=now.S+dy[k];\n\twhile(1) {\n\t  if(!check(x,y) || s[x][y]=='#') break;\n\t  if(s[x][y]=='*') {\n\t    s[x][y]='.';\n\t    break;\n\t  }\n\t  x+=dx[k];\n\t  y+=dy[k];\n\t}\t\t\t\t\t\t   \n      } else {\n\tk=news(t[i]);\n\tint x=now.F+dx[k],y=now.S+dy[k];\n\tif(check(x,y) && s[x][y]=='.') {\n\t  now.F=x;\n\t  now.S=y;\n\t}\n      }\n    }\n    rep(i,n) {\n      rep(j,m) {\n\tif(i==now.F && j==now.S) {\n\t  if(k==1) cout << '<';\n\t  else if(k==0) cout << '^';\n\t  else if(k==3) cout << '>';\n\t  else cout << 'v';\n\t} else cout << s[i][j];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[20][21], t[4]={'^','>','v','<'};\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\t//ã0 E1 º2 ¶3\nint T, H, W, N;\nstruct {int x, y, a;} p;\t//íÔÌ éÀW,íÔÌü«\nvoid shoot(int x, int y, int a)\n{\n\twhile (0 <= x+dx[a] && x+dx[a] < W && 0 <= y+dy[a] && y+dy[a] < H)\n\t{\n\t\tx+=dx[a], y+=dy[a];\n\t\tif (m[y][x]=='*')\n\t\t{\n\t\t\tm[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t\telse if (m[y][x]=='#')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar o[101]=\"\";\n\tint i, j, nx, ny;\n\tcin >> T;\n\tfor (; T > 0; T--)\n\t{\n\t\tcin >> H >> W;\n\t\tfor (i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tswitch (m[i][j])\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t\tp.x=j, p.y=i, p.a=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tp.x=j, p.y=i, p.a=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tp.x=j, p.y=i, p.a=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tp.x=j, p.y=i, p.a=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[i][j]='\\0';\n\t\t}\n\t\tcin >> N >> o;\n\t\tif (T > 1)\n\t\t\tcout << endl;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tswitch (o[i])\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\tp.a=0;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tp.a=2;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tp.a=3;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tp.a=1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshoot(p.x, p.y, p.a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx=p.x+dx[p.a], ny=p.y+dy[p.a];\n\t\t\tif (o[i] != 'S')\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\tif (0 <= nx && nx < W && 0 <= ny && ny < H && m[ny][nx]=='.')\n\t\t\t{\n\t\t\t\tm[p.y][p.x]='.';\n\t\t\t\tp.x=nx, p.y=ny;\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < H; i++)\n\t\t\tcout << m[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[4]={-1,0,0,1},dy[4]={0,-1,1,0};\nunordered_map<char,int>U;\nint main(){\n    U['D']=3;\n    U['L']=1;\n    U['R']=2;\n    int a;cin>>a;\n    for(int b=0;b<a;b++){\n\tif(b)puts(\"\");\n\tint c,d;cin>>c>>d;\n\tstring f[20];\n\tint x=0,y=0,z=0;\n\tfor(int e=0;e<c;e++){\n\t    cin>>e[f];\n\t    for(int g=0;g<d;g++){\n\t\tif(e[f][g]=='^'){x=e,y=g;z=0;e[f][g]='.';}\n\t\telse if(e[f][g]=='v'){x=e,y=g;z=3;e[f][g]='.';}\n\t\telse if(e[f][g]=='<'){x=e,y=g;z=1;e[f][g]='.';}\n\t\telse if(e[f][g]=='>'){x=e,y=g;z=2;e[f][g]='.';}\n\t\t}\n\t    }  \n\tint n;string S;\n\tcin>>n>>S;\n\tfor(char i:S){\n\t    if(i=='S'){\n\t\tfor(int k=1;x+dx[z]*k>=0&&x+dx[z]*k<c&&y+dy[z]*k>=0&&y+dy[z]*k<d;k++){\n\t\t    if(f[x+dx[z]*k][y+dy[z]*k]=='*'){f[x+dx[z]*k][y+dy[z]*k]='.';break;}\n\t\t    if(f[x+dx[z]*k][y+dy[z]*k]=='#')break;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t    z=U[i];\n\t    if(x+dx[z]>=0&&x+dx[z]<c&&y+dy[z]>=0&&y+dy[z]<d&&f[x+dx[z]][y+dy[z]]=='.'){x+=dx[z];y+=dy[z];}\n\t    }\n\tswitch(z){\n\t    case 0:f[x][y]='^';break;\n\t    case 1:f[x][y]='<';break;\n\t    case 2:f[x][y]='>';break;\n\t    case 3:f[x][y]='v';break;\n\t    }\n\t for(int Q=0;Q<c;Q++)cout<<f[Q]<<endl;   \n\t}\n    }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint h, w;\nchar f[21][21];\npoint now;\nint nowdir;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nchar car[5]=\">^<v\";\n\nvoid move(char c){\n\t//????????¢???\n\tif(c=='R') nowdir=0;\n\telse if(c=='U') nowdir=1;\n\telse if(c=='L') nowdir=2;\n\telse if(c=='D') nowdir=3;\n\t\n\t//?¬????????????´???\n\tint nx=now.x+dx[nowdir];\n\tint ny=now.y+dy[nowdir];\n\t\n\t//?§?????????????????§????\n\tif(0<=nx && nx<w && 0<=ny && ny<h && f[ny][nx]=='.'){\n\t\tf[ny][nx]=car[nowdir];\n\t\tf[now.y][now.x]='.';\n\t\tnow.x=nx;\n\t\tnow.y=ny;\n\t}\n}\n\nvoid printField(){\n\tfor(int i=0; i<h; ++i){\n\t\tfor(int j=0; j<w; ++j){\n\t\t\tprintf(\"%c\", f[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\t\n}\n\nvoid shoot(){\n\tint t=1; //???????????????\n\n\twhile(1){\n\t\tint nx=t*dx[nowdir]+now.x;\t\n\t\tint ny=t*dy[nowdir]+now.y;\n\t\t\n\t\tif(nx<0 || w<=nx || ny<0 || h<=ny) break;\n\t\t\n\t\tif(f[ny][nx]=='*'){\n\t\t\tf[ny][nx]='.';\n\t\t\tbreak;\t\n\t\t}\n\t\telse if(f[ny][nx]=='#') break;\t\n\t\t\t\n\t\tt++;\t\t\t\n\t}\n}\n\nint main(){\t\n\tint times;\n\tcin >> times;\n\tfor(int t=0; t<times; ++t){\n\t\tif(t!=0) printf(\"\\n\");\n\t\t\n\t\tscanf(\" %d %d\", &h, &w);\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\tfor(int j=0; j<w; ++j){\n\t\t\t\tscanf(\" %c\", &f[i][j]);\n\t\t\t\t\n\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\tif(f[i][j]==car[k]){\t\n\t\t\t\t\t\tnowdir=k;\n\t\t\t\t\t\tnow.x=j;\n\t\t\t\t\t\tnow.y=i;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n;\n\t\tstring order;\n\t\tscanf(\" %d\", &n);\n\t\tcin >> order;\n\t\t\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(order[i]=='S') shoot();\n\t\t\telse move(order[i]);\n\t\t\t/*\n\t\t\tprintf(\"nowdir=%d\\n\", nowdir);\n\t\t\tprintField();\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t}\n\t\t\n\t\tprintField();\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint dx[] = {0,0,-1,1};\nint dy[] = {1,-1,0,0};\n\nint direction(char c) {\n\tint dir;\n\tif(c == '^')\n\t\tdir = 1;\n\telse if(c == 'v')\n\t\tdir = 0;\n\telse if(c == '>')\n\t\tdir = 3;\n\telse\n\t\tdir = 2;\n\treturn dir;\n}\n\nint main() {\n\tint T;\n\tcin >> T;\n\tfor(int t = 0; t < T; t++) {\n\t\tint H, W, N;\n\t\tvector<string> board;\n\t\tstring command;\n\t\tcin >> H >> W;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tboard.push_back(s);\n\t\t}\n\t\tcin >> N >> command;\n\t\tchar c;\n\t\tint x, y;\n\n\t\tfor(int i = 0; i < board.size(); i++) {\n\t\t\tfor(int j = 0; j < board[i].size(); j++) {\n\t\t\t\tc = board[i][j];\n\t\t\t\tif(c == '^' || c == 'v' || c == '>' || c == '<') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<string> res = board;\n\t\tfor(int i = 0; i < command.size(); i++) {\n\t\t\tif(command[i] == 'S') {\n\t\t\t\tint dir = direction(res[y][x]);\n\t\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\t\twhile(0 <= nx && nx < W && 0 <= ny && ny < H) {\n\t\t\t\t\tif(res[ny][nx] == '*') {\n\t\t\t\t\t\tres[ny][nx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(res[ny][nx] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnx += dx[dir];\n\t\t\t\t\tny += dy[dir];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint c = command[i];\n\t\t\t\tif(c == 'U') {\n\t\t\t\t\tif(y > 0 && res[y-1][x] == '.') {\n\t\t\t\t\t\tres[y][x] = '.';\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\tres[y][x] = '^';\n\t\t\t\t}\n\t\t\t\telse if(c == 'D') {\n\t\t\t\t\tif(y < H-1 && res[y+1][x] == '.') {\n\t\t\t\t\t\tres[y][x] = '.';\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\tres[y][x] = 'v';\n\t\t\t\t}\n\t\t\t\telse if(c == 'R') {\n\t\t\t\t\tif(x < W-1 && res[y][x+1] == '.') {\n\t\t\t\t\t\tres[y][x] = '.';\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tres[y][x] = '>';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(x > 0 && res[y][x-1] == '.') {\n\t\t\t\t\t\tres[y][x] = '.';\n\t\t\t\t\t\tx--;\n\t\t\t\t\t}\n\t\t\t\t\tres[y][x] = '<';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(t) cout << endl;\n\t\tfor(int i = 0; i < res.size(); i++)\n\t\t\tcout << res[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint dir[][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\nchar tank[] = {'>','<','v','^'};\n\nchar map[20][20],tx,ty,td;\n\nint getdir(char c){\n  switch(c) {\n  case 'U': return 3;\n  case 'D': return 2;\n  case 'L': return 1;\n  case 'R': return 0;\n  }\n}\n\nint main(){\n  int t;\n  scanf(\"%d\",&t);\n\n  for(;t--;){\n    int h,w;\n    scanf(\"%d %d\\n\",&h,&w);\n\n    for(int y=0; y<h; y++){\n      for(int x=0; x<w; x++){\n\tmap[x][y] = getchar();\n\tswitch(map[x][y]){\n\tcase '>': tx=x; ty=y; td=0; break;\n\tcase '<': tx=x; ty=y; td=1; break;\n\tcase 'v': tx=x; ty=y; td=2; break;\n\tcase '^': tx=x; ty=y; td=3; break;\n\t}\n      }\n      getchar(); \n    }\n\n    int n;\n    scanf(\"%d\\n\",&n);\n\n    for(;n--;){\n      int x,y,op = getchar();\n      if(op=='S'){\n\tint dx=dir[td][0],dy=dir[td][1];\n\tfor(x=tx+dx,y=ty+dy;;x+=dx,y+=dy){\n\t  if(x<0 || x>=w || y<0 || y>=h)\n\t     break;\n\t  else\n\t    switch(map[x][y]){\n\t    case '.' : \n\t    case '_' : break;\n\t    case '*' : map[x][y]='.';\n\t    case '#' : goto outer;\n\t    }\n\t}\n      }else{\n\ttd = getdir(op);\n\tx = tx+dir[td][0]; y = ty+dir[td][1];\n\tmap[tx][ty] = '.';\n\tif(x>=0 && x<w && y>=0 && y<h && map[x][y]=='.'){\n\t  tx = x; ty = y;\n\t} \n\tmap[tx][ty] = tank[td];\n      }\n    outer: ;\n    }\n\n    for(int y=0; y<h; y++){\n      for(int x=0; x<w; x++)\n\tputchar(map[x][y]);\n      putchar('\\n');\n    }\n    if(t!=0) putchar('\\n');\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n \nusing namespace std;\n \ntypedef pair<int,int> P;\nconst int MAX = 20;\nP pos;\nchar m[MAX][MAX];\nint r,c;\n \nvoid input(){\n  for(int i = 0; i < r; i++)\n    for(int j = 0; j < c; j++){\n      cin >> m[i][j];\n      if(m[i][j] == '<' || m[i][j] == '>' ||\n     m[i][j] == '^' || m[i][j] == 'v') pos = P(i,j);\n    }\n}\n \nbool inside(P p){\n  return (0 <= p.first && p.first < r && 0 <= p.second && p.second < c);\n}\n \nvoid shoot(char c){\n \n  int x = 0, y = 0;\n  P p = pos;\n  if(c == '^') y = -1;\n  if(c == 'v') y = 1;\n  if(c == '>') x = 1;\n  if(c == '<') x = -1;\n \n  while(1){\n    p.first += y;\n    p.second += x;\n    if(!inside(p)) break;\n    if(m[p.first][p.second] == '#') break;\n    if(m[p.first][p.second] == '*'){\n      m[p.first][p.second] = '.';\n      break;\n    }\n  }\n}\n \nvoid move(char c, int x, int y){\n  if(inside(P(pos.first+y,pos.second+x)) && m[pos.first+y][pos.second+x] == '.'){\n    m[pos.first][pos.second] = '.';\n    m[pos.first+y][pos.second+x] = c;\n    pos.first += y;\n    pos.second += x;\n  }else{\n    m[pos.first][pos.second] = c;\n  }\n}\n \nint main(){\n  bool flag = false;\n  int X;\n  cin >> X;\n  while(X--){\n    if(flag) cout << endl;\n    flag = true;\n \n    cin >> r >> c;\n    input();\n    int num;\n    cin >> num;\n    for(int i = 0; i < num; i++){\n      char c;\n      cin >> c;\n      if(c == 'S') shoot(m[pos.first][pos.second]);\n      if(c == 'U') move('^',0,-1);\n      if(c == 'D') move('v',0,1);\n      if(c == 'L') move('<',-1,0);\n      if(c == 'R') move('>',1,0);\n    }\n \n    for(int i = 0; i < r; i++){\n      for(int j = 0; j < c; j++)\n    cout << m[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint dir[][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\nchar tank[] = {'>','<','v','^'};\n\nchar map[20][20],tx,ty,td;\n\nint getdir(char c){\n  switch(c) {\n  case 'U': return 3;\n  case 'D': return 2;\n  case 'L': return 1;\n  case 'R': return 0;\n  }\n}\n\nint main(){\n  int t;\n  scanf(\"%d\",&t);\n\n  for(;t--;){\n    int h,w;\n    scanf(\"%d %d\\n\",&h,&w);\n\n    for(int y=0; y<h; y++){\n      for(int x=0; x<w; x++){\n\tmap[x][y] = getchar();\n\tswitch(map[x][y]){\n\tcase '>': tx=x; ty=y; td=0; break;\n\tcase '<': tx=x; ty=y; td=1; break;\n\tcase 'v': tx=x; ty=y; td=2; break;\n\tcase '^': tx=x; ty=y; td=3; break;\n\t}\n      }\n      getchar(); \n    }\n\n    int n;\n    scanf(\"%d\\n\",&n);\n\n    for(;n--;){\n      int x,y,op = getchar();\n      if(op=='S'){\n\tint dx=dir[td][0],dy=dir[td][1];\n\tfor(x=tx+dx,y=ty+dy;;x+=dx,y+=dy){\n\t  if(x<0 || x>=w || y<0 || y>=h)\n\t     break;\n\t  else\n\t    switch(map[x][y]){\n\t    case '.' : \n\t    case '_' : break;\n\t    case '*' : map[x][y]='.';\n\t    case '#' : goto outer;\n\t    }\n\t}\n      }else{\n\ttd = getdir(op);\n\tx = tx+dir[td][0]; y = ty+dir[td][1];\n\tmap[tx][ty] = '.';\n\tif(x>=0 && x<w && y>=0 && y<h && map[x][y]=='.'){\n\t  tx = x; ty = y;\n\t} \n\tmap[tx][ty] = tank[td];\n      }\n    outer: ;\n    }\n\n    for(int y=0; y<h; y++){\n      for(int x=0; x<w; x++)\n\tputchar(map[x][y]);\n      putchar('\\n');\n    }\n    putchar('\\n');\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint main(void){\n\tint T;\n\tcin>>T;\n\tfor(int i=0,H,W,N;i<T;++i){\n\t\tif(i!=0)cout<<endl;\n\t\tchar field[21][21];\n\t\tint x,y,a;\n\t\tcin>>H>>W;\n\t\tfor(int j=0;j<H;++j){\n\t\t\tscanf(\"%s\",field[j]);\n\t\t\tfor(int k=0;k<W;++k)\n\t\t\t\tif(field[j][k]=='^'||field[j][k]=='v'||field[j][k]=='<'||field[j][k]=='>')\n\t\t\t\t\t{\n\t\t\t\t\t\tx=k;y=j;\n\t\t\t\t\t\tif(field[j][k]=='^') a=0;\n\t\t\t\t\t\telse if(field[j][k]=='v') a=1;\n\t\t\t\t\t\telse if(field[j][k]=='<') a=2;\n\t\t\t\t\t\telse if(field[j][k]=='>') a=3;\n\t\t\t\t\t}\n\t\t}\n\t\tstring s;cin>>N;\n\t\tcin>>s;\n\t\tfor(int j=0;j<s.size();++j){\n\t\t\tint nx[]={0,0,-1,1},ny[]={-1,1,0,0};//UDLR\n\t\t\tchar pos[]={'^','v','<','>'};\n\t\t\tif(s[j]=='U'||s[j]=='D'||s[j]=='L'||s[j]=='R'){\n\t\t\t\tif(s[j]=='U') a=0;\n\t\t\t\telse if(s[j]=='D') a=1;\n\t\t\t\telse if(s[j]=='L') a=2;\n\t\t\t\telse if(s[j]=='R') a=3;\n\t\t\t\tif(0<=x+nx[a] && x+nx[a]<W && 0<=y+ny[a] && y+ny[a]<H){\n\t\t\t\t\tif(field[y+ny[a]][x+nx[a]]=='.'){\n\t\t\t\t\t\tfield[y][x]='.';\n\t\t\t\t\t\tx+=nx[a];y+=ny[a];\n\t\t\t\t\t\tfield[y][x]=pos[a];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(s[j]=='S'){\n\t\t\t\tint sx=x+nx[a],sy=y+ny[a];\n\t\t\t\twhile(0<=sx && 0<=sy && sx<W && sy<H){\n\t\t\t\t\tif(field[sy][sx]=='#') break;\n\t\t\t\t\tif(field[sy][sx]=='*'){\n\t\t\t\t\t\tfield[sy][sx]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsx+=nx[a];sy+=ny[a];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<H;++j){\n\t\t\tprintf(\"%s\\n\",field[j]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n \nusing namespace std;\n \ntypedef pair<int,int> P;\nconst int MAX = 20;\nP pos;\nchar m[MAX][MAX];\nint r,c;\nvoid input(){\n  for(int i = 0; i < r; i++)\n    for(int j = 0; j < c; j++){\n      cin >> m[i][j];\n      if(m[i][j] == '<' || m[i][j] == '>' ||\n     m[i][j] == '^' || m[i][j] == 'v') pos = P(i,j);\n    }\n   \n}\n \nbool inside(P p){\n  return (0 <= p.first && p.first < r && 0 <= p.second && p.second < c);\n}\n \nvoid shoot(char c){\n \n  int x = 0, y = 0;\n  P p = pos;\n  if(c == '^') y = -1;\n  if(c == 'v') y = 1;\n  if(c == '>') x = 1;\n  if(c == '<') x = -1;\n \n  while(1){\n    p.first += y;\n    p.second += x;\n    if(!inside(p)) break;\n    if(m[p.first][p.second] == '#') break;\n    if(m[p.first][p.second] == '*'){\n      m[p.first][p.second] = '.';\n      break;\n    }\n  }\n}\n \n \nvoid move(char c, int x, int y){\n  if(0 <= pos.first+y && pos.first+y < r &&\n     0 <= pos.second+x && pos.second+x < c &&\n     m[pos.first+y][pos.second+x] == '.'){\n    m[pos.first][pos.second] = '.';\n    m[pos.first+y][pos.second+x] = c;\n    pos.first += y;\n    pos.second += x;\n  }else{\n    m[pos.first][pos.second] = c;\n  }\n}\n \nint main(){\n  bool flag = false;\n  int X;\n  cin >> X;\n  while(X--){\n    if(flag) cout << endl;\n    flag = true;\n \n    cin >> r >> c;\n    input();\n    int num;\n    cin >> num;\n    for(int i = 0; i < num; i++){\n      char c;\n      cin >> c;\n      if(c == 'S') shoot(m[pos.first][pos.second]);\n      if(c == 'U') move('^',0,-1);\n      if(c == 'D') move('v',0,1);\n      if(c == 'L') move('<',-1,0);\n      if(c == 'R') move('>',1,0);\n    }\n \n    for(int i = 0; i < r; i++){\n      for(int j = 0; j < c; j++)\n    cout << m[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<cstring>\n#include<iostream>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> pin;\ntypedef std::pair<int,std::pair<int, int> > ppin;\n\nusing namespace std;\n\nchar ma[22][22];\n\nint main(){\n    \n    int n;\n    cin>>n;\n    while(n--){\n        int a,b;\n        cin>>a>>b;\n        int x=0,y=0,d=0;\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cin>>ma[i][j];\n                if(ma[i][j]=='^'){\n                    y=i; x=j; d=0;\n                }\n                if(ma[i][j]=='v'){\n                    y=i; x=j; d=1;\n                }\n                if(ma[i][j]=='<'){\n                    y=i; x=j; d=2;\n                }\n                if(ma[i][j]=='>'){\n                    y=i; x=j; d=3;\n                }\n            }\n        }\n        \n        int str;\n        cin>>str;\n        string s;\n        cin>>s;\n        for(int k=0;k<s.length();k++){\n            switch(s[k]){\n                case 'U':\n                    \n                    d=0;\n                    if(ma[y-1][x]!='.'||y==0)\n                        continue;\n                    y--;\n                    ma[y+1][x]='.';\n                    ma[y][x]='^';\n                    break;\n                case 'D':\n                    d=1;\n                    if(ma[y+1][x]!='.'||y+1==a)\n                        continue;\n                    \n                    y++;\n                    ma[y-1][x]='.';\n                    ma[y][x]='v';\n                    break;\n                case 'L':\n                    d=2;\n                    if(ma[y][x-1]!='.'||x==0)\n                        continue;\n                    \n                    x--;\n                    ma[y][x+1]='.';\n                    ma[y][x]='<';\n                    break;\n                case 'R':\n                    d=3;\n                    if(ma[y][x+1]!='.'||x+1==b)\n                        continue;\n                    \n                    x++;\n                    ma[y][x-1]='.';\n                    ma[y][x]='>';\n                    break;\n                case 'S':\n                    switch(d){\n                        case 0:\n                            for(int i=y-1;i>=0;i--){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 1:\n                            for(int i=y+1;i<a;i++){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 2:\n                            for(int i=x-1;i>=0;i--){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 3:\n                            for(int i=x+1;i<b;i++){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                    }\n//                    for(int i=0;i<a;i++){\n//                        for(int j=0;j<b;j++){\n//                            cout<<ma[i][j];\n//                        }\n//                        cout<<endl;\n//                    }\n//                    cout<<endl;\n                    break;\n            }\n        }\n        switch(d){\n            case 0:\n                ma[y][x]='^';\n                break;\n            case 1:\n                ma[y][x]='v';\n                break;\n            case 2:\n                ma[y][x]='<';\n                break;\n            case 3:\n                ma[y][x]='>';\n                break;\n        }\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cout<<ma[i][j];\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,1,0,0,1,-1,1,-1};\nconst int dx[] = {0,0,-1,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nconst string Dir = \"UDLR^v<>\";\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t;\n  cin >> t;\n  rep(z,t){\n    if(z) cout << endl;\n    ll h,w,x,y,dir;\n    cin >> h >> w;\n    vector<vector<char>> v(h,vector<char>(w));\n    rep(i,h){\n      rep(j,w){\n        cin >> v[i][j];\n        if(v[i][j] == '^'){\n          dir = 0;\n          x = j,y = i;\n        }\n        if(v[i][j] == 'v'){\n          dir = 1;\n          x = j,y = i;\n        }\n        if(v[i][j] == '<'){\n          dir = 2;\n          x = j,y = i;\n        }\n        if(v[i][j] == '>'){\n          dir = 3;\n          x = j,y = i;\n        }\n      }\n    }\n    ll n;\n    cin >> n;\n    string s;\n    cin >> s;\n    rep(i,n){\n      if(s[i] != 'S'){\n        rep(j,4){\n          if(s[i] == Dir[j]){\n            dir = j;\n            break;\n          }\n        }\n        ll nx = x + dx[dir],ny = y+dy[dir];\n        if(value(nx,ny,w,h)){\n          if(v[ny][nx] == '.'){\n            v[y][x] = '.';\n            x = nx,y = ny;\n            v[ny][nx] = Dir[dir+4];\n          }\n          else{\n            v[y][x] = Dir[dir+4];\n          }\n        }\n      }\n      else{\n        ll nx = x,ny = y;\n        while(1){\n          nx += dx[dir],ny += dy[dir];\n          if(!value(nx,ny,w,h)) break;\n          if(v[ny][nx] == '*'){\n            v[ny][nx] = '.';\n            break;\n          }\n          if(v[ny][nx] == '#'){\n            break;\n          }\n        }\n      }\n    }\n    rep(i,h){\n      rep(j,w){\n        cout << v[i][j] ;\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint h,w;\npair<pii,int> foo1(vector<string> &v){\n\tstring vec=\">v<^\";\n\trep(i,v.size()){\n\t\trep(j,v[i].size()){\n\t\t\trep(k,4){\n\t\t\t\tif(v[i][j]==vec[k]){\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t\treturn mkp(pii(i,j),k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mkp(pii(-1,-1),-1);\n}\nbool check(int a,int b){\n\tif(0<=a&&a<h&&0<=b&&b<w) return true;\n\treturn false;\n}\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\trep(o,n){\n\t\tcin>>h>>w;\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tstring s;\n\t\tint t;\n\t\tcin>>t>>s;\n\t\tint dd[]={0,1,0,-1,0};// >,v,<,^\n\t\tpair<pii,int> pos=foo1(v);\n\t\tstring DRUL=\"RDLU\";\n\t\t//SRSSRRUSSR\n\t\trep(i,s.size()){\n\t\t\t// cout<<pos.F.F<<\" \"<<pos.F.S<<\" \"<<pos.S<<endl;\n\t\t\t// rep(j,h) cout<<v[j]<<endl;\n\t\t\t// cout<<endl;\n\t\t\tif(s[i]=='S'){\n\t\t\t\tint y=pos.F.F;\n\t\t\t\tint x=pos.F.S;\n\t\t\t\ty+=dd[pos.S];\n\t\t\t\tx+=dd[pos.S+1];\n\t\t\t\twhile(check(y,x)){\n\t\t\t\t\tif(v[y][x]=='#') break;\n\t\t\t\t\tif(v[y][x]=='*'){\n\t\t\t\t\t\tv[y][x]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ty+=dd[pos.S];\n\t\t\t\t\tx+=dd[pos.S+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(j,4){\n\t\t\t\t\tif(\"RDLU\"[j]==s[i]){\n\t\t\t\t\t\tpos.S=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ny=pos.F.F+dd[pos.S];\n\t\t\t\tint nx=pos.F.S+dd[pos.S+1];\n\t\t\t\tif(check(ny,nx)&&v[ny][nx]=='.'){\n\t\t\t\t\tpos.F=pii(ny,nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv[pos.F.F][pos.F.S]=\">v<^\"[pos.S];\n\t\trep(i,h){\n\t\t\tcout<<v[i]<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(0);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<cstring>\n#include<iostream>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> pin;\ntypedef std::pair<int,std::pair<int, int> > ppin;\n\nusing namespace std;\n\nchar ma[22][22];\n\nint main(){\n    \n    int n;\n    cin>>n;\n    while(n--){\n        int a,b;\n        cin>>a>>b;\n        int x=0,y=0,d=0;\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cin>>ma[i][j];\n                if(ma[i][j]=='^'){\n                    y=i; x=j; d=0;\n                }\n                if(ma[i][j]=='v'){\n                    y=i; x=j; d=1;\n                }\n                if(ma[i][j]=='<'){\n                    y=i; x=j; d=2;\n                }\n                if(ma[i][j]=='>'){\n                    y=i; x=j; d=3;\n                }\n            }\n        }\n        \n        int str;\n        cin>>str;\n        string s;\n        cin>>s;\n        for(int k=0;k<s.length();k++){\n            switch(s[k]){\n                case 'U':\n                    \n                    d=0;\n                    if(ma[y-1][x]!='.'||y==0)\n                        continue;\n                    y--;\n                    ma[y+1][x]='.';\n                    ma[y][x]='^';\n                    break;\n                case 'D':\n                    d=1;\n                    if(ma[y+1][x]!='.'||y+1==a)\n                        continue;\n                    \n                    y++;\n                    ma[y-1][x]='.';\n                    ma[y][x]='v';\n                    break;\n                case 'L':\n                    d=2;\n                    if(ma[y][x-1]!='.'||x==0)\n                        continue;\n                    \n                    x--;\n                    ma[y][x+1]='.';\n                    ma[y][x]='<';\n                    break;\n                case 'R':\n                    d=3;\n                    if(ma[y][x+1]!='.'||x+1==b)\n                        continue;\n                    \n                    x++;\n                    ma[y][x-1]='.';\n                    ma[y][x]='>';\n                    break;\n                case 'S':\n                    switch(d){\n                        case 0:\n                            for(int i=y-1;i>=0;i--){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 1:\n                            for(int i=y+1;i<a;i++){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 2:\n                            for(int i=x-1;i>=0;i--){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 3:\n                            for(int i=x+1;i<b;i++){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                    }\n//                    for(int i=0;i<a;i++){\n//                        for(int j=0;j<b;j++){\n//                            cout<<ma[i][j];\n//                        }\n//                        cout<<endl;\n//                    }\n//                    cout<<endl;\n                    break;\n            }\n        }\n        switch(d){\n            case 0:\n                ma[y][x]='^';\n                break;\n            case 1:\n                ma[y][x]='v';\n                break;\n            case 2:\n                ma[y][x]='<';\n                break;\n            case 3:\n                ma[y][x]='>';\n                break;\n        }\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cout<<ma[i][j];\n            }\n            if(n>0||i<a-1)cout<<endl;\n        }\n        if(n>1)cout<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nchar town[21][21];\npair<int, int> p;\n\n// ú»\nvoid initTown(int h, int w){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\ttown[i][j] = '#';\n\t\t}\n\t}\n}\n\n// eÌÊ\nvoid shoot(int y, int x, int direction){\n\tif(town[y][x] == '#'){\n\t\treturn;\n\t}\n\tif(town[y][x] == '*'){\n\t\ttown[y][x] = '.';\n\t\treturn;\n\t}\n\t\n\tif(y > 0 && direction == 0){\n\t\tshoot(y - 1, x, 0);\n\t}\n\telse if(direction == 1){\n\t\tshoot(y, x + 1, 1);\n\t}\n\telse if(direction == 2){\n\t\tshoot(y + 1, x, 2);\n\t}\n\telse if(x > 0 && direction == 3){\n\t\tshoot(y, x - 1, 3);\n\t}\n\t\n\treturn;\n}\n\n// íÔÌì\nvoid control(int n){\n\tchar cont;\n\tfor(; n > 0; --n){\n\t\tscanf(\" %c\", &cont);\n\t\tif(cont == 'U'){\n\t\t\tif(p.first > 0 && town[p.first - 1][p.second] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\n\t\t\t\ttown[p.first - 1][p.second] = '^';\n\t\t\t\tp.first--;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = '^';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'D'){\n\t\t\tif(town[p.first + 1][p.second] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\t\n\t\t\t\ttown[p.first + 1][p.second] = 'v';\n\t\t\t\tp.first++;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = 'v';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'L'){\n\t\t\tif(p.second > 0 && town[p.first][p.second - 1] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\n\t\t\t\ttown[p.first][p.second - 1] = '<';\n\t\t\t\tp.second--;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = '<';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'R'){\n\t\t\tif(town[p.first][p.second + 1] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\n\t\t\t\ttown[p.first][p.second + 1] = '>';\n\t\t\t\tp.second++;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = '>';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'S'){\n\t\t\tif(town[p.first][p.second] == '^'){\n\t\t\t\tshoot(p.first, p.second, 0);\n\t\t\t}\n\t\t\telse if(town[p.first][p.second] == '>'){\n\t\t\t\tshoot(p.first, p.second, 1);\n\t\t\t}\t\n\t\t\telse if(town[p.first][p.second] == 'v'){\n\t\t\t\tshoot(p.first, p.second, 2);\n\t\t\t}\n\t\t\telse if(town[p.first][p.second] == '<'){\n\t\t\t\tshoot(p.first, p.second, 3);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\nint main(){\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor(;t > 0; --t){\n\t\tint h,w;\n\t\tscanf(\"%d %d\", &h, &w);\n\t\tinitTown(21, 21);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", town[i]);\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(town[i][j] == '^' || town[i][j] == '<' || town[i][j] == '>' || town[i][j] == 'v'){\n\t\t\t\t\tp.first = i;\n\t\t\t\t\tp.second = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tcontrol(n);\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tprintf(\"%c\", town[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tif(n != 1){\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\nint h,w;\nbool check(pii a){\n    if(0<=a.F&&a.F<h&&0<=a.S&&a.S<w) return true;\n    return false;\n}\nvoid mainmain(){\n    int n;cin>>n;\n    rep(o,n){\n        cin>>h>>w;\n        vector<string> v(h);\n        rep(i,h) cin>>v[i];\n        string s;\n        cin>>s;\n        cin>>s;\n        // dump(s);\n        pii pos;\n        int dx[]={0,0,1,-1};\n        int dy[]={1,-1,0,0};\n        string vec=\"v^><\";\n        string vec2=\"DURL\";\n        rep(i,h){\n            rep(j,w){\n                if(v[i][j]=='<'||v[i][j]=='^'||v[i][j]=='>'||v[i][j]=='v') pos=pii(i,j);\n            }\n        }\n        // cout<<pos.F<<\" \"<<pos.S<<endl;\n        rep(i,s.size()){\n            // dump(s[i]);\n            // rep(j,h) cout<<v[j]<<endl;\n            // cout<<endl;\n            if(s[i]=='S'){\n                rep(j,4){\n                    if(v[pos.F][pos.S]==vec[j]){\n                        pii tmp=pos;\n                        while(check(tmp)){\n                            // cout<<tmp.F<<\" \"<<tmp.S<<endl;\n                            if(v[tmp.F][tmp.S]=='*'){\n                                v[tmp.F][tmp.S]='.';\n                                break;\n                            }\n                            if(v[tmp.F][tmp.S]=='#'){\n                                break;\n                            }\n                            tmp.F+=dy[j];\n                            tmp.S+=dx[j];\n                        }\n                        break;\n                    }\n                }\n            }\n            else{\n                pii npos=pos;\n                rep(j,4){\n                    if(s[i]==vec2[j]){\n                        v[pos.F][pos.S]=vec[j];\n                        npos.F+=dy[j];\n                        npos.S+=dx[j];\n                        if(check(npos)&&v[npos.F][npos.S]=='.'){\n                            v[npos.F][npos.S]=v[pos.F][pos.S];\n                            v[pos.F][pos.S]='.';\n                            pos=npos;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        if(o) cout<<endl;\n        rep(i,h){\n            cout<<v[i]<<endl;\n        }\n    }\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n      cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\n\nvoid printStage(char stage[20][20],int W,int H,int i,int n){\n\tfor(int y=0;y<H;y++){\n\t\tfor(int x=0;x<W;x++){\n\t\t\tprintf(\"%c\",stage[y][x]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tif(i != n-1) printf(\"\\n\");\n}\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint W,H;\n\t\t\tchar stage[20][20];\n\n\t\t\tscanf(\"%d %d\",&H,&W);\n\n\t\t\tint px,py;\n\t\t\tfor(int y=0;y<H;y++){\n\t\t\t\tchar buf[32];\n\t\t\t\tscanf(\"%s\",buf);\n\t\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\t\tstage[y][x] = buf[x];\n\t\t\t\t\tif(buf[x]=='>'\n\t\t\t\t\t\t|| buf[x]=='<'\n\t\t\t\t\t\t|| buf[x]=='^'\n\t\t\t\t\t\t|| buf[x]=='v'){\n\t\t\t\t\t\t\tpx = x;\n\t\t\t\t\t\t\tpy = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint com;\n\t\t\tchar buf[128];\n\t\t\tscanf(\"%d\",&com);\n\t\t\tscanf(\"%s\",buf);\n\t\t\tfor(int j=0;j<com;j++){\n\t\t\t\tswitch(buf[j]){\n\t\t\t\tcase 'U':\n\t\t\t\t\tstage[py][px] = '^';\n\t\t\t\t\tif(py -1 >= 0 && stage[py-1][px] == '.'){\n\t\t\t\t\t\tstage[py][px] = '.';\n\t\t\t\t\t\tstage[py-1][px] = '^';\n\t\t\t\t\t\tpy--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tstage[py][px] = 'v';\n\t\t\t\t\tif(py +1 < H && stage[py+1][px] == '.'){\n\t\t\t\t\t\tstage[py][px] = '.';\n\t\t\t\t\t\tstage[py+1][px] = 'v';\n\t\t\t\t\t\tpy++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tstage[py][px] = '<';\n\t\t\t\t\tif(px -1 >= 0 && stage[py][px-1] == '.'){\n\t\t\t\t\t\tstage[py][px] = '.';\n\t\t\t\t\t\tstage[py][px-1] = '<';\n\t\t\t\t\t\tpx--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tstage[py][px] = '>';\n\t\t\t\t\tif(px +1 < W && stage[py][px+1] == '.'){\n\t\t\t\t\t\tstage[py][px] = '.';\n\t\t\t\t\t\tstage[py][px+1] = '>';\n\t\t\t\t\t\tpx++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tswitch(stage[py][px]){\n\t\t\t\t\tcase '^':\n\t\t\t\t\t\tfor(int y=py;y>=0;y--){\n\t\t\t\t\t\t\tif(stage[y][px] == '#'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(stage[y][px] == '*'){\n\t\t\t\t\t\t\t\tstage[y][px] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tfor(int y=py;y<H;y++){\n\t\t\t\t\t\t\tif(stage[y][px] == '#'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(stage[y][px] == '*'){\n\t\t\t\t\t\t\t\tstage[y][px] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tfor(int x=px;x>=0;x--){\n\t\t\t\t\t\t\tif(stage[py][x] == '#'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(stage[py][x] == '*'){\n\t\t\t\t\t\t\t\tstage[py][x] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\tfor(int x=px;x<W;x++){\n\t\t\t\t\t\t\tif(stage[py][x] == '#'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(stage[py][x] == '*'){\n\t\t\t\t\t\t\t\tstage[py][x] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintStage(stage,W,H,i,n);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\ntypedef pair<int,pii>piii;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n///#include<sstream>\n///#include<cstring>\n///#include<stack>\n///#include<complex>\n\n\nconst int dx[]={0,0,-1,1};\nconst int dy[]={-1,1,0,0};\nstruct State{\n    int fld[20][20];\n    int H,W;\n    int y,x;\n    int dir;\n    void CTR(char c){\n        if(c=='S')Fire();\n        else Move(c);\n    }\n    void Move(char c){\n        if(c=='U')dir=0;\n        else if(c=='D')dir=1;\n        else if(c=='L')dir=2;\n        else if(c=='R')dir=3;\n\n        int ty=y+dy[dir];\n        int tx=x+dx[dir];\n        if(ty<0||ty>=H||tx<0||tx>=W)return;\n        if(fld[ty][tx]!=0)return;\n        fld[y][x]=0;\n        y=ty;x=tx;\n        fld[y][x]=-1;\n    }\n    void Fire(){\n        int ny=y,nx=x;\n        while(true){\n            ny+=dy[dir];\n            nx+=dx[dir];\n            if(ny<0||ny>=H||nx<0||nx>=W)break;\n            if(fld[ny][nx]==0||fld[ny][nx]==3)continue;\n            if(fld[ny][nx]==1){\n                fld[ny][nx]=0;\n                break;\n            }\n            if(fld[ny][nx]==2)break;\n        }\n    }\n};\n\nvoid solve(){\n    State state;\n    scanf(\"%d%d\",&state.H,&state.W);\n    rep(i,state.H){\n        char str[36];\n        scanf(\"%s\",str);\n        rep(j,state.W){\n            if(str[j]=='.')state.fld[i][j]=0;\n            else if(str[j]=='*')state.fld[i][j]=1;\n            else if(str[j]=='#')state.fld[i][j]=2;\n            else if(str[j]=='-')state.fld[i][j]=3;\n            else{\n                state.fld[i][j]=-1;\n                state.y=i;state.x=j;\n                if(str[j]=='^')state.dir=0;\n                else if(str[j]=='v')state.dir=1;\n                else if(str[j]=='<')state.dir=2;\n                else if(str[j]=='>')state.dir=3;\n            }\n        }\n    }\n\n    int len;\n    char opr[128];\n    scanf(\"%d%s\",&len,opr);\n\n    rep(i,len){\n        state.CTR(opr[i]);\n    }\n\n\n    char p[]=\"^v<>\",o[]=\".*#-\";\n    rep(i,state.H){\n        rep(j,state.W){\n            if(state.fld[i][j]==-1)printf(\"%c\",p[state.dir]);\n            else printf(\"%c\",o[state.fld[i][j]]);\n        }\n        puts(\"\");\n    }\n}\n\nint main(){\n    int N;\n    scanf(\"%d\",&N);\n    bool flag=false;\n    while(N--){\n        if(flag)puts(\"\");\n        else flag=true;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <string>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define dm(x) cerr << #x << \" = \" << x << endl;\nusing namespace std;\n\nchar map[20][21];\nint H,W,N;\n\nstruct po{\n  int x;\n  int y;\n  po operator+(po &p){\n    po t={x+p.x, y+p.y};\n    return t;\n  }\n  char &l(){return map[x][y];}\n  bool v(){return 0<=x && x<H && 0<=y && y<W;}\n  void d(){dm(x);dm(y);}\n};\n\npo mp(int x,int y){\n  po t={x, y};\n  return t;\n}\n\nint main()\n{\n  int T;\n  scanf(\"%d\", &T);\n  rep(datasetindex, T){\n    po p={0,0},d={0,0};\n    char c[101];\n    scanf(\"%d %d\", &H, &W);\n    rep(i,H) scanf(\"%s\", map[i]);\n    scanf(\"%d\", &N);\n    scanf(\"%s\", c);\n    //dm(H);dm(W);\n    rep(j,W) rep(i,H){\n      switch(map[i][j]){\n      case '^':p=mp(i,j);d=mp(-1,0);break;\n      case '>':p=mp(i,j);d=mp(0,1);break;\n      case 'v':p=mp(i,j);d=mp(1,0);break;\n      case '<':p=mp(i,j);d=mp(0,-1);break;\n      }\n    }\n    //rep(i,H) printf(\"%d : %s\\n\", i, map[i]);\n    //p.d();d.d();\n    rep(i,N){\n      //dm(c[i]);\n      switch(c[i]){\n      case 'S':{\n        po s=p;\n        do{s=s+d;}while(s.v() && s.l()!='*' && s.l()!='#');\n        if(s.v() && s.l()=='*')\n          s.l()='.';\n        break;\n      }\n      case 'U':\n        p.l()='.';\n        d=mp(-1,0);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='^';\n        break;\n      case 'R':\n        p.l()='.';\n        d=mp(0,1);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='>';\n        break;\n      case 'D':\n        p.l()='.';\n        d=mp(1,0);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='v';\n        break;\n      case 'L':\n        p.l()='.';\n        d=mp(0,-1);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='<';\n        break;\n      }\n      //rep(i,H) printf(\"%d : %s\\n\", i, map[i]);\n    }\n    rep(i,H) printf(\"%s\\n\",map[i]);\n    printf(\"\\n\");\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint main(){\n\n\tchar field[21][21];\n\tint h,w;\n\tint t;\n\tcin>>t;\n\tfor(int l = 0; l < t; l++){\n\t\tif(l!=0)\n\t\t\tcout<<endl;\n\t\tchar angle;\n\t\tcin>>h>>w;\n\t\tint sy,sx;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tswitch(field[i][j]){\n\t\t\t\tcase '^':\n\t\t\t\t\tangle='u';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tangle='d';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tangle='r';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tangle='l';\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint num;\n\t\tcin>>num;\n\t\tstring order;\n\t\tcin>>order;\n\t\tint cx=sx;\n\t\tint cy=sy;\n\t\tfor(int i = 0; i < order.size(); i++){\n\t\t\tchar o=order[i];\n\t\t\tif(o=='U'){\n\t\t\t\tangle='u';\n\t\t\t\tint ny=cy-1;\n\t\t\t\tint nx=cx;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='^';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='D'){\n\t\t\t\tangle='d';\n\t\t\t\tint ny=cy+1;\n\t\t\t\tint nx=cx;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='v';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='L'){\n\t\t\t\tangle='l';\n\t\t\t\tint ny=cy;\n\t\t\t\tint nx=cx-1;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='<';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='R'){\n\t\t\t\tangle='r';\n\t\t\t\tint ny=cy;\n\t\t\t\tint nx=cx+1;\n\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w){\n\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\tfield[cy][cx]='.';\n\t\t\t\t\t\tcy=ny;\n\t\t\t\t\t\tcx=nx;\n\t\t\t\t\t\tfield[cy][cx]='>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(o=='S'){\n\t\t\t\tif(angle=='r'){\n\t\t\t\t\tfor(int i = cx+1; i < w; i++){\n\t\t\t\t\t\tif(field[cy][i]=='#'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[cy][i]=='*'){\n\t\t\t\t\t\t\tfield[cy][i]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='l'){\n\t\t\t\t\tfor(int i = cx-1; i >= 0; i--){\n\t\t\t\t\t\tif(field[cy][i]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[cy][i]=='*'){\n\t\t\t\t\t\t\tfield[cy][i]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='u'){\n\t\t\t\t\tfor(int i = cy-1; i >= 0; i--){\n\t\t\t\t\t\tif(field[i][cx]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[i][cx]=='*'){\n\t\t\t\t\t\t\tfield[i][cx]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(angle=='d'){\n\t\t\t\t\tfor(int i = cy+1; i < h; i++){\n\t\t\t\t\t\tif(field[i][cx]=='#')\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse if(field[i][cx]=='*'){\n\t\t\t\t\t\t\tfield[i][cx]='.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcout<<field[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nchar mp[30][30];\nint dx[]{ -1,1,0,0 }, dy[]{ 0,0,-1,1 };\nchar cc[]{ 'U','D','L','R' }, ccc[]{ '^','v','<','>' };\nint main() {\n\tint t; scanf(\"%d\", &t);\n\trep(k, t) {\n\t\tint h, w; scanf(\"%d%d\", &h, &w);\n\t\tint px, py, dir;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", mp[i]);\n\t\t\trep(j, w) {\n\t\t\t\tint d = find(ccc, ccc + 4, mp[i][j]) - ccc;\n\t\t\t\tif (d < 4)px = i, py = j, dir = d, mp[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tint n; string s; cin >> n >> s;\n\t\tfor (char c : s) {\n\t\t\tif (c != 'S') {\n\t\t\t\tdir = find(cc, cc + 4, c) - cc;\n\t\t\t\tint nx = px + dx[dir], ny = py + dy[dir];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&mp[nx][ny] == '.')px = nx, py = ny;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int nx = px, ny = py; 0 <= nx&&nx < h && 0 <= ny&&ny < w; nx += dx[dir], ny += dy[dir]) {\n\t\t\t\tif (mp[nx][ny] == '*') {\n\t\t\t\t\tmp[nx][ny] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mp[nx][ny] == '#')break;\n\t\t\t}\n\t\t}\n\t\tmp[px][py] = ccc[dir];\n\t\trep(i, h)printf(\"%s\\n\", mp[i]);\n\t\tif (k != t - 1)printf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint H, W, N, y, x;\nchar field[25][25], order[120];\n \nbool inField(int _y, int _x){\n  return (0 <= _x && _x < W && 0 <= _y && _y < H);\n}\n \nvoid funcU(){\n  field[y][x] = '^';\n \n  int ny = y-1, nx = x;\n  if(!inField(ny,nx)) return;\n  if(field[ny][nx] != '.') return;\n  field[y][x] = '.';\n  y = ny; x = nx;\n  field[y][x] = '^';\n}\n \nvoid funcD(){\n  field[y][x] = 'v';\n \n  int ny = y+1, nx = x;\n  if(!inField(ny,nx)) return;\n  if(field[ny][nx] != '.') return;\n  field[y][x] = '.';\n  y = ny; x = nx;\n  field[y][x] = 'v';\n}\n \nvoid funcL(){\n  field[y][x] = '<';\n \n  int ny = y, nx = x-1;\n  if(!inField(ny,nx)) return;\n  if(field[ny][nx] != '.') return;\n  field[y][x] = '.';\n  y = ny; x = nx;\n  field[y][x] = '<';\n}\n \nvoid funcR(){\n  field[y][x] = '>';\n \n  int ny = y, nx = x+1;\n  if(!inField(ny,nx)) return;\n  if(field[ny][nx] != '.') return;\n  field[y][x] = '.';\n  y = ny; x = nx;\n  field[y][x] = '>';\n}\n \nvoid shoot(){\n  int dir;\n  int dx[4] = {0,0,-1,1};\n  int dy[4] = {-1,1,0,0};\n \n  switch(field[y][x]){\n  case '^':\n    dir = 0;\n    break;\n  case 'v':\n    dir = 1;\n    break;\n  case '<':\n    dir = 2;\n    break;\n  case '>':\n    dir = 3;\n    break;\n  }\n  int tx = x, ty = y;\n  while(true){\n    int nx = tx + dx[dir];\n    int ny = ty + dy[dir];\n \n    if(!inField(ny,nx)) return;\n    if(field[ny][nx] == '.' || field[ny][nx] == '-'){\n      tx = nx; ty = ny;\n      continue;\n    }else if(field[ny][nx] == '*'){\n      field[ny][nx] = '.';\n      return;\n    }else{\n      return;\n    }\n  }\n}\n \nvoid print(){\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(j == W-1){\n        cout << field[i][j] << endl;\n      }else{\n        cout << field[i][j];\n      }\n    }\n  }\n}\n \nvoid solve(){\n  for(int i = 0 ; i < N ; i++){\n    switch(order[i]){\n    case 'U':\n      funcU();\n      break;\n    case 'D':\n      funcD();\n      break;\n    case 'L':\n      funcL();\n      break;\n    case 'R':\n      funcR();\n      break;\n    default:\n      shoot();\n      break;\n    }\n  }\n  print();\n}\n \nint main(){\n  int Tc;\n  bool flg = false;\n \n  cin >> Tc;\n  while(Tc--){\n    string str;\n    if(flg) cout << endl;\n    cin >> H >> W;\n    for(int i = 0 ; i < H ; i++){\n      cin >> str;\n      for(int j = 0 ; j < W ; j++){\n        field[i][j] = str[j];\n        if(str[j] == '^' || str[j] == 'v' ||\n           str[j] == '<' || str[j] == '>'){\n          y = i, x = j;\n        }\n      }\n    }\n    cin >> N;\n    for(int i = 0 ; i < N ; i++){\n      cin >> order[i];\n    }\n    solve();\n    flg = true;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint w,h;\nint px,py,pa;\nchar f[22][22];\nint dx[] = {0,0,-1,1};\nint dy[] = {-1,1,0,0};\nint main(void){\n  int n;\n  cin >> n;\n  for(int k = 0; k < n; k++){\n    cin >> h >> w;\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n\tcin >> f[x][y];\n\tswitch(f[x][y]){\n\tcase '^': px = x; py = y; pa = 0; break;\n\tcase 'v': px = x; py = y; pa = 1; break;\n\tcase '<': px = x; py = y; pa = 2; break;\n\tcase '>': px = x; py = y; pa = 3; break;\n\t}\n      }\n    }\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      char c;\n      cin >> c;\n      if(c == 'S'){\n\tfor(int nx = px + dx[pa],ny = py + dy[pa];0 <= nx && nx < w && 0 <= ny && ny < h; nx+=dx[pa],ny+=dy[pa]){\n\t  if(f[nx][ny] == '*'){\n\t    f[nx][ny] = '.';\n\t    break;\n\t  }\n\t  if(f[nx][ny] == '#') break;\n\t}\n      }else{\n\tf[px][py] = '.';\n\tswitch(c){\n\tcase 'U': pa = 0; break;\n\tcase 'D': pa = 1; break;\n\tcase 'L': pa = 2; break;\n\tcase 'R': pa = 3; break;\n\t}\n\tint nx = px + dx[pa];\n\tint ny = py + dy[pa];\n\tif(0 <= nx && nx < w && 0 <= ny && ny < h && f[nx][ny] == '.'){\n\t  px = nx;\n\t  py = ny;\n\t}\n\tswitch(pa){\n\tcase 0: f[px][py]='^'; break;\n\tcase 1: f[px][py]='v'; break;\n\tcase 2: f[px][py]='<'; break;\n\tcase 3: f[px][py]='>'; break;\n\t}\n      }\n    }\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n\tcout << f[x][y];\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar c[30][30];\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nint dd(char c){\n\tif( c == 'U' || c == '^') return 1;\n\tif( c == 'D' || c == 'v') return 3;\n\tif( c == 'L' || c == '<') return 0;\n\tif( c == 'R' || c == '>') return 2;\n\treturn -1000;\n}\n\nchar ddd(int n){\n\tif(n == 0 ) return '<';\n\tif(n == 1 ) return '^';\n\tif(n == 2 ) return '>';\n\tif(n == 3 ) return 'v';\n}\nint main(){\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tint H,W;\n\t\tcin >> H >> W;\n\t\tfor(int i = 0 ; i < 30 ; i++)\n\t\t\tfor(int j = 0 ; j < 30 ; j++)\n\t\t\t\tc[i][j] = '#';\n\t\t\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tcin >> c[i][j];\n\t\t\t}\n\t\t}\n\t\tint N;\n\t\tcin >> N;\n\t\tfor(int _ = 0 ; _ < N ; _++){\n\t\t\tchar s;\n\t\t\tcin >> s;\n\t\t\tint sx = 0 , sy = 0;\n\t\t\tfor(int j = 1 ; j <= H ; j++)\n\t\t\t\tfor(int k = 1 ; k <= W ; k++)\n\t\t\t\t\tif( c[j][k] == 'v' || c[j][k] == '^' || c[j][k] == '<' || c[j][k] == '>'){\n\t\t\t\t\t\tsx = k;\n\t\t\t\t\t\tsy = j;\n\t\t\t\t\t}\n\t\t\tif( s == 'S' ){\n\t\t\t\tint dir = dd(c[sy][sx]);\n\t\t\t\tint X = sx + dx[dir];\n\t\t\t\tint Y = sy + dy[dir];\n\t\t\t\twhile(c[Y][X] != '#' && c[Y][X] != '*'){\n\t\t\t\t\tX += dx[dir];\n\t\t\t\t\tY += dy[dir];\n\t\t\t\t}\n\t\t\t\tif( c[Y][X] == '*' ) c[Y][X] = '.';\n\t\t\t}else{\n\t\t\t\t//cout << s << \" \" << dd(s) << \" \" << ddd(dd(s)) << endl;\n\t\t\t\tc[sy][sx] = ddd(dd(s));\n\t\t\t\t\n\t\t\t\tint dir = dd(c[sy][sx]);\n\t\t\t\tint X = sx + dx[dir];\n\t\t\t\tint Y = sy + dy[dir];\n\t\t\t\tif( c[Y][X] == '.'){\n\t\t\t\t\tc[Y][X] = c[sy][sx];\n\t\t\t\t\tc[sy][sx] = '.';\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tcout << c[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tif( T )cout << endl;\n\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n\tint t;\n\tcin >> t;\n\tfor (int i = 0; i < t; i++) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tvector<string> data(h);\n\t\tP p;\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tcin >> data[j];\n\t\t\tif (data[j].find('>') != string::npos) {\n\t\t\t\tp.first = j;\n\t\t\t\tp.second = data[j].find('>');\n\t\t\t}\n\n\t\t\tif (data[j].find('<') != string::npos) {\n\t\t\t\tp.first = j;\n\t\t\t\tp.second = data[j].find('<');\n\t\t\t}\n\t\t\t\n\t\t\tif (data[j].find('^') != string::npos) {\n\t\t\t\tp.first = j;\n\t\t\t\tp.second = data[j].find('^');\n\t\t\t}\n\t\t\t\n\t\t\tif (data[j].find('v') != string::npos) {\n\t\t\t\tp.first = j;\n\t\t\t\tp.second = data[j].find('v');\n\t\t\t}\n\t\t}\n\t\tint n;\n\t\tcin >> n;\n\t\tstring aa;\n\t\tcin >> aa;\n\t\t//cout << p.first << ' ' << p.second << endl;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\t//cout << aa[j] << endl;\n\t\t\tif (aa[j] == 'U') {\n\t\t\t\tdata[p.first][p.second] = '^';\n\t\t\t\tif (p.first-1 >= 0 && data[p.first-1][p.second] == '.') {\n\t\t\t\t\tdata[p.first][p.second] = '.';\n\t\t\t\t\tdata[p.first-1][p.second] = '^';\n\t\t\t\t\tp.first--;\n\t\t\t\t}\n\t\t\t} else if (aa[j] == 'D') {\n\t\t\t\tdata[p.first][p.second] = 'v';\n\t\t\t\tif (p.first+1 < h && data[p.first+1][p.second] == '.') {\n\t\t\t\t\tdata[p.first][p.second] = '.';\n\t\t\t\t\tdata[p.first+1][p.second] = 'v';\n\t\t\t\t\tp.first++;\n\t\t\t\t}\n\t\t\t} else if (aa[j] == 'L') {\n\t\t\t\tdata[p.first][p.second] = '<';\n\t\t\t\tif (p.second-1 >= 0 && data[p.first][p.second-1] == '.') {\n\t\t\t\t\tdata[p.first][p.second] = '.';\n\t\t\t\t\tdata[p.first][p.second-1] = '<';\n\t\t\t\t\tp.second--;\n\t\t\t\t}\n\t\t\t} else if (aa[j] == 'R') {\n\t\t\t\tdata[p.first][p.second] = '>';\n\t\t\t\tif (p.second+1 < w && data[p.first][p.second+1] == '.') {\n\t\t\t\t\tdata[p.first][p.second] = '.';\n\t\t\t\t\tdata[p.first][p.second+1] = '>';\n\t\t\t\t\tp.second++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tP pp = p;\n\t\t\t\t//cout << data[p.first][p.second] << endl;\n\t\t\t\tif (data[p.first][p.second] == '^') {\n\t\t\t\t\t//cout << 'b' << endl;\n\t\t\t\t\twhile (pp.first > 0) {\n\t\t\t\t\t\tpp.first--;\n\t\t\t\t\t\tif (data[pp.first][pp.second] == '*') {\n\t\t\t\t\t\t\tdata[pp.first][pp.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (data[pp.first][pp.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << 'a' << endl;\n\t\t\t\t} else if (data[p.first][p.second] == 'v') {\n\t\t\t\t\twhile (pp.first < h-1) {\n\t\t\t\t\t\tpp.first++;\n\t\t\t\t\t\tif (data[pp.first][pp.second] == '*') {\n\t\t\t\t\t\t\tdata[pp.first][pp.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (data[pp.first][pp.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (data[p.first][p.second] == '<') {\n\t\t\t\t\twhile (pp.second > 0) {\n\t\t\t\t\t\tpp.second--;\n\t\t\t\t\t\tif (data[pp.first][pp.second] == '*') {\n\t\t\t\t\t\t\tdata[pp.first][pp.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (data[pp.first][pp.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (data[p.first][p.second] == '>') {\n\t\t\t\t\twhile (pp.second < w-1) {\n\t\t\t\t\t\tpp.second++;\n\t\t\t\t\t\tif (data[pp.first][pp.second] == '*') {\n\t\t\t\t\t\t\tdata[pp.first][pp.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (data[pp.first][pp.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t\t/*for (int k = 0; k < h; k++) {\n\t\t\t\tcout << data[k] << endl;\n\t\t\t}*/\n\t\t}\n\t\tif (i != 0) {\n\t\t\tcout << endl;\n\t\t}\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tcout << data[j] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nconst int dx[4] = { 0, 0, -1, 1 };\nconst int dy[4] = { -1, 1, 0, 0 };\nconst char mov[] = \"UDLR\";\nconst char tank[] = \"^v<>\";\n\nint h, w, d, x, y;\nstring map[22], command;\n\nint main()\n{\n    int t, n;\n    cin >> t;\n    map[0] = \"######################\";\n\n    for(int i = 1; ; ++i)\n    {\n        cin >> h >> w;\n        for(int j = 1; j <= h; ++j) {\n            cin >> map[j];\n            map[j] = \"#\" + map[j] + \"#\";\n        }\n        map[h+1] = map[0];\n        cin >> n >> command;\n\n        for(int j = 1; j <= h; ++j)\n            for(int k = 0; k < 4; ++k)\n\t\t\t\tif(map[j].find(tank[k]) != string::npos)\n\t\t\t\t\ty = j, x = map[j].find(tank[k]), d = k, map[y][x] = '.';\n\n        for(int j = 0; j < n; ++j)\n        {\n            for(int k = 0; k < 4; ++k)\n                if(command[j] == mov[k]) {\n                    d = k;\n                    if(map[y+dy[d]][x+dx[d]] == '.')\n                        x += dx[d], y += dy[d];\n                }\n\n            if(command[j] == 'S')\n                for(int xx = x, yy = y; map[yy][xx] != '#'; xx += dx[d], yy += dy[d])\n                    if(map[yy][xx] == '*') { map[yy][xx] = '.'; break; }\n        }\n\n        map[y][x] = tank[d];\n\n        for(int j = 1; j <= h; ++j)\n            cout << map[j].substr(1, w) << endl;\n\n        if(i == t) break;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define in_range(x,l,r) (l<=x && x<r)\nusing namespace std;\ntypedef vector<int> vi;\n\nconst string dir = \"URDL\", tank = \"^>v<\";\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  int t;\n  cin >> t;\n  while(t--){\n    int h,w;\n    cin >> h >> w;\n    vector<string> g(h);\n    rep(i,h)cin >> g[i];\n\n    int len;\n    string command;\n    cin >> len >> command;\n\n    int y=0,x=0,d=0;\n    rep(i,h)rep(j,w){\n      rep(k,4){\n\tif(g[i][j] == tank[k]){\n\t  y = i; x = j; d = k;\n\t  g[i][j] = '.';\n\t}\n      }\n    }\n\n    rep(i,command.size()){\n      if(command[i] == 'S'){\n\tint ny = y+dy[d], nx = x+dx[d];\n\twhile(in_range(ny,0,h) && in_range(nx,0,w)){\n\t  if(g[ny][nx] == '#')break;\n\t  if(g[ny][nx] == '*'){\n\t    g[ny][nx] = '.';\n\t    break;\n\t  }\n\t  ny += dy[d]; nx += dx[d];\n\t}\n      }else{\n\trep(k,4){\n\t  if(command[i] == dir[k])d = k;\n\t}\n\tint ny = y+dy[d], nx = x+dx[d];\n\tif(in_range(ny,0,h) && in_range(nx,0,w) && g[ny][nx] == '.'){\n\t  y = ny; x = nx;\n\t}\n      }\n    }\n\n    g[y][x] = tank[d];\n    rep(i,h)cout << g[i] << endl;\n    if(t!=0)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nchar town[30][30];\nint h,w,dir,x,y;\n\nbool intown(int x,int y){\n  return !(x<0 || y<0 || x>=h || y>=w || town[x][y]!='.');\n}\n\nvoid hou(int cx,int cy){\n  if(cx<0 || cy<0 || cx>=h || cy>=w || town[cx][cy]=='#')return;\n  if(town[cx][cy]=='.' || town[cx][cy]=='-')hou(cx+dx[dir],cy+dy[dir]);\n  else if(town[cx][cy]=='*'){\n    town[cx][cy]='.';\n    return;\n  }\n}\n\nmain(){\n  int n;\n  cin>>n;\n  while(n--){\n    cin>>h>>w;\n    rep(i,h){\n      cin>>town[i];\n      rep(j,w){\n        switch(town[i][j]){\n        case '^':\n          dir=3;\n          x=i,y=j;\n          break;\n        case '>':\n          dir=0;\n          x=i,y=j;\n          break;\n        case 'v':\n          dir=1;\n          x=i,y=j;\n          break;\n        case '<':\n          dir=2;\n          x=i,y=j;\n          break;\n        }\n      }\n    }\n\n    int s;\n    cin>>s;\n    string str;\n    cin>>str;\n    rep(i,str.size()){\n      switch(str[i]){\n      case 'U':\n        dir=3;\n        if(intown(x+dx[dir],y+dy[dir])){\n          town[x][y]='.';\n          x+=dx[dir],y+=dy[dir];\n        }\n        town[x][y]='^';\n        break;\n      case 'D':\n        dir=1;\n        if(intown(x+dx[dir],y+dy[dir])){\n          town[x][y]='.';\n          x+=dx[dir],y+=dy[dir];\n        }\n        town[x][y]='v';\n        break;\n      case 'R':\n        dir=0;\n        if(intown(x+dx[dir],y+dy[dir])){\n          town[x][y]='.';\n          x+=dx[dir],y+=dy[dir];\n        }\n        town[x][y]='>';\n        break;\n      case 'L':\n        dir=2;\n        if(intown(x+dx[dir],y+dy[dir])){\n          town[x][y]='.';\n          x+=dx[dir],y+=dy[dir];\n        }\n        town[x][y]='<';\n        break;\n      case 'S':\n        hou(x+dx[dir],y+dy[dir]);\n        break;\n      }\n      //cout<<str[i]<<endl;\n      //rep(i,h)cout<<town[i]<<endl;\n\n    }\n    rep(i,h)cout<<town[i]<<endl;\n    if(n)cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n\nint H, W;\nint my[] = {-1, 1, 0, 0};\nint mx[] = {0, 0, -1, 1};\nstring tank = \"^v<>\";\n\nvoid disp(vector< vector<char> > &v, bool t, int y, int x, int d){\n  REP(i, H){\n    REP(j, W){\n      if(i == y && j == x) cout <<tank[d];\n      else cout <<v[i][j];\n    }\n    cout <<endl;\n  }\n  if(t) cout <<endl;\n}\n\nvoid move(vector< vector<char> > &v, char c, int &y, int &x, int &d){\n  if(c == 'U') d = 0;\n  if(c == 'D') d = 1;\n  if(c == 'L') d = 2;\n  if(c == 'R') d = 3;\n  if(c == 'S'){\n    int xx = x, yy = y;\n    while(xx >= 0 && yy >= 0 && xx < W && yy < H){\n      if(v[yy][xx] == '#') break;\n      if(v[yy][xx] == '*') { v[yy][xx] = '.'; break; }\n      yy += my[d]; xx += mx[d];\n    }\n  }\n  if(c != 'S' && y + my[d] >= 0 && y + my[d] < H && x + mx[d] >= 0 && x + mx[d] < W && v[y + my[d]][x + mx[d]] == '.') { y += my[d]; x += mx[d]; }\n}\n\nint main() {\n  int T; cin >>T;\n  REP(t, T){\n    cin >>H >>W;\n    vector< vector<char> > v(H, vector<char>(W));\n    REP(i, H) REP(j, W) cin >>v[i][j];\n    int y, x, d, l;\n    REP(i, H){\n      REP(j, W){\n        int l = tank.find(v[i][j], 0);\n        if(l != string::npos) { y = i; x = j; d = l; v[i][j] = '.'; }\n      }\n    }\n    int N; cin >>N;\n    REP(n, N){ char c; cin >>c; move(v, c, y, x, d); }\n    disp(v, t + 1 == T ? 0 : 1, y, x, d);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int n, w, h, len;\n  char m[21][21];\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {-1, 0, 1, 0};\n  char d[] = \"^>v<\";\n  cin >> n;\n  while(n--){\n    int cx, cy, cd, bx, by;\n    cin >> h >> w;\n    getchar();\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tm[j][i] = getchar();\n\tif(m[j][i] == '^'){ cx = j; cy = i; cd = 0; m[j][i] = '.'; }\n\tif(m[j][i] == '>'){ cx = j; cy = i; cd = 1; m[j][i] = '.'; }\n\tif(m[j][i] == 'v'){ cx = j; cy = i; cd = 2; m[j][i] = '.'; }\n\tif(m[j][i] == '<'){ cx = j; cy = i; cd = 3; m[j][i] = '.'; }\n      }\n      getchar();\n    }\n    cin >> len;\n    getchar();\n    for(int c = 0; c < len; c++){\n      switch(getchar()){\n      case 'U':\n\tcd = 0;\n\tif(cy > 0 && m[cx][cy - 1] == '.') cy--;\n\tbreak;\n      case 'R':\n\tcd = 1;\n\tif(cx < w-1 && m[cx + 1][cy] == '.') cx++;\n\tbreak;\n      case 'D':\n\tcd = 2;\n\tif(cy < h-1 && m[cx][cy + 1] == '.') cy++;\n\tbreak;\n      case 'L':\n\tcd = 3;\n\tif(cx > 0 && m[cx - 1][cy] == '.') cx--;\n\tbreak;\n      case 'S':\n\tbx = cx; by = cy;\n\twhile(m[bx][by] == '.' || m[bx][by] == '-'){\n\t  bx += dx[cd];\n\t  by += dy[cd];\n\t  if(m[bx][by] == '*'){\n\t    m[bx][by] = '.';\n\t    break;\n\t  }\n\t}\n      }\n    }\n    getchar();\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(i == cy && j == cx) cout << d[cd];\n\telse cout << m[j][i];\n      }\n      cout << endl;\n    }\n    if(n) cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst string DIRS = \"URDL\", TANK = \"^>v<\";\nconst int dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nint dir(char c) { return DIRS.find(c); }\n\nint T, H, W, N, tx, ty;\nstring grid[22], operation;\n\nvoid move(int d) {\n\tgrid[ty][tx] = '.';\n\t\n\tint nx = tx + dx[d], ny = ty + dy[d];\n\t\n\tif (in_range(nx, ny, W, H) && grid[ny][nx] == '.') {\n\t\tgrid[ny][nx] = TANK[d];\n\t\tty = ny; tx = nx;\n\t} else {\n\t\tgrid[ty][tx] = TANK[d];\n\t}\n}\n\nvoid shoot() {\n\tint d = TANK.find(grid[ty][tx]);\n\tint x = tx + dx[d], y = ty + dy[d];\n\t\n\twhile (in_range(x, y, W, H) && grid[y][x] != '#' && grid[y][x] != '*') {\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\t\n\tif (in_range(x, y, W, H) && grid[y][x] == '*') grid[y][x] = '.';\n}\n\nvoid simulate() {\n\tfor_(i,0,N) {\n\t\tchar c = operation[i];\n\t\t\n\t\tif (c == 'S') {\n\t\t\tshoot();\n\t\t} else {\n\t\t\tmove(dir(c));\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> T;\n\t\n\tfor_(case_num,0,T) {\n\t\tcin >> H >> W;\n\t\t\n\t\tfor_(y,0,H) {\n\t\t\tcin >> grid[y];\n\t\t\tfor_(x,0,W) if (TANK.find(grid[y][x]) != TANK.npos) tx = x, ty = y;\n\t\t}\n\t\t\n\t\tcin >> N;\n\t\tcin >> operation;\n\t\t\n\t\tsimulate();\n\t\t\n\t\tfor_(y,0,H) cout << grid[y] << endl;\n\t\tif (case_num < T - 1) cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nchar town[21][21];\npair<int, int> p;\n\n// ú»\nvoid initTown(int h, int w){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\ttown[i][j] = '#';\n\t\t}\n\t}\n}\n\n// eÌÊ\nvoid shoot(int y, int x, int direction){\n\tif(town[y][x] == '#'){\n\t\treturn;\n\t}\n\tif(town[y][x] == '*'){\n\t\ttown[y][x] = '.';\n\t\treturn;\n\t}\n\t\n\tif(y > 0 && direction == 0){\n\t\tshoot(y - 1, x, 0);\n\t}\n\telse if(direction == 1){\n\t\tshoot(y, x + 1, 1);\n\t}\n\telse if(direction == 2){\n\t\tshoot(y + 1, x, 2);\n\t}\n\telse if(x > 0 && direction == 3){\n\t\tshoot(y, x - 1, 3);\n\t}\n\t\n\treturn;\n}\n\n// íÔÌì\nvoid control(int n){\n\tchar cont;\n\tfor(; n > 0; --n){\n\t\tscanf(\" %c\", &cont);\n\t\tif(cont == 'U'){\n\t\t\tif(p.first > 0 && town[p.first - 1][p.second] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\n\t\t\t\ttown[p.first - 1][p.second] = '^';\n\t\t\t\tp.first--;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = '^';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'D'){\n\t\t\tif(town[p.first + 1][p.second] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\t\n\t\t\t\ttown[p.first + 1][p.second] = 'v';\n\t\t\t\tp.first++;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = 'v';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'L'){\n\t\t\tif(p.second > 0 && town[p.first][p.second - 1] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\n\t\t\t\ttown[p.first][p.second - 1] = '<';\n\t\t\t\tp.second--;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = '<';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'R'){\n\t\t\tif(town[p.first][p.second + 1] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\n\t\t\t\ttown[p.first][p.second + 1] = '>';\n\t\t\t\tp.second++;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = '>';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'S'){\n\t\t\tif(town[p.first][p.second] == '^'){\n\t\t\t\tshoot(p.first, p.second, 0);\n\t\t\t}\n\t\t\telse if(town[p.first][p.second] == '>'){\n\t\t\t\tshoot(p.first, p.second, 1);\n\t\t\t}\t\n\t\t\telse if(town[p.first][p.second] == 'v'){\n\t\t\t\tshoot(p.first, p.second, 2);\n\t\t\t}\n\t\t\telse if(town[p.first][p.second] == '<'){\n\t\t\t\tshoot(p.first, p.second, 3);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\nint main(){\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor(;t > 0; --t){\n\t\tint h,w;\n\t\tscanf(\"%d %d\", &h, &w);\n\t\tinitTown(21, 21);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", town[i]);\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(town[i][j] == '^' || town[i][j] == '<' || town[i][j] == '>' || town[i][j] == 'v'){\n\t\t\t\t\tp.first = i;\n\t\t\t\t\tp.second = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tcontrol(n);\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tprintf(\"%c\", town[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tif(t != 1){\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring field[20];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\nstring dir_str = \">^<v\";\nstring dir_str2 = \"RULD\";\n\n#define DBG(x) cout<<#x<<\": \"<<x<<endl;\n\nint main() {\n\tint N;\n\tcin >> N;\n\twhile(N--) {\n\t\tint H, W;\n\t\t\n\t\tcin >> H >> W;\n\t\t\n\t\tcin.ignore();\n\t\t\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tgetline(cin, field[y]);\n\t\t}\n\t\t\n\t\tint curX, curY, dir;\n\t\t\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(find(dir_str.begin(), dir_str.end(), field[y][x]) != dir_str.end()) {\n\t\t\t\t\tdir = find(dir_str.begin(), dir_str.end(), field[y][x]) - dir_str.begin();\n\t\t\t\t\tcurX = x;\n\t\t\t\t\tcurY = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tDBG(curX);\n\t\tDBG(curY);\n\t\tDBG(dir);\n\t\t*/\n\t\t\n\t\tint len_cmd; string cmd;\n\t\tcin >> len_cmd >> cmd;\n\t\t\n\t\tfor(int cn = 0; cn < len_cmd; cn++) {\n\t\t\tchar c = cmd[cn];\n\t\t\tif(find(dir_str2.begin(), dir_str2.end(), c) != dir_str2.end()) {\n\t\t\t\tint d = find(dir_str2.begin(), dir_str2.end(), c) - dir_str2.begin();\n\t\t\t\t\n\t\t\t\tdir = d;\n\t\t\t\tfield[curY][curX] = dir_str[d];\n\t\t\t\t\n\t\t\t\tint nx = curX + dx[d];\n\t\t\t\tint ny = curY + dy[d];\n\t\t\t\t\n\t\t\t\tif(0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] == '.') {\n\t\t\t\t\tfield[curY][curX] = '.';\n\t\t\t\t\tfield[ny][nx] = dir_str[d];\n\t\t\t\t\tcurX = nx;\n\t\t\t\t\tcurY = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(c == 'S') {\n\t\t\t\tint nx = curX + dx[dir];\n\t\t\t\tint ny = curY + dy[dir];\n\t\t\t\t\n\t\t\t\twhile(0 <= nx && nx < W && 0 <= ny && ny < H) {\n\t\t\t\t\t\n\t\t\t\t\tif(field[ny][nx] == '*') {\n\t\t\t\t\t\tfield[ny][nx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(field[ny][nx] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tnx += dx[dir];\n\t\t\t\t\tny += dy[dir];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << \"turn: \" << cn << endl;\n\t\t\t\n\t\t\tDBG(curX);\n\t\t\tDBG(curY);\n\t\t\tDBG(dir);\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++) {\n\t\t\t\tcout << field[y] << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tcout << field[y] << endl;\n\t\t}\n\t\t\n\t\tif(N > 0) {\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\nint dir[4][2] = {\n\t{0, -1},\n\t{-1, 0},\n\t{1, 0},\n\t{0, 1}\n};\n\nvoid shoot(char a[20][20], int s, int t, int x, int y, int d)\n{\n\tif(x < 0 || x == t || y < 0 || y == s){\n\t\treturn ;\n\t}\n\tif(a[y][x] == '.' || a[y][x] == '-'){\n\t\tshoot(a, s, t, x+dir[d][0], y+dir[d][1], d);\n\t} else if(a[y][x] == '*'){\n\t\ta[y][x] = '.';\n\t}\n\t\n\treturn ;\n}\n\nint main(int argc, char **argv)\n{\n\tint n, s, t, x, y, d, m;\n\tchar a[20][20], *c;\n\t\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tif(i != 0){\n\t\t\tcout << endl;\n\t\t}\n\t\tcin >> s >> t;\n\t\tfor(int j = 0, f = 0; j < s; j++){\n\t\t\tscanf(\"%s\", a[j]);\n\t\t\tfor(int k = 0; k < t && f == 0; k++){\n\t\t\t\tif(a[j][k] == '^'){\n\t\t\t\t\tx = k;\n\t\t\t\t\ty = j;\n\t\t\t\t\tf = 1;\n\t\t\t\t\td = 0;\n\t\t\t\t\ta[j][k] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\telse if(a[j][k] == '<'){\n\t\t\t\t\tx = k;\n\t\t\t\t\ty = j;\n\t\t\t\t\tf = 1;\n\t\t\t\t\td = 1;\n\t\t\t\t\ta[j][k] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(a[j][k] == '>'){\n\t\t\t\t\tx = k;\n\t\t\t\t\ty = j;\n\t\t\t\t\tf = 1;\n\t\t\t\t\td = 2;\n\t\t\t\t\ta[j][k] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(a[j][k] == 'v'){\n\t\t\t\t\tx = k;\n\t\t\t\t\ty = j;\n\t\t\t\t\tf = 1;\n\t\t\t\t\td = 3;\n\t\t\t\t\ta[j][k] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tc = (char *)malloc((m+1)*sizeof(char));\n\t\tscanf(\"%s\", c);\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(c[j] == 'U'){\n\t\t\t\tif(y > 0 && a[y-1][x] == '.'){\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\td = 0;\n\t\t\t} else if(c[j] == 'D'){\n\t\t\t\tif(y < s-1 && a[y+1][x] == '.'){\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\td = 3;\n\t\t\t} else if(c[j] == 'L'){\n\t\t\t\tif(x > 0 && a[y][x-1] == '.'){\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t\td = 1;\n\t\t\t} else if(c[j] == 'R'){\n\t\t\t\tif(x < t-1 && a[y][x+1] == '.'){\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\td = 2;\n\t\t\t} else {\n\t\t\t\tshoot(a, s, t, x+dir[d][0], y+dir[d][1], d);\n\t\t\t}\n\t\t}\n\t\tfree(c);\n\t\tfor(int k = 0; k < s; k++){\n\t\t\tfor(int j = 0; j < t; j++){\n\t\t\t\tif(k == y && j == x){\n\t\t\t\t\tif(d == 0){\n\t\t\t\t\t\tcout << '^';\n\t\t\t\t\t} else if(d == 1){\n\t\t\t\t\t\tcout << '<';\n\t\t\t\t\t} else if(d == 2){\n\t\t\t\t\t\tcout << '>';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << 'v';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcout << a[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[20][21], t[4]={'^','>','v','<'};\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\t//ã0 E1 º2 ¶3\nint T, H, W, N;\nstruct {int x, y, a;} p;\t//íÔÌ éÀW,íÔÌü«\nvoid shoot(int x, int y, int a)\n{\n\twhile (0 <= x+dx[a] && x+dx[a] <= W && 0 <= y+dy[a] && y+dy[a] <= H)\n\t{\n\t\tx+=dx[a], y+=dy[a];\n\t\tif (m[y][x]=='*')\n\t\t{\n\t\t\tm[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t\telse if (m[y][x]=='#')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar o[101]=\"\";\n\tint i, j, nx, ny;\n\tcin >> T;\n\tfor (; T > 0; T--)\n\t{\n\t\tcin >> H >> W;\n\t\tfor (i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tswitch (m[i][j])\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t\tp.x=j, p.y=i, p.a=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tp.x=j, p.y=i, p.a=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tp.x=j, p.y=i, p.a=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tp.x=j, p.y=i, p.a=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[i][j]='\\0';\n\t\t}\n\t\tcin >> N >> o;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tswitch (o[i])\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\tp.a=0;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tp.a=2;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tp.a=3;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tp.a=1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshoot(p.x, p.y, p.a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx=p.x+dx[p.a], ny=p.y+dy[p.a];\n\t\t\tif (o[i] != 'S' && 0 <= nx && nx <= W && 0 <= ny && ny <= H && m[ny][nx]=='.')\n\t\t\t{\n\t\t\t\tm[p.y][p.x]='.';\n\t\t\t\tp.x=nx, p.y=ny;\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < H; i++)\n\t\t\tcout << m[i] << endl;\n\t\tif (T > 1)\n\t\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\nint main(){\n    int n;\n    cin>>n;\n    rep(loop,n){\n        if(loop!=0)cout<<endl;\n        string data[30];\n        int h,w;\n        cin>>h>>w;\n        rep(i,h){\n            cin>>data[i];\n        }\n        int x;\n        cin>>x;\n        string s;\n        cin>>s;\n        \n        pii now;\n        char st=' ';\n        \n        rep(i,h){\n            rep(j,w){\n                if( data[i][j]=='>' || data[i][j]=='^' || data[i][j]=='<' || data[i][j]=='v' ){\n                    now=pii(i,j);\n                    st=data[i][j];\n                    data[i][j]='.';\n                    break;\n                }\n            }\n        }\n        rep(i,x){\n            if(s[i]=='R'){\n                if(now.second+1<w&&data[now.first][now.second+1]=='.'){\n                    now.second++;\n                }\n                st='>';\n            }\n            if(s[i]=='L'){\n                if(now.second-1>=0&&data[now.first][now.second-1]=='.'){\n                    now.second--;\n                }\n                st='<';\n            }\n            if(s[i]=='D'){\n                if(now.first+1<h&&data[now.first+1][now.second]=='.'){\n                    now.first++;\n                }\n                st='v';\n            }\n            if(s[i]=='U'){\n                if(now.first-1>=0&&data[now.first-1][now.second]=='.'){\n                    now.first--;\n                }\n                st='^';\n            }\n            if(s[i]=='S'){\n                int y=now.first,x=now.second;\n                int dir=0;\n                int dx[]={0,1,0,-1};\n                int dy[]={1,0,-1,0};\n                if(st=='v')dir=0;\n                if(st=='>')dir=1;\n                if(st=='^')dir=2;\n                if(st=='<')dir=3;\n                while(1){\n                    y+=dy[dir];\n                    x+=dx[dir];\n                    if(y<0||y>=h||x<0||x>=w)break;\n                    if(data[y][x]=='#')break;\n                    if(data[y][x]=='*'){\n                        data[y][x]='.';\n                        break;\n                    }\n                }\n            }\n        }\n        data[now.first][now.second]=st;\n        rep(i,h){\n            rep(j,w){\n                cout<<data[i][j];\n            }\n            cout<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint w,h;\nint px,py,pa;\nchar f[22][22];\nint dx[] = {0,0,-1,1};\nint dy[] = {-1,1,0,0};\nint main(void){\n  int n;\n  cin >> n;\n  for(int k = 0; k < n; k++){\n    cin >> h >> w;\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n\tcin >> f[x][y];\n\tswitch(f[x][y]){\n\tcase '^': px = x; py = y; pa = 0; break;\n\tcase 'v': px = x; py = y; pa = 1; break;\n\tcase '<': px = x; py = y; pa = 2; break;\n\tcase '>': px = x; py = y; pa = 3; break;\n\t}\n      }\n    }\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      char c;\n      cin >> c;\n      if(c == 'S'){\n\tfor(int nx = px + dx[pa],ny = py + dy[pa];0 <= nx && nx < w && 0 <= ny && ny < h; nx+=dx[pa],ny+=dy[pa]){\n\t  if(f[nx][ny] == '*'){\n\t    f[nx][ny] = '.';\n\t    break;\n\t  }\n\t  if(f[nx][ny] == '#') break;\n\t}\n      }else{\n\tf[px][py] = '.';\n\tswitch(c){\n\tcase 'U': pa = 0; break;\n\tcase 'D': pa = 1; break;\n\tcase 'L': pa = 2; break;\n\tcase 'R': pa = 3; break;\n\t}\n\tint nx = px + dx[pa];\n\tint ny = py + dy[pa];\n\tif(0 <= nx && nx < w && 0 <= ny && ny < h && f[nx][ny] == '.'){\n\t  px = nx;\n\t  py = ny;\n\t}\n\tswitch(pa){\n\tcase 0: f[px][py]='^'; break;\n\tcase 1: f[px][py]='v'; break;\n\tcase 2: f[px][py]='<'; break;\n\tcase 3: f[px][py]='>'; break;\n\t}\n      }\n    }\n    for(int y = 0; y < h; y++){\n      for(int x = 0; x < w; x++){\n\tcout << f[x][y];\n      }\n      cout << endl;\n    }\n    if(n-k-1) cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n\tint loop;\n\tconst int UP = 0;\n\tconst int DOWN = 1;\n\tconst int LEFT = 2;\n\tconst int RIGHT = 3;\n\tint shot[4][2] = {{0,-1},{0,1},{-1,0},{1,0}};\n\tcin >> loop;\n\tfor(int n=0;n<loop;n++){\n\t\tchar stage[22][22] = {'#'};\n\t\tint h,w;\n\t\tint commandlength;\n\t\tstring command;\n\t\tint playerX,playerY,playerDir;\n\t\t\n\t\tcin >> h >> w;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tstring buf;\n\t\t\tcin >> buf;\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tstage[i][j] = buf[j-1];\n\t\t\t\tif(buf[j-1] == '^' || buf[j-1] == 'v' || buf[j-1] == '<' || buf[j-1] == '>'){\n\t\t\t\t\tplayerX = j;\n\t\t\t\t\tplayerY = i;\n\t\t\t\t\tswitch(buf[j-1]){\n\t\t\t\t\tcase '^':\n\t\t\t\t\t\tplayerDir = UP;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tplayerDir = DOWN;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tplayerDir = LEFT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\tplayerDir = RIGHT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> commandlength;\n\t\tcin >> command;\n\n\t\tfor(int i=0;i<commandlength;i++){\n\t\t\tswitch(command[i]){\n\t\t\tcase 'U':\n\t\t\t\tif(stage[playerY-1][playerX] == '.'){\n\t\t\t\t\tstage[playerY][playerX] = '.';\n\t\t\t\t\tplayerY--;\n\t\t\t\t}\n\t\t\t\tstage[playerY][playerX] = '^';\n\t\t\t\tplayerDir = UP;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tif(stage[playerY+1][playerX] == '.'){\n\t\t\t\t\tstage[playerY][playerX] = '.';\n\t\t\t\t\tplayerY++;\n\t\t\t\t}\n\t\t\t\tstage[playerY][playerX] = 'v';\n\t\t\t\tplayerDir = DOWN;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tif(stage[playerY][playerX-1] == '.'){\n\t\t\t\t\tstage[playerY][playerX] = '.';\n\t\t\t\t\tplayerX--;\n\t\t\t\t}\n\t\t\t\tstage[playerY][playerX] = '<';\n\t\t\t\tplayerDir = LEFT;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tif(stage[playerY][playerX+1] == '.'){\n\t\t\t\t\tstage[playerY][playerX] = '.';\n\t\t\t\t\tplayerX++;\n\t\t\t\t}\n\t\t\t\tstage[playerY][playerX] = '>';\n\t\t\t\tplayerDir = RIGHT;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\t\tif(stage[playerY+shot[playerDir][1]*j][playerX+shot[playerDir][0]*j] == '*'){\n\t\t\t\t\t\tstage[playerY+shot[playerDir][1]*j][playerX+shot[playerDir][0]*j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(stage[playerY+shot[playerDir][1]*j][playerX+shot[playerDir][0]*j] == '#'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcout<<stage[y][x];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tif(n+1 != loop){\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nchar m[108][108];\nint h, w, n, ni, nj, t;\nchar c;\nvoid solve(){\n\tcin >> h >> w;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tcin >> m[i][j];\n\t\t\tif(m[i][j] == '<' || m[i][j] == '>' || m[i][j] == '^' || m[i][j] == 'v'){\n\t\t\t\tni = i; \n\t\t\t\tnj = j;\n\t\t\t}\n\t\t}\n\t}\n\tcin >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> c;\n\t\tswitch(c){\n\t\t\tcase 'U':\n\t\t\t\tm[ni][nj] = '^';\n\t\t\t\tif(ni > 0 && m[ni-1][nj] == '.'){\n\t\t\t\t\tswap(m[ni][nj], m[ni-1][nj]);\n\t\t\t\t\tni--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tm[ni][nj] = 'v';\n\t\t\t\tif(ni < h - 1 && m[ni+1][nj] == '.'){\n\t\t\t\t\tswap(m[ni][nj], m[ni+1][nj]);\n\t\t\t\t\tni++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tm[ni][nj] = '<';\n\t\t\t\tif(nj > 0 && m[ni][nj-1] == '.'){\n\t\t\t\t\tswap(m[ni][nj], m[ni][nj-1]);\n\t\t\t\t\tnj--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tm[ni][nj] = '>';\n\t\t\t\tif(nj < w - 1 && m[ni][nj+1] == '.'){\n\t\t\t\t\tswap(m[ni][nj], m[ni][nj+1]);\n\t\t\t\t\tnj++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tint dx = 0, dy = 0;         \n\t\t\t\tint ti = ni, tj = nj;\n\t\t\t\tif(m[ni][nj] == '^')dx = -1;\n\t\t\t\tif(m[ni][nj] == 'v')dx = 1;\n\t\t\t\tif(m[ni][nj] == '>')dy = 1;\n\t\t\t\tif(m[ni][nj] == '<')dy = -1;\n\t\t\t\twhile(0 <= ti && ti < h && 0 <= tj && tj < w){\n\t\t\t\t\tif(m[ti][tj] == '*'){\n\t\t\t\t\t\tm[ti][tj] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[ti][tj] == '#'){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tti += dx;\n\t\t\t\t\ttj += dy;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++)cout << m[i][j];\n\t\tcout << endl;\n\t}\n\t\n}\n\nint main(){\n\tcin >> t;\n\tfor(int i = 0;i < t;i++){\n\t\tif(i)cout << endl;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\nusing namespace std;\nstring grid[100], s;\nint x, y;\nint w, h;\n\ntypedef pair<int, int> pii;\n\nvoid move(int dx, int dy, char c){\n  int nx = x + dx, ny = y + dy;\n  if(c == 'R'){\n    grid[y][x] = '>';\n  }else if(c == 'L'){\n    grid[y][x] = '<';\n  }else if(c == 'U'){\n    grid[y][x] = '^';\n  }else if(c == 'D'){\n    grid[y][x] = 'v';\n  }\n  if(0 <= nx && nx < w &&\n     0 <= ny && ny < h &&\n     grid[ny][nx] == '.'){\n    grid[y][x] = '.';\n    if(c == 'R'){\n      grid[ny][nx] = '>';\n    }else if(c == 'L'){\n      grid[ny][nx] = '<';\n    }else if(c == 'U'){\n      grid[ny][nx] = '^';\n    }else if(c == 'D'){\n      grid[ny][nx] = 'v';\n    }\n    x = nx , y = ny;\n  }\n}\n\nvoid shoot(char dist){\n  //cout << \"shoot\" << endl;\n\n  if(dist == 'v'){\n    for(int i = 0;i + y < h; i++){\n      if(grid[i + y][x] == '#' || grid[i + y][x] == '*'){\n\tif(grid[i + y][x] == '*')grid[i + y][x] = '.';\n\tbreak;\n      }\n    }\n  }else if(dist == '<'){\n    for(int i = 0;i + x >= 0; i--){\n      if(grid[y][x + i] == '#' || grid[y][x+i] =='*'){\n\tif(grid[y][x+i] == '*')grid[y][x+i] = '.';\n\tbreak;\n      }\n    } \n  }else if(dist == '>'){\n    for(int i = 0;i + x < w; i++){\n      if(grid[y][x + i] == '#' || grid[y][x+i] =='*'){\n\tif(grid[y][x+i] == '*')grid[y][x+i] = '.';\n\tbreak;\n      }\n    } \n  }else{\n    for(int i = 0;i + y >= 0; i--){\n      if(grid[i + y][x] == '#' || grid[i + y][x] == '*'){\n\tif(grid[i + y][x] == '*')grid[i + y][x] = '.';\n\tbreak;\n      }\n    }\n  }\n\t\n}\n\nint main(){\n  int n;\n  cin >> n;\n  for(int ite = 0; ite < n; ite++){\n\n    cin >> h >> w;\n    for(int i = 0;i < h; i++){\n      cin >> grid[i];\n    }\n\n    for(int i = 0;i < h; i++){\n      for(int j = 0;j < w; j++){\n\tif(grid[i][j] == 'v' || grid[i][j] == '<' ||\n\t   grid[i][j] == '>' || grid[i][j] == '^'){\n\t  x = j; y = i;\n\t}\n      }\n    }\n    map<char, pii> next_trun;\n    next_trun['R'] = mp(1, 0);\n    next_trun['U'] = mp(0, -1);\n    next_trun['L'] = mp(-1, 0);\n    next_trun['D'] = mp(0, 1);\n    next_trun['S'] = mp(0, 0);\n    int tmp;\n    cin >> tmp >> s;\n    for(int i = 0; i < s.length(); i++){\n      if(next_trun[s[i]].first == 0 && next_trun[s[i]].second == 0){\n\tshoot(grid[y][x]);\n      }else{\n\tmove(next_trun[s[i]].first, next_trun[s[i]].second, s[i]);\n      }\n      //cout << next_trun[s[i]].first << \" \" << next_trun[s[i]].second << endl;\n\n      //cout << s[i] << \" \" << x << \" \" << y << endl;\n    }\n    for(int i = 0; i < h; i++){\n      cout << grid[i] << endl;\n    }\n    if(ite < n - 1) cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\n\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tint h,w;\n\t\tcin >> h >> w;\n\t\tint field[h][w]; //0:plain 1:stone 2:steel 3.water\n\t\tstring str;\n\t\tstring ope;\n\t\tpair<int,int> pos; //position of a tank\n\t\tint dir; //direction of a tank\n\t\t\n\t\t//read data\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j] == '.'){\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}else if(str[j] == '*'){\n\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t}else if(str[j] == '#'){\n\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t}else if(str[j] == '-'){\n\t\t\t\t\tfield[i][j] = 3;\n\t\t\t\t}else{\n\t\t\t\t\tpos.first = i;\n\t\t\t\t\tpos.second = j;\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\tif(str[j] == '>'){\n\t\t\t\t\t\tdir = 0;\n\t\t\t\t\t}else if(str[j] == '^'){\n\t\t\t\t\t\tdir = 1;\n\t\t\t\t\t}else if(str[j] == '<'){\n\t\t\t\t\t\tdir = 2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdir = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//operate\n\t\tint num;\n\t\tcin >> num;\n\t\tcin >> ope;\n\t\tfor(int i=0;i<ope.size();i++){\n\t\t\tif(ope[i] == 'R'){\n\t\t\t\tdir = 0;\n\t\t\t\tif(pos.second + 1 < w && field[pos.first][pos.second+1] == 0){\n\t\t\t\t\tpos.second++;\n\t\t\t\t}\n\t\t\t}else if(ope[i] == 'U'){\n\t\t\t\tdir = 1;\n\t\t\t\tif(0 <= pos.first - 1 && field[pos.first-1][pos.second] == 0){\n\t\t\t\t\tpos.first--;\n\t\t\t\t}\n\t\t\t}else if(ope[i] == 'L'){\n\t\t\t\tdir = 2;\n\t\t\t\tif(0 <= pos.second - 1 && field[pos.first][pos.second-1] == 0){\n\t\t\t\t\tpos.second--;\n\t\t\t\t}\n\t\t\t}else if(ope[i] == 'D'){\n\t\t\t\tdir = 3;\n\t\t\t\tif(pos.first + 1 < h && field[pos.first+1][pos.second] == 0){\n\t\t\t\t\tpos.first++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint x = pos.first, y = pos.second;\n\t\t\t\twhile(1){\n\t\t\t\t\tx += dx[dir];\n\t\t\t\t\ty += dy[dir];\n\t\t\t\t\tif(0 <= x && x < h && 0 <= y && y < w){\n\t\t\t\t\t\tif(field[x][y] == 1){\n\t\t\t\t\t\t\tfield[x][y] = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(field[x][y] == 2){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//result\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(i == pos.first && j == pos.second){\n\t\t\t\t\tif(dir == 0){\n\t\t\t\t\t\tcout << \">\";\n\t\t\t\t\t}else if(dir == 1){\n\t\t\t\t\t\tcout << \"^\";\n\t\t\t\t\t}else if(dir == 2){\n\t\t\t\t\t\tcout << \"<\";\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcout << \"v\";\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(field[i][j] == 0){\n\t\t\t\t\t\tcout << \".\";\n\t\t\t\t\t}else if(field[i][j] == 1){\n\t\t\t\t\t\tcout << \"*\";\n\t\t\t\t\t}else if(field[i][j] == 2){\n\t\t\t\t\t\tcout << \"#\";\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcout << \"-\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tif(n) cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint t, h, w, n, i, j, k, l, x, y, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar field[20][21], c, dir[5] = {\"^>v<\"};\n\tscanf(\"%d\",&t);\n\tfor(i = 0;i < t;i++){\n\t\tscanf(\"%d%d%*c\",&h,&w);\n\t\tfor(j = 0;j < h;j++){\n\t\t\tfor(k = 0;k < w;k++){\n\t\t\t\tfield[j][k] = getchar();\n\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\tif(dir[l] == field[j][k]){\n\t\t\t\t\t\ty = j, x = k;\n\t\t\t\t\t\td = l;\n\t\t\t\t\t\tfield[j][k] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[j][k] = '\\0';\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d%*c\",&n);\n\t\tfor(k = 0;k < n;k++){\n\t\t\tc = getchar();\n\t\t\tif(c == 'U'){\n\t\t\t\tif(y - 1 >= 0 && field[y - 1][x] == '.')\n\t\t\t\t\ty--;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(c == 'D'){\n\t\t\t\tif(y + 1 < h && field[y + 1][x] == '.')\n\t\t\t\t\ty++;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse if(c == 'L'){\n\t\t\t\tif(x - 1 >= 0 && field[y][x - 1] == '.')\n\t\t\t\t\tx--;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(c == 'R'){\n\t\t\t\tif(x + 1 < w && field[y][x + 1] == '.')\n\t\t\t\t\tx++;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse if(c == 'S'){\n\t\t\t\tfor(j = 1;y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && (field[y + dy[d] * j][x + dx[d] * j] == '.' || field[y + dy[d] * j][x + dx[d] * j] == '-');j++);\n\t\t\t\tif(y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && field[y + dy[d] * j][x + dx[d] * j] == '*')\n\t\t\t\t\tfield[y + dy[d] * j][x + dx[d] * j] = '.';\n\t\t\t}\n\t\t}\n\t\tfield[y][x] = dir[d];\n\t\tfor(j = 0;j < h;j++)\n\t\t\tputs(field[j]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint t, h, w, n, i, j, k, l, x, y, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar field[20][21], c, dir[5] = {\"^>v<\"};\n\tscanf(\"%d\",&t);\n\tfor(i = 0;i < t;i++){\n\t\tscanf(\"%d%d%*c\",&h,&w);\n\t\tfor(j = 0;j < h;j++){\n\t\t\tfor(k = 0;k < w;k++){\n\t\t\t\tfield[j][k] = getchar();\n\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\tif(dir[l] == field[j][k]){\n\t\t\t\t\t\ty = j, x = k;\n\t\t\t\t\t\td = l;\n\t\t\t\t\t\tfield[j][k] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[j][k] = '\\0';\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d%*c\",&n);\n\t\tfor(k = 0;k < n;k++){\n\t\t\tc = getchar();\n\t\t\tif(c == 'U'){\n\t\t\t\tif(y - 1 >= 0 && field[y - 1][x] == '.')\n\t\t\t\t\ty--;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(c == 'D'){\n\t\t\t\tif(y + 1 < h && field[y + 1][x] == '.')\n\t\t\t\t\ty++;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse if(c == 'L'){\n\t\t\t\tif(x - 1 >= 0 && field[y][x - 1] == '.')\n\t\t\t\t\tx--;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(c == 'R'){\n\t\t\t\tif(x + 1 < w && field[y][x + 1] == '.')\n\t\t\t\t\tx++;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse if(c == 'S'){\n\t\t\t\tfor(j = 1;y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && (field[y + dy[d] * j][x + dx[d] * j] == '.' || field[y + dy[d] * j][x + dx[d] * j] == '-');j++);\n\t\t\t\tif(y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && field[y + dy[d] * j][x + dx[d] * j] == '*')\n\t\t\t\t\tfield[y + dy[d] * j][x + dx[d] * j] = '.';\n\t\t\t}\n\t\t}\n\t\tfield[y][x] = dir[d];\n\t\tfor(j = 0;j < h;j++)\n\t\t\tputs(field[j]);\n\t\tif(i != t - 1)\n\t\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint T,H,W,N;\nchar map[20][20],cmd[100];\nint x,y,d;\n\nint main(){\n  scanf(\"%d\",&T);\n  while(T--){\n    scanf(\"%d%d\",&H,&W);\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tscanf(\" %c\",&map[i][j]);\n\tswitch(map[i][j]){\n\tcase '^': x=i,y=j,d=0,map[i][j]='.'; break;\n\tcase 'v': x=i,y=j,d=1,map[i][j]='.'; break;\n\tcase '>': x=i,y=j,d=2,map[i][j]='.'; break;\n\tcase '<': x=i,y=j,d=3,map[i][j]='.'; break;\n\t}\n      }\n    }\n    scanf(\"%d\",&N);\n    for(int i=0;i<N;i++){\n      scanf(\" %c\",&cmd[i]);\n    }\n    for(int i=0;i<N;i++){\n      switch(cmd[i]){\n      case 'U':\td=0; if(x>0&&map[x-1][y]=='.') x--; break;\n      case 'D': d=1; if(x<H-1&&map[x+1][y]=='.') x++; break;\n      case 'R': d=2; if(y<W-1&&map[x][y+1]=='.') y++; break;\n      case 'L': d=3; if(y>0&&map[x][y-1]=='.') y--; break;\n      case 'S': \n\tswitch(d){\n\tcase 0:{\n\t  int X=x,Y=y;\n\t  for(;;){\n\t    if(X>=0){\n\t      if (map[X][Y]=='*') { map[X][Y]='.'; break; }\n\t      if (map[X][Y]=='#') break;\n\t      X--;\n\t    }else{\n\t      break;\n\t    }\n\t  }\n\t  break;\n\t}\n\tcase 1:{\n\t  int X=x,Y=y;\n\t  for(;;){\n\t    if(X<H){\n\t      if (map[X][Y]=='*') { map[X][Y]='.'; break; }\n\t      if (map[X][Y]=='#') break;\n\t      X++;\n\t    }else{\n\t      break;\n\t    }\n\t  }\n\t  break;\n\t}\n\tcase 2:{\n\t  int X=x,Y=y;\n\t  for(;;){\n\t    if(Y<W){\n\t      if (map[X][Y]=='*') { map[X][Y]='.'; break; }\n\t      if (map[X][Y]=='#') break;\n\t      Y++;\n\t    }else{\n\t      break;\n\t    }\n\t  }\n\t  break;\n\t}\n\tcase 3:{\n\t  int X=x,Y=y;\n\t  for(;;){\n\t    if(Y>=0){\n\t      if (map[X][Y]=='*') { map[X][Y]='.'; break; }\n\t      if (map[X][Y]=='#') break;\n\t      Y--;\n\t    }else{\n\t      break;\n\t    }\n\t  }\n\t  break;\n\t}\n\t}\n      }\n    }\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif (i==x&&j==y){\n\t  switch(d){\n\t  case 0: printf(\"^\"); break;\n\t  case 1: printf(\"v\"); break;\n\t  case 2: printf(\">\"); break;\n\t  case 3: printf(\"<\"); break;\n\t  }\n\t}else{\n\t  printf(\"%c\",map[i][j]);\n\t}\n      }\n      puts(\"\");\n    }\n    if (T!=0) puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\nint H, W;\nstring field[30];\n\nbool check(int y, int x){\n\tif(y < 0 || y >= H || x < 0 || x >= W){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid shoot(int y, int x, char dir){\n\twhile(true){\n\t\tif(dir == '^'){\n\t\t\ty--;\n\t\t}else if(dir == 'v'){\n\t\t\ty++;\n\t\t}else if(dir == '<'){\n\t\t\tx--;\n\t\t}else if(dir == '>'){\n\t\t\tx++;\n\t\t}\n\t\tif(!check(y, x)){\n\t\t\tbreak;\n\t\t}\n\t\tif(field[y][x] == '*'){\n\t\t\tfield[y][x] = '.';\n\t\t\tbreak;\n\t\t}\n\t\tif(field[y][x] == '#'){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint T;\n\tcin >> T;\n\t\n\tfor(int loop = 0; loop < T; loop++){\n\t\t\n\t\tif(loop != 0){\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t\tcin >> H >> W;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcin >> field[i];\n\t\t}\n\t\t\n\t\tchar dir;\n\t\tint pos_x, pos_y;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(field[i][j] == '^' || field[i][j] == 'v' || field[i][j] == '<' || field[i][j] == '>'){\n\t\t\t\t\tdir = field[i][j];\n\t\t\t\t\tpos_y = i;\n\t\t\t\t\tpos_x = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint hoge;\n\t\tcin >> hoge;\n\t\t\n\t\tstring ord;\n\t\t\n\t\tcin >> ord;\n\t\t\n\t\tfor(int i = 0; i < hoge; i++){\n\t\t\tif(ord[i] == 'U'){\n\t\t\t\tdir = '^';\n\t\t\t\tif(check(pos_y - 1, pos_x)){\n\t\t\t\t\tif(field[pos_y - 1][pos_x] == '.'){\n\t\t\t\t\t\tfield[pos_y][pos_x] = '.';\n\t\t\t\t\t\tpos_y -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord[i] == 'D'){\n\t\t\t\tdir = 'v';\n\t\t\t\tif(check(pos_y + 1, pos_x)){\n\t\t\t\t\tif(field[pos_y + 1][pos_x] == '.'){\n\t\t\t\t\t\tfield[pos_y][pos_x] = '.';\n\t\t\t\t\t\tpos_y += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord[i] == 'L'){\n\t\t\t\tdir = '<';\n\t\t\t\tif(check(pos_y, pos_x - 1)){\n\t\t\t\t\tif(field[pos_y][pos_x - 1] == '.'){\n\t\t\t\t\t\tfield[pos_y][pos_x] = '.';\n\t\t\t\t\t\tpos_x -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord[i] == 'R'){\n\t\t\t\tdir = '>';\n\t\t\t\tif(check(pos_y, pos_x + 1)){\n\t\t\t\t\tif(field[pos_y][pos_x + 1] == '.'){\n\t\t\t\t\t\tfield[pos_y][pos_x] = '.';\n\t\t\t\t\t\tpos_x += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ord[i] == 'S'){\n\t\t\t\tshoot(pos_y, pos_x, dir);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfield[pos_y][pos_x] = dir;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcout << field[i] << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nstruct player{\n\tpublic:\n\t\tplayer(char a, int b, int c):dir(a), posX(b), posY(c){}\n\t\tvoid actU(vector<vector<char> > &table){\n\t\t\tif(posY-1<0){\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t\tdir = '^';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY-1][posX] == '.'){\n\t\t\t\ttable[posY--][posX] = '.';\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t}\n\t\t\telse table[posY][posX] = '^';\n\t\t\tdir = '^';\n\t\t}\n\t\tvoid actD(vector<vector<char> > &table){\n\t\t\tif(posY+1>=table.size()){\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t\tdir = 'v';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY+1][posX] == '.'){\n\t\t\t\ttable[posY++][posX] = '.';\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t}\n\t\t\telse table[posY][posX] = 'v';\n\t\t\tdir = 'v';\n\t\t}\n\t\tvoid actL(vector<vector<char> > &table){\n\t\t\tif(posX-1<0){\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t\tdir = '<';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX-1] == '.'){\n\t\t\t\ttable[posY][posX--] = '.';\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t}\n\t\t\telse table[posY][posX] = '<';\n\t\t\tdir = '<';\n\t\t}\n\t\tvoid actR(vector<vector<char> > &table){\n\t\t\tif(posX+1>=table[0].size()){\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t\tdir = '>';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX+1] == '.'){\n\t\t\t\ttable[posY][posX++] = '.';\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t}\n\t\t\telse table[posY][posX] = '>';\n\t\t\tdir = '>';\n\t\t}\n\t\tvoid actS(vector<vector<char> > &table){\n\t\t\tint progressX = 0;\n\t\t\tint progressY = 0;\n\t\t\tif(dir == '^') progressY = -1;\n\t\t\telse if(dir == 'v') progressY = 1;\n\t\t\telse if(dir == '<') progressX = -1;\n\t\t\telse if(dir == '>') progressX = 1;\n\t\t\tint sposX = posX+progressX, sposY = posY+progressY;\n\t\t\twhile((sposX>=0&&sposX<table[0].size())&&(sposY>=0&&sposY<table.size())){\n\t\t\t\tif(table[sposY][sposX] == '*' || table[sposY][sposX] == '#'){\n\t\t\t\t\tif(table[sposY][sposX] == '*') table[sposY][sposX] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsposX += progressX;\n\t\t\t\tsposY += progressY;\n\t\t\t}\n\t\t}\n\t\tchar dir;\n\t\tint posX;\n\t\tint posY;\n};\n\nvoid action(char act, player &p, vector<vector<char> > &table){\n\tswitch(act){\n\tcase 'U':\n\t\tp.actU(table);\n\t\tbreak;\n\tcase 'D':\n\t\tp.actD(table);\n\t\tbreak;\n\tcase 'L':\n\t\tp.actL(table);\n\t\tbreak;\n\tcase 'R':\n\t\tp.actR(table);\n\t\tbreak;\n\tcase 'S':\n\t\tp.actS(table);\n\t\tbreak;\n\tdefault:\n\t\t\tbreak;\n\t}\n\n}\n\nint main(){\n\tint n = 0;\n\tfreopen(\"test.txt\", \"r\", stdin);\n\tcin >> n;\n\twhile(n--){\n\t\tint h = 0, w = 0;\n\t\tcin >> h >> w;\n\t\tvector<vector<char> > table(h, vector<char>(w, ' '));\n\t\tplayer p(' ', -1, -1);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tif(table[i][j]=='^'||table[i][j]=='v'||table[i][j]=='<'||table[i][j]=='>'){\n\t\t\t\t\tp.dir = table[i][j];\n\t\t\t\t\tp.posX = j;\n\t\t\t\t\tp.posY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = 0;\n\t\tcin >> m;\n\t\tvector<char> act(m, ' ');\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> act[i];\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\taction(act[i], p, table);\n\t\t}\n\n\t\tfor(int i = 0; i < table.size(); i++){\n\t\t\tfor(int j = 0; j < table[0].size(); j++){\n\t\t\t\tcout << table[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nvoid Search(vector<string>&, int&, int&);\nvoid GoUp(vector<string>&, int&, int&);\nvoid GoDown(vector<string>&, int&, int&);\nvoid GoLeft(vector<string>&, int&, int&);\nvoid GoRight(vector<string>&, int&, int&);\nvoid ShootUp(vector<string>&, int&, int&);\nvoid ShootDown(vector<string>&, int&, int&);\nvoid ShootLeft(vector<string>&, int&, int&);\nvoid ShootRight(vector<string>&, int&, int&);\n\nint main(){\n  int i, j, n, m, h, w, x, y;\n  string s;\n  vector<string> str;\n\n  cin >> n;\n\n  for(i=0; i<n; ++i){\n    cin >> h >> w;\n\n    for(j=0; j<h; ++j){\n      cin >> s;\n      str.push_back(s);\n    }\n\n    Search(str, x, y);\n    cin >> m >> s;\n\n    for(j=0; j<s.size(); ++j){\n      if(s[j] == 'U') GoUp(str, x, y);\n      else if(s[j] == 'D') GoDown(str, x, y);\n      else if(s[j] == 'L') GoLeft(str, x, y);\n      else if(s[j] == 'R') GoRight(str, x, y);\n      else if(s[j] == 'S' && str[x][y] == '^') ShootUp(str, x, y);\n      else if(s[j] == 'S' && str[x][y] == 'v') ShootDown(str, x, y);\n      else if(s[j] == 'S' && str[x][y] == '<') ShootLeft(str, x, y);\n      else if(s[j] == 'S' && str[x][y] == '>') ShootRight(str, x, y);\n    }\n\n    if(i != 0) cout << endl;\n\n    for(j=0; j<h; ++j)\n      cout << str[j] << endl;\n\n    str.clear();\n  }\n  return 0;\n}\n\nvoid Search(vector<string>& str, int& x, int& y){\n  int i, j;\n  for(i=0, x=-1, y=-1; i<str.size(); ++i){\n    for(j=0; j<str[i].size(); ++j){\n      if(str[i][j] == '^' || str[i][j] == 'v' || str[i][j] == '<' || str[i][j] == '>'){\n\tx = i;\n\ty = j;\n\tbreak;\n      }\n    }\n    if(x != -1 && y != -1) break;\n  }\n}\n\nvoid GoUp(vector<string>& str, int& x, int& y){\n  if(x > 0 && str[x-1][y] == '.'){\n    str[x-1][y] = '^';\n    str[x][y] = '.';\n    --x;\n  }else{\n    str[x][y] = '^';\n  }\n}\n\nvoid GoDown(vector<string>& str, int& x, int& y){\n  if(x < str.size()-1 && str[x+1][y] == '.'){\n    str[x+1][y] = 'v';\n    str[x][y] = '.';\n    ++x;\n  }else{\n    str[x][y] = 'v';\n  }\n}\n\nvoid GoLeft(vector<string>& str, int& x, int& y){\n  if(y > 0 && str[x][y-1] == '.'){\n    str[x][y-1] = '<';\n    str[x][y] = '.';\n    --y;\n  }else{\n    str[x][y] = '<';\n  }\n}\n\nvoid GoRight(vector<string>& str, int& x, int& y){\n  if(y < str[x].size()-1 && str[x][y+1] == '.'){\n    str[x][y+1] = '>';\n    str[x][y] = '.';\n    ++y;\n  }else{\n    str[x][y] = '>';\n  }\n}\n\nvoid ShootUp(vector<string>& str, int& x, int& y){\n  int i;\n  for(i=x-1; i>-1; --i){\n    if(str[i][y] == '*'){\n      str[i][y] = '.';\n      break;\n    }else if(str[i][y] == '#'){\n      break;\n    }\n  }\n}\n\nvoid ShootDown(vector<string>& str, int& x, int& y){\n  int i;\n  for(i=x+1; i<str.size(); ++i){\n    if(str[i][y] == '*'){\n      str[i][y] = '.';\n      break;\n    }else if(str[i][y] == '#'){\n      break;\n    }\n  }\n}\n\nvoid ShootLeft(vector<string>& str, int& x, int& y){\n  int i;\n  for(i=y-1; i>-1; --i){\n    if(str[x][i] == '*'){\n      str[x][i] = '.';\n      break;\n    }else if(str[x][i] == '#'){\n      break;\n    }\n  }\n}\n\nvoid ShootRight(vector<string>& str, int& x, int& y){\n  int i;\n  for(i=y+1; i<str[x].size(); ++i){\n    if(str[x][i] == '*'){\n      str[x][i] = '.';\n      break;\n    }else if(str[x][i] == '#'){\n      break;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint main(void){\n\tint T;\n\tcin>>T;\n\tfor(int i=0,H,W,N;i<T;++i){\n\t\tif(i!=0)cout<<endl;\n\t\tchar field[21][21];\n\t\tint x,y,a;\n\t\tcin>>H>>W;\n\t\tfor(int j=0;j<H;++j){\n\t\t\tstring line;\n\t\t\tcin>>line;\n\t\t\tfor(int k=0;k<=W;++k) field[j][k]=line[k];\n\t\t\t//scanf(\"%s\",field[j]);\n\t\t\tfor(int k=0;k<W;++k)\n\t\t\t\tif(field[j][k]=='^'||field[j][k]=='v'||field[j][k]=='<'||field[j][k]=='>')\n\t\t\t\t\t{\n\t\t\t\t\t\tx=k;y=j;\n\t\t\t\t\t\tif(field[j][k]=='^') a=0;\n\t\t\t\t\t\telse if(field[j][k]=='v') a=1;\n\t\t\t\t\t\telse if(field[j][k]=='<') a=2;\n\t\t\t\t\t\telse if(field[j][k]=='>') a=3;\n\t\t\t\t\t}\n\t\t}\n\t\tstring s;cin>>N;\n\t\tcin>>s;\n\t\tfor(int j=0;j<s.size();++j){\n\t\t\tint dx[]={0,0,-1,1},dy[]={-1,1,0,0};//UDLR\n\t\t\tchar pos[]={'^','v','<','>'};\n\t\t\tif(s[j]=='U'||s[j]=='D'||s[j]=='L'||s[j]=='R'){\n\t\t\t\tif(s[j]=='U') a=0;\n\t\t\t\telse if(s[j]=='D') a=1;\n\t\t\t\telse if(s[j]=='L') a=2;\n\t\t\t\telse if(s[j]=='R') a=3;\n\t\t\t\tif(0<=x+dx[a] && x+dx[a]<W && 0<=y+dy[a] && y+dy[a]<H){\n\t\t\t\t\tif(field[y+dy[a]][x+dx[a]]=='.'){\n\t\t\t\t\t\tfield[y][x]='.';\n\t\t\t\t\t\tx+=dx[a];y+=dy[a];\n\t\t\t\t\t\tfield[y][x]=pos[a];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(s[j]=='S'){\n\t\t\t\tint sx=x+dx[a],sy=y+dy[a];\n\t\t\t\twhile(0<=sx && 0<=sy && sx<W && sy<H){\n\t\t\t\t\tif(field[sy][sx]=='#') break;\n\t\t\t\t\tif(field[sy][sx]=='*'){\n\t\t\t\t\t\tfield[sy][sx]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsx+=dx[a];sy+=dy[a];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<H;++j){\n\t\t\tprintf(\"%s\\n\",field[j]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nint main()\n{\n\tint T;\n\tcin >> T;\n\twhile (T--)\n\t{\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tchar m[32][32];\n\t\tCLEAR(m, '#');\n\t\tfor (int y = 1; y <= h; ++y)\n\t\t{\n\t\t\tcin >> m[y] + 1;\n\t\t\tm[y][w + 1] = '#';\n\t\t}\n\n\t\tconst char* dd = \"v>^<\";\n\t\tint x, y, dir;\n\t\tfor (int yy = 1; yy <= h; ++yy)\n\t\t\tfor (int xx = 1; xx <= w; ++xx)\n\t\t\t\tif (strchr(dd, m[yy][xx]))\n\t\t\t\t{\n\t\t\t\t\tx = xx, y = yy;\n\t\t\t\t\tdir = strchr(dd, m[yy][xx]) - dd;\n\t\t\t\t\tm[yy][xx] = '.';\n\t\t\t\t}\n\n\t\tint n;\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tchar c = s[i];\n\n\t\t\tconst char* dc = \"DRUL\";\n\t\t\tif (strchr(dc, c))\n\t\t\t{\n\t\t\t\tdir = strchr(dc, c) - dc;\n\t\t\t\tint tx = x + dx[dir], ty = y + dy[dir];\n\t\t\t\tif (m[ty][tx] == '.')\n\t\t\t\t\tx = tx, y = ty;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint tx = x + dx[dir], ty = y + dy[dir];\n\t\t\t\twhile (m[ty][tx] != '#')\n\t\t\t\t{\n\t\t\t\t\tif (m[ty][tx] == '*')\n\t\t\t\t\t{\n\t\t\t\t\t\tm[ty][tx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttx += dx[dir], ty += dy[dir];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm[y][x] = dd[dir];\n\n\t\tfor (int yy = 1; yy <= h; ++yy)\n\t\t{\n\t\t\tfor (int xx = 1; xx <= w; ++xx)\n\t\t\t\tcout << m[yy][xx];\n\t\t\tcout << endl;\n\t\t}\n\t\tif (T)\n\t\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {-1, 0, 1, 0};\n    int dx[] = {0, 1, 0, -1};\n    char dirF[] = {'^', '>', 'v', '<'};\n    char dirC[] = {'U', 'R', 'D', 'L'};\n\n    int t;\n    cin >> t;\n    while(--t >= 0){\n        int h, w, n;\n        cin >> h >> w;\n        vector<string> field(h);\n        for(int i=0; i<h; ++i)\n            cin >> field[i];\n        string command;\n        cin >> n >> command;\n\n        int y, x, dir;\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                int d = find(dirF, dirF+4, field[i][j]) - dirF;\n                if(d != 4){\n                    y = i;\n                    x = j;\n                    dir = d;\n                    field[y][x] = '.';\n                }\n            }\n        }\n\n        for(int i=0; i<n; ++i){\n            int d = find(dirC, dirC+4, command[i]) - dirC;\n            if(d < 4){\n                int y1 = y + dy[d];\n                int x1 = x + dx[d];\n                if(0 <= y1 && y1 < h && 0 <= x1 && x1 < w && field[y1][x1] == '.'){\n                    y = y1;\n                    x = x1;\n                }\n                dir = d;\n            }else{\n                int y1 = y;\n                int x1 = x;\n                for(;;){\n                    y1 += dy[dir];\n                    x1 += dx[dir];\n                    if(y1 < 0 || y1 >= h || x1 < 0 || x1 >= w)\n                        break;\n                    if(field[y1][x1] == '*'){\n                        field[y1][x1] = '.';\n                        break;\n                    }\n                    if(field[y1][x1] == '#')\n                        break;\n                }\n            }\n        }\n\n        field[y][x] = dirF[dir];\n        for(int i=0; i<h; ++i)\n            cout << field[i] << endl;\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef struct TankState{\n  int x, y, dir;//u:0, r:1, d:2, l:3\n}TankState;\n\nbool range(int x, int y, int w, int h){\n  return (0 <= x and x < w) and (0 <= y and y < h);\n}\n\nint main(){\n  int n;\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {-1, 0, 1, 0};\n  std::cin >> n;\n  for (int l = 0; l < n; l++) {\n    TankState pos;\n    int h, w;\n    std::cin >> h >> w;\n    vector<string> vs(h);\n    for (int i = 0; i < h; i++) std::cin >> vs[i];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(vs[i][j] == '^')pos.x = j, pos.y = i, pos.dir = 0;\n        if(vs[i][j] == '>')pos.x = j, pos.y = i, pos.dir = 1;\n        if(vs[i][j] == 'v')pos.x = j, pos.y = i, pos.dir = 2;\n        if(vs[i][j] == '<')pos.x = j, pos.y = i, pos.dir = 3;\n      }\n    }\n    string operation;\n    int tmp;\n    std::cin >> tmp >> operation;\n    for (int i = 0; i < operation.length(); i++) {\n      if(operation[i] == 'S'){\n        int x = pos.x, y = pos.y;\n        while(range(x, y, w, h) and \n              vs[y][x] != '*' and vs[y][x] != '#')\n          y += dy[pos.dir], x += dx[pos.dir];\n        if(range(x, y, w, h) and vs[y][x] == '*')vs[y][x] = '.';\n      }else if(operation[i] == 'U'){\n        pos.dir = 0;\n        if(range(pos.x, pos.y - 1, w, h) and\n           vs[pos.y - 1][pos.x] == '.'){\n          vs[pos.y - 1][pos.x] = '^';\n          vs[pos.y][pos.x] = '.';\n          pos.y -= 1;\n        }else{\n          vs[pos.y][pos.x] = '^';\n        }\n      }else if(operation[i] == 'R'){\n        pos.dir = 1;\n        if(range(pos.x + 1, pos.y, w, h) and\n           vs[pos.y][pos.x + 1] == '.'){\n          vs[pos.y][pos.x + 1] = '>';\n          vs[pos.y][pos.x] = '.';\n          pos.x += 1;\n        }else{\n          vs[pos.y][pos.x] = '>';\n        }\n      }else if(operation[i] == 'D'){\n        pos.dir = 2;\n        if(range(pos.x, pos.y + 1, w, h) and\n           vs[pos.y + 1][pos.x] == '.'){\n          vs[pos.y + 1][pos.x] = 'v';\n          vs[pos.y][pos.x] = '.';\n          pos.y += 1;\n        }else{\n          vs[pos.y][pos.x] = 'v';\n        }\n      }else if(operation[i] == 'L'){\n        pos.dir = 3;\n        if(range(pos.x - 1, pos.y, w, h) and\n           vs[pos.y][pos.x - 1] == '.'){\n          vs[pos.y][pos.x - 1] = '<';\n          vs[pos.y][pos.x] = '.';\n          pos.x -= 1;\n        }else{\n          vs[pos.y][pos.x] = '<';\n        }\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      std::cout << vs[i] << std::endl;\n    }\n    if(l != n - 1)std::cout << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2103.cpp\n *\n *  Created on: 2012/07/08\n *      Author: shimomire\n */\n\n#include <iostream>\n#include<algorithm>\n#include <complex>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define REPr(i,b,n) for(int i=n-1;i>=b;i--)\n#define REPr0(i,n)   REPr(i,0,n)\n\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\n#define ALL(o) (o).begin(),(o).end()\n#define ARRSIZE(x) (sizeof(x)/sizeof(x[0]))\n#define ARRALL(x) x,x+ARRSIZE(x)\n\ntypedef complex<double> P;\nbool operator <(const P& a, const P& b) {\n\treturn make_pair(real(a), imag(a)) < make_pair(real(b), imag(b));\n}\n\nint N, H, W;\n\nstring map[30];\n\nint main() {\n\tcin >> N;\n\n\twhile (N-- != 0) {\n\t\tcin >> H >> W;\n\n\t\tpair<int, int> pos;\n\t\tREP0(h,H){\n\t\t\tcin >>map[h];\n\t\t\tREP0(w,W) {\n\t\t\t\tif (map[h][w] == '^' || map[h][w] == '<' || map[h][w] == '>'\n\t\t\t\t\t\t|| map[h][w] == 'v') {\n\t\t\t\t\tpos = make_pair(h, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\tREP0(m,M) {\n\t\t\tchar op;\n\t\t\tcin >> op;\n\t\t\tswitch (op) {\n\t\t\tcase 'S':\n\t\t\t\tswitch (map[pos.first][pos.second]) {\n\t\t\t\tcase '^':\n\t\t\t\t\tfor (int h = pos.first - 1; h >= 0; h--) {\n\t\t\t\t\t\tif (map[h][pos.second] == '*') {\n\t\t\t\t\t\t\tmap[h][pos.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[h][pos.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tfor (int h = pos.first + 1; h < H; h++) {\n\t\t\t\t\t\tif (map[h][pos.second] == '*') {\n\t\t\t\t\t\t\tmap[h][pos.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[h][pos.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tfor (int w = pos.second - 1; w >= 0; w--) {\n\t\t\t\t\t\tif (map[pos.first][w] == '*') {\n\t\t\t\t\t\t\tmap[pos.first][w] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[pos.first][w] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tfor (int w = pos.second + 1; w < W; w++) {\n\t\t\t\t\t\tif (map[pos.first][w] == '*') {\n\t\t\t\t\t\t\tmap[pos.first][w] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[pos.first][w] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tmap[pos.first][pos.second] = '^';\n\t\t\t\tif (pos.first >= 1 && map[pos.first - 1][pos.second] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first - 1][pos.second] = '^';\n\t\t\t\t\tpos.first--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tmap[pos.first][pos.second] = 'v';\n\t\t\t\tif (pos.first < H - 1\n\t\t\t\t\t\t&& map[pos.first + 1][pos.second] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first + 1][pos.second] = 'v';\n\t\t\t\t\tpos.first++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':\n\t\t\t\tmap[pos.first][pos.second] = '>';\n\t\t\t\tif (pos.second < W - 1\n\t\t\t\t\t\t&& map[pos.first][pos.second + 1] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first][pos.second + 1] = '>';\n\t\t\t\t\tpos.second++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tmap[pos.first][pos.second] = '<';\n\t\t\t\tif (pos.second >= 1 && map[pos.first][pos.second - 1] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first][pos.second - 1] = '<';\n\t\t\t\t\tpos.second--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ends;\n\t\tREP0(h,H) {\n\t\t\tcout<<map[h]<< endl;\n\t\t}\n\t\tcout <<ends<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint h, w;\nchar f[21][21];\npoint now;\nint nowdir;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nchar car[5]=\">^<v\";\n\nvoid move(char c){\n\t//????????¢???\n\tif(c=='R') nowdir=0;\n\telse if(c=='U') nowdir=1;\n\telse if(c=='L') nowdir=2;\n\telse if(c=='D') nowdir=3;\n\t\n\t//?¬????????????´???\n\tint nx=now.x+dx[nowdir];\n\tint ny=now.y+dy[nowdir];\n\t\n\t//?§?????????????????§????\n\tif(0<=nx && nx<w && 0<=ny && ny<h && f[ny][nx]=='.'){\n\t\tf[ny][nx]=car[nowdir];\n\t\tf[now.y][now.x]='.';\n\t\tnow.x=nx;\n\t\tnow.y=ny;\n\t}\n}\n\nvoid printField(){\n\tfor(int i=0; i<h; ++i){\n\t\tfor(int j=0; j<w; ++j){\n\t\t\tprintf(\"%c\", f[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\t\n}\n\nvoid shoot(){\n\tint t=1; //???????????????\n\n\twhile(1){\n\t\tint nx=t*dx[nowdir]+now.x;\t\n\t\tint ny=t*dy[nowdir]+now.y;\n\t\t\n\t\tif(nx<0 || w<=nx || ny<0 || h<ny) break;\n\t\t\n\t\tif(f[ny][nx]=='*'){\n\t\t\tf[ny][nx]='.';\n\t\t\tbreak;\t\n\t\t}\n\t\telse if(f[ny][nx]=='#') break;\t\n\t\t\t\n\t\tt++;\t\t\t\n\t}\n}\n\nint main(){\t\n\tint times;\n\tcin >> times;\n\tfor(int t=0; t<times; ++t){\n\t\tscanf(\" %d %d\", &h, &w);\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\tfor(int j=0; j<w; ++j){\n\t\t\t\tscanf(\" %c\", &f[i][j]);\n\t\t\t\t\n\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\tif(f[i][j]==car[k]){\t\n\t\t\t\t\t\tnowdir=k;\n\t\t\t\t\t\tnow.x=j;\n\t\t\t\t\t\tnow.y=i;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n;\n\t\tstring order;\n\t\tscanf(\" %d\", &n);\n\t\tcin >> order;\n\t\t\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(order[i]=='S') shoot();\n\t\t\telse move(order[i]);\n\t\t\t/*\n\t\t\tprintf(\"nowdir=%d\\n\", nowdir);\n\t\t\tprintField();\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t}\n\t\t\n\t\tprintField();\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <string>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define dm(x) cerr << #x << \" = \" << x << endl;\nusing namespace std;\n\nchar map[20][21];\nint H,W,N;\n\nstruct po{\n  int x;\n  int y;\n  po operator+(po &p){\n    po t={x+p.x, y+p.y};\n    return t;\n  }\n  char &l(){return map[x][y];}\n  bool v(){return 0<=x && x<H && 0<=y && y<W;}\n  void d(){dm(x);dm(y);}\n};\n\npo mp(int x,int y){\n  po t={x, y};\n  return t;\n}\n\nint main()\n{\n  int T;\n  scanf(\"%d\", &T);\n  rep(datasetindex, T){\n    po p={0,0},d={0,0};\n    char c[101];\n    scanf(\"%d %d\", &H, &W);\n    rep(i,H) scanf(\"%s\", map[i]);\n    scanf(\"%d\", &N);\n    scanf(\"%s\", c);\n    //dm(H);dm(W);\n    rep(j,W) rep(i,H){\n      switch(map[i][j]){\n      case '^':p=mp(i,j);d=mp(-1,0);break;\n      case '>':p=mp(i,j);d=mp(0,1);break;\n      case 'v':p=mp(i,j);d=mp(1,0);break;\n      case '<':p=mp(i,j);d=mp(0,-1);break;\n      }\n    }\n    //rep(i,H) printf(\"%d : %s\\n\", i, map[i]);\n    //p.d();d.d();\n    rep(i,N){\n      switch(c[i]){\n      case 'S':{\n        po s=p;\n        do{s=s+d;}while(s.v() && s.l()!='*' && s.l()!='#');\n        if(s.v() && s.l()=='*')\n          s.l()='.';\n        break;\n      }\n      case 'U':\n        p.l()='.';\n        d=mp(-1,0);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='^';\n        break;\n      case 'R':\n        p.l()='.';\n        d=mp(0,1);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='>';\n        break;\n      case 'D':\n        p.l()='.';\n        d=mp(1,0);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='v';\n        break;\n      case 'L':\n        p.l()='.';\n        d=mp(0,-1);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='<';\n        break;\n      }\n      //rep(i,H) printf(\"%d : %s\\n\", i, map[i]);\n    }\n    rep(i,H) printf(\"%s\\n\",map[i]);\n    if(datasetindex<T-1)\n      printf(\"\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nchar town[21][21];\npair<int, int> p;\n\n// ú»\nvoid initTown(int h, int w){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\ttown[i][j] = '#';\n\t\t}\n\t}\n}\n\n// eÌÊ\nvoid shoot(int y, int x, int direction){\n\tif(town[y][x] == '#'){\n\t\treturn;\n\t}\n\tif(town[y][x] == '*'){\n\t\ttown[y][x] = '.';\n\t\treturn;\n\t}\n\t\n\tif(y > 0 && direction == 0){\n\t\tshoot(y - 1, x, 0);\n\t}\n\telse if(direction == 1){\n\t\tshoot(y, x + 1, 1);\n\t}\n\telse if(direction == 2){\n\t\tshoot(y + 1, x, 2);\n\t}\n\telse if(x > 0 && direction == 3){\n\t\tshoot(y, x - 1, 3);\n\t}\n\t\n\treturn;\n}\n\n// íÔÌì\nvoid control(int n){\n\tchar cont;\n\tfor(; n > 0; --n){\n\t\tscanf(\" %c\", &cont);\n\t\tif(cont == 'U'){\n\t\t\tif(p.first > 0 && town[p.first - 1][p.second] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\n\t\t\t\ttown[p.first - 1][p.second] = '^';\n\t\t\t\tp.first--;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = '^';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'D'){\n\t\t\tif(town[p.first + 1][p.second] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\t\n\t\t\t\ttown[p.first + 1][p.second] = 'v';\n\t\t\t\tp.first++;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = 'v';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'L'){\n\t\t\tif(p.second > 0 && town[p.first][p.second - 1] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\n\t\t\t\ttown[p.first][p.second - 1] = '<';\n\t\t\t\tp.second--;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = '<';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'R'){\n\t\t\tif(town[p.first][p.second + 1] == '.'){\n\t\t\t\ttown[p.first][p.second] = '.';\n\t\t\t\ttown[p.first][p.second + 1] = '>';\n\t\t\t\tp.second++;\n\t\t\t}else{\n\t\t\t\ttown[p.first][p.second] = '>';\n\t\t\t}\n\t\t}\n\t\telse if(cont == 'S'){\n\t\t\tif(town[p.first][p.second] == '^'){\n\t\t\t\tshoot(p.first, p.second, 0);\n\t\t\t}\n\t\t\telse if(town[p.first][p.second] == '>'){\n\t\t\t\tshoot(p.first, p.second, 1);\n\t\t\t}\t\n\t\t\telse if(town[p.first][p.second] == 'v'){\n\t\t\t\tshoot(p.first, p.second, 2);\n\t\t\t}\n\t\t\telse if(town[p.first][p.second] == '<'){\n\t\t\t\tshoot(p.first, p.second, 3);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\nint main(){\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor(;t > 0; --t){\n\t\tint h,w;\n\t\tscanf(\"%d %d\", &h, &w);\n\t\tinitTown(21, 21);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", town[i]);\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(town[i][j] == '^' || town[i][j] == '<' || town[i][j] == '>' || town[i][j] == 'v'){\n\t\t\t\t\tp.first = i;\n\t\t\t\t\tp.second = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tcontrol(n);\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tprintf(\"%c\", town[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t\n\t}\n\treturn 0;\n\t\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr int dx[4] = {1, -1, 0, 0};\nconstexpr int dy[4] = {0, 0, 1, -1};\nchar decode[4] = {'>', '<', 'v', '^'};\nint encode[256];\n\nvoid init() {\n\tmemset(encode, -1, sizeof(encode));\n\tfor(int i = 0; i < 4; ++i) encode[decode[i]] = i;\n\tencode['R'] = 0;\n\tencode['L'] = 1;\n\tencode['D'] = 2;\n\tencode['U'] = 3;\n}\n\nvoid solve() {\n\tint h, w;\n\tcin >> h >> w;\n\n\tvector<string> field(h + 2, string(w + 2, '#'));\n\tfor(int i = 1; i <= h; ++i) {\n\t\tfor(int j = 1; j <= w; ++j) {\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\n\tint n;\n\tstring command;\n\tcin >> n >> command;\n\n\tint x, y, d;\n\tfor(int i = 1; i <= h; ++i) {\n\t\tfor(int j = 1; j <= w; ++j) {\n\t\t\tif(encode[field[i][j]] != -1) {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t\td = encode[field[i][j]];\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t}\n\n\tassert(false);\n\nnext:\n\tfor(const auto &operation : command) {\n\t\tif(operation == 'S') {\n\t\t\tint cx = x + dx[d], cy = y + dy[d];\n\t\t\twhile(field[cy][cx] == '.' || field[cy][cx] == '-') {\n\t\t\t\tcx += dx[d];\n\t\t\t\tcy += dy[d];\n\t\t\t}\n\t\t\tif(field[cy][cx] == '*') field[cy][cx] = '.';\n\t\t}\n\t\telse {\n\t\t\td = encode[operation];\n\t\t\tif(field[y + dy[d]][x + dx[d]] == '.') {\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tx = x + dx[d];\n\t\t\t\ty = y + dy[d];\n\t\t\t}\n\t\t}\n\t}\n\n\tfield[y][x] = decode[d];\n\n\tfor(int i = 1; i <= h; ++i) {\n\t\tcout << field[i].substr(1, w) << endl;\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tinit();\n\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tsolve();\n\t\tif(t) cout << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<cstring>\n#include<iostream>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> pin;\ntypedef std::pair<int,std::pair<int, int> > ppin;\n\nusing namespace std;\n\nchar ma[22][22];\n\nint main(){\n    \n    int n;\n    cin>>n;\n    while(n--){\n        int a,b;\n        cin>>a>>b;\n        int x=0,y=0,d=0;\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cin>>ma[i][j];\n                if(ma[i][j]=='^'){\n                    y=i; x=j; d=0;\n                }\n                if(ma[i][j]=='v'){\n                    y=i; x=j; d=1;\n                }\n                if(ma[i][j]=='<'){\n                    y=i; x=j; d=2;\n                }\n                if(ma[i][j]=='>'){\n                    y=i; x=j; d=3;\n                }\n            }\n        }\n        \n        int str;\n        cin>>str;\n        string s;\n        cin>>s;\n        for(int k=0;k<s.length();k++){\n            switch(s[k]){\n                case 'U':\n                    \n                    d=0;\n                    if(ma[y-1][x]!='.'||y==0)\n                        continue;\n                    y--;\n                    ma[y+1][x]='.';\n                    ma[y][x]='^';\n                    break;\n                case 'D':\n                    d=1;\n                    if(ma[y+1][x]!='.'||y+1==a)\n                        continue;\n                    \n                    y++;\n                    ma[y-1][x]='.';\n                    ma[y][x]='v';\n                    break;\n                case 'L':\n                    d=2;\n                    if(ma[y][x-1]!='.'||x==0)\n                        continue;\n                    \n                    x--;\n                    ma[y][x+1]='.';\n                    ma[y][x]='<';\n                    break;\n                case 'R':\n                    d=3;\n                    if(ma[y][x+1]!='.'||x+1==b)\n                        continue;\n                    \n                    x++;\n                    ma[y][x-1]='.';\n                    ma[y][x]='>';\n                    break;\n                case 'S':\n                    switch(d){\n                        case 0:\n                            for(int i=y-1;i>=0;i--){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    cout<<\"H\"<<endl;\n                                    break;\n                                }\n                            }\n                            break;\n                        case 1:\n                            for(int i=y+1;i<a;i++){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 2:\n                            for(int i=x-1;i>=0;i--){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 3:\n                            for(int i=x+1;i<b;i++){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                    }\n//                    for(int i=0;i<a;i++){\n//                        for(int j=0;j<b;j++){\n//                            cout<<ma[i][j];\n//                        }\n//                        cout<<endl;\n//                    }\n//                    cout<<endl;\n                    break;\n            }\n        }\n        switch(d){\n            case 0:\n                ma[y][x]='^';\n                break;\n            case 1:\n                ma[y][x]='v';\n                break;\n            case 2:\n                ma[y][x]='<';\n                break;\n            case 3:\n                ma[y][x]='>';\n                break;\n        }\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cout<<ma[i][j];\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\nint main( void )\n{\n\tint T;\n\tcin >> T;\n\n\tfor ( int lpc = 0; lpc < T; lpc++ )\n\t{\n\t\t// }bv\n\t\tint W, H;\n\t\tcin >> H >> W;\n\n\t\tvector <string> map(H);\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t\tcin >> map[i];\n\n\t\t// ú»\n\t\tint x;\n\t\tint y;\n\t\tint a;\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < W; j++ )\n\t\t\t{\n\t\t\t\t// íÔÌê\n\t\t\t\ta = (map[i][j]=='^')?1:(map[i][j]=='v')?2:(map[i][j]=='<')?3:(map[i][j]=='>')?4:a;\n\t\t\t\tswitch(map[i][j]) { case '^':case 'v':case '<':case '>': x = j; y = i;map[i][j]='.'; }\n\t\t\t}\n\t\t}\n\n\t\tcout << x << \" \" << y << \" \" << a << endl;\n\n\t\t// ì\n\t\tint N;\n\t\tcin >> N;\n\t\t\n\t\tstring ops;\n\t\tcin >> ops;\n\t\tistringstream is(ops);\n\t\tfor ( int i = 0; i < N; i++ )\n\t\t{\n\t\t\tchar op;\n\t\t\tis >> op;\n\t\t\tif ( op == 'U' )\n\t\t\t{\n\t\t\t\ta = 1;\n\t\t\t\tif ( y-1 >= 0 && map[y-1][x] == '.' )\n\t\t\t\t{\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( op == 'D' )\n\t\t\t{\n\t\t\t\ta = 2;\n\t\t\t\tif ( y+1 < H && map[y+1][x] == '.' )\n\t\t\t\t\ty++;\n\t\t\t}\n\t\t\telse if ( op == 'L' )\n\t\t\t{\n\t\t\t\ta = 3;\n\t\t\t\tif ( x-1 >= 0 && map[y][x-1] == '.' )\n\t\t\t\t\tx--;\n\t\t\t}\n\t\t\telse if ( op == 'R' )\n\t\t\t{\n\t\t\t\ta = 4;\n\t\t\t\tif ( x+1 < W && map[y][x+1] == '.' )\n\t\t\t\t\tx++;\n\t\t\t}\n\t\t\telse if ( op == 'S' )\n\t\t\t{\n\t\t\t\tint nx = x;\n\t\t\t\tint ny = y;\n\t\t\t\twhile (1)\n\t\t\t\t{\n\t\t\t\t\tnx = ((a==3)?nx-1:(a==4?nx+1:nx));\n\t\t\t\t\tny = ((a==1)?ny-1:(a==2?ny+1:ny));\n\t\t\t\t\tif ( nx < 0 || nx >= W || ny < 0 || ny >= H )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif ( map[ny][nx] == '#' )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif ( map[ny][nx] == '*' )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ny][nx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tmap[y][x] = ((a==1)?'^':(a==2)?'v':(a==3)?'<':(a==4)?'>':' ');\n\n\t\t// oÍ\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < W; j++ )\n\t\t\t{\n\t\t\t\tcout << map[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t} // while\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[20][21], t[4]={'^','>','v','<'};\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\t//ã0 E1 º2 ¶3\nint T, H, W, N;\nstruct {int x, y, a;} p;\t//íÔÌ éÀW,íÔÌü«\nvoid shoot(int x, int y, int a)\n{\n\twhile (0 <= x+dx[a] && x+dx[a] <= W && 0 <= y+dy[a] && y+dy[a] <= H)\n\t{\n\t\tx+=dx[a], y+=dy[a];\n\t\tif (m[y][x]=='*')\n\t\t{\n\t\t\tm[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t\telse if (m[y][x]=='#')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar o[101]=\"\";\n\tint i, j, nx, ny;\n\tcin >> T;\n\tfor (; T > 0; T--)\n\t{\n\t\tcin >> H >> W;\n\t\tfor (i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tswitch (m[i][j])\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t\tp.x=j, p.y=i, p.a=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tp.x=j, p.y=i, p.a=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tp.x=j, p.y=i, p.a=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tp.x=j, p.y=i, p.a=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[i][j]='\\0';\n\t\t}\n\t\tcin >> N >> o;\n\t\tif (T > 1)\n\t\t\tcout << endl;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tswitch (o[i])\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\tp.a=0;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tp.a=2;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tp.a=3;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tp.a=1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshoot(p.x, p.y, p.a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx=p.x+dx[p.a], ny=p.y+dy[p.a];\n\t\t\tif (o[i] != 'S' && m[ny][nx]=='.')\n\t\t\t{\n\t\t\t\tm[p.y][p.x]='.';\n\t\t\t\tp.x=nx, p.y=ny;\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < H; i++)\n\t\t\tcout << m[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#define F first\n#define S second\n\nusing namespace std;\nint H,W,dir,x,y;//dir 0->U 1->D 2->L 3->R\nchar cmap[30][30],tank[4] = {'^','v','<','>'};\nstring op;\nint dx[4] = {0,0,-1,1};// U D L R\nint dy[4] = {-1,1,0,0};\n\nvoid op_U(){\n  dir = 0;\n  if( 0 <= y-1 && cmap[y-1][x] == '.'){\n    cmap[y][x] = '.';\n    y--;\n    cmap[y][x] = tank[dir];\n  }\n}\n\nvoid op_D(){\n  dir = 1;\n  if(y+1<H && cmap[y+1][x] == '.'){\n    cmap[y][x] = '.';\n    y++;\n    cmap[y][x] = tank[dir];\n  }\n}\n\nvoid op_L(){\n  dir = 2;\n  if(0<=x-1 && cmap[y][x-1] == '.'){\n    cmap[y][x] = '.';\n    x--;\n    cmap[y][x] = tank[dir];\n  }\n}\n\nvoid op_R(){\n  dir = 3;\n  if(x+1<W && cmap[y][x+1] == '.'){\n    cmap[y][x] = '.';\n    x++;\n    cmap[y][x] = tank[dir];\n  }\n}\n\nvoid op_S(){\n  int cnt=1;\n  while(true){\n    if(!( 0<=x+dx[dir]*cnt  && x+dx[dir]*cnt < W && 0<=y+dy[dir]*cnt && y+dy[dir]*cnt < H) )break;\n    if(cmap[y+dy[dir]*cnt][x+dx[dir]*cnt] == '*'){\n      cmap[y+dy[dir]*cnt][x+dx[dir]*cnt] = '.';\n      break;\n    }\n    else if(cmap[y+dy[dir]*cnt][x+dx[dir]*cnt] == '#'){\n      break;\n    }\n    cnt++;\n  }\n}\n\nvoid display(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cout << cmap[i][j];\n    }\n    cout << endl;\n  }\n}\n\nvoid solve(){\n  for(int i=0;i<op.length();i++){\n    if(op[i] == 'U')op_U();\n    else if(op[i] == 'D')op_D();\n    else if(op[i] == 'L')op_L();\n    else if(op[i] == 'R')op_R();\n    else if(op[i] == 'S')op_S();\n  }\n  display();\n}\n\n\n\n\nint main(){\n  int T,enu;\n  cin >> T;\n  while(T-- > 0){\n    cin >> H >> W;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> cmap[i][j];\n\tif(cmap[i][j] == '^'){\n\t  dir = 0;\n\t  x = j; y = i;\n\t}\n\telse if(cmap[i][j] == 'v'){\n\t  dir = 1;\n\t  x = j; y = i;\n\t}\n\telse if(cmap[i][j] == '<'){\n\t  dir = 2;\n\t  x = j; y = i;\n\t}\n\telse if(cmap[i][j] == '>'){\n\t  dir = 3;\n\t  x = j; y = i;\n\t}\n      }\n    }\n    cin >> enu;\n    cin >> op;\n    solve();\n    if(T > 0)cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\ntypedef pair<int,int> pii;\n\ntypedef vector<int> vint;\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\n#define mkp make_pair\nint h,w;\npair<pii,int> foo1(vector<string> &v){\n\tstring vec=\">v<^\";\n\trep(i,v.size()){\n\t\trep(j,v[i].size()){\n\t\t\trep(k,4){\n\t\t\t\tif(v[i][j]==vec[k]){\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t\treturn mkp(pii(i,j),k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mkp(pii(-1,-1),-1);\n}\nbool check(int a,int b){\n\tif(0<=a&&a<h&&0<=b&&b<w) return true;\n\treturn false;\n}\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\trep(o,n){\n\t\tif(o) cout<<endl;\n\t\tcin>>h>>w;\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tstring s;\n\t\tint t;\n\t\tcin>>t>>s;\n\t\tint dd[]={0,1,0,-1,0};// >,v,<,^\n\t\tpair<pii,int> pos=foo1(v);\n\t\tstring DRUL=\"RDLU\";\n\t\t//SRSSRRUSSR\n\t\trep(i,s.size()){\n\t\t\t// cout<<pos.F.F<<\" \"<<pos.F.S<<\" \"<<pos.S<<endl;\n\t\t\t// rep(j,h) cout<<v[j]<<endl;\n\t\t\t// cout<<endl;\n\t\t\tif(s[i]=='S'){\n\t\t\t\tint y=pos.F.F;\n\t\t\t\tint x=pos.F.S;\n\t\t\t\ty+=dd[pos.S];\n\t\t\t\tx+=dd[pos.S+1];\n\t\t\t\twhile(check(y,x)){\n\t\t\t\t\tif(v[y][x]=='#') break;\n\t\t\t\t\tif(v[y][x]=='*'){\n\t\t\t\t\t\tv[y][x]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ty+=dd[pos.S];\n\t\t\t\t\tx+=dd[pos.S+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(j,4){\n\t\t\t\t\tif(\"RDLU\"[j]==s[i]){\n\t\t\t\t\t\tpos.S=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint ny=pos.F.F+dd[pos.S];\n\t\t\t\tint nx=pos.F.S+dd[pos.S+1];\n\t\t\t\tif(check(ny,nx)&&v[ny][nx]=='.'){\n\t\t\t\t\tpos.F=pii(ny,nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv[pos.F.F][pos.F.S]=\">v<^\"[pos.S];\n\t\trep(i,h){\n\t\t\tcout<<v[i]<<endl;\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(0);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nint t;\nint h, w, n;\nstring field[100];\nstring s;\nP pos;\n\nvoid solve(char c){\n\tint y = pos.first, x = pos.second;\n\tif (c == 'U'){\n\t\tif (y != 0){\n\t\t\tif (field[y - 1][x] == '.'){\n\t\t\t\tfield[y - 1][x] = '^';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\ty--;\n\t\t\t}\n\t\t\telse field[y][x] = '^';\n\t\t}\n\t\telse field[y][x] = '^';\n\t}\n\telse if (c == 'D'){\n\t\tif (y != h - 1){\n\t\t\tif (field[y + 1][x] == '.'){\n\t\t\t\tfield[y + 1][x] = 'v';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\ty++;\n\t\t\t}\n\t\t\telse field[y][x] = 'v';\n\t\t}\n\t\telse field[y][x] = 'v';\n\t}\n\telse if (c == 'L'){\n\t\tif (x != 0){\n\t\t\tif (field[y][x - 1] == '.'){\n\t\t\t\tfield[y][x - 1] = '<';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tx--;\n\t\t\t}\n\t\t\telse field[y][x] = '<';\n\t\t}\n\t\telse field[y][x] = '<';\n\t}\n\telse if (c == 'R'){\n\t\tif (x != w - 1){\n\t\t\tif (field[y][x + 1] == '.'){\n\t\t\t\tfield[y][x + 1] = '>';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse field[y][x] = '>';\n\t\t}\n\t\telse field[y][x] = '>';\n\t}\n\telse{\n\t\tint cy = y, cx = x;\n\t\tif (field[y][x] == '^'){\n\t\t\twhile (cy >= 0){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcy--;\n\t\t\t}\n\t\t}\n\t\telse if (field[y][x] == 'v'){\n\t\t\twhile (cy <= h - 1){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcy++;\n\t\t\t}\n\t\t}\n\t\telse if (field[y][x] == '<'){\n\t\t\twhile (cx >= 0){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcx--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (cx <= w - 1){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t}\n\t//REP(i, h){\n\t//\tREP(j, w){\n\t//\t\tcout << field[i][j];\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\tpos = P(y, x);\n}\n\nint main(){\n\tcin >> t;\n\twhile (t--){\n\t\tcin >> h >> w;\n\t\tREP(i, h){\n\t\t\tcin >> field[i];\n\t\t\tREP(j, w){\n\t\t\t\tif (field[i][j] == '^' || field[i][j] == 'v'\n\t\t\t\t\t|| field[i][j] == '>' || field[i][j] == '<'){\n\t\t\t\t\tpos = P(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> n >> s;\n\t\tREP(i, n){\n\t\t\tsolve(s[i]);\n\t\t}\n\t\tREP(i, h){\n\t\t\tREP(j, w){\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tif (t != 1)cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w, h, tx, ty, d;\nint dx[] = {0,0,1,-1};\nint dy[] = {-1,1,0,0};\nchar dir[256];\nstring f[21];\n\nvoid solve(string s){\n\tfor(int j=0 ; j < (int)s.size() ; j++ ){\n\t\tchar c = s[j];\n\t\tif( c == 'S' ){\n\t\t\tint sx = tx;\n\t\t\tint sy = ty;\n\t\t\tfor(;;){\n\t\t\t\tint mx = sx + dx[ dir[d] ];\n\t\t\t\tint my = sy + dy[ dir[d] ];\n\t\t\t\tif( mx < 0 || my < 0 || mx > w || my > h ){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if( f[my][mx] == '.' || f[my][mx] == '-' ){\n\t\t\t\t\tsx = mx;\n\t\t\t\t\tsy = my;\n\t\t\t\t}else if( f[my][mx] == '*' ){\n\t\t\t\t\tf[my][mx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}else if( f[my][mx] == '#' ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\td = dir[c];\n\t\t\tint mx = tx + dx[ dir[d] ];\n\t\t\tint my = ty + dy[ dir[d] ];\n\t\t\tif( mx < 0 || my < 0 || mx > w || my > h ){\n\t\t\t\tcontinue;\n\t\t\t}else if( f[my][mx] == '.' ){\n\t\t\t\ttx = mx;\n\t\t\t\tty = my;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint t, n;\n\tstring s;\n\t\n\tdir['U'] = '^';\n\tdir['D'] = 'v';\n\tdir['R'] = '>';\n\tdir['L'] = '<';\n\tdir['^'] = 0;\n\tdir['v'] = 1;\n\tdir['>'] = 2;\n\tdir['<'] = 3;\n\t\n\tcin >> t;\n\tfor(int i=0 ; i < t ; i++ ){\n\t\tcin >> h >> w;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> f[y];\n\t\t}\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tchar c = f[y][x];\n\t\t\t\tif( c == '>' || c == '<' || c == '^' || c == 'v' ){\n\t\t\t\t\ttx = x;\n\t\t\t\t\tty = y;\n\t\t\t\t\td = c;\n\t\t\t\t\tf[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> n;\n\t\tcin >> s;\n\t\tsolve( s );\n\t\tf[ty][tx] = d;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcout << f[y] << endl;\n\t\t}\n\t\tif( i != t-1 ) cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint W, H, x, y;\n\nvoid Move(char c, vector<string> &map)\n{\n    if (c == 'U') {\n        map[y][x] = '^';\n        if (y - 1 >= 0 && map[y - 1][x] == '.') {\n            swap(map[y][x], map[y - 1][x]);\n            --y;\n        }\n    }\n    else if (c == 'D') {\n        map[y][x] = 'v';\n        if (y + 1 < H && map[y + 1][x] == '.') {\n            swap(map[y][x], map[y + 1][x]);\n            ++y;\n        }\n    }\n    else if (c == 'L') {\n        map[y][x] = '<';\n        if (x - 1 >= 0 && map[y][x - 1] == '.') {\n            swap(map[y][x], map[y][x - 1]);\n            --x;\n        }\n    }\n    else if (c == 'R') {\n        map[y][x] = '>';\n        if (x + 1 < W && map[y][x + 1] == '.') {\n            swap(map[y][x], map[y][x + 1]);\n            ++x;\n        }\n    }\n    else if (c == 'S') {\n        int dx = 0, dy = 0;\n        if (map[y][x] == '^')\n            dy = -1;\n        else if (map[y][x] == '>')\n            dx = 1;\n        else if (map[y][x] == 'v')\n            dy = 1;\n        else if (map[y][x] == '<')\n            dx = -1;\n\n        for (int i = 1; ; ++i) {\n            if (x + i * dx < 0 || x + i * dx >= W ||\n                y + i * dy < 0 || y + i * dy >= H)\n                break;\n            if (map[y + i * dy][x + i * dx] == '*') {\n                map[y + i * dy][x + i * dx] = '.';\n                break;\n            }\n            if (map[y + i * dy][x + i * dx] == '#')\n                break;\n        }\n    }\n}\n\nint main()\n{\n    int T;\n\n    cin >> T;\n    while (T--) {\n        cin >> H >> W;\n        vector<string> map(H);\n\n        for (int i = 0; i < H; ++i)\n            cin >> map[i];\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                if (map[i][j] == '^' || map[i][j] == '>' ||\n                    map[i][j] == 'v' || map[i][j] == '<')\n                    x = j, y = i;\n\n        string order;\n        int num;\n\n        cin >> num;\n        cin >> order;\n\n        for (int i = 0; i < num; ++i)\n            Move(order[i], map);\n\n        // Output\n        for (int i = 0; i < H; ++i)\n            cout << map[i] << \"\\n\";\n        if (T != 0)\n            cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring mp[20],str;\nint dir[256],h,w,m;\nchar ch[4]={'^','>','v','<'};\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\nint get_d(char a){\n  if(a=='U') return 0;\n  if(a=='R') return 1;\n  if(a=='D') return 2;\n  if(a=='L') return 3;\n  return -1;\n}\n\nvoid shoot(int x,int y,int d){\n  while(1){\n    x+=dx[d],y+=dy[d];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')return;\n    if(mp[y][x]=='*'){\n      mp[y][x]='.';\n      return;\n    }\n  }\n\n}\n\nvoid update(int x,int y,int d){\n  mp[y][x]='.';\n  for(int i=0;i<m;i++){\n    int pd=d,nx,ny;\n    d=get_d(str[i]);\n    if(d==-1){d=pd,shoot(x,y,d);continue;}\n\n    nx=x+dx[d],ny=y+dy[d];\n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]!='.')nx=x,ny=y;\n    y=ny,x=nx;\n  }\n  mp[y][x]=ch[d];\n}\n\nint main(){\n  memset(dir,-1,sizeof(dir));\n  dir['^']=0,dir['>']=1,dir['v']=2,dir['<']=3;\n\n  int q;\n  cin>>q;\n  while(q--){\n    cin>>h>>w;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    cin>>m>> str;\n\n    for(int i=0;i<h;i++){\n      int f=0;\n      for(int j=0;j<w;j++) \n\tif(dir[mp[i][j]]!=-1) {\n\t  update(j,i,dir[mp[i][j]]);\n\t  f=1;\n\t  break;\n\t}\n      if(f)break;\n    }\n\n    for(int i=0;i<h;i++)cout <<mp[i]<<endl;\n    if(q) cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<list>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cmath>\nusing namespace std;\nint main() {\n\tint u, n, m;\n\tcin >> u;\n\tfor (int z = 0; z < u; z++) {\n\t\tcin >> n >> m;\n\t\tchar a[20][20];\n\t\tint b[2];\n\t\tstring t;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> t;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ta[i][j] = t[j];\n\t\t\t\tif (a[i][j] == '>' || a[i][j] == '<' || a[i][j] == '^' || a[i][j] == 'v') {\n\t\t\t\t\tb[0] = i;\n\t\t\t\t\tb[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s;\n\t\tcin >> s;\n\t\tcin >> t;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tchar d;\n\t\t\td=t[i];\n\t\t\tswitch (d)\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\ta[b[0]][b[1]] = '^';\n\t\t\t\tif (b[0] - 1 >= 0 && a[b[0] - 1][b[1]] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[0]--;\n\t\t\t\t\ta[b[0]][b[1]] = '^';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\ta[b[0]][b[1]] = 'v';\n\t\t\t\tif (b[0] + 1 < n && a[b[0] + 1][b[1]] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[0]++;\n\t\t\t\t\ta[b[0]][b[1]] = 'v';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ta[b[0]][b[1]] = '<';\n\t\t\t\tif (b[1] - 1 >= 0 && a[b[0]][b[1] - 1] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[1]--;\n\t\t\t\t\ta[b[0]][b[1]] = '<';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\ta[b[0]][b[1]] = '>';\n\t\t\t\tif (b[1] + 1 < m && a[b[0]][b[1] + 1] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[1]++;\n\t\t\t\t\ta[b[0]][b[1]] = '>';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tint x=0, y=0;\n\t\t\t\tif (a[b[0]][b[1]] == '^') {\n\t\t\t\t\tx = -1;\n\t\t\t\t}\n\t\t\t\telse if (a[b[0]][b[1]] == 'v') {\n\t\t\t\t\tx = 1;\n\t\t\t\t}\n\t\t\t\telse if (a[b[0]][b[1]] == '>') {\n\t\t\t\t\ty = 1;\n\t\t\t\t}\n\t\t\t\telse if (a[b[0]][b[1]] == '<') {\n\t\t\t\t\ty = -1;\n\t\t\t\t}\n\t\t\t\tint k = b[0], l = b[1];\n\t\t\t\twhile (k < n&&k >= 0 && l < m&&l >= 0) {\n\t\t\t\t\tif (a[k][l] == '*') {\n\t\t\t\t\t\ta[k][l] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (a[k][l] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk += x;\n\t\t\t\t    l += y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcout << a[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w, h, x, y, tstate;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nstring grid[100], s, tank = \">v<^\";\n\nvoid move(int d){\n  tstate = d;\n  int nx = x + dx[d], ny = y + dy[d];\n  if(0 <= nx && nx < w &&\n     0 <= ny && ny < h &&\n     grid[ny][nx] == '.'){\n    x = nx, y = ny;\n  }\n}\n\nvoid shoot(int dist){\n  int nx = x + dx[dist], ny = y + dy[dist];\n  while(0 <= nx && nx < w &&\n\t0 <= ny && ny < h){\n    if(grid[ny][nx] == '#')break;\n    if(grid[ny][nx] == '*'){\n      grid[ny][nx] = '.';\n      break;\n    }\n    nx += dx[dist], ny += dy[dist];\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  map<char,int> hash;\n  hash['R'] = 0;\n  hash['D'] = 1;\n  hash['L'] = 2;\n  hash['U'] = 3;\n  hash['S'] = 4;\n  for(int r = 0; r < n; r++){\n    cin >> h >> w;\n    for(int i = 0; i < h; i++){\n      cin >> grid[i];\n    }\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(grid[i][j] == 'v' || grid[i][j] == '>' ||\n\t   grid[i][j] == '<' || grid[i][j] == '^'){\n\t  x = j; y = i;\n\t  for(int k = 0; k < 4; k++)\n\t    if(grid[i][j] == tank[k])tstate = k;\n\t  grid[i][j] = '.';\n\t}\n      }\n    }\n    int len;\n    cin >> len >> s;\n    for(int i = 0; i < len; i++){\n      int d = hash[s[i]];\n      if(d == 4){\n\tshoot(tstate);\n      }else{\n\tmove(d);\n      }\n    }\n    grid[y][x] = tank[tstate];\n    for(int i = 0; i < h; i++){\n      cout << grid[i] << endl;\n    }\n    if(r < n - 1)cout << endl;\n  }\n}\n\n       \n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\nint main( void )\n{\n\tint T;\n\tcin >> T;\n\n\tfor ( int lpc = 0; lpc < T; lpc++ )\n\t{\n\t\t// }bv\n\t\tint W, H;\n\t\tcin >> H >> W;\n\n\t\tvector <string> map(H);\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t\tcin >> map[i];\n\n\t\t// ú»\n\t\tint x;\n\t\tint y;\n\t\tint a;\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < W; j++ )\n\t\t\t{\n\t\t\t\t// íÔÌê\n\t\t\t\ta = (map[i][j]=='^')?1:(map[i][j]=='v')?2:(map[i][j]=='<')?3:(map[i][j]=='>')?4:a;\n\t\t\t\tswitch(map[i][j]) { case '^':case 'v':case '<':case '>': x = j; y = i;map[i][j]='.'; }\n\t\t\t}\n\t\t}\n\n\t\tcout << x << \" \" << y << \" \" << a << endl;\n\n\t\t// ì\n\t\tint N;\n\t\tcin >> N;\n\t\t\n\t\tstring ops;\n\t\tcin >> ops;\n\t\tistringstream is(ops);\n\t\tfor ( int i = 0; i < N; i++ )\n\t\t{\n\t\t\tchar op;\n\t\t\tis >> op;\n\t\t\tif ( op == 'U' )\n\t\t\t{\n\t\t\t\ta = 1;\n\t\t\t\tif ( y-1 >= 0 && map[y-1][x] == '.' )\n\t\t\t\t{\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( op == 'D' )\n\t\t\t{\n\t\t\t\ta = 2;\n\t\t\t\tif ( y+1 < H && map[y+1][x] == '.' )\n\t\t\t\t\ty++;\n\t\t\t}\n\t\t\telse if ( op == 'L' )\n\t\t\t{\n\t\t\t\ta = 3;\n\t\t\t\tif ( x-1 >= 0 && map[y][x-1] == '.' )\n\t\t\t\t\tx--;\n\t\t\t}\n\t\t\telse if ( op == 'R' )\n\t\t\t{\n\t\t\t\ta = 4;\n\t\t\t\tif ( x+1 < W && map[y][x+1] == '.' )\n\t\t\t\t\tx++;\n\t\t\t}\n\t\t\telse if ( op == 'S' )\n\t\t\t{\n\t\t\t\tint nx = x;\n\t\t\t\tint ny = y;\n\t\t\t\twhile (1)\n\t\t\t\t{\n\t\t\t\t\tnx = ((a==3)?nx-1:(a==4?nx+1:nx));\n\t\t\t\t\tny = ((a==1)?ny-1:(a==2?ny+1:ny));\n\t\t\t\t\tif ( nx < 0 || nx >= W || ny < 0 || ny >= H )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif ( map[ny][nx] == '#' )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif ( map[ny][nx] == '*' )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ny][nx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tmap[y][x] = ((a==1)?'^':(a==2)?'v':(a==3)?'<':(a==4)?'>':' ');\n\n\t\t// oÍ\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < W; j++ )\n\t\t\t{\n\t\t\t\tcout << map[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tif ( lpc < T-1 )\n\t\t\tcout << endl;\n\n\t} // while\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nchar map[20][20];\nint dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};\nchar dm[4]={'^','v','<','>'};\nint main(){\n\tint t;\n\tcin>>t;\n\tfor(int r=0;r<t;r++){\n\tif(r!=0)cout<<endl;\n\tint h,w;\n\tcin>>h>>w;\n\tint set,x,y;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>map[i][j];\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(map[i][j]==dm[k]){\n\t\t\t\t\tset=k;\n\t\t\t\t\ty=i;\n\t\t\t\t\tx=j;\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\tchar z;\n\tcin>>n;\n\tfor(int u=0;u<n;u++){\n\t\tcin>>z;\n\t\tif(z=='U'){\n\t\t\tset=0;\n\t\t}\n\t\tif(z=='D'){\n\t\t\tset=1;\n\t\t}\n\t\tif(z=='L'){\n\t\t\tset=2;\n\t\t}\n\t\tif(z=='R'){\n\t\t\tset=3;\n\t\t}\n\t\tif(z=='S'){\n\t\t\tint f=y,g=x;\n\t\t\twhile(true){\n\t\t\t\tif(f<0||f==h||g<0||g==w){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[f][g]=='*'){\n\t\t\t\t\tmap[f][g]='.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[f][g]=='#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tf+=dy[set];\n\t\t\t\tg+=dx[set];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(y+dy[set]>=0&&y+dy[set]<h&&x+dx[set]>=0&&x+dx[set]<w){\n\t\t\t\tif(map[y+dy[set]][x+dx[set]]=='.'){\n\t\t\t\t\ty+=dy[set];\n\t\t\t\t\tx+=dx[set];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(i==y&&j==x){\n\t\t\t\tcout<<dm[set];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<map[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[20][21], t[4]={'^','>','v','<'};\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\t//ã0 E1 º2 ¶3\nint T, H, W, N;\nstruct {int x, y, a;} p;\t//íÔÌ éÀW,íÔÌü«\nvoid shoot(int x, int y, int a)\n{\n\twhile (0 <= x+dx[a] && x+dx[a] <= W && 0 <= y+dy[a] && y+dy[a] <= H)\n\t{\n\t\tx+=dx[a], y+=dy[a];\n\t\tif (m[y][x]=='*')\n\t\t{\n\t\t\tm[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t\telse if (m[y][x]=='#')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar o[101]=\"\";\n\tint i, j, nx, ny;\n\tcin >> T;\n\tfor (; T > 0; T--)\n\t{\n\t\tcin >> H >> W;\n\t\tfor (i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tswitch (m[i][j])\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t\tp.x=j, p.y=i, p.a=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tp.x=j, p.y=i, p.a=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tp.x=j, p.y=i, p.a=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tp.x=j, p.y=i, p.a=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[i][j]='\\0';\n\t\t}\n\t\tcin >> N >> o;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tswitch (o[i])\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\tp.a=0;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tp.a=2;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tp.a=3;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tp.a=1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshoot(p.x, p.y, p.a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx=p.x+dx[p.a], ny=p.y+dy[p.a];\n\t\t\tif (o[i] != 'S' && m[ny][nx]=='.')\n\t\t\t{\n\t\t\t\tm[p.y][p.x]='.';\n\t\t\t\tp.x=nx, p.y=ny;\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < H; i++)\n\t\t\tcout << m[i] << endl;\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  char sensha[] = {'^', '>', 'v', '<'};\n  map<char, int> toi;\n  toi['U'] = 0;\n  toi['R'] = 1;\n  toi['D'] = 2;\n  toi['L'] = 3;\n  toi['S'] = 4;\n  int dx[] = {0, 1, 0, -1};\n  int dy[] = {-1, 0, 1, 0};\n  int T;\n  cin>>T;\n  bool f = false;\n  while(T--){\n    if(f)cout<<endl;\n    else f = true;\n    int H, W;\n    cin>>H>>W;\n    vector<string> grid(H);\n    REP(i,H)cin>>grid[i];\n    int N; cin>>N;\n    string ope; cin>>ope;\n    int nx, ny, nr;\n    REP(y,H)REP(x,W)REP(r,4)if(sensha[r] == grid[y][x]){\n      nx = x;\n      ny = y;\n      nr = r;\n      grid[y][x] = '.';\n    }\n    REP(time, N){\n      char o = ope[time];\n      int t = toi[o];\n      if(t < 4){\n        nr = t;\n        int gx = nx+dx[nr];\n        int gy = ny+dy[nr];\n        if(0<=gx && gx < W && 0<=gy && gy < H && grid[gy][gx] == '.'){\n          nx = gx;\n          ny = gy;\n        }\n      }else{\n        int bx = nx;\n        int by = ny;\n        while(0<=bx && bx < W && 0<=by && by < H){\n          if(grid[by][bx] == '*'){\n            grid[by][bx] = '.';\n            break;\n          }else if(grid[by][bx] == '#'){\n            break;\n          }\n          bx += dx[nr];\n          by += dy[nr];\n        }\n      }\n    }\n    grid[ny][nx] = sensha[nr];\n    REP(y,H)cout<<grid[y]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<(b))\nusing namespace std;\nint t, h, w, n;\nchar town[32][32], cmd[128];\n\nvoid shot(int y, int x){\n   int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0}; // U D L R\n  int d;\n  switch(town[y][x]){\n  case '^': d = 0; break;\n  case 'v': d = 1; break;\n  case '<': d = 2; break;\n  case '>': d = 3; break;\n  }\n  //  printf(\"%d\\n\", d);\n  while(true){\n    if(between(0,y+dy[d], h) && between(0, x+dx[d], w)){\n      y+=dy[d]; x+=dx[d];\n      if(town[y][x] == '*'){\n\ttown[y][x] = '.';\n\tbreak;\n      }else if(town[y][x] == '#'){\n\tbreak;\n      }\n    }else break;\n  }\n  return;\n}\n\nint main(){\n  scanf(\"%d\", &t);\n  bool f = false;\n  while(t--){\n    scanf(\"%d%d\", &h, &w);\n    rep(i, h) scanf(\"%s\", town[i]);\n \n    scanf(\"%d\", &n);\n    scanf(\"%s\", cmd);\n    int x, y;\n    rep(i, h) rep(j, w) \n      if(town[i][j]=='^' || town[i][j]=='v' || town[i][j]=='<' || town[i][j]=='>')x=j,y=i;\n    rep(i, n){\n      //      printf(\"%d %d\\n\", y, x);\n      switch(cmd[i]){\n      case 'U':\n\tif(town[y-1][x] == '.'){ town[y][x] = '.'; town[--y][x] = '^';}\n\telse town[y][x] = '^';\n\tbreak;\n      case 'D':\n\tif(town[y+1][x] == '.'){ town[y][x] = '.'; town[++y][x] = 'v';}\n\telse town[y][x] = 'v';\n\tbreak;\n      case 'L':\n\tif(town[y][x-1] == '.'){ town[y][x] = '.'; town[y][--x] = '<';}\n\telse town[y][x] = '<';\n\tbreak;\n      case 'R':\n\tif(town[y][x+1] == '.'){ town[y][x] = '.'; town[y][++x] = '>';}\n\telse town[y][x] = '>';\n\tbreak;\n      case 'S':\n\tshot(y, x);\n\tbreak;\n      }\n    }      \n    if(f) puts(\"\");\n    rep(i, h){\n      rep(j, w) printf(\"%c\", town[i][j]);\n      puts(\"\");\n    }\n    \n    f = 1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint h, w;\n\nbool isIn(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint main(){\n    int t;\n    cin >> t;\n    for(int q=0; q < t; q++){\n        if(q) cout << endl;\n        string s = \"^><v\";\n        int direction, mx, my;\n        int dx[4] = {1, 0, 0, -1};\n        int dy[4] = {0, 1, -1, 0};\n        cin >> h >> w;\n        string field[h];\n        for(int i=0; i < h; i++){\n            cin >> field[i];\n            for(int j=0; j < field[i].size(); j++) if(s.find(field[i][j]) != -1){mx = i; my = j, direction = s.find(field[i][j]); field[i][j] = '.';}\n        }\n        int n; cin >> n;\n        string c; cin >> c;\n\n        for(int i=0; i < c.size(); i++){\n            if(c[i] == 'U'){\n                direction = 0;\n                if(isIn(mx-1, my) && field[mx-1][my] == '.')mx--;\n            }\n            if(c[i] == 'D'){\n                direction = 3;\n                if(isIn(mx+1, my) && field[mx+1][my] == '.')mx++;\n            }\n            if(c[i] == 'L'){\n                direction = 2;\n                if(isIn(mx, my-1) && field[mx][my-1] == '.')my--;\n            }\n            if(c[i] == 'R'){\n                direction = 1;\n                if(isIn(mx, my+1) && field[mx][my+1] == '.')my++;\n            }\n            if(c[i] == 'S'){\n                for(int j=1; ; j++){\n                    if(!isIn(mx-j*dx[direction], my+j*dy[direction])) break;\n                    if(field[mx-j*dx[direction]][my+j*dy[direction]] == '#') break;\n                    if(field[mx-j*dx[direction]][my+j*dy[direction]] == '*'){\n                        field[mx-j*dx[direction]][my+j*dy[direction]] = '.';\n                        break;\n                    }\n                }\n            }\n        }\n        field[mx][my] = s[direction];\n        for(int i=0; i< h; i++) cout << field[i] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\n\nint n,h,w,m,a,b,muki;\nchar Town[40][40];\nstring s;\n\nbool in(int y,int x){\n  if(y<0 || x<0 || h<=y || w<=x)return false;\n  return true;\n}\n\nint modify(char c){\n  if(c=='U')return 0;\n  if(c=='R')return 1;\n  if(c=='D')return 2;\n  return 3;\n}\n\nchar modify2(char c){\n  if(c=='U')return '^';\n  if(c=='R')return '>';\n  if(c=='D')return 'v';\n  return '<';\n} \nint main()\n{\n\n  cin>>n;\n  for(int k=0;k<n;k++){\n\n    cin>>h>>w;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>Town[i][j];\n\tif(Town[i][j]=='^'||Town[i][j]=='v'||Town[i][j]=='<'||Town[i][j]=='>'){\n\t  a=i;b=j;\n\t  if(Town[i][j]=='^')muki=0;\n\t  if(Town[i][j]=='>')muki=1;\n\t  if(Town[i][j]=='v')muki=2;\n\t  if(Town[i][j]=='<')muki=3;\n\t}\n      }\n    }\n    cin>>m>>s;\n\n    for(int i=0;i<s.length();i++){\n      if(s[i]=='S'){\n\tint c=a+Y[muki],d=b+X[muki];\n\twhile(1){\n\t  if(!in(c,d))break;\n\t  if(Town[c][d]=='#')break;\n\t  if(Town[c][d]=='*'){\n\t    Town[c][d]='.';\n\t    break;\n\t  }\n\t  c+=Y[muki];\n\t  d+=X[muki];\n\t}\n      }\n      else {\n\tmuki=modify(s[i]);\n\tif(Town[a+Y[muki]][b+X[muki]]=='.' && in(a+Y[muki],b+X[muki])){\n\t  Town[a][b]='.';\n\t  a+=Y[muki];\n\t  b+=X[muki];\n\t}\n\tTown[a][b]=modify2(s[i]);\n      }\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cout<<Town[i][j];\n      cout<<endl;\n    }\n    if(k!=n-1)cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint main()\n{\n  int t;\n  cin>>t;\n  for(;t--;)\n    {\n      int h,w;\n      cin>>h>>w;\n      //      cout<<h<<\" \"<<w<<endl;\n      char map[h][w];\n      int x,y;\n      //      char move;     //^=0,>=1,v=2,<=3\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>map[i][j];\n\t    \n\t    if(map[i][j]=='^' ||map[i][j]=='>'\n\t       ||map[i][j]=='v'||map[i][j]=='<')\n\t      x=i,y=j;//move=map[i][j];\t    \n\t    \n\t  }\n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  char tmp;\n\t  cin>>tmp;\n\t  if(tmp=='U')\n\t    {\n\t      map[x][y]='^';\n\t      if(x>0&&map[x-1][y]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  x--;\n\t\t  map[x][y]='^';\n\t\t}\n\t    }\n\t  if(tmp=='D')\n\t    {\n\t      map[x][y]='v';\n\t      if(x<h-1&&map[x+1][y]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  x++;\n\t\t  map[x][y]='v';\n\t\t}\n\t    }\n\n\n\t  if(tmp=='L')\n\t    {\n\t      map[x][y]='<';\n\t      if(y>0&&map[x][y-1]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  y--;\n\t\t  map[x][y]='<';\n\t\t}\n\t    }\n\t  if(tmp=='R')\n\t    {\n\t      map[x][y]='>';\n\t      if(y<w-1&&map[x][y+1]=='.')\n\t\t{\n\t\t  map[x][y]='.';\n\t\t  y++;\n\t\t  map[x][y]='>';\n\t\t}\n\t    }\n\t  if(tmp=='S')\n\t    {\n\t      int dx=0,dy=0;\n\t      int tmpx=x,tmpy=y;\n\t      if(map[x][y]=='^')\n\t\tdx=-1;\n\t      else if(map[x][y]=='v')\n\t\tdx=1;\n\t      else if(map[x][y]=='<')\n\t\tdy=-1;\n\t      else\n\t\tdy=1;\n\t      while(tmpx+dx<h&&tmpy+dy<w)\n\t\t{\n\t\t  tmpx+=dx;\n\t\t  tmpy+=dy;\n\t\t  if(map[tmpx][tmpy]=='*')\n\t\t    {\n\t\t      map[tmpx][tmpy]='.';\n\t\t      break;\n\t\t    }\n\t\t  if(map[tmpx][tmpy]=='#')\n\t\t    {\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\t  \n\t}\n\t\n\t\n\tfor(int i=0;i<h;i++,cout<<endl)\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      cout<<map[i][j];\n\t    }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstring field[30];\nint x,y,d;\nint h,w;\nint xxx[]={0,0,-1,1},yyy[]={-1,1,0.0};\n\nvoid move(){\n\tint xx=x+xxx[d],yy=y+yyy[d];\n\tif(xx<0||w<=xx||yy<0||h<=yy)return;\n\tif(field[yy][xx]=='.'){x=xx;y=yy;}\n\treturn;\n}\n\nvoid shoot(){\n\tint xx=x+xxx[d],yy=y+yyy[d];\n\tfor(;;xx+=xxx[d],yy+=yyy[d]){\n\t\tif(xx<0||w<=xx||yy<0||h<=yy)break;\n\t\tif(field[yy][xx]=='*'){field[yy][xx]='.';break;}\n\t\tif(field[yy][xx]=='#')break;\n\t}\n}\n\nint main() {\n\tint t=in();\n\tint i;\n\tbool first=true;\n\tfor(i=0;i<t;i++){\n\t\tif(!first)cout<<endl;\n\t\tfirst=false;\n\t\tcin>>h>>w;\n\t\tint j;\n\t\tfor(j=0;j<h;j++){\n\t\t\tcin>>field[j];\n\t\t}\n\t\tint k;\n\t\tfor(j=0;j<h;j++){\n\t\t\tfor(k=0;k<w;k++){\n\t\t\t\tif(field[j][k]=='^'){x=k;y=j;d=0;}\n\t\t\t\tif(field[j][k]=='v'){x=k;y=j;d=1;}\n\t\t\t\tif(field[j][k]=='<'){x=k;y=j;d=2;}\n\t\t\t\tif(field[j][k]=='>'){x=k;y=j;d=3;}\n\t\t\t}\n\t\t}\n\t\tfield[y][x]='.';\n\t\tint n;\n\t\tstring ope;\n\t\tcin>>n>>ope;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(ope[j]=='U'){d=0;move();}\n\t\t\tif(ope[j]=='D'){d=1;move();}\n\t\t\tif(ope[j]=='L'){d=2;move();}\n\t\t\tif(ope[j]=='R'){d=3;move();}\n\t\t\tif(ope[j]=='S'){\n\t\t\t\tshoot();\n\t\t\t}\n\t\t}\n\t\tstring c=\"^v<>\";\n\t\tfield[y][x]=c[d];\n\t\tfor(j=0;j<h;j++)cout<<field[j]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint h, w;\n\nvector<string> field;\n\nenum dir_t {N, W, S, E};\n\nint x, y;\ndir_t dir;\n\nvoid find_armor() {\n    for (int i = 0; i < field.size(); i++) {\n        for (int j = 0; j < field[i].size(); j++) {\n            switch (field[i][j]) {\n                case '^':\n                    dir = N;\n                    x = j, y = i;\n                    break;\n                case '>':\n                    dir = W;\n                    x = j, y = i;\n                    break;\n                case 'v':\n                    dir = S;\n                    x = j, y = i;\n                    break;\n                case '<':\n                    dir = E;\n                    x = j, y = i;\n                    break;\n            }\n        }\n    }\n}\n\nvoid up() {\n    dir = N;\n    if (0 < y && field[y-1][x] == '.') {\n        field[y][x] = '.';\n        field[y-1][x] = '^';\n        y--;\n    }\n}\n\nvoid down() {\n    dir = S;\n    if (y < h-1 && field[y+1][x] == '.') {\n        field[y][x] = '.';\n        field[y+1][x] = 'v';\n        y++;\n    }\n}\n\nvoid right() {\n    dir = W;\n    if (x < w-1 && field[y][x+1] == '.') {\n        field[y][x] = '.';\n        field[y][x+1] = '>';\n        x++;\n    }\n}\n\nvoid left() {\n    dir = E;\n    if (0 < x && field[y][x-1] == '.') {\n        field[y][x] = '.';\n        field[y][x-1] = '<';\n        x--;\n    }\n}\n\nvoid shoot() {\n    switch (dir) {\n        case N:\n            for (int i = y-1; i >= 0; i--) {\n                if (field[i][x] == '#') break;\n                if (field[i][x] == '*') {\n                    field[i][x] = '.';\n                    break;\n                }\n            }\n            break;\n        case W:\n            for (int i = x+1; i < w; i++) {\n                if (field[y][i] == '#') break;\n                if (field[y][i] == '*') {\n                    field[y][i] = '.';\n                    break;\n                }\n            }\n            break;\n        case S:\n            for (int i = y+1; i < h; i++) {\n                if (field[i][x] == '#') break;\n                if (field[i][x] == '*') {\n                    field[i][x] = '.';\n                    break;\n                }\n            }\n            break;\n        case E:\n            for (int i = x-1; i >= 0; i--) {\n                if (field[y][i] == '#') break;\n                if (field[y][i] == '*') {\n                    field[y][i] = '.';\n                    break;\n                }\n            }\n            break;\n    }\n}\n\nvoid do_cmd(char cmd) {\n    switch (cmd) {\n        case 'U':\n            up();\n            break;\n        case 'D':\n            down();\n            break;\n        case 'L':\n            left();\n            break;\n        case 'R':\n            right();\n            break;\n        case 'S':\n            shoot();\n            break;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        cin >> h >> w;\n        field.clear();\n        for (int j = 0; j < h; j++) {\n            string s; cin >> s;\n            field.push_back(s);\n        }\n\n        int no_cmd; string cmd;\n        cin >> no_cmd >> cmd;\n\n        find_armor();\n        for (int j = 0; j < no_cmd; j++) {\n            do_cmd(cmd[j]);\n        }\n\n        for (int j = 0; j < field.size(); j++) {\n            cout << field[j] << endl;\n        }\n\n        if (i != T-1) cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nint t;\nint h, w, n;\nstring field[100];\nstring s;\nP pos;\n\nvoid solve(char c){\n\tint y = pos.first, x = pos.second;\n\tif (c == 'U'){\n\t\tif (y != 0){\n\t\t\tif (field[y - 1][x] == '.'){\n\t\t\t\tfield[y - 1][x] = '^';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\ty--;\n\t\t\t}\n\t\t\telse field[y][x] = '^';\n\t\t}\n\t\telse field[y][x] = '^';\n\t}\n\telse if (c == 'D'){\n\t\tif (y != h - 1){\n\t\t\tif (field[y + 1][x] == '.'){\n\t\t\t\tfield[y + 1][x] = 'v';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\ty++;\n\t\t\t}\n\t\t\telse field[y][x] = 'v';\n\t\t}\n\t\telse field[y][x] = 'v';\n\t}\n\telse if (c == 'L'){\n\t\tif (x != 0){\n\t\t\tif (field[y][x - 1] == '.'){\n\t\t\t\tfield[y][x - 1] = '<';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tx--;\n\t\t\t}\n\t\t\telse field[y][x] = '<';\n\t\t}\n\t\telse field[y][x] = '<';\n\t}\n\telse if (c == 'R'){\n\t\tif (x != w - 1){\n\t\t\tif (field[y][x + 1] == '.'){\n\t\t\t\tfield[y][x + 1] = '>';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse field[y][x] = '>';\n\t\t}\n\t\telse field[y][x] = '>';\n\t}\n\telse{\n\t\tint cy = y, cx = x;\n\t\tif (field[y][x] == '^'){\n\t\t\twhile (cy >= 0){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcy--;\n\t\t\t}\n\t\t}\n\t\telse if (field[y][x] == 'v'){\n\t\t\twhile (cy <= h - 1){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcy++;\n\t\t\t}\n\t\t}\n\t\telse if (field[y][x] == '<'){\n\t\t\twhile (cx >= 0){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcx--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (cx <= w - 1){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t}\n\t//REP(i, h){\n\t//\tREP(j, w){\n\t//\t\tcout << field[i][j];\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\tpos = P(y, x);\n}\n\nint main(){\n\tcin >> t;\n\twhile (t--){\n\t\tcin >> h >> w;\n\t\tREP(i, h){\n\t\t\tcin >> field[i];\n\t\t\tREP(j, w){\n\t\t\t\tif (field[i][j] == '^' || field[i][j] == 'v' \n\t\t\t\t\t|| field[i][j] == '>' || field[i][j] == '<'){\n\t\t\t\t\tpos = P(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> n >> s;\n\t\tREP(i, n){\n\t\t\tsolve(s[i]);\n\t\t}\n\t\tREP(i, h){\n\t\t\tREP(j, w){\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main () {\n\n  char map[21][20];\n  char com[101];\n\n  char tank[4] = {'^','>','v','<'};\n  int num;\n\n  int dx[4] = { 0, 1, 0, -1};\n  int dy[4] = { -1, 0, 1, 0};\n   \n  cin >> num;\n\n  for ( int n=0; n<num; n++ )\n\t{\n\t  int h,w;\n\t  cin >> h >> w;\n\t  for ( int i=0; i<h; i++ )\n\t\t{\n\t\t  cin >> map[i];\n\t\t}\n\n\t  //for ( int i=0; i<h; i++ )\n\t  //cout << map[i] << endl;\n\t  \n\t  int comlen;\n\t  \n\t  cin >> comlen;\n\t  cin >> com;\n\n\t  int direct = -1;\n\t  int px, py;\n\t  int mx, my;\n\t  int bx, by;\n\t  bool move;\n\t  \n\t  //cout << com << endl;\n\n\t  for ( int i=0; i<h; i++ )\n\t\t{\n\t\t  for ( int j=0; j<w; j++ )\n\t\t\t{\n\t\t\t  switch ( map[i][j] )\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t  direct = 0;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\tcase '>':\n\t\t\t\t  direct = 1;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\tcase 'v':\n\t\t\t\t  direct = 2;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\tcase '<':\n\t\t\t\t  direct = 3;\n\t\t\t\t  px = j;\n\t\t\t\t  py = i;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t  for ( int j=0; j<comlen; j++ )\n\t\t{\n\t\t  move = false;\n\n\t\t  \n\t\t  //cout << j << endl;\n\t\t  //cout << j << \" \" << com[j] << endl;\n\t\t  switch(com[j]) {\n\t\t\t\n\t\t  case 'U':\n\t\t\tdirect = 0;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  case 'R':\n\t\t\tdirect = 1;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  case 'D':\n\t\t\tdirect = 2;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  case 'L':\n\t\t\tdirect = 3;\n\t\t\tmove = true;\n\t\t\tbreak;\n\t\t  }\n\t\t  \n\t\t  bool pass = false;\n\t\t  if ( move ) {\n\t\t\tif ( py + dy[direct] >= h || py + dy[direct] < 0 || px + dx[direct] >= w || px + dx[direct] < 0 )\n\t\t\t  continue;\n\t\t\tif ( map[py+dy[direct]][px+dx[direct]] == '.')\n\t\t\t  {\n\t\t\t\tmap[py+dy[direct]][px+dx[direct]] = tank[direct];\n\t\t\t\tmap[py][px] = '.';\n\t\t\t\tpx += dx[direct];\n\t\t\t\tpy += dy[direct];\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t\tmap[py][px] = tank[direct];\n\t\t\t  }\n\t\t  } else {\n\t\t\tif ( com[j] == 'S' )\n\t\t\t  {\n\t\t\t\t//cout << \"in\" << endl;\n\t\t\t\t//cout << tank[direct] << endl;\n\t\t\t\tmx = px + dx[direct];\n\t\t\t\tmy = py + dy[direct];\n\t\t\t\t//cout << mx << \" \" << my << endl;//\" \" << map[my][mx] << endl;\n\n\t\t\t\tif ( my < h || my >= 0 || mx < w || mx >= 0 )\n\t\t\t\t  {\t\t\t\t\n\t\t\t\t\twhile ( map[my][mx] == '.' || map[my][mx] == '-' )\n\t\t\t\t\t  {\n\t\t\t\t\t\tmy += dy[direct];\n\t\t\t\t\t\tmx += dx[direct];\n\t\t\t\t\t\tif ( my >= h || my < 0 || mx >= w || mx < 0 )\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\tpass = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t\t  if ( !pass ) {\n\t\t\t\t\tif ( map[my][mx] == '*')\n\t\t\t\t\t  {\n\t\t\t\t\t\tmap[my][mx] = '.';\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\n\t\t\t//cout << mx << \" \" << my << endl;\n\t\t  }\n\t\t}\n\t    for ( int i=0; i<h; i++ )\n\t\t  cout << map[i] << endl;\n\t\tif ( !(n == num -1) )\n\t\t  cout << endl;\n  \n\n\t}\n  \n}\n\t\t  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\nint main( void )\n{\n\tint T;\n\tcin >> T;\n\n\tfor ( int lpc = 0; lpc < T; lpc++ )\n\t{\n\t\t// }bv\n\t\tint W, H;\n\t\tcin >> H >> W;\n\n\t\tvector <string> map(H);\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t\tcin >> map[i];\n\n\t\t// ú»\n\t\tint x;\n\t\tint y;\n\t\tint a;\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < W; j++ )\n\t\t\t{\n\t\t\t\t// íÔÌê\n\t\t\t\ta = (map[i][j]=='^')?1:(map[i][j]=='v')?2:(map[i][j]=='<')?3:(map[i][j]=='>')?4:a;\n\t\t\t\tswitch(map[i][j]) { case '^':case 'v':case '<':case '>': x = j; y = i;map[i][j]='.'; }\n\t\t\t}\n\t\t}\n\n\t\t// ì\n\t\tint N;\n\t\tcin >> N;\n\t\t\n\t\tstring ops;\n\t\tcin >> ops;\n\t\tistringstream is(ops);\n\t\tfor ( int i = 0; i < N; i++ )\n\t\t{\n\t\t\tchar op;\n\t\t\tis >> op;\n\t\t\tif ( op == 'U' )\n\t\t\t{\n\t\t\t\ta = 1;\n\t\t\t\tif ( y-1 >= 0 && map[y-1][x] == '.' )\n\t\t\t\t{\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( op == 'D' )\n\t\t\t{\n\t\t\t\ta = 2;\n\t\t\t\tif ( y+1 < H && map[y+1][x] == '.' )\n\t\t\t\t\ty++;\n\t\t\t}\n\t\t\telse if ( op == 'L' )\n\t\t\t{\n\t\t\t\ta = 3;\n\t\t\t\tif ( x-1 >= 0 && map[y][x-1] == '.' )\n\t\t\t\t\tx--;\n\t\t\t}\n\t\t\telse if ( op == 'R' )\n\t\t\t{\n\t\t\t\ta = 4;\n\t\t\t\tif ( x+1 < W && map[y][x+1] == '.' )\n\t\t\t\t\tx++;\n\t\t\t}\n\t\t\telse if ( op == 'S' )\n\t\t\t{\n\t\t\t\tint nx = x;\n\t\t\t\tint ny = y;\n\t\t\t\twhile (1)\n\t\t\t\t{\n\t\t\t\t\tnx = ((a==3)?nx-1:(a==4?nx+1:nx));\n\t\t\t\t\tny = ((a==1)?ny-1:(a==2?ny+1:ny));\n\t\t\t\t\tif ( nx < 0 || nx >= W || ny < 0 || ny >= H )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif ( map[ny][nx] == '#' )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif ( map[ny][nx] == '*' )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ny][nx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tmap[y][x] = ((a==1)?'^':(a==2)?'v':(a==3)?'<':(a==4)?'>':' ');\n\n\t\t// oÍ\n\t\tfor ( int i = 0; i < H; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < W; j++ )\n\t\t\t{\n\t\t\t\tcout << map[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tif ( lpc < T-1 )\n\t\t\tcout << endl;\n\n\t} // while\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[30][30];\nint dx[]={1,-1,0,0};\nint dy[]={0,0,-1,1};\nchar dir[6]=\"DULR\";\nchar com[110];\nint main(){\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);for(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tint d=0;\n\t\tint row,col;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='^'){\n\t\t\t\td=1;row=i;col=j;\n\t\t\t}\n\t\t\tif(str[i][j]=='v'){\n\t\t\t\td=0;row=i;col=j;\n\t\t\t}\n\t\t\tif(str[i][j]=='<'){\n\t\t\t\td=2;row=i;col=j;\n\t\t\t}\n\t\t\tif(str[i][j]=='>'){\n\t\t\t\td=3;row=i;col=j;\n\t\t\t}\n\t\t}\n\t\tstr[row][col]='.';\n\t\tint c;scanf(\"%d\",&c);\n\t\tscanf(\"%s\",com);\n\t\tfor(int i=0;i<c;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(com[i]==dir[j]){\n\t\t\t\t\td=j;\n\t\t\t\t\tif(0<=row+dx[d]&&row+dx[d]<a&&0<=col+dy[d]&&col+dy[d]<b&&str[row+dx[d]][col+dy[d]]=='.'){\n\t\t\t\t\t\trow+=dx[d];\n\t\t\t\t\t\tcol+=dy[d];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(com[i]=='S'){\n\t\t\t\tint nr=row;int nc=col;\n\t\t\t\twhile(1){\n\t\t\t\t\tnr+=dx[d];\n\t\t\t\t\tnc+=dy[d];\n\t\t\t\t\tif(nr<0||nr>=a||nc<0||nc>=b||str[nr][nc]=='#')break;\n\t\t\t\t\tif(str[nr][nc]=='*'){\n\t\t\t\t\t\tstr[nr][nc]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d==0)str[row][col]='v';\n\t\tif(d==1)str[row][col]='^';\n\t\tif(d==2)str[row][col]='<';\n\t\tif(d==3)str[row][col]='>';\n\t\tfor(int i=0;i<a;i++)printf(\"%s\\n\",str[i]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nchar town[30][30];\nint h,w,dir,x,y;\n\nbool intown(int x,int y){\n  return !(x<0 || y<0 || x>=w || y>=h || town[x][y]!='.');\n}\n\nvoid hou(int cx,int cy){\n  if(cx<0 || cy<0 || cx>=w || cy>=h || town[cx][cy]=='#')return;\n  if(town[cx][cy]!='*')hou(cx+dx[dir],cy+dy[dir]);\n  else if(town[cx][cy]=='*'){\n    town[cx][cy]='.';\n    return;\n  }\n}\n\nmain(){\n  int n;\n  cin>>n;\n  while(n--){\n    cin>>h>>w;\n    rep(i,h){\n      cin>>town[i];\n      rep(j,w){\n        switch(town[i][j]){\n        case '^':\n          dir=3;\n          x=i,y=j;\n          break;\n        case '>':\n          dir=0;\n          x=i,y=j;\n          break;\n        case 'v':\n          dir=1;\n          x=i,y=j;\n          break;\n        case '<':\n          dir=2;\n          x=i,y=j;\n          break;\n        }\n      }\n    }\n\n    int s;\n    cin>>s;\n    string str;\n    cin>>str;\n    rep(i,str.size()){\n      switch(str[i]){\n      case 'U':\n        dir=3;\n        if(intown(x+dx[dir],y+dy[dir])){\n          town[x][y]='.';\n          x+=dx[dir],y+=dy[dir];\n        }\n        town[x][y]='^';\n        break;\n      case 'D':\n        dir=1;\n        if(intown(x+dx[dir],y+dy[dir])){\n          town[x][y]='.';\n          x+=dx[dir],y+=dy[dir];\n        }\n        town[x][y]='v';\n        break;\n      case 'R':\n        dir=0;\n        if(intown(x+dx[dir],y+dy[dir])){\n          town[x][y]='.';\n          x+=dx[dir],y+=dy[dir];\n        }\n        town[x][y]='>';\n        break;\n      case 'L':\n        dir=2;\n        if(intown(x+dx[dir],y+dy[dir])){\n          town[x][y]='.';\n          x+=dx[dir],y+=dy[dir];\n        }\n        town[x][y]='<';\n        break;\n      case 'S':\n        hou(x+dx[dir],y+dy[dir]);\n        break;\n      }\n    }\n    rep(i,h)cout<<town[i]<<endl;\n    if(n)cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nchar field[21][21];\n\nint main(){\n  int t;\n  int H, W;\n  cin >> t;\n  for(int cs = 0 ; cs < t ; cs++){\n    cin >> H >> W;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> field[i][j];\n      }\n    }\n    \n    int tmp;\n    string op;\n    cin >> tmp;\n    cin >> op;\n    \n    \n    for(int cc = 0 ; cc < tmp ; cc++){\n      if(op[cc] == 'U' || op[cc] == 'D' || op[cc] == 'L' || op[cc] == 'R'){\n\tbool flag = false;\n\tfor(int i = 0 ; i < H ; i++){\n\t  for(int j = 0 ; j < W ; j++){\n\t    if(flag) break;\n\t    if(field[i][j] == '^' || field[i][j] == 'v' || field[i][j] == '<' || field[i][j] == '>'){\n\t      flag = true;\n\t      \n\t      if(op[cc] == 'U'){\n\t\tif(i-1 < 0 || field[i-1][j] == '*' || field[i-1][j] == '#' || field[i-1][j] == '-') field[i][j] = '^';\n\t\telse{\n\t\t  field[i-1][j] = '^';\n\t\t  field[i][j] = '.';\n\t\t}\n\t      }\n\t      \n\t      if(op[cc] == 'D'){\n\t\tif(H <= i+1 || field[i+1][j] == '*' || field[i+1][j] == '#' || field[i+1][j] == '-') field[i][j] = 'v';\n\t\telse{\n\t\t  field[i+1][j] = 'v';\n\t\t  field[i][j] = '.';\n\t\t}\n\t      }\n\t      \n\t      if(op[cc] == 'L'){\n\t\tif(j-1 < 0 || field[i][j-1] == '*' || field[i][j-1] == '#' || field[i][j-1] == '-') field[i][j] = '<';\n\t\telse{\n\t\t  field[i][j-1] = '<';\n\t\t  field[i][j] = '.';\n\t\t}\n\t      }\n\t      \n\t      if(op[cc] == 'R'){\n\t\tif(W <= j+1 || field[i][j+1] == '*' || field[i][j+1] == '#' || field[i][j+1] == '-') field[i][j] = '>';\n\t\telse{\n\t\t  field[i][j+1] = '>';\n\t\t  field[i][j] = '.';\n\t\t}\n\t      }\t      \n\t    }\n\t  }\n\t}\n      }\n      else if(op[cc] == 'S'){\n\tbool flag = false;\n\tfor(int i = 0 ; i < H ; i++){\n\t  for(int j = 0 ; j < W ; j++){\n\t    if(flag) break;\n\t    \n\t    if(field[i][j] == '^'){\n\t      flag = true;\n\t      for(int y = i-1 ; y >= 0 ; y--){\n\t\tif(field[y][j] == '#') break;\n\t\telse if(field[y][j] == '*'){\n\t\t  field[y][j] = '.';\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\n\t    if(field[i][j] == 'v'){\n\t      flag = true;\n\t      for(int y = i+1 ; y < H ; y++){\n\t\tif(field[y][j] == '#') break;\n\t\telse if(field[y][j] == '*'){\n\t\t  field[y][j] = '.';\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\t    \n\t    if(field[i][j] == '<'){\n\t      flag = true;\n\t      for(int x = j-1 ; x >= 0 ; x--){\n\t\tif(field[i][x] == '#') break;\n\t\telse if(field[i][x] == '*'){\n\t\t  field[i][x] = '.';\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\n\t    if(field[i][j] == '>'){\n\t      flag = true;\n\t      for(int x = j+1 ; x < W ; x++){\n\t\tif(field[i][x] == '#') break;\n\t\telse if(field[i][x] == '*'){\n\t\t  field[i][x] = '.';\n\t\t  break;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      /*\n      for(int a = 0 ; a < H ; a++){\n\tfor(int b = 0 ; b < W ; b++){\n\t  cout << field[a][b];\n\t}\n\tcout << endl;\n      }\n      cout << endl;*/\n    }\n    \n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcout << field[i][j];\n      }\n      cout << endl;\n    }\n    if(cs != t-1)cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\n\nint n,h,w,m,a,b,muki;\nchar Town[40][40];\nstring s;\n\nbool in(int y,int x){\n  if(y<0 || x<0 || h<=y || w<=x)return false;\n  return true;\n}\n\nint modify(char c){\n  if(c=='U')return 0;\n  if(c=='R')return 1;\n  if(c=='D')return 2;\n  return 3;\n}\n\nchar modify2(char c){\n  if(c=='U')return '^';\n  if(c=='R')return '>';\n  if(c=='D')return 'v';\n  return '<';\n} \nint main()\n{\n\n  cin>>n;\n  for(int k=0;k<n;k++){\n\n    cin>>h>>w;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>Town[i][j];\n\tif(Town[i][j]=='^'||Town[i][j]=='v'||Town[i][j]=='<'||Town[i][j]=='>'){\n\t  a=i;b=j;\n\t  if(Town[i][j]=='^')muki=0;\n\t  if(Town[i][j]=='>')muki=1;\n\t  if(Town[i][j]=='v')muki=2;\n\t  if(Town[i][j]=='<')muki=3;\n\t}\n      }\n    }\n    cin>>m>>s;\n\n    for(int i=0;i<s.length();i++){\n      if(s[i]=='S'){\n\tint c=a+Y[muki],d=b+X[muki];\n\twhile(1){\n\t  if(!in(c,d))break;\n\t  if(Town[c][d]=='#')break;\n\t  if(Town[c][d]=='*'){\n\t    Town[c][d]='.';\n\t    break;\n\t  }\n\t  c+=Y[muki];\n\t  d+=X[muki];\n\t}\n      }\n      else {\n\tmuki=modify(s[i]);\n\tif(Town[a+Y[muki]][b+X[muki]]=='.'){\n\t  Town[a][b]='.';\n\t  a+=Y[muki];\n\t  b+=X[muki];\n\t}\n\tTown[a][b]=modify2(s[i]);\n      }\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cout<<Town[i][j];\n      cout<<endl;\n    }\n    if(k!=n-1)cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nint t,h,w,n;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nbool inside(int x,int y){\n\tif(x>=0 && x<w && y>=0 && y<h)return true;\n\telse return false;\n}\n\nint main(){\n\tcin>>t;\n\trep(p,t){\n\t\tcin>>h>>w;\n\t\tstring dt[h];\n\t\tchar dir;\n\t\tint x,y;\n\t\trep(i,h){\n\t\t\tcin>>dt[i];\n\t\t\trep(j,w){\n\t\t\t\tif(dt[i][j]=='^'){x=j;y=i;dir='^';dt[i][j]='.';}\n\t\t\t\tif(dt[i][j]=='>'){x=j;y=i;dir='>';dt[i][j]='.';}\n\t\t\t\tif(dt[i][j]=='<'){x=j;y=i;dir='<';dt[i][j]='.';}\n\t\t\t\tif(dt[i][j]=='v'){x=j;y=i;dir='v';dt[i][j]='.';}\n\t\t\t}\n\t\t}\n\t\tcin>>n;\n\t\tstring com;\n\t\tcin>>com;\n\t\trep(i,com.size()){\n\t\t\tif(com[i]=='U'){dir='^';if(inside(x,y-1) && dt[y-1][x]=='.')y--;}\n\t\t\tif(com[i]=='D'){dir='v';if(inside(x,y+1) && dt[y+1][x]=='.')y++;}\n\t\t\tif(com[i]=='L'){dir='<';if(inside(x-1,y) && dt[y][x-1]=='.')x--;}\n\t\t\tif(com[i]=='R'){dir='>';if(inside(x+1,y) && dt[y][x+1]=='.')x++;}\n\t\t\tif(com[i]=='S'){\n\t\t\t\tint mx=x,my=y;\n\t\t\t\tif(dir=='^')my--;\n\t\t\t\tif(dir=='v')my++;\n\t\t\t\tif(dir=='<')mx--;\n\t\t\t\tif(dir=='>')mx++;\n\t\t\t\twhile(inside(mx,my) &&(dt[my][mx]=='.' || dt[my][mx]=='-')){\n\t\t\t\t\tif(dir=='^')my--;\n\t\t\t\t\tif(dir=='v')my++;\n\t\t\t\t\tif(dir=='<')mx--;\n\t\t\t\t\tif(dir=='>')mx++;\n\t\t\t\t}\n\t\t\t\tif(inside(mx,my) && dt[my][mx]=='*')dt[my][mx]='.';\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(i==y && j==x)cout<<dir;\n\t\t\t\telse cout<<dt[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\tif(p!=t-1)cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,1,0,0,1,-1,1,-1};\nconst int dx[] = {0,0,-1,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nconst string Dir = \"UDLR^v<>\";\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll t;\n  cin >> t;\n  rep(z,t){\n    if(z) cout << endl;\n    ll h,w,x,y,dir;\n    cin >> h >> w;\n    vector<vector<char>> v(h,vector<char>(w));\n    rep(i,h){\n      rep(j,w){\n        cin >> v[i][j];\n        if(v[i][j] == '^'){\n          dir = 0;\n          x = j,y = i;\n        }\n        if(v[i][j] == 'v'){\n          dir = 1;\n          x = j,y = i;\n        }\n        if(v[i][j] == '<'){\n          dir = 2;\n          x = j,y = i;\n        }\n        if(v[i][j] == '>'){\n          dir = 3;\n          x = j,y = i;\n        }\n      }\n    }\n    ll n;\n    cin >> n;\n    string s;\n    cin >> s;\n    rep(i,n){\n      if(s[i] != 'S'){\n        rep(j,4){\n          if(s[i] == Dir[j]){\n            dir = j;\n            break;\n          }\n        }\n        ll nx = x + dx[dir],ny = y+dy[dir];\n        if(value(nx,ny,w,h) && v[ny][nx] == '.'){\n          v[y][x] = '.';\n          x = nx,y = ny;\n          v[ny][nx] = Dir[dir+4];\n        }\n      }\n      else{\n        ll nx = x,ny = y;\n        while(1){\n          nx += dx[dir],ny += dy[dir];\n          if(!value(nx,ny,w,h)) break;\n          if(v[ny][nx] == '*'){\n            v[ny][nx] = '.';\n            break;\n          }\n          if(v[ny][nx] == '#'){\n            break;\n          }\n        }\n      }\n    }\n    rep(i,h){\n      rep(j,w){\n        cout << v[i][j] ;\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int t;\n  cin>>t;\n  for(;t--;)\n    {\n      int h,w;\n      cin>>h>>w;\n      //      cout<<h<<\" \"<<w<<endl;\n      char maps[h][w];\n      int x,y;\n      //      char move;     //^=0,>=1,v=2,<=3\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>maps[i][j];\n\t    \n\t    if(maps[i][j]=='^' ||maps[i][j]=='>'\n\t       ||maps[i][j]=='v'||maps[i][j]=='<')\n\t      {\n\t\tx=i;\n\t\ty=j;\n\t      }\n\t    \n\t  }\n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  char tmp;\n\t  cin>>tmp;\n\t  if(tmp=='U')\n\t    {\n\t      maps[x][y]='^';\n\t      if(x>0&&maps[x-1][y]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  x--;\n\t\t  maps[x][y]='^';\n\t\t}\n\t    }\n\t  if(tmp=='D')\n\t    {\n\t      maps[x][y]='v';\n\t      if(x<h-1&&maps[x+1][y]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  x++;\n\t\t  maps[x][y]='v';\n\t\t}\n\t    }\n\n\n\t  if(tmp=='L')\n\t    {\n\t      maps[x][y]='<';\n\t      if(y>0&&maps[x][y-1]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  y--;\n\t\t  maps[x][y]='<';\n\t\t}\n\t    }\n\t  if(tmp=='R')\n\t    {\n\t      maps[x][y]='>';\n\t      if(y<w-1&&maps[x][y+1]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  y++;\n\t\t  maps[x][y]='>';\n\t\t}\n\t    }\n\t  if(tmp=='S')\n\t    {\n\t      int dx=0,dy=0;\n\t      int tmpx=x,tmpy=y;\n\t      if(maps[x][y]=='^')\n\t\tdx=-1;\n\t      else if(maps[x][y]=='v')\n\t\tdx=1;\n\t      else if(maps[x][y]=='<')\n\t\tdy=-1;\n\t      else\n\t\tdy=1;\n\t      while(tmpx+dx<h&&tmpy+dy<w &&tmpx+dx>=0&&tmpy+dy>=0)\n\t\t{\n\t\t  tmpx+=dx;\n\t\t  tmpy+=dy;\n\t\t  if(maps[tmpx][tmpy]=='*')\n\t\t    {\n\t\t      maps[tmpx][tmpy]='.';\n\t\t      break;\n\t\t    }\n\t\t  if(maps[tmpx][tmpy]=='#')\n\t\t    {\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\t  \n\t}\n\t\n\t\n\tfor(int i=0;i<h;i++,cout<<endl)\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      cout<<maps[i][j];\n\t    }\n\tif(t!=0)\n\t  cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\nusing namespace std;\nchar mas[22][22];\nchar str[110];\nint MUKI,x,y,H,W;\nint tx[]={-1,1,0,0},ty[]={0,0,-1,1}; //上下左右 (tx * ty)\nvoid JUMP(char);\nvoid SHOOT(int,int);\nvoid UGOKU(char);\nint main(){\n  int T,l;\n  map<char,int> hoge;\n  hoge['^']=0;\n  hoge['v']=1;\n  hoge['<']=2;\n  hoge['>']=3;\n\n  cin >> T;\n  for(int i=0;i<T;i++){\n    scanf(\"%d %d\",&H,&W);\n    for(int j=0;j<H;j++){\n      scanf(\"%s\",mas[j]);\n    }\n    scanf(\"%d\",&l);\n    scanf(\"%s\",str);\n\n    for(int j=0;j<H;j++){\n      for(int k=0;k<W;k++){\n\tif(mas[j][k]=='^'||mas[j][k]=='v'||mas[j][k]=='<'||mas[j][k]=='>'){\n\t  MUKI=hoge[mas[j][k]];\n\t  x=j; y=k;\n\t  k=W,j=H;\n\t}\n      }\n    }\n    for(int j=0;j<l;j++){\n      JUMP(str[j]);\n    }\n    for(int j=0;j<H;j++){\n      printf(\"%s\\n\",mas[j]);\n    }\n    if(i!=T-1)puts(\"\");\n  }\n}\n\nvoid JUMP(char s){\n  if(s=='S'){\n    int ax=x,ay=y; //ax,ay 弾座標\n    SHOOT(ax,ay);\n  }\n  else UGOKU(s);\n  return;\n}\nvoid SHOOT(int ax,int ay){\n  if(!(ax>=0 && ax<H && ay>=0 && ay<W))return;\n  else if(mas[ax][ay]=='*'){\n    mas[ax][ay]='.';\n    return;\n  }else if(mas[ax][ay]=='#'){\n    return;\n  }else{\n    SHOOT(ax+tx[MUKI],ay+ty[MUKI]);\n  }\n}\nvoid UGOKU(char ss){\n  map<char,int> hoge; map<int,char> hogehoge;\n  hoge['U']=0;hogehoge[0]='^';\n  hoge['D']=1;hogehoge[1]='v';\n  hoge['L']=2;hogehoge[2]='<';\n  hoge['R']=3;hogehoge[3]='>';\n  MUKI=hoge[ss];\n  mas[x][y]=hogehoge[MUKI];\n  int dx=x+tx[MUKI];\n  int dy=y+ty[MUKI];\n  if(dx>=0&&dx<H&&dy>=0&&dy<W){\n    if(mas[dx][dy]=='.'){\n      mas[x][y]='.';\n      x+=tx[MUKI];\n      y+=ty[MUKI];\n      mas[x][y]=hogehoge[MUKI];\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint di[4] = {-1, 0, 1, 0};\nint dj[4] = {0, 1, 0, -1};\n\nint main(){\n\n    int q; cin >> q;\n    for(int nn = 0; nn < q; nn++){\n        int h, w; cin >> h >> w;\n        if(!h) break;\n\n        int nowi, nowj, k;\n        vector<vector<char> > s(h + 2, vector<char> (w + 2, '#'));\n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                cin >> s[i][j];\n                if(s[i][j] == '^'){\n                    nowi = i;\n                    nowj = j;\n                    k = 0; \n                }else if(s[i][j] == '>'){\n                    nowi = i;\n                    nowj = j;\n                    k = 1;\n                }else if(s[i][j] == 'v'){\n                    nowi = i;\n                    nowj = j;\n                    k = 2;\n                }else if(s[i][j] == '<'){\n                    nowi = i;\n                    nowj = j;\n                    k = 3;\n                }\n            }\n        }\n\n        int n; cin >> n;\n        string op; cin >> op;\n        for(int i = 0; i < n; i++){\n\n            if(op[i] == 'U'){\n                k = 0;\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n                if(s[nexti][nextj] == '.'){\n                    char tmp = s[nowi][nowj];\n                    s[nowi][nowj] = s[nexti][nextj];\n                    s[nexti][nextj] = tmp;\n                    nowi = nexti;\n                    nowj = nextj;\n                }\n            }\n\n            if(op[i] == 'R'){\n                k = 1;\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n                if(s[nexti][nextj] == '.'){\n                    char tmp = s[nowi][nowj];\n                    s[nowi][nowj] = s[nexti][nextj];\n                    s[nexti][nextj] = tmp;\n                    nowi = nexti;\n                    nowj = nextj;\n                }\n            }\n\n            if(op[i] == 'D'){\n                k = 2;\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n                if(s[nexti][nextj] == '.'){\n                    char tmp = s[nowi][nowj];\n                    s[nowi][nowj] = s[nexti][nextj];\n                    s[nexti][nextj] = tmp;\n                    nowi = nexti;\n                    nowj = nextj;\n                }\n            }\n\n            if(op[i] == 'L'){\n                k = 3;\n                int nexti = nowi + di[k];\n                int nextj = nowj + dj[k];\n                if(s[nexti][nextj] == '.'){\n                    char tmp = s[nowi][nowj];\n                    s[nowi][nowj] = s[nexti][nextj];\n                    s[nexti][nextj] = tmp;\n                    nowi = nexti;\n                    nowj = nextj;\n                }\n            }\n\n\n            if(op[i] == 'S'){\n                int bi = nowi + di[k];\n                int bj = nowj + dj[k];\n\n                while(1){\n                    if(s[bi][bj] == '#') break;\n                    else if(s[bi][bj] == '*'){\n                        s[bi][bj] = '.';\n                        break;\n                    }\n\n                    bi += di[k];\n                    bj += dj[k];\n                }\n            }\n\n            /*for(int i = 1; i <= h; i++){\n                for(int j = 1; j <= w; j++){\n                    cout << s[i][j];\n                }\n                cout << endl;\n            }\n\n            cout << endl;*/\n        }\n        \n        if(k == 0){\n            s[nowi][nowj] = '^';\n        }else if(k == 1){\n            s[nowi][nowj] = '>';            \n        }else if(k == 2){\n            s[nowi][nowj] = 'v';\n        }else{\n            s[nowi][nowj] = '<';\n        }\n        \n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                cout << s[i][j];\n            }\n            cout << endl;\n        }\n\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring mp[20],str;\nint dir[256],h,w,m;\nchar ch[4]={'^','>','v','<'};\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n \nint get_d(char a){\n  if(a=='U') return 0;\n  if(a=='R') return 1;\n  if(a=='D') return 2;\n  if(a=='L') return 3;\n  return -1;\n}\n \nvoid shoot(int x,int y,int d){\n  while(1){\n    x+=dx[d],y+=dy[d];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')return;\n    if(mp[y][x]=='*'){\n      mp[y][x]='.';\n      return;\n    }\n  }\n \n}\n \nvoid update(int x,int y,int d){\n  mp[y][x]='.';\n  for(int i=0;i<m;i++){\n    int pd=d,nx,ny;\n    d=get_d(str[i]);\n    if(d==-1){d=pd,shoot(x,y,d);continue;}\n \n    nx=x+dx[d],ny=y+dy[d];\n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]!='.')nx=x,ny=y;\n    y=ny,x=nx;\n  }\n  mp[y][x]=ch[d];\n}\n \nint main(){\n  memset(dir,-1,sizeof(dir));\n  dir['^']=0,dir['>']=1,dir['v']=2,dir['<']=3;\n \n  int q;\n  cin>>q;\n  while(q--){\n    cin>>h>>w;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    cin>>m>> str;\n \n    for(int i=0;i<h;i++){\n      int f=0;\n      for(int j=0;j<w;j++) \n    if(dir[mp[i][j]]!=-1) {\n      update(j,i,dir[mp[i][j]]);\n      f=1;\n      break;\n    }\n      if(f)break;\n    }\n \n    for(int i=0;i<h;i++)cout <<mp[i]<<endl;\n    if(q) cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint h, w;\n\nvector<string> field;\n\nenum dir_t {N, W, S, E};\n\nint x, y;\ndir_t dir;\n\nvoid find_armor() {\n    for (int i = 0; i < field.size(); i++) {\n        for (int j = 0; j < field[i].size(); j++) {\n            switch (field[i][j]) {\n                case '^':\n                    dir = N;\n                    x = j, y = i;\n                    break;\n                case '>':\n                    dir = W;\n                    x = j, y = i;\n                    break;\n                case 'v':\n                    dir = S;\n                    x = j, y = i;\n                    break;\n                case '<':\n                    dir = E;\n                    x = j, y = i;\n                    break;\n            }\n        }\n    }\n}\n\nvoid up() {\n    dir = N;\n    if (0 < y && field[y-1][x] == '.') {\n        field[y][x] = '.';\n        field[y-1][x] = '^';\n        y--;\n    } else {\n        field[y][x] = '^';\n    }\n}\n\nvoid down() {\n    dir = S;\n    if (y < h-1 && field[y+1][x] == '.') {\n        field[y][x] = '.';\n        field[y+1][x] = 'v';\n        y++;\n    } else {\n        field[y][x] = 'v';\n    }\n}\n\nvoid right() {\n    dir = W;\n    if (x < w-1 && field[y][x+1] == '.') {\n        field[y][x] = '.';\n        field[y][x+1] = '>';\n        x++;\n    } else {\n        field[y][x] = '>';\n    }\n}\n\nvoid left() {\n    dir = E;\n    if (0 < x && field[y][x-1] == '.') {\n        field[y][x] = '.';\n        field[y][x-1] = '<';\n        x--;\n    } else {\n        field[y][x] = '<';\n    }\n}\n\nvoid shoot() {\n    switch (dir) {\n        case N:\n            for (int i = y-1; i >= 0; i--) {\n                if (field[i][x] == '#') break;\n                if (field[i][x] == '*') {\n                    field[i][x] = '.';\n                    break;\n                }\n            }\n            break;\n        case W:\n            for (int i = x+1; i < w; i++) {\n                if (field[y][i] == '#') break;\n                if (field[y][i] == '*') {\n                    field[y][i] = '.';\n                    break;\n                }\n            }\n            break;\n        case S:\n            for (int i = y+1; i < h; i++) {\n                if (field[i][x] == '#') break;\n                if (field[i][x] == '*') {\n                    field[i][x] = '.';\n                    break;\n                }\n            }\n            break;\n        case E:\n            for (int i = x-1; i >= 0; i--) {\n                if (field[y][i] == '#') break;\n                if (field[y][i] == '*') {\n                    field[y][i] = '.';\n                    break;\n                }\n            }\n            break;\n    }\n}\n\nvoid do_cmd(char cmd) {\n    switch (cmd) {\n        case 'U':\n            up();\n            break;\n        case 'D':\n            down();\n            break;\n        case 'L':\n            left();\n            break;\n        case 'R':\n            right();\n            break;\n        case 'S':\n            shoot();\n            break;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        cin >> h >> w;\n        field.clear();\n        for (int j = 0; j < h; j++) {\n            string s; cin >> s;\n            field.push_back(s);\n        }\n\n        int no_cmd; string cmd;\n        cin >> no_cmd >> cmd;\n\n        find_armor();\n        for (int j = 0; j < no_cmd; j++) {\n            do_cmd(cmd[j]);\n        }\n\n        for (int j = 0; j < field.size(); j++) {\n            cout << field[j] << endl;\n        }\n\n        if (i != T-1) cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint W, H, x, y;\nvector<string> map;\n\nvoid Move(char c)\n{\n    if (c == 'U') {\n        map[y][x] = '^';\n        if (y - 1 >= 0 && map[y - 1][x] == '.') {\n            swap(map[y][x], map[y - 1][x]);\n            --y;\n        }\n    }\n    else if (c == 'D') {\n        map[y][x] = 'v';\n        if (y + 1 < H && map[y + 1][x] == '.') {\n            swap(map[y][x], map[y + 1][x]);\n            ++y;\n        }\n    }\n    else if (c == 'L') {\n        map[y][x] = '<';\n        if (x - 1 >= 0 && map[y][x - 1] == '.') {\n            swap(map[y][x], map[y][x - 1]);\n            --x;\n        }\n    }\n    else if (c == 'R') {\n        map[y][x] = '>';\n        if (x + 1 < W && map[y][x + 1] == '.') {\n            swap(map[y][x], map[y][x + 1]);\n            ++x;\n        }\n    }\n    else if (c == 'S') {\n        int dx = 0, dy = 0;\n        if (map[y][x] == '^')\n            dy = -1;\n        else if (map[y][x] == '>')\n            dx = 1;\n        else if (map[y][x] == 'v')\n            dy = 1;\n        else if (map[y][x] == '<')\n            dx = -1;\n\n        for (int i = 1; ; ++i) {\n            if (x + i * dx < 0 || x + i * dx >= W ||\n                y + i * dy < 0 || y + i * dy >= H)\n                break;\n            if (map[y + i * dy][x + i * dx] == '*') {\n                map[y + i * dy][x + i * dx] = '.';\n                break;\n            }\n            if (map[y + i * dy][x + i * dx] == '#')\n                break;\n        }\n    }\n}\n\nint main()\n{\n    int T;\n\n    cin >> T;\n    while (T--) {\n        cin >> H >> W;\n        map.assign(H, \"\");\n\n        for (int i = 0; i < H; ++i)\n            cin >> map[i];\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                if (map[i][j] == '^' || map[i][j] == '>' ||\n                    map[i][j] == 'v' || map[i][j] == '<')\n                    x = j, y = i;\n\n        string order;\n        int num;\n\n        cin >> num;\n        cin >> order;\n\n        for (int i = 0; i < num; ++i)\n            Move(order[i]);\n\n        // Output\n        for (int i = 0; i < H; ++i)\n            cout << map[i] << \"\\n\";\n        if (T != 0)\n            cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w, h, tx, ty, d;\nint dx[] = {0,0,1,-1};\nint dy[] = {-1,1,0,0};\nchar dir[256];\nstring f[21];\n\nvoid solve(string s){\n\tfor(int j=0 ; j < (int)s.size() ; j++ ){\n\t\tchar c = s[j];\n\t\tif( c == 'S' ){\n\t\t\tint sx = tx;\n\t\t\tint sy = ty;\n\t\t\tfor(;;){\n\t\t\t\tint mx = sx + dx[ dir[d] ];\n\t\t\t\tint my = sy + dy[ dir[d] ];\n\t\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if( f[my][mx] == '.' || f[my][mx] == '-' ){\n\t\t\t\t\tsx = mx;\n\t\t\t\t\tsy = my;\n\t\t\t\t}else if( f[my][mx] == '*' ){\n\t\t\t\t\tf[my][mx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}else if( f[my][mx] == '#' ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\td = dir[c];\n\t\t\tint mx = tx + dx[ dir[d] ];\n\t\t\tint my = ty + dy[ dir[d] ];\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ){\n\t\t\t\tcontinue;\n\t\t\t}else if( f[my][mx] == '.' ){\n\t\t\t\ttx = mx;\n\t\t\t\tty = my;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint t, n;\n\tstring s;\n\t\n\tdir['U'] = '^';\n\tdir['D'] = 'v';\n\tdir['R'] = '>';\n\tdir['L'] = '<';\n\tdir['^'] = 0;\n\tdir['v'] = 1;\n\tdir['>'] = 2;\n\tdir['<'] = 3;\n\t\n\tcin >> t;\n\tfor(int i=0 ; i < t ; i++ ){\n\t\tcin >> h >> w;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> f[y];\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tchar c = f[y][x];\n\t\t\t\tif( c == '>' || c == '<' || c == '^' || c == 'v' ){\n\t\t\t\t\ttx = x;\n\t\t\t\t\tty = y;\n\t\t\t\t\td = c;\n\t\t\t\t\tf[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> n >> s;\n\t\tsolve( s );\n\t\tf[ty][tx] = d;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcout << f[y] << endl;\n\t\t}\n\t\tif( i != t-1 ) cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//33\n#include<iostream>\n\nusing namespace std;\n\nint main(){\n  int t;\n  cin>>t;\n  while(t--){\n    int h,w;\n    cin>>h>>w;\n    char g[20][20];\n    int tx,ty,d=0;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n\tswitch(g[y][x]){\n\tcase '<':\n\t  d++;\n\tcase 'v':\n\t  d++;\n\tcase '>':\n\t  d++;\n\tcase '^':\n\t  ty=y;\n\t  tx=x;\n\t  g[y][x]='.';\n\t}\n      }\n    }\n    int n;\n    cin>>n;\n    while(n--){\n      char o;\n      cin>>o;\n      int dy[]={-1,0,1,0};\n      int dx[]={0,1,0,-1};\n      if(o=='S'){\n\tint gy=ty+dy[d];\n\tint gx=tx+dx[d];\n\tfor(;;){\n\t  if(gy<0||h<=gy||gx<0||w<=gx)break;\n\t  if(g[gy][gx]=='#')break;\n\t  if(g[gy][gx]=='*'){\n\t    g[gy][gx]='.';\n\t    break;\n\t  }\n\t  gy+=dy[d];\n\t  gx+=dx[d];\n\t}\n      }else{\n\td=(o=='U')?0:\n\t  (o=='R')?1:\n\t  (o=='D')?2:3;\n\tint ny=ty+dy[d];\n\tint nx=tx+dx[d];\n\tif(0<=ny&&ny<h&&0<=nx&&nx<w&&g[ny][nx]=='.'){\n\t  ty=ny;\n\t  tx=nx;\n\t}\n      }\n    }\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tif(y!=ty||x!=tx){\n\t  cout<<g[y][x];\n\t}else{\n\t  const char *tc=\"^>v<\";\n\t  cout<<tc[d];\n\t}\n      }\n      cout<<endl;\n    }\n    if(t){\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\t\n      "
  },
  {
    "language": "C++",
    "code": "/*\n * 2103.cpp\n *\n *  Created on: 2012/07/08\n *      Author: shimomire\n */\n\n#include <iostream>\n#include<algorithm>\n#include <complex>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define REPr(i,b,n) for(int i=n-1;i>=b;i--)\n#define REPr0(i,n)   REPr(i,0,n)\n\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\n#define ALL(o) (o).begin(),(o).end()\n#define ARRSIZE(x) (sizeof(x)/sizeof(x[0]))\n#define ARRALL(x) x,x+ARRSIZE(x)\n\ntypedef complex<double> P;\nbool operator <(const P& a, const P& b) {\n\treturn make_pair(real(a), imag(a)) < make_pair(real(b), imag(b));\n}\n\nint N, H, W;\n\nstring map[30];\n\nint main() {\n\tcin >> N;\n\n\twhile (N-- != 0) {\n\t\tcin >> H >> W;\n\n\t\tpair<int, int> pos;\n\t\tREP0(h,H){\n\t\t\tcin >>map[h];\n\t\t\tREP0(w,W) {\n\t\t\t\tif (map[h][w] == '^' || map[h][w] == '<' || map[h][w] == '>'\n\t\t\t\t\t\t|| map[h][w] == 'v') {\n\t\t\t\t\tpos = make_pair(h, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\tREP0(m,M) {\n\t\t\tchar op;\n\t\t\tcin >> op;\n\t\t\tswitch (op) {\n\t\t\tcase 'S':\n\t\t\t\tswitch (map[pos.first][pos.second]) {\n\t\t\t\tcase '^':\n\t\t\t\t\tfor (int h = pos.first - 1; h >= 0; h--) {\n\t\t\t\t\t\tif (map[h][pos.second] == '*') {\n\t\t\t\t\t\t\tmap[h][pos.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[h][pos.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tfor (int h = pos.first + 1; h < H; h++) {\n\t\t\t\t\t\tif (map[h][pos.second] == '*') {\n\t\t\t\t\t\t\tmap[h][pos.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[h][pos.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tfor (int w = pos.second - 1; w >= 0; w--) {\n\t\t\t\t\t\tif (map[pos.first][w] == '*') {\n\t\t\t\t\t\t\tmap[pos.first][w] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[pos.first][w] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tfor (int w = pos.second + 1; w < W; w++) {\n\t\t\t\t\t\tif (map[pos.first][w] == '*') {\n\t\t\t\t\t\t\tmap[pos.first][w] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[pos.first][w] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tmap[pos.first][pos.second] = '^';\n\t\t\t\tif (pos.first >= 1 && map[pos.first - 1][pos.second] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first - 1][pos.second] = '^';\n\t\t\t\t\tpos.first--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tmap[pos.first][pos.second] = 'v';\n\t\t\t\tif (pos.first < H - 1\n\t\t\t\t\t\t&& map[pos.first + 1][pos.second] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first + 1][pos.second] = 'v';\n\t\t\t\t\tpos.first++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':\n\t\t\t\tmap[pos.first][pos.second] = '>';\n\t\t\t\tif (pos.second < W - 1\n\t\t\t\t\t\t&& map[pos.first][pos.second + 1] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first][pos.second + 1] = '>';\n\t\t\t\t\tpos.second++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tmap[pos.first][pos.second] = '<';\n\t\t\t\tif (pos.second >= 1 && map[pos.first][pos.second - 1] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first][pos.second - 1] = '<';\n\t\t\t\t\tpos.second--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ends;\n\t\tREP0(h,H) {\n\t\t\tcout<<map[h]<< endl;\n\t\t}\n\t\tif(N>1)cout <<ends<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2103.cpp\n *\n *  Created on: 2012/07/08\n *      Author: shimomire\n */\n\n#include <iostream>\n#include<algorithm>\n#include <complex>\n\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n#define REPr(i,b,n) for(int i=n-1;i>=b;i--)\n#define REPr0(i,n)   REPr(i,0,n)\n\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\n#define ALL(o) (o).begin(),(o).end()\n#define ARRSIZE(x) (sizeof(x)/sizeof(x[0]))\n#define ARRALL(x) x,x+ARRSIZE(x)\n\ntypedef complex<double> P;\nbool operator <(const P& a, const P& b) {\n\treturn make_pair(real(a), imag(a)) < make_pair(real(b), imag(b));\n}\n\nint N, H, W;\n\nstring map[30];\n\nint main() {\n\tcin >> N;\n\n\twhile (N-- != 0) {\n\t\tcin >> H >> W;\n\n\t\tpair<int, int> pos;\n\t\tREP0(h,H){\n\t\t\tcin >>map[h];\n\t\t\tREP0(w,W) {\n\t\t\t\tif (map[h][w] == '^' || map[h][w] == '<' || map[h][w] == '>'\n\t\t\t\t\t\t|| map[h][w] == 'v') {\n\t\t\t\t\tpos = make_pair(h, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\tREP0(m,M) {\n\t\t\tchar op;\n\t\t\tcin >> op;\n\t\t\tswitch (op) {\n\t\t\tcase 'S':\n\t\t\t\tswitch (map[pos.first][pos.second]) {\n\t\t\t\tcase '^':\n\t\t\t\t\tfor (int h = pos.first - 1; h >= 0; h--) {\n\t\t\t\t\t\tif (map[h][pos.second] == '*') {\n\t\t\t\t\t\t\tmap[h][pos.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[h][pos.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tfor (int h = pos.first + 1; h < H; h++) {\n\t\t\t\t\t\tif (map[h][pos.second] == '*') {\n\t\t\t\t\t\t\tmap[h][pos.second] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[h][pos.second] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tfor (int w = pos.second - 1; w >= 0; w--) {\n\t\t\t\t\t\tif (map[pos.first][w] == '*') {\n\t\t\t\t\t\t\tmap[pos.first][w] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[pos.first][w] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tfor (int w = pos.second + 1; w < W; w++) {\n\t\t\t\t\t\tif (map[pos.first][w] == '*') {\n\t\t\t\t\t\t\tmap[pos.first][w] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (map[pos.first][w] == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\tmap[pos.first][pos.second] = '^';\n\t\t\t\tif (pos.first >= 1 && map[pos.first - 1][pos.second] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first - 1][pos.second] = '^';\n\t\t\t\t\tpos.first--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tmap[pos.first][pos.second] = 'v';\n\t\t\t\tif (pos.first < H - 1\n\t\t\t\t\t\t&& map[pos.first + 1][pos.second] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first + 1][pos.second] = 'v';\n\t\t\t\t\tpos.first++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':\n\t\t\t\tmap[pos.first][pos.second] = '>';\n\t\t\t\tif (pos.second < W - 1\n\t\t\t\t\t\t&& map[pos.first][pos.second + 1] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first][pos.second + 1] = '>';\n\t\t\t\t\tpos.second++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tmap[pos.first][pos.second] = '<';\n\t\t\t\tif (pos.second >= 1 && map[pos.first][pos.second - 1] == '.') {\n\t\t\t\t\tmap[pos.first][pos.second] = '.';\n\t\t\t\t\tmap[pos.first][pos.second - 1] = '<';\n\t\t\t\t\tpos.second--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<ends;\n\t\tREP0(h,H) {\n\t\t\tcout<<map[h]<< endl;\n\t\t}\n\t\tif(N>0)cout <<ends<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint W, H, x, y;\nvector<string> map(20);\n\nvoid Move(char c)\n{\n    if (c == 'U') {\n        map[y][x] = '^';\n        if (y - 1 >= 0 && map[y - 1][x] == '.') {\n            swap(map[y][x], map[y - 1][x]);\n            --y;\n        }\n    }\n    else if (c == 'D') {\n        map[y][x] = 'v';\n        if (y + 1 < H && map[y + 1][x] == '.') {\n            swap(map[y][x], map[y + 1][x]);\n            ++y;\n        }\n    }\n    else if (c == 'L') {\n        map[y][x] = '<';\n        if (x - 1 >= 0 && map[y][x - 1] == '.') {\n            swap(map[y][x], map[y][x - 1]);\n            --x;\n        }\n    }\n    else if (c == 'R') {\n        map[y][x] = '>';\n        if (x + 1 < W && map[y][x + 1] == '.') {\n            swap(map[y][x], map[y][x + 1]);\n            ++x;\n        }\n    }\n    else if (c == 'S') {\n        int dx = 0, dy = 0;\n        if (map[y][x] == '^')\n            dy = -1;\n        else if (map[y][x] == '>')\n            dx = 1;\n        else if (map[y][x] == 'v')\n            dy = 1;\n        else if (map[y][x] == '<')\n            dx = -1;\n\n        for (int i = 1; ; ++i) {\n            if (x + i * dx < 0 || x + i * dx >= W ||\n                y + i * dy < 0 || y + i * dy >= H)\n                break;\n            if (map[y + i * dy][x + i * dx] == '*') {\n                map[y + i * dy][x + i * dx] = '.';\n                break;\n            }\n            if (map[y + i * dy][x + i * dx] == '#')\n                break;\n        }\n    }\n}\n\nint main()\n{\n    int T;\n\n    cin >> T;\n    while (T--) {\n        cin >> H >> W;\n\n        for (int i = 0; i < H; ++i)\n            cin >> map[i];\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j)\n                if (map[i][j] == '^' || map[i][j] == '>' ||\n                    map[i][j] == 'v' || map[i][j] == '<')\n                    x = j, y = i;\n\n        string order;\n        int num;\n\n        cin >> num;\n        cin >> order;\n\n        for (int i = 0; i < num; ++i)\n            Move(order[i]);\n\n        // Output\n        for (int i = 0; i < H; ++i)\n            cout << map[i] << \"\\n\";\n        if (T != 0)\n            cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nenum Mapchip{BLANK='.',BRICK='*',STEAL='#',WATER='-',UP='^',DOWN='v',LEFT='<',RIGHT='>'};\nstruct Tank{int x,y;char dir;};\n\nint T,H,W,N;\nstring manip;\nvector<string>field;\nTank me;\n\nvoid move(char dir){\n  Tank next;\n  next.y = me.y + (dir==DOWN)-(dir==UP);\n  next.x = me.x + (dir==RIGHT)-(dir==LEFT);\n  next.dir = dir;\n  if(next.x<0 || W<=next.x || next.y<0 || H<=next.y || field[next.y][next.x]!=BLANK){\n    me.dir=dir;\n    field[me.y][me.x]=dir;\n    return;\n  }else{\n    field[me.y][me.x]=BLANK;\n    field[next.y][next.x]=next.dir;\n    me=next;\n    return;\n  }\n  return;\n}\n\nvoid shoot(){\n  Tank next;\n  int dx,dy,x,y;\n  dy = (me.dir==DOWN)-(me.dir==UP);\n  dx = (me.dir==RIGHT)-(me.dir==LEFT);\n  y = me.y + dy;\n  x = me.x + dx;\n  while(0<=x && x<W && 0<=y && y<H){\n    if(field[y][x]==STEAL){\n      break;\n    }else if(field[y][x]==BRICK){\n      field[y][x]=BLANK;\n      break;\n    }\n    y+=dy;\n    x+=dx;\n  }\n  return;\n}\n\nint main()\n{\n  int i,j;\n  cin>>T;\n  while(T-->0){\n    cin>>H>>W;\n    field.resize(H);\n    for(i=0;i<H;i++){\n      cin>>field[i];\n      string tanks=\"^v<>\";\n      for(j=0;j<W;j++){\n\tif(tanks.find(field[i][j])!=string::npos){\n\t  me.x=j;\n\t  me.y=i;\n\t  me.dir=field[i][j];\n\t}\n      }\n    }\n    cin>>N>>manip;\n\n    for(i=0;i<N;i++){\n      switch(manip[i]){\n      case 'U':\n\tmove(UP);\n\tbreak;\n      case 'D':\n\tmove(DOWN);\n\tbreak;\n      case 'L':\n\tmove(LEFT);\n\tbreak;\n      case 'R':\n\tmove(RIGHT);\n\tbreak;\n      case 'S':\n\tshoot();\n\tbreak;\n      default:\n\tcout<<\"error\"<<endl;\n\tbreak;\n      }\n      continue;\n    }\n\n    for(i=0;i<H;i++)cout<<field[i]<<endl;\n    if(T!=0)puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define int long long\nusing namespace std;\nchar map[23][23];\nint h, w, a, b, x, y;\nvoid f(char ch) {\n\tif (ch == '^') { a = -1; b = 0; return; }\n\tif (ch == 'v') { a = 1; b = 0; return; }\n\tif (ch == '<') { a = 0; b = -1; return; }\n\tif (ch == '>') { a = 0; b = 1; return; }\n}\nvoid f1() {\n\tif (x + a < 1 || h < x + a || y + b < 1 || w < y + b)return;\n\tif (map[x + a][y + b] == '.') {\n\t\tswap(map[x + a][y + b], map[x][y]);\n\t\tx += a; y += b;\n\t}\n\treturn;\n}\nvoid solve() {\n\tcin >> h >> w;\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcin >> map[i][j];\n\t\t\tif (map[i][j] == '^' || map[i][j] == 'v' || map[i][j] == '<' || map[i][j] == '>') {\n\t\t\t\tf(map[i][j]); x = i; y = j;\n\t\t\t}\n\t\t}\n\t}\n\tstring s; cin >> s >> s;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == 'S') {\n\t\t\tint x1 = x, y1 = y;\n\t\t\tfor (; !(x1 + a < 1 || h < x1 + a || y1 + b < 1 || w < y1 + b);) {\n\t\t\t\tif (map[x1 + a][y1 + b] == '#')break;\n\t\t\t\telse if (map[x1 + a][y1 + b] == '*') { map[x1 + a][y1 + b] = '.'; break; }\n\t\t\t\telse {\n\t\t\t\t\tx1 += a; y1 += b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (s[i] == 'U') map[x][y] = '^';\n\t\t\telse if (s[i] == 'D') map[x][y] = 'v';\n\t\t\telse if (s[i] == 'L') map[x][y] = '<';\n\t\t\telse if (s[i] == 'R') map[x][y] = '>';\n\t\t\tf(map[x][y]); f1();\n\t\t}\n\t}\n\tfor (int i = 1; i <= h; i++) {\n\t\tfor (int j = 1; j <= w; j++) {\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn;\n}\nsigned main() {\n\tint n; cin >> n; for (int i = 0; i < n; i++) { if (i)cout << endl; solve(); }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nusing namespace std;\nint T, H, W, N; string s[22], t;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nint main() {\n\tcin >> T;\n\twhile (T--) {\n\t\tcin >> H >> W;\n\t\tfor (int i = 0; i < H; i++) cin >> s[i];\n\t\tcin >> N >> t;\n\t\tint tx = 0, ty = 0, d = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar c = s[i][j];\n\t\t\t\tif (c == 'v') tx = j, ty = i, d = 0;\n\t\t\t\tif (c == '>') tx = j, ty = i, d = 1;\n\t\t\t\tif (c == '^') tx = j, ty = i, d = 2;\n\t\t\t\tif (c == '<') tx = j, ty = i, d = 3;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tchar c = t[i];\n\t\t\tif (c == 'D') d = 0, s[ty][tx] = 'v';\n\t\t\tif (c == 'R') d = 1, s[ty][tx] = '>';\n\t\t\tif (c == 'U') d = 2, s[ty][tx] = '^';\n\t\t\tif (c == 'L') d = 3, s[ty][tx] = '<';\n\t\t\tif (c != 'S') {\n\t\t\t\tint sx = tx + dx[d], sy = ty + dy[d];\n\t\t\t\tif (rng(sx, sy) && s[sy][sx] == '.') s[sy][sx] = s[ty][tx], s[ty][tx] = '.', tx = sx, ty = sy;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint sx = tx, sy = ty;\n\t\t\t\twhile (true) {\n\t\t\t\t\tsx += dx[d];\n\t\t\t\t\tsy += dy[d];\n\t\t\t\t\tif (!rng(sx, sy)) break;\n\t\t\t\t\tif (s[sy][sx] == '*') { s[sy][sx] = '.'; break; }\n\t\t\t\t\tif (s[sy][sx] == '#') break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) cout << s[i] << endl;\n\t\tif (T) cout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n \nusing namespace std;\n \ntypedef pair<int,int> P;\nconst int MAX = 20;\nP pos;\nchar m[MAX][MAX];\nint r,c;\nvoid input(){\n  for(int i = 0; i < r; i++)\n    for(int j = 0; j < c; j++){\n      cin >> m[i][j];\n      if(m[i][j] == '<' || m[i][j] == '>' ||\n     m[i][j] == '^' || m[i][j] == 'v') pos = P(i,j);\n    }\n   \n}\n \nbool inside(P p){\n  return (0 <= p.first && p.first < r && 0 <= p.second && p.second < c);\n}\n \nvoid shoot(char c){\n \n  int x = 0, y = 0;\n  P p = pos;\n  if(c == '^') y = -1;\n  if(c == 'v') y = 1;\n  if(c == '>') x = 1;\n  if(c == '<') x = -1;\n \n  while(1){\n    p.first += y;\n    p.second += x;\n    if(!inside(p)) break;\n    if(m[p.first][p.second] == '#') break;\n    if(m[p.first][p.second] == '*'){\n      m[p.first][p.second] = '.';\n      break;\n    }\n  }\n}\n \nbool movable(char c){\n  string s = \"\";\n \n  for(int i = 0; i < s.length(); i++)\n    if(c == s[i]) return false;\n \n  return true;\n}\n \n \nvoid move(char c, int x, int y){\n  if(0 <= pos.first+y && pos.first+y < r &&\n     0 <= pos.second+x && pos.second+x < c &&\n     m[pos.first+y][pos.second+x] == '.'){\n    m[pos.first][pos.second] = '.';\n    m[pos.first+y][pos.second+x] = c;\n    pos.first += y;\n    pos.second += x;\n  }else{\n    m[pos.first][pos.second] = c;\n  }\n}\n \nint main(){\n  bool flag = false;\n  int X;\n  cin >> X;\n  while(X--){\n    if(flag) cout << endl;\n    flag = true;\n \n    cin >> r >> c;\n    input();\n    int num;\n    cin >> num;\n    for(int i = 0; i < num; i++){\n      char c;\n      cin >> c;\n      if(c == 'S') shoot(m[pos.first][pos.second]);\n      if(c == 'U') move('^',0,-1);\n      if(c == 'D') move('v',0,1);\n      if(c == 'L') move('<',-1,0);\n      if(c == 'R') move('>',1,0);\n    }\n \n    for(int i = 0; i < r; i++){\n      for(int j = 0; j < c; j++)\n    cout << m[i][j];\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nint main()\n{\n\tint T;\n\tcin >> T;\n\twhile (T--)\n\t{\n\t\tint h, w;\n\t\tcin >> h >> w;\n\n\t\tchar m[32][32];\n\t\tCLEAR(m, '#');\n\t\tfor (int y = 1; y <= h; ++y)\n\t\t{\n\t\t\tcin >> m[y] + 1;\n\t\t\tm[y][w + 1] = '#';\n\t\t}\n\n\t\tconst char* dd = \"v>^<\";\n\t\tint x, y, dir;\n\t\tfor (int yy = 1; yy <= h; ++yy)\n\t\t\tfor (int xx = 1; xx <= w; ++xx)\n\t\t\t\tif (strchr(dd, m[yy][xx]))\n\t\t\t\t{\n\t\t\t\t\tx = xx, y = yy;\n\t\t\t\t\tdir = strchr(dd, m[yy][xx]) - dd;\n\t\t\t\t\tm[yy][xx] = '.';\n\t\t\t\t}\n\n\t\tint n;\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tchar c = s[i];\n\n\t\t\tconst char* dc = \"DRUL\";\n\t\t\tif (strchr(dc, c))\n\t\t\t{\n\t\t\t\tdir = strchr(dc, c) - dc;\n\t\t\t\tint tx = x + dx[dir], ty = y + dy[dir];\n\t\t\t\tif (m[ty][tx] == '.')\n\t\t\t\t\tx = tx, y = ty;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint tx = x + dx[dir], ty = y + dy[dir];\n\t\t\t\twhile (m[ty][tx] != '#')\n\t\t\t\t{\n\t\t\t\t\tif (m[ty][tx] == '*')\n\t\t\t\t\t{\n\t\t\t\t\t\tm[ty][tx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttx += dx[dir], ty += dy[dir];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm[y][x] = dd[dir];\n\n\t\tfor (int yy = 1; yy <= h; ++yy)\n\t\t{\n\t\t\tfor (int xx = 1; xx <= w; ++xx)\n\t\t\t\tcout << m[yy][xx];\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tstring field[20];\n\t\tfor(int i = 0; i < h; ++i){ cin >> field[i]; }\n\t\tint x, y, dir;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tswitch(field[i][j]){\n\t\t\t\t\tcase '^': x = j; y = i; dir = 0; break;\n\t\t\t\t\tcase 'v': x = j; y = i; dir = 1; break;\n\t\t\t\t\tcase '<': x = j; y = i; dir = 2; break;\n\t\t\t\t\tcase '>': x = j; y = i; dir = 3; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tstring cmd;\n\t\tcin >> m >> cmd;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tswitch(cmd[i]){\n\t\t\t\tcase 'U':\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tif(y > 0 && field[y - 1][x] == '.'){ field[y][x] = '.'; --y; }\n\t\t\t\t\tfield[y][x] = '^';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdir = 1;\n\t\t\t\t\tif(y < h - 1 && field[y + 1][x] == '.'){ field[y][x] = '.'; ++y; }\n\t\t\t\t\tfield[y][x] = 'v';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tif(x > 0 && field[y][x - 1] == '.'){ field[y][x] = '.'; --x; }\n\t\t\t\t\tfield[y][x] = '<';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tdir = 3;\n\t\t\t\t\tif(x < w - 1 && field[y][x + 1] == '.'){ field[y][x] = '.'; ++x; }\n\t\t\t\t\tfield[y][x] = '>';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tif(dir == 0){\n\t\t\t\t\t\tint i = y - 1;\n\t\t\t\t\t\tfor(; i >= 0; --i){ if(field[i][x] == '*' || field[i][x] == '#'){ break; } }\n\t\t\t\t\t\tif(i >= 0 && field[i][x] == '*'){ field[i][x] = '.'; }\n\t\t\t\t\t}else if(dir == 1){\n\t\t\t\t\t\tint i = y + 1;\n\t\t\t\t\t\tfor(; i < h; ++i){ if(field[i][x] == '*' || field[i][x] == '#'){ break; } }\n\t\t\t\t\t\tif(i < h && field[i][x] == '*'){ field[i][x] = '.'; }\n\t\t\t\t\t}else if(dir == 2){\n\t\t\t\t\t\tint i = x - 1;\n\t\t\t\t\t\tfor(; i >= 0; --i){ if(field[y][i] == '*' || field[y][i] == '#'){ break; } }\n\t\t\t\t\t\tif(i >= 0 && field[y][i] == '*'){ field[y][i] = '.'; }\n\t\t\t\t\t}else if(dir == 3){\n\t\t\t\t\t\tint i = x + 1;\n\t\t\t\t\t\tfor(; i < w; ++i){ if(field[y][i] == '*' || field[y][i] == '#'){ break; } }\n\t\t\t\t\t\tif(i < w && field[y][i] == '*'){ field[y][i] = '.'; }\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tfor(int j = 0; j < h; ++j){ cout << field[j] << endl; }\n//\t\t\tcout << endl;\n\t\t}\n\t\tfor(int i = 0; i < h; ++i){ cout << field[i] << endl; }\n\t\tif(n != 0){ cout << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<list>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<cmath>\nusing namespace std;\nint main() {\n\tint u, n, m;\n\tcin >> u;\n\tfor (int z = 0; z < u; z++) {\n\t\tif (z != 0) cout << endl;\n\t\tcin >> n >> m;\n\t\tchar a[20][20];\n\t\tint b[2];\n\t\tstring t;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> t;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\ta[i][j] = t[j];\n\t\t\t\tif (a[i][j] == '>' || a[i][j] == '<' || a[i][j] == '^' || a[i][j] == 'v') {\n\t\t\t\t\tb[0] = i;\n\t\t\t\t\tb[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s;\n\t\tcin >> s;\n\t\tcin >> t;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tchar d;\n\t\t\td=t[i];\n\t\t\tswitch (d)\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\ta[b[0]][b[1]] = '^';\n\t\t\t\tif (b[0] - 1 >= 0 && a[b[0] - 1][b[1]] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[0]--;\n\t\t\t\t\ta[b[0]][b[1]] = '^';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\ta[b[0]][b[1]] = 'v';\n\t\t\t\tif (b[0] + 1 < n && a[b[0] + 1][b[1]] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[0]++;\n\t\t\t\t\ta[b[0]][b[1]] = 'v';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ta[b[0]][b[1]] = '<';\n\t\t\t\tif (b[1] - 1 >= 0 && a[b[0]][b[1] - 1] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[1]--;\n\t\t\t\t\ta[b[0]][b[1]] = '<';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\ta[b[0]][b[1]] = '>';\n\t\t\t\tif (b[1] + 1 < m && a[b[0]][b[1] + 1] == '.') {\n\t\t\t\t\ta[b[0]][b[1]] = '.';\n\t\t\t\t\tb[1]++;\n\t\t\t\t\ta[b[0]][b[1]] = '>';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tint x=0, y=0;\n\t\t\t\tif (a[b[0]][b[1]] == '^') {\n\t\t\t\t\tx = -1;\n\t\t\t\t}\n\t\t\t\telse if (a[b[0]][b[1]] == 'v') {\n\t\t\t\t\tx = 1;\n\t\t\t\t}\n\t\t\t\telse if (a[b[0]][b[1]] == '>') {\n\t\t\t\t\ty = 1;\n\t\t\t\t}\n\t\t\t\telse if (a[b[0]][b[1]] == '<') {\n\t\t\t\t\ty = -1;\n\t\t\t\t}\n\t\t\t\tint k = b[0], l = b[1];\n\t\t\t\twhile (k < n&&k >= 0 && l < m&&l >= 0) {\n\t\t\t\t\tif (a[k][l] == '*') {\n\t\t\t\t\t\ta[k][l] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (a[k][l] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tk += x;\n\t\t\t\t    l += y;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcout << a[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem2103 : Battle Town **/\nint main()\n{\n\tint T, W, H; cin>>T;\n\tbool first = true;\n\tstring ds = \"^>v<\";\n\t\n\trep(z, T) {\n\t\tcin>>H>>W;\n\t\tchar field[H][W];\n\t\tP p; int d=0;\n\t\t\n\t\trep(y, H) rep(x, W) {\n\t\t\tcin>>field[y][x];\n\t\t\t\n\t\t\tif (field[y][x]=='>') {\n\t\t\t\tp.first=x, p.second=y;\n\t\t\t\td=1;\n\t\t\t\tfield[y][x] = '.';\n\t\t\t}\n\t\t\t\n\t\t\tif (field[y][x]=='^') {\n\t\t\t\tp.first=x, p.second=y;\n\t\t\t\td=0;\n\t\t\t\tfield[y][x] = '.';\n\t\t\t}\n\t\t\t\n\t\t\tif (field[y][x]=='v') {\n\t\t\t\tp.first=x, p.second=y;\n\t\t\t\td=2;\n\t\t\t\tfield[y][x] = '.';\n\t\t\t}\n\t\t\t\n\t\t\tif (field[y][x]=='<') {\n\t\t\t\tp.first=x, p.second=y;\n\t\t\t\td=3;\n\t\t\t\tfield[y][x] = '.';\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring S; int N;\n\t\tcin>>N>>S;\n\t\t\n\t\trep(i, N) {\n\t\t\tif (S[i] == 'S') {\n\t\t\t\tint sx = p.first, sy = p.second;\n\t\t\t\twhile (1) {\n\t\t\t\t\tsx+=dx[d], sy+=dy[d];\n\t\t\t\t\tif_range(sx, sy, W, H) {\n\t\t\t\t\t\tif (field[sy][sx] == '#') break;\n\t\t\t\t\t\tif (field[sy][sx] == '*') {field[sy][sx]='.'; break;}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (S[i] == 'U')\n\t\t\t\t\td=0;\n\t\t\t\tif (S[i] == 'D')\n\t\t\t\t\td=2;\n\t\t\t\tif (S[i] == 'L')\n\t\t\t\t\td=3;\n\t\t\t\tif (S[i] == 'R')\n\t\t\t\t\td=1;\n\t\t\t\t\n\t\t\t\tint nx = p.first+dx[d], ny = p.second+dy[d];\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t\tp.first = nx, p.second = ny;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif (!first) cout << endl;\n\t\trep(y, H) {\n\t\t\trep(x, W) {\n\t\t\t\tif (x == p.first && y == p.second)\n\t\t\t\t\tcout << ds[d];\n\t\t\t\telse\n\t\t\t\t\tcout << field[y][x];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t\tfirst = false;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint dx[] = {0,0,-1,1};\nint dy[] = {1,-1,0,0};\n\nint direction(char c) {\n\tint dir;\n\tif(c == '^')\n\t\tdir = 1;\n\telse if(c == 'v')\n\t\tdir = 0;\n\telse if(c == '>')\n\t\tdir = 3;\n\telse\n\t\tdir = 2;\n\treturn dir;\n}\n\nint main() {\n\tint T;\n\tcin >> T;\n\tfor(int t = 0; t < T; t++) {\n\t\tint H, W, N;\n\t\tvector<string> board;\n\t\tstring command;\n\t\tcin >> H >> W;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tboard.push_back(s);\n\t\t}\n\t\tcin >> N >> command;\n\t\tchar c;\n\t\tint x, y;\n\n\t\tfor(int i = 0; i < board.size(); i++) {\n\t\t\tfor(int j = 0; j < board.size(); j++) {\n\t\t\t\tc = board[i][j];\n\t\t\t\tif(c == '^' || c == 'v' || c == '>' || c == '<') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<string> res = board;\n\t\tfor(int i = 0; i < command.size(); i++) {\n\t\t\tif(command[i] == 'S') {\n\t\t\t\tint dir = direction(res[y][x]);\n\t\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\t\twhile(0 <= nx && nx < W && 0 <= ny && ny < H) {\n\t\t\t\t\tif(res[ny][nx] == '*') {\n\t\t\t\t\t\tres[ny][nx] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(res[ny][nx] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnx += dx[dir];\n\t\t\t\t\tny += dy[dir];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint c = command[i];\n\t\t\t\tif(c == 'U') {\n\t\t\t\t\tif(y > 0 && res[y-1][x] == '.') {\n\t\t\t\t\t\tres[y][x] = '.';\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\tres[y][x] = '^';\n\t\t\t\t}\n\t\t\t\telse if(c == 'D') {\n\t\t\t\t\tif(y < H-1 && res[y+1][x] == '.') {\n\t\t\t\t\t\tres[y][x] = '.';\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\tres[y][x] = 'v';\n\t\t\t\t}\n\t\t\t\telse if(c == 'R') {\n\t\t\t\t\tif(x < W-1 && res[y][x+1] == '.') {\n\t\t\t\t\t\tres[y][x] = '.';\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tres[y][x] = '>';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(x > 0 && res[y][x-1] == '.') {\n\t\t\t\t\t\tres[y][x] = '.';\n\t\t\t\t\t\tx--;\n\t\t\t\t\t}\n\t\t\t\t\tres[y][x] = '<';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\t\t\t\t\tcout << x << \",\" << y << endl;\n\t\t}\n\n\t\tif(t) cout << endl;\n\t\tfor(int i = 0; i < res.size(); i++)\n\t\t\tcout << res[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint T, H, W, N;\nchar m[22][32], q[110];\nconst char dir[] = { 'U', 'R', 'D', 'L' };\nconst char dir_c[] = { '^', '>', 'v', '<' };\nconst int di[] = { -1, 0, 1, 0 };\nconst int dj[] = { 0, 1, 0, -1 };\n\nbool is_tank(char c) { return c == '<' || c == '>' || c == '^' || c == 'v' ; }\n\nint get_dir(char c) {\n  int ret = -1;\n  rep(i,4) if (c == dir[i]) ret = i;\n  return ret;\n}\nchar get_dir_c(char c) {\n  char ret = -1;\n  rep(i,4) if (c == dir[i]) ret = dir_c[i];\n  return ret;\n}\n\nvoid do_shoot(int dir, int ci, int cj) {\n  while (0 <= ci && ci < H && 0 <= cj && cj < W) {\n    bool flag = false;\n    switch (m[ci][cj]) {\n      case '-':\n      case '.': break;\n      case '#': flag = true; break;\n      case '*': m[ci][cj] = '.'; flag = true; break;\n    }\n    if (flag) break;\n    ci += di[dir];\n    cj += dj[dir];\n  }\n}\n\nvoid f() {\n  int dir = -1, ci = -1, cj = -1;\n  rep(i,H) rep(j,W) if(is_tank(m[i][j])) {\n    switch (m[i][j]) {\n      case '^': dir = 0; break;\n      case '>': dir = 1; break;\n      case 'v': dir = 2; break;\n      case '<': dir = 3; break;\n    }\n    ci = i, cj = j;\n    break;\n  }\n  rep(i,N) {\n    if (q[i] == 'S') {\n      do_shoot(dir, ci, cj);\n    } else {\n      dir = get_dir(q[i]);\n      int ti = ci + di[dir], tj = cj + dj[dir];\n      if (0 <= ti && ti < H && 0 <= tj && tj <= W && m[ti][tj] == '.') {\n        m[ci][cj] = '.';\n        m[ti][tj] = get_dir_c(q[i]);\n        ci = ti, cj = tj;\n      }\n    }\n    // puts(\"----------\");\n    // rep(i,H) printf(\"%s\\n\", m[i]);\n    // puts(\"\");\n  }\n  rep(i,H) printf(\"%s\\n\", m[i]);\n}\n\nint main() {\n  scanf(\"%d\", &T);\n  rep(loop,T) {\n    if (loop) puts(\"\");\n    scanf(\"%d%d\", &H, &W);\n    rep(i,H) scanf(\"%s\", m[i]);\n    scanf(\"%d\", &N);\n    scanf(\"%s\", q);\n    f();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef struct TankState{\n  int x, y, dir;//u:0, r:1, d:2, l:3\n}TankState;\n\nbool range(int x, int y, int w, int h){\n  return (0 <= x and x < w) and (0 <= y and y < h);\n}\n\nint main(){\n  int n;\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {-1, 0, 1, 0};\n  std::cin >> n;\n  for (int l = 0; l < n; l++) {\n    TankState pos;\n    int h, w;\n    std::cin >> h >> w;\n    vector<string> vs(h);\n    for (int i = 0; i < h; i++) std::cin >> vs[i];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(vs[i][j] == '^')pos.x = j, pos.y = i, pos.dir = 0;\n        if(vs[i][j] == '>')pos.x = j, pos.y = i, pos.dir = 1;\n        if(vs[i][j] == 'v')pos.x = j, pos.y = i, pos.dir = 2;\n        if(vs[i][j] == '<')pos.x = j, pos.y = i, pos.dir = 3;\n      }\n    }\n    string operation;\n    int tmp;\n    std::cin >> tmp >> operation;\n    for (int i = 0; i < operation.length(); i++) {\n      if(operation[i] == 'S'){\n        int x = pos.x, y = pos.y;\n        while(range(x, y, w, h) and \n              vs[y][x] != '*' and vs[y][x] != '#')\n          y += dy[pos.dir], x += dx[pos.dir];\n        if(range(x, y, w, h) and vs[y][x] == '*')vs[y][x] = '.';\n      }else if(operation[i] == 'U'){\n        pos.dir = 0;\n        if(range(pos.x, pos.y - 1, w, h) and\n           vs[pos.y - 1][pos.x] == '.'){\n          vs[pos.y - 1][pos.x] = '^';\n          vs[pos.y][pos.x] = '.';\n          pos.y -= 1;\n        }\n      }else if(operation[i] == 'R'){\n        pos.dir = 1;\n        if(range(pos.x + 1, pos.y, w, h) and\n           vs[pos.y][pos.x + 1] == '.'){\n          vs[pos.y][pos.x + 1] = '>';\n          vs[pos.y][pos.x] = '.';\n          pos.x += 1;\n        }\n      }else if(operation[i] == 'D'){\n        pos.dir = 2;\n        if(range(pos.x, pos.y + 1, w, h) and\n           vs[pos.y + 1][pos.x] == '.'){\n          vs[pos.y + 1][pos.x] = 'v';\n          vs[pos.y][pos.x] = '.';\n          pos.y += 1;\n        }\n      }else if(operation[i] == 'L'){\n        pos.dir = 3;\n        if(range(pos.x - 1, pos.y, w, h) and\n           vs[pos.y][pos.x - 1] == '.'){\n          vs[pos.y][pos.x - 1] = '<';\n          vs[pos.y][pos.x] = '.';\n          pos.x -= 1;\n        }\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      std::cout << vs[i] << std::endl;\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[]={-1,0,1,0};\nint dy[]={0,1,0,-1};\nvoid shot(const int ax,const int ay,vector<string>&field,int way){\n    int nextx=ax;\n    int nexty=ay;\n    while(true){\n        nextx+=dx[way];\n        nexty+=dy[way];\n        char& ch(field[nexty][nextx]);\n        if(ch=='.')continue;\n        else if(ch=='*'){\n            ch='.';\n            return;\n        }else if(ch=='#'){\n            return;\n        }else if(ch=='-')continue;\n        else{\n            assert(false);\n        }\n    }\n}\nint main(){\n    int T;cin>>T;\n    while(T--){\n        int H,W;cin>>H>>W;\n        H+=2;\n        W+=2;\n        vector<string>field(H);\n        field[0]=string(W,'#');\n        for(int i=0;i<H-2;++i){\n            string st;cin>>st;\n            field[i+1]=\"#\"+st+\"#\";\n        }\n        field[H-1]=string(W,'#');\n        int way;\n        int tank_x,tank_y;\n        string way_mp=\"<v>^\";\n        {\n            for(int y=0;y<H;++y){\n                for(int x=0;x<W;++x){\n                    char ch=field[y][x];\n                    if(way_mp.find(ch)!=-1){\n                        way=way_mp.find(ch);\n                        field[y][x]='.';\n                        tank_x=x;\n                        tank_y=y;\n                    }\n                }\n            }\n        }\n        int N;cin>>N;\n        string move_st;\n        cin>>move_st;\n\n        for(auto ch:move_st){\n            string move_mp(\"LDRUS\");\n            int k=move_mp.find(ch);\n            if(k==4){\n                shot(tank_x,tank_y,field,way);\n            }else{\n                way=k;\n                int next_tank_x=tank_x+dx[way];\n                int next_tank_y=tank_y+dy[way];\n                if(field[next_tank_y][next_tank_x]=='.'){\n                    tank_x=next_tank_x;\n                    tank_y=next_tank_y;\n                }\n            }\n        }\n        field[tank_y][tank_x]=way_mp[way];\n        for(int i=1;i<H-1;++i){\n            cout<<field[i].substr(1,W-2)<<endl;\n        }\n        if(T)cout<<endl;\n        \n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\nusing namespace std;\nint H,W,dir,x,y;//dir 0->U 1->D 2->L 3->R\nchar cmap[30][30],tank[4] = {'^','v','<','>'};\nstring op;\nint dx[4] = {0,0,-1,1};// U D L R\nint dy[4] = {-1,1,0,0};\n\nvoid op_U(){\n  dir = 0;\n  if( 0 <= y-1 && cmap[y-1][x] == '.'){\n    cmap[y][x] = '.';\n    y--; \n  } \n  cmap[y][x] = tank[dir];\n}\n\nvoid op_D(){\n  dir = 1;\n  if(y+1<H && cmap[y+1][x] == '.'){\n    cmap[y][x] = '.';\n    y++;\n  }\n  cmap[y][x] = tank[dir];\n}\n\nvoid op_L(){\n  dir = 2;\n  if(0<=x-1 && cmap[y][x-1] == '.'){\n    cmap[y][x] = '.';\n    x--;\n  }\n  cmap[y][x] = tank[dir];\n}\n\nvoid op_R(){\n  dir = 3;\n  if(x+1<W && cmap[y][x+1] == '.'){\n    cmap[y][x] = '.';\n    x++;\n  \n  }\n  cmap[y][x] = tank[dir];\n}\n\nvoid op_S(){\n  int cnt=1;\n  while(true){\n    if(!( 0<=x+dx[dir]*cnt  && x+dx[dir]*cnt < W && 0<=y+dy[dir]*cnt && y+dy[dir]*cnt < H) )break;\n    if(cmap[y+dy[dir]*cnt][x+dx[dir]*cnt] == '*'){\n      cmap[y+dy[dir]*cnt][x+dx[dir]*cnt] = '.';\n      break;\n    }\n    else if(cmap[y+dy[dir]*cnt][x+dx[dir]*cnt] == '#'){\n      break;\n    }\n    cnt++;\n  }\n}\n\nvoid display(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cout << cmap[i][j];\n    }\n    cout << endl;\n  }\n}\n\nvoid solve(){\n  for(int i=0;i<op.length();i++){\n    if(op[i] == 'U')op_U();\n    else if(op[i] == 'D')op_D();\n    else if(op[i] == 'L')op_L();\n    else if(op[i] == 'R')op_R();\n    else if(op[i] == 'S')op_S();\n  }\n  display();\n}\n\n\n\n\nint main(){\n  int T,enu;\n  cin >> T;\n  while(T-- > 0){\n    cin >> H >> W;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> cmap[i][j];\n\tif(cmap[i][j] == '^'){\n\t  dir = 0;\n\t  x = j; y = i;\n\t}\n\telse if(cmap[i][j] == 'v'){\n\t  dir = 1;\n\t  x = j; y = i;\n\t}\n\telse if(cmap[i][j] == '<'){\n\t  dir = 2;\n\t  x = j; y = i;\n\t}\n\telse if(cmap[i][j] == '>'){\n\t  dir = 3;\n\t  x = j; y = i;\n\t}\n      }\n    }\n    cin >> enu;\n    cin >> op;\n    solve();\n    if(T > 0)cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint t, h, w, n, i, j, k, l, x, y, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar field[20][21], c, dir[] = {\"^>v<\"};/*　鉄壁　レンガ壁　水　平地 */;\n\tscanf(\"%d\",&t);\n\tfor(i = 0;i < t;i++){\n\t\tscanf(\"%d%d%*c\",&h,&w);\n\t\tfor(j = 0;j < h;j++){\n\t\t\tfor(k = 0;k < w;k++){\n\t\t\t\tfield[j][k] = getchar();\n\t\t\t\tfor(l = 0;l < 4;l++){\n\t\t\t\t\tif(dir[l] == field[j][k]){\n\t\t\t\t\t\ty = j, x = k;\n\t\t\t\t\t\td = l;\n\t\t\t\t\t\tfield[j][k] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[j][k] = '\\0';\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d%*c\",&n);\n\t\tfor(k = 0;k < n;k++){\n\t\t\tc = getchar();\n\t\t\tif(c == 'U'){\n\t\t\t\tif(y - 1 >= 0 && field[y - 1][x] == '.')\n\t\t\t\t\ty--;\n\t\t\t\td = 0;\n\t\t\t}\n\t\t\telse if(c == 'D'){\n\t\t\t\tif(y + 1 < h && field[y + 1][x] == '.')\n\t\t\t\t\ty++;\n\t\t\t\td = 2;\n\t\t\t}\n\t\t\telse if(c == 'L'){\n\t\t\t\tif(x - 1 >= 0 && field[y][x - 1] == '.')\n\t\t\t\t\tx--;\n\t\t\t\td = 3;\n\t\t\t}\n\t\t\telse if(c == 'R'){\n\t\t\t\tif(x + 1 < w && field[y][x + 1] == '.')\n\t\t\t\t\tx++;\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\telse if(c == 'S'){\n\t\t\t\tfor(j = 1;y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && (field[y + dy[d] * j][x + dx[d] * j] == '.' || field[y + dy[d] * j][x + dx[d] * j] == '-');j++);\n\t\t\t\tif(y + dy[d] * j >= 0 && y + dy[d] * j < h && x + dx[d] * j >= 0 && x + dx[d] * j < w && field[y + dy[d] * j][x + dx[d] * j] == '*')\n\t\t\t\t\tfield[y + dy[d] * j][x + dx[d] * j] = '.';\n\t\t\t}\n\t\t}\n\t\tfield[y][x] = dir[d];\n\t\tfor(j = 0;j < h;j++){\n\t\t\tfor(k = 0;k < w;k++) printf(\"%c\",field[j][k]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nint t;\nint h, w, n;\nstring field[100];\nstring s;\nP pos;\n\nvoid solve(char c){\n\tint y = pos.first, x = pos.second;\n\tif (c == 'U'){\n\t\tif (y != 0){\n\t\t\tif (field[y - 1][x] == '.'){\n\t\t\t\tfield[y - 1][x] = '^';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\ty--;\n\t\t\t}\n\t\t\telse field[y][x] = '^';\n\t\t}\n\t\telse field[y][x] = '^';\n\t}\n\telse if (c == 'D'){\n\t\tif (y != h - 1){\n\t\t\tif (field[y + 1][x] == '.'){\n\t\t\t\tfield[y + 1][x] = 'v';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\ty++;\n\t\t\t}\n\t\t\telse field[y][x] = 'v';\n\t\t}\n\t\telse field[y][x] = 'v';\n\t}\n\telse if (c == 'L'){\n\t\tif (x != 0){\n\t\t\tif (field[y][x - 1] == '.'){\n\t\t\t\tfield[y][x - 1] = '<';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tx--;\n\t\t\t}\n\t\t\telse field[y][x] = '<';\n\t\t}\n\t\telse field[y][x] = '<';\n\t}\n\telse if (c == 'R'){\n\t\tif (x != w - 1){\n\t\t\tif (field[y][x + 1] == '.'){\n\t\t\t\tfield[y][x + 1] = '>';\n\t\t\t\tfield[y][x] = '.';\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse field[y][x] = '>';\n\t\t}\n\t\telse field[y][x] = '>';\n\t}\n\telse{\n\t\tint cy = y, cx = x;\n\t\tif (field[y][x] == '^'){\n\t\t\twhile (cy >= 0){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcy--;\n\t\t\t}\n\t\t}\n\t\telse if (field[y][x] == 'v'){\n\t\t\twhile (cy <= h - 1){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcy++;\n\t\t\t}\n\t\t}\n\t\telse if (field[y][x] == '<'){\n\t\t\twhile (cx >= 0){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcx--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twhile (cx <= w - 1){\n\t\t\t\tif (field[cy][cx] == '*'){\n\t\t\t\t\tfield[cy][cx] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (field[cy][cx] == '#')break;\n\t\t\t\tcx++;\n\t\t\t}\n\t\t}\n\t}\n\t//REP(i, h){\n\t//\tREP(j, w){\n\t//\t\tcout << field[i][j];\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\tpos = P(y, x);\n}\n\nint main(){\n\tcin >> t;\n\twhile (t--){\n\t\tcin >> h >> w;\n\t\tREP(i, h){\n\t\t\tcin >> field[i];\n\t\t\tREP(j, w){\n\t\t\t\tif (field[i][j] == '^' || field[i][j] == 'v'\n\t\t\t\t\t|| field[i][j] == '>' || field[i][j] == '<'){\n\t\t\t\t\tpos = P(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> n >> s;\n\t\tREP(i, n){\n\t\t\tsolve(s[i]);\n\t\t}\n\t\tREP(i, h){\n\t\t\tREP(j, w){\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tif (t != 0)cout<< endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint h, w;\nchar f[21][21];\npoint now;\nint nowdir;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nchar car[5]=\">^<v\";\n\nvoid move(char c){\n\t//????????¢???\n\tif(c=='R') nowdir=0;\n\telse if(c=='U') nowdir=1;\n\telse if(c=='L') nowdir=2;\n\telse if(c=='D') nowdir=3;\n\tf[now.y][now.x]=car[nowdir];\n\t\n\t//?¬????????????´???\n\tint nx=now.x+dx[nowdir];\n\tint ny=now.y+dy[nowdir];\n\t\n\t//?§?????????????????§????\n\tif(0<=nx && nx<w && 0<=ny && ny<h && f[ny][nx]=='.'){\n\t\tf[ny][nx]=car[nowdir];\n\t\tf[now.y][now.x]='.';\n\t\tnow.x=nx;\n\t\tnow.y=ny;\n\t}\n}\n\nvoid printField(){\n\tfor(int i=0; i<h; ++i){\n\t\tfor(int j=0; j<w; ++j){\n\t\t\tprintf(\"%c\", f[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\t\n}\n\nvoid shoot(){\n\tint t=1; //???????????????\n\n\twhile(1){\n\t\tint px=t*dx[nowdir]+now.x;\t\n\t\tint py=t*dy[nowdir]+now.y;\n\t\t\n\t\tif(px<0 || w<=px || py<0 || h<=py) break;\n\t\t\n\t\tif(f[py][px]=='*'){\n\t\t\tf[py][px]='.';\n\t\t\tbreak;\t\n\t\t}\n\t\telse if(f[py][px]=='#') break;\t\n\t\t\t\n\t\tt++;\t\t\t\n\t}\n}\n\nint main(){\t\n\tint times;\n\tcin >> times;\n\tfor(int t=0; t<times; ++t){\n\t\tif(t!=0) printf(\"\\n\");\n\t\t\n\t\tscanf(\" %d %d\", &h, &w);\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\tfor(int j=0; j<w; ++j){\n\t\t\t\tscanf(\" %c\", &f[i][j]);\n\t\t\t\t\n\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\tif(f[i][j]==car[k]){\t\n\t\t\t\t\t\tnowdir=k;\n\t\t\t\t\t\tnow.x=j;\n\t\t\t\t\t\tnow.y=i;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n;\n\t\tstring order;\n\t\tscanf(\" %d\", &n);\n\t\tcin >> order;\n\t\t\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(order[i]=='S') shoot();\n\t\t\telse move(order[i]);\n\t\t\t/*\n\t\t\tprintf(\"nowdir=%d\\n\", nowdir);\n\t\t\tprintField();\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t}\n\t\t\n\t\tprintField();\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n--){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tstring field[20];\n\t\tfor(int i = 0; i < h; ++i){ cin >> field[i]; }\n\t\tint x, y, dir;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tswitch(field[i][j]){\n\t\t\t\t\tcase '^': x = j; y = i; dir = 0; break;\n\t\t\t\t\tcase 'v': x = j; y = i; dir = 1; break;\n\t\t\t\t\tcase '<': x = j; y = i; dir = 2; break;\n\t\t\t\t\tcase '>': x = j; y = i; dir = 3; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tstring cmd;\n\t\tcin >> m >> cmd;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tswitch(cmd[i]){\n\t\t\t\tcase 'U':\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tif(y > 0 && field[y - 1][x] == '.'){ field[y][x] = '.'; --y; }\n\t\t\t\t\tfield[y][x] = '^';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdir = 1;\n\t\t\t\t\tif(y < h - 1 && field[y + 1][x] == '.'){ field[y][x] = '.'; ++y; }\n\t\t\t\t\tfield[y][x] = 'v';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tif(x > 0 && field[y][x - 1] == '.'){ field[y][x] = '.'; --x; }\n\t\t\t\t\tfield[y][x] = '<';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tdir = 3;\n\t\t\t\t\tif(x < w - 1 && field[y][x + 1] == '.'){ field[y][x] = '.'; ++x; }\n\t\t\t\t\tfield[y][x] = '>';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tif(dir == 0){\n\t\t\t\t\t\tint i = y - 1;\n\t\t\t\t\t\tfor(; i >= 0; --i){ if(field[i][x] == '*' || field[i][x] == '#'){ break; } }\n\t\t\t\t\t\tif(i >= 0 && field[i][x] == '*'){ field[i][x] = '.'; }\n\t\t\t\t\t}else if(dir == 1){\n\t\t\t\t\t\tint i = y + 1;\n\t\t\t\t\t\tfor(; i < h; ++i){ if(field[i][x] == '*' || field[i][x] == '#'){ break; } }\n\t\t\t\t\t\tif(i < h && field[i][x] == '*'){ field[i][x] = '.'; }\n\t\t\t\t\t}else if(dir == 2){\n\t\t\t\t\t\tint i = x - 1;\n\t\t\t\t\t\tfor(; i >= 0; --i){ if(field[y][i] == '*' || field[y][i] == '#'){ break; } }\n\t\t\t\t\t\tif(i >= 0 && field[y][i] == '*'){ field[y][i] = '.'; }\n\t\t\t\t\t}else if(dir == 3){\n\t\t\t\t\t\tint i = x + 1;\n\t\t\t\t\t\tfor(; i < w; ++i){ if(field[y][i] == '*' || field[y][i] == '#'){ break; } }\n\t\t\t\t\t\tif(i < w && field[y][i] == '*'){ field[y][i] = '.'; }\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tfor(int j = 0; j < h; ++j){ cout << field[j] << endl; }\n//\t\t\tcout << endl;\n\t\t}\n\t\tfor(int i = 0; i < h; ++i){ cout << field[i] << endl; }\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define inRange(x, y, w, h) (0 <= x && x < w && 0 <= y && y < h)\n\nusing namespace std;\n\nint main( void )\n{\n\tenum {\n\t\tU, D, L, R\n\t};\n\tchar p[] = { '^', 'v', '<', '>' };\n\tint dx[] = { 0, 0, -1, 1 };\n\tint dy[] = { -1, 1, 0, 0 };\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tint w, h, px, py, drct;\n\t\tchar map[21][21];\n\t\tcin >> h >> w;\n\t\tfor(int y=0; y < h; ++y)\n\t\t\tfor(int x=0; x < w; ++x) {\n\t\t\t\tcin >> map[y][x];\n\t\t\t\tswitch(map[y][x]) {\n\t\t\t\t\tcase '^':\tpx = x; py = y; drct = U;\tbreak;\n\t\t\t\t\tcase '<':\tpx = x; py = y; drct = L;\tbreak;\n\t\t\t\t\tcase '>':\tpx = x; py = y; drct = R;\tbreak;\n\t\t\t\t\tcase 'v':\tpx = x; py = y; drct = D;\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tmap[py][px] = '.';\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tint mx, my;\n\t\t\tswitch(c) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tdrct = U;\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\tif(inRange(mx, my, w, h) && map[my][mx] == '.') {\n\t\t\t\t\t\tpx = mx; py = my;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdrct = D;\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\tif(inRange(mx, my, w, h) && map[my][mx] == '.') {\n\t\t\t\t\t\tpx = mx; py = my;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tdrct = L;\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\tif(inRange(mx, my, w, h) && map[my][mx] == '.') {\n\t\t\t\t\t\tpx = mx; py = my;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tdrct = R;\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\tif(inRange(mx, my, w, h) && map[my][mx] == '.') {\n\t\t\t\t\t\tpx = mx; py = my;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\twhile(inRange(mx, my, w, h)) {\n\t\t\t\t\t\tchar info = map[my][mx];\n\t\t\t\t\t\tif\t\t(info == '*') {\n\t\t\t\t\t\t\tmap[my][mx] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if\t(info == '#') break;\n\t\t\t\t\t\tmx += dx[drct]; my += dy[drct];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmap[py][px] = p[drct];\n\t\tfor(int y=0; y < h; ++y, cout << endl)\n\t\t\tfor(int x=0; x < w; ++x)\n\t\t\t\tcout << map[y][x];\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<cstring>\n#include<iostream>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> pin;\ntypedef std::pair<int,std::pair<int, int> > ppin;\n\nusing namespace std;\n\nchar ma[22][22];\n\nint main(){\n    \n    int n;\n    cin>>n;\n    while(n--){\n        int a,b;\n        cin>>a>>b;\n        int x=0,y=0,d=0;\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cin>>ma[i][j];\n                if(ma[i][j]=='^'){\n                    y=i; x=j; d=0;\n                }\n                if(ma[i][j]=='v'){\n                    y=i; x=j; d=1;\n                }\n                if(ma[i][j]=='<'){\n                    y=i; x=j; d=2;\n                }\n                if(ma[i][j]=='>'){\n                    y=i; x=j; d=3;\n                }\n            }\n        }\n        \n        int str;\n        cin>>str;\n        string s;\n        cin>>s;\n        for(int k=0;k<s.length();k++){\n            switch(s[k]){\n                case 'U':\n                    \n                    d=0;\n                    if(ma[y-1][x]!='.')\n                        continue;\n                    y--;\n                    ma[y+1][x]='.';\n                    ma[y][x]='^';\n                    break;\n                case 'D':\n                    d=1;\n                    if(ma[y+1][x]!='.')\n                        continue;\n                    \n                    y++;\n                    ma[y-1][x]='.';\n                    ma[y][x]='v';\n                    break;\n                case 'L':\n                    d=2;\n                    if(ma[y][x-1]!='.')\n                        continue;\n                    \n                    x--;\n                    ma[y][x+1]='.';\n                    ma[y][x]='<';\n                    break;\n                case 'R':\n                    d=3;\n                    if(ma[y][x+1]!='.')\n                        continue;\n                    \n                    x++;\n                    ma[y][x-1]='.';\n                    ma[y][x]='>';\n                    break;\n                case 'S':\n                    switch(d){\n                        case 0:\n                            for(int i=y-1;i>=0;i--){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    cout<<\"H\"<<endl;\n                                    break;\n                                }\n                            }\n                            break;\n                        case 1:\n                            for(int i=y+1;i<a;i++){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 2:\n                            for(int i=x-1;i>=0;i--){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 3:\n                            for(int i=x+1;i<b;i++){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                    }\n//                    for(int i=0;i<a;i++){\n//                        for(int j=0;j<b;j++){\n//                            cout<<ma[i][j];\n//                        }\n//                        cout<<endl;\n//                    }\n//                    cout<<endl;\n                    break;\n            }\n        }\n        switch(d){\n            case 0:\n                ma[y][x]='^';\n                break;\n            case 1:\n                ma[y][x]='v';\n                break;\n            case 2:\n                ma[y][x]='<';\n                break;\n            case 3:\n                ma[y][x]='>';\n                break;\n        }\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cout<<ma[i][j];\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nstruct player{\n\tpublic:\n\t\tplayer(char a, int b, int c):dir(a), posX(b), posY(c){}\n\t\tvoid actU(vector<vector<char> > &table){\n\t\t\tif(posY-1<0){\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t\tdir = '^';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY-1][posX] == '.'){\n\t\t\t\ttable[posY--][posX] = '.';\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t}\n\t\t\telse table[posY][posX] = '^';\n\t\t\tdir = '^';\n\t\t}\n\t\tvoid actD(vector<vector<char> > &table){\n\t\t\tif(posY+1>=table.size()){\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t\tdir = 'v';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY+1][posX] == '.'){\n\t\t\t\ttable[posY++][posX] = '.';\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t}\n\t\t\telse table[posY][posX] = 'v';\n\t\t\tdir = 'v';\n\t\t}\n\t\tvoid actL(vector<vector<char> > &table){\n\t\t\tif(posX-1<0){\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t\tdir = '<';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX-1] == '.'){\n\t\t\t\ttable[posY][posX--] = '.';\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t}\n\t\t\telse table[posY][posX] = '<';\n\t\t\tdir = '<';\n\t\t}\n\t\tvoid actR(vector<vector<char> > &table){\n\t\t\tif(posX+1>=table[0].size()){\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t\tdir = '>';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX+1] == '.'){\n\t\t\t\ttable[posY][posX++] = '.';\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t}\n\t\t\telse table[posY][posX] = '>';\n\t\t\tdir = '>';\n\t\t}\n\t\tvoid actS(vector<vector<char> > &table){\n\t\t\tint progressX = 0;\n\t\t\tint progressY = 0;\n\t\t\tif(dir == '^') progressY = -1;\n\t\t\telse if(dir == 'v') progressY = 1;\n\t\t\telse if(dir == '<') progressX = -1;\n\t\t\telse if(dir == '>') progressX = 1;\n\t\t\tint sposX = posX+progressX, sposY = posY+progressY;\n\t\t\twhile((sposX>=0&&sposX<table[0].size())&&(sposY>=0&&sposY<table.size())){\n\t\t\t\tif(table[sposY][sposX] == '*' || table[sposY][sposX] == '#'){\n\t\t\t\t\tif(table[sposY][sposX] == '*') table[sposY][sposX] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsposX += progressX;\n\t\t\t\tsposY += progressY;\n\t\t\t}\n\t\t}\n\t\tchar dir;\n\t\tint posX;\n\t\tint posY;\n};\n\nvoid action(char act, player &p, vector<vector<char> > &table){\n\tswitch(act){\n\tcase 'U':\n\t\tp.actU(table);\n\t\tbreak;\n\tcase 'D':\n\t\tp.actD(table);\n\t\tbreak;\n\tcase 'L':\n\t\tp.actL(table);\n\t\tbreak;\n\tcase 'R':\n\t\tp.actR(table);\n\t\tbreak;\n\tcase 'S':\n\t\tp.actS(table);\n\t\tbreak;\n\tdefault:\n\t\t\tbreak;\n\t}\n\n}\n\nint main(){\n\tint n = 0;\n\tfreopen(\"test.txt\", \"r\", stdin);\n\tcin >> n;\n\twhile(n--){\n\t\tint h = 0, w = 0;\n\t\tcin >> h >> w;\n\t\tvector<vector<char> > table(h, vector<char>(w, ' '));\n\t\tplayer p(' ', -1, -1);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tif(table[i][j]=='^'||table[i][j]=='v'||table[i][j]=='<'||table[i][j]=='>'){\n\t\t\t\t\tp.dir = table[i][j];\n\t\t\t\t\tp.posX = j;\n\t\t\t\t\tp.posY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = 0;\n\t\tcin >> m;\n\t\tvector<char> act(m, ' ');\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> act[i];\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\taction(act[i], p, table);\n\t\t}\n\n\t\tfor(int i = 0; i < table.size(); i++){\n\t\t\tfor(int j = 0; j < table[0].size(); j++){\n\t\t\t\tcout << table[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\nchar v[] = { '>', 'v', '<', '^' };\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\twhile (N--)\n\t{\n\t\tint H,W;\n\t\tcin >> H >> W;\n\n\t\tchar a[H][W];\n\t\tfor (int i=0; i<H; i++)\n\t\tfor (int k=0; k<W; k++)\n\t\t\tcin >> a[i][k];\n\n\t\tint x,y,d;\n\t\tbool f=1;\n\t\tfor (int i=0; f&&i<H; i++)\n\t\tfor (int k=0; f&&k<W; k++)\n\t\t\tif (a[i][k]=='v'||a[i][k]=='^'||a[i][k]=='<'||a[i][k]=='>')\n\t\t\t{\n\t\t\t\tswitch (a[i][k])\n\t\t\t\t{\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\td=0; break;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\td=1; break;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\td=2; break;\n\t\t\t\t\tcase '^':\n\t\t\t\t\t\td=3; break;\n\t\t\t\t}\n\t\t\t\tx=k; y=i; a[i][k]='.';\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tint S;\n\t\tcin >> S;\n\t\tfor (int p=0; p<S; p++)\n\t\t{\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'S')\n\t\t\t{\n\t\t\t\tint px=x+dx[d], py=y+dy[d];\n\t\t\t\twhile (px>=0 && px<W && py>=0 && py<H)\n\t\t\t\t{\n\t\t\t\t\tif (a[py][px]=='*' || a[py][px]=='#')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (a[py][px]=='*')\n\t\t\t\t\t\t\ta[py][px] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpx += dx[d]; py+= dy[d];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (c)\n\t\t\t\t{\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\td=0; break;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\t\td=1; break;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\td=2; break;\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\td=3; break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint nx=x+dx[d], ny=y+dy[d];\n\t\t\t\tif (nx>=0 && nx<W && ny>=0 && ny<H && a[ny][nx]=='.')\n\t\t\t\t{\n\t\t\t\t\tx=nx; y=ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i<H; i++)\n\t\t{\n\t\t\tfor (int k=0; k<W; k++)\n\t\t\t\tif (i==y&&k==x)\n\t\t\t\t\tcout << v[d];\n\t\t\t\telse\n\t\t\t\t\tcout << a[i][k];\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t\tif (N > 0)\n\t\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef struct TankState{\n  int x, y, dir;//u:0, r:1, d:2, l:3\n}TankState;\n\nbool range(int x, int y, int w, int h){\n  return (0 <= x and x < w) and (0 <= y and y < h);\n}\n\nint main(){\n  int n;\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {-1, 0, 1, 0};\n  std::cin >> n;\n  for (int l = 0; l < n; l++) {\n    TankState pos;\n    int h, w;\n    std::cin >> h >> w;\n    vector<string> vs(h);\n    for (int i = 0; i < h; i++) std::cin >> vs[i];\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if(vs[i][j] == '^')pos.x = j, pos.y = i, pos.dir = 0;\n        if(vs[i][j] == '>')pos.x = j, pos.y = i, pos.dir = 1;\n        if(vs[i][j] == 'v')pos.x = j, pos.y = i, pos.dir = 2;\n        if(vs[i][j] == '<')pos.x = j, pos.y = i, pos.dir = 3;\n      }\n    }\n    string operation;\n    int tmp;\n    std::cin >> tmp >> operation;\n    for (int i = 0; i < operation.length(); i++) {\n      if(operation[i] == 'S'){\n        int x = pos.x, y = pos.y;\n        while(range(x, y, w, h) and \n              vs[y][x] != '*' and vs[y][x] != '#')\n          y += dy[pos.dir], x += dx[pos.dir];\n        if(range(x, y, w, h) and vs[y][x] == '*')vs[y][x] = '.';\n      }else if(operation[i] == 'U'){\n        pos.dir = 0;\n        if(range(pos.x, pos.y - 1, w, h) and\n           vs[pos.y - 1][pos.x] == '.'){\n          vs[pos.y - 1][pos.x] = '^';\n          vs[pos.y][pos.x] = '.';\n          pos.y -= 1;\n        }\n      }else if(operation[i] == 'R'){\n        pos.dir = 1;\n        if(range(pos.x + 1, pos.y, w, h) and\n           vs[pos.y][pos.x + 1] == '.'){\n          vs[pos.y][pos.x + 1] = '>';\n          vs[pos.y][pos.x] = '.';\n          pos.x += 1;\n        }\n      }else if(operation[i] == 'D'){\n        pos.dir = 2;\n        if(range(pos.x, pos.y + 1, w, h) and\n           vs[pos.y + 1][pos.x] == '.'){\n          vs[pos.y + 1][pos.x] = 'v';\n          vs[pos.y][pos.x] = '.';\n          pos.y += 1;\n        }\n      }else if(operation[i] == 'L'){\n        pos.dir = 3;\n        if(range(pos.x - 1, pos.y, w, h) and\n           vs[pos.y][pos.x - 1] == '.'){\n          vs[pos.y][pos.x - 1] = '<';\n          vs[pos.y][pos.x] = '.';\n          pos.x -= 1;\n        }\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      std::cout << vs[i] << std::endl;\n    }\n    if(l != n - 1)std::cout << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint x[99][99];\nint H, W, CX, CY, CD;\nint dy[4] = { -1,0,1,0 };\nint dx[4] = { 0,1,0,-1 };\nchar T[9] = \".*#-^>v<\";\nint main() {\n\tint U; cin >> U;\n\tfor (int i = 0; i < U; i++) {\n\t\tif (i) cout << endl;\n\t\tcin >> H >> W;\n\t\tfor (int i = 0; i < 99; i++) {\n\t\t\tfor (int j = 0; j < 99; j++) x[i][j] = 2;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tif (T[k] == c) x[i][j] = k;\n\t\t\t\t}\n\t\t\t\tif (x[i][j] >= 4) {\n\t\t\t\t\tCY = i; CX = j; CD = x[i][j] - 4;\n\t\t\t\t\tx[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint P; cin >> P;\n\t\tstring S; cin >> S;\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tif (S[i] == 'U') CD = 0;\n\t\t\tif (S[i] == 'R') CD = 1;\n\t\t\tif (S[i] == 'D') CD = 2;\n\t\t\tif (S[i] == 'L') CD = 3;\n\t\t\tif (S[i] == 'S') {\n\t\t\t\tint DY = CY, DX = CX;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (x[DY][DX] == 1) { x[DY][DX] = 0; break; }\n\t\t\t\t\tif (x[DY][DX] == 2) { break; }\n\t\t\t\t\tDY += dy[CD]; DX += dx[CD];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (x[CY + dy[CD]][CX + dx[CD]] == 0) {\n\t\t\t\t\tCY += dy[CD]; CX += dx[CD];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (CY == i && CX == j) { cout << T[CD + 4]; }\n\t\t\t\telse { cout << T[x[i][j]]; }\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int t;\n  cin>>t;\n  for(;t--;)\n    {\n      int h,w;\n      cin>>h>>w;\n      //      cout<<h<<\" \"<<w<<endl;\n      char maps[h][w];\n      int x,y;\n      //      char move;     //^=0,>=1,v=2,<=3\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>maps[i][j];\n\t    \n\t    if(maps[i][j]=='^' ||maps[i][j]=='>'\n\t       ||maps[i][j]=='v'||maps[i][j]=='<')\n\t      {\n\t\tx=i;\n\t\ty=j;\n\t      }\n\t    \n\t  }\n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  char tmp;\n\t  cin>>tmp;\n\t  if(tmp=='U')\n\t    {\n\t      maps[x][y]='^';\n\t      if(x>0&&maps[x-1][y]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  x--;\n\t\t  maps[x][y]='^';\n\t\t}\n\t    }\n\t  if(tmp=='D')\n\t    {\n\t      maps[x][y]='v';\n\t      if(x<h-1&&maps[x+1][y]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  x++;\n\t\t  maps[x][y]='v';\n\t\t}\n\t    }\n\n\n\t  if(tmp=='L')\n\t    {\n\t      maps[x][y]='<';\n\t      if(y>0&&maps[x][y-1]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  y--;\n\t\t  maps[x][y]='<';\n\t\t}\n\t    }\n\t  if(tmp=='R')\n\t    {\n\t      maps[x][y]='>';\n\t      if(y<w-1&&maps[x][y+1]=='.')\n\t\t{\n\t\t  maps[x][y]='.';\n\t\t  y++;\n\t\t  maps[x][y]='>';\n\t\t}\n\t    }\n\t  if(tmp=='S')\n\t    {\n\t      int dx=0,dy=0;\n\t      int tmpx=x,tmpy=y;\n\t      if(maps[x][y]=='^')\n\t\tdx=-1;\n\t      else if(maps[x][y]=='v')\n\t\tdx=1;\n\t      else if(maps[x][y]=='<')\n\t\tdy=-1;\n\t      else\n\t\tdy=1;\n\t      while(tmpx+dx<h&&tmpy+dy<w)\n\t\t{\n\t\t  tmpx+=dx;\n\t\t  tmpy+=dy;\n\t\t  if(maps[tmpx][tmpy]=='*')\n\t\t    {\n\t\t      maps[tmpx][tmpy]='.';\n\t\t      break;\n\t\t    }\n\t\t  if(maps[tmpx][tmpy]=='#')\n\t\t    {\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\t  \n\t}\n\t\n\t\n\tfor(int i=0;i<h;i++,cout<<endl)\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      cout<<maps[i][j];\n\t    }\n\tif(t!=0)\n\t  cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\ntypedef int Direction;\ntypedef char Command;\nint h,w;\nenum Dir{UP,RIGHT,LEFT,DOWN};\nclass Tank{\npublic:\n\tDirection dir;\n\tint x;\n\tint y;\n\tstring getDir(){\n\t\tif(dir==UP)return \"UP\";\n\t\tif(dir==RIGHT)return \"RIGHT\";\n\t\tif(dir==LEFT)return \"LEFT\";\n\t\tif(dir==DOWN)return \"DOWN\";\n\t\telse return \"NAN\";\n\t}\n\tvoid printCondition(){\n\t\tcout<<\"-- tank -----\"<<endl;\n\t\tcout<<\" dir:\"<<getDir()<<endl;\n\t\tcout<<\"   x:\"<<x<<endl;\n\t\tcout<<\"   y:\"<<y<<endl;\n\t\tcout<<\"-------------\"<<endl;\n\t}\n\n};\nTank tank;\n\nchar map[21][21];\nCommand command;\nDirection judgeDir(char c){\n\tif(c=='^')return UP;\n\tif(c=='v')return DOWN;\n\tif(c=='>')return RIGHT;\n\tif(c=='<')return LEFT;\n\n}\nchar getCharDir(){\n\tif(tank.dir==UP)return '^';\n\tif(tank.dir==DOWN)return 'v';\n\tif(tank.dir==RIGHT)return '>';\n\tif(tank.dir==LEFT)return '<';\n\n}\nvoid init(){\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)map[i][j]='N';\n\t}\n}\nvoid shoot(){\n\t//cout<<\"shoot()\"<<endl;\n\tDirection dy=0;\n\tDirection dx=0;\n\tif(tank.dir==UP)dy=-1;\n\tif(tank.dir==DOWN)dy=1;\n\tif(tank.dir==RIGHT)dx=1;\n\tif(tank.dir==LEFT)dx=-1;\n\tint x=tank.x;\n\tint y=tank.y;\n\tfor(;;){\n\t\tif(x+dx<0||x+dx>w||y+dy<0||y+dy>h||map[y+dy][x+dx]=='#')break;\n\n\t\tx+=dx;\n\t\ty+=dy;\n\t\t//cout<<\" gun[\"<<y<<\"][\"<<x<<\"]\"<<endl;\n\t\tif(map[y][x]=='*'){\n\t\t\tmap[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ;\n\n}\nvoid next(Command command){\n\tmap[tank.y][tank.x]='.';\n\t//cout<<\"tank(\"<<tank.x<<\",\"<<tank.y<<\")\"<<endl;\n\tif(command=='U'){\n\t//\tcout<<\"   UP\"<<endl;\n\t\ttank.dir=UP;\n\t\tif(tank.y-1>=0 && map[tank.y-1][tank.x]=='.'){\n\t\t\ttank.y=tank.y-1;\n\t\t}\n\t}\n\telse if(command=='D'){\n\t//\tcout<<\"   DOWN\"<<endl;\n\t\ttank.dir=DOWN;\n\t\tif(tank.y+1<h && map[tank.y+1][tank.x]=='.'){\n\t\t\ttank.y=tank.y+1;\n\t\t}\n\n\t}\n\telse if(command=='L'){\n\t//\tcout<<\"   LEFT\"<<endl;\n\t\ttank.dir=LEFT;\n\t\tif(tank.x-1>=0 && map[tank.y][tank.x-1]=='.'){\n\t\t\ttank.x=tank.x-1;\n\t\t}\n\t}\n\telse if(command=='R'){\n\t//\tcout<<\"   RIGHT\"<<endl;\n\t\ttank.dir=RIGHT;\n\t\tif(tank.x+1<w && map[tank.y][tank.x+1]=='.'){\n\t\t\ttank.x=tank.x+1;\n\t\t}\n\t}\n\telse if(command=='S'){\n\t//\tcout<<\"   SHOOT\"<<endl;\n\t\tshoot();\n\t}\n\tmap[tank.y][tank.x]='@';\n}\nvoid printMap(){\n\tcout<<\"-- MAP --------\"<<endl;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcout<<map[i][j];\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<\"---------------\"<<endl;\n}\nint main(){\n\tint d;\n\tcin>>d;\n\tfor(int k=0;k<d;k++){\n\t\tif(k)cout<<endl;\n\t\tcin>>h>>w;\n\t\tinit();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>map[i][j];\n\t\t\t\tif(map[i][j]=='^'|| map[i][j]=='v'\n\t\t\t\t\t\t||map[i][j]=='>'||map[i][j]=='<'){\n\t\t\t\t\ttank.dir=judgeDir(map[i][j]);\n\t\t\t\t\ttank.x=j;\n\t\t\t\t\ttank.y=i;\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint commandNum;\n\t\tcin>>commandNum;\n//\t\ttank.printCondition();\n\t\tfor(int i=0;i<commandNum;i++){\n\t\t\tcin>>command;\n\t\t\tnext(command);\n\t\t\t//printMap();\n\t\t\t//tank.printCondition();\n\t\t}\n\t\t//\t\tcout<<\"==========END============\"<<endl;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@')cout<<getCharDir();\n\t\t\t\telse cout<<map[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\n\t\t//\t\tcout<<\"=========================\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <string>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n#define fi first\n#define se second\nP2 p;\nint n,h,w;\nstring s[21],t;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nP2 get_tank(){\n  r(i,h)r(j,w){\n    if(s[i][j]=='^')return P2(0,P(i,j));\n    if(s[i][j]=='>')return P2(1,P(i,j));\n    if(s[i][j]=='v')return P2(2,P(i,j));\n    if(s[i][j]=='<')return P2(3,P(i,j));\n  }\n}\nvoid shoot(){\n  int y=p.se.fi;\n  int x=p.se.se;\n  while(1){\n    y+=dy[p.fi];\n    x+=dx[p.fi];\n    if(x<0||y<0||y>=h||x>=w)break;\n    if(s[y][x]=='#')break;\n    if(s[y][x]=='*'){\n      s[y][x]='.';\n      break;\n    }\n  }\n}\nvoid GGG(int po){\n  p.fi=po;\n  int y=p.se.fi+dy[po];\n  int x=p.se.se+dx[po];\n  if(x<0||y<0||y>=h||x>=w)return;\n  if(s[y][x]!='.')return;\n  p.se.fi=y;\n  p.se.se=x;\n}\nint main(){\n  cin>>n;\n  while(n--){\n    cin>>h>>w;\n    r(i,h)cin>>s[i];\n    p=get_tank();\n    s[p.se.fi][p.se.se]='.';\n    cin>>t>>t;\n    r(i,t.size()){\n      if(t[i]=='S')shoot();\n      else{\n\tint po;\n        if(t[i]=='U')po=0;\n        if(t[i]=='R')po=1;\n        if(t[i]=='D')po=2;\n        if(t[i]=='L')po=3;\n\tGGG(po);\n      }\n    }\n    if(p.fi==0)s[p.se.fi][p.se.se]='^';\n    if(p.fi==1)s[p.se.fi][p.se.se]='>';\n    if(p.fi==2)s[p.se.fi][p.se.se]='v';\n    if(p.fi==3)s[p.se.fi][p.se.se]='<';\n    r(i,h)cout<<s[i]<<endl;\n   if(n!=1)cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nchar mp[30][30];\nint dx[]{ -1,1,0,0 }, dy[]{ 0,0,-1,1 };\nchar cc[]{ 'U','D','L','R' }, ccc[]{ '^','v','<','>' };\nint main() {\n\tint t; scanf(\"%d\", &t);\n\trep(k, t) {\n\t\tint h, w; scanf(\"%d%d\", &h, &w);\n\t\tint px, py, dir;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", mp[i]);\n\t\t\trep(j, w) {\n\t\t\t\tint d = find(ccc, ccc + 4, mp[i][j]) - ccc;\n\t\t\t\tif (d < 4)px = i, py = j, dir = d, mp[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tint n; string s; cin >> n >> s;\n\t\tfor (char c : s) {\n\t\t\tif (c != 'S') {\n\t\t\t\tdir = find(cc, cc + 4, c) - cc;\n\t\t\t\tint nx = px + dx[dir], ny = py + dy[dir];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&mp[nx][ny] == '.')px = nx, py = ny;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int nx = px, ny = py; 0 <= nx&&nx < h && 0 <= ny&&ny < w; nx += dx[dir], ny += dy[dir]) {\n\t\t\t\tif (mp[nx][ny] == '*') {\n\t\t\t\t\tmp[nx][ny] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mp[nx][ny] == '#')break;\n\t\t\t}\n\t\t}\n\t\tmp[px][py] = ccc[dir];\n\t\trep(i, h)printf(\"%s\\n\", mp[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define in_range(x,y,w,h) (0<=x && x<=w && 0<=y && y<h)\n\nint T, H, W, N, tx, ty, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\nstring grid[22], opr, CHS = \"URDL^>v<\";\n\nvoid move(int d) {\n\tint nx = tx + dx[d], ny = ty + dy[d];\n\tif (!in_range(nx, ny, W, H) || grid[ny][nx] != '.') nx = tx, ny = ty;\n\tgrid[ty][tx] = '.';\n\tgrid[ny][nx] = CHS[d+4];\n\tty = ny; tx = nx;\n}\n\nvoid shoot() {\n\tint d = CHS.find(grid[ty][tx]) - 4;\n\tint x = tx + dx[d], y = ty + dy[d];\n\t\n\twhile (in_range(x,y,W,H) && grid[y][x] != '#' && grid[y][x] != '*') {\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\t\n\tif (in_range(x,y,W,H) && grid[y][x] == '*') grid[y][x] = '.';\n}\n\nvoid simulate() {\n\tfor_(i,0,N) {\n\t\tchar c = opr[i];\n\t\tif (c == 'S') shoot();\n\t\telse move((int)CHS.find(c));\n\t}\n}\n\nint main() {\n\tcin >> T;\n\t\n\tfor_(case_num,0,T) {\n\t\tcin >> H >> W;\n\t\t\n\t\tfor_(y,0,H) {\n\t\t\tcin >> grid[y];\n\t\t\tfor_(x,0,W) if (CHS.find(grid[y][x]) != CHS.npos) tx = x, ty = y;\n\t\t}\n\t\t\n\t\tcin >> N;\n\t\tcin >> opr;\n\t\t\n\t\tsimulate();\n\t\t\n\t\tfor_(y,0,H) cout << grid[y] << endl;\n\t\tif (case_num < T - 1) cout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w, h;\nstring field[21];\n\nvoid print_field() {\n    for (int i = 0; i < h; i++) {\n        cout << field[i] << endl;\n    }\n}\n\nvoid shoot(int x, int y) {\n    int dx, dy;\n    switch (field[y][x]) {\n        case '^': dx = 0; dy = -1; break;\n        case 'v': dx = 0; dy = 1; break;\n        case '<': dx = -1; dy = 0; break;\n        case '>': dx = 1; dy = 0; break;\n    }\n    while (1) {\n        x += dx;\n        y += dy;\n        if (x < 0 || w <= x || y < 0 || h <= y || field[y][x] == '#') {\n            return;\n        }\n        if (field[y][x] == '*') {\n            field[y][x] = '.';\n            return;\n        }\n    }\n}\n\nvoid solve() {\n    int x, y;\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        cin >> field[i];\n        for (int j = 0; j < field[i].size(); j++) {\n            char c = field[i][j];\n            if (c == '<' || c == '^' || c == '>' || c == 'v') {\n                x = j; y = i;\n            }\n        }\n    }\n    int n;\n    string s;\n    cin >> n >> s;\n    for (char c : s) {\n        if (c == 'S') shoot(x, y);\n        else {\n            int dx, dy;\n            char mark;\n            switch (c) {\n                case 'U': dx = 0; dy = -1; mark = '^'; break;\n                case 'D': dx = 0; dy = 1; mark = 'v'; break;\n                case 'L': dx = -1; dy = 0; mark = '<'; break;\n                case 'R': dx = 1; dy = 0; mark = '>'; break;\n            }\n            int nx = x + dx;\n            int ny = y + dy;\n            field[y][x] = mark;\n            if (0 <= nx && nx < w && 0 <= ny && ny < h && field[ny][nx] == '.') {\n                field[y][x] = '.';\n                field[ny][nx] = mark;\n                x = nx;\n                y = ny;\n            }\n        }\n    }\n    print_field();\n}\n\nint main() {\n    int t;\n    for (cin >> t; t; t--) {\n        solve();\n        if (t != 1) cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring mp[20],str;\nint dir[256],h,w,m;\nchar ch[4]={'^','>','v','<'};\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\nint get_d(char a){\n  if(a=='U') return 0;\n  if(a=='R') return 1;\n  if(a=='D') return 2;\n  if(a=='L') return 3;\n  return -1;\n}\n\nvoid shoot(int x,int y,int d){\n  while(1){\n    x+=dx[d],y+=dy[d];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#')return;\n    if(mp[y][x]=='*'){\n      mp[y][x]='.';\n      return;\n    }\n  }\n\n}\n\nvoid out(char c){\n    cout <<c<<endl;\n  for(int i=0;i<h;i++) cout <<mp[i]<<endl;\n  cout <<\"------------\"<<endl;\n}\n\nvoid update(int x,int y,int d){\n  mp[y][x]='.';\n  for(int i=0;i<m;i++){\n    int pd=d,nx,ny;\n    d=get_d(str[i]);\n    if(d==-1){d=pd,shoot(x,y,d);continue;}\n\n    nx=x+dx[d],ny=y+dy[d];\n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]!='.')nx=x,ny=y;\n    y=ny,x=nx;\n      \n  }\n  mp[y][x]=ch[d];\n}\n\nint main(){\n  memset(dir,-1,sizeof(dir));\n  dir['^']=0,dir['>']=1,dir['v']=2,dir['<']=3;\n\n  int q;\n  cin>>q;\n  while(q--){\n    cin>>h>>w;\n    for(int i=0;i<h;i++) cin>>mp[i];\n    cin>>m>> str;\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) \n\tif(dir[mp[i][j]]!=-1) {\n\t  update(j,i,dir[mp[i][j]]);\n\t  break;\n\t}\n\n    for(int i=0;i<h;i++)cout <<mp[i]<<endl;\n    if(q) cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define inRange(x, y, w, h) (0 <= x && x < w && 0 <= y && y < h)\n\nusing namespace std;\n\nint main( void )\n{\n\tenum {\n\t\tU, D, L, R\n\t};\n\tchar p[] = { '^', 'v', '<', '>' };\n\tint dx[] = { 0, 0, -1, 1 };\n\tint dy[] = { -1, 1, 0, 0 };\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tint w, h, px, py, drct;\n\t\tchar map[21][21];\n\t\tcin >> h >> w;\n\t\tfor(int y=0; y < h; ++y)\n\t\t\tfor(int x=0; x < w; ++x) {\n\t\t\t\tcin >> map[y][x];\n\t\t\t\tswitch(map[y][x]) {\n\t\t\t\t\tcase '^':\tpx = x; py = y; drct = U;\tbreak;\n\t\t\t\t\tcase '<':\tpx = x; py = y; drct = L;\tbreak;\n\t\t\t\t\tcase '>':\tpx = x; py = y; drct = R;\tbreak;\n\t\t\t\t\tcase 'v':\tpx = x; py = y; drct = D;\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tmap[py][px] = '.';\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tint mx, my;\n\t\t\tswitch(c) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tdrct = U;\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\tif(inRange(mx, my, w, h) && map[my][mx] == '.') {\n\t\t\t\t\t\tpx = mx; py = my;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdrct = D;\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\tif(inRange(mx, my, w, h) && map[my][mx] == '.') {\n\t\t\t\t\t\tpx = mx; py = my;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tdrct = L;\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\tif(inRange(mx, my, w, h) && map[my][mx] == '.') {\n\t\t\t\t\t\tpx = mx; py = my;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tdrct = R;\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\tif(inRange(mx, my, w, h) && map[my][mx] == '.') {\n\t\t\t\t\t\tpx = mx; py = my;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tmx = px + dx[drct]; my = py + dy[drct];\n\t\t\t\t\twhile(inRange(mx, my, w, h)) {\n\t\t\t\t\t\tchar info = map[my][mx];\n\t\t\t\t\t\tif\t\t(info == '*') {\n\t\t\t\t\t\t\tmap[my][mx] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if\t(info == '#') break;\n\t\t\t\t\t\tmx += dx[drct]; my += dy[drct];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmap[py][px] = p[drct];\n\t\tfor(int y=0; y < h; ++y, cout << endl)\n\t\t\tfor(int x=0; x < w; ++x)\n\t\t\t\tcout << map[y][x];\n\t\tif(t) cout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint main(){\n\tmap<char,int>a;\n\ta['<']=1;\n\ta['>']=2;\n\ta['^']=3;\n\ta['v']=4;\n\tint dx[5]={0,0,0,-1,1};\n\tint dy[5]={0,-1,1,0,0};\n\tint w;\n\tcin>>w;\n\trep(z,w){\n\t\tif(z)cout<<endl;\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tvector<vector<char> >in(n+2,vector<char>(m+2));\n\t\trep(i,n+2)rep(j,m+2)\n\t\t\tif(!i||!j||i==n+1||j==m+1)in[i][j]='#';\n\t\t\telse cin>>in[i][j];\n\t\tint q;cin>>q;\n\t\tstring s;cin>>s;\n\t\tint x,y;\n\t\trep(i,n+2)rep(j,m+2)if(a[in[i][j]]){x=i;y=j;}\n\t\trep(i,q){\n\t\t\tif(s[i]=='D'){\n\t\t\t\tin[x][y]='v';\n\t\t\t\tif(in[x+1][y]=='.'){in[x][y]='.';x++;in[x][y]='v';}\n\t\t\t}\n\t\t\tif(s[i]=='U'){\n\t\t\t\tin[x][y]='^';\n\t\t\t\tif(in[x-1][y]=='.'){in[x][y]='.';x--;in[x][y]='^';}\n\t\t\t}\n\t\t\tif(s[i]=='R'){\n\t\t\t\tin[x][y]='>';\n\t\t\t\tif(in[x][y+1]=='.'){in[x][y]='.';y++;in[x][y]='>';}\n\t\t\t}\n\t\t\tif(s[i]=='L'){\n\t\t\t\tin[x][y]='<';\n\t\t\t\tif(in[x][y-1]=='.'){in[x][y]='.';y--;in[x][y]='<';}\n\t\t\t}\n\t\t\tif(s[i]=='S'){\n\t\t\t\tint d=a[in[x][y]];\n\t\t\t\tint sx=x;\n\t\t\t\tint sy=y;\n\t\t\t\twhile(1){\n\t\t\t\t\tsx+=dx[d];\n\t\t\t\t\tsy+=dy[d];\n\t\t\t\t\tif(in[sx][sy]=='#')break;\n\t\t\t\t\tif(in[sx][sy]=='*'){\n\t\t\t\t\t\tin[sx][sy]='.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(k,n){\n\t\t\trep(j,m)cout<<in[k+1][j+1];\n\t\t\tcout<<endl;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstring mp[20];\nchar tank[4] = {'<', '^', '>', 'v'};\nint dx[4] = { -1, 0, 1, 0 };\nint dy[4] = { 0, -1, 0, +1 };\nint w,h;\n\npair<int,pair<int,int> > getpos() {\n    int i,j,k;\n    rep(i,h) rep(j,mp[i].length()) rep(k,4)\n        if(mp[i][j] == tank[k]) return make_pair(k,make_pair(i,j));\n}\n\nvoid solve(string com) {\n    for(int i=0; i<com.length(); ++i) {\n        int dir = getpos().first;\n        int x = getpos().second.first;\n        int y = getpos().second.second;\n\n        if(com[i] == 'S') {\n            while((x < h) && (x >= 0) && (y < w) && (y >= 0)) {\n                if(mp[x][y] == '*') {\n                    mp[x][y] = '.';\n                    break;\n                }else if(mp[x][y] == '#') {\n                    break;\n                }\n                      x += dy[dir];\n                      y += dx[dir];\n            }\n        }else if(com[i] == 'U') {\n            if(x-1 < 0 || mp[x-1][y] != '.') mp[x][y] = '^';\n            else {\n                mp[x-1][y] = '^';\n                mp[x][y] = '.';\n            }\n        }else if(com[i] == 'R') {\n            if(y+1 >= w || mp[x][y+1] != '.') mp[x][y] = '>';\n            else {\n                mp[x][y+1] = '>';\n                mp[x][y] = '.';\n            }\n        }else if(com[i] == 'D') {\n            if(x+1 >= h || mp[x+1][y] != '.') mp[x][y] = 'v';\n            else {\n                mp[x+1][y] = 'v';\n                mp[x][y] = '.';\n            }\n        }else if(com[i] == 'L') {\n            if(y-1 < 0 || mp[x][y-1] != '.') mp[x][y] = '<';\n            else {\n                mp[x][y-1] = '<';\n                mp[x][y] = '.';\n            }\n        }else assert(false);\n\n    }\n}\n\nint main() {\n    int t,n;\n    string com;\n    cin>>t;\n    while(t--) {\n        cin>>h>>w;\n        for(int i=0; i<h; ++i) cin>>mp[i];\n        cin>>n;\n        cin>>com;\n\n        solve(com);\n        for(int i=0; i<h; ++i) cout<<mp[i]<<endl;\n        if(t > 0) cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem2103 : Battle Town **/\nint main()\n{\n\tint T, W, H; cin>>T;\n\tbool first = true;\n\tstring ds = \"^>v<\";\n\t\n\trep(z, T) {\n\t\tcin>>H>>W;\n\t\tchar field[H][W];\n\t\tP p; int d=0;\n\t\t\n\t\trep(y, H) rep(x, W) {\n\t\t\tcin>>field[y][x];\n\t\t\t\n\t\t\tif (field[y][x]=='>') {\n\t\t\t\tp.first=x, p.second=y;\n\t\t\t\td=1;\n\t\t\t\tfield[y][x] = '.';\n\t\t\t}\n\t\t\t\n\t\t\tif (field[y][x]=='^') {\n\t\t\t\tp.first=x, p.second=y;\n\t\t\t\td=0;\n\t\t\t\tfield[y][x] = '.';\n\t\t\t}\n\t\t\t\n\t\t\tif (field[y][x]=='v') {\n\t\t\t\tp.first=x, p.second=y;\n\t\t\t\td=2;\n\t\t\t\tfield[y][x] = '.';\n\t\t\t}\n\t\t\t\n\t\t\tif (field[y][x]=='<') {\n\t\t\t\tp.first=x, p.second=y;\n\t\t\t\td=3;\n\t\t\t\tfield[y][x] = '.';\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring S; int N;\n\t\tcin>>N>>S;\n\t\t\n\t\trep(i, N) {\n\t\t\tif (S[i] == 'S') {\n\t\t\t\tint sx = p.first, sy = p.second;\n\t\t\t\twhile (1) {\n\t\t\t\t\tsx+=dx[d], sy+=dy[d];\n\t\t\t\t\tif_range(sx, sy, W, H) {\n\t\t\t\t\t\tif (field[sy][sx] == '#') break;\n\t\t\t\t\t\tif (field[sy][sx] == '*') {field[sy][sx]='.'; break;}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (S[i] == 'U')\n\t\t\t\t\td=0;\n\t\t\t\tif (S[i] == 'D')\n\t\t\t\t\td=2;\n\t\t\t\tif (S[i] == 'L')\n\t\t\t\t\td=3;\n\t\t\t\tif (S[i] == 'R')\n\t\t\t\t\td=1;\n\t\t\t\t\n\t\t\t\tint nx = p.first+dx[d], ny = p.second+dy[d];\n\t\t\t\tif_range(nx, ny, W, H) {\n\t\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t\t\tp.first = nx, p.second = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!first) cout << endl;\n\t\trep(y, H) {\n\t\t\trep(x, W) {\n\t\t\t\tif (x == p.first && y == p.second)\n\t\t\t\t\tcout << ds[d];\n\t\t\t\telse\n\t\t\t\t\tcout << field[y][x];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t\tfirst = false;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[20][21], t[4]={'^','>','v','<'};\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\t//ã0 E1 º2 ¶3\nint T, H, W, N;\nstruct {int x, y, a;} p;\t//íÔÌ éÀW,íÔÌü«\nvoid shoot(int x, int y, int a)\n{\n\twhile (0 <= x+dx[a] && x+dx[a] <= W && 0 <= y+dy[a] && y+dy[a] <= H)\n\t{\n\t\tx+=dx[a], y+=dy[a];\n\t\tif (m[y][x]=='*')\n\t\t{\n\t\t\tm[y][x]='.';\n\t\t\tbreak;\n\t\t}\n\t\telse if (m[y][x]=='#')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tchar o[101]=\"\";\n\tint i, j, nx, ny;\n\tcin >> T;\n\tfor (; T > 0; T--)\n\t{\n\t\tcin >> H >> W;\n\t\tfor (i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tswitch (m[i][j])\n\t\t\t\t{\n\t\t\t\tcase '^':\n\t\t\t\t\tp.x=j, p.y=i, p.a=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tp.x=j, p.y=i, p.a=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tp.x=j, p.y=i, p.a=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tp.x=j, p.y=i, p.a=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm[i][j]='\\0';\n\t\t}\n\t\tcin >> N >> o;\n\t\tif (T > 1)\n\t\t\tcout << endl;\n\t\tfor (i = 0; i < N; i++)\n\t\t{\n\t\t\tswitch (o[i])\n\t\t\t{\n\t\t\tcase 'U':\n\t\t\t\tp.a=0;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tp.a=2;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tp.a=3;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tp.a=1;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshoot(p.x, p.y, p.a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx=p.x+dx[p.a], ny=p.y+dy[p.a];\n\t\t\tif (o[i] != 'S' && 0 <= nx && nx <= W && 0 <= ny && ny <= H && m[ny][nx]=='.')\n\t\t\t{\n\t\t\t\tm[p.y][p.x]='.';\n\t\t\t\tp.x=nx, p.y=ny;\n\t\t\t\tm[p.y][p.x]=t[p.a];\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < H; i++)\n\t\t\tcout << m[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nchar field[30][30];\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\nconst char dir1[] = {'^', '<', 'v', '>'};\nconst char dir2[] = {'U', 'L', 'D', 'R'};\n\nint main() {\n  int T; scanf(\"%d\", &T);\n  while (T--) {\n    int W, H;\n    scanf(\"%d%d\", &H, &W);\n    memset(field, '#', sizeof(field));\n    int ty, tx, td;\n    for (int y = 1; y <= H; ++y) {\n      for (int x = 1; x <= W; ++x) {\n        scanf(\" %c\", &field[y][x]);\n        for (int k = 0; k < 4; ++k) {\n          if (field[y][x] == dir1[k]) {\n            ty = y; tx = x; td = k;\n            field[y][x] = '.';\n            break;\n          }\n        }\n      }\n    }\n\n    int N; scanf(\"%d\", &N);\n    for (int i = 0; i < N; ++i) {\n      char op; scanf(\" %c\", &op);\n      for (int k = 0; k < 4; ++k) {\n        if (op == dir2[k]) {\n          td = k;\n          int ny = ty+dy[k], nx = tx+dx[k];\n          if (field[ny][nx] == '.') { ty = ny; tx = nx; }\n          break;\n        }\n      }\n      if (op == 'S') {\n        int by = ty, bx = tx;\n        while (field[by][bx] == '.' || field[by][bx] == '-') {\n          by += dy[td]; bx += dx[td];\n        }\n        if (field[by][bx] == '*') {\n          field[by][bx] = '.';\n        }\n      }\n    }\n\n    for (int y = 1; y <= H; ++y) {\n      for (int x = 1; x <= W; ++x) {\n        printf(\"%c\", field[y][x]);\n      }\n      puts(\"\");\n    }\n    if (T > 0) { puts(\"\"); }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n;\n  cin >> n;\n  int dx[] = {0,1,0,-1};\n  int dy[] = {-1,0,1,0};\n  while(n--) {\n    int h,w;\n    cin >> h >> w;\n    char ba[w][h];\n    int nx, ny, d;\n    REP(i,h)\n      REP(j,w) {\n      cin >> ba[j][i];\n      if (ba[j][i]=='^') {\n        nx = j;\n        ny = i;\n        d = 0;\n      } else if  (ba[j][i]=='>') {\n        nx = j;\n        ny = i;\n        d = 1;\n      } else if  (ba[j][i]=='v') {\n        nx = j;\n        ny = i;\n        d = 2;\n      } else if  (ba[j][i]=='<') {\n        nx = j;\n        ny = i;\n        d = 3;\n      }\n    }\n    ba[nx][ny] = '.';\n    int m;\n    cin >> m;\n    REP(i,m) {\n      char c;\n      cin >> c;\n      if (c=='S') {\n        int sx=nx, sy=ny;\n        while(1) {\n          sx+=dx[d];\n          sy+=dy[d];\n\n          if (sx<0||sx>=w||sy<0||sy>=h) break;\n          if (ba[sx][sy]=='*') {\n            ba[sx][sy] = '.';\n            break;\n          } else if (ba[sx][sy] == '#') break;\n        }\n      } else {\n        if (c=='U') {\n          d = 0;\n        }else if (c=='D')\n          d=2;\n        else if (c=='L')\n          d = 3;\n        else\n          d=1;\n        if (ba[nx+dx[d]][ny+dy[d]] == '.') {\n          nx += dx[d];\n          ny += dy[d];\n        }\n      }\n    }\n    string hoge=\"^>v<\";\n    ba[nx][ny] = hoge[d];\n    REP(y,h) {\n      REP(x,w)\n        cout << ba[x][y];\n      cout << endl;\n    }\n    if (n)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <string>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n#define fi first\n#define se second\nP2 p;\nint n,h,w;\nstring s[21],t;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nP2 get_tank(){\n  r(i,h)r(j,w){\n    if(s[i][j]=='^')return P2(0,P(i,j));\n    if(s[i][j]=='>')return P2(1,P(i,j));\n    if(s[i][j]=='v')return P2(2,P(i,j));\n    if(s[i][j]=='<')return P2(3,P(i,j));\n  }\n}\nvoid shoot(){\n  int y=p.se.fi;\n  int x=p.se.se;\n  while(1){\n    y+=dy[p.fi];\n    x+=dx[p.fi];\n    if(x<0||y<0||y>=h||x>=w)break;\n    if(s[y][x]=='#')break;\n    if(s[y][x]=='*'){\n      s[y][x]='.';\n      break;\n    }\n  }\n}\nvoid GGG(int po){\n  p.fi=po;\n  int y=p.se.fi+dy[po];\n  int x=p.se.se+dx[po];\n  if(x<0||y<0||y>=h||x>=w)return;\n  if(s[y][x]!='.')return;\n  p.se.fi=y;\n  p.se.se=x;\n}\nint main(){\n  cin>>n;\n  while(n--){\n    cin>>h>>w;\n    r(i,h)cin>>s[i];\n    p=get_tank();\n    s[p.se.fi][p.se.se]='.';\n    cin>>t>>t;\n    r(i,t.size()){\n      if(t[i]=='S')shoot();\n      else{\n\tint po;\n        if(t[i]=='U')po=0;\n        if(t[i]=='R')po=1;\n        if(t[i]=='D')po=2;\n        if(t[i]=='L')po=3;\n\tGGG(po);\n      }\n    }\n    if(p.fi==0)s[p.se.fi][p.se.se]='^';\n    if(p.fi==1)s[p.se.fi][p.se.se]='>';\n    if(p.fi==2)s[p.se.fi][p.se.se]='v';\n    if(p.fi==3)s[p.se.fi][p.se.se]='<';\n    r(i,h)cout<<s[i]<<endl;\n   if(n!=0)cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nstruct player{\n\tpublic:\n\t\tplayer(char a, int b, int c):dir(a), posX(b), posY(c){}\n\t\tvoid actU(vector<vector<char> > &table){\n\t\t\tif(posY-1<0){\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t\tdir = '^';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY-1][posX] == '.'){\n\t\t\t\ttable[posY--][posX] = '.';\n\t\t\t\ttable[posY][posX] = '^';\n\t\t\t}\n\t\t\telse table[posY][posX] = '^';\n\t\t\tdir = '^';\n\t\t}\n\t\tvoid actD(vector<vector<char> > &table){\n\t\t\tif(posY+1>=table.size()){\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t\tdir = 'v';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY+1][posX] == '.'){\n\t\t\t\ttable[posY++][posX] = '.';\n\t\t\t\ttable[posY][posX] = 'v';\n\t\t\t}\n\t\t\telse table[posY][posX] = 'v';\n\t\t\tdir = 'v';\n\t\t}\n\t\tvoid actL(vector<vector<char> > &table){\n\t\t\tif(posX-1<0){\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t\tdir = '<';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX-1] == '.'){\n\t\t\t\ttable[posY][posX--] = '.';\n\t\t\t\ttable[posY][posX] = '<';\n\t\t\t}\n\t\t\telse table[posY][posX] = '<';\n\t\t\tdir = '<';\n\t\t}\n\t\tvoid actR(vector<vector<char> > &table){\n\t\t\tif(posX+1>=table[0].size()){\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t\tdir = '>';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(table[posY][posX+1] == '.'){\n\t\t\t\ttable[posY][posX++] = '.';\n\t\t\t\ttable[posY][posX] = '>';\n\t\t\t}\n\t\t\telse table[posY][posX] = '>';\n\t\t\tdir = '>';\n\t\t}\n\t\tvoid actS(vector<vector<char> > &table){\n\t\t\tint progressX = 0;\n\t\t\tint progressY = 0;\n\t\t\tif(dir == '^') progressY = -1;\n\t\t\telse if(dir == 'v') progressY = 1;\n\t\t\telse if(dir == '<') progressX = -1;\n\t\t\telse if(dir == '>') progressX = 1;\n\t\t\tint sposX = posX+progressX, sposY = posY+progressY;\n\t\t\twhile((sposX>=0&&sposX<table[0].size())&&(sposY>=0&&sposY<table.size())){\n\t\t\t\tif(table[sposY][sposX] == '*' || table[sposY][sposX] == '#'){\n\t\t\t\t\tif(table[sposY][sposX] == '*') table[sposY][sposX] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsposX += progressX;\n\t\t\t\tsposY += progressY;\n\t\t\t}\n\t\t}\n\t\tchar dir;\n\t\tint posX;\n\t\tint posY;\n};\n\nvoid action(char act, player &p, vector<vector<char> > &table){\n\tswitch(act){\n\tcase 'U':\n\t\tp.actU(table);\n\t\tbreak;\n\tcase 'D':\n\t\tp.actD(table);\n\t\tbreak;\n\tcase 'L':\n\t\tp.actL(table);\n\t\tbreak;\n\tcase 'R':\n\t\tp.actR(table);\n\t\tbreak;\n\tcase 'S':\n\t\tp.actS(table);\n\t\tbreak;\n\tdefault:\n\t\t\tbreak;\n\t}\n\n}\n\nint main(){\n\tint n = 0;\n\tcin >> n;\n\twhile(n--){\n\t\tint h = 0, w = 0;\n\t\tcin >> h >> w;\n\t\tvector<vector<char> > table(h, vector<char>(w, ' '));\n\t\tplayer p(' ', -1, -1);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tif(table[i][j]=='^'||table[i][j]=='v'||table[i][j]=='<'||table[i][j]=='>'){\n\t\t\t\t\tp.dir = table[i][j];\n\t\t\t\t\tp.posX = j;\n\t\t\t\t\tp.posY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = 0;\n\t\tcin >> m;\n\t\tvector<char> act(m, ' ');\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> act[i];\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\taction(act[i], p, table);\n\t\t}\n\n\t\tfor(int i = 0; i < table.size(); i++){\n\t\t\tfor(int j = 0; j < table[0].size(); j++){\n\t\t\t\tcout << table[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<fstream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<cstring>\n#include<iostream>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> pin;\ntypedef std::pair<int,std::pair<int, int> > ppin;\n\nusing namespace std;\n\nchar ma[22][22];\n\nint main(){\n    \n    int n;\n    cin>>n;\n    while(n--){\n        int a,b;\n        cin>>a>>b;\n        int x=0,y=0,d=0;\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cin>>ma[i][j];\n                if(ma[i][j]=='^'){\n                    y=i; x=j; d=0;\n                }\n                if(ma[i][j]=='v'){\n                    y=i; x=j; d=1;\n                }\n                if(ma[i][j]=='<'){\n                    y=i; x=j; d=2;\n                }\n                if(ma[i][j]=='>'){\n                    y=i; x=j; d=3;\n                }\n            }\n        }\n        \n        int str;\n        cin>>str;\n        string s;\n        cin>>s;\n        for(int k=0;k<s.length();k++){\n            switch(s[k]){\n                case 'U':\n                    \n                    d=0;\n                    if(ma[y-1][x]!='.'||y==0)\n                        continue;\n                    y--;\n                    ma[y+1][x]='.';\n                    ma[y][x]='^';\n                    break;\n                case 'D':\n                    d=1;\n                    if(ma[y+1][x]!='.'||y+1==a)\n                        continue;\n                    \n                    y++;\n                    ma[y-1][x]='.';\n                    ma[y][x]='v';\n                    break;\n                case 'L':\n                    d=2;\n                    if(ma[y][x-1]!='.'||x==0)\n                        continue;\n                    \n                    x--;\n                    ma[y][x+1]='.';\n                    ma[y][x]='<';\n                    break;\n                case 'R':\n                    d=3;\n                    if(ma[y][x+1]!='.'||x+1==b)\n                        continue;\n                    \n                    x++;\n                    ma[y][x-1]='.';\n                    ma[y][x]='>';\n                    break;\n                case 'S':\n                    switch(d){\n                        case 0:\n                            for(int i=y-1;i>=0;i--){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 1:\n                            for(int i=y+1;i<a;i++){\n                                if(ma[i][x]=='*'){\n                                    ma[i][x]='.';\n                                    break;\n                                }\n                                else if(ma[i][x]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 2:\n                            for(int i=x-1;i>=0;i--){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                        case 3:\n                            for(int i=x+1;i<b;i++){\n                                if(ma[y][i]=='*'){\n                                    ma[y][i]='.';\n                                    break;\n                                }\n                                else if(ma[y][i]=='#'){\n                                    break;\n                                }\n                            }\n                            break;\n                    }\n                    break;\n            }\n        }\n        switch(d){\n            case 0:\n                ma[y][x]='^';\n                break;\n            case 1:\n                ma[y][x]='v';\n                break;\n            case 2:\n                ma[y][x]='<';\n                break;\n            case 3:\n                ma[y][x]='>';\n                break;\n        }\n        for(int i=0;i<a;i++){\n            for(int j=0;j<b;j++){\n                cout<<ma[i][j];\n            }\n            cout<<endl;\n        }\n        if(n>1)cout<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.State\nimport Data.List\nimport Data.List.Split (splitOn)\nimport Data.Vector.Unboxed (Vector, (!), (//))\nimport qualified Data.Vector.Unboxed as V\n\nmain :: IO ()\nmain = do\n  n <- readLn\n  [h, w] <- f\n  solve h w <$> replicateM h getLine <*> (getLine >> getLine) >>= mapM_ putStrLn\n  replicateM_ (n - 1) $ do\n    putStrLn \"\"\n    [h, w] <- f\n    solve h w <$> replicateM h getLine <*> (getLine >> getLine) >>= mapM_ putStrLn\n  where\n    f = map read <$> words <$> getLine\n\nsolve :: Int -> Int -> [String] -> String -> [String]\nsolve h w ss cs = let iv = V.fromList $ replicate (w + 1) ' ' ++ intercalate \" \" ss ++ replicate (w + 1) ' '\n                      Just ii = find (\\i -> let c = iv ! i in c == '^' || c == 'v' || c == '<' || c == '>') [0..]\n                      is = (fromIdx ii, iv)\n                  in evalState (f cs) is\n  where\n    toIdx (i, j) = (i + 1) * (w + 1) + j\n    fromIdx ix = let (q, r) = divMod ix (w + 1) in (q - 1, r)\n\n    f :: String -> State ((Int, Int), Vector Char) [String]\n    f [] = do\n      (_, v) <- get\n      return $ splitOn \" \" $ take (h * (w + 1) - 1) $ drop (w + 1) $ V.toList v\n\n    f (c:cs) = do\n      ((i, j), v) <- get\n      case c of\n       'U' -> if v ! (toIdx (i - 1, j)) == '.'\n              then put ((i - 1, j), v // [(toIdx (i - 1, j), '^'),(toIdx (i, j), '.')])\n              else put ((i, j), v // [(toIdx (i, j), '^')])\n       'D' -> if v ! (toIdx (i + 1, j)) == '.'\n              then put ((i + 1, j), v // [(toIdx (i + 1, j), 'v'),(toIdx (i, j), '.')])\n              else put ((i, j), v // [(toIdx (i, j), 'v')])\n       'L' -> if v ! (toIdx (i, j - 1)) == '.'\n              then put ((i, j - 1), v // [(toIdx (i, j - 1), '<'),(toIdx (i, j), '.')])\n              else put ((i, j), v // [(toIdx (i, j), '<')])\n       'R' -> if v ! (toIdx (i, j + 1)) == '.'\n              then put ((i, j + 1), v // [(toIdx (i, j + 1), '>'),(toIdx (i, j), '.')])\n              else put ((i, j), v // [(toIdx (i, j), '>')])\n       'S' -> let ixs = case v ! (toIdx (i, j)) of\n                    '^' -> zip [i-1, i-2 .. 0] (repeat j)\n                    'v' -> zip [i+1 .. h-1] (repeat j)\n                    '<' -> zip (repeat i) [j-1, j-2 .. 0]\n                    '>' -> zip (repeat i) [j+1 .. w-1]\n              in case find (\\(x,y) -> let c = v ! (toIdx (x, y)) in c == '*' || c == '#') ixs of\n                  Nothing -> put ((i, j), v)\n                  Just (x, y) -> if v ! (toIdx (x, y)) == '*'\n                                 then put ((i, j), v // [(toIdx (x, y), '.')])\n                                 else put ((i, j), v)\n      f cs\n\n"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <string>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define dm(x) cerr << #x << \" = \" << x << endl;\nusing namespace std;\n\nchar map[20][21];\nint H,W,N;\n\nstruct po{\n  int x;\n  int y;\n  po operator+(po &p){\n    po t={x+p.x, y+p.y};\n    return t;\n  }\n  char &l(){return map[x][y];}\n  bool v(){return 0<=x && x<H && 0<=y && y<W;}\n  void d(){dm(x);dm(y);}\n};\n\npo mp(int x,int y){\n  po t={x, y};\n  return t;\n}\n\nint main()\n{\n  int T;\n  scanf(\"%d\", &T);\n  rep(datasetindex, T){\n    po p={0,0},d={0,0};\n    char c[101];\n    scanf(\"%d %d\", &H, &W);\n    rep(i,H) scanf(\"%s\", map[i]);\n    scanf(\"%d\", &N);\n    scanf(\"%s\", c);\n    dm(H);dm(W);\n    rep(j,W) rep(i,H){\n      switch(map[i][j]){\n      case '^':p=mp(i,j);d=mp(-1,0);break;\n      case '>':p=mp(i,j);d=mp(0,1);break;\n      case 'v':p=mp(i,j);d=mp(1,0);break;\n      case '<':p=mp(i,j);d=mp(0,-1);break;\n      }\n    }\n    rep(i,H) printf(\"%d : %s\\n\", i, map[i]);\n    p.d();d.d();\n    rep(i,N){\n      dm(c[i]);\n      switch(c[i]){\n      case 'S':{\n        po s=p;\n        do{s=s+d;}while(s.v() && s.l()!='*' && s.l()!='#');\n        if(s.v() && s.l()=='*')\n          s.l()='.';\n        break;\n      }\n      case 'U':\n        p.l()='.';\n        d=mp(-1,0);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='^';\n        break;\n      case 'R':\n        p.l()='.';\n        d=mp(0,1);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='>';\n        break;\n      case 'D':\n        p.l()='.';\n        d=mp(1,0);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='v';\n        break;\n      case 'L':\n        p.l()='.';\n        d=mp(0,-1);\n        if((p+d).v() && (p+d).l()=='.')\n          p=p+d;\n        p.l()='<';\n        break;\n      }\n      rep(i,H) printf(\"%d : %s\\n\", i, map[i]);\n    }\n  }\n}\n  "
  },
  {
    "language": "C",
    "code": "// Aizu 2103: Battle Town\n// 2017.9.20 bal4u@uu\n\n#include <stdio.h>\n\nchar map[22][22]; int h, w;\nchar s[102];\nchar tbl[128];\nint mv[4][2] = { {-1,0},{0,1},{1,0},{0,-1} };\nchar dir[4] = { '^', '>', 'v', '<' };\n\nint main()\n{\n\tint cno, t, n, r, c, tr, tc, d, k;\n\tchar *p;\n\n\ttbl['^'] = 1, tbl['>'] = 2, tbl['v'] = 3, tbl['<'] = 4;\n\ttbl['U'] = 1, tbl['R'] = 2, tbl['D'] = 3, tbl['L'] = 4;\n\tscanf(\"%d\", &t); cno = 0; while (t-- > 0) {\n\t\tscanf(\"%d%d\", &h, &w);\n\t\tfor (r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tfor (c = 0; c < w; c++) if ((k = tbl[map[r][c]]) > 0) tr = r, tc = c, d = k-1;\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%s\", s); p = s;\n\t\twhile (*p) {\n\t\t\tif (*p != 'S') {\n\t\t\t\td = tbl[*p]-1; r = tr + mv[d][0], c = tc + mv[d][1]; map[tr][tc] = '.';\n\t\t\t\tif (r >= 0 && r < h && c >= 0 && c < w && map[r][c] == '.') tr = r, tc = c;\n\t\t\t\tmap[tr][tc] = dir[d];\n\t\t\t} else {\n\t\t\t\tr = tr, c = tc; while (1) {\n\t\t\t\t\tr += mv[d][0], c += mv[d][1];\n\t\t\t\t\tif (r < 0 || r >= h || c < 0 || c >= w) break;\n\t\t\t\t\tif (map[r][c] == '*') { map[r][c] = '.'; break; }\n\t\t\t\t\telse if (map[r][c] == '#') break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (cno++) putchar('\\n');\n\t\tfor (r = 0; r < h; r++) puts(map[r]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char m[20][21],s[101];\nchar direc[5]=\"^v<>\";\n\nsolve(h,w,n){\n  int i,j,x,y,d;\n  char *p;\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      if(p=strchr(direc,m[i][j])){\n        y=i;x=j;\n        d=p-direc;\n        m[i][j]='.';\n        break;\n      }\n  for(j=0;j<n;j++)\n    switch(s[j]){\n      case 'U':\n        d=0;if(y>0  &&m[y-1][x]=='.')y--;break;\n      case 'D':\n        d=1;if(y<h-1&&m[y+1][x]=='.')y++;break;\n      case 'L':\n        d=2;if(x>0  &&m[y][x-1]=='.')x--;break;\n      case 'R':\n        d=3;if(x<w-1&&m[y][x+1]=='.')x++;break;\n      case 'S':\n        switch(d){\n          case 0:\n            for(i=y-1;~i;i--){\n              if(m[i][x]=='#')break;\n              if(m[i][x]=='*'){m[i][x]='.';break;}\n            }break;\n          case 1:\n            for(i=y+1;i<h;i++){\n              if(m[i][x]=='#')break;\n              if(m[i][x]=='*'){m[i][x]='.';break;}\n            }break;\n          case 2:\n            for(i=x-1;~i;i--){\n              if(m[y][i]=='#')break;\n              if(m[y][i]=='*'){m[y][i]='.';break;}\n            }break;\n          case 3:\n            for(i=x+1;i<w;i++){\n              if(m[y][i]=='#')break;\n              if(m[y][i]=='*'){m[y][i]='.';break;}\n            }break;\n        }\n        break;\n    }\n  m[y][x]=direc[d];\n  for(i=0;i<h;i++)\n    printf(\"%s\\n\",m[i]);\n}\n\nmain(){\n  int c,h,w,n,i;\n  scanf(\"%d\",&c);\n  for(;c;c--){\n    scanf(\"%d%d\",&h,&w);\n    for(i=0;i<h;i++)\n      scanf(\"%s\",m[i]);\n    scanf(\"%d%s\",&n,s);\n    solve(h,w,n);\n    if(c>1)puts(\"\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint x, y, d;\nint dir[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\nchar map[24][24];\n\nvoid chDir(char op){\n  if(op == 'U') d = 0;\n  else if(op == 'R') d = 1;\n  else if(op == 'D') d = 2;\n  else d = 3;\n}\n\nvoid goStraight(void){\n  int nx, ny;\n\n  nx = x + dir[d][1];\n  ny = y + dir[d][0];\n  if(map[ny][nx] == '.'){\n    x = nx;\n    y = ny;\n  }\n}\n\nvoid shoot(void){\n  int tx = x, ty = y;\n\n  for(; map[ty][tx] != '#' && map[ty][tx] != '*'; tx += dir[d][1], ty += dir[d][0]);\n\n  if(map[ty][tx] == '*'){\n    map[ty][tx] = '.';\n  }\n}\n\nint main(void){\n  int i, j;\n  int n, h, w, len;\n  int flg;\n  char op[104];\n\n  scanf(\"%d\",&n);\n  while(n--){\n    scanf(\"%d%d\",&h,&w);\n\n    memset(map,'#',sizeof(map));\n    flg = 0;\n    for(i = 1; i <= h; i++){\n      scanf(\"%s\",&map[i][1]);\n      map[i][w+1] = '#';\n      for(j = 1; !flg && j <= w; j++){\n\tif(map[i][j] == '^'){\n\t  flg = 1;\n\t  d = 0;\n\t}\n\telse if(map[i][j] == '>'){\n\t  flg = 1;\n\t  d = 1;\n\t}\n\telse if(map[i][j] == 'v'){\n\t  flg = 1;\n\t  d = 2;\n\t}\n\telse if(map[i][j] == '<'){\n\t  flg = 1;\n\t  d = 3;\n\t}\n\tif(flg){\n\t  map[i][j] = '.';\n\t  x = j;\n\t  y = i;\n\t}\n      }\n    }\n    scanf(\"%d%s\",&len,op);\n\n    for(i = 0; i < len; i++){\n      if(op[i] == 'S'){\n\tshoot();\n      }\n      else{\n\tchDir(op[i]);\n\tgoStraight();\n      }\n    }\n\n    if(d == 0){\n      map[y][x] = '^';\n    }\n    else if(d == 1){\n      map[y][x] = '>';\n    }\n    else if(d == 2){\n      map[y][x] = 'v';\n    }\n    else{\n      map[y][x] = '<';\n    }\n\n    for(i = 1; i <= h; i++){\n      for(j = 1; j <= w; j++){\n\tputchar(map[i][j]);\n      }\n      putchar('\\n');\n    }\n\n    if(n != 0){\n      putchar('\\n');\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n/* 自機を表す文字 */ \n#define MYCHAR_UP\t\t'^'\n#define MYCHAR_DOWN\t\t'v'\n#define MYCHAR_LEFT\t\t'<'\n#define MYCHAR_RIGHT\t'>'\n\n/* マップを表す文字 */ \n#define MAP_PLAIN\t'.' /* 平地　　　 */ \n#define MAP_BRICK\t'*' /* レンガの壁 */ \n#define MAP_IRON\t'#' /* 鉄の壁　　 */ \n#define MAP_WATER\t'-' /* 水　　　　 */ \n\n/* マップを読み込む */ \nvoid inputMap(char map[20][21],int* mapWidth,int* mapHeight) {\n\tint i;\n\tscanf(\"%d%d\",mapHeight,mapWidth);\n\tfor(i=0;i<*mapHeight;i++)scanf(\"%s\",map[i]);\n}\n\n/* コマンドを読み込む */ \nvoid inputCommand(char* command,int* commandLength) {\n\tscanf(\"%d\",commandLength);\n\tscanf(\"%s\",command);\n}\n\n/* 与えられた文字が自機を表す文字か判定する */\nint isMyChar(char c) {\n\treturn (c==MYCHAR_UP || c==MYCHAR_DOWN || c==MYCHAR_LEFT || c==MYCHAR_RIGHT);\n}\n\n/* スタート位置を取得する。成功したら真、失敗したら偽を返す */ \nint getStart(int* x,int* y,char map[20][21],int mapWidth,int mapHeight) {\n\tint i,j;\n\t*x=*y=-1;\n\tfor(i=0;i<mapHeight;i++) {\n\t\tfor(j=0;j<mapWidth;j++) {\n\t\t\tif(isMyChar(map[i][j])) {\n\t\t\t\t*y=i;*x=j;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* 弾を発射する */ \nvoid shootMyBullet(int x,int y,char map[20][21],int mapWidth,int mapHeight) {\n\tint i;\n\tswitch(map[y][x]) {\n\t\tcase MYCHAR_UP:\n\t\t\tfor(i=y;i>=0;i--) {\n\t\t\t\tif(map[i][x]==MAP_BRICK) {\n\t\t\t\t\tmap[i][x]=MAP_PLAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(map[i][x]==MAP_IRON)break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MYCHAR_DOWN:\n\t\t\tfor(i=y;i<mapHeight;i++) {\n\t\t\t\tif(map[i][x]==MAP_BRICK) {\n\t\t\t\t\tmap[i][x]=MAP_PLAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(map[i][x]==MAP_IRON)break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MYCHAR_LEFT:\n\t\t\tfor(i=x;i>=0;i--) {\n\t\t\t\tif(map[y][i]==MAP_BRICK) {\n\t\t\t\t\tmap[y][i]=MAP_PLAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(map[y][i]==MAP_IRON)break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MYCHAR_RIGHT:\n\t\t\tfor(i=x;i<mapWidth;i++) {\n\t\t\t\tif(map[y][i]==MAP_BRICK) {\n\t\t\t\t\tmap[y][i]=MAP_PLAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(map[y][i]==MAP_IRON)break;\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\n\n/* 自機を動かす */ \nvoid moveMyChar(char command,int* x,int* y,char map[20][21],int mapWidth,int mapHeight) {\n\tswitch(command) {\n\t\tcase 'U':\n\t\t\t/* 上に移動する */ \n\t\t\tmap[*y][*x]=MYCHAR_UP;\n\t\t\tif(*y>0 && map[*y-1][*x]==MAP_PLAIN) {\n\t\t\t\tmap[*y-1][*x]=MYCHAR_UP;\n\t\t\t\tmap[*y][*x]=MAP_PLAIN;\n\t\t\t\t(*y)--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\t/* 下に移動する */ \n\t\t\tmap[*y][*x]=MYCHAR_DOWN;\n\t\t\tif(*y<mapHeight-1 && map[*y+1][*x]==MAP_PLAIN) {\n\t\t\t\tmap[*y+1][*x]=MYCHAR_DOWN;\n\t\t\t\tmap[*y][*x]=MAP_PLAIN;\n\t\t\t\t(*y)++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t/* 左に移動する */ \n\t\t\tmap[*y][*x]=MYCHAR_LEFT;\n\t\t\tif(*x>0 && map[*y][*x-1]==MAP_PLAIN) {\n\t\t\t\tmap[*y][*x-1]=MYCHAR_LEFT;\n\t\t\t\tmap[*y][*x]=MAP_PLAIN;\n\t\t\t\t(*x)--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\t/* 右に移動する */ \n\t\t\tmap[*y][*x]=MYCHAR_RIGHT;\n\t\t\tif(*x<mapWidth-1 && map[*y][*x+1]==MAP_PLAIN) {\n\t\t\t\tmap[*y][*x+1]=MYCHAR_RIGHT;\n\t\t\t\tmap[*y][*x]=MAP_PLAIN;\n\t\t\t\t(*x)++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\t/* 弾を撃つ */\n\t\t\tshootMyBullet(*x,*y,map,mapWidth,mapHeight);\n\t\t\tbreak;\n\t}\n}\n\n/* マップの状態を出力する */ \nvoid printMap(char map[20][21],int mapHeight) {\n\tint i;\n\tfor(i=0;i<mapHeight;i++)puts(map[i]);\n}\n\nint main(void) {\n\t/* データの情報 */ \n\tint mapWidth,mapHeight;\t/* マップの大きさ */ \n\tchar map[20][21]; \t\t/* マップ本体　最後にNULを含む */ \n\tint commandLength; \t\t/* コマンドの文字数 */ \n\tchar command[200];\t\t/* コマンド本体 */ \n\n\tint dataNum,dataCount; \n\tint i;\n\tint x,y;\n\n\tscanf(\"%d\",&dataNum);\n\n\tfor(dataCount=0;dataCount<dataNum;dataCount++) {\n\t\tinputMap(map,&mapWidth,&mapHeight);\n\t\tinputCommand(command,&commandLength);\n\n\t\tif(!getStart(&x,&y,map,mapWidth,mapHeight))return 1;\n\t\tfor(i=0;i<commandLength;i++) {\n\t\t\tmoveMyChar(command[i],&x,&y,map,mapWidth,mapHeight);\n\t\t}\n\n\t\tprintMap(map,mapHeight);\n\t\tif(dataCount<dataNum-1)putchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n    /* ?????????????????± */\n    int mapWidth,mapHeight; /* ??????????????§?????? */\n    char map[20][21];       /* ???????????¬??? ?????????NUL????????? */\n    int commandLength;      /* ???????????????????????° */\n    char command[200];      /* ??????????????¬??? */\n \n    int dataNum,dataCount; \n    int i;\n    int x,y;\n \n    scanf(\"%d\",&dataNum);\n \n    for(dataCount=0;dataCount<dataNum;dataCount++) {\n        inputMap(map,&mapWidth,&mapHeight);\n        inputCommand(command,&commandLength);\n \n        if(!getStart(&x,&y,map,mapWidth,mapHeight))return 1;\n        for(i=0;i<commandLength;i++) {\n            moveMyChar(command[i],&x,&y,map,mapWidth,mapHeight);\n        }\n \n        printMap(map,mapHeight);\n        if(dataCount<dataNum-1)putchar('\\n');\n    }\n    return 0;\n}\n\n\n\n/* ???????????¨????????? */\n#define MYCHAR_UP       '^'\n#define MYCHAR_DOWN     'v'\n#define MYCHAR_LEFT     '<'\n#define MYCHAR_RIGHT    '>'\n \n/* ??????????????¨????????? */\n#define MAP_PLAIN   '.' /* ?????°????????? */ \n#define MAP_BRICK   '*' /* ??¬?????¬????£? */ \n#define MAP_IRON    '#' /* ???????£??????? */ \n#define MAP_WATER   '-' /* ?°´???????????? */ \n \n/* ???????????????????????? */\nvoid inputMap(char map[20][21],int* mapWidth,int* mapHeight) {\n    int i;\n    scanf(\"%d%d\",mapHeight,mapWidth);\n    for(i=0;i<*mapHeight;i++)scanf(\"%s\",map[i]);\n}\n \n/* ??????????????????????????? */\nvoid inputCommand(char* command,int* commandLength) {\n    scanf(\"%d\",commandLength);\n    scanf(\"%s\",command);\n}\n \n/* ???????????????????????????????????¨???????????????????????? */\nint isMyChar(char c) {\n    return (c==MYCHAR_UP || c==MYCHAR_DOWN || c==MYCHAR_LEFT || c==MYCHAR_RIGHT);\n}\n \n/* ???????????????????????????????????????????????????????????±???????????????????????? */\nint getStart(int* x,int* y,char map[20][21],int mapWidth,int mapHeight) {\n    int i,j;\n    *x=*y=-1;\n    for(i=0;i<mapHeight;i++) {\n        for(j=0;j<mapWidth;j++) {\n            if(isMyChar(map[i][j])) {\n                *y=i;*x=j;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n \n/* ??????????°??????? */\nvoid shootMyBullet(int x,int y,char map[20][21],int mapWidth,int mapHeight) {\n    int i;\n    switch(map[y][x]) {\n        case MYCHAR_UP:\n            for(i=y;i>=0;i--) {\n                if(map[i][x]==MAP_BRICK) {\n                    map[i][x]=MAP_PLAIN;\n                    break;\n                } else if(map[i][x]==MAP_IRON)break;\n            }\n            break;\n        case MYCHAR_DOWN:\n            for(i=y;i<mapHeight;i++) {\n                if(map[i][x]==MAP_BRICK) {\n                    map[i][x]=MAP_PLAIN;\n                    break;\n                } else if(map[i][x]==MAP_IRON)break;\n            }\n            break;\n        case MYCHAR_LEFT:\n            for(i=x;i>=0;i--) {\n                if(map[y][i]==MAP_BRICK) {\n                    map[y][i]=MAP_PLAIN;\n                    break;\n                } else if(map[y][i]==MAP_IRON)break;\n            }\n            break;\n        case MYCHAR_RIGHT:\n            for(i=x;i<mapWidth;i++) {\n                if(map[y][i]==MAP_BRICK) {\n                    map[y][i]=MAP_PLAIN;\n                    break;\n                } else if(map[y][i]==MAP_IRON)break;\n            }\n            break;\n    }\n}\n \n/* ?????????????????? */\nvoid moveMyChar(char command,int* x,int* y,char map[20][21],int mapWidth,int mapHeight) {\n    switch(command) {\n        case 'U':\n            /* ???????§?????????? */\n            map[*y][*x]=MYCHAR_UP;\n            if(*y>0 && map[*y-1][*x]==MAP_PLAIN) {\n                map[*y-1][*x]=MYCHAR_UP;\n                map[*y][*x]=MAP_PLAIN;\n                (*y)--;\n            }\n            break;\n        case 'D':\n            /* ???????§?????????? */\n            map[*y][*x]=MYCHAR_DOWN;\n            if(*y<mapHeight-1 && map[*y+1][*x]==MAP_PLAIN) {\n                map[*y+1][*x]=MYCHAR_DOWN;\n                map[*y][*x]=MAP_PLAIN;\n                (*y)++;\n            }\n            break;\n        case 'L':\n            /* ???????§?????????? */\n            map[*y][*x]=MYCHAR_LEFT;\n            if(*x>0 && map[*y][*x-1]==MAP_PLAIN) {\n                map[*y][*x-1]=MYCHAR_LEFT;\n                map[*y][*x]=MAP_PLAIN;\n                (*x)--;\n            }\n            break;\n        case 'R':\n            /* ???????§?????????? */\n            map[*y][*x]=MYCHAR_RIGHT;\n            if(*x<mapWidth-1 && map[*y][*x+1]==MAP_PLAIN) {\n                map[*y][*x+1]=MYCHAR_RIGHT;\n                map[*y][*x]=MAP_PLAIN;\n                (*x)++;\n            }\n            break;\n        case 'S':\n            /* ???????????? */\n            shootMyBullet(*x,*y,map,mapWidth,mapHeight);\n            break;\n    }\n}\n \n/* ??????????????¶?????????????????? */\nvoid printMap(char map[20][21],int mapHeight) {\n    int i;\n    for(i=0;i<mapHeight;i++)puts(map[i]);\n}"
  },
  {
    "language": "C",
    "code": "//#define DEBUG\n\nint Nsets, Ncodes; int mapW, mapH;\nint tankX, tankY, tankD;//the position and the direction of the tank\nchar map[20][20]; char code;\nvoid init_map(); void print_map(); void step(); void move(int); void shoot();\n\nint main(){\n\tint i;\n\tscanf(\"%d\", &Nsets);\n\twhile(Nsets--){\n\t\tinit_map();\n\t\t\t#ifdef DEBUG\n\t\t\tprintf(\"map print test.\\n\");\n\t\t\tprint_map();\n\t\t\t#endif\n\t\tscanf(\"%d\", &Ncodes);\n\t\tfor(i = 0; i < Ncodes; i++)step( scanf(\" %c\", &code) );\n\t\tprint_map();\n\t\tif(Nsets)printf(\"\\n\");\n\t}\n\treturn 0;\n}\n\nvoid step(){\n\tint i;\n\tchar move_symbol[] = \"UDLR\";\n\tfor(i = 0; move_symbol[i]; i++){\n\t\tif(move_symbol[i] == code){\n\t\t\tmove(i);\n\t\t\treturn;\n\t\t}\n\t}\n\tshoot();\n}\nvoid move(int d){\n\t\t#ifdef DEBUG\n\t\tprintf(\"move(%d) is called.\\n\", d);\n\t\t#endif\n\tint moveX[] = {0,0,-1,1}; int moveY[] = {-1,1,0,0};\n\tint newX = tankX + moveX[d], newY = tankY + moveY[d];\n\tchar tank_symbol[] = \"^v<>\";\n\t//is leagal move?\n\tif( (0 <= newX && newX < mapW) && (0 <= newY && newY < mapH) &&\n\tmap[newX][newY] == '.'){\n\t\t//move\n\t\tmap[tankX][tankY] = '.';\n\t\ttankX = newX, tankY = newY;\n\t}\n\ttankD = d;\n\tmap[tankX][tankY] = tank_symbol[tankD];\n}\nvoid shoot(){\n\tint moveX[] = {0,0,-1,1}; int moveY[] = {-1,1,0,0};\n\tint x = tankX + moveX[tankD], y = tankY + moveY[tankD];\n\twhile(0 <= x && x < mapW && 0 <= y && y < mapH){\n\t\tif(map[x][y] == '*'){\n\t\t\tmap[x][y] = '.';\n\t\t\tbreak;\n\t\t}else if(map[x][y] == '#'){\n\t\t\tbreak;\n\t\t}\n\t\tx += moveX[tankD], y += moveY[tankD];\n\t}\n}\n\nvoid init_map(){\n\tint i, j, k;\n\tchar tank_symbol[] = \"^v<>\";\n\tscanf(\"%d %d\", &mapH, &mapW);\n\tfor(j = 0; j < mapH; j++)for(i = 0; i < mapW; i++){\n\t\tscanf(\" %c\", &map[i][j]);\n\t\tfor(k = 0; tank_symbol[k]; k++)if(map[i][j] == tank_symbol[k])tankX = i, tankY = j, tankD = k;\n\t}\n}\nvoid print_map(){\n\tint i, j;\n\tfor(j = 0; j < mapH; j++){\n\t\tfor(i = 0; i < mapW; i++)printf(\"%c\", map[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2103 \n  Title:Battle Town\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\n\nint T,H,W,N;\nint py,px;   //position\nchar map[20][21];\nchar map2[20][21];\nchar op[101];\nint dir;\nint diffx[4]={1,0,-1,0};\nint diffy[4]={0,-1,0,1};\nchar sensha[4]=\">^<v\";\n\nint in_range(int y,int x)\n{\n        return(y>=0 && y<H && x>=0 && x<W);\n}\nvoid dispatch(char ins)\n{\n        int dx,dy;\n\n        if(ins=='U')\n        {\n                dir=1;\n                if(py>0   && map[py-1][px]=='.')\n                        py--;\n        }\n        if(ins=='D')\n        {\n                dir=3;\n                if(py<H-1 && map[py+1][px]=='.')\n                        py++;\n        }\n        if(ins=='L')\n        {\n                dir=2;\n                if(py>0   && map[py][px-1]=='.')\n                        px--;\n        }\n        if(ins=='R')\n        {\n                dir=0;\n                if(px<H-1 && map[py][px+1]=='.')\n                        px++;\n        }\n        if(ins=='S')\n        {\n                dy=py;dx=px;\n                while(in_range(dy,dx) && (map[dy][dx]=='.' || map[dy][dx]=='-'))\n                {\n                        dy+=diffy[dir];\n                        dx+=diffx[dir];\n                        //printf(\"DYX=%d %d\\n\",dy,dx);\n                }\n                if(in_range(dy,dx) && map[dy][dx]=='*')\n                        map[dy][dx]='.';\n        }\n}\nvoid write_map(int cr)\n{\n        int i;\n        \n        memcpy(map2,map,20*21);\n        map2[py][px]=sensha[dir];\n\n        for(i=0;i<H;i++)\n                printf(\"%s\\n\",&map2[i][0]);\n\n        if(cr)\n                printf(\"\\n\");\n}\nint search_pos(int * y,int * x)\n{\n        int i,j;\n        char *p;\n\n        for(i=0;i<H;i++)\n                for(j=0;j<W;j++)\n                        if((p=strchr(sensha,map[i][j])))\n                        {\n                                *y=i;*x=j;return(p-sensha);\n                        }\n        return(-1);\n}\nvoid solve()\n{\n        int i;\n        char ins;\n\n        dir=search_pos(&py,&px);\n\n        //printf(\"YX=%d %d (%d)\\n\",py,px,dir);\n\n        map[py][px]='.';\n\n        for(i=0;i<N;i++)\n        {\n                //write_map();\n                ins=op[i];\n                //printf(\"INS=%c\\n\",ins);\n                dispatch(ins);\n        }\n}\nmain()\n{\n        int i,j,ret;\n\n        scanf(\"%d\",&T);\n        for(i=0;i<T;i++)\n        {\n                scanf(\"%d %d\",&H,&W);\n                for(j=0;j<H;j++)\n                        scanf(\"%s\",&map[j][0]);\n                scanf(\"%d\",&N);\n                scanf(\"%s\",&op[0]);\n                solve();\n                write_map((i<T-1));\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[20][21];\t\t\t\t\t\t\t\t\t\t\t//高さ * 幅\nint h, w;\t\t\t\t\t\t\t\t\t\t\t\t\t//マップの高さ、幅\nint px, py, dir = 0;\t\t\t\t\t\t\t\t\t\t//自分の座標、方向\nint dirx[4] = { 0,0,-1,1 };\nint diry[4] = { -1,1,0,0 };\nchar my[4] = { '^', 'v', '<', '>' };\n\nvoid act(char *n);\nvoid move(int x);\nvoid shot(int x);\nvoid format(int x, int y);\nvoid view(void);\n\nint main(void) {\n\tformat(20, 20);\n\tint i, j, k;\n\tint data;\t\t\t\t\t\t\t\t\t\t\t\t//繰り返し回数\n\tint nmax;\t\t\t\t\t\t\t\t\t\t\t\t//操作列の長さ\n\tchar n[101];\t\t\t\t\t\t\t\t\t\t\t//操作列の格納用\n\tscanf(\"%d\\n\", &data);\t\t\t\t\t\t\t\t\t//繰り返し回数の取得\n\tfor (k = 0; k < data; k++) {\n\t\tscanf(\"%d %d\\n\", &h, &w);\t\t\t\t\t\t\t//高さと幅の取得\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tmap[i][j] = getchar();\n\t\t\t\tif (map[i][j] == '^') { px = j, py = i, dir = 0; }\n\t\t\t\tif (map[i][j] == 'v') { px = j, py = i, dir = 1; }\n\t\t\t\tif (map[i][j] == '<') { px = j, py = i, dir = 2; }\n\t\t\t\tif (map[i][j] == '>') { px = j, py = i, dir = 3; }\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d\\n\", &nmax);\t\t\t\t\t\t\t\t//操作列の長さの取得\n\t\tif (nmax < 0) { nmax = 0; }\n\t\tif (nmax > 100) { nmax = 100; }\n\t\tfor (i = 0; i < nmax; i++) {\t\t\t\t\t\t//操作列の取得\n\t\t\tn[i] = getchar();\n\t\t}\n\t\tn[i] = '\\0';\n\t\tact(&n[0]);\t\t\t\t\t\t\t\t\t\t\t//行動処理\n\t\tview();\t\t\t\t\t\t\t\t\t\t\t\t//結果の表示\n\t\tif (k + 1 != data) { printf(\"\\n\"); }\n\t}\n\treturn 0;\n}\nvoid act(char *str) {\t\t\t\t\t\t\t\t\t\t//行動処理\n\twhile (*str != '\\0') {\n\t\tswitch (*str) {\n\t\tcase 'U':\n\t\t\tdir = 0;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdir = 1;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tdir = 2;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdir = 3;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tshot(dir);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t}\n}\nvoid move(int x) {\t\t\t\t\t\t\t\t\t\t\t//移動処理\n\tint sx = px + dirx[x], sy = py + diry[x], flag = 0;\n\tif (sx < 0 || sx >= w) { flag = 1; }\n\tif (sy < 0 || sy >= h) { flag = 1; }\n\tif (map[sy][sx] == '.' && flag == 0) {\n\t\tmap[py][px] = '.';\t\t\t\t\t\t\t\t\t//自分のいた場所を平地へ変更する\n\t\tpx = sx, py = sy;\t\t\t\t\t\t\t\t\t//座標を移動する\n\t}\n\tmap[py][px] = my[dir];\n}\nvoid shot(int x) {\t\t\t\t\t\t\t\t\t\t\t//砲弾処理\n\tint sx = px + dirx[x], sy = py + diry[x] , flag;\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t//移動可能な限り繰り返す\n\t\tflag = 0;\n\t\tif (sx < 0 || sx >= w) { break; }\t\t\t\t\t//幅の範囲外は見ない\n\t\tif (sy < 0 || sy >= h) { break; }\t\t\t\t\t//高さの範囲外は見ない\n\t\tswitch (map[sy][sx]) {\n\t\t\tcase '*':\t\t\t\t\t\t\t\t\t\t//レンガの壁の場合\n\t\t\t\tmap[sy][sx] = '.';\t\t\t\t\t\t\t//平地に変更する\n\t\t\t\tbreak;\n\t\t\tcase '#':\t\t\t\t\t\t\t\t\t\t//鉄の壁の場合\n\t\t\t\tbreak;\n\t\t\tdefault:\t\t\t\t\t\t\t\t\t\t//障害物以外の場合\n\t\t\t\tflag = 1;\t\t\t\t\t\t\t\t\t//繰り返す\n\t\t\t\tbreak;\n\t\t}\n\t\tsx += dirx[x];\n\t\tsy += diry[x];\n\t} while (flag != 0);\n}\nvoid format(int x, int y) {\n\tint i, j;\n\tfor (i = 0; i < x; i++) {\n\t\tfor (j = 0; j < y; j++) {\n\t\t\tmap[i][j] = '0';\n\t\t}\n\t}\n}\nvoid view(void) {\n\tint i, j;\n\tprintf(\"\\n\");\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tprintf(\"%c\", map[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n//\tprintf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,k,ny,nx,w,h,d,y,x;\n  int Y[]={-1,0,1,0};\n  int X[]={0,1,0,-1};\n  char c,s[4]={\"^>v<\"};\n  scanf(\"%d\",&n);\n  while(n--){\n   char m[22][22]={0};\n   d=4;\n   scanf(\"%d %d\",&h,&w);\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&m[i][j]);\n\tif(d==4){\n\t  for(d=0;d<4;d++){\n\t    if(m[i][j]==s[d])break;\n\t  }\n\t  if(d-4)m[y=i][x=j]='.';\n\t}//printf(\"%d \",d);\n      }\n    }\n    scanf(\"%d\",&k);\n    while(k--){\n      scanf(\" %c\",&c);//printf(\"%d\\n\",d);\n      if(c=='U')d=0;\n      if(c=='R')d=1;\n      if(c=='D')d=2;\n      if(c=='L')d=3;\n      if(c=='S'){\n\tfor(i=1;1;i++){\n\t  nx=x+X[d]*i;\n\t  ny=y+Y[d]*i;\n\t  if(m[ny][nx]=='#'||m[ny][nx]==0)break;\n\t  if(m[ny][nx]=='*'){\n\t    m[ny][nx]='.';\n\t    break;\n\t  }\n\t}//printf(\"i%d\\n\",i);\n      }\n      else{\n\tnx=x+X[d];\n\tny=y+Y[d];\n\tif(m[ny][nx]=='.'){\n\t  y=ny;\n\t  x=nx;\n\t}\n      }\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(i==y&&j==x)printf(\"%c\",s[d]);\n\telse printf(\"%c\",m[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    if(n)printf(\"\\n\");\n  }\n  return 0;\n}\n       \n\t  \n\t  \n    \n    \n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[20][21];\t\t\t\t\t\t\t\t\t\t\t//高さ * 幅\nint h, w;\t\t\t\t\t\t\t\t\t\t\t\t\t//マップの高さ、幅\nint px, py, dir = 0;\t\t\t\t\t\t\t\t\t\t//自分の座標、方向\nint dirx[4] = { 0,0,-1,1 };\nint diry[4] = { -1,1,0,0 };\nchar my[4] = { '^', 'v', '<', '>' };\n\nvoid act(char *n);\nvoid move(int x);\nvoid shot(int x);\nvoid format(int x, int y);\nvoid view(void);\n\nint main(void) {\n\tformat(20, 20);\n\tint i, j, k;\n\tint data;\t\t\t\t\t\t\t\t\t\t\t\t//繰り返し回数\n\tint nmax;\t\t\t\t\t\t\t\t\t\t\t\t//操作列の長さ\n\tchar n[101];\t\t\t\t\t\t\t\t\t\t\t//操作列の格納用\n\tscanf(\"%d\\n\", &data);\t\t\t\t\t\t\t\t\t//繰り返し回数の取得\n\tfor (k = 0; k < data; k++) {\n\t\tscanf(\"%d %d\\n\", &h, &w);\t\t\t\t\t\t\t//高さと幅の取得\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tmap[i][j] = getchar();\n\t\t\t\tif (map[i][j] == '^') { px = j, py = i, dir = 0; }\n\t\t\t\tif (map[i][j] == 'v') { px = j, py = i, dir = 1; }\n\t\t\t\tif (map[i][j] == '<') { px = j, py = i, dir = 2; }\n\t\t\t\tif (map[i][j] == '>') { px = j, py = i, dir = 3; }\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d\\n\", &nmax);\t\t\t\t\t\t\t\t//操作列の長さの取得\n\t\tif (nmax < 0) { nmax = 0; }\n\t\tif (nmax > 100) { nmax = 100; }\n\t\tfor (i = 0; i < nmax; i++) {\t\t\t\t\t\t//操作列の取得\n\t\t\tn[i] = getchar();\n\t\t}\n\t\tn[i] = '\\0';\n\t\tact(&n[0]);\t\t\t\t\t\t\t\t\t\t\t//行動処理\n\t\tview();\t\t\t\t\t\t\t\t\t\t\t\t//結果の表示\n\t\tif (k + 1 != data) { printf(\"\\n\"); }\n\t}\n\treturn 0;\n}\nvoid act(char *str) {\t\t\t\t\t\t\t\t\t\t//行動処理\n\twhile (*str != '\\0') {\n\t\tswitch (*str) {\n\t\tcase 'U':\n\t\t\tdir = 0;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdir = 1;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tdir = 2;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdir = 3;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tshot(dir);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t}\n}\nvoid move(int x) {\t\t\t\t\t\t\t\t\t\t\t//移動処理\n\tint sx = px + dirx[x], sy = py + diry[x], flag = 0;\n\tif (sx < 0 || sx >= w) { flag = 1; }\n\tif (sy < 0 || sy >= h) { flag = 1; }\n\tif (map[sy][sx] == '.' && flag == 0) {\n\t\tmap[py][px] = '.';\t\t\t\t\t\t\t\t\t//自分のいた場所を平地へ変更する\n\t\tpx = sx, py = sy;\t\t\t\t\t\t\t\t\t//座標を移動する\n\t}\n\tmap[py][px] = my[dir];\n}\nvoid shot(int x) {\t\t\t\t\t\t\t\t\t\t\t//砲弾処理\n\tint sx = px + dirx[x], sy = py + diry[x] , flag;\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t//移動可能な限り繰り返す\n\t\tflag = 0;\n\t\tif (sx < 0 || sx >= w) { break; }\t\t\t\t\t//幅の範囲外は見ない\n\t\tif (sy < 0 || sy >= h) { break; }\t\t\t\t\t//高さの範囲外は見ない\n\t\tswitch (map[sy][sx]) {\n\t\t\tcase '*':\t\t\t\t\t\t\t\t\t\t//レンガの壁の場合\n\t\t\t\tmap[sy][sx] = '.';\t\t\t\t\t\t\t//平地に変更する\n\t\t\t\tbreak;\n\t\t\tcase '#':\t\t\t\t\t\t\t\t\t\t//鉄の壁の場合\n\t\t\t\tbreak;\n\t\t\tdefault:\t\t\t\t\t\t\t\t\t\t//障害物以外の場合\n\t\t\t\tflag = 1;\t\t\t\t\t\t\t\t\t//繰り返す\n\t\t\t\tbreak;\n\t\t}\n\t\tsx += dirx[x];\n\t\tsy += diry[x];\n\t} while (flag != 0);\n}\nvoid format(int x, int y) {\n\tint i, j;\n\tfor (i = 0; i < x; i++) {\n\t\tfor (j = 0; j < y; j++) {\n\t\t\tmap[i][j] = '0';\n\t\t}\n\t}\n}\nvoid view(void) {\n\tint i, j;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tprintf(\"%c\", map[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(void){\n  int i,n,j,k,h,w,N,a=0,b=0; \n  char map[22][22],mapf[20][20],command[105];\n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++){\n    \n    //初期化\n    for(j=0;j<22;j++){\n      for(k=0;k<22;k++){\n\tmap[j][k]='#';\n      }\n    }\n    scanf(\"%d %d\",&h,&w);\n\n   //初期化\n    for(j=0;j<20;j++){\n      for(k=0;k<20;k++){\n\tmapf[j][k]='#';\n      }\n    }\n\n\n    for(j=0;j<h;j++){\n\tscanf(\"%s%*c\",mapf[j]);\n    }\n\n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tmap[j+1][k+1]=mapf[j][k];\n      }\n    }\n    //map 完成 以下命令\n\n    scanf(\"%d\",&N);\n    scanf(\"%s\",command);\n    /*for(j=0;j<N;j++){\n      printf(\"%c\",command[j]);\n    }\n    printf(\"\\n\");*/\n\n    //以下処理\n\n    //現在地把握\n    for(j=0;j<22;j++){\n      for(k=0;k<22;k++){\n\tif((map[j][k]=='^') || (map[j][k]=='v') ||( map[j][k]=='>') || (map[j][k]=='<')){\n\t  a=j;\n\t  b=k;\n\t  break;\n\t}\n      }\n     if(a!=0) break;\n    }\n   \n\n    for(j=0;j<N;j++){\n\t//上に移動\n      if(command[j]=='U'){\n\tif(map[a-1][b]=='.'){\n\t  map[a-1][b]='^';\n\t  map[a][b]='.';\n\t  a--;\n\t}else{\n\t  map[a][b]='^';\n\t}\n      }\n      //下に移動\n      if(command[j]=='D'){\n\tif(map[a+1][b]=='.'){\n\t  map[a+1][b]='v';\n\t  map[a][b]='.';\n\t  a++;\n\t}else{\n\t  map[a][b]='v';\n\t}\n      }\n      //左に移動\n      if(command[j]=='L'){\n\tif(map[a][b-1]=='.'){\n\t  map[a][b-1]='<';\n\t  map[a][b]='.';\n\t  b--;\n\t}else{\n\t  map[a][b]='<';\n\t}\n      }\n      //右に移動\n      if(command[j]=='R'){\n\tif(map[a][b+1]=='.'){\n\t  map[a][b+1]='>';\n\t  map[a][b]='.';\n\t  b++;\n\t}else{\n\t  map[a][b]='>';\n\t}\n\n      }\n\n      //ショットの処理\n      if(command[j]=='S'){\n\n\tif(map[a][b]=='^'){\n\t  for(k=a;;k--){\n\t    if(map[k][b]=='*'){\n\t      map[k][b]='.';\n\t      break;\n\t    }else if(map[k][b]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='v'){\n\t  for(k=a;;k++){\n\t    if(map[k][b]=='*'){\n\t      map[k][b]='.';\n\t      break;\n\t    }else if(map[k][b]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='>'){\n\t  for(k=b;;k++){\n\t    if(map[a][k]=='*'){\n\t      map[a][k]='.';\n\t      break;\n\t    }else if(map[a][k]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='<'){\n\t  for(k=b;;k--){\n\t    if(map[a][k]=='*'){\n\t      map[a][k]='.';\n\t      break;\n\t    }else if(map[a][k]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n      }\n    }\n\n    //以下出力    \n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tprintf(\"%c\",map[j+1][k+1]);\n      }\n      printf(\"\\n\");\n    }\n    if(j!=n-1) printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(void){\n  int i,n,j,k,h,w,N,a=0,b=0; \n  char map[22][22],mapf[20][20],command[105];\n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++){\n    \n    //初期化\n    for(j=0;j<22;j++){\n      for(k=0;k<22;k++){\n\tmap[j][k]='#';\n      }\n    }\n    scanf(\"%d %d\",&h,&w);\n\n   //初期化\n    for(j=0;j<20;j++){\n      for(k=0;k<20;k++){\n\tmapf[j][k]='#';\n      }\n    }\n\n\n    for(j=0;j<h;j++){\n\tscanf(\"%s%*c\",mapf[j]);\n    }\n\n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tmap[j+1][k+1]=mapf[j][k];\n      }\n    }\n    //map 完成 以下命令\n\n    scanf(\"%d\",&N);\n    scanf(\"%s\",command);\n    /*for(j=0;j<N;j++){\n      printf(\"%c\",command[j]);\n    }\n    printf(\"\\n\");*/\n\n    //以下処理\n\n    //現在地把握\n    for(j=0;j<22;j++){\n      for(k=0;k<22;k++){\n\tif((map[j][k]=='^') || (map[j][k]=='v') ||( map[j][k]=='>') || (map[j][k]=='<')){\n\t  a=j;\n\t  b=k;\n\t  break;\n\t}\n      }\n     if(a!=0) break;\n    }\n   \n\n    for(j=0;j<N;j++){\n\t//上に移動\n      if(command[j]=='U'){\n\tif(map[a-1][b]=='.'){\n\t  map[a-1][b]='^';\n\t  map[a][b]='.';\n\t  a--;\n\t}else{\n\t  map[a][b]='^';\n\t}\n      }\n      //下に移動\n      if(command[j]=='D'){\n\tif(map[a+1][b]=='.'){\n\t  map[a+1][b]='v';\n\t  map[a][b]='.';\n\t  a++;\n\t}else{\n\t  map[a][b]='v';\n\t}\n      }\n      //左に移動\n      if(command[j]=='L'){\n\tif(map[a][b-1]=='.'){\n\t  map[a][b-1]='<';\n\t  map[a][b]='.';\n\t  b--;\n\t}else{\n\t  map[a][b]='<';\n\t}\n      }\n      //右に移動\n      if(command[j]=='R'){\n\tif(map[a][b+1]=='.'){\n\t  map[a][b+1]='>';\n\t  map[a][b]='.';\n\t  b++;\n\t}else{\n\t  map[a][b]='>';\n\t}\n\n      }\n\n      //ショットの処理\n      if(command[j]=='S'){\n\n\tif(map[a][b]=='^'){\n\t  for(k=a;;k--){\n\t    if(map[k][b]=='*'){\n\t      map[k][b]='.';\n\t      break;\n\t    }else if(map[k][b]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='v'){\n\t  for(k=a;;k++){\n\t    if(map[k][b]=='*'){\n\t      map[k][b]='.';\n\t      break;\n\t    }else if(map[k][b]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='>'){\n\t  for(k=b;;k++){\n\t    if(map[a][k]=='*'){\n\t      map[a][k]='.';\n\t      break;\n\t    }else if(map[a][k]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='<'){\n\t  for(k=b;;k--){\n\t    if(map[a][k]=='*'){\n\t      map[a][k]='.';\n\t      break;\n\t    }else if(map[a][k]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n      }\n    }\n\n    //以下出力    \n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tprintf(\"%c\",map[j+1][k+1]);\n      }\n      printf(\"\\n\");\n    }\n    if(j!=N-1)　printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint width,height;\nchar map[20][21];\nint command_len;\nchar command[200];\n\nint main(void) {\n\tint d_num,c_data;\n\tint i,j;\n\tint x,y;\n\tscanf(\"%d\",&d_num);\n\tfor(c_data=0;c_data<d_num;c_data++) {\n\t\tscanf(\"%d%d\",&height,&width);\n\t\tfor(i=0;i<height;i++)scanf(\"%s\",map[i]);\n\t\tscanf(\"%d\",&command_len);\n\t\tscanf(\"%s\",command);\n\t\ti=1;\n\t\tfor(y=0;y<height && i;y++) {\n\t\t\tfor(x=0;x<width;x++) {\n\t\t\t\tif(map[y][x]=='^' || map[y][x]=='v' ||\n\t\t\t\t\t\tmap[y][x]=='<' || map[y][x]=='>') {\n\t\t\t\t\ti=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ty--;\n\t\tfor(i=0;i<command_len;i++) {\n\t\t\t/* if bug make RE */\n\t\t\tif(map[y][x]!='^' && map[y][x]!='v' &&\n\t\t\t\t\t\tmap[y][x]!='<' && map[y][x]!='>')return 1;\n\t\t\tswitch(command[i]) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tmap[y][x]='^';\n\t\t\t\t\tif(y>0 && map[y-1][x]=='.') {\n\t\t\t\t\t\tmap[y-1][x]='^';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tmap[y][x]='v';\n\t\t\t\t\tif(y<height-1 && map[y+1][x]=='.') {\n\t\t\t\t\t\tmap[y+1][x]='^';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tmap[y][x]='<';\n\t\t\t\t\tif(x>0 && map[y][x-1]=='.') {\n\t\t\t\t\t\tmap[y][x-1]='<';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tmap[y][x]='>';\n\t\t\t\t\tif(x<width-1 && map[y][x+1]=='.') {\n\t\t\t\t\t\tmap[y][x+1]='>';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tswitch(map[y][x]) {\n\t\t\t\t\t\tcase '^':\n\t\t\t\t\t\t\tfor(j=1;y-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y-j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y-j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y-j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tfor(j=1;y+j<height;j++) {\n\t\t\t\t\t\t\t\tif(map[y+j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y+j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y+j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\tfor(j=1;x-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x-j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x-j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x-j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tfor(j=1;x+j<width;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x+j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x+j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x+j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<height;i++)puts(map[i]);\n\t\tif(c_data<d_num-1)putchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(void){\n  int i,n,j,k,h,w,N,a=0,b=0; \n  char map[22][22],mapf[20][20],command[105];\n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++){\n    \n    //初期化\n    for(j=0;j<22;j++){\n      for(k=0;k<22;k++){\n\tmap[j][k]='#';\n      }\n    }\n    scanf(\"%d %d\",&h,&w);\n\n   //初期化\n    for(j=0;j<20;j++){\n      for(k=0;k<20;k++){\n\tmapf[j][k]='#';\n      }\n    }\n\n\n    for(j=0;j<h;j++){\n\tscanf(\"%s%*c\",mapf[j]);\n    }\n\n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tmap[j+1][k+1]=mapf[j][k];\n      }\n    }\n    //map 完成 以下命令\n\n    scanf(\"%d\",&N);\n    scanf(\"%s\",command);\n    /*for(j=0;j<N;j++){\n      printf(\"%c\",command[j]);\n    }\n    printf(\"\\n\");*/\n\n    //以下処理\n\n    //現在地把握\n    for(j=0;j<22;j++){\n      for(k=0;k<22;k++){\n\tif((map[j][k]=='^') || (map[j][k]=='v') ||( map[j][k]=='>') || (map[j][k]=='<')){\n\t  a=j;\n\t  b=k;\n\t  break;\n\t}\n      }\n     if(a!=0) break;\n    }\n   \n\n    for(j=0;j<N;j++){\n\t//上に移動\n      if(command[j]=='U'){\n\tif(map[a-1][b]=='.'){\n\t  map[a-1][b]='^';\n\t  map[a][b]='.';\n\t  a--;\n\t}else{\n\t  map[a][b]='^';\n\t}\n      }\n      //下に移動\n      if(command[j]=='D'){\n\tif(map[a+1][b]=='.'){\n\t  map[a+1][b]='v';\n\t  map[a][b]='.';\n\t  a++;\n\t}else{\n\t  map[a][b]='v';\n\t}\n      }\n      //左に移動\n      if(command[j]=='L'){\n\tif(map[a][b-1]=='.'){\n\t  map[a][b-1]='<';\n\t  map[a][b]='.';\n\t  b--;\n\t}else{\n\t  map[a][b]='<';\n\t}\n      }\n      //右に移動\n      if(command[j]=='R'){\n\tif(map[a][b+1]=='.'){\n\t  map[a][b+1]='>';\n\t  map[a][b]='.';\n\t  b++;\n\t}else{\n\t  map[a][b]='>';\n\t}\n\n      }\n\n      //ショットの処理\n      if(command[j]=='S'){\n\n\tif(map[a][b]=='^'){\n\t  for(k=a;;k--){\n\t    if(map[k][b]=='*'){\n\t      map[k][b]='.';\n\t      break;\n\t    }else if(map[k][b]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='v'){\n\t  for(k=a;;k++){\n\t    if(map[k][b]=='*'){\n\t      map[k][b]='.';\n\t      break;\n\t    }else if(map[k][b]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='>'){\n\t  for(k=b;;k++){\n\t    if(map[a][k]=='*'){\n\t      map[a][k]='.';\n\t      break;\n\t    }else if(map[a][k]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='<'){\n\t  for(k=b;;k--){\n\t    if(map[a][k]=='*'){\n\t      map[a][k]='.';\n\t      break;\n\t    }else if(map[a][k]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n      }\n    }\n\n    //以下出力    \n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tprintf(\"%c\",map[j+1][k+1]);\n      }\n      printf(\"\\n\");\n    }\n    if(j!=N-1) printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2103 \n  Title:Battle Town\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\n\nint T,H,W,N;\nint py,px;   //position\nchar map[20][21];\nchar map2[20][21];\nchar op[101];\nint dir;\nint diffx[4]={1,0,-1,0};\nint diffy[4]={0,-1,0,1};\nchar sensha[4]=\">^<v\";\n\nint in_range(int y,int x)\n{\n        return(y>=0 && y<H && x>=0 && x<W);\n}\nvoid dispatch(char ins)\n{\n        int dx,dy;\n\n        if(ins=='U')\n        {\n                dir=1;\n                if(py>0   && map[py-1][px]=='.')\n                        py--;\n        }\n        if(ins=='D')\n        {\n                dir=3;\n                if(py<H-1 && map[py+1][px]=='.')\n                        py++;\n        }\n        if(ins=='L')\n        {\n                dir=2;\n                if(px>0   && map[py][px-1]=='.')\n                        px--;\n        }\n        if(ins=='R')\n        {\n                dir=0;\n                if(px<H-1 && map[py][px+1]=='.')\n                        px++;\n        }\n        if(ins=='S')\n        {\n                dy=py;dx=px;\n                while(in_range(dy,dx) && (map[dy][dx]=='.' || map[dy][dx]=='-'))\n                {\n                        dy+=diffy[dir];\n                        dx+=diffx[dir];\n                        //printf(\"DYX=%d %d\\n\",dy,dx);\n                }\n                if(in_range(dy,dx) && map[dy][dx]=='*')\n                        map[dy][dx]='.';\n        }\n}\nvoid write_map(int cr)\n{\n        int i;\n        \n        memcpy(map2,map,20*21);\n        map2[py][px]=sensha[dir];\n\n        for(i=0;i<H;i++)\n                printf(\"%s\\n\",&map2[i][0]);\n\n        if(cr)\n                printf(\"\\n\");\n}\nint search_pos(int * y,int * x)\n{\n        int i,j;\n        char *p;\n\n        for(i=0;i<H;i++)\n                for(j=0;j<W;j++)\n                        if((p=strchr(sensha,map[i][j])))\n                        {\n                                *y=i;*x=j;return(p-sensha);\n                        }\n        return(-1);\n}\nvoid solve()\n{\n        int i;\n        char ins;\n\n        dir=search_pos(&py,&px);\n\n        //printf(\"YX=%d %d (%d)\\n\",py,px,dir);\n\n        map[py][px]='.';\n\n        for(i=0;i<N;i++)\n        {\n                write_map(1);\n                ins=op[i];\n                printf(\"INS=%c\\n\",ins);\n                dispatch(ins);\n        }\n}\nmain()\n{\n        int i,j,ret;\n\n        scanf(\"%d\",&T);\n        for(i=0;i<T;i++)\n        {\n                scanf(\"%d %d\",&H,&W);\n                for(j=0;j<H;j++)\n                        scanf(\"%s\",&map[j][0]);\n                scanf(\"%d\",&N);\n                scanf(\"%s\",&op[0]);\n                solve();\n                write_map((i<T-1));\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nchar map[22][22];\n\nchar ctodir(int dir){\n  return dir==0?'^':dir==1?'>':dir==2?'v':'<';\n}\nint dtoc(char ch){\n  return ch=='^'?0:ch=='>'?1:ch=='v'?2:3;\n}\nint main(){\n  int i,j,pc,x,y,h,w,k,clen,dir,dc[4][2]={{-1,0},{0,1},{1,0},{0,-1}},cx,cy;\n  char found,cmd[101],c;\n  for(i=0;i<22;i++)\n    map[0][i]=map[i][0]='\\0';\n  scanf(\"%d\",&pc);\n  \n  for(i=0;i<pc;i++){\n    scanf(\"%d %d\",&h,&w);\n    for(j=0,found=0;j<h;j++){\n      scanf(\"%s\",&(map[j+1][1]));\n      for(k=0;k<w;k++){\n\tif(!found&&(map[j+1][k+1]=='<'||map[j+1][k+1]=='>'||map[j+1][k+1]=='^'\n\t\t    ||map[j+1][k+1]=='v')){\n\t  x=k+1;\n\t  y=j+1;\n\t  found=1;\n\t  dir=dtoc(map[j+1][k+1]);\n\t  break;\n\t}\n      }\n    }\n    for(j=0;j<w;j++) map[h+1][j+1]='\\0';\n    for(j=0;j<h;j++) map[w+1][j+1]='\\0';\n    scanf(\"%d\",&clen);\n    scanf(\"%s\",cmd);\n    for(j=0;j<clen;j++){\n      if(cmd[j]=='S'){\n\tfor(cx=x+dc[dir][1],cy=y+dc[dir][0];\n\t    map[cy][cx];\n\t    cx+=dc[dir][1],cy+=dc[dir][0]){\n\t  if(map[cy][cx]=='#'){\n\t    break;\n\t  }else if(map[cy][cx]=='*'){\n\t    map[cy][cx]='.';\n\t    break;\n\t  }\n\t}\n      }else{\n\tdir=cmd[j]=='U'?0:cmd[j]=='R'?1:cmd[j]=='D'?2:3;\n\tif(map[y+dc[dir][0]][x+dc[dir][1]]=='.'){\n\t  map[y+dc[dir][0]][x+dc[dir][1]]=ctodir(dir);\n\t  map[y][x]='.';\n\t  y+=dc[dir][0];\n\t  x+=dc[dir][1];\n\t}else{\n\t  map[y][x]=ctodir(dir);\n\t}\n      }\n    }\n    for(j=0;j<h;j++)\n      printf(\"%s\\n\",map[j+1]+1);\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint width,height;\nchar map[20][21];\nint command_len;\nchar command[200];\n\nint main(void) {\n\tint d_num,c_data;\n\tint i,j;\n\tint x,y;\n\tscanf(\"%d\",&d_num);\n\tfor(c_data=0;c_data<d_num;c_data++) {\n\t\tscanf(\"%d%d\",&height,&width);\n\t\tfor(i=0;i<height;i++)scanf(\"%s\",map[i]);\n\t\tscanf(\"%d\",&command_len);\n\t\tscanf(\"%s\",command);\n\t\tx=y=-1;\n\t\tfor(i=0;i<height;i++) {\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tif(map[i][j]=='^' || map[i][j]=='v' ||\n\t\t\t\t\t\tmap[i][j]=='<' || map[i][j]=='>') {\n\t\t\t\t\ty=i;x=j;\n\t\t\t\t\ti=height;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x<0 || y<0)return 1;\n\t\tfor(i=0;i<command_len;i++) {\n\t\t\tswitch(command[i]) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tmap[y][x]='^';\n\t\t\t\t\tif(y>0 && map[y-1][x]=='.') {\n\t\t\t\t\t\tmap[y-1][x]='^';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tmap[y][x]='v';\n\t\t\t\t\tif(y<height-1 && map[y+1][x]=='.') {\n\t\t\t\t\t\tmap[y+1][x]='^';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tmap[y][x]='<';\n\t\t\t\t\tif(x>0 && map[y][x-1]=='.') {\n\t\t\t\t\t\tmap[y][x-1]='<';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tmap[y][x]='>';\n\t\t\t\t\tif(x<width-1 && map[y][x+1]=='.') {\n\t\t\t\t\t\tmap[y][x+1]='>';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tswitch(map[y][x]) {\n\t\t\t\t\t\tcase '^':\n\t\t\t\t\t\t\tfor(j=0;y-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y-j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y-j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y-j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tfor(j=0;y+j<height;j++) {\n\t\t\t\t\t\t\t\tif(map[y+j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y+j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y+j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\tfor(j=0;x-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x-j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x-j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x-j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tfor(j=0;x+j<width;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x+j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x+j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x+j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<height;i++)puts(map[i]);\n\t\tif(c_data<d_num-1)putchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nchar map[20][21];\nint command_len;\nchar command[200];\n\nint main(void) {\n\tint d_num,c_data;\n\tint i,j;\n\tint x,y;\n\tscanf(\"%d\",&d_num);\n\tfor(c_data=0;c_data<d_num;c_data++) {\n\t\tscanf(\"%d%d\",&height,&width);\n\t\tfor(i=0;i<height;i++)scanf(\"%s\",map[i]);\n\t\tscanf(\"%d\",&command_len);\n\t\tscanf(\"%s\",command);\n\t\tx=y=-1;\n\t\tfor(i=0;i<height;i++) {\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tif(map[i][j]=='^' || map[i][j]=='v' ||\n\t\t\t\t\t\tmap[i][j]=='<' || map[i][j]=='>') {\n\t\t\t\t\ty=i;x=j;\n\t\t\t\t\ti=height;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(strlen(command)!=command_len)return 1;/* detect bug */\n\t\tif(x<0 || y<0)return 1;\n\t\tfor(i=0;i<command_len;i++) {\n\t\t\tswitch(command[i]) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tmap[y][x]='^';\n\t\t\t\t\tif(y>0 && map[y-1][x]=='.') {\n\t\t\t\t\t\tmap[y-1][x]='^';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tmap[y][x]='v';\n\t\t\t\t\tif(y<height-1 && map[y+1][x]=='.') {\n\t\t\t\t\t\tmap[y+1][x]='^';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tmap[y][x]='<';\n\t\t\t\t\tif(x>0 && map[y][x-1]=='.') {\n\t\t\t\t\t\tmap[y][x-1]='<';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tmap[y][x]='>';\n\t\t\t\t\tif(x<width-1 && map[y][x+1]=='.') {\n\t\t\t\t\t\tmap[y][x+1]='>';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tswitch(map[y][x]) {\n\t\t\t\t\t\tcase '^':\n\t\t\t\t\t\t\tfor(j=0;y-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y-j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y-j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y-j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tfor(j=0;y+j<height;j++) {\n\t\t\t\t\t\t\t\tif(map[y+j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y+j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y+j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\tfor(j=0;x-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x-j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x-j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x-j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tfor(j=0;x+j<width;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x+j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x+j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x+j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<height;i++)puts(map[i]);\n\t\tif(c_data<d_num-1)putchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nchar map[22][22];\n\nchar ctodir(int dir){\n  return dir==0?'^':dir==1?'>':dir==2?'v':'<';\n}\nint dtoc(char ch){\n  return ch=='^'?0:ch=='>'?1:ch=='v'?2:3;\n}\nint main(){\n  int i,j,pc,x,y,h,w,k,clen,dir,dc[4][2]={{-1,0},{0,1},{1,0},{0,-1}},cx,cy;\n  char found,cmd[101],c;\n  for(i=0;i<22;i++)\n    map[0][i]=map[i][0]='\\0';\n  scanf(\"%d\",&pc);\n  \n  for(i=0;i<pc;i++){\n    scanf(\"%d %d\",&h,&w);\n    for(j=0,found=0;j<h;j++){\n      scanf(\"%s\",&(map[j+1][1]));\n      for(k=0;k<w;k++){\n\tif(!found&&(map[j+1][k+1]=='<'||map[j+1][k+1]=='>'||map[j+1][k+1]=='^'\n\t\t    ||map[j+1][k+1]=='v')){\n\t  x=k+1;\n\t  y=j+1;\n\t  found=1;\n\t  dir=dtoc(map[j+1][k+1]);\n\t  break;\n\t}\n      }\n    }\n    for(j=0;j<w;j++) map[h+1][j+1]='\\0';\n    for(j=0;j<h;j++) map[w+1][j+1]='\\0';\n    scanf(\"%d\",&clen);\n    scanf(\"%s\",cmd);\n    for(j=0;j<clen;j++){\n      if(cmd[j]=='S'){\n\tfor(cx=x+dc[dir][1],cy=y+dc[dir][0];\n\t    map[cy][cx];\n\t    cx+=dc[dir][1],cy+=dc[dir][0]){\n\t  if(map[cy][cx]=='#'){\n\t    break;\n\t  }else if(map[cy][cx]=='*'){\n\t    map[cy][cx]='.';\n\t    break;\n\t  }\n\t}\n      }else{\n\tdir=cmd[j]=='U'?0:cmd[j]=='R'?1:cmd[j]=='D'?2:3;\n\tif(map[y+dc[dir][0]][x+dc[dir][1]]=='.'){\n\t  map[y+dc[dir][0]][x+dc[dir][1]]=ctodir(dir);\n\t  map[y][x]='.';\n\t  y+=dc[dir][0];\n\t  x+=dc[dir][1];\n\t}else{\n\t  map[y][x]=ctodir(dir);\n\t}\n      }\n    }\n    for(j=0;j<h-1;j++)\n      printf(\"%s\\n\",map[j+1]+1);\n    printf(\"%s\",map[j+1]+1);\n    if(i+1<pc) printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2103 \n  Title:Battle Town\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\n\nint T,H,W,N;\nint py,px;   //position\nchar map[20][21];\nchar map2[20][21];\nchar op[101];\nint dir;\nint diffx[4]={1,0,-1,0};\nint diffy[4]={0,-1,0,1};\nchar sensha[4]=\">^<v\";\n\nint in_range(int y,int x)\n{\n        return(y>=0 && y<H && x>=0 && x<W);\n}\nvoid dispatch(char ins)\n{\n        int dx,dy;\n\n        if(ins=='U')\n        {\n                dir=1;\n                if(py>0   && map[py-1][px]=='.')\n                        py--;\n        }\n        if(ins=='D')\n        {\n                dir=3;\n                if(py<H-1 && map[py+1][px]=='.')\n                        py++;\n        }\n        if(ins=='L')\n        {\n                dir=2;\n                if(px>0   && map[py][px-1]=='.')\n                        px--;\n        }\n        if(ins=='R')\n        {\n                dir=0;\n                if(px<W-1 && map[py][px+1]=='.')\n                        px++;\n        }\n        if(ins=='S')\n        {\n                dy=py;dx=px;\n                while(in_range(dy,dx) && (map[dy][dx]=='.' || map[dy][dx]=='-'))\n                {\n                        dy+=diffy[dir];\n                        dx+=diffx[dir];\n                        //printf(\"DYX=%d %d\\n\",dy,dx);\n                }\n                if(in_range(dy,dx) && map[dy][dx]=='*')\n                        map[dy][dx]='.';\n        }\n}\nvoid write_map(int cr)\n{\n        int i;\n        \n        memcpy(map2,map,20*21);\n        map2[py][px]=sensha[dir];\n\n        for(i=0;i<H;i++)\n                printf(\"%s\\n\",&map2[i][0]);\n\n        if(cr)\n                printf(\"\\n\");\n}\nint search_pos(int * y,int * x)\n{\n        int i,j;\n        char *p;\n\n        for(i=0;i<H;i++)\n                for(j=0;j<W;j++)\n                        if((p=strchr(sensha,map[i][j])))\n                        {\n                                *y=i;*x=j;return(p-sensha);\n                        }\n        return(-1);\n}\nvoid solve()\n{\n        int i;\n        char ins;\n\n        dir=search_pos(&py,&px);\n\n        //printf(\"YX=%d %d (%d)\\n\",py,px,dir);\n\n        map[py][px]='.';\n\n        for(i=0;i<N;i++)\n        {\n                write_map(1);\n                ins=op[i];\n                printf(\"INS=%c\\n\",ins);\n                dispatch(ins);\n        }\n}\nmain()\n{\n        int i,j,ret;\n\n        scanf(\"%d\",&T);\n        for(i=0;i<T;i++)\n        {\n                scanf(\"%d %d\",&H,&W);\n                for(j=0;j<H;j++)\n                        scanf(\"%s\",&map[j][0]);\n                scanf(\"%d\",&N);\n                scanf(\"%s\",&op[0]);\n                solve();\n                write_map((i<T-1));\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nchar map[22][22];\n\nchar ctodir(int dir){\n  return dir==0?'^':dir==1?'>':dir==2?'v':'<';\n}\nint dtoc(char ch){\n  return ch=='^'?0:ch=='>'?1:ch=='v'?2:3;\n}\nint main(){\n  int i,j,pc,x,y,h,w,k,clen,dir,dc[4][2]={{-1,0},{0,1},{1,0},{0,-1}},cx,cy;\n  char found,cmd[101],c;\n  for(i=0;i<22;i++)\n    map[0][i]=map[i][0]='\\0';\n  scanf(\"%d\",&pc);\n  \n  for(i=0;i<pc;i++){\n    scanf(\"%d %d\",&h,&w);\n    for(j=0,found=0;j<h;j++){\n      scanf(\"%s\",&(map[j+1][1]));\n      if(!found){\n\tfor(k=0;k<w;k++){\n\t  if(!found&&(map[j+1][k+1]=='<'||map[j+1][k+1]=='>'||map[j+1][k+1]=='^'\n\t\t      ||map[j+1][k+1]=='v')){\n\t    x=k+1;\n\t    y=j+1;\n\t    found=1;\n\t    dir=dtoc(map[j+1][k+1]);\n\t    break;\n\t  }\n\t}\n      }\n    }\n    for(j=0;j<w+1;j++) map[h+1][j+1]='\\0';\n    for(j=0;j<h;j++) map[w+1][j+1]='\\0';\n    scanf(\"%d\",&clen);\n    scanf(\"%s\",cmd);\n    for(j=0;j<clen;j++){\n      if(cmd[j]=='S'){\n\tfor(cx=x+dc[dir][1],cy=y+dc[dir][0];\n\t    map[cy][cx];\n\t    cx+=dc[dir][1],cy+=dc[dir][0]){\n\t  if(map[cy][cx]=='#'){\n\t    break;\n\t  }else if(map[cy][cx]=='*'){\n\t    map[cy][cx]='.';\n\t    break;\n\t  }\n\t}\n      }else{\n\tdir=cmd[j]=='U'?0:cmd[j]=='R'?1:cmd[j]=='D'?2:3;\n\tif(map[y+dc[dir][0]][x+dc[dir][1]]=='.'){\n\t  map[y+dc[dir][0]][x+dc[dir][1]]=ctodir(dir);\n\t  map[y][x]='.';\n\t  y+=dc[dir][0];\n\t  x+=dc[dir][1];\n\t}else{\n\t  map[y][x]=ctodir(dir);\n\t}\n      }\n    }\n    for(j=0;j<h-1;j++)\n      printf(\"%s\\n\",map[j+1]+1);\n    printf(\"%s\",map[j+1]+1);\n    if(i+1<pc) printf(\"\\n\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[20][21];\t\t\t\t\t\t\t\t\t\t\t//高さ * 幅\nint h, w;\t\t\t\t\t\t\t\t\t\t\t\t\t//マップの高さ、幅\nint px, py, dir = 0;\t\t\t\t\t\t\t\t\t\t//自分の座標、方向\nint dirx[4] = { 0,0,-1,1 };\nint diry[4] = { -1,1,0,0 };\nchar my[4] = { '^', 'v', '<', '>' };\n\nvoid act(char *n);\nvoid move(int x);\nvoid shot(int x);\nvoid format(int x, int y);\nvoid view(void);\n\nint main(void) {\n\tformat(20, 20);\n\tint i, j, k;\n\tint data;\t\t\t\t\t\t\t\t\t\t\t\t//繰り返し回数\n\tint nmax;\t\t\t\t\t\t\t\t\t\t\t\t//操作列の長さ\n\tchar n[101];\t\t\t\t\t\t\t\t\t\t\t//操作列の格納用\n\tscanf(\"%d\\n\", &data);\t\t\t\t\t\t\t\t\t//繰り返し回数の取得\n\tfor (k = 0; k < data; k++) {\n\t\tscanf(\"%d %d\\n\", &h, &w);\t\t\t\t\t\t\t//高さと幅の取得\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tmap[i][j] = getchar();\n\t\t\t\tif (map[i][j] == '^') { px = j, py = i, dir = 0; }\n\t\t\t\tif (map[i][j] == 'v') { px = j, py = i, dir = 1; }\n\t\t\t\tif (map[i][j] == '<') { px = j, py = i, dir = 2; }\n\t\t\t\tif (map[i][j] == '>') { px = j, py = i, dir = 3; }\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d\\n\", &nmax);\t\t\t\t\t\t\t\t//操作列の長さの取得\n\t\tif (nmax < 0) { nmax = 0; }\n\t\tif (nmax > 100) { nmax = 100; }\n\t\tfor (i = 0; i < nmax; i++) {\t\t\t\t\t\t//操作列の取得\n\t\t\tn[i] = getchar();\n\t\t}\n\t\tn[i] = '\\0';\n\t\tact(&n[0]);\t\t\t\t\t\t\t\t\t\t\t//行動処理\n\t\tview();\t\t\t\t\t\t\t\t\t\t\t\t//結果の表示\n\t\tif (k != data) { printf(\"\\n\"); }\n\t}\n\treturn 0;\n}\nvoid act(char *str) {\t\t\t\t\t\t\t\t\t\t//行動処理\n\twhile (*str != '\\0') {\n\t\tswitch (*str) {\n\t\tcase 'U':\n\t\t\tdir = 0;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdir = 1;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tdir = 2;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdir = 3;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tshot(dir);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t}\n}\nvoid move(int x) {\t\t\t\t\t\t\t\t\t\t\t//移動処理\n\tint sx = px + dirx[x], sy = py + diry[x], flag = 0;\n\tif (sx < 0 || sx >= w) { flag = 1; }\n\tif (sy < 0 || sy >= h) { flag = 1; }\n\tif (map[sy][sx] == '.' && flag == 0) {\n\t\tmap[py][px] = '.';\t\t\t\t\t\t\t\t\t//自分のいた場所を平地へ変更する\n\t\tpx = sx, py = sy;\t\t\t\t\t\t\t\t\t//座標を移動する\n\t}\n\tmap[py][px] = my[dir];\n}\nvoid shot(int x) {\t\t\t\t\t\t\t\t\t\t\t//砲弾処理\n\tint sx = px + dirx[x], sy = py + diry[x] , flag;\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t//移動可能な限り繰り返す\n\t\tflag = 0;\n\t\tif (sx < 0 || sx >= w) { break; }\t\t\t\t\t//幅の範囲外は見ない\n\t\tif (sy < 0 || sy >= h) { break; }\t\t\t\t\t//高さの範囲外は見ない\n\t\tswitch (map[sy][sx]) {\n\t\t\tcase '*':\t\t\t\t\t\t\t\t\t\t//レンガの壁の場合\n\t\t\t\tmap[sy][sx] = '.';\t\t\t\t\t\t\t//平地に変更する\n\t\t\t\tbreak;\n\t\t\tcase '#':\t\t\t\t\t\t\t\t\t\t//鉄の壁の場合\n\t\t\t\tbreak;\n\t\t\tdefault:\t\t\t\t\t\t\t\t\t\t//障害物以外の場合\n\t\t\t\tflag = 1;\t\t\t\t\t\t\t\t\t//繰り返す\n\t\t\t\tbreak;\n\t\t}\n\t\tsx += dirx[x];\n\t\tsy += diry[x];\n\t} while (flag != 0);\n}\nvoid format(int x, int y) {\n\tint i, j;\n\tfor (i = 0; i < x; i++) {\n\t\tfor (j = 0; j < y; j++) {\n\t\t\tmap[i][j] = '0';\n\t\t}\n\t}\n}\nvoid view(void) {\n\tint i, j;\n\tprintf(\"\\n\");\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tprintf(\"%c\", map[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n//\tprintf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[20][21];\t\t\t\t\t\t\t\t\t\t\t//高さ * 幅\nint h, w;\t\t\t\t\t\t\t\t\t\t\t\t\t//マップの高さ、幅\nint px, py, dir = 0;\t\t\t\t\t\t\t\t\t\t//自分の座標、方向\nint dirx[4] = { 0,0,-1,1 };\nint diry[4] = { -1,1,0,0 };\nchar my[4] = { '^', 'v', '<', '>' };\n\nvoid act(char *n);\nvoid move(int x);\nvoid shot(int x);\nvoid format(int x, int y);\nvoid view(void);\n\nint main(void) {\n\tformat(20, 20);\n\tint i, j, k;\n\tint data;\t\t\t\t\t\t\t\t\t\t\t\t//繰り返し回数\n\tint nmax;\t\t\t\t\t\t\t\t\t\t\t\t//操作列の長さ\n\tchar n[101];\t\t\t\t\t\t\t\t\t\t\t//操作列の格納用\n\tscanf(\"%d\\n\", &data);\t\t\t\t\t\t\t\t\t//繰り返し回数の取得\n\tfor (k = 0; k < data; k++) {\n\t\tscanf(\"%d %d\\n\", &h, &w);\t\t\t\t\t\t\t//高さと幅の取得\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tmap[i][j] = getchar();\n\t\t\t\tif (map[i][j] == '^') { px = j, py = i, dir = 0; }\n\t\t\t\tif (map[i][j] == 'v') { px = j, py = i, dir = 1; }\n\t\t\t\tif (map[i][j] == '<') { px = j, py = i, dir = 2; }\n\t\t\t\tif (map[i][j] == '>') { px = j, py = i, dir = 3; }\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d\\n\", &nmax);\t\t\t\t\t\t\t\t//操作列の長さの取得\n\t\tif (nmax < 0) { nmax = 0; }\n\t\tif (nmax > 100) { nmax = 100; }\n\t\tfor (i = 0; i < nmax; i++) {\t\t\t\t\t\t//操作列の取得\n\t\t\tn[i] = getchar();\n\t\t}\n\t\tn[i] = '\\0';\n\t\tact(&n[0]);\t\t\t\t\t\t\t\t\t\t\t//行動処理\n\t\tview();\t\t\t\t\t\t\t\t\t\t\t\t//結果の表示\n\t}\n\treturn 0;\n}\nvoid act(char *str) {\t\t\t\t\t\t\t\t\t\t//行動処理\n\twhile (*str != '\\0') {\n\t\tswitch (*str) {\n\t\tcase 'U':\n\t\t\tdir = 0;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdir = 1;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tdir = 2;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdir = 3;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tshot(dir);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t}\n}\nvoid move(int x) {\t\t\t\t\t\t\t\t\t\t\t//移動処理\n\tint sx = px + dirx[x], sy = py + diry[x], flag = 0;\n\tif (sx < 0 || sx >= w) { flag = 1; }\n\tif (sy < 0 || sy >= h) { flag = 1; }\n\tif (map[sy][sx] == '.' && flag == 0) {\n\t\tmap[py][px] = '.';\t\t\t\t\t\t\t\t\t//自分のいた場所を平地へ変更する\n\t\tpx = sx, py = sy;\t\t\t\t\t\t\t\t\t//座標を移動する\n\t}\n\tmap[py][px] = my[dir];\n}\nvoid shot(int x) {\t\t\t\t\t\t\t\t\t\t\t//砲弾処理\n\tint sx = px + dirx[x], sy = py + diry[x] , flag;\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t//移動可能な限り繰り返す\n\t\tflag = 0;\n\t\tif (sx < 0 || sx >= w) { break; }\t\t\t\t\t//幅の範囲外は見ない\n\t\tif (sy < 0 || sy >= h) { break; }\t\t\t\t\t//高さの範囲外は見ない\n\t\tswitch (map[sy][sx]) {\n\t\t\tcase '*':\t\t\t\t\t\t\t\t\t\t//レンガの壁の場合\n\t\t\t\tmap[sy][sx] = '.';\t\t\t\t\t\t\t//平地に変更する\n\t\t\t\tbreak;\n\t\t\tcase '#':\t\t\t\t\t\t\t\t\t\t//鉄の壁の場合\n\t\t\t\tbreak;\n\t\t\tdefault:\t\t\t\t\t\t\t\t\t\t//障害物以外の場合\n\t\t\t\tflag = 1;\t\t\t\t\t\t\t\t\t//繰り返す\n\t\t\t\tbreak;\n\t\t}\n\t\tsx += dirx[x];\n\t\tsy += diry[x];\n\t} while (flag != 0);\n}\nvoid format(int x, int y) {\n\tint i, j;\n\tfor (i = 0; i < x; i++) {\n\t\tfor (j = 0; j < y; j++) {\n\t\t\tmap[i][j] = '0';\n\t\t}\n\t}\n}\nvoid view(void) {\n\tint i, j;\n\tprintf(\"\\n\");\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tprintf(\"%c\", map[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint h, w;\nchar map[21][21];\nint d, x, y;\n\nvoid koudou(char);\n\nmain(){\n  int t, i, j, k, n, f=0, l;\n  char temp;\n  \n  scanf(\"%d\", &t);\n  \n  for(i=0;i<t;i++){\n    if(f==1) printf(\"\\n\");\n    scanf(\"%d %d\", &h, &w);\n    getchar();\n    \n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tscanf(\"%c\", &map[j][k]);\n\tif(map[j][k]=='^'){\n\t  y=j;\n\t  x=k;\n\t  d=0;\n\t}\n\telse if(map[j][k]=='>'){\n\t  y=j;\n\t  x=k;\n\t  d=1;\n\t}\n\telse if(map[j][k]=='v'){\n\t  y=j;\n\t  x=k;\n\t  d=2;\n\t}\n\telse if(map[j][k]=='<'){\n\t  y=j;\n\t  x=k;\n\t  d=3;\n\t}\n      }\n      getchar();\n    }\n    scanf(\"%d\", &n);\n    getchar();\n    \n    for(j=0;j<n;j++){\n      scanf(\"%c\", &temp);\n      koudou(temp);\n    }\n\n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tprintf(\"%c\", map[j][k]);\n      }\n      printf(\"\\n\");\n    }\n    \n    f=1;\n  }\n  return 0;\n}\n\n\nvoid koudou(char a){\n  int i, j, k, ty, tx;\n  \n  if(a=='U'){\n    d=0;\n    map[y][x]='.';\n    ty=y-1;\n    tx=x;\n    if(ty>=0 && ty<h && tx>=0 && tx<w){\n      if(map[ty][tx]=='.'){\n\ty=ty;\n\tx=tx;\n      }\n    }\n    map[y][x]='^';\n  }\n  \n  else if(a=='R'){\n    d=1;\n    map[y][x]='.';\n    ty=y;\n    tx=x+1;\n    if(ty>=0 && ty<h && tx>=0 && tx<w){\n      if(map[ty][tx]=='.'){\n\ty=ty;\n\tx=tx;\n      }\n    }\n    map[y][x]='>';\n  }\n  \n  else if(a=='D'){\n    d=2;\n    map[y][x]='.';\n    ty=y+1;\n    tx=x;\n    if(ty>=0 && ty<h && tx>=0 && tx<w){\n      if(map[ty][tx]=='.'){\n\ty=ty;\n\tx=tx;\n      }\n    }\n    map[y][x]='v';\n  }\n  \n  else if(a=='L'){\n    d=3;\n    map[y][x]='.';\n    ty=y;\n    tx=x-1;\n    if(ty>=0 && ty<h && tx>=0 && tx<w){\n      if(map[ty][tx]=='.'){\n\ty=ty;\n\tx=tx;\n      }\n    }\n    map[y][x]='<';\n  }\n  \n  else if(a=='S'){\n    ty=y;\n    tx=x;\n    while(1){\n      if(d==0){\n\tty--;\n\tif(ty<0 || ty>=h || tx<0 || tx>=w) break;\n\tif(map[ty][tx]=='#') break;\n\tif(map[ty][tx]=='*'){\n\t  map[ty][tx]='.';\n\t  break;\n\t}\n      }\n      \n      else if(d==1){\n\ttx++;\n\tif(ty<0 || ty>=h || tx<0 || tx>=w) break;\n\tif(map[ty][tx]=='#') break;\n\tif(map[ty][tx]=='*'){\n\t  map[ty][tx]='.';\n\t  break;\n\t}\n      }\n      \n      else if(d==2){\n\tty++;\n\tif(ty<0 || ty>=h || tx<0 || tx>=w) break;\n\tif(map[ty][tx]=='#') break;\n\tif(map[ty][tx]=='*'){\n\t  map[ty][tx]='.';\n\t  break;\n\t}\n      }\n      \n      else if(d==3){\n\ttx--;\n\tif(ty<0 || ty>=h || tx<0 || tx>=w) break;\n\tif(map[ty][tx]=='#') break;\n\tif(map[ty][tx]=='*'){\n\t  map[ty][tx]='.';\n\t  break;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,k,ny,nx,w,h,d,y,x;\n  int Y[]={-1,0,1,0};\n  int X[]={0,1,0,-1};\n  char c,s[4]={\"^>v<\"};\n  scanf(\"%d\",&n);\n  while(n--){\n   char m[22][22]={0};\n   d=4;\n   scanf(\"%d %d\",&h,&w);\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&m[i][j]);\n\tif(d==4){\n\t  for(d=0;d<4;d++){\n\t    if(m[i][j]==s[d])break;\n\t  }\n\t  if(d-4)m[y=i][x=j]='.';\n\t}//printf(\"%d \",d);\n      }\n    }\n    scanf(\"%d\",&k);\n    while(k--){\n      scanf(\" %c\",&c);//printf(\"%d\\n\",d);\n      if(c=='U')d=0;\n      if(c=='R')d=1;\n      if(c=='D')d=2;\n      if(c=='L')d=3;\n      if(c=='S'){\n\tfor(i=1;1;i++){\n\t  nx=x+X[d]*i;\n\t  ny=y+Y[d]*i;\n\t  if(m[ny][nx]=='#'||m[ny][nx]==0)break;\n\t  if(m[ny][nx]=='*'){\n\t    m[ny][nx]='.';\n\t    break;\n\t  }\n\t}//printf(\"i%d\\n\",i);\n      }\n      else{\n\tnx=x+X[d];\n\tny=y+Y[d];\n\tif(m[ny][nx]=='.'){\n\t  y=ny;\n\t  x=nx;\n\t}\n      }\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(i==y&&j==x)printf(\"%c\",s[d]);\n\telse printf(\"%c\",m[i][j]);\n      }\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(void){\n  int i,n,j,k,h,w,N,a=0,b=0; \n  char map[22][22],mapf[20][20],command[105];\n  scanf(\"%d\",&n);\n  \n  for(i=0;i<n;i++){\n    \n    //初期化\n    for(j=0;j<22;j++){\n      for(k=0;k<22;k++){\n\tmap[j][k]='#';\n      }\n    }\n    scanf(\"%d %d\",&h,&w);\n\n   //初期化\n    for(j=0;j<20;j++){\n      for(k=0;k<20;k++){\n\tmapf[j][k]='#';\n      }\n    }\n\n\n    for(j=0;j<h;j++){\n\tscanf(\"%s%*c\",mapf[j]);\n    }\n\n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tmap[j+1][k+1]=mapf[j][k];\n      }\n    }\n    //map 完成 以下命令\n\n    scanf(\"%d\",&N);\n    scanf(\"%s\",command);\n    /*for(j=0;j<N;j++){\n      printf(\"%c\",command[j]);\n    }\n    printf(\"\\n\");*/\n\n    //以下処理\n\n    //現在地把握\n    for(j=0;j<22;j++){\n      for(k=0;k<22;k++){\n\tif((map[j][k]=='^') || (map[j][k]=='v') ||( map[j][k]=='>') || (map[j][k]=='<')){\n\t  a=j;\n\t  b=k;\n\t  break;\n\t}\n      }\n     if(a!=0) break;\n    }\n   \n\n    for(j=0;j<N;j++){\n\t//上に移動\n      if(command[j]=='U'){\n\tif(map[a-1][b]=='.'){\n\t  map[a-1][b]='^';\n\t  map[a][b]='.';\n\t  a--;\n\t}else{\n\t  map[a][b]='^';\n\t}\n      }\n      //下に移動\n      if(command[j]=='D'){\n\tif(map[a+1][b]=='.'){\n\t  map[a+1][b]='v';\n\t  map[a][b]='.';\n\t  a++;\n\t}else{\n\t  map[a][b]='v';\n\t}\n      }\n      //左に移動\n      if(command[j]=='L'){\n\tif(map[a][b-1]=='.'){\n\t  map[a][b-1]='<';\n\t  map[a][b]='.';\n\t  b--;\n\t}else{\n\t  map[a][b]='<';\n\t}\n      }\n      //右に移動\n      if(command[j]=='R'){\n\tif(map[a][b+1]=='.'){\n\t  map[a][b+1]='>';\n\t  map[a][b]='.';\n\t  b++;\n\t}else{\n\t  map[a][b]='>';\n\t}\n\n      }\n\n      //ショットの処理\n      if(command[j]=='S'){\n\n\tif(map[a][b]=='^'){\n\t  for(k=a;;k--){\n\t    if(map[k][b]=='*'){\n\t      map[k][b]='.';\n\t      break;\n\t    }else if(map[k][b]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='v'){\n\t  for(k=a;;k++){\n\t    if(map[k][b]=='*'){\n\t      map[k][b]='.';\n\t      break;\n\t    }else if(map[k][b]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='>'){\n\t  for(k=b;;k++){\n\t    if(map[a][k]=='*'){\n\t      map[a][k]='.';\n\t      break;\n\t    }else if(map[a][k]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n\n\n\tif(map[a][b]=='<'){\n\t  for(k=b;;k--){\n\t    if(map[a][k]=='*'){\n\t      map[a][k]='.';\n\t      break;\n\t    }else if(map[a][k]=='#'){\n\t      break;\n\t    }\n\t    \n\t  }\n\t}\n      }\n    }\n\n    //以下出力    \n    for(j=0;j<h;j++){\n      for(k=0;k<w;k++){\n\tprintf(\"%c\",map[j+1][k+1]);\n      }\n      printf(\"\\n\");\n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint width,height;\nchar map[20][21];\nint command_len;\nchar command[200];\n\nint main(void) {\n\tint d_num,c_data;\n\tint i,j;\n\tint x,y;\n\tscanf(\"%d\",&d_num);\n\tfor(c_data=0;c_data<d_num;c_data++) {\n\t\tscanf(\"%d%d\",&height,&width);\n\t\tfor(i=0;i<height;i++)scanf(\"%s\",map[i]);\n\t\tscanf(\"%d\",&command_len);\n\t\tscanf(\"%s\",command);\n\t\tx=y=-1;\n\t\tfor(i=0;i<height;i++) {\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tif(map[i][j]=='^' || map[i][j]=='v' ||\n\t\t\t\t\t\tmap[i][j]=='<' || map[i][j]=='>') {\n\t\t\t\t\ty=i;x=j;\n\t\t\t\t\ti=height;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x<0 || y<0)return 1;\n\t\tfor(i=0;i<command_len;i++) {\n\t\t\tswitch(command[i]) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tmap[y][x]='^';\n\t\t\t\t\tif(y>0 && map[y-1][x]=='.') {\n\t\t\t\t\t\tmap[y-1][x]='^';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tmap[y][x]='v';\n\t\t\t\t\tif(y<height-1 && map[y+1][x]=='.') {\n\t\t\t\t\t\tmap[y+1][x]='v';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tmap[y][x]='<';\n\t\t\t\t\tif(x>0 && map[y][x-1]=='.') {\n\t\t\t\t\t\tmap[y][x-1]='<';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tmap[y][x]='>';\n\t\t\t\t\tif(x<width-1 && map[y][x+1]=='.') {\n\t\t\t\t\t\tmap[y][x+1]='>';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tswitch(map[y][x]) {\n\t\t\t\t\t\tcase '^':\n\t\t\t\t\t\t\tfor(j=0;y-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y-j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y-j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y-j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tfor(j=0;y+j<height;j++) {\n\t\t\t\t\t\t\t\tif(map[y+j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y+j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y+j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\tfor(j=0;x-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x-j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x-j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x-j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tfor(j=0;x+j<width;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x+j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x+j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x+j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<height;i++)puts(map[i]);\n\t\tif(c_data<d_num-1)putchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[20][21];\t\t\t\t\t\t\t\t\t\t\t//高さ * 幅\nint h, w;\t\t\t\t\t\t\t\t\t\t\t\t\t//マップの高さ、幅\nint px, py, dir;\t\t\t\t\t\t\t\t\t\t\t//自分の座標、方向\nint dirx[4] = { 0,0,-1,1 };\nint diry[4] = { -1,1,0,0 };\nchar my[4] = { '^', 'v', '<', '>' };\n\nvoid act(int nmax, char *n);\nvoid move(int x);\nvoid shot(int x);\nvoid format(int x, int y);\nvoid view(void);\n\nint main(void) {\n\tformat(20, 20);\n\tint i, j, k;\n\tint data;\t\t\t\t\t\t\t\t\t\t\t\t//繰り返し回数\n\tint nmax;\t\t\t\t\t\t\t\t\t\t\t\t//操作列の長さ\n\tchar n[101];\t\t\t\t\t\t\t\t\t\t\t//操作列の格納用\n\tscanf(\"%d\\n\", &data);\t\t\t\t\t\t\t\t\t//繰り返し回数の取得\n\tfor (k = 0; k < data; k++) {\n\t\tscanf(\"%d %d\\n\", &h, &w);\t\t\t\t\t\t\t//高さと幅の取得\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tmap[i][j] = getchar();\n\t\t\t\tif (map[i][j] == '^') { px = j, py = i, dir = 0; }\n\t\t\t\tif (map[i][j] == 'v') { px = j, py = i, dir = 1; }\n\t\t\t\tif (map[i][j] == '<') { px = j, py = i, dir = 2; }\n\t\t\t\tif (map[i][j] == '>') { px = j, py = i, dir = 3; }\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tscanf(\"%d\\n\", &nmax);\t\t\t\t\t\t\t\t//操作列の長さの取得\n\t\tfor (i = 0; i < nmax; i++) {\t\t\t\t\t\t//操作列の取得\n\t\t\tn[i] = getchar();\n\t\t}\n\t\tact(nmax, &n[0]);\t\t\t\t\t\t\t\t\t//行動処理\n\t\tview();\t\t\t\t\t\t\t\t\t\t\t\t//結果の表示\n\t}\n\treturn 0;\n}\nvoid act(int nmax, char *str) {\t\t\t\t\t\t\t\t//行動処理\n\twhile (*str != '\\0') {\n\t\tswitch (*str) {\n\t\tcase 'U':\n\t\t\tdir = 0;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdir = 1;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tdir = 2;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tdir = 3;\n\t\t\tmove(dir);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tshot(dir);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tstr++;\n\t}\n}\nvoid move(int x) {\t\t\t\t\t\t\t\t\t\t\t//移動処理\n\tint sx = px + dirx[x], sy = py + diry[x];\n\tif (map[sy][sx] == '.') {\n\t\tmap[py][px] = '.';\t\t\t\t\t\t\t\t\t//自分のいた場所を平地へ変更する\n\t\tpx = sx, py = sy;\t\t\t\t\t\t\t\t\t//座標を移動する\n\t}\n\tmap[py][px] = my[dir];\n}\nvoid shot(int x) {\t\t\t\t\t\t\t\t\t\t\t//砲弾処理\n\tint sx = px + dirx[x], sy = py + diry[x] , flag;\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t//移動可能な限り繰り返す\n\t\tflag = 0;\n\t\tif (sx < 0 || sx >= w) { break; }\t\t\t\t\t//幅の範囲外は見ない\n\t\tif (sy < 0 || sy >= h) { break; }\t\t\t\t\t//高さの範囲外は見ない\n\t\tswitch (map[sy][sx]) {\n\t\t\tcase '*':\t\t\t\t\t\t\t\t\t\t//レンガの壁の場合\n\t\t\t\tmap[sy][sx] = '.';\t\t\t\t\t\t\t//平地に変更する\n\t\t\t\tbreak;\n\t\t\tcase '#':\t\t\t\t\t\t\t\t\t\t//鉄の壁の場合\n\t\t\t\tbreak;\n\t\t\tdefault:\t\t\t\t\t\t\t\t\t\t//障害物以外の場合\n\t\t\t\tflag = 1;\t\t\t\t\t\t\t\t\t//繰り返す\n\t\t\t\tbreak;\n\t\t}\n\t\tsx += dirx[x];\n\t\tsy += diry[x];\n\t} while (flag != 0);\n}\nvoid format(int x, int y) {\n\tint i, j;\n\tfor (i = 0; i < x; i++) {\n\t\tfor (j = 0; j < y; j++) {\n\t\t\tmap[i][j] = '0';\n\t\t}\n\t}\n}\nvoid view(void) {\n\tint i, j;\n\tprintf(\"\\n\");\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tprintf(\"%c\", map[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n//#define DEBUG\n\n/*??°?????????????????°*/\nchar map[22][22] ={{}};\t\t\t//??°???\nint tankx = 0 ;\nint tanky = 0 ;\t\t\t\t\t//?????????x??§?¨????y??§?¨?????¨????\nint x = 0 ;\t\t\t\t\t\t//??°????????????\nint y = 0 ;\t\t\t\t\t\t//??°???????¨????\n\n\n\nvoid showmap(void);\nvoid readmap(void);\nvoid control(char);\nvoid shootU(void);\nvoid shootD(void);\nvoid shootR(void);\nvoid shootL(void);\n\nvoid showanswer(void);\n\n\nint main (void){\n\n\tint j = 0 ;\t\t\t\t\t//??????????????????????????°\n\tint k = 0 ;\t\t\t\t\t//???????????°\n\n\tscanf(\"%d\" , &j );\n\n\tfor(k = 1 ; k <= j ; k++){\t\t//?????°???????????????????????????????????????\n\n\t\tint n = 0 ;\t\t\t\t\t//??????????????°\n\t\tchar command[101] = {} ;\t//??????????????????\n\t\tint i = 0 ;\t\t\t\t\t//???????????°\n\n\t\treadmap();\n\n\t\tscanf(\"%d\",&n);\n\t\tscanf(\"%s\",command);\n\n#ifdef DEBUG\n\t\tshowmap();\n#endif\n\n\t\tfor( i = 0 ; i < n ; i++ ){\n\t\t\tcontrol(command[i]);\t\t//????????¢??°??????????????????\n\n\t\t}\n\n\t\tshowanswer();\n\n\tif(k != j){\t\t//???????????????\n\t\tprintf(\"\\n\");\n\t}\n\n\t}//???????????°k???????????????????????§\n\n\treturn 0 ;\n}\n\n/*???????¢??????¨????????¨?????°??¢?????¨???????????¢??°*/\nvoid showmap(void){\n\tint i = 0 ;\n\tint j = 0 ;\n\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tprintf(\"%c\",map[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\n\n/*????????¨????????¨?????°??¢?????¨???????????¢??°*/\nvoid showanswer(void){\n\tint i = 0 ;\n\tint j = 0 ;\n\n\tfor(i=1;i<=y;i++){\n\t\tfor(j=1;j<=x;j++){\n\t\t\tprintf(\"%c\",map[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n/*???????????????????????¨??°??¢?????????????????¢??°*/\nvoid readmap(void){\n\tint i = 0 ;\n\tint j = 0 ;\n\tchar terrain[21] = {} ;\n\n\tscanf(\"%d\",&y);\n\tscanf(\"%d\",&x);\n\n\t/*??°??????????????????????????¨???-??§???????????????*/\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tmap[i][j] =0;\n\t\t}\n\t}\n\n\tfor(i=1;i<=y;i++){\n\t\tscanf(\"%s\",terrain);\n\t\tfor(j=1;j<=x;j++){\n\t\t\tmap[i][j] = terrain[j-1];\n\t\t\tif(map[i][j] == '^'||map[i][j] == '<'||map[i][j] == '>'||map[i][j] == 'v'){\n\t\t\t\ttankx = j ;\n\t\t\t\ttanky = i ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid control(char cmd){\n\n\tswitch(cmd){\n\tcase 'U':\n\t\tmap[tanky][tankx]='^';\t\t//???????????????????????????\n\t\tif(map[tanky-1][tankx] == '.' ){\t\t//1?????????????????°??§????????°\n\t\t\tmap[tanky][tankx] = '.' ;\t\t\t//??????????????¨??§?¨?????????°??????????????????\n\t\t\ttanky--;\t\t\t\t\t\t\t//???????????§?¨????1?????????????§????\n\t\t\tmap[tanky][tankx] = '^' ;\t\t\t//???????????°????????§?¨????????????????\n\t\t}\n\t\tbreak;\n\tcase 'D':\n\t\tmap[tanky][tankx]='v';\t\t//???????????????????????????\n\t\tif(map[tanky+1][tankx] == '.' ){\t\t//1?????????????????°??§????????°\n\t\t\tmap[tanky][tankx] = '.' ;\t\t\t//??????????????¨??§?¨?????????°??????????????????\n\t\t\ttanky++;\t\t\t\t\t\t\t//???????????§?¨????1?????????????§????\n\t\t\tmap[tanky][tankx] = 'v' ;\t\t\t//???????????°????????§?¨????????????????\n\t\t}\n\t\tbreak;\n\tcase 'R':\n\t\tmap[tanky][tankx]='>';\t\t//???????????????????????????\n\t\tif(map[tanky][tankx+1] == '.' ){\t\t//1?????????????????°??§????????°\n\t\t\tmap[tanky][tankx] = '.' ;\t\t\t//??????????????¨??§?¨?????????°??????????????????\n\t\t\ttankx++;\t\t\t\t\t\t\t//???????????§?¨????1?????????????§????\n\t\t\tmap[tanky][tankx] = '>' ;\t\t\t//???????????°????????§?¨????????????????\n\t\t}\n\t\tbreak;\n\tcase 'L':\n\t\tmap[tanky][tankx]='<';\t\t//???????????????????????????\n\t\tif(map[tanky][tankx-1] == '.' ){\t\t//1?????????????????°??§????????°\n\t\t\tmap[tanky][tankx] = '.' ;\t\t\t//??????????????¨??§?¨?????????°??????????????????\n\t\t\ttankx--;\t\t\t\t\t\t\t//???????????§?¨????1?????????????§????\n\t\t\tmap[tanky][tankx] = '<' ;\t\t\t//???????????°????????§?¨????????????????\n\t\t}\n\t\tbreak;\n\n\tcase 'S':\n\n\t\tswitch(map[tanky][tankx]){\n\t\tcase '^':\n\t\t\tshootU();\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tshootD();\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tshootR();\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tshootL();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"control error at case 'S'\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\n\n\tdefault:\n\t\tprintf(\"control error\\n\");\n\t\tbreak;\n\n\t}\n\n}\n\nvoid shootU(void){\n\tint i = 0 ;\n\tfor( i = 1 ; i < 20 ; i++){\t\t\t//?????§20??????????????§19?????????????????????????????£????????????????????????\n\t\tswitch(map[tanky-i][tankx]){\t//??????????????¨??§?¨??????????????????????????????????????????????\n\n\t\tcase '*':\t\t\t\t\t\t//??¬?????¬????£????????????£??????\n\t\t\tmap[tanky-i][tankx] = '.' ;\t\t//?????°????????????????????????\n\t\t\treturn;\n\n\t\tcase '#':\t\t\t\t\t\t//???????£????????????£??????\n\t\t\treturn;\t\t\t\t\t\t//??????????????????\n\t\tcase '\\0':\t\t\t\t\t\t//\\0???????????£?????????????????°????????????????¶????????????¨???????????????\n\t\t\treturn;\t\t\t\t\t\t//??????????????????\n\n\t\tcase '.':\t\t\t\t\t\t//?????°????°´????????????????¶????\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tbreak;\n\n\t\tdefault:\t\t\t\t\t\t//???????????\\????????????????????¶??????????????????\n\t\t\tprintf(\"shootU error:map[tanky-i][tankx] == '%c'\\n\",map[tanky-i][tankx]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid shootD(void){\n\tint i = 0 ;\n\tfor( i = 1 ; i < 20 ; i++){\t\t\t//?????§20??????????????§19?????????????????????????????£????????????????????????\n\t\tswitch(map[tanky+i][tankx]){\t//??????????????¨??§?¨??????????????????????????????????????????????\n\n\t\tcase '*':\t\t\t\t\t\t//??¬?????¬????£????????????£??????\n\t\t\tmap[tanky+i][tankx] = '.' ;\t\t//?????°????????????????????????\n\t\t\treturn;\n\n\t\tcase '#':\t\t\t\t\t\t//???????£????????????£??????\n\t\t\treturn;\t\t\t\t\t\t//??????????????????\n\t\tcase '\\0':\t\t\t\t\t\t//\\0???????????£?????????????????°????????????????¶????????????¨???????????????\n\t\t\treturn;\t\t\t\t\t\t//??????????????????\n\n\t\tcase '.':\t\t\t\t\t\t//?????°????°´????????????????¶????\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tbreak;\n\n\t\tdefault:\t\t\t\t\t\t//???????????\\????????????????????¶??????????????????\n\t\t\tprintf(\"shootD error:map[tanky+i][tankx] == '%c'\\n\",map[tanky-i][tankx]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid shootR(void){\n\tint i = 0 ;\n\tfor( i = 1 ; i < 20 ; i++){\t\t\t//?????§20??????????????§19?????????????????????????????£????????????????????????\n\t\tswitch(map[tanky][tankx+i]){\t//??????????????¨??§?¨??????????????????????????????????????????????\n\n\t\tcase '*':\t\t\t\t\t\t//??¬?????¬????£????????????£??????\n\t\t\tmap[tanky][tankx+i] = '.' ;\t\t//?????°????????????????????????\n\t\t\treturn;\n\n\t\tcase '#':\t\t\t\t\t\t//???????£????????????£??????\n\t\t\treturn;\t\t\t\t\t\t//??????????????????\n\t\tcase '\\0':\t\t\t\t\t\t//\\0???????????£?????????????????°????????????????¶????????????¨???????????????\n\t\t\treturn;\t\t\t\t\t\t//??????????????????\n\n\t\tcase '.':\t\t\t\t\t\t//?????°????°´????????????????¶????\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tbreak;\n\n\t\tdefault:\t\t\t\t\t\t//???????????\\????????????????????¶??????????????????\n\t\t\tprintf(\"shootR error:map[tanky][tankx+i] == '%c'\\n\",map[tanky][tankx+i]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid shootL(void){\n\tint i = 0 ;\n\tfor( i = 1 ; i < 20 ; i++){\t\t\t//?????§20??????????????§19?????????????????????????????£????????????????????????\n\t\tswitch(map[tanky][tankx-i]){\t//??????????????¨??§?¨??????????????????????????????????????????????\n\n\t\tcase '*':\t\t\t\t\t\t//??¬?????¬????£????????????£??????\n\t\t\tmap[tanky][tankx-i] = '.' ;\t\t//?????°????????????????????????\n\t\t\treturn;\n\n\t\tcase '#':\t\t\t\t\t\t//???????£????????????£??????\n\t\t\treturn;\t\t\t\t\t\t//??????????????????\n\t\tcase '\\0':\t\t\t\t\t\t//\\0???????????£?????????????????°????????????????¶????????????¨???????????????\n\t\t\treturn;\t\t\t\t\t\t//??????????????????\n\n\t\tcase '.':\t\t\t\t\t\t//?????°????°´????????????????¶????\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tbreak;\n\n\t\tdefault:\t\t\t\t\t\t//???????????\\????????????????????¶??????????????????\n\t\t\tprintf(\"shootL error:map[tanky][tankx-1] == '%c'\\n\",map[tanky][tankx-i]);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint width,height;\nchar map[20][21];\nint command_len;\nchar command[200];\n\nint main(void) {\n\tint d_num,c_data;\n\tint i,j;\n\tint x,y;\n\tscanf(\"%d\",&d_num);\n\tfor(c_data=0;c_data<d_num;c_data++) {\n\t\tscanf(\"%d%d\",&height,&width);\n\t\tfor(i=0;i<height;i++)scanf(\"%s\",map[i]);\n\t\tscanf(\"%d\",&command_len);\n\t\tscanf(\"%s\",command);\n\t\ti=1;\n\t\tfor(y=0;y<height && i;y++) {\n\t\t\tfor(x=0;x<width;x++) {\n\t\t\t\tif(map[y][x]=='^' || map[y][x]=='v' ||\n\t\t\t\t\t\tmap[y][x]=='<' || map[y][x]=='>') {\n\t\t\t\t\ti=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ty--;\n\t\tfor(i=0;i<command_len;i++) {\n\t\t\tswitch(command[i]) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tmap[y][x]='^';\n\t\t\t\t\tif(y>0 && map[y-1][x]=='.') {\n\t\t\t\t\t\tmap[y-1][x]='^';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tmap[y][x]='v';\n\t\t\t\t\tif(y<height-1 && map[y+1][x]=='.') {\n\t\t\t\t\t\tmap[y+1][x]='^';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\ty++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tmap[y][x]='<';\n\t\t\t\t\tif(x>0 && map[y][x-1]=='.') {\n\t\t\t\t\t\tmap[y][x-1]='<';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tmap[y][x]='>';\n\t\t\t\t\tif(x<width-1 && map[y][x+1]=='.') {\n\t\t\t\t\t\tmap[y][x+1]='>';\n\t\t\t\t\t\tmap[y][x]='.';\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tswitch(map[y][x]) {\n\t\t\t\t\t\tcase '^':\n\t\t\t\t\t\t\tfor(j=1;y-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y-j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y-j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y-j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tfor(j=1;y+j<height;j++) {\n\t\t\t\t\t\t\t\tif(map[y+j][x]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y+j][x]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y+j][x]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '<':\n\t\t\t\t\t\t\tfor(j=1;x-j>=0;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x-j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x-j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x-j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\tfor(j=1;x+j<width;j++) {\n\t\t\t\t\t\t\t\tif(map[y][x+j]=='*') {\n\t\t\t\t\t\t\t\t\tmap[y][x+j]='.';\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else if(map[y][x+j]=='#')break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<height;i++)puts(map[i]);\n\t\tif(c_data<d_num-1)putchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2103 \n  Title:Battle Town\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\n\nint T,H,W,N;\nint py,px;   //position\nchar map[20][21];\nchar map2[20][21];\nchar op[101];\nint dir;\nint diffx[4]={1,0,-1,0};\nint diffy[4]={0,-1,0,1};\nchar sensha[4]=\">^<v\";\n\nint in_range(int y,int x)\n{\n        return(y>=0 && y<H && x>=0 && x<W);\n}\nvoid dispatch(char ins)\n{\n        int dx,dy;\n\n        if(ins=='U')\n        {\n                dir=1;\n                if(py>0   && map[py-1][px]=='.')\n                        py--;\n        }\n        if(ins=='D')\n        {\n                dir=3;\n                if(py<H-1 && map[py+1][px]=='.')\n                        py++;\n        }\n        if(ins=='L')\n        {\n                dir=2;\n                if(px>0   && map[py][px-1]=='.')\n                        px--;\n        }\n        if(ins=='R')\n        {\n                dir=0;\n                if(px<W-1 && map[py][px+1]=='.')\n                        px++;\n        }\n        if(ins=='S')\n        {\n                dy=py;dx=px;\n                while(in_range(dy,dx) && (map[dy][dx]=='.' || map[dy][dx]=='-'))\n                {\n                        dy+=diffy[dir];\n                        dx+=diffx[dir];\n                        //printf(\"DYX=%d %d\\n\",dy,dx);\n                }\n                if(in_range(dy,dx) && map[dy][dx]=='*')\n                        map[dy][dx]='.';\n        }\n}\nvoid write_map(int cr)\n{\n        int i;\n        \n        memcpy(map2,map,20*21);\n        map2[py][px]=sensha[dir];\n\n        for(i=0;i<H;i++)\n                printf(\"%s\\n\",&map2[i][0]);\n\n        if(cr)\n                printf(\"\\n\");\n}\nint search_pos(int * y,int * x)\n{\n        int i,j;\n        char *p;\n\n        for(i=0;i<H;i++)\n                for(j=0;j<W;j++)\n                        if((p=strchr(sensha,map[i][j])))\n                        {\n                                *y=i;*x=j;return(p-sensha);\n                        }\n        return(-1);\n}\nvoid solve()\n{\n        int i;\n        char ins;\n\n        dir=search_pos(&py,&px);\n\n        //printf(\"YX=%d %d (%d)\\n\",py,px,dir);\n\n        map[py][px]='.';\n\n        for(i=0;i<N;i++)\n        {\n#ifdef DEBUG\n                write_map(1);\n#endif\n                ins=op[i];\n#ifdef DEBUG\n                printf(\"INS=%c\\n\",ins);\n#endif\n                dispatch(ins);\n        }\n}\nmain()\n{\n        int i,j,ret;\n\n        scanf(\"%d\",&T);\n        for(i=0;i<T;i++)\n        {\n                scanf(\"%d %d\",&H,&W);\n                for(j=0;j<H;j++)\n                        scanf(\"%s\",&map[j][0]);\n                scanf(\"%d\",&N);\n                scanf(\"%s\",&op[0]);\n                solve();\n                write_map((i<T-1));\n        }\n        return(0);\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>):Unit {\n    repeat(readLine()!!.toInt()){\n        val (h, w) = readLine()!!.split(' ').map(String::toInt)\n        val stage = Stage(h, w)\n        var tank = Tank()\n        repeat(h){ y ->\n            readLine()!!.forEachIndexed { x, c ->\n                stage[x, y] = when (c) {\n                    '*' -> MapObject.Block\n                    '#' -> MapObject.Steal\n                    '-' -> MapObject.Water\n                    '.' -> MapObject.Plane\n                    else -> {\n                        tank = Tank(Point(x, y), when (c) {\n                            '^' -> TankDirection.Up\n                            'v' -> TankDirection.Down\n                            '<' -> TankDirection.Left\n                            else -> TankDirection.Right\n                        })\n                        MapObject.Plane\n                    }\n                }\n            }\n        }\n        readLine()\n        readLine()!!.toCharArray().forEach {\n            if (it == 'S') {\n                var point = tank.bullet.find {\n                    when (stage[it]) {\n                        MapObject.Block -> true\n                        MapObject.Steal -> true\n                        else -> false\n                    }\n                }!!\n                when (stage[point]) {\n                    MapObject.Block -> {\n                        stage[point] = MapObject.Plane\n                    }\n                    else -> {\n                    }\n                }\n            } else {\n                tank = when (it) {\n                    'U' -> tank.turnedToUp\n                    'D' -> tank.turnedToDown\n                    'L' -> tank.turnedToLeft\n                    else -> tank.turnedToRight\n                }\n                when (stage[tank.forward]) {\n                    MapObject.Plane -> tank = tank.moved()\n                    else -> {\n                    }\n                }\n            }\n        }\n        if (it != 0) println()\n        println(stage.mkString(tank))\n    }\n}\n\nclass Point(val x:Int, val y:Int){\n    operator fun plus(other:Point):Point = Point(x + other.x, y + other.y)\n}\nsealed class MapObject(val asChar:Char){\n    object Plane:MapObject('.')\n    object Block:MapObject('*')\n    object Steal:MapObject('#')\n    object Water:MapObject('-')\n}\nsealed class TankDirection(val asChar:Char, val difference:Point){\n    object Up:TankDirection('^', Point(0, -1))\n    object Down:TankDirection('v', Point(0, 1))\n    object Left:TankDirection('<', Point(-1, 0))\n    object Right:TankDirection('>', Point(1, 0))\n}\nclass Stage(val height:Int, val width:Int){\n    private val mArray:Array<Array<MapObject>> = Array(height + 2){Array(width * 2){MapObject.Steal as MapObject}}\n    operator fun set(x:Int, y:Int, value:MapObject):Unit {\n        mArray[y + 1][x + 1] = value\n    }\n    operator fun set(point:Point, value:MapObject):Unit {\n        mArray[point.y + 1][point.x + 1] = value\n    }\n    operator fun get(x:Int, y:Int):MapObject = mArray[y + 1][x + 1]\n    operator fun get(point:Point):MapObject = mArray[point.y + 1][point.x + 1]\n    fun mkString(tank:Tank):String {\n        val str = (1 .. height).map{y -> (1 .. width).map{x -> mArray[y][x].asChar}.toCharArray()}.toTypedArray()\n        str[tank.position.y][tank.position.x] = tank.direction.asChar\n        return str.joinToString (separator = \"\\n\"){ it.joinToString(\"\") }\n    }\n}\nclass Tank(val position:Point = Point(0, 0), val direction: TankDirection = TankDirection.Up){\n    val bullet:Iterable<Point>\n        get() = BulletLine(position, direction.difference)\n    val turnedToUp:Tank\n        get() = Tank(position, TankDirection.Up)\n    val turnedToDown:Tank\n        get() = Tank(position, TankDirection.Down)\n    val turnedToLeft:Tank\n        get() = Tank(position, TankDirection.Left)\n    val turnedToRight:Tank\n        get() = Tank(position, TankDirection.Right)\n    val forward:Point\n        get() = position + direction.difference\n    fun moved():Tank = Tank(forward, direction)\n    private class BulletLine(private var current:Point, private val diff:Point):Iterator<Point>, Iterable<Point>{\n        override fun iterator(): Iterator<Point> = this\n        override fun hasNext(): Boolean = true\n        override fun next(): Point {\n            current += diff\n            return current\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>):Unit {\n    repeat(readLine()!!.toInt()){\n        val (h, w) = readLine()!!.split(' ').map(String::toInt)\n        val stage = Stage(h, w)\n        var tank = Tank()\n        repeat(h){ y ->\n            readLine()!!.forEachIndexed { x, c ->\n                stage[x, y] = when (c) {\n                    '*' -> MapObject.Block\n                    '#' -> MapObject.Steal\n                    '-' -> MapObject.Water\n                    '.' -> MapObject.Plane\n                    else -> {\n                        tank = Tank(Point(x, y), when (c) {\n                            '^' -> TankDirection.Up\n                            'v' -> TankDirection.Down\n                            '<' -> TankDirection.Left\n                            else -> TankDirection.Right\n                        })\n                        MapObject.Plane\n                    }\n                }\n            }\n        }\n        readLine()\n        readLine()!!.toCharArray().forEach {\n            if (it == 'S') {\n                var point = tank.bullet.find {\n                    when (stage[it]) {\n                        MapObject.Block -> true\n                        MapObject.Steal -> true\n                        else -> false\n                    }\n                }!!\n                when (stage[point]) {\n                    MapObject.Block -> {\n                        stage[point] = MapObject.Plane\n                    }\n                    else -> {\n                    }\n                }\n            } else {\n                tank = when (it) {\n                    'U' -> tank.turnedToUp\n                    'D' -> tank.turnedToDown\n                    'L' -> tank.turnedToLeft\n                    else -> tank.turnedToRight\n                }\n                when (stage[tank.forward]) {\n                    MapObject.Plane -> tank = tank.moved()\n                    else -> {\n                    }\n                }\n            }\n        }\n        if (it != 0) println()\n        println(stage.mkString(tank))\n    }\n}\n\nclass Point(val x:Int, val y:Int){\n    operator fun plus(other:Point):Point = Point(x + other.x, y + other.y)\n}\nsealed class MapObject(val asChar:Char){\n    object Plane:MapObject('.')\n    object Block:MapObject('*')\n    object Steal:MapObject('#')\n    object Water:MapObject('-')\n}\nsealed class TankDirection(val asChar:Char, val difference:Point){\n    object Up:TankDirection('^', Point(0, -1))\n    object Down:TankDirection('v', Point(0, 1))\n    object Left:TankDirection('<', Point(-1, 0))\n    object Right:TankDirection('>', Point(1, 0))\n}\nclass Stage(val height:Int, val width:Int){\n    private val mArray:Array<Array<MapObject>> = Array(height + 2){Array(width * 2){MapObject.Steal as MapObject}}\n    operator fun set(x:Int, y:Int, value:MapObject):Unit {\n        mArray[y + 1][x + 1] = value\n    }\n    operator fun set(point:Point, value:MapObject):Unit {\n        mArray[point.y + 1][point.x + 1] = value\n    }\n    operator fun get(x:Int, y:Int):MapObject = mArray[y + 1][x + 1]\n    operator fun get(point:Point):MapObject = mArray[point.y + 1][point.x + 1]\n    fun mkString(tank:Tank):String {\n        val str = (1 .. height).map{y -> (1 .. width).map{x -> mArray[y][x].asChar}.toCharArray()}.toTypedArray()\n        str[tank.position.y][tank.position.x] = tank.direction.asChar\n        return str.joinToString (separator = \"\\n\"){ it.joinToString() }\n    }\n}\nclass Tank(val position:Point = Point(0, 0), val direction: TankDirection = TankDirection.Up){\n    val bullet:Iterable<Point>\n        get() = BulletLine(position, direction.difference)\n    val turnedToUp:Tank\n        get() = Tank(position, TankDirection.Up)\n    val turnedToDown:Tank\n        get() = Tank(position, TankDirection.Down)\n    val turnedToLeft:Tank\n        get() = Tank(position, TankDirection.Left)\n    val turnedToRight:Tank\n        get() = Tank(position, TankDirection.Right)\n    val forward:Point\n        get() = position + direction.difference\n    fun moved():Tank = Tank(forward, direction)\n    private class BulletLine(private var current:Point, private val diff:Point):Iterator<Point>, Iterable<Point>{\n        override fun iterator(): Iterator<Point> = this\n        override fun hasNext(): Boolean = true\n        override fun next(): Point {\n            current += diff\n            return current\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\tSystem.out.println();\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \npublic class Main{\n    static int mapNum;//Buttle Town図の数\n    static int h;//地図の大きさの縦\n    static int w;//地図の大きさの横\n    static char[][] battleTown;//Buttle Town地図取込用\n    static int bomberActNum;//指示された戦車の行動数\n    static char [] bomberAct;//指示された戦車の行動\n//    static char [] tankDirection={'^','v','<','>'};//戦車の方向\n//    static char [] tankAct={'U','D','L','R','S'};//戦車の行動方向と砲弾発射\n    static int []tank = new int [2];\n    static int xOfTank;\n    static int yOfTank;\n    static int xOfBomber;\n    static int yOfBomber;    \n    static int s;//表示用\n    static int k;//表示用\n    static int a;//x Of Bomber\n    static int b;//y Of Bomber\n    static int x;//tankの位置x\n    static int y;//tankの位置y\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        mapNum = sc.nextInt();\n\n        for(int i = 0;i < mapNum; i++){\n            if(1<=i && i< mapNum){\n                System.out.println(\"\");\n            }\n            h = sc.nextInt();\n            w = sc.nextInt();\n\n            battleTown = new char[h][w];\n\n\n            for(int j=0; j<h; j++){\n                char[] c = sc.next().toCharArray();\n                for(int k=0; k<w; k++){\n                    battleTown[j][k] = c[k];\n//                    System.out.print(battleTown[j][k]);\n\n                    if('^'==battleTown[j][k]\n                    ||'v'==battleTown[j][k]\n                    ||'<'==battleTown[j][k]\n                    ||'>'==battleTown[j][k]){\n                        //x.yがTankの位置ということで。\n                        x = j;\n                        y = k; \n                        \n                    }\n\n                } \n\n            }\n//                  System.out.println(\"tank x は\" + x);\n//                  System.out.println(\"tank y は\" + y);\n            bomberActNum = sc.nextInt();\n            bomberAct = sc.next().toCharArray();\n\n            if(0 <= x && x <= h && 0<= y && y <= w){ \n                for(int l=0; l<bomberActNum; l++){\n                \n                    if(bomberAct[l] == 'U'){\n//検証用\n//System.out.print(bomberAct[l] + \"です。\");                 \n                        battleTown[x][y] ='^';\n                            if(x-1 >=0 && battleTown[x-1][y]=='.'){\n    \n//System.out.print( \"[\" + x + \"-1][\" + y + \"]が平地なので進みます\");                                           \n                                 battleTown[x-1][y] ='^';\n                                 battleTown[x][y] ='.';\n                                 x--;\n                            }\n                    }\n                    if(bomberAct[l] == 'D'){\n                        \n//検証用\n//System.out.print(bomberAct[l] + \"です。\");\n\n                        battleTown[x][y] ='v';\n                            if(x+1 <h && battleTown[x+1][y]=='.'){\n//System.out.print( \"[\" + x + \"-1][\" + y + \"]が平地なので進みます\");                    \n                                battleTown[x+1][y] ='v';\n                                battleTown[x][y] ='.';\n                                x++;//戦車の位置\n                            }\n                    }\n                    if(bomberAct[l] == 'L'){\n\n//System.out.print(bomberAct[l] + \"です。\");\n\n                         battleTown[x][y] ='<';\n                            if(y-1 >=0 && battleTown[x][y-1]=='.'){\n//System.out.print( \"[\" + x + \"][\" + y + \"-1]が平地なので進みます\");                    \n                                battleTown[x][y-1] ='<';\n                                battleTown[x][y] ='.';\n                                y--;\n                            }\n                    }\n                    if(bomberAct[l] == 'R'){\n//検証用\n//System.out.print(bomberAct[l] + \"です。\");                             \n                        battleTown[x][y] ='>';\n                           if(y+1 <w && battleTown[x][y+1]=='.'){\n//System.out.print( \"[\" + x + \"][\" + y + \"+1]が平地なので進みます\");                    \n                                battleTown[x][y+1] ='>';\n                                battleTown[x][y] ='.';\n                                y++;\n                           }\n                    }\n                    \n                    if(bomberAct[l] == 'S'){\n//検証用\n//System.out.print(bomberAct[l] + \"です。\");                                         \n                        xOfBomber = x;\n                        yOfBomber = y;\n                        moveBomber(xOfBomber,yOfBomber);\n                    }\n                }\n                for(s =0; s < h;s++){\n                    for(k =0; k <w;k++){\n                        System.out.print(battleTown[s][k]);\n                    }System.out.println();\n                //}if(s != mapNum){\n                 //   System.out.println();\n                \n                }\n            }\n        }\n    }\n    \n    \n    \n\n/*            for(int s =0; s < h;s++){\n                for(int k =0; k <w;k++){\n                    if(0<i){\n                        System.out.println();\n                    }else{\n                        System.out.println(battleTown[s][k]);*/\n \n\n\n    public static void moveBomber(int a,int b){\n//System.out.println(\"int a =  \" + a +\"  int b = \" + b);                  \n//System.out.println(\"battleTown[a][b] = \" + battleTown[a][b]);                  \n/*        \n        while(true){\n            if(!(0 <= a && a <= h && 0<= b && b <= w)){\n                break;\n            }else{\n*/               \n      if(0 <= a && a <= h && 0<= b && b <= w){\n\n            if('^'==battleTown[a][b]){\n//System.out.print(\"戦車は上向き。\");                \n                 for(int i = a-1;  i >= 0; i--){\n                     if(a<=0){\n                            return;\n                     }else\n//                while(0 <= x && x <= h && 0<= y && y <= w){\n//            ||0 <= xOfBomber && xOfBomber <= h && 0<= yOfTank && yOfTank <= w){\n                  \n                    if(battleTown[a-1][b]=='*'){\n//System.out.print(\"レンガ壁です。\");                  \n                        \n                        battleTown[a-1][b]='.';\n//System.out.print(\"レンガ壁を砲撃し平地に。終わります。\");                  \n                        \n                        return;\n                    }else if(battleTown[a-1][b]=='#'){\n//System.out.print(\"鉄の壁なので終わります。\");                  \n                        \n                        return;\n                    }else{\n                \n                        a--;\n//                        System.out.print(\"a--したらaは今、\" + a +\"になった。\");\n                        if(a==0){\n                            return;\n                        }\n//System.out.print(\"砲弾が上方向へ進みます。\");                          \n                    }\n           }\n        }\n\n        if('v'==battleTown[a][b]){\n            for(int i = a+1; i < h; i++){\n\n//System.out.print(\"戦車は下向き。\");                  \n                    \n                    if(battleTown[a+1][b]=='*'){\n                        battleTown[a+1][b]='.';\n//System.out.print(\"レンガ壁を砲撃し平地に。終わります。\");                  \n                        \n                        return;\n                    }else if(battleTown[a+1][b]=='#'){\n//System.out.print(\"鉄の壁なので終わります。\");                  \n                        \n                        return;\n                    }else{\n                        a++;\n                        if(a==h){\n                            return;\n                        }\n//System.out.print(\"砲弾が下方向へ進みます。\");                  \n                        \n                    }\n            }\n        }\n        if('<'==battleTown[a][b]){\n            for(int i = b-1; i >= 0; i--){\n// System.out.print(\"戦車は左向き。\");                  \n                   \n                     if(battleTown[a][b-1]=='*'){\n                        battleTown[a][b-1]='.';\n//System.out.print(\"レンガ壁を砲撃し平地に。終わります。\");                  \n                        \n                        return;\n                     }else if(battleTown[a][b-1]=='#'){\n//System.out.print(\"鉄の壁なので終わります。\");                  \n                         \n                        return;\n                    }else{\n                        b--;\n                        if(b==0){\n                            return;\n                        }\n//System.out.print(\"砲弾が左方向へ進みます。\");                  \n                        \n                    }\n            }\n        }\n        if('>'==battleTown[a][b]){\n            for(int i = b+1; i < w; i++){\n//System.out.print(\"戦車は右向き。\");                  \n                    \n                     if(battleTown[a][b+1]=='*'){\n                        battleTown[a][b+1]='.';\n//System.out.print(\"レンガ壁を砲撃し平地に。終わります。\");                  \n                        \n                        return;\n                     }else if(battleTown[a][b+1]=='#'){\n//System.out.print(\"鉄の壁なので終わります。\");                  \n                         \n                        return;\n                    }else{\n                        b++;\n                        if(b==w){\n                            return;\n                        }\n//System.out.print(\"砲弾が右方向へ進みます。\");\n\n\n                        \n                    }\n            }\n        }\n        }\n    }\n    \n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tstatic int H,W;\n\tstatic char field[][];\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint T=in.nextInt();\n\t\tfor(int I=0;I<T;I++)\n\t\t{\n\t\t\tif(I!=0)\n\t\t\t\tSystem.out.println();\n\t\t\tint H=in.nextInt();\n\t\t\tint W=in.nextInt();\n\t\t\tint sh=0;\n\t\t\tint sw=0;\n\t\t\tint dir=0;\n\t\t\tfield=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tchar ch[]=in.next().toCharArray();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tfield[i][j]=ch[j];\n\t\t\t\t\tif(ch[j]=='>'||ch[j]=='v'||ch[j]=='<'||ch[j]=='^')\n\t\t\t\t\t{\n\t\t\t\t\t\t sh=i;\n\t\t\t\t\t\t sw=j;\n\t\t\t\t\t\t field[i][j]='.';\n\t\t\t\t\t}\n\t\t\t\t\tif(ch[j]=='^')\n\t\t\t\t\t\tdir=1;\n\t\t\t\t\telse if(ch[j]=='>')\n\t\t\t\t\t\tdir=2;\n\t\t\t\t\telse if(ch[j]=='v')\n\t\t\t\t\t\tdir=3;\n\t\t\t\t\telse if(ch[j]=='<')\n\t\t\t\t\t\tdir=4;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint N=in.nextInt();\n\t\t\tchar d[]=in.next().toCharArray();\n\t\t\t\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(d[i]=='U')\n\t\t\t\t{\n\t\t\t\t\tdir=1;\n\t\t\t\t\tif(sh-1>=0&&field[sh-1][sw]=='.')\n\t\t\t\t\t\tsh--;\n\t\t\t\t}\n\t\t\t\telse if(d[i]=='R')\n\t\t\t\t{\n\t\t\t\t\tdir=2;\n\t\t\t\t\tif(sw+1<W&&field[sh][sw+1]=='.')\n\t\t\t\t\t\tsw++;\n\t\t\t\t}\n\t\t\t\telse if(d[i]=='D')\n\t\t\t\t{\n\t\t\t\t\tdir=3;\n\t\t\t\t\tif(sh+1<H&&field[sh+1][sw]=='.')\n\t\t\t\t\t\tsh++;\n\t\t\t\t}\n\t\t\t\telse if(d[i]=='L')\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tdir=4;\n\t\t\t\t\tif(sw-1>=0&&field[sh][sw-1]=='.')\n\t\t\t\t\t\tsw--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint nh=sh;\n\t\t\t\t\tint nw=sw;\n\t\t\t\t\tif(dir==1)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nh>=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnh--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(dir==2)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nw<W)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnw++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(dir==3)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nh<H)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnh++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(dir==4)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nw>=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnw--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dir==1)\n\t\t\t\tfield[sh][sw]='^';\n\t\t\telse if(dir==2)\n\t\t\t\tfield[sh][sw]='>';\n\t\t\telse if(dir==3)\n\t\t\t\tfield[sh][sw]='v';\n\t\t\telse if(dir==4)\n\t\t\t\tfield[sh][sw]='<';\n\t\t\t\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map2> map_list = new ArrayList<map2>();\n\n\n\n\t\t// 入力の回数\n        Scanner sc = new Scanner(System.in);\n        int input_length = 0;\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t// マップの高さ\n\t\t\theight = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\twidth = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap2 map = new map2();\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank2 tank = new tank2();\n\t\t\tmap.setMap(height, width);\n\n\t\t\tString line = null;\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tline = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint command_number = 0;\n\t\t\tString command_attack = \"\";\n\t\t\t// コマンド入力回数\n\t\t\tcommand_number = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\n\t\t\tcommand_attack = sc.next();\n\t\t\t// ひとつずつ配列に入れる\n\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (map2 obj : map_list) {\n\t\t\tobj.out_map();\n\t\t\t// 改行\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\n\t}\n\n}\n\nclass tank2 {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map2 {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t// マップの高さ\n\t\t\theight = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\twidth = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap map = new map();\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank tank = new tank();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint command_number = 0;\n\t\t\tString command_attack = \"\";\n\t\t\t// コマンド入力回数\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_number = sc.nextInt();\n\t\t\t}\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; i < command_number; c++) {\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//砲弾発射だったら\n\t\t\t\tif(command_attack.equals(\"S\")){\n\t\t\t\t\t//マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(), tank.getSituation());\n\t\t\t\t}else{\n\t\t\t\t\t//移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(), tank.getSituation());\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (map obj : map_list) {\n\t\t\tobj.out_map();\n\t\t\t// 改行\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(int height, int width, String[][] map) {\n\t\tfor (int h = 0; h < height; h++) {\n\t\t\tfor (int w = 0; w < width; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map[h][w] == val) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\t// マップの高さ\n\tprivate int height = 0;\n\t// マップの幅さ\n\tprivate int width = 0;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t\theight = h;\n\t\twidth = w;\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t//\n\t\t\tfor (int i = 0; i < now_w; i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\tfor (int i = 0; i < (width - 1 - now_w); i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\tfor (int i = 0; i < (height - 1 - now_h); i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\tfor (int i = 0; i < now_h; i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更 現在位置 向き\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w + 1] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        ArrayList<char[][]> listBattleArea = new ArrayList<char[][]>();\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        \n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            \n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            listBattleArea.add(aryBattleArea);\n            \n        }\n        \n        for( int i = 0 ; i < listBattleArea.size() ; i++ ){\n        \t\n        \tchar[][] output = listBattleArea.get(i);\n        \t\n        \tfor( int j = 0 ; j < output.length ; j++ ){\n        \t\tfor( int k = 0 ; k < output[j].length ; k++ ){\n        \t\t\t\n        \t\t\tSystem.out.print(output[j][k]);\n        \t\t\t\n        \t\t}\n        \t\tSystem.out.println();\n        \t}\n        \tSystem.out.println();\n        }\n        \n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    //private ArrayList<char[][]> list = new ArrayList<char[][]>();\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                              //  continue;\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    public void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n        //??????????°?  \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[i][x] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea[i].length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[i][x] == '#' ){\n                        //break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package BattleTown;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//\nenum Situation{\n    /// <summary>\n    /// 上\n    /// </summary>\n    Up,\n    /// <summary>\n    /// 下\n    /// </summary>\n    Down,\n    /// <summary>\n    /// 左\n    /// </summary>\n    Left,\n    /// <summary>\n    /// 右\n    /// </summary>\n    Right,\n}\nenum Map_name{\n    /// <summary>\n    /// 平地\n    /// </summary>\n    Normal,\n    /// <summary>\n    /// レンガ壁\n    /// </summary>\n    WallOfBlock,\n    /// <summary>\n    /// 鉄壁\n    /// </summary>\n    WallOfIron,\n    /// <summary>\n    /// 水\n    /// </summary>\n    Water\n}\n\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\t//\n\t\tMap<Situation,String> Tank_situation= new HashMap<Situation,String>();\n\t\t\n\t\t//戦車の方向を定義する\n\t\tTank_situation.put(Situation.Left,\"<\");\n\t\tTank_situation.put(Situation.Right, \">\");\n\t\tTank_situation.put(Situation.Up, \"^\");\n\t\tTank_situation.put(Situation.Down, \"v\");\n\t\t\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<Field> map_list = new ArrayList<Field>();\n\t\t// 入力クラス\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// 入力の回数\n\t\tint input_length = sc.nextInt();\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tField map = new Field();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// 戦車のインスタンスを作る\n\t\t\tTank tank = new Tank();\n\n\t\t\t// マップ高さ分まわす\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// マップを作る\n\t\t\t\tmap.createMap(h, line);\n\t\t\t}\n\n\t\t\t// コマンド入力回数\n\t\t\tint no_use = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tString command_row = sc.next();\n\n\t\t\t// 戦車の動き\n\t\t\ttank.Action(command_row, map,Tank_situation);\n\n\t\t\t// できたマップリストにを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\n\t\t\tmap_list.get(f).out_map();\n\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 戦車について扱ったクラス\nclass Tank {\n\n\t//戦車の要素\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\t\n\tTank(){\n\t\t\n\t}\n\n\t// 現在位置と向きを探す\n\tpublic void now_position(Field map) {\n\t\t// マップ全体を探す\n\t\tfor (int h = 0; h < map.getMap().length; h++) {\n\t\t\tfor (int w = 0; w < map.getMap()[0].length; w++) {\n\n\t\t\t\t// 自分(戦車)がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map.getMap()[h][w].equals(val)) {\n\t\t\t\t\t\t// 自分(戦車)の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t\t\n//\t\t\t\t\t\tswitch (val){\n//\t\t\t\t        case \"^\": situation = String.valueOf(Situation.Up); break;\n//\t\t\t\t        case \"v\": situation = String.valueOf(Situation.Down); break;\n//\t\t\t\t        case \"<\": situation = String.valueOf(Situation.Left); break;\n//\t\t\t\t        case \">\": situation = String.valueOf(Situation.Right); break;\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 戦車行動によるマップ変更\n\tpublic Field Action(String command_row, Field map,Map<Situation,String> tank_situation) {\n\t\t// 一文字づつに変換\n\t\tchar[] command_char = command_row.toCharArray();\n\n\t\t// コマンドがある分まわす\n\t\tfor (int i = 0; i < command_char.length; i++) {\n\n\t\t\t// 現在位置を把握\n\t\t\tnow_position(map);\n\n\t\t\t// ひとつのコマンド\n\t\t\tString one_command = String.valueOf(command_char[i]);\n\n\t\t\t// コマンド入力によって行動を変化\n\t\t\tswitch (one_command) {\n\t\t\t// 移動\n\t\t\tcase \"R\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"U\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"D\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\t// 砲撃\n\t\t\tcase \"S\":\n\t\t\t\tshuttGun(map,tank_situation);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車砲撃によるマップ変更\n\tpublic Field shuttGun(Field map,Map<Situation,String> tank_situation) {\n\t\t\n\t\t//String Left = String.valueOf(tank_situation.get(\"Left\"));\n\t\t// 場合わけ\n\t\tswitch (situation) {\n\n\t\t// 左向き\n\t\tcase tank_situation.get(\"Left\"):\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_width; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// 右向き\n\t\tcase \">\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map.getMap()[0].length - now_width); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width + i] = \".\";\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// 上向き\n\t\tcase \"^\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_height; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"*\")) {\n\n\t\t\t\t\t\tmap.getMap()[now_height - i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// 下向き\n\t\tcase \"v\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.getMap().length - now_height); i++) {\n\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height + i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic Field move(String s, Field map) {\n\n\t\t// ケース分け\n\t\tswitch (s) {\n\n\t\t// 左向き\n\t\tcase \"L\":\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 右向き\n\t\tcase \"R\":\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 下向き\n\t\tcase \"D\":\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\n\t\t\t} else if (map.getMap()[now_height + 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height + 1][now_width] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 上向き\n\t\tcase \"U\":\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height - 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height - 1][now_width] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\n// マップについて扱ったクラス\nclass Field {\n\n\t// マップ構成要素\n\tfinal String[] Map_element = new String[] { \".\", \"*\", \"#\", \"-\" };\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t\t\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, String map_row) {\n\t\t// 一文字づつに変換\n\t\tchar[] map_ele = map_row.toCharArray();\n\t\t// 一文字マップに構成要素を追加していく\n\t\tfor (int w = 0; w < map_ele.length; w++) {\n\t\t\tmap[height_i][w] = String.valueOf(map_ele[w]);\n\t\t}\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\t// ???????????????\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], 'W');\n\t\t\t}\n\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = tmp_row.charAt(mw);\n\n\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t// ???????????????????????°????????????\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw + 1]) > -1) {\n\t\t\t\t\t\t// init tank.\n\t\t\t\t\t\ttank = new Tank(game_Map, game_Map[mh][mw + 1], new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\ttank.command(cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\ttank.last_tankLocate();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\t// ???????????????????????°????????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n}// ???????????????????????????????????????\n\nclass Tank {\n\n\t/**\n\t * ?????????\n\t */\n\tprivate char[][] map;\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/*\n\t * ????????????????????????\n\t */\n\tTank(char[][] map, char dir, int[] pos) {\n\t\tthis.dir = dir;\n\t\tthis.map = map;\n\t\tthis.pos = pos;\n\t}\n\n\t/*\n\t * ?§??????????\n\t */\n\tHashMap<Character, Character> move_Cmd = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t/*\n\t * ?§??????¢???\n\t */\n\tHashMap<Character, int[]> move_Dir = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ???????????????????????°????????????\n\tvoid command(char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\tmove_tank(cmd);\n\t\t} else {\n\t\t\tcannon_Shot();\n\t\t}\n\t}\n\n\t/**\n\t * <pre>\n\t * ?????????????????????\n\t * ????????¬?????¬????£??????¶????????£???????????°?????????\n\t * ?????????????£??????°?????????\n\t * ????????°??????????????¨??§?????£????????????????¶????\n\t * </pre>\n\t *\n\t * @param shell\n\t *            ??????\n\t */\n\tprivate void cannon_Shot() {\n\t\tint[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\twhile (true) {\n\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\tcase '.':\n\t\t\tcase '-':\n\t\t\t\tcontinue;\n\t\t\tcase '*':\n\t\t\t\tmap[shell[0]][shell[1]] = '.';\n\t\t\tcase '#':\n\t\t\tcase 'x':\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}// cannon_Shoot????????????????????????\n\n\t/**\n\t * <pre>\n\t *?????????????§????\n\t *\n\t *???????????°???????§??????????\n\t *???????????¬??????????????????????????£????§???????????????¨?????????\n\t * </pre>\n\t *\n\t * @param cmd\n\t *            ?????¬??????????????????\n\t * @param move\n\t *            ??????????§????\n\t */\n\tprivate void move_tank(char cmd) {\n\n\t\tthis.dir = move_Cmd.get(cmd);\n\t\tint[] next = new int[] { this.pos[0], this.pos[1] };\n\t\tnext[0] += move_Dir.get(this.dir)[0];\n\t\tnext[1] += move_Dir.get(this.dir)[1];\n\t\tif (map[next[0]][next[1]] == '.') {\n\t\t\tthis.pos[0] = next[0];\n\t\t\tthis.pos[1] = next[1];\n\t\t}\n\t}// move_tank????????????????????????\n\n\tvoid last_tankLocate() {\n\t\t// ?????????????????¨??°?????°????????¨?¨???????\n\t\tmap[this.pos[0]][this.pos[1]] = this.dir;\n\t}\n\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]) {\n\t\tStringBuilder result = new StringBuilder();\n\t\tScanner scan = new Scanner(System.in);\n\t\tint setCount = scan.nextInt();\n\n\t\t// setCount????????°??°???????????????\n\t\tfor(int i=0;i<setCount;i++){\n\n\t\t// PlayerControl??????????????????????????????\n\t\tPlayerControl pc = new PlayerControl(scan.nextInt(), scan.nextInt());\n\t\t// ????????????????????????\n\t\tpc.mapBuild(scan);\n\n\t\t// System.out.println(pc.map[3][0]);\n\n\t\t// ?????¬???????????\\??????????????°?????????\n\t\tint playerControlCount = scan.nextInt();\n\t\t// ?????¬???????????\\??????????????????????????????\n\t\tString setPlayerControl = scan.next();\n\t\tfor (int k = 0; k < playerControlCount; k++) {\n\t\t\tif (String.valueOf(setPlayerControl.charAt(k)).equals(\"S\")) {\n\t\t\t\t// ???????????????????????????????????????????°??????????\n\t\t\t\tpc.tankShoot();\n\t\t\t} else {\n\t\t\t\t// ?????????????????¢??????????????????????????°??§????????°?§??????????\n\t\t\t\tpc.tankMove(String.valueOf(setPlayerControl.charAt(k)));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//???????????¨????????????????????????result????????????????????????\n\t\tresult.append(pc.mapOutput()).append(\"\\n\");\n\t\t}\n\t\t\n\t\tresult.deleteCharAt(result.length() - 2);\n\t\tSystem.out.print(new String(result));\n\n\t\t\n\n\t}\n}\n\n/**\n * ?????¬????????????????????????????????????????????????\n * \n * @author SS\n *\n */\nclass PlayerControl {\n\t// ??????????????????\n\tString map[][];\n\n\t// ??????????????±\n\tint tankHeight;\n\tint tankWidth;\n\tString tankState;\n\n\t// ?????????????????????????????¨????????????????¨????\n\tPlayerControl(int height, int width) {\n\t\tmap = new String[height][width];\n\t\ttankHeight = 0;\n\t\ttankWidth = 0;\n\t\ttankState = \"\";\n\t}\n\n\t/**\n\t * ??????????????????\n\t * \n\t * @param main???Scanner??????????¶????\n\t */\n\tpublic void mapBuild(Scanner scan) {\n\t\t// height * width ??????????????§??????????????????????????????\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tString setObject = scan.next();\n\t\t\tfor (int j = 0; j < map[0].length; j++) {\n\t\t\t\t// ?????????????????¨??¶???????????±????¨????\n\t\t\t\tswitch (map[i][j] = String.valueOf(setObject.charAt(j))) {\n\t\t\t\tcase \"^\":\n\n\t\t\t\t\ttankInfo(i, j, \"^\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"v\":\n\t\t\t\t\ttankInfo(i, j, \"v\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \">\":\n\t\t\t\t\ttankInfo(i, j, \">\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"<\":\n\t\t\t\t\ttankInfo(i, j, \"<\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * ?????????????????¨??¶???????¨??????????\n\t * \n\t * @param height\n\t *            ????????§?¨?\n\t * @param width\n\t *            ?¨??????§?¨?\n\t * @param state\n\t *            ??¶?????????????????????\n\t */\n\tprivate void tankInfo(int height, int width, String state) {\n\n\t\ttankHeight = height;\n\t\ttankWidth = width;\n\t\ttankState = state;\n\n\t}\n\n\t/**\n\t * \n\t * @param ?????¬???????????????????????????????????????\n\t */\n\tpublic void Control(String instruction) {\n\t\tswitch (instruction) {\n\t\tcase \"S\":// ???????????????????????¨???\n\t\t\tSystem.out.println(\"tankShoot()???????????????\");\n\t\t\ttankShoot();\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tpublic void tankMove(String move) {\n\t\tswitch (move) {\n\t\tcase \"U\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"^\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????????§????????¨?????????????????????\n\t\t\tif (tankHeight - 1 >= 0) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight - 1][tankWidth].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight - 1][tankWidth] = \"^\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight - 1, tankWidth, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"D\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"v\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\t\t\t\n\t\t\t// ?????????????????????????¶????????????¨?????????????????????\n\t\t\tif (tankHeight + 1 < map.length) {\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight + 1][tankWidth].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight + 1][tankWidth] = \"v\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight + 1, tankWidth, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"L\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"<\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????????§????????¨?????????????????????\n\t\t\tif (tankWidth - 1 >= 0) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight][tankWidth - 1].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight][tankWidth - 1] = \"<\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight, tankWidth - 1, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"R\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \">\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????¶????????????¨?????????????????????\n\t\t\tif (tankWidth + 1 < map[0].length) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight][tankWidth + 1].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight][tankWidth + 1] = \">\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight, tankWidth + 1, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * S?????????????????¨??????????????????????????????????????????????°????????????? ??¬?????¬????£??????¶????????£?????¨???????????¬?????¬????£?????????°??¨?????????\n\t */\n\tpublic void tankShoot() {\n\t\ttry {\n\t\t\tswitch (tankState) {\n\t\t\tcase \"^\":// ???????????????????????????\n\n\t\t\t\tfor (int i = 1; i <= tankHeight; i++) {\n\t\t\t\t\tif (map[tankHeight - i][tankWidth].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight - i][tankWidth] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight - i][tankWidth].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase \"v\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= (map.length - 1) - tankHeight; i++) {\n\t\t\t\t\tif (map[tankHeight + i][tankWidth].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight + i][tankWidth] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight + i][tankWidth].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \">\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= (map[0].length - 1) - tankWidth; i++) {\n\t\t\t\t\tif (map[tankHeight][tankWidth + i].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight][tankWidth + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight][tankWidth + i].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"<\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= tankWidth; i++) {\n\t\t\t\t\tif (map[tankHeight][tankWidth - i].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight][tankWidth - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight][tankWidth - i].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"??´??????????????????\");\n\t\t}\n\n\t}\n\n\tpublic StringBuilder mapOutput() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tfor (int j = 0; j < map[0].length; j++) {\n\t\t\t\tsb.append(map[i][j]);\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\t\n\t\treturn sb;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ??????????????????????????±?????¶???????????????\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§???????????????????????????????????????????\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ????????????????????¨?????????????????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('U', '^');\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// ('D', 'v');\n\t\t\t// ('v', { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('L', '<');\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('R', '>');\n\t\t\t// ('>',{ 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\t// ??????????????????????????????\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('v',{ 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('>', { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map3> map_list = new ArrayList<map3>();\n\t\t//\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length =0;\n\t\t// 入力の回数\n\t\twhile(sc.hasNext()){\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap3 map = new map3();\n\t\t\tmap.setMap(height, width);\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank3 tank = new tank3();\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// コマンド入力回数\n\t\t\tint command_number = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\tString command_attack = sc.next();\n\t\t\t// ひとつずつ配列に入れる\n\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\tmap_list.get(f).out_map();\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nclass tank3 {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\nclass map3 {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n//\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\t\t\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<Field> map_list = new ArrayList<Field>();\n\t\t// 入力クラス\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// 入力の回数\n\t\tint input_length = sc.nextInt();\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tField map = new Field();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// 戦車のインスタンスを作る\n\t\t\tTank tank = new Tank();\n\n\t\t\t// マップ高さ分まわす\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// マップを作る\n\t\t\t\tmap.createMap(h, line);\n\t\t\t}\n\n\t\t\t// コマンド入力回数\n\t\t\tint no_use = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tString command_row = sc.next();\n\n\t\t\t// 戦車の動き\n\t\t\ttank.Action(command_row, map);\n\n\t\t\t// できたマップリストにを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\n\t\t\tmap_list.get(f).out_map();\n\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 戦車について扱ったクラス\nclass Tank {\n\n\t//戦車の要素\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す\n\tpublic void now_position(Field map) {\n\t\t// マップ全体を探す\n\t\tfor (int h = 0; h < map.getMap().length; h++) {\n\t\t\tfor (int w = 0; w < map.getMap()[0].length; w++) {\n\n\t\t\t\t// 自分(戦車)がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map.getMap()[h][w].equals(val)) {\n\t\t\t\t\t\t// 自分(戦車)の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 戦車行動によるマップ変更\n\tpublic Field Action(String command_row, Field map) {\n\t\t// 一文字づつに変換\n\t\tchar[] command_char = command_row.toCharArray();\n\n\t\t// コマンドがある分まわす\n\t\tfor (int i = 0; i < command_char.length; i++) {\n\n\t\t\t// 現在位置を把握\n\t\t\tnow_position(map);\n\n\t\t\t// ひとつのコマンド\n\t\t\tString one_command = String.valueOf(command_char[i]);\n\n\t\t\t// コマンド入力によって行動を変化\n\t\t\tswitch (one_command) {\n\t\t\t// 移動\n\t\t\tcase \"R\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"U\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"D\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\t// 砲撃\n\t\t\tcase \"S\":\n\t\t\t\tshuttGun(map);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車砲撃によるマップ変更\n\tpublic Field shuttGun(Field map) {\n\t\t// 場合わけ\n\t\tswitch (situation) {\n\n\t\t// 左向き\n\t\tcase \"<\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_width; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// 右向き\n\t\tcase \">\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map.getMap()[0].length - now_width); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width + i] = \".\";\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// 上向き\n\t\tcase \"^\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_height; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"*\")) {\n\n\t\t\t\t\t\tmap.getMap()[now_height - i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// 下向き\n\t\tcase \"v\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.getMap().length - now_height); i++) {\n\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height + i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic Field move(String s, Field map) {\n\n\t\t// ケース分け\n\t\tswitch (s) {\n\n\t\t// 左向き\n\t\tcase \"L\":\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 右向き\n\t\tcase \"R\":\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 下向き\n\t\tcase \"D\":\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\n\t\t\t} else if (map.getMap()[now_height + 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height + 1][now_width] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 上向き\n\t\tcase \"U\":\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height - 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height - 1][now_width] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\n// マップについて扱ったクラス\nclass Field {\n\n\t// マップ構成要素\n\tfinal String[] Map_element = new String[] { \".\", \"*\", \"#\", \"-\" };\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, String map_row) {\n\t\t// 一文字づつに変換\n\t\tchar[] map_ele = map_row.toCharArray();\n\t\t// 一文字マップに構成要素を追加していく\n\t\tfor (int w = 0; w < map_ele.length; w++) {\n\t\t\tmap[height_i][w] = String.valueOf(map_ele[w]);\n\t\t}\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        ArrayList<char[][]> list = new ArrayList<char[][]>();\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        \n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            \n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            list.add(aryBattleArea);\n        }\n        \n        for( int i = 0 ; i < list.size() ; i++ ){\n        \t\n        \tchar[][] s = list.get(i);\n        \t\n        \tfor( int j = 0 ; j < s.length ; j++ ){\n        \t\tfor( int k = 0 ; k < s[i].length ; k++ ){\n        \t\t\t\n        \t\t\tSystem.out.print(s[j][k]);\n        \t\t\t\n        \t\t}\n        \t\tSystem.out.println();\n        \t}\n        }\n        \n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                              //  continue;\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    public void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n        //??????????°?  \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n \nimport static java.lang.Integer.parseInt;\n \n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n \n    public static void main(String[] args) throws IOException {\n        \n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\t// ???????????????\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tString[][] game_Map = new String[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], \"W\");\n\t\t\t}\n\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = String.valueOf(tmp_row.charAt(mw));\n\n\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t// ???????????????????????°????????????\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw + 1]) > -1) {\n\t\t\t\t\t\t// init tank.\n\t\t\t\t\t\ttank = new Tank(game_Map, game_Map[mh][mw + 1], new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = \".\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray()) tank.command(cmd);\n\t\t\t//????????????????????????????????±?????¨?¨???????\n\t\t\ttank.last_tankLocate();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\t// ???????????????????????°????????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n}// ???????????????????????????????????????\n \nclass Tank {\n \n    /*\n\t * ?§??????????\n\t */\n\tstatic HashMap<String, String> move_Cmd = new HashMap<String, String>() {\n\t\t{\n\t\t\tput(\"U\", \"^\");\n\t\t\tput(\"D\", \"v\");\n\t\t\tput(\"L\", \"<\");\n\t\t\tput(\"R\", \">\");\n\t\t}\n\t};\n   /*\n\t * ?§??????¢???\n\t */\n\tstatic HashMap<String, int[]> move_Dir = new HashMap<String, int[]>() {\n\t\t{\n\t\t\tput(\"^\", new int[] { -1, 0 });\n\t\t\tput(\"v\", new int[] { 1, 0 });\n\t\t\tput(\"<\", new int[] { 0, -1 });\n\t\t\tput(\">\", new int[] { 0, 1 });\n\t\t}\n\t};\n \n   /**\n\t * ?????????\n\t */\n\tprivate String[][] map;\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate String dir;\n\n\t/*\n\t * ????????????????????????\n\t */\n\tTank(String[][] game_Map, String tank_dir, int[] tank_pos) {\n\t\tthis.map = game_Map;\n\t\tthis.pos = tank_pos;\n\t\tthis.dir = tank_dir;\n\t}\n\n \n   // ???????????????????????°????????????\n\tvoid command(char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\tmove_tank(String.valueOf(cmd));\n\t\t} else {\n\t\t\tcannon_Shot();\n\t\t}\n\t}\n \n    /**\n\t * <pre>\n\t *?????????????§????\n\t *\n\t *???????????°???????§??????????\n\t *???????????¬??????????????????????????£????§???????????????¨?????????\n\t * </pre>\n\t *\n\t * @param cmd\n\t *            ?????¬??????????????????\n\t * @param move\n\t *            ??????????§????\n\t */\n\tprivate void move_tank(String cmd) {\n       this.dir = move_Cmd.get(cmd);\n\t\tint[] move = new int[] { this.pos[0], this.pos[1] };\n\t\tmove[0] += move_Dir.get(this.dir)[0];\n\t\tmove[1] += move_Dir.get(this.dir)[1];\n\t\tif (map[move[0]][move[1]] == \".\") {\n\t\t\tthis.pos[0] = move[0];\n\t\t\tthis.pos[1] = move[1];\n\t\t}\n\t}// move_tank????????????????????????\n \n    /**\n\t * <pre>\n\t * ?????????????????????\n\t * ????????¬?????¬????£??????¶????????£???????????°?????????\n\t * ?????????????£??????°?????????\n\t * ????????°??????????????¨??§?????£????????????????¶????\n\t * </pre>\n\t *\n\t * @param shell\n\t *            ??????\n\t */\n\tprivate void cannon_Shot() {\n        int[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\twhile (true) {\n\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\tcase \".\":\n\t\t\tcase \"-\":\n\t\t\t\tcontinue;\n\t\t\tcase \"*\":\n\t\t\t\tmap[shell[0]][shell[1]] = \".\";\n\t\t\tcase \"#\":\n\t\t\tcase \"W\":\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n        }\n    }// cannon_Shoot????????????????????????\n \n    void last_tankLocate() {\n// ?????????????????¨??°?????°????????¨?¨???????\n        map[this.pos[0]][this.pos[1]] = this.dir;\n    }\n \n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\nenum Situation\n{\n    /// <summary>\n    /// 上\n    /// </summary>\n    Up,\n    /// <summary>\n    /// 下\n    /// </summary>\n    Down,\n    /// <summary>\n    /// 左\n    /// </summary>\n    Left,\n    /// <summary>\n    /// 右\n    /// </summary>\n    Right,\n\n    /// <summary>\n    /// 未設定\n    /// </summary>\n    None,\n}\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\t//戦車方向のハッシュ配列\n\t\tMap<String,String> Tank_situation= new HashMap<String,String>();\n\t\t\n\t\t//戦車の方向を定義する\n\t\tTank_situation.put(\"Left\",\"<\");\n\t\tTank_situation.put(\"Right\", \">\");\n\t\tTank_situation.put(\"Up\", \"^\");\n\t\tTank_situation.put(\"Down\", \"v\");\n\t\t\n\t\t//マップ要素のハッシュ配列\n\t\tMap<String,String> Map_element= new HashMap<String,String>();\n\t\t\n\t\t//戦車の方向を定義する\n\t\tTank_situation.put(\"Normal\",\".\");\n\t\tTank_situation.put(\"WallOfBlock,\", \"*\");\n\t\tTank_situation.put(\"WallOfIron\", \"#\");\n\t\tTank_situation.put(\"Water\", \"-\");\n\n\t\t\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<Field> map_list = new ArrayList<Field>();\n\t\t// 入力クラス\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// 入力の回数\n\t\tint input_length = sc.nextInt();\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tField map = new Field();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// 戦車のインスタンスを作る\n\t\t\tTank tank = new Tank();\n\n\t\t\t// マップ高さ分まわす\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// マップを作る\n\t\t\t\tmap.createMap(h, line);\n\t\t\t}\n\n\t\t\t// コマンド入力回数\n\t\t\tint no_use = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tString command_row = sc.next();\n\n\t\t\t// 戦車の動き\n\t\t\ttank.Action(command_row, map,Tank_situation);\n\n\t\t\t// できたマップリストにを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\n\t\t\tmap_list.get(f).out_map();\n\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 戦車について扱ったクラス\nclass Tank {\n\t//戦車方向のハッシュ配列\n\tMap<String,String> Tank_situati= new HashMap<String,String>();\n\n\t//戦車の要素\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\t\n\tTank(){\n\t\t\n\t}\n\n\t// 現在位置と向きを探す\n\tpublic void now_position(Field map) {\n\t\t// マップ全体を探す\n\t\tfor (int h = 0; h < map.getMap().length; h++) {\n\t\t\tfor (int w = 0; w < map.getMap()[0].length; w++) {\n\n\t\t\t\t// 自分(戦車)がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map.getMap()[h][w].equals(val)) {\n\t\t\t\t\t\t// 自分(戦車)の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t\t\n//\t\t\t\t\t\tswitch (val){\n//\t\t\t\t        case \"^\": situation = String.valueOf(Situation.Up); break;\n//\t\t\t\t        case \"v\": situation = String.valueOf(Situation.Down); break;\n//\t\t\t\t        case \"<\": situation = String.valueOf(Situation.Left); break;\n//\t\t\t\t        case \">\": situation = String.valueOf(Situation.Right); break;\n//\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 戦車行動によるマップ変更\n\tpublic Field Action(String command_row, Field map,Map<String,String> tank_situation) {\n\t\t// 一文字づつに変換\n\t\tchar[] command_char = command_row.toCharArray();\n\n\t\t// コマンドがある分まわす\n\t\tfor (int i = 0; i < command_char.length; i++) {\n\n\t\t\t// 現在位置を把握\n\t\t\tnow_position(map);\n\n\t\t\t// ひとつのコマンド\n\t\t\tString one_command = String.valueOf(command_char[i]);\n\n\t\t\t// コマンド入力によって行動を変化\n\t\t\tswitch (one_command) {\n\t\t\t// 移動\n\t\t\tcase \"R\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"U\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"D\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\t// 砲撃\n\t\t\tcase \"S\":\n\t\t\t\tshuttGun(map,tank_situation);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車砲撃によるマップ変更\n\tpublic Field shuttGun(Field map,Map<String,String> tank_situation) {\n\t\t\n\t\ttank_situation.get(\"Left\");\n\t\t// 場合わけ\n\t\tswitch (situation) {\n\n\t\t// 左向き\n\t\tcase tank_situation.get(\"Left\"):\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_width; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// 右向き\n\t\tcase tank_situation.get(\"Right\"):\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map.getMap()[0].length - now_width); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width + i] = \".\";\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// 上向き\n\t\tcase tank_situation.get(\"Up\"):\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_height; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"*\")) {\n\n\t\t\t\t\t\tmap.getMap()[now_height - i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// 下向き\n\t\tcase tank_situation.get(\"Down\"):\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.getMap().length - now_height); i++) {\n\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height + i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic Field move(String s, Field map) {\n\n\t\t// ケース分け\n\t\tswitch (s) {\n\n\t\t// 左向き\n\t\tcase \"L\":\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 右向き\n\t\tcase \"R\":\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 下向き\n\t\tcase \"D\":\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\n\t\t\t} else if (map.getMap()[now_height + 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height + 1][now_width] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 上向き\n\t\tcase \"U\":\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height - 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height - 1][now_width] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\n// マップについて扱ったクラス\nclass Field {\n\n\t// マップ構成要素\n\tfinal String[] Map_element = new String[] { \".\", \"*\", \"#\", \"-\" };\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t\t\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, String map_row) {\n\t\t// 一文字づつに変換\n\t\tchar[] map_ele = map_row.toCharArray();\n\t\t// 一文字マップに構成要素を追加していく\n\t\tfor (int w = 0; w < map_ele.length; w++) {\n\t\t\tmap[height_i][w] = String.valueOf(map_ele[w]);\n\t\t}\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic void move_up ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]-1][tank_pos[0]] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]-1][tank_pos[0]] = '^';\n\t\t\ttank_pos[1]--;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '^';\n\t\t}\n\t}\n\n\tstatic void move_down ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]+1][tank_pos[0]] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]+1][tank_pos[0]] = 'v';\n\t\t\ttank_pos[1]++;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = 'v';\n\t\t}\n\t}\n\n\tstatic void move_left ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]][tank_pos[0]-1] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]][tank_pos[0]-1] = '<';\n\t\t\ttank_pos[0]--;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '<';\n\t\t}\n\t}\n\n\tstatic void move_right ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]][tank_pos[0]+1] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]][tank_pos[0]+1] = '>';\n\t\t\ttank_pos[0]++;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '>';\n\t\t}\n\t}\n\n\tstatic void shoot ( char[][] map, int tank_x, int tank_y ) {\n\n\t\tint missile_x = tank_x;\n\t\tint missile_y = tank_y;\n\n\t\twhile ( true ) {\n\t\t\tif ( map[tank_y][tank_x] == '^' ) {\n\t\t\t\tmissile_y--;\n\t\t\t} else if ( map[tank_y][tank_x] == 'v' ) {\n\t\t\t\tmissile_y++;\n\t\t\t} else if ( map[tank_y][tank_x] == '<' ) {\n\t\t\t\tmissile_x--;\n\t\t\t} else if ( map[tank_y][tank_x] == '>' ) {\n\t\t\t\tmissile_x++;\n\t\t\t}\n\n\t\t\tif ( map[missile_y][missile_x] == '*' ) {\n\t\t\t\tmap[missile_y][missile_x] = '.';\n\t\t\t\tbreak;\n\t\t\t} else if( map[missile_y][missile_x] == '#' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\t//データセット数\n\t\tint set_num_T;\n\n\t\tint map_H = 0;\n\t\tint map_W = 0;\n\t\tint input_op_length_N = 0;\n\t\tint[] tank_pos = new int[]{ 0, 0 };\n\t\tString str_buf = \"\";\n\t\tString str_op = \"\";\n\t\tchar[][] map;\n\t\tchar[] tank = new char[]{'^','>','v','<'};\n\n\t\tScanner sc= new Scanner( System.in );\n\n\t\tset_num_T = sc.nextInt();\n\n\t\tfor( int i = 0; i < set_num_T ; i++ ) {\n\n\t\t\t//データ読み込み\n\t\t\tmap_H = sc.nextInt();\n\t\t\tmap_W = sc.nextInt();\n\n\t\t\tmap = new char[map_H+2][map_W+2];\n\n\t\t\t//mapセット mapを#で囲む\n\t\t\tfor ( int j = 0 ; j < map.length ; j++ ) {\n\t\t\t\tfor ( int k = 0 ; k < map[j].length ; k++ ) {\n\t\t\t\t\tif ( ( ( j+1 ) % ( map.length-1 ) ) == 1 || ( ( k+1 ) % ( map[i].length-1 ) ) == 1 ) {\n\t\t\t\t\t\tmap[j][k] = '#';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( k== 1 ) {\n\t\t\t\t\t\t\tstr_buf =sc.next();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmap[j][k]=str_buf.charAt( k-1 );\n\n\t\t\t\t\t\t//読み込みデータが戦車の時、戦車の位置を取得\n\t\t\t\t\t\tfor( int l = 0 ; l < 4 ; l++ ) {\n\t\t\t\t\t\t\tif ( map[j][k] == tank[l] ) {\n\t\t\t\t\t\t\t\ttank_pos[0] = k;\n\t\t\t\t\t\t\t\ttank_pos[1] = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinput_op_length_N = sc.nextInt();\n\t\t\tstr_op = sc.next();\n\n\n\t\t\t//命令に従ってMAPと戦車を書き換える\n\t\t\tfor ( int j = 0 ; j < input_op_length_N; j++) {\n\t\t\t\tswitch( str_op.charAt(j) ) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tmove_up( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tmove_down( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tmove_left( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tmove_right( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tshoot( map, tank_pos[0], tank_pos[1] );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//結果処理\n\t\t\tfor ( int j = 1 ; j < map_H+1 ; j++ ) {\n\t\t\t\tfor ( int k = 1 ; k < map_W+1 ; k++ ) {\n\t\t\t\t\tSystem.out.print( map[j][k] );\n\t\t\t\t}\n\t\t\t\tSystem.out.print( \"\\n\" );\n\t\t\t}\n\n\t\t\tif(i != set_num_T-1) {\n\t\t\t\tSystem.out.print( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\t\t//ArrayList<Field> list = new ArrayList<Field>();\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\tint[] aryArea = new int[2];\n\t\t//?????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\t\t\t//?????£??????????????§??????????????????????´?\n\t\t\taryArea[0] = intHeight;\n\t\t\taryArea[1] = intWidth;\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\t//????????\\???????????????????????????????????????????´?\n\t\t\t\tString[] fieldLine = new String[intWidth];\n\t\t\t\tfieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond,aryArea);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\t\t\t//??????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\n\t\t\tField insField = aryIns[k];\n\t\t\tfor(int j = 0; j < insField.aryArea[0]; j++){\n\n\t\t\t\tfor(int i = 0; i < insField.aryArea[1]; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != aryIns.length-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£??????????????§???????????????????????????*/\n\t\tprivate int[] aryArea;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond ,int[] aryArea){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.aryArea = aryArea;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????£????????????????????¨???????????£??\\\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\t\t\t\t//System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\t\t\t\t//System.out.println(\"tank:\" + j + i);\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\t\t\t//?????£??????????????§??????\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Battle Town\npublic class Main{\n\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\tchar[] c = {'^', '>', 'v', '<'};\n\tint h, w;\n\tchar[][] map;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tfor(int t=0;t<T;t++){\n\t\t\tif(t>0)System.out.println();\n\t\t\th = sc.nextInt(); w = sc.nextInt();\n\t\t\tmap = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)map[i]=sc.next().toCharArray();\n\t\t\tsc.nextInt();\n\t\t\tint pi = -1, pj = -1, d = -1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='^'||map[i][j]=='>'||map[i][j]=='v'||map[i][j]=='<'){\n\t\t\t\t\tfor(d=0;d<4;d++)if(map[i][j]==c[d])break;\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tpi = i; pj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(char cmd:sc.next().toCharArray()){\n\t\t\t\tif(cmd=='S'){\n\t\t\t\t\tint ni = pi, nj = pj;\n\t\t\t\t\twhile(0<=ni&&ni<h&&0<=nj&&nj<w){\n\t\t\t\t\t\tif(map[ni][nj]=='*'){\n\t\t\t\t\t\t\tmap[ni][nj] = '.'; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(map[ni][nj]=='#')break;\n\t\t\t\t\t\tni += move[d][0]; nj += move[d][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\td = cmd=='U'?0:cmd=='R'?1:cmd=='D'?2:3;\n\t\t\t\t\tint ni = pi+move[d][0], nj = pj+move[d][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&map[ni][nj]=='.'){\n\t\t\t\t\t\tpi = ni; pj = nj;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap[pi][pj] = c[d];\n\t\t\tfor(int i=0;i<h;i++)System.out.println(new String(map[i]));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\t\t//ArrayList<Field> list = new ArrayList<Field>();\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\tint[] aryArea = new int[2];\n\t\t//?????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\t\t\t//?????£??????????????§??????????????????????´?\n\t\t\taryArea[0] = intHeight;\n\t\t\taryArea[1] = intWidth;\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\t//????????\\???????????????????????????????????????????´?\n\t\t\t\tString[] fieldLine = new String[intWidth];\n\t\t\t\tfieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\t\t\t//??????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\t//System.out.print(\"intHeight:\" + aryIns[0].field.length);\n\t\t//System.out.println(\" intWidth:\" + aryIns[0].field[0].length);\n\t\t\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\n\t\t\tField insField = aryIns[k];\n\t\t\tint intHeight = insField.field.length;\n\t\t\tint intWidth = insField.field[0].length;\n\t\t\t\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != aryIns.length-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£??????????????§???????????????????????????*/\n\t\tprivate int[] aryArea;\n\t\tint intHeight;\n\t\tint intWidth;\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond ){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.intHeight = field.length;\n\t\t\tthis.intWidth = field[0].length;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????£????????????????????¨???????????£??\\\n\t\t\t//int intHeight = aryArea[0];\n\t\t\t//int intWidth = aryArea[1];\n\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\t\t\t\t//System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\t\t\t\t//System.out.println(\"tank:\" + j + i);\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\t\t\t//?????£??????????????§??????\n\t\t\t//int intHeight = aryArea[0];\n\t\t\t//int intWidth = aryArea[1];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\t//???????????????????????°??????\n\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\t\t\t//?????£??????????????§??????????????????????´?\n\t\t\tint[] aryArea = {intHeight,intWidth};\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tString[] fieldLine = new String[intWidth];\n\t\t\t\tfieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond,aryArea);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\n\t\t\t//?????£??????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(deta != setNum-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£??????????????§???????????????????????????*/\n\t\tprivate int[] aryArea;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond ,int[] aryArea){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.aryArea = aryArea;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????£????????????????????¨???????????£??\\\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\t\t\t\t//System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\t\t\t\t//System.out.println(\"tank:\" + j + i);\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][j] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\t\t\t//?????£??????????????§??????\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\tdata_set--;\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\tif(data_set > 0){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\tstatic ArrayList<String> print = new ArrayList<String>();\n\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\t\tString str;\n\t\tint x;\n\t\tint y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tenum ActionType {\n\t\tU, D, L, R, S;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint dataSetsCount=Integer.parseInt(sc.nextLine());\n\t\tfor(int count=0;count<dataSetsCount;count++) {\n\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\n\t\t\tmap.Print();\n\t\t\tif(count<=dataSetsCount)print.add(\"\\n\");\n\t\t}\n\t\tfor(String str:print) {\n\t\t\tSystem.out.print(str);\n\t\t}\n\n\t}\n\n\tstatic void ExecuteAction(ActionType action) {\n\t\tTank tank = map.tank;\n\t\tTile tile;\n\t\tswitch (action) {\n\t\tcase U:\n\t\t\ttile =map.getTile(tank.X, tank.Y - 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Up;\n\t\t\tbreak;\n\t\tcase D:\n\t\t\ttile =map.getTile(tank.X, tank.Y + 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Down;\n\t\t\tbreak;\n\t\tcase L:\n\t\t\ttile =map.getTile(tank.X-1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Left;\n\t\t\tbreak;\n\t\tcase R:\n\t\t\ttile =map.getTile(tank.X+1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Right;\n\t\t\tbreak;\n\t\tcase S:\n\t\t\tint x = tank.X ;\n\t\t\tint y = tank.Y ;\n\t\t\ttile = map.getTile(x, y);\n\t\t\twhile (tile != null &&( tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\tx += tank.State.x;\n\t\t\t\ty += tank.State.y;\n\t\t\t\ttile = map.getTile(x, y);\n\t\t\t}\n\t\t\tif (tile != null && tile.Type == TileType.Brick) {\n\t\t\t\ttile.Type = TileType.Field;\n\t\t\t\tmap.setTile(x, y, tile);\n\n\t\t\t}\n\n\t\t}\n\t\tmap.tank = tank;\n\t}\n\n\tstatic class Map {\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\n\t\tint[][] coordinate;\n\t\tint height;\n\t\tint width;\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tcoordinate = new int[height][width];\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvoid setTile(int x, int y, Tile tile) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, tile);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\n\t\t\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\t\t\tif (tt.str.equals(line[x])) {\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\t\t\t\t\tif (ts.str.equals(line[x])) {\n\t\t\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Print() {\n\t\t\t\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString str=\"\";\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\tif (tank.Y == y && tank.X == x) {\n\t\t\t\t\t\tstr+=tank.State.str;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTile t = getTile(x, y);\n\t\t\t\t\t\tstr+=t.Type.str;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr+=\"\\n\";\n\t\t\t\tprint.add(str);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Tile {\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\tstatic class Tank {\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = sc.nextInt();\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\t\tfor (int cnt = 0; cnt < data_set; cnt++) {\n\t\t\t// ??????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\t// ???????????????\n\t\t\tint map_width = sc.nextInt();\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tString[][] game_Map = new String[map_height+2][map_width+2];\n\n\t\t\t//??°??????????????¨???????£?????????????\n\t\t\t for (int wall = 0; wall < map_height + 2; wall++) {\n\t                Arrays.fill(game_Map[wall], \"x\");\n\t            }\n\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tint[] tank_pos = new int[2];\n\t\t\tString tank_dir = \"\";\n\n\n\t\t\tsc.nextLine();\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height+1; mh++) {\n\t\t\t\ttmp_row = sc.nextLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw+1] = String.valueOf(tmp_row.charAt(mw));\n\n\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\tString chk_tank = game_Map[mh][mw];\n\t\t\t\t\tif (chk_tank.equals(\"^\") || chk_tank.equals(\"v\") || chk_tank.equals(\"<\") || chk_tank.equals(\">\")) {\n\t\t\t\t\t\ttank_pos[0] = mh;\n\t\t\t\t\t\ttank_pos[1] = mw;\n\t\t\t\t\t\ttank_dir = chk_tank;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????????????????±\n\t\t\tTank tank = new Tank(game_Map, tank_pos, tank_dir);\n\n\t\t\tsc.nextLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = sc.nextLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray()) {\n\t\t\t\ttank.command(cmd);\n\t\t\t}\n\t\t\t// ??????????????¨??°?????\\??????\n\t\t\ttank.tankLastPosition();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t}\n\n\t}// ?????????????????????????????????\n\n\tstatic class Tank {\n\n\t\t/**\n\t\t * ?????????\n\t\t */\n\t\tprivate String[][] map;\n\t\t/**\n\t\t * ??????????????¨??°\n\t\t */\n\t\tprivate int[] pos;\n\t\t/**\n\t\t * ??????\n\t\t */\n\t\tprivate String dir;\n\n\t\t/*\n\t\t * ????????????????????????\n\t\t */\n\t\tTank(String[][] game_Map, int[] tank_pos, String tank_dir) {\n\t\t\tmap = game_Map;\n\t\t\tpos = tank_pos;\n\t\t\tdir = tank_dir;\n\t\t}\n\n\t\t/*\n\t\t * ?§??????????\n\t\t */\n\t\tstatic HashMap<String, String> move_Cmd = new HashMap<String, String>() {\n\t\t\t{\n\t\t\t\t// ?????????????????????\n\t\t\t\tput(\"U\", \"^\");\n\t\t\t\t// ?????????????????????\n\t\t\t\tput(\"D\", \"v\");\n\t\t\t\t// ?????????????????????\n\t\t\t\tput(\"L\", \"<\");\n\t\t\t\t// ?????????????????????\n\t\t\t\tput(\"R\", \">\");\n\t\t\t}\n\t\t};\n\n\t\t/*\n\t\t * ????????¢???\n\t\t */\n\t\tstatic HashMap<String, int[]> move_Dir = new HashMap<String, int[]>() {\n\t\t\t{\n\t\t\t\tput(\"^\", new int[] { -1, 0 });\n\t\t\t\tput(\"v\", new int[] { 1, 0 });\n\t\t\t\tput(\"<\", new int[] { 0, -1 });\n\t\t\t\tput(\">\", new int[] { 0, 1 });\n\t\t\t}\n\t\t};\n\n\t\tvoid command(char cmd) {\n\n\t\t\tif (cmd != 'S') {\n\t\t\t\tmove_tank(String.valueOf(cmd));\n\t\t\t} else {\n\t\t\t\tcannon_Shoot();\n\t\t\t}\n\t\t}\n\n\t\t// ?????????\n\t\tprivate void cannon_Shoot() {\n\t\t\tint[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\t\twhile (true) {\n\t\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\t\tcase \".\":\n\t\t\t\tcase \"-\":\n\t\t\t\t\tcontinue;\n\t\t\t\tcase \"*\":\n\t\t\t\t\tmap[shell[0]][shell[1]] = \".\";\n\t\t\t\tcase \"#\":\n\t\t\t\tcase \"x\":\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\t// ?????????\n\t\tprivate void move_tank(String cmd) {\n\n\t\t\t  this.dir = move_Cmd.get(cmd);\n\t\t        int[] move = new int[]{this.pos[0], this.pos[1]};\n\t\t        move[0] += move_Dir.get(this.dir)[0];\n\t\t        move[1] += move_Dir.get(this.dir)[1];\n\t\t        if (map[move[0]][move[1]] == \".\") {\n\t\t            this.pos[0] = move[0];\n\t\t            this.pos[1] = move[1];\n\t\t        }\n\t\t}\n\n\t\t// // ?????????\n\t\tvoid tankLastPosition() {\n\t\t\tmap[this.pos[0]][this.pos[1]] = this.dir;\n\t\t}\n\n\t}// Tank?????????????????????\n}// ???????????????????????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tif(i != 0){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tfinal int H = sc.nextInt();\n\t\t\tfinal int W = sc.nextInt();\n\t\t\t\n\t\t\tchar[][] map = new char[H+2][W+2];\n\t\t\t\n\t\t\tint p_x = 0, p_y = 0;\n\t\t\t\n\t\t\tfor(int j = 0; j < (H + 2); j++){\n\t\t\t\tchar[] str = null;\n\t\t\t\tif(!(j == 0 || j == H + 1)){\n\t\t\t\t\tstr = sc.next().toCharArray();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < (W + 2); k++){\n\t\t\t\t\tif(j == 0 || j == H + 1 || k == 0 || k == W + 1){\n\t\t\t\t\t\tmap[j][k] = '#';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[j][k] = str[k-1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(map[j][k] == '<' || map[j][k] == '>' || map[j][k] == '^' || map[j][k] == 'v'){\n\t\t\t\t\t\t\tp_x = k;\n\t\t\t\t\t\t\tp_y = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc.next();\n\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\tfor(char c : input){\n\t\t\t\tif(c == 'U'){\n\t\t\t\t\tmap[p_y][p_x] = '^';\n\t\t\t\t\tif(map[p_y-1][p_x] == '.'){\n\t\t\t\t\t\tmap[p_y-1][p_x] = '^';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_y--;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'D'){\n\t\t\t\t\tmap[p_y][p_x] = 'v';\n\t\t\t\t\tif(map[p_y+1][p_x] == '.'){\n\t\t\t\t\t\tmap[p_y+1][p_x] = 'v';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_y++;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'L'){\n\t\t\t\t\tmap[p_y][p_x] = '<';\n\t\t\t\t\tif(map[p_y][p_x-1] == '.'){\n\t\t\t\t\t\tmap[p_y][p_x-1] = '<';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_x--;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'R'){\n\t\t\t\t\tmap[p_y][p_x] = '>';\n\t\t\t\t\tif(map[p_y][p_x+1] == '.'){\n\t\t\t\t\t\tmap[p_y][p_x+1] = '>';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_x++;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'S'){\n\t\t\t\t\tint s_x = 0, s_y = 0;\n\t\t\t\t\t\n\t\t\t\t\tif(map[p_y][p_x] == '^'){\n\t\t\t\t\t\ts_y = -1;\n\t\t\t\t\t}else if(map[p_y][p_x] == 'v'){\n\t\t\t\t\t\ts_y = 1;\n\t\t\t\t\t}else if(map[p_y][p_x] == '<'){\n\t\t\t\t\t\ts_x = -1;\n\t\t\t\t\t}else if(map[p_y][p_x] == '>'){\n\t\t\t\t\t\ts_x = 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint xx = p_x + s_x;\n\t\t\t\t\tint yy = p_y + s_y;\n\t\t\t\t\t\n\t\t\t\t\twhile(!(map[yy][xx] == '*' || map[yy][xx] == '#')){\n\t\t\t\t\t\tyy += s_y;\n\t\t\t\t\t\txx += s_x;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(map[yy][xx] == '*'){\n\t\t\t\t\t\tmap[yy][xx] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 1; j < H + 1; j++){\n\t\t\t\tfor(int k = 1; k < W + 1; k++){\n\t\t\t\t\tSystem.out.print(map[j][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\n\t\tsc = new Scanner(System.in);\n\t\ttry {\n\n\t\t\t//???????????°???????????????\n\t\t\tint input = Integer.parseInt(sc.next());\n\t\t\tfor (int i = 0; i < input; i++) {\n\n\t\t\t\t//??????????????????\n\t\t\t\tint depth = sc.nextInt();\n\t\t\t\tint width = sc.nextInt();\n\t\t\t\tString[][] map = new String[depth][width];\n\t\t\t\tString line = \"\";//sc.nextLine();\n\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t\t}\n\t\t\t\t\t//?????????????????????\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\tString[] list = line.split(\"\");\n\t\t\t\t\t//????????????????´???????\n\t\t\t\t\tfor (int k = 0; k < map[0].length; k++) {\n\t\t\t\t\t\tmap[j][k] = list[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//?????????????????????\n\t\t\t\tint commNum = Integer.parseInt(sc.next());\n\t\t\t\tline = sc.next();\n\t\t\t\tString[] command = line.split(\"\");\n\n\t\t\t\tmap = command(map,command);\n\t\t\t\tfor (String[] gamemap : map) {\n\t\t\t\t\tfor (String cel : gamemap) {\n\t\t\t\t\t\tSystem.out.print(cel);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n\t//???????????????????????????????????????\n\tpublic static String[][] command(String[][] map, String[] comm) {\n\n\t\tint dep = 0;\n\t\tint wid = 0;\n\t\tString player = \"\";\n\t\tString[][] playmap;\n\t\tString[] command;\n\n\t\tplaymap = map;\n\t\tcommand = comm;\n\n\t\t\t//?????????????????¨???????????????\n\t\tfor (int i = 0; i < playmap.length; i++) {\n\t\t\tif (player.equals(\"\")) {\n\n\t\t\t\tfor (int j = 0; j < playmap[0].length; j++) {\n\t\t\t\t\t//?????????????????§??????\n\t\t\t\t\tif (playmap[i][j].equals(\"^\")) {\n\t\t\t\t\t\tplayer = \"^\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"v\")) {\n\t\t\t\t\t\tplayer = \"v\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\">\")) {\n\t\t\t\t\t\tplayer = \">\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"<\")) {\n\t\t\t\t\t\tplayer = \"<\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//?????????????????????\n\t\tfor (int i = 0; i < command.length; i++) {\n\t\t\t//??????????????§????????????\n\t\t\tswitch (command[i]) {\n\t\t\tcase \"U\":\n\t\t\t\tplaymap[dep][wid] = \"^\";\n\t\t\t\tplayer = \"^\";\n\t\t\t\tif (dep != 0 && playmap[dep - 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep - 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tplaymap[dep][wid] = \"v\";\n\t\t\t\tplayer = \"v\";\n\t\t\t\tif (dep != playmap.length - 1 && playmap[dep + 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep + 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"R\":\n\t\t\t\tplaymap[dep][wid] = \">\";\n\t\t\t\tplayer = \">\";\n\t\t\t\tif (wid != playmap[0].length - 1 && playmap[dep][wid + 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid + 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tplaymap[dep][wid] = \"<\";\n\t\t\t\tplayer = \"<\";\n\t\t\t\tif (wid != 0 && playmap[dep][wid - 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid - 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\t//???????????????????????´???\n\t\t\t\tif (player.equals(\"^\")) {\n\t\t\t\t\tint count = dep;\n\t\t\t\t\tfor (int k = 0; k <= dep; k++) {\n\t\t\t\t\t\tif (playmap[count][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[count][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"v\")) {\n\t\t\t\t\tfor (int k = dep; k < playmap.length; k++) {\n\t\t\t\t\t\tif (playmap[k][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[k][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\">\")) {\n\t\t\t\t\tfor (int k = wid; k < playmap[0].length; k++) {\n\t\t\t\t\t\tif (playmap[dep][k].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][k] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][k].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"<\")) {\n\t\t\t\t\tint count = wid;\n\t\t\t\t\tfor (int k = 0; k <= wid; k++) {\n\t\t\t\t\t\tif (playmap[dep][count].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][count] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][count].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"othercCommand\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn playmap;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class BattleTown {\n\tpublic static void main (String args[]){\n\n\t\t//??\\??????????????????????????????Scanner???????????§???????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tint i = 0;\n\n\t\tfor(i = 0; i < T; i++){\n\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tchar[][] map = new char[H][W];\n\n\t\t\t//???0??????1??????2??????3\n\t\t\tchar tank;\n\n\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tString line = sc.next();\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tmap[j][k] = line.charAt(k);\n\n\t\t\t\t\tif(map[j][k] == '^' || map[j][k] == 'v' || map[j][k] == '<' || map[j][k] == '>'){\n\t\t\t\t\t\tif(map[j][k] == '^'){\n\t\t\t\t\t\t\ttank = '^';\n\t\t\t\t\t\t}else if(map[j][k] == 'v'){\n\t\t\t\t\t\t\ttank = 'v';\n\t\t\t\t\t\t}else if(map[j][k] == '<'){\n\t\t\t\t\t\t\ttank = '<';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttank = '>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint t = j;\n\t\t\t\t\t\tint y = k;\n\t\t\t\t\t\tBattle BT = new Battle(t,y,tank,map);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint N = sc.nextInt();\n\t\t\tString com = sc.next();\n\t\t\tchar[] command = new char[N];\n\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tBattle.check(command[j] = com.charAt(j));\n\t\t\t}\n\n\t\t\tSystem.out.print(Battle.output());\n\n\t\t\tif(i != T){\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}\n\nclass Battle{\n\tstatic int tate;\n\tstatic int yoko;\n\tstatic char tank;\n\tstatic char[][] map;\n\n\t//????????\\??????\n\tBattle(int t, int y, char tankk, char[][] mapp){\n\t\ttate = t;\n\t\tyoko = y;\n\t\tmap = mapp;\n\t\ttank = tankk;\n\t}\n\n\tpublic static String output(){\n\t\tStringBuffer str = new StringBuffer();\n\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\tstr.append(map[i][j]);\n\t\t\t}\n\t\t\tstr.append(System.getProperty(\"line.separator\"));\n\t\t}\n\t\tString ans = new String(str);\n\t\treturn ans;\n\t}\n\n\tpublic static void check(char command){\n\n\t\tswitch (command){\n\n\t\tcase 'U':\n\t\t\ttank = '^';\n\t\t\tif(tate > 0){\n\t\t\t\tif(map[tate-1][yoko] == '.'){\n\t\t\t\t\ttate = tate - 1;\n\t\t\t\t\tmap[tate][yoko] = '^';\n\t\t\t\t\tmap[tate+1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\ttank = 'v';\n\t\t\tif((map.length - (tate+1)) > 0){\n\t\t\t\tif(map[tate+1][yoko] == '.'){\n\t\t\t\t\ttate = tate + 1;\n\t\t\t\t\tmap[tate][yoko] = 'v';\n\t\t\t\t\tmap[tate-1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\ttank = '<';\n\t\t\tif(yoko > 0){\n\t\t\t\tif(map[tate][yoko-1] == '.'){\n\t\t\t\t\tyoko = yoko - 1;\n\t\t\t\t\tmap[tate][yoko] = '<';\n\t\t\t\t\tmap[tate][yoko+1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\ttank = '>';\n\t\t\tif((map[tate].length - (yoko+1)) > 0){\n\t\t\t\tif(map[tate][yoko+1] == '.'){\n\t\t\t\t\tyoko = yoko + 1;\n\t\t\t\t\tmap[tate][yoko] = '>';\n\t\t\t\t\tmap[tate][yoko-1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tswitch (tank){\n\t\t\tcase '^':\n\t\t\t\tfor(int i = tate; i >= 0; i--){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tfor(int i = tate; i < map.length; i++){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '<':\n\t\t\t\tfor(int i = yoko; i >= 0; i--){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = -1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tfor(int i = yoko; i < map[tate].length; i++){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = map[tate].length +1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int t, h, w;\n\tstatic char[][] field;\n\tstatic String order;\n\tstatic int[] dx = {0, 1, 0, -1}, dy = {-1, 0, 1, 0};\n\tpublic static void main(String[] args) {\n\t\tread();\n\t\t//solve();\n\t}\n\t\n\tstatic boolean read(){\n\t\tif(!sc.hasNext())return false;\n\t\tt = sc.nextInt();\n\t\tfor(int i = 0; i < t; i++){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tfield = new char[h][w];\n\t\t\tfor(int j = 0; j < field.length; j++){\n\t\t\t\tfield[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint no_use = sc.nextInt();\n\t\t\torder = sc.next();\n\t\t\tsolve();\n\t\t\tif(i != t-1){\n\t\t\t\tprintField();\n\t\t\t}else{\n\t\t\t\tfor(int k = 0; k < field.length; k++){\n\t\t\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\t\t\tSystem.out.print(field[k][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tint sx = 0, sy = 0;\n\t\tchar tank = '-';\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tif(field[i][j] == '^'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '>'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '<'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == 'v'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nx = sx, ny = sy;\n\t\tfor(int i = 0; i < order.length(); i++){\n\t\t\tchar c = order.charAt(i);\n\t\t\tswitch(c){\n\t\t\tcase 'U':\n\t\t\t\ttank = '^';\n\t\t\t\tfield[ny][nx] = tank;\n\t\t\t\tnx += dx[0]; ny += dy[0];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '^';\n\t\t\t\t\tfield[ny-dy[0]][nx-dx[0]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[0]; ny -= dy[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\ttank = 'v';\n\t\t\t\tfield[ny][nx] = tank;\n\t\t\t\tnx += dx[2]; ny += dy[2];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = 'v';\n\t\t\t\t\tfield[ny-dy[2]][nx-dx[2]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[2]; ny -= dy[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttank = '<';\n\t\t\t\tfield[ny][nx] = tank;\n\t\t\t\tnx += dx[3]; ny += dy[3];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '<';\n\t\t\t\t\tfield[ny-dy[3]][nx-dx[3]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[3]; ny -= dy[3];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\ttank = '>';\n\t\t\t\tfield[ny][nx] = tank;\n\t\t\t\tnx += dx[1]; ny += dy[1];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '>';\n\t\t\t\t\tfield[ny-dy[1]][nx-dx[1]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[1]; ny -= dy[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshot(nx, ny, tank);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void printField(){\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic void shot(int x, int y, char t){\n\t\tint vector = 0;\n\t\tswitch(t){\n\t\tcase '^':\n\t\t\tvector = 0; break;\n\t\tcase '>':\n\t\t\tvector = 1; break;\n\t\tcase 'v':\n\t\t\tvector = 2; break;\n\t\tcase '<':\n\t\t\tvector = 3; break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tint nx = x + dx[vector], ny = y + dy[vector];\n\t\twhile(true){\n\t\t\tif(nx < 0 || nx >= field[0].length || ny < 0 || ny >= field.length)break;\n\t\t\tif(field[ny][nx] == '#')break;\n\t\t\tif(field[ny][nx] == '*'){field[ny][nx] = '.'; break;}\n\t\t\tnx += dx[vector]; ny += dy[vector];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main (String args[]){\n\n\t\t//??\\??????????????????????????????Scanner???????????§???????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tint i = 0;\n\n\t\tfor(i = 0; i < T; i++){\n\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tchar[][] map = new char[H][W];\n\n\t\t\t//???0??????1??????2??????3\n\t\t\tchar tank;\n\n\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tString line = sc.next();\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tmap[j][k] = line.charAt(k);\n\n\t\t\t\t\tif(map[j][k] == '^' || map[j][k] == 'v' || map[j][k] == '<' || map[j][k] == '>'){\n\t\t\t\t\t\tif(map[j][k] == '^'){\n\t\t\t\t\t\t\ttank = '^';\n\t\t\t\t\t\t}else if(map[j][k] == 'v'){\n\t\t\t\t\t\t\ttank = 'v';\n\t\t\t\t\t\t}else if(map[j][k] == '<'){\n\t\t\t\t\t\t\ttank = '<';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttank = '>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint t = j;\n\t\t\t\t\t\tint y = k;\n\t\t\t\t\t\tBattle BT = new Battle(t,y,tank,map);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint N = sc.nextInt();\n\t\t\tString com = sc.next();\n\t\t\tchar[] command = new char[N];\n\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tBattle.check(command[j] = com.charAt(j));\n\t\t\t}\n\n\t\t\tSystem.out.println(Battle.output());\n\n\t\t\tif(i != T){\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}\n\nclass Battle{\n\tstatic int tate;\n\tstatic int yoko;\n\tstatic char tank;\n\tstatic char[][] map;\n\n\t//????????\\??????\n\tBattle(int t, int y, char tankk, char[][] mapp){\n\t\ttate = t;\n\t\tyoko = y;\n\t\tmap = mapp;\n\t\ttank = tankk;\n\t}\n\n\tpublic static String output(){\n\t\tStringBuffer str = new StringBuffer();\n\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\tstr.append(map[i][j]);\n\t\t\t}\n\t\t\tstr.append(System.getProperty(\"line.separator\"));\n\t\t}\n\t\tString ans = new String(str);\n\t\treturn ans;\n\t}\n\n\tpublic static void check(char command){\n\n\t\tswitch (command){\n\n\t\tcase 'U':\n\t\t\ttank = '^';\n\t\t\tif(tate > 0){\n\t\t\t\tif(map[tate-1][yoko] == '.'){\n\t\t\t\t\ttate = tate - 1;\n\t\t\t\t\tmap[tate][yoko] = '^';\n\t\t\t\t\tmap[tate+1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\ttank = 'v';\n\t\t\tif((map.length - tate+1) > 0){\n\t\t\t\tif(map[tate+1][yoko] == '.'){\n\t\t\t\t\ttate = tate + 1;\n\t\t\t\t\tmap[tate][yoko] = 'v';\n\t\t\t\t\tmap[tate-1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\ttank = '<';\n\t\t\tif(yoko > 0){\n\t\t\t\tif(map[tate][yoko-1] == '.'){\n\t\t\t\t\tyoko = yoko - 1;\n\t\t\t\t\tmap[tate][yoko] = '<';\n\t\t\t\t\tmap[tate][yoko+1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\ttank = '>';\n\t\t\tif((map[tate].length - (yoko+1)) > 0){\n\t\t\t\tif(map[tate][yoko+1] == '.'){\n\t\t\t\t\tyoko = yoko + 1;\n\t\t\t\t\tmap[tate][yoko] = '>';\n\t\t\t\t\tmap[tate][yoko-1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tswitch (tank){\n\t\t\tcase '^':\n\t\t\t\tfor(int i = tate; i >= 0; i--){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tfor(int i = tate; i < map.length; i++){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '<':\n\t\t\t\tfor(int i = yoko; i >= 0; i--){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = -1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tfor(int i = yoko; i < map[tate].length; i++){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = map[tate].length +1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tint tankPositionH = 0;\n\t\t\tint tankPositionW = 0;\n\n\t\t\tfor(int j = 0; j < height; j++) {\n\n\t\t\t\tfor(int k = 0; k < width; k++) {\n\n\t\t\t\t\tif(townMap[j][k].equals(\"^\") || townMap[j][k].equals(\"v\")\n\t\t\t\t\t\t\t|| townMap[j][k].equals(\"<\") || townMap[j][k].equals(\">\")) {\n\n\t\t\t\t\t\ttankPositionH = j;\n\t\t\t\t\t\ttankPositionW = k;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ?????????????????????????????§??????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\tString direction = tank.changeDirection(commandArray[j]);\n\n\t\t\t\t\t// ????????????????????????????????¨??????????????´\n\t\t\t\t\tswitch(direction) {\n\n\t\t\t\t\tcase \"^\":\n\n\t\t\t\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"v\":\n\n\t\t\t\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"<\":\n\n\t\t\t\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \">\":\n\n\t\t\t\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n\n// ???????????????\nclass Tank{\n\n\t// ?????????????????????????????????\n\tString changeDirection(char command){\n\n\t\tString direction = null;\n\n\t\tswitch(command){\n\n\t\tcase 'U':\n\n\t\t\tdirection = \"^\";\n\t\t\tbreak;\n\n\t\tcase 'D':\n\n\t\t\tdirection = \"v\";\n\t\t\tbreak;\n\n\t\tcase 'L':\n\n\t\t\tdirection = \"<\";\n\t\t\tbreak;\n\n\t\tcase 'R':\n\n\t\t\tdirection = \">\";\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn direction;\n\n\t}\n\n\tvoid shoot(String[][] townMap, int height, int width, int tankPositionH, int tankPositionW) {\n\n\t\tswitch(townMap[tankPositionH][tankPositionW]) {\n\n\t\tcase \"^\":\n\n\t\t\tfor(int i = tankPositionH - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPositionH + 1; i < height; i++) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPositionW - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPositionW + 1; i < width; i++) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ?????????????????????????????£????????????????????§???????????????\n\t\t\tField field = new Field(townMap);\n\t\t\t// ??????????????????????????????\n\t\t\tint[] tankPosition = field.getPosition();\n\t\t\t// ????????????????????????\n\t\t\tString tankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank(tankPosition, tankDirection);\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(tankDirection, field);\n\n\t\t\t\t// ?§???????????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ???????§????????????????\n\t\t\t\t\ttank.move(commandArray[j], field);\n\t\t\t\t\t// ?§?????????????????????????????????´??°\n\t\t\t\t\ttankPosition = field.getPosition();\n\t\t\t\t\t// ?§?????????????????????????????????´??°\n\t\t\t\t\ttankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ?????£??????????????????\nclass Field{\n\n\t// ?????£??????????????°\n\tString[][] field;\n\n\t// ?????????????????????\n\tField(String[][] field){\n\n\t\tthis.field = new String[field.length][];\n\n\t\tfor(int i = 0; i < field.length; i++) {\n\n\t\t\tthis.field[i] = field[i];\n\n\t\t\tfor(int j = 0; j < field[i].length; j++) {\n\n\t\t\t\tthis.field[i][j] = field[i][j];\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// ??????????????????????´¢??????????????????\n\tint[] getPosition() {\n\n\t\tint[] tankPosition = new int[2];\n\n\t\tfor(int i = 0; i < this.field.length; i++) {\n\n\t\t\tfor(int j = 0; j < this.field[i].length; j++) {\n\n\t\t\t\tif(field[i][j].equals(\"^\") || field[i][j].equals(\"v\")\n\t\t\t\t\t\t|| field[i][j].equals(\"<\") || field[i][j].equals(\">\")) {\n\n\t\t\t\t\ttankPosition[0] = i;\n\t\t\t\t\ttankPosition[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tankPosition;\n\n\t}\n}\n\n// ???????????????\nclass Tank{\n\n\t// ?????£??????????????°\n\tint[] tankPosition = new int[2];\n\tString tankDirection;\n\n\t// ?????????????????????\n\tTank(int[] tankPosition, String tankDirection) {\n\n\t\tthis.tankPosition[0] = tankPosition[0];\n\t\tthis.tankPosition[1] = tankPosition[1];\n\t\tthis.tankDirection = tankDirection;\n\t}\n\n\t// ??????????§??????????????????????\n\tvoid move(char command, Field field) {\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command) {\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != 0 && field.field[tankPosition[0] - 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] - 1][tankPosition[1]] = \"^\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[0] = tankPosition[0] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"^\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'D':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != field.field.length - 1 && field.field[tankPosition[0] + 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] + 1][tankPosition[1]] = \"v\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[0] = tankPosition[0] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"v\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'L':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != 0 && field.field[tankPosition[0]][tankPosition[1] - 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] - 1] = \"<\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[1] = tankPosition[1] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"<\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'R':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != field.field[0].length - 1 && field.field[tankPosition[0]][tankPosition[1] + 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] + 1] = \">\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[1] = tankPosition[1] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \">\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\t// ???????????????????????????\n\tvoid shoot(String tankDirection, Field field) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(tankDirection) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPosition[0] - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPosition[0] + 1; i < field.field.length; i++) {\n\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPosition[1] - 1; i >= 0; i--) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPosition[1] + 1; i < field.field[0].length; i++) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}\n\n\n//===========================??????=============================================\n\n/*public class MainBatlleTown {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tint tankPositionH = 0;\n\t\t\tint tankPositionW = 0;\n\n\t\t\tfor(int j = 0; j < height; j++) {\n\n\t\t\t\tfor(int k = 0; k < width; k++) {\n\n\t\t\t\t\tif(townMap[j][k].equals(\"^\") || townMap[j][k].equals(\"v\")\n\t\t\t\t\t\t\t|| townMap[j][k].equals(\"<\") || townMap[j][k].equals(\">\")) {\n\n\t\t\t\t\t\ttankPositionH = j;\n\t\t\t\t\t\ttankPositionW = k;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t// ??????????§?????????´???\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?????????)\n\t\t\t\t\ttankPositionH = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t// ?¨????????§?????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?¨???????)\n\t\t\t\t\ttankPositionW = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// ???????????????\nclass Tank{\n\n\t// ??????????§??????????????????????\n\tint move(char command, String[][] townMap, int height, int width, int tankPositionH, int tankPositionW){\n\n\t\t// ?????????(??????????????¨??°)?????\\???????????°\n\t\tint tankPosition = 0;\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command){\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t// ?????¨??°????????????????????????????????????????????????\n\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°????????°???????????????\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t// ?§???????????????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH - 1;\n\n\t\t\t// ???????????°?????????????????°?????????????????´\n\t\t\t} else {\n\n\t\t\t\t// ???????????´\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ???????§????????????????\n\t\tcase 'D':\n\n\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionH + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'L':\n\n\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW - 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'R':\n\n\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// ?????´??????????????¨??°???????????????\n\t\treturn tankPosition;\n\n\t}\n\n\n\t// ???????????????????????????\n\tvoid shoot(String[][] townMap, int height, int width, int tankPositionH, int tankPositionW) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(townMap[tankPositionH][tankPositionW]) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPositionH - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°??????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPositionH + 1; i < height; i++) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPositionW - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPositionW + 1; i < width; i++) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}*/\n\n//=======================================================================\n\n\t\t\t//???????????°?????????????????????\n\t\t\t/*for(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ?????????????????????????????§??????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\t// String direction = tank.changeDirection(commandArray[j]);\n\t\t\t\t\ttankPositionH = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttankPositionW = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t\t// ????????????????????????????????¨??????????????´\n\t\t\t\t\tswitch(direction) {\n\n\t\t\t\t\tcase \"^\":\n\n\t\t\t\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"v\":\n\n\t\t\t\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"<\":\n\n\t\t\t\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \">\":\n\n\t\t\t\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}*/\n\n\n\t\t\t\t//String direction = tank.changeDirection(commandArray[j]);\n\n\t\t\t\t//String direction = null;\n\n\t\t\t\t/*\n\t\t\t\tswitch(direction){\n\t\t\t\tcase 'U':\n\n\t\t\t\t\tdirection = \"^\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'D':\n\n\t\t\t\t\tdirection = \"v\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'L':\n\n\t\t\t\t\tdirection = \"<\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'R':\n\n\t\t\t\t\tdirection = \">\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn direction;\n\n\t\t\t}*/"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int t, h, w;\n\tstatic char[][] field;\n\tstatic String order;\n\tstatic int[] dx = {0, 1, 0, -1}, dy = {-1, 0, 1, 0};\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\t//solve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tif(!sc.hasNext())return false;\n\t\tt = sc.nextInt();\n\t\tfor(int i = 0; i < t; i++){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tfield = new char[h][w];\n\t\t\tfor(int j = 0; j < field.length; j++){\n\t\t\t\tfield[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint no_use = sc.nextInt();\n\t\t\torder = sc.next();\n\t\t\tsolve();\n\t\t\tif(i != t-1){\n\t\t\t\tprintField();\n\t\t\t}else{\n\t\t\t\tfor(int k = 0; k < field.length; k++){\n\t\t\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\t\t\tSystem.out.print(field[k][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tint sx = 0, sy = 0;\n\t\tchar tank = '-';\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tif(field[i][j] == '^'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '>'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '<'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == 'v'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nx = sx, ny = sy;\n\t\tfor(int i = 0; i < order.length(); i++){\n\t\t\tchar c = order.charAt(i);\n\t\t\tswitch(c){\n\t\t\tcase 'U':\n\t\t\t\ttank = '^';\n\t\t\t\tnx += dx[0]; ny += dy[0];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '^';\n\t\t\t\t\tfield[ny-dy[0]][nx-dx[0]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[0]; ny -= dy[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\ttank = 'v';\n\t\t\t\tnx += dx[2]; ny += dy[2];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = 'v';\n\t\t\t\t\tfield[ny-dy[2]][nx-dx[2]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[2]; ny -= dy[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttank = '<';\n\t\t\t\tnx += dx[3]; ny += dy[3];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '<';\n\t\t\t\t\tfield[ny-dy[3]][nx-dx[3]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[3]; ny -= dy[3];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\ttank = '>';\n\t\t\t\tnx += dx[1]; ny += dy[1];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '>';\n\t\t\t\t\tfield[ny-dy[1]][nx-dx[1]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[1]; ny -= dy[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshot(nx, ny, tank);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void printField(){\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic void shot(int x, int y, char t){\n\t\tint vector = 0;\n\t\tswitch(t){\n\t\tcase '^':\n\t\t\tvector = 0; break;\n\t\tcase '>':\n\t\t\tvector = 1; break;\n\t\tcase 'v':\n\t\t\tvector = 2; break;\n\t\tcase '<':\n\t\t\tvector = 3; break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tint nx = x + dx[vector], ny = y + dy[vector];\n\t\twhile(true){\n\t\t\tif(nx < 0 || nx >= field[0].length || ny < 0 || ny >= field.length)break;\n\t\t\tif(field[ny][nx] == '#')break;\n\t\t\tif(field[ny][nx] == '*'){field[ny][nx] = '.'; break;}\n\t\t\tnx += dx[vector]; ny += dy[vector];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tString[][] map = new String[h][w];\n\t\t\tint[] x = new int[2];\n\t\t\tsc.nextLine();\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\t\tmap[j][k] = String.valueOf(s.charAt(k));\n\t\t\t\t\tString _s = map[j][k];\n\t\t\t\t\tif(_s.equals(\"^\") || _s.equals(\"v\") || _s.equals(\"<\") || _s.equals(\">\")){\n\t\t\t\t\t\tx[0] = j;\n\t\t\t\t\t\tx[1] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tString[] command = new String[n];\n\t\t\tsc.nextLine();\n\t\t\tString s = sc.nextLine();\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcommand[j] = String.valueOf(s.charAt(j));\n\t\t\t}\n\t\t\tplay(map, x, command);\n\t\t\tif(i < t-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic void play(String[][] map, int[] x, String[] command){\n\t\tfor(int i = 0; i < command.length; i++){\n\t\t\tif(command[i].equals(\"S\")){\n\t\t\t\tshoot(map, x);\n\t\t\t}else{\n\t\t\t\tmove(map, x, command[i]);\n\t\t\t}\n\t\t}\n\t\tprintMap(map);\n\t}\n\tstatic void move(String[][] map,int[] x, String s){\n\t\tint[] v = new int[2];\n\t\tif(s.equals(\"U\")){\n\t\t\tv[0] = -1;\n\t\t}else if(s.equals(\"D\")){\n\t\t\tv[0] = 1;\n\t\t}else if(s.equals(\"L\")){\n\t\t\tv[1] = -1;\n\t\t}else{\n\t\t\tv[1] = 1;\n\t\t}\n\t\tint[] nx = {x[0]+v[0], x[1]+v[1]};\n\t\tif(isInMap(map, nx) && map[nx[0]][nx[1]].equals(\".\")){\n\t\t\tmap[nx[0]][nx[1]] = v2p(v);\n\t\t\tmap[x[0]][x[1]] = \".\";\n\t\t\tx = nx;\n\t\t}else{\n\t\t\tmap[x[0]][x[1]] = v2p(v);\n\t\t}\n\n\t}\n\tstatic String v2p(int[] v){\n\t\tif(v[0] == 0){\n\t\t\tif(v[1] == 1){\n\t\t\t\treturn \">\";\n\t\t\t}else{\n\t\t\t\treturn \"<\";\n\t\t\t}\n\t\t}else if(v[0] == -1){\n\t\t\treturn \"^\";\n\t\t}else{\n\t\t\treturn \"v\";\n\t\t}\n\t}\n\tstatic void shoot(String[][] map, int[] x){\n\t\tint[] v = new int[2];\n\t\tString s = map[x[0]][x[1]];\n\t\tif(s.equals(\"^\")){\n\t\t\tv[0] = -1;\n\t\t}else if(s.equals(\"v\")){\n\t\t\tv[0] = 1;\n\t\t}else if(s.equals(\"<\")){\n\t\t\tv[1] = -1;\n\t\t}else{\n\t\t\tv[1] = 1;\n\t\t}\n\t\tint[] bx = {x[0], x[1]};\n\t\twhile(isInMap(map, bx) && (!map[bx[0]][bx[1]].equals(\"*\") && !map[bx[0]][bx[1]].equals(\"#\"))){\n\t\t\tbx[0] += v[0];\n\t\t\tbx[1] += v[1];\n\t\t}\n\t\tif(isInMap(map, bx)){\n\t\t\tif(map[bx[0]][bx[1]].equals(\"*\")){\n\t\t\t\tmap[bx[0]][bx[1]] = \".\";\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean isInMap(String[][] map, int[] x){\n\t\treturn 0 <= x[0] && x[0] < map.length && 0 <= x[1] && x[1] < map[0].length;\n\t}\n\tstatic void printMap(String[][] map){\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tfor(int j = 0; j < map[0].length; j++){\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ?????£????????????????????§????????????\n\t\t\tField field = new Field(townMap);\n\t\t\t// ??????????????????????????????\n\t\t\tint[] tankPosition = field.tankPosition();\n\t\t\t// ????????????????????????\n\t\t\tString tankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank(tankPosition, tankDirection);\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(tankDirection, field);\n\n\t\t\t\t// ?§???????????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ???????§????????????????\n\t\t\t\t\ttank.move(commandArray[j], field);\n\t\t\t\t\ttankPosition = field.tankPosition();\n\t\t\t\t\ttankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ?????£??????????????????\nclass Field{\n\n\t// ?????£??????????????°\n\tString[][] field;\n\n\t// ?????????????????????\n\tField(String[][] field){\n\n\t\tthis.field = new String[field.length][];\n\n\t\tfor(int i = 0; i < field.length; i++) {\n\n\t\t\tthis.field[i] = field[i];\n\n\t\t\tfor(int j = 0; j < field[i].length; j++) {\n\n\t\t\t\tthis.field[i][j] = field[i][j];\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// ??????????????????????´¢??????????????????\n\tint[] tankPosition() {\n\n\t\tint[] tankPosition = new int[2];\n\n\t\tfor(int i = 0; i < this.field.length; i++) {\n\n\t\t\tfor(int j = 0; j < this.field[i].length; j++) {\n\n\t\t\t\tif(field[i][j].equals(\"^\") || field[i][j].equals(\"v\")\n\t\t\t\t\t\t|| field[i][j].equals(\"<\") || field[i][j].equals(\">\")) {\n\n\t\t\t\t\ttankPosition[0] = i;\n\t\t\t\t\ttankPosition[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tankPosition;\n\n\t}\n}\n\n// ???????????????\nclass Tank{\n\n\t// ?????£??????????????°\n\tint[] tankPosition = new int[2];\n\tString tankDirection;\n\n\t// ?????????????????????\n\tTank(int[] tankPosition, String tankDirection) {\n\n\t\tthis.tankPosition[0] = tankPosition[0];\n\t\tthis.tankPosition[1] = tankPosition[1];\n\t\tthis.tankDirection = tankDirection;\n\t}\n\n\t// ??????????§??????????????????????\n\tvoid move(char command, Field field) {\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command) {\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != 0 && field.field[tankPosition[0] - 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] - 1][tankPosition[1]] = \"^\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[0] = tankPosition[0] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"^\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'D':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != field.field.length && field.field[tankPosition[0] + 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] + 1][tankPosition[1]] = \"v\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[0] = tankPosition[0] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"v\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'L':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != 0 && field.field[tankPosition[0]][tankPosition[1] - 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] - 1] = \"<\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[1] = tankPosition[1] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"<\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'R':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != field.field[0].length && field.field[tankPosition[0]][tankPosition[1] + 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] + 1] = \">\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[1] = tankPosition[1] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \">\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\t// ???????????????????????????\n\tvoid shoot(String tankDirection, Field field) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(tankDirection) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPosition[0] - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPosition[0] + 1; i < field.field.length; i++) {\n\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPosition[1] - 1; i >= 0; i--) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPosition[1] + 1; i < field.field[0].length; i++) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}\n\n\n//===========================??????=============================================\n\n/*public class MainBatlleTown {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tint tankPositionH = 0;\n\t\t\tint tankPositionW = 0;\n\n\t\t\tfor(int j = 0; j < height; j++) {\n\n\t\t\t\tfor(int k = 0; k < width; k++) {\n\n\t\t\t\t\tif(townMap[j][k].equals(\"^\") || townMap[j][k].equals(\"v\")\n\t\t\t\t\t\t\t|| townMap[j][k].equals(\"<\") || townMap[j][k].equals(\">\")) {\n\n\t\t\t\t\t\ttankPositionH = j;\n\t\t\t\t\t\ttankPositionW = k;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t// ??????????§?????????´???\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?????????)\n\t\t\t\t\ttankPositionH = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t// ?¨????????§?????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?¨???????)\n\t\t\t\t\ttankPositionW = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// ???????????????\nclass Tank{\n\n\t// ??????????§??????????????????????\n\tint move(char command, String[][] townMap, int height, int width, int tankPositionH, int tankPositionW){\n\n\t\t// ?????????(??????????????¨??°)?????\\???????????°\n\t\tint tankPosition = 0;\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command){\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t// ?????¨??°????????????????????????????????????????????????\n\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°????????°???????????????\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t// ?§???????????????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH - 1;\n\n\t\t\t// ???????????°?????????????????°?????????????????´\n\t\t\t} else {\n\n\t\t\t\t// ???????????´\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ???????§????????????????\n\t\tcase 'D':\n\n\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionH + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'L':\n\n\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW - 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'R':\n\n\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// ?????´??????????????¨??°???????????????\n\t\treturn tankPosition;\n\n\t}\n\n\n\t// ???????????????????????????\n\tvoid shoot(String[][] townMap, int height, int width, int tankPositionH, int tankPositionW) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(townMap[tankPositionH][tankPositionW]) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPositionH - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°??????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPositionH + 1; i < height; i++) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPositionW - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPositionW + 1; i < width; i++) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}*/\n\n//=======================================================================\n\n\t\t\t//???????????°?????????????????????\n\t\t\t/*for(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ?????????????????????????????§??????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\t// String direction = tank.changeDirection(commandArray[j]);\n\t\t\t\t\ttankPositionH = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttankPositionW = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t\t// ????????????????????????????????¨??????????????´\n\t\t\t\t\tswitch(direction) {\n\n\t\t\t\t\tcase \"^\":\n\n\t\t\t\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"v\":\n\n\t\t\t\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"<\":\n\n\t\t\t\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \">\":\n\n\t\t\t\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}*/\n\n\n\t\t\t\t//String direction = tank.changeDirection(commandArray[j]);\n\n\t\t\t\t//String direction = null;\n\n\t\t\t\t/*\n\t\t\t\tswitch(direction){\n\t\t\t\tcase 'U':\n\n\t\t\t\t\tdirection = \"^\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'D':\n\n\t\t\t\t\tdirection = \"v\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'L':\n\n\t\t\t\t\tdirection = \"<\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'R':\n\n\t\t\t\t\tdirection = \">\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn direction;\n\n\t\t\t}*/"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// ?????????????§???????????????????\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ????????????????????????\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tTank2[][] game_Map = new Tank2[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank2 tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], new Tank2('W'));\n\t\t\t}\n\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2(tmp_row.charAt(mw));\n\n\t\t\t\t\tif(\"^v<>\".indexOf(game_Map[mh][mw + 1].getMap_info()) > -1){\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank2(game_Map[mh][mw + 1].getMap_info(), new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\tcommand(tank, game_Map, cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void command(Tank2 tank, Tank2[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ??????????????±?????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] next = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tnext[0] += tank.getDir_Map().get(tank.getDir())[0];\n\t\t\tnext[1] += tank.getDir_Map().get(tank.getDir())[1];\n\t\t\t// ?????°???????§??????????\n\t\t\tif (game_Map[next[0]][next[1]].getMap_info() == '.') {\n\t\t\t\ttank.setPos(next);\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\twhile (true) {\n\t\t\t\tshell[0] += tank.getDir_Map().get(tank.getDir())[0];\n\t\t\t\tshell[1] += tank.getDir_Map().get(tank.getDir())[1];\n\t\t\t\tswitch (game_Map[shell[0]][shell[1]].getMap_info()) {\n\t\t\t\tcase '.':\n\t\t\t\tcase '-':\n\t\t\t\t\tcontinue;\n\t\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\t\tcase '*':\n\t\t\t\t\tgame_Map[shell[0]][shell[1]] = new Tank2('.');\n\t\t\t\tcase '#':\n\t\t\t\tcase 'W':\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}// command????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t *\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t */\n\tprivate static void last_tankLocate(Tank2 tank, Tank2[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Tank2(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n}\n\nclass Tank2 {\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/*\n\t * ???????????????????????????????????????\n\t */\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\t/*\n\t * ????????????????????????\n\t */\n\tpublic Tank2(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Tank2(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// tank2 ?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\n\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\n\t\t// ??????????????????????????????\n\t\tswitch (tank.getDir()) {\n\t\t// ('^', { -1, 0 });\n\t\tcase '^':\n\t\t\tfor (int cnt = pos[0]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[cnt][pos[1]] == '*') {\n\t\t\t\t\tgame_Map[cnt][pos[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[cnt][pos[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('v',{ 1, 0 });\n\t\tcase 'v':\n\t\t\tfor (int cnt = 1; cnt < game_Map[0].length - pos[0]; cnt++) {\n\t\t\t\tif (game_Map[pos[0] + cnt][pos[1]] == '*') {\n\t\t\t\t\tgame_Map[pos[0] + cnt][pos[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0] + cnt][pos[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('<', { 0, -1 });\n\t\tcase '<':\n\t\t\tfor (int cnt = pos[1]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[pos[0]][cnt] == '*') {\n\t\t\t\t\tgame_Map[pos[0]][cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0]][cnt] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('>', { 0, 1 });\n\t\tcase '>':\n\t\t\tfor (int cnt = 1; cnt < game_Map[1].length - pos[1]; cnt++) {\n\t\t\t\tif (game_Map[pos[0]][pos[1] + cnt] == '*') {\n\t\t\t\t\tgame_Map[pos[0]][pos[1] + cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0]][pos[1] + cnt] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}// canon_Shot????????????????????????\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\n\t\tif(tank.getDir() == '^'){\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0]--;\n\t\t\t}\n\t\t}else if (tank.getDir() == 'v'){\n\t\t\tif (move[0] + 1 < game_Map[0].length) {\n\t\t\t\tmove[0]++;\n\t\t\t}\n\t\t}else if (tank.getDir() == '<'){\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1]--;\n\t\t\t}\n\t\t}else if (tank.getDir() == '>'){\n\t\t\tif (move[1] + 1 < game_Map[1].length) {\n\t\t\t\tmove[1]++;\n\t\t\t}\n\t\t}\n\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\ttank.setPos(move);\n\t\t}\n\n\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// ?????????????§???????????????????\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ????????????????????????\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\n\t\t\tString[] trans_row = tmp_row.split(\" \");\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = Integer.parseInt(trans_row[0]);\n\t\t\tint map_width = Integer.parseInt(trans_row[1]);\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tTank2[][] game_Map = new Tank2[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank2 tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], new Tank2('W'));\n\t\t\t}\n\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2(tmp_row.charAt(mw));\n\n\t\t\t\t\tif(\"^v<>\".indexOf(game_Map[mh][mw + 1].getMap_info()) > -1){\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank2(game_Map[mh][mw + 1].getMap_info(), new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\ttank_Action(tank, game_Map, cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank2 tank, Tank2[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ??????????????±?????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tmove[0] += tank.getDir_Map().get(tank.getDir())[0];\n\t\t\tmove[1] += tank.getDir_Map().get(tank.getDir())[1];\n\t\t\t// ?????°???????§??????????\n\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\ttank.setPos(move);\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\twhile (true) {\n\t\t\t\tshell[0] += tank.getDir_Map().get(tank.getDir())[0];\n\t\t\t\tshell[1] += tank.getDir_Map().get(tank.getDir())[1];\n\t\t\t\tswitch (game_Map[shell[0]][shell[1]].getMap_info()) {\n\t\t\t\tcase '.':\n\t\t\t\tcase '-':\n\t\t\t\t\tcontinue;\n\t\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\t\tcase '*':\n\t\t\t\t\tgame_Map[shell[0]][shell[1]] = new Tank2('.');\n\t\t\t\tcase '#':\n\t\t\t\tcase 'W':\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}// command????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank2 tank, Tank2[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Tank2(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n}\n\nclass Tank2 {\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/*\n\t * ???????????????????????????????????????\n\t */\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\t/*\n\t * ????????????????????????\n\t */\n\tpublic Tank2(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Tank2(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// tank2 ?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int w, h;\n    char[][] map;\n    int[] dx = {0, 0, -1, 1};\n    int[] dy = {-1, 1, 0, 0};\n    char[] dirc = {'^', 'v', '<', '>'};\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int dataNum = sc.nextInt();\n        while(dataNum-->0){\n            h = sc.nextInt(); w = sc.nextInt();\n            map = new char[h][w];\n\n            int x = 0, y = 0, dir = 0;\n\n            for(int i=0; i<h; i++){\n                char[] line = sc.next().toCharArray();\n                for(int j=0; j<w; j++){\n                    map[i][j] = line[j];\n                    if(map[i][j]=='^'){ x = j; y = i; dir = 0;}\n                    if(map[i][j]=='v'){ x = j; y = i; dir = 1;}\n                    if(map[i][j]=='<'){ x = j; y = i; dir = 2;}\n                    if(map[i][j]=='>'){ x = j; y = i; dir = 3;}\n                }\n            }\n\n            int n = sc.nextInt();\n            char[] command = sc.next().toCharArray();\n            for(int i=0; i<n; i++){\n                if(command[i]=='U') dir = 0;\n                if(command[i]=='D') dir = 1;\n                if(command[i]=='L') dir = 2;\n                if(command[i]=='R') dir = 3;\n                if(command[i]!='S'){\n                    int nx = x + dx[dir], ny = y + dy[dir];\n                    if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                    if(map[ny][nx]=='.'){\n                        map[ny][nx] = dirc[dir];\n                        map[y][x] = '.';\n                        x = nx; y = ny;\n                    }\n                }\n                if(command[i]=='S'){\n                    int nx = x, ny = y;\n                    while(true){\n                        nx += dx[dir]; ny += dy[dir];\n                        if(nx<0 || nx>=w || ny<0 || ny>=h || map[ny][nx]=='#') break;\n                        if(map[ny][nx]=='*'){\n                            map[ny][nx] = '.';\n                            break;\n                        }\n                    }\n                }                \n            }\n            for(int i=0; i<h; i++) System.out.println(String.valueOf(map[i]));\n            if(dataNum!=0) System.out.println();\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ??????????????????????????±?????¶???????????????\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§???????????????????????????????????????????\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ????????????????????¨?????????????????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('U', '^');\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// ('D', 'v');\n\t\t\t// ('v', { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('L', '<');\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('R', '>');\n\t\t\t// ('>',{ 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\t// ??????????????????????????????\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('v',{ 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('>', { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ??????????????????????????±?????¶???????????????\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ????????????????????¨?????????????????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('U', '^');\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// ('D', 'v');\n\t\t\t// ('v', { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('L', '<');\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('R', '>');\n\t\t\t// ('>',{ 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\t// ??????????????????????????????\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('v',{ 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('>', { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\t\tSystem.out.println();\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);String o,e=\"\";for(int t=s.nextInt(),i,j,p,q,d,h,w;t-->0;){char[]m=new char[(h=s.nextInt())*(w=s.nextInt()+2)],x,a={60,62,94,118},b={76,82,85,68};int[]r={-1,1,-w,w};for(i=p=0;i<h;++i)for(j=0,x=s.next().toCharArray();j<w-2;++j)for(q=0;q<4;++q)if(a[q]==(m[i*w+j+1]=x[j]))p=i*w+j+1;s.next();o=s.next();for(char c:o.toCharArray())if(c==83){for(i=0;a[i]!=m[p];++i);d=r[i];for(q=p+d;0<q&&q<h*w&&(m[q]==45||m[q]==46);q+=d);if(0<q&&q<h*w&&m[q]==42)m[q]=46;}else for(i=4;i-->0;)if(c==b[i]){d=r[i];q=p+d;if(!(0<q&&q<h*w&&m[q]==46))q-=d;m[p]=46;m[p=q]=a[i];}for(i=0;i<h;++i,e+=\"\\n\")for(j=1;j<w-1;++j)e+=m[i*w+j];e+=\"\\n\";}System.out.println(e.replaceAll(\"\\n$\",\"\"));}}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t// マップ\n\n\t// 戦車\n\tclass Tank {\n\n\t\tchar[][] map;\n\n\t\tint x, y; \t  // 座標\n\t\tchar dir; \t  // 向いてる方角\n\n\t\tint bx=-1, by=-1;   // 砲弾の座標\n\n\t\tpublic Tank(int x, int y,  int dir, char[][] map) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.map = map;\n\t\t\tif(dir == 0) this.dir = 'L';\n\t\t\telse if(dir == 1) this.dir = 'U';\n\t\t\telse if(dir == 2) this.dir = 'R';\n\t\t\telse if(dir == 3) this.dir = 'D';\n\t\t}\n\n\t\t// 命令\n\t\t// rの取りうる値: UDLR\n\t\tpublic void order(char r) {\n\n\t\t\t// 回転し、進めるのであれば進む\n\t\t\tif(r == 'U') {\n\t\t\t\tdir = 'U';\n\t\t\t\tmap[y][x] = '^';\n\t\t\t\tif(isMovable(x, y-1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty -= 1;\n\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = '^';\n\t\t\t\t} else {\n\t\t\t\t\t// 方向転換だけ行う\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'D') {\n\t\t\t\tdir = 'D';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t\tif(isMovable(x, y+1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty += 1;\n\t\t\t\t\t//\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = 'v';\n\t\t\t\t}\n\t\t\t} else if(r == 'L') {\n\t\t\t\tdir = 'L';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t\tif(isMovable(x-1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx -= 1;\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'R') {\n\t\t\t\tdir = 'R';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t\tif(isMovable(x+1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx += 1;\n\t\t\t\t\tmap[y][x] = '>';\n\t\t\t\t}\n\t\t\t} else if(r == 'S') {\n\t\t\t\tshot(dir);\n\t\t\t}\n\n\t\t}\n\n\t\t// 砲撃\n\t\tpublic void shot(char dir) {\n\n\t\t\t// 砲弾の位置初期化\n\t\t\tbx = x;\n\t\t\tby = y;\n\n\t\t\t// 方向を設定し発射\n\t\t\tmoveBullet(dir);\n\n\t\t}\n\n\t\t// 砲弾の移動\n\t\tpublic void moveBullet(char dir) {\n\n\t\t\t// 移動先座標\n\t\t\tint toX = -1;\n\t\t\tint toY = -1;\n\t\t\tif(dir == 'L') {\n\t\t\t\ttoX = bx-1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx -= 1;\n\t\t\t} else if(dir == 'U') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by-1;\n\t\t\t\tby -= 1;\n\t\t\t} else if(dir == 'R') {\n\t\t\t\ttoX = bx+1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx += 1;\n\t\t\t} else if(dir == 'D') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by+1;\n\t\t\t\tby += 1;\n\t\t\t}\n\n\t\t\t// 指定座標に移動できれば破壊し移動する\n\t\t\tif(map[toY][toX] == '*') {\n\t\t\t\t// 破壊\n\t\t\t\tmap[toY][toX] = '.';\n\t\t\t\treturn;\n\t\t\t} else if(map[toY][toX] == '#') {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmoveBullet(dir);\n\t\t\t}\n\t\t}\n\n\t\t// 指定の座標に戦車が進めるか\n\t\tpublic boolean isMovable(int x, int y) {\n\n\t\t\tif(map[y][x] == '.') return true;\n\t\t\telse return false;\n\n\t\t}\n\n\t\t// マップを表示\n\t\tpublic void drawMap() {\n\t\t\tfor(int i=1; i<map.length-1; i++) {\n\t\t\t\tfor(int j=1; j<map[i].length-1; j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップから戦車の位置と向きを取得する\n\t// @return int[] [0]戦車のx座標, [1]戦車のy座標, [2]戦車の向き(左から時計回りに0~3)\n\tpublic int[] getTankDir(char[][] map) {\n\n\t\tint[] ret = new int[3];\n\t\tfor(int i=0; i<map.length; i++) {\n\t\t\tfor(int j=0; j<map[i].length; j++){\n\t\t\t\tif(map[i][j] == '<') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 0;\n\t\t\t\t} else if(map[i][j] == '^') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 1;\n\t\t\t\t} else if(map[i][j] == '>') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 2;\n\t\t\t\t} else if(map[i][j] == 'v') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// マップセットの個数入力\n\t\tint num = sc.nextInt();\n\n\t\tfor(int n=0; n<num; n++) {\n\n\t\t\t// 地図データの入力\n\t\t\tint y = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\n\t\t\tchar[][] map = new char[y+2][x+2];\n\n\t\t\t// 外を埋める\n\t\t\tfor(int i=0; i<y+2; i++) {\n\t\t\t\tfor(int j=0; j<x+2; j++) {\n\t\t\t\t\tif(i == 0 || i == y+1 || j == 0 || j == x+1) map[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t\t\tmap[i][j] = line.toCharArray()[j-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 命令を入力\n\t\t\tint orderNum = sc.nextInt();\n\t\t\tString orders = sc.next();\n\t\t\tchar[] orderArr = orders.toCharArray();\n\n\t\t\tMain b = new Main();\n\n\t\t\t// 戦車の初期位置と向きを取得\n\t\t\tint[] tankPos = b.getTankDir(map);\n\n\n\t\t\t// 戦車を生成\n\t\t\tTank t = new Main().new Tank(tankPos[0], tankPos[1], tankPos[2], map);\n\n\t\t\t// 命令を実行\n\t\t\tfor(int i=0; i<orderNum; i++) {\n\t\t\t\tt.order(orderArr[i]);\n\t\t\t}\n\n\n\t\t\t// debug\n\t\t\t// 戦車の移動テスト\n\t\t\t//\t\tt.rotate('L');\n\n\t\t\t// マップを再表示\n\t\t\tt.drawMap();\n\t\t\tif(n != num-1) System.out.println(\"\");\n\n\t\t}\n\n\t\tsc.close();\n\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\n\t\tint sysout_cnt = data_set;\n\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\tif(sysout_cnt > 0){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ??????????????????????????±?????¶???????????????\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§???????????????????????????????????????????\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ????????????????????¨?????????????????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('U', '^');\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// ('D', 'v');\n\t\t\t// ('v', { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('L', '<');\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('R', '>');\n\t\t\t// ('>',{ 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\t// ??????????????????????????????\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// ('v',{ 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// ('>', { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int t, h, w;\n\tstatic char[][] field;\n\tstatic String order;\n\tstatic int[] dx = {0, 1, 0, -1}, dy = {-1, 0, 1, 0};\n\tpublic static void main(String[] args) {\n\t\tread();\n\t\t//solve();\n\t}\n\t\n\tstatic boolean read(){\n\t\tif(!sc.hasNext())return false;\n\t\tt = sc.nextInt();\n\t\tfor(int i = 0; i < t; i++){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tfield = new char[h][w];\n\t\t\tfor(int j = 0; j < field.length; j++){\n\t\t\t\tfield[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint no_use = sc.nextInt();\n\t\t\torder = sc.next();\n\t\t\tsolve();\n\t\t\tif(i != t-1){\n\t\t\t\tprintField();\n\t\t\t}else{\n\t\t\t\tfor(int k = 0; k < field.length; k++){\n\t\t\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\t\t\tSystem.out.print(field[k][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tint sx = 0, sy = 0;\n\t\tchar tank = '-';\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tif(field[i][j] == '^'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '>'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '<'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == 'v'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nx = sx, ny = sy;\n\t\tfor(int i = 0; i < order.length(); i++){\n\t\t\tchar c = order.charAt(i);\n\t\t\tswitch(c){\n\t\t\tcase 'U':\n\t\t\t\ttank = '^';\n\t\t\t\tnx += dx[0]; ny += dy[0];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '^';\n\t\t\t\t\tfield[ny-dy[0]][nx-dx[0]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[0]; ny -= dy[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\ttank = 'v';\n\t\t\t\tnx += dx[2]; ny += dy[2];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = 'v';\n\t\t\t\t\tfield[ny-dy[2]][nx-dx[2]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[2]; ny -= dy[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttank = '<';\n\t\t\t\tnx += dx[3]; ny += dy[3];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '<';\n\t\t\t\t\tfield[ny-dy[3]][nx-dx[3]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[3]; ny -= dy[3];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\ttank = '>';\n\t\t\t\tnx += dx[1]; ny += dy[1];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '>';\n\t\t\t\t\tfield[ny-dy[1]][nx-dx[1]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[1]; ny -= dy[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshot(nx, ny, tank);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void printField(){\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic void shot(int x, int y, char t){\n\t\tint vector = 0;\n\t\tswitch(t){\n\t\tcase '^':\n\t\t\tvector = 0; break;\n\t\tcase '>':\n\t\t\tvector = 1; break;\n\t\tcase 'v':\n\t\t\tvector = 2; break;\n\t\tcase '<':\n\t\t\tvector = 3; break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tint nx = x + dx[vector], ny = y + dy[vector];\n\t\twhile(true){\n\t\t\tif(nx < 0 || nx >= field[0].length || ny < 0 || ny >= field.length)break;\n\t\t\tif(field[ny][nx] == '#')break;\n\t\t\tif(field[ny][nx] == '*'){field[ny][nx] = '.'; break;}\n\t\t\tnx += dx[vector]; ny += dy[vector];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tint tankPositionH = 0;\n\t\t\tint tankPositionW = 0;\n\n\t\t\tfor(int j = 0; j < height; j++) {\n\n\t\t\t\tfor(int k = 0; k < width; k++) {\n\n\t\t\t\t\tif(townMap[j][k].equals(\"^\") || townMap[j][k].equals(\"v\")\n\t\t\t\t\t\t\t|| townMap[j][k].equals(\"<\") || townMap[j][k].equals(\">\")) {\n\n\t\t\t\t\t\ttankPositionH = j;\n\t\t\t\t\t\ttankPositionW = k;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ?????????????????????????????§??????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\t// String direction = tank.changeDirection(commandArray[j]);\n\t\t\t\t\ttankPositionH = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttankPositionW = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t\t// ????????????????????????????????¨??????????????´\n\t\t\t\t\t/*switch(direction) {\n\n\t\t\t\t\tcase \"^\":\n\n\t\t\t\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"v\":\n\n\t\t\t\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"<\":\n\n\t\t\t\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \">\":\n\n\t\t\t\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}*/\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n\n// ???????????????\nclass Tank{\n\n\t// ?????????????????????????????????\n\tint changeDirection(char command, String[][] townMap, int height, int width, int tankPositionH, int tankPositionW){\n\n\t\t// String direction = null;\n\t\tint tankPosition = 0;\n\n\t\tswitch(command){\n\n\t\tcase 'U':\n\n\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionH - 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'D':\n\n\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionH + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'L':\n\n\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW - 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'R':\n\n\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\treturn tankPosition;\n\n\t}\n\n\t\t/*case 'U':\n\n\t\t\tdirection = \"^\";\n\t\t\tbreak;\n\n\t\tcase 'D':\n\n\t\t\tdirection = \"v\";\n\t\t\tbreak;\n\n\t\tcase 'L':\n\n\t\t\tdirection = \"<\";\n\t\t\tbreak;\n\n\t\tcase 'R':\n\n\t\t\tdirection = \">\";\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn direction;\n\n\t}*/\n\n\tvoid shoot(String[][] townMap, int height, int width, int tankPositionH, int tankPositionW) {\n\n\t\tswitch(townMap[tankPositionH][tankPositionW]) {\n\n\t\tcase \"^\":\n\n\t\t\tfor(int i = tankPositionH - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPositionH + 1; i < height; i++) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPositionW - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPositionW + 1; i < width; i++) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tStringBuilder result = new StringBuilder();\n\t\tScanner scan = new Scanner(System.in);\n\t\tint setCount = scan.nextInt();\n\n\t\t// setCount????????°??°???????????????\n\t\tfor(int i=0;i<setCount;i++){\n\n\t\t// PlayerControl??????????????????????????????\n\t\tPlayerControl pc = new PlayerControl(scan.nextInt(), scan.nextInt());\n\t\t// ????????????????????????\n\t\tpc.mapBuild(scan);\n\n\t\t// System.out.println(pc.map[3][0]);\n\n\t\t// ?????¬???????????\\??????????????°?????????\n\t\tint playerControlCount = scan.nextInt();\n\t\t// ?????¬???????????\\??????????????????????????????\n\t\tString setPlayerControl = scan.next();\n\t\tfor (int k = 0; k < playerControlCount; k++) {\n\t\t\tif (String.valueOf(setPlayerControl.charAt(k)).equals(\"S\")) {\n\t\t\t\t// ???????????????????????????????????????????°??????????\n\t\t\t\tpc.tankShoot();\n\t\t\t} else {\n\t\t\t\t// ?????????????????¢??????????????????????????°??§????????°?§??????????\n\t\t\t\tpc.tankMove(String.valueOf(setPlayerControl.charAt(k)));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//???????????¨????????????????????????result????????????????????????\n\t\tresult.append(pc.mapOutput()).append(\"\\n\");\n\t\t}\n\t\t\n\t\tresult.deleteCharAt(result.length() - 2);\n\t\tSystem.out.println(new String(result));\n\n\t\t\n\n\t}\n}\n\n/**\n * ?????¬????????????????????????????????????????????????\n * \n * @author SS\n *\n */\nclass PlayerControl {\n\t// ??????????????????\n\tString map[][];\n\n\t// ??????????????±\n\tint tankHeight;\n\tint tankWidth;\n\tString tankState;\n\n\t// ?????????????????????????????¨????????????????¨????\n\tPlayerControl(int height, int width) {\n\t\tmap = new String[height][width];\n\t\ttankHeight = 0;\n\t\ttankWidth = 0;\n\t\ttankState = \"\";\n\t}\n\n\t/**\n\t * ??????????????????\n\t * \n\t * @param main???Scanner??????????¶????\n\t */\n\tpublic void mapBuild(Scanner scan) {\n\t\t// height * width ??????????????§??????????????????????????????\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tString setObject = scan.next();\n\t\t\tfor (int j = 0; j < map[0].length; j++) {\n\t\t\t\t// ?????????????????¨??¶???????????±????¨????\n\t\t\t\tswitch (map[i][j] = String.valueOf(setObject.charAt(j))) {\n\t\t\t\tcase \"^\":\n\n\t\t\t\t\ttankInfo(i, j, \"^\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"v\":\n\t\t\t\t\ttankInfo(i, j, \"v\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \">\":\n\t\t\t\t\ttankInfo(i, j, \">\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"<\":\n\t\t\t\t\ttankInfo(i, j, \"<\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * ?????????????????¨??¶???????¨??????????\n\t * \n\t * @param height\n\t *            ????????§?¨?\n\t * @param width\n\t *            ?¨??????§?¨?\n\t * @param state\n\t *            ??¶?????????????????????\n\t */\n\tprivate void tankInfo(int height, int width, String state) {\n\n\t\ttankHeight = height;\n\t\ttankWidth = width;\n\t\ttankState = state;\n\n\t}\n\n\t/**\n\t * \n\t * @param ?????¬???????????????????????????????????????\n\t */\n\tpublic void Control(String instruction) {\n\t\tswitch (instruction) {\n\t\tcase \"S\":// ???????????????????????¨???\n\t\t\tSystem.out.println(\"tankShoot()???????????????\");\n\t\t\ttankShoot();\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tpublic void tankMove(String move) {\n\t\tswitch (move) {\n\t\tcase \"U\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"^\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????????§????????¨?????????????????????\n\t\t\tif (tankHeight - 1 >= 0) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight - 1][tankWidth].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight - 1][tankWidth] = \"^\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight - 1, tankWidth, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"D\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"v\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\t\t\t\n\t\t\t// ?????????????????????????¶????????????¨?????????????????????\n\t\t\tif (tankHeight + 1 < map.length) {\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight + 1][tankWidth].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight + 1][tankWidth] = \"v\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight + 1, tankWidth, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"L\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"<\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????????§????????¨?????????????????????\n\t\t\tif (tankWidth - 1 >= 0) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight][tankWidth - 1].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight][tankWidth - 1] = \"<\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight, tankWidth - 1, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"R\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \">\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????¶????????????¨?????????????????????\n\t\t\tif (tankWidth + 1 < map[0].length) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight][tankWidth + 1].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight][tankWidth + 1] = \">\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight, tankWidth + 1, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * S?????????????????¨??????????????????????????????????????????????°????????????? ??¬?????¬????£??????¶????????£?????¨???????????¬?????¬????£?????????°??¨?????????\n\t */\n\tpublic void tankShoot() {\n\t\t\tswitch (tankState) {\n\t\t\tcase \"^\":// ???????????????????????????\n\n\t\t\t\tfor (int i = 1; i <= tankHeight; i++) {\n\t\t\t\t\tif (map[tankHeight - i][tankWidth].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight - i][tankWidth] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight - i][tankWidth].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase \"v\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= (map.length - 1) - tankHeight; i++) {\n\t\t\t\t\tif (map[tankHeight + i][tankWidth].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight + i][tankWidth] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight + i][tankWidth].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \">\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= (map[0].length - 1) - tankWidth; i++) {\n\t\t\t\t\tif (map[tankHeight][tankWidth + i].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight][tankWidth + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight][tankWidth + i].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"<\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= tankWidth; i++) {\n\t\t\t\t\tif (map[tankHeight][tankWidth - i].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight][tankWidth - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight][tankWidth - i].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t}\n\n\tpublic StringBuilder mapOutput() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tfor (int j = 0; j < map[0].length; j++) {\n\t\t\t\tsb.append(map[i][j]);\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\t\n\t\treturn sb;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// データセット数の入力\n\t\tint dataSetsCount = Integer.parseInt(sc.nextLine());\n\t\tfor (int count = 0; count < dataSetsCount; count++) {\n\n\t\t\t// マップの縦幅と横幅の入力\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\n\t\t\t// マップ情報の入力\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\n\t\t\t// 戦車の行動の入力・マップの更新\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tmap.tank.ExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\n\t\t\t// 表示\n\t\t\tPrint();\n\t\t\t// データセットの間に改行をいれる\n\t\t\tif (count < dataSetsCount - 1) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\t// マップ内容の表示\n\tstatic void Print() {\n\t\tfor (int y = 0; y < map.height; y++) {\n\t\t\tString str = \"\";\n\t\t\tfor (int x = 0; x < map.width; x++) {\n\t\t\t\t// 戦車がいる場所か\n\t\t\t\tif (map.tank.Y == y && map.tank.X == x) {\n\t\t\t\t\t// 戦車の文字を取り出す\n\t\t\t\t\tstr += map.tank.State.str;\n\t\t\t\t} else {\n\t\t\t\t\t// タイルの文字を取り出す\n\t\t\t\t\tTile t = map.getTile(x, y);\n\t\t\t\t\tstr += t.Type.str;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 出力\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n\n\t// タイルの種類\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\t// タイル\n\tstatic class Tile {\n\t\t// タイルタイプ・座標\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\t// 戦車の向き\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\n\t\t// 戦車の向き・向きを表す座標\n\t\tString str;\n\t\tint X;\n\t\tint Y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t}\n\t}\n\n\t// 戦車の行動\n\tenum ActionType {\n\t\tU(\"Up\"), D(\"Down\"), L(\"Left\"), R(\"Right\"), S;\n\n\t\t// 行動後の戦車の状態\n\t\tTankState ts;\n\n\t\tActionType() {\n\t\t}\n\n\t\tActionType(String str) {\n\t\t\tthis.ts = TankState.valueOf(str);\n\t\t}\n\t}\n\n\t// 戦車\n\tstatic class Tank {\n\t\t// 戦車の向き・戦車の座標\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\n\t\t// 行動の実行\n\t\tvoid ExecuteAction(ActionType action) {\n\t\t\t// Sなら砲撃、S以外は移動\n\t\t\tif (action == ActionType.S) {\n\t\t\t\tthis.Shoot();\n\t\t\t} else {\n\t\t\t\tMove(action.ts);\n\t\t\t}\n\t\t}\n\n\t\t// 移動\n\t\tvoid Move(TankState ts) {\n\t\t\t// 戦車の向きを変更\n\t\t\tthis.State = ts;\n\t\t\t// 戦車の向きから移動先が移動可能であるか\n\t\t\tif (map.MobilityCheck(this.X + ts.X, this.Y + ts.Y)) {\n\t\t\t\tthis.X += ts.X;\n\t\t\t\tthis.Y += ts.Y;\n\t\t\t}\n\t\t}\n\n\t\t// 砲撃\n\t\tvoid Shoot() {\n\t\t\tint x = this.X + this.State.X;\n\t\t\tint y = this.Y + this.State.Y;\n\t\t\twhile (map.BombardmentProceedsCheck(x, y)) {\n\t\t\t\tx += this.State.X;\n\t\t\t\ty += this.State.Y;\n\t\t\t}\n\t\t\tmap.BreakBrickTile(x, y);\n\t\t}\n\t}\n\n\t// マップ\n\tstatic class Map {\n\t\t// タイルリスト\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\t\t// 縦幅・横幅\n\t\tint height;\n\t\tint width;\n\t\t// 戦車\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\t// リストからタイルを取り出す\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t// マップデータの入力を反映する\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\t// 入力を1文字単位に分割\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\t// タイルタイプへ変換\n\t\t\t\t\tTileType tt = TileDiscrimination(line[x]);\n\t\t\t\t\tif (tt != null) {\n\t\t\t\t\t\t// タイルをリストに追加\n\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// タイルでないなら戦車へ変換\n\t\t\t\t\t\tTankState ts = TankDiscrimination(line[x]);\n\t\t\t\t\t\tif (ts != null) {\n\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 1文字からタイルタイプへ\n\t\tTileType TileDiscrimination(String str) {\n\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\tif (tt.str.equals(str)) {\n\t\t\t\t\treturn tt;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t// 1文字から戦車へ\n\t\tTankState TankDiscrimination(String str) {\n\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\tif (ts.str.equals(str)) {\n\t\t\t\t\treturn ts;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t// 移動可能な場所であるか判定\n\t\tboolean MobilityCheck(int x, int y) {\n\t\t\tTile t = getTile(x, y);\n\t\t\tif (t != null && t.Type == TileType.Field) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// 砲弾が進むか判定\n\t\tboolean BombardmentProceedsCheck(int x, int y) {\n\t\t\tTile tile = this.getTile(x, y);\n\t\t\tif (tile != null && (tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// レンガの壁を壊す\n\t\tvoid BreakBrickTile(int x, int y) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.Type == TileType.Brick && t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, new Tile(x, y, TileType.Field));\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        ArrayList<char[][]> listBattleArea = new ArrayList<char[][]>();\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        \n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            \n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            listBattleArea.add(aryBattleArea);\n            \n        }\n        \n        for( int i = 0 ; i < listBattleArea.size() ; i++ ){\n        \t\n        \tchar[][] output = listBattleArea.get(i);\n        \t\n        \tfor( int j = 0 ; j < output.length ; j++ ){\n        \t\tfor( int k = 0 ; k < output[i].length ; k++ ){\n        \t\t\t\n        \t\t\tSystem.out.print(output[j][k]);\n        \t\t\t\n        \t\t}\n        \t\tSystem.out.println();\n        \t}\n        \tSystem.out.println();\n        }\n        \n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    //private ArrayList<char[][]> list = new ArrayList<char[][]>();\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                              //  continue;\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    public void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n        //??????????°?  \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tSystem.setIn(new FileInputStream(\"src/aoj2103/input.txt\"));\n\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(\"src/aoj2103/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\n\n\tScanner sc;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile (T-- >0) {\n\t\t\tsolve();\n\t\t\tif (T > 0)\n\t\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tint R, C;\n\tchar[][] table;\n\tboolean isin(int r, int c) {\n\t\treturn 0 <= r && r < R && 0 <= c && c < C;\n\t}\n\tboolean canmove(int r, int c) {\n\t\treturn isin(r,c) && table[r][c] == '.';\n\t}\n\n\tvoid solve() {\n\t\tR = sc.nextInt();\n\t\tC = sc.nextInt();\n\t\ttable = new char[R][C];\n\n\t\tfor (int r = 0; r < R; r++) {\n\t\t\ttable[r] = sc.next().toCharArray();\n\t\t}\n\n\t\tint x = -1, y = -1;\n\t\tfor (int r = 0; r < R; r++)\n\t\t\tfor (int c = 0; c < C; c++)\n\t\t\t\tif (table[r][c] == '^' || table[r][c] == 'v' || table[r][c] == '<' || table[r][c] == '>') {\n\t\t\t\t\tx = r;\n\t\t\t\t\ty = c;\n\t\t\t\t}\n\n\n\t\tString dirs = \">^<v\";\n\t\tint[] dr = {0, -1, 0, 1};\n\t\tint[] dc = {1, 0, -1, 0};\n\t\tint M = sc.nextInt();\n\t\tchar[] cmd = sc.next().toCharArray();\n\t\tfor (int i = 0; i < cmd.length; i++) {\n\t\t\tif (cmd[i] == 'S') {\n\t\t\t\tint d = dirs.indexOf(table[x][y]);\n\t\t\t\tint tx = x + dr[d];\n\t\t\t\tint ty = y + dc[d];\n\t\t\t\twhile (isin(tx, ty)) {\n\t\t\t\t\tif (table[tx][ty] == '*') {\n\t\t\t\t\t\ttable[tx][ty] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (table[tx][ty] == '#')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ttx += dr[d];\n\t\t\t\t\tty += dc[d];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmd[i] == 'U') {\n\t\t\t\ttable[x][y] = '^';\n\t\t\t\tif (canmove(x - 1, y)) {\n\t\t\t\t\ttable[x][y] = '.';\n\t\t\t\t\ttable[x-1][y] = '^';\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmd[i] == 'D') {\n\t\t\t\ttable[x][y] = 'v';\n\t\t\t\tif (canmove(x + 1, y)) {\n\t\t\t\t\ttable[x][y] = '.';\n\t\t\t\t\ttable[x+1][y] = 'v';\n\t\t\t\t\tx++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (cmd[i] == 'L') {\n\t\t\t\ttable[x][y] = '<';\n\t\t\t\tif (canmove(x, y-1)) {\n\t\t\t\t\ttable[x][y] = '.';\n\t\t\t\t\ttable[x][y-1] = '<';\n\t\t\t\t\ty--;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (cmd[i] == 'R') {\n\t\t\t\ttable[x][y] = '>';\n\t\t\t\tif (canmove(x, y+1)) {\n\t\t\t\t\ttable[x][y] = '.';\n\t\t\t\t\ttable[x][y+1] = '>';\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < R; i++){\n\t\t\tfor (int j = 0; j < C; j++)\n\t\t\t\tSystem.out.print(table[i][j]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        ArrayList<char[][]> listBattleArea = new ArrayList<char[][]>();\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        \n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            \n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            listBattleArea.add(aryBattleArea);\n            \n        }\n        \n        for( int i = 0 ; i < listBattleArea.size() ; i++ ){\n        \t\n        \tchar[][] output = listBattleArea.get(i);\n        \t\n        \tfor( int j = 0 ; j < output.length ; j++ ){\n        \t\tfor( int k = 0 ; k < output[j].length ; k++ ){\n        \t\t\t\n        \t\t\tSystem.out.print(output[j][k]);\n        \t\t\t\n        \t\t}\n        \t\tSystem.out.println();\n        \t}\n        \tSystem.out.println();\n        }\n        \n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    //private ArrayList<char[][]> list = new ArrayList<char[][]>();\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                              //  continue;\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    public void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n        //??????????°?  \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[i][x] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea[i].length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[i][x] == '#' ){\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\tstatic ArrayList<String> print = new ArrayList<String>();\n\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\t\tString str;\n\t\tint x;\n\t\tint y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tenum ActionType {\n\t\tU, D, L, R, S;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint dataSetsCount=Integer.parseInt(sc.nextLine());\n\t\tfor(int count=0;count<dataSetsCount;count++) {\n\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\n\t\t\tmap.Print();\n\t\t\tif(count<=dataSetsCount-1)print.add(\"\\n\");\n\t\t}\n\t\tfor(String str:print) {\n\t\t\tSystem.out.print(str);\n\t\t}\n\n\t}\n\n\tstatic void ExecuteAction(ActionType action) {\n\t\tTank tank = map.tank;\n\t\tTile tile;\n\t\tswitch (action) {\n\t\tcase U:\n\t\t\ttile =map.getTile(tank.X, tank.Y - 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Up;\n\t\t\tbreak;\n\t\tcase D:\n\t\t\ttile =map.getTile(tank.X, tank.Y + 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Down;\n\t\t\tbreak;\n\t\tcase L:\n\t\t\ttile =map.getTile(tank.X-1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Left;\n\t\t\tbreak;\n\t\tcase R:\n\t\t\ttile =map.getTile(tank.X+1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Right;\n\t\t\tbreak;\n\t\tcase S:\n\t\t\tint x = tank.X ;\n\t\t\tint y = tank.Y ;\n\t\t\ttile = map.getTile(x, y);\n\t\t\twhile (tile != null &&( tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\tx += tank.State.x;\n\t\t\t\ty += tank.State.y;\n\t\t\t\ttile = map.getTile(x, y);\n\t\t\t}\n\t\t\tif (tile != null && tile.Type == TileType.Brick) {\n\t\t\t\ttile.Type = TileType.Field;\n\t\t\t\tmap.setTile(x, y, tile);\n\n\t\t\t}\n\n\t\t}\n\t\tmap.tank = tank;\n\t}\n\n\tstatic class Map {\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\n\t\tint[][] coordinate;\n\t\tint height;\n\t\tint width;\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tcoordinate = new int[height][width];\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvoid setTile(int x, int y, Tile tile) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, tile);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\n\t\t\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\t\t\tif (tt.str.equals(line[x])) {\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\t\t\t\t\tif (ts.str.equals(line[x])) {\n\t\t\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Print() {\n\t\t\t\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString str=\"\";\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\tif (tank.Y == y && tank.X == x) {\n\t\t\t\t\t\tstr+=tank.State.str;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTile t = getTile(x, y);\n\t\t\t\t\t\tstr+=t.Type.str;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr+=\"\\n\";\n\t\t\t\tprint.add(str);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Tile {\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\tstatic class Tank {\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t// マップ\n\n\t// 戦車\n\tclass Tank {\n\n\t\tchar[][] map;\n\n\t\tint x, y; \t  // 座標\n\t\tchar dir; \t  // 向いてる方角\n\n\t\tint bx=-1, by=-1;   // 砲弾の座標\n\n\t\tpublic Tank(int x, int y,  int dir, char[][] map) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.map = map;\n\t\t\tif(dir == 0) this.dir = 'L';\n\t\t\telse if(dir == 1) this.dir = 'U';\n\t\t\telse if(dir == 2) this.dir = 'R';\n\t\t\telse if(dir == 3) this.dir = 'D';\n\t\t}\n\n\t\t// 命令\n\t\t// rの取りうる値: UDLR\n\t\tpublic void order(char r) {\n\n\t\t\t// 回転し、進めるのであれば進む\n\t\t\tif(r == 'U') {\n\t\t\t\tdir = 'U';\n\t\t\t\tmap[y][x] = '^';\n\t\t\t\tif(isMovable(x, y-1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty -= 1;\n\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = '^';\n\t\t\t\t} else {\n\t\t\t\t\t// 方向転換だけ行う\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'D') {\n\t\t\t\tdir = 'D';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t\tif(isMovable(x, y+1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty += 1;\n\t\t\t\t\t//\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = 'v';\n\t\t\t\t}\n\t\t\t} else if(r == 'L') {\n\t\t\t\tdir = 'L';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t\tif(isMovable(x-1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx -= 1;\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'R') {\n\t\t\t\tdir = 'R';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t\tif(isMovable(x+1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx += 1;\n\t\t\t\t\tmap[y][x] = '>';\n\t\t\t\t}\n\t\t\t} else if(r == 'S') {\n\t\t\t\tshot(dir);\n\t\t\t}\n\n\t\t}\n\n\t\t// 砲撃\n\t\tpublic void shot(char dir) {\n\n\t\t\t// 砲弾の位置初期化\n\t\t\tbx = x;\n\t\t\tby = y;\n\n\t\t\t// 方向を設定し発射\n\t\t\tmoveBullet(dir);\n\n\t\t}\n\n\t\t// 砲弾の移動\n\t\tpublic void moveBullet(char dir) {\n\n\t\t\t// 移動先座標\n\t\t\tint toX = -1;\n\t\t\tint toY = -1;\n\t\t\tif(dir == 'L') {\n\t\t\t\ttoX = bx-1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx -= 1;\n\t\t\t} else if(dir == 'U') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by-1;\n\t\t\t\tby -= 1;\n\t\t\t} else if(dir == 'R') {\n\t\t\t\ttoX = bx+1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx += 1;\n\t\t\t} else if(dir == 'D') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by+1;\n\t\t\t\tby += 1;\n\t\t\t}\n\n\t\t\t// 指定座標に移動できれば破壊し移動する\n\t\t\tif(map[toY][toX] == '*') {\n\t\t\t\t// 破壊\n\t\t\t\tmap[toY][toX] = '.';\n\t\t\t\treturn;\n\t\t\t} else if(map[toY][toX] == '#') {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmoveBullet(dir);\n\t\t\t}\n\t\t}\n\n\t\t// 指定の座標に戦車が進めるか\n\t\tpublic boolean isMovable(int x, int y) {\n\n\t\t\tif(map[y][x] == '.') return true;\n\t\t\telse return false;\n\n\t\t}\n\n\t\t// マップを表示\n\t\tpublic void drawMap() {\n\t\t\tfor(int i=1; i<map.length-1; i++) {\n\t\t\t\tfor(int j=1; j<map[i].length-1; j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップから戦車の位置と向きを取得する\n\t// @return int[] [0]戦車のx座標, [1]戦車のy座標, [2]戦車の向き(左から時計回りに0~3)\n\tpublic int[] getTankDir(char[][] map) {\n\n\t\tint[] ret = new int[3];\n\t\tfor(int i=0; i<map.length; i++) {\n\t\t\tfor(int j=0; j<map[i].length; j++){\n\t\t\t\tif(map[i][j] == '<') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 0;\n\t\t\t\t} else if(map[i][j] == '^') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 1;\n\t\t\t\t} else if(map[i][j] == '>') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 2;\n\t\t\t\t} else if(map[i][j] == 'v') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// マップセットの個数入力\n\t\tint num = sc.nextInt();\n\n\t\tfor(int n=0; n<num; n++) {\n\n\t\t\t// 地図データの入力\n\t\t\tint y = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\n\t\t\tchar[][] map = new char[y+2][x+2];\n\n\t\t\t// 外を埋める\n\t\t\tfor(int i=0; i<y+2; i++) {\n\t\t\t\tfor(int j=0; j<x+2; j++) {\n\t\t\t\t\tif(i == 0 || i == y+1 || j == 0 || j == x+1) map[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t\t\tmap[i][j] = line.toCharArray()[j-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// マップを表示\n\t\t\t//\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t//\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t//\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\tSystem.out.println(\"\");\n\t\t\t//\t\t}\n\n\t\t\t// 命令を入力\n\t\t\tint orderNum = sc.nextInt();\n\t\t\tString orders = sc.next();\n\t\t\tchar[] orderArr = orders.toCharArray();\n\n\t\t\tMain b = new Main();\n\n\t\t\t// 戦車の初期位置と向きを取得\n\t\t\tint[] tankPos = b.getTankDir(map);\n\n//\t\t\tfor(int i=0; i<3; i++) {\n//\t\t\t\tSystem.out.println(tankPos[i]);\n//\t\t\t}\n\n\t\t\t// 戦車を生成\n\t\t\tTank t = new Main().new Tank(tankPos[0], tankPos[1], tankPos[2], map);\n\n\t\t\t// 命令を実行\n\t\t\tfor(int i=0; i<orderNum; i++) {\n\t\t\t\tt.order(orderArr[i]);\n\t\t\t}\n\n\n\t\t\t// debug\n\t\t\t// 戦車の移動テスト\n\t\t\t//\t\tt.rotate('L');\n\n\t\t\t// マップを再表示\n\t\t\tSystem.out.println(\"\");\n\t\t\tt.drawMap();\n\n\t\t}\n\n\t\tsc.close();\n\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tstatic int H,W;\n\tstatic char field[][];\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint T=in.nextInt();\n\t\tfor(int I=0;I<T;I++)\n\t\t{\n\t\t\tif(I!=0)\n\t\t\t\tSystem.out.println();\n\t\t\tint H=in.nextInt();\n\t\t\tint W=in.nextInt();\n\t\t\tint sh=0;\n\t\t\tint sw=0;\n\t\t\tint dir=0;\n\t\t\tfield=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tchar ch[]=in.next().toCharArray();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tfield[i][j]=ch[j];\n\t\t\t\t\tif(ch[j]=='>'||ch[j]=='v'||ch[j]=='<'||ch[j]=='^')\n\t\t\t\t\t{\n\t\t\t\t\t\t sh=i;\n\t\t\t\t\t\t sw=j;\n\t\t\t\t\t\t field[i][j]='.';\n\t\t\t\t\t}\n\t\t\t\t\tif(ch[j]=='^')\n\t\t\t\t\t\tdir=1;\n\t\t\t\t\telse if(ch[j]=='>')\n\t\t\t\t\t\tdir=2;\n\t\t\t\t\telse if(ch[j]=='v')\n\t\t\t\t\t\tdir=3;\n\t\t\t\t\telse if(ch[j]=='<')\n\t\t\t\t\t\tdir=4;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint N=in.nextInt();\n\t\t\tchar d[]=in.next().toCharArray();\n\t\t\t\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(d[i]=='U')\n\t\t\t\t{\n\t\t\t\t\tdir=1;\n\t\t\t\t\tif(sh-1>=0&&field[sh-1][sw]=='.')\n\t\t\t\t\t\tsh--;\n\t\t\t\t}\n\t\t\t\telse if(d[i]=='R')\n\t\t\t\t{\n\t\t\t\t\tdir=2;\n\t\t\t\t\tif(sw+1<W&&field[sh][sw+1]=='.')\n\t\t\t\t\t\tsw++;\n\t\t\t\t}\n\t\t\t\telse if(d[i]=='D')\n\t\t\t\t{\n\t\t\t\t\tdir=3;\n\t\t\t\t\tif(sh+1<H&&field[sh+1][sw]=='.')\n\t\t\t\t\t\tsh++;\n\t\t\t\t}\n\t\t\t\telse if(d[i]=='L')\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tdir=4;\n\t\t\t\t\tif(sw-1>=0&&field[sh][sw-1]=='.')\n\t\t\t\t\t\tsw--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint nh=sh;\n\t\t\t\t\tint nw=sw;\n\t\t\t\t\tif(dir==1)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nh>=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnh--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(dir==2)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nw<W)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnw++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(dir==3)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nh<H)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnh++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(dir==4)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nw>=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnw--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dir==1)\n\t\t\t\tfield[sh][sw]='^';\n\t\t\telse if(dir==2)\n\t\t\t\tfield[sh][sw]='>';\n\t\t\telse if(dir==3)\n\t\t\t\tfield[sh][sw]='v';\n\t\t\telse if(dir==4)\n\t\t\t\tfield[sh][sw]='<';\n\t\t\t\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tSystem.out.println();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main{\n\t\n\t/**\n\t * プログラムエントリポイント\n\t * @param args\n\t */\n\tpublic static void main (String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//データセット回数を入力\n\t\tint setCountData = sc.nextInt();\n\t\t//入力されたデータセット回数分繰り返す\n\t\tfor( int i = 0 ; i < setCountData ; i++ ){\n\t\t\t//繰り返す回数ごとに配列を作成して２次元配列の長さを入力\n\t\t\tchar[][] aryBattleArea = new char[sc.nextInt()][sc.nextInt()];\n\t\t\t//配列aryBattleAreaに市街戦の要素入力\n\t\t\tfor( int j = 0 ; j < aryBattleArea.length ; j++ ){\n\t\t\t\taryBattleArea[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\t//繰り返す回数ごとに配列を作成して１次元配列の長さを入力\n\t\t\tchar[] aryOperation = new char[sc.nextInt()];\n\t\t\t//配列aryOperationに操作分を入力したものを文字ごとに配列に格納\n\t\t\taryOperation = sc.next().toCharArray();\n\t\t\t\n\t\t\t//BattleTownをインスタンス化\n\t\t\tBattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n\t\t\t\n\t\t\taryBattleArea = insBt.runOperation();\n\t\t\t\n\t\t\tfor( int x = 0 ; x < aryBattleArea.length ; x++ ){\n\t\t\t\tfor( int y = 0 ; y < aryBattleArea[i].length ; y++ ){\n\t\t\t\t\tSystem.out.print(aryBattleArea[x][y]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\n/**\n * \n * 操作を実行する\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n\t\n\tprivate char[][] aryBattleArea;\n\tprivate char[] aryOperation;\n\t\n\t/**\n\t * コンストラクタ\n\t * @param aryBattleArea 戦場を表す二次元配列\n\t * @param aryOperation 命令を表す一次元配列\n\t */\n\tpublic BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n\t\t\n\t\tthis.aryBattleArea = aryBattleArea;\n\t\tthis.aryOperation = aryOperation;\n\t\t\n\t}\n\t\n\t/**\n\t * 指定された操作を順番にactionTankクラス渡し\n\t * 渡した操作は'0'にして読み取れないように\n\t */\n\tpublic char[][] runOperation(){\n\t\t\n\t\tfor( int k = 0 ; k < aryOperation.length ; k++ ){\n\t\t\t\n\t\t\tif( aryOperation[k] != '0' ){\n\t\t\t\n\t\t\t\tfor( int i = 0 ; i < aryBattleArea.length ; i++ ){\n\t\t\t\t\tfor( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n\t\t\t\t\t\t\t|| aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tactionTank( i , j , aryOperation[k] );\n\t\t\t\t\t\t\t\taryOperation[k] = '0';\n\t\t\t\t\t\t\t\t//runOperation();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn aryBattleArea;\n\t}\n\t\n\t/**\n\t * 指定された操作を実行する\n\t * @param i 戦車を発見した配列の位置\n\t * @param j 戦車を発見した配列の位置\n\t * @param c 操作命令\n\t */\n\tprivate void actionTank( int i , int j , char operation ) {\n\t\t\t\n\t\t//戦車上方向\n\t\tif( operation == 'U' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '^';\n\t\t\t\n\t\t\tif( i-1 >= 0 ){\n\t\t\t\tif( aryBattleArea[i-1][j] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i-1][j] = '^';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t//戦車下方向\n\t\t}else if( operation == 'D' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = 'v';\n\t\t\t\n\t\t\tif( i+1 < aryBattleArea.length ){\n\t\t\t\tif( aryBattleArea[i+1][j] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i+1][j] = 'v';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//戦車左方向\n\t\t}else if( operation == 'L' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '<';\n\t\t\t\n\t\t\tif( j-1 >= 0 ){\n\t\t\t\tif( aryBattleArea[i][j-1] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i][j-1] = '<';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//戦車右方向\n\t\t}else if( operation == 'R' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '>';\n\t\t\t\n\t\t\tif( j+1 < aryBattleArea[i].length ){\n\t\t\t\tif( aryBattleArea[i][j+1] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i][j+1] = '>';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}else if( operation == 'S' ){\n\t\t\n\t\t\tif(aryBattleArea[i][j] == '^'){\n\t\t\t\t\n\t\t\t\tfor( int x = i ; x >= 0 ; x-- ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[x][j] == '*' ){\n\t\t\t\t\t\taryBattleArea[x][j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == 'v'){\n\t\t\t\t\n\t\t\t\tfor( int x = i ; x < aryBattleArea.length ; x++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[x][j] == '*' ){\n\t\t\t\t\t\taryBattleArea[x][j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == '<'){\n\t\t\t\t\n\t\t\t\tfor( int x = j ; x >= 0 ; x-- ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][x] == '*' ){\n\t\t\t\t\t\taryBattleArea[i][x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == '>'){\n\t\t\t\t\n\t\t\t\tfor( int x = j ; x < aryBattleArea.length ; x++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][x] == '*' ){\n\t\t\t\t\t\taryBattleArea[i][x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tSystem.setIn(new FileInputStream(\"src/aoj2103/input.txt\"));\n\t\t\tSystem.setOut(new PrintStream(new FileOutputStream(\"src/aoj2103/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\n\n\tScanner sc;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile (T-- >0) {\n\t\t\tsolve();\n\t\t\tif (T > 0)\n\t\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tint R, C;\n\tchar[][] table;\n\tboolean isin(int r, int c) {\n\t\treturn 0 <= r && r < R && 0 <= c && c < C;\n\t}\n\tboolean canmove(int r, int c) {\n\t\treturn isin(r,c) && table[r][c] == '.';\n\t}\n\n\tvoid solve() {\n\t\tR = sc.nextInt();\n\t\tC = sc.nextInt();\n\t\ttable = new char[R][C];\n\n\t\tfor (int r = 0; r < R; r++) {\n\t\t\ttable[r] = sc.next().toCharArray();\n\t\t}\n\n\t\tint x = -1, y = -1;\n\t\tfor (int r = 0; r < R; r++)\n\t\t\tfor (int c = 0; c < C; c++)\n\t\t\t\tif (table[r][c] == '^' || table[r][c] == 'v' || table[r][c] == '<' || table[r][c] == '>') {\n\t\t\t\t\tx = r;\n\t\t\t\t\ty = c;\n\t\t\t\t}\n\n\n\t\tString dirs = \">^<v\";\n\t\tint[] dr = {0, -1, 0, 1};\n\t\tint[] dc = {1, 0, -1, 0};\n\t\tint M = sc.nextInt();\n\t\tchar[] cmd = sc.next().toCharArray();\n\t\tfor (int i = 0; i < cmd.length; i++) {\n\t\t\tif (cmd[i] == 'S') {\n\t\t\t\tint d = dirs.indexOf(table[x][y]);\n\t\t\t\tint tx = x + dr[d];\n\t\t\t\tint ty = y + dc[d];\n\t\t\t\twhile (isin(tx, ty)) {\n\t\t\t\t\tif (table[tx][ty] == '*') {\n\t\t\t\t\t\ttable[tx][ty] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (table[tx][ty] == '#')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\ttx += dr[d];\n\t\t\t\t\tty += dc[d];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmd[i] == 'U') {\n\t\t\t\ttable[x][y] = '^';\n\t\t\t\tif (canmove(x - 1, y)) {\n\t\t\t\t\ttable[x][y] = '.';\n\t\t\t\t\ttable[x-1][y] = '^';\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmd[i] == 'D') {\n\t\t\t\ttable[x][y] = 'v';\n\t\t\t\tif (canmove(x + 1, y)) {\n\t\t\t\t\ttable[x][y] = '.';\n\t\t\t\t\ttable[x+1][y] = 'v';\n\t\t\t\t\tx++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (cmd[i] == 'L') {\n\t\t\t\ttable[x][y] = '<';\n\t\t\t\tif (canmove(x, y-1)) {\n\t\t\t\t\ttable[x][y] = '.';\n\t\t\t\t\ttable[x][y-1] = '<';\n\t\t\t\t\ty--;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (cmd[i] == 'R') {\n\t\t\t\ttable[x][y] = '>';\n\t\t\t\tif (canmove(x, y+1)) {\n\t\t\t\t\ttable[x][y] = '.';\n\t\t\t\t\ttable[x][y+1] = '>';\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < R; i++){\n\t\t\tfor (int j = 0; j < C; j++)\n\t\t\t\tSystem.out.print(table[i][j]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\n\t\tint sysout_cnt = data_set;\n\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\tif(sysout_cnt-- > 0){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\t\t\n\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t//???????????????\n\t\tint[] addr = { -1, 1 };\n\t\twhile (true) {\n\t\t\tif (tank.getDir() == '^') {\n\t\t\t\tpos[0] += addr[0];\n\t\t\t\tif (pos[0] == -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == 'v') {\n\t\t\t\tpos[0] += addr[1];\n\t\t\t\tif (pos[0] >= game_Map[0].length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '<') {\n\t\t\t\tpos[1] += addr[0];\n\t\t\t\tif (pos[1] == -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '>') {\n\t\t\t\tpos[1] += addr[1];\n\t\t\t\tif (pos[1] >= game_Map[0].length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (game_Map[pos[0]][pos[1]]) {\n\t\t\tcase '.':\n\t\t\tcase '-':\n\t\t\t\tcontinue;\n\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\tcase '*':\n\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t\tcase '#':\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\n\t}// canon_Shot????????????????????????\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\tint[] addr = { -1, 1 };\n\n\t\tif (tank.getDir() == '^') {\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == 'v') {\n\t\t\tif (move[0] + 1 < game_Map[0].length) {\n\t\t\t\tmove[0] += addr[1];\n\t\t\t}\n\t\t} else if (tank.getDir() == '<') {\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == '>') {\n\t\t\tif (move[1] + 1 < game_Map[1].length) {\n\t\t\t\tmove[1] += addr[1];\n\t\t\t}\n\t\t}\n\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\ttank.setPos(move);\n\t\t}\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static final int RIGHT = 0;\n\tpublic static final int BELOW = 1;\n\tpublic static final int LEFT = 2;\n\tpublic static final int ABOVE = 3;\n\tpublic static final int X = 0;\n\tpublic static final int Y = 1;\n\tpublic static final int DIR = 2;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\t\t//test();\n\t}\n\tpublic static void test(){\n\t\tString s = \"abcdefg\";\n\t\tint l = s.length();\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tchar c = s.charAt(i);\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\t//make field \n\t\t\tchar[][] field = new char[w][h];\n\t\t\t//x,y,direction\n\t\t\tint[] tank = new int[3];\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tString str = sc.next();\n\t\t\t\t//System.out.println(str);\n\t\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\t\tchar c = str.charAt(k);\n\t\t\t\t\t//System.out.println(c);\n\t\t\t\t\tfield[k][j] = c;\n\t\t\t\t\tif(c == '^'){\n\t\t\t\t\t\ttank[X] = k;\n\t\t\t\t\t\ttank[Y] = j;\n\t\t\t\t\t\ttank[DIR] = ABOVE;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == 'v'){\n\t\t\t\t\t\ttank[X] = k;\n\t\t\t\t\t\ttank[Y] = j;\n\t\t\t\t\t\ttank[DIR] = BELOW;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == '<'){\n\t\t\t\t\t\ttank[X] = k;\n\t\t\t\t\t\ttank[Y] = j;\n\t\t\t\t\t\ttank[DIR] = LEFT;\n\t\t\t\t\t}\n\t\t\t\t\telse if(c == '>'){\n\t\t\t\t\t\ttank[X] = k;\n\t\t\t\t\t\ttank[Y] = j;\n\t\t\t\t\t\ttank[DIR] = RIGHT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tString input = sc.next();\n\t\t\t//execute input\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tchar c = input.charAt(j);\n\t\t\t\tint x = tank[X];\n\t\t\t\tint y = tank[Y];\n\t\t\t\tswitch(c)\n\t\t\t\t{\n\t\t\t\tcase 'U':\n\t\t\t\t\ttank[DIR] = ABOVE;\n\t\t\t\t\tfield[x][y] = '^';\n\t\t\t\t\ty -= 1;\n\t\t\t\t\tif(y >= 0 && field[x][y] == '.'){\n\t\t\t\t\t\ttank[Y] = y;\n\t\t\t\t\t\tfield[x][y] = '^';\n\t\t\t\t\t\tfield[x][y + 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttank[DIR] = BELOW;\n\t\t\t\t\tfield[x][y] = 'v';\n\t\t\t\t\ty += 1;\n\t\t\t\t\tif(y < h && field[x][y] == '.'){\n\t\t\t\t\t\ttank[Y] = y;\n\t\t\t\t\t\tfield[x][y] = 'v';\n\t\t\t\t\t\tfield[x][y - 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\ttank[DIR] = LEFT;\n\t\t\t\t\tfield[x][y] = '<';\n\t\t\t\t\tx -= 1;\n\t\t\t\t\tif(x >= 0 && field[x][y] == '.'){\n\t\t\t\t\t\ttank[X] = x;\n\t\t\t\t\t\tfield[x][y] = '<';\n\t\t\t\t\t\tfield[x + 1][y] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\ttank[DIR] = RIGHT;\n\t\t\t\t\tfield[x][y] = '>';\n\t\t\t\t\tx += 1;\n\t\t\t\t\tif(x < w && field[x][y] == '.'){\n\t\t\t\t\t\ttank[X] = x;\n\t\t\t\t\t\tfield[x][y] = '>';\n\t\t\t\t\t\tfield[x - 1][y] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tif(tank[DIR] == ABOVE){\n\t\t\t\t\t\tfor(int k = y - 1; k >= 0; k--){\n\t\t\t\t\t\t\t//レンガの壁だったら\n\t\t\t\t\t\t\tif(field[x][k] == '*'){\n\t\t\t\t\t\t\t\tfield[x][k] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[x][k] == '#'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(tank[DIR] == BELOW){\n\t\t\t\t\t\tfor(int k = y + 1; k < h; k++){\n\t\t\t\t\t\t\t//レンガの壁だったら\n\t\t\t\t\t\t\tif(field[x][k] == '*'){\n\t\t\t\t\t\t\t\tfield[x][k] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[x][k] == '#'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(tank[DIR] == RIGHT){\n\t\t\t\t\t\tfor(int k = x + 1; k < w; k++){\n\t\t\t\t\t\t\t//レンガの壁だったら\n\t\t\t\t\t\t\tif(field[k][y] == '*'){\n\t\t\t\t\t\t\t\tfield[k][y] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[k][y] == '#'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(tank[DIR] == LEFT){\n\t\t\t\t\t\tfor(int k = x - 1; k >= 0; k--){\n\t\t\t\t\t\t\t//レンガの壁だったら\n\t\t\t\t\t\t\tif(field[k][y] == '*'){\n\t\t\t\t\t\t\t\tfield[k][y] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[k][y] == '#'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"j = \" + j + \", c = \" + c);\n\t\t\t\t//System.out.println(\"x = \" + tank[X] + \", y = \" + tank[Y]);\n\t\t\t\t//print(field, false);\n\t\t\t}\n\t\t\tif(i != t - 1){\n\t\t\t\tprint(field, false);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprint(field, true);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void print(char[][] field, boolean bLast){\n\t\tint w = field.length;\n\t\tint h = field[0].length;\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tfor(int k = 0; k < w - 1; k++){\n\t\t\t\tSystem.out.print(field[k][j]);\n\t\t\t}\n\t\t\tSystem.out.println(field[w - 1][j]);\n\t\t}\n\t\tif(bLast == false){\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ?????????????????????????????£????????????????????§???????????????\n\t\t\tField field = new Field(townMap);\n\t\t\t// ??????????????????????????????\n\t\t\tint[] tankPosition = field.tankPosition();\n\t\t\t// ????????????????????????\n\t\t\tString tankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank(tankPosition, tankDirection);\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(tankDirection, field);\n\n\t\t\t\t// ?§???????????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ???????§????????????????\n\t\t\t\t\ttank.move(commandArray[j], field);\n\t\t\t\t\t// ?§?????????????????????????????????´??°\n\t\t\t\t\ttankPosition = field.tankPosition();\n\t\t\t\t\t// ?§?????????????????????????????????´??°\n\t\t\t\t\ttankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ?????£??????????????????\nclass Field{\n\n\t// ?????£??????????????°\n\tString[][] field;\n\n\t// ?????????????????????\n\tField(String[][] field){\n\n\t\tthis.field = new String[field.length][];\n\n\t\tfor(int i = 0; i < field.length; i++) {\n\n\t\t\tthis.field[i] = field[i];\n\n\t\t\tfor(int j = 0; j < field[i].length; j++) {\n\n\t\t\t\tthis.field[i][j] = field[i][j];\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// ??????????????????????´¢??????????????????\n\tint[] tankPosition() {\n\n\t\tint[] tankPosition = new int[2];\n\n\t\tfor(int i = 0; i < this.field.length; i++) {\n\n\t\t\tfor(int j = 0; j < this.field[i].length; j++) {\n\n\t\t\t\tif(field[i][j].equals(\"^\") || field[i][j].equals(\"v\")\n\t\t\t\t\t\t|| field[i][j].equals(\"<\") || field[i][j].equals(\">\")) {\n\n\t\t\t\t\ttankPosition[0] = i;\n\t\t\t\t\ttankPosition[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tankPosition;\n\n\t}\n}\n\n// ???????????????\nclass Tank{\n\n\t// ?????£??????????????°\n\tint[] tankPosition = new int[2];\n\tString tankDirection;\n\n\t// ?????????????????????\n\tTank(int[] tankPosition, String tankDirection) {\n\n\t\tthis.tankPosition[0] = tankPosition[0];\n\t\tthis.tankPosition[1] = tankPosition[1];\n\t\tthis.tankDirection = tankDirection;\n\t}\n\n\t// ??????????§??????????????????????\n\tvoid move(char command, Field field) {\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command) {\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != 0 && field.field[tankPosition[0] - 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] - 1][tankPosition[1]] = \"^\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[0] = tankPosition[0] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"^\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'D':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != field.field.length - 1 && field.field[tankPosition[0] + 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] + 1][tankPosition[1]] = \"v\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[0] = tankPosition[0] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"v\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'L':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != 0 && field.field[tankPosition[0]][tankPosition[1] - 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] - 1] = \"<\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[1] = tankPosition[1] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"<\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'R':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != field.field[0].length - 1 && field.field[tankPosition[0]][tankPosition[1] + 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] + 1] = \">\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[1] = tankPosition[1] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \">\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\t// ???????????????????????????\n\tvoid shoot(String tankDirection, Field field) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(tankDirection) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPosition[0] - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPosition[0] + 1; i < field.field.length; i++) {\n\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPosition[1] - 1; i >= 0; i--) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPosition[1] + 1; i < field.field[0].length; i++) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}\n\n\n//===========================??????=============================================\n\n/*public class MainBatlleTown {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tint tankPositionH = 0;\n\t\t\tint tankPositionW = 0;\n\n\t\t\tfor(int j = 0; j < height; j++) {\n\n\t\t\t\tfor(int k = 0; k < width; k++) {\n\n\t\t\t\t\tif(townMap[j][k].equals(\"^\") || townMap[j][k].equals(\"v\")\n\t\t\t\t\t\t\t|| townMap[j][k].equals(\"<\") || townMap[j][k].equals(\">\")) {\n\n\t\t\t\t\t\ttankPositionH = j;\n\t\t\t\t\t\ttankPositionW = k;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t// ??????????§?????????´???\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?????????)\n\t\t\t\t\ttankPositionH = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t// ?¨????????§?????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?¨???????)\n\t\t\t\t\ttankPositionW = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// ???????????????\nclass Tank{\n\n\t// ??????????§??????????????????????\n\tint move(char command, String[][] townMap, int height, int width, int tankPositionH, int tankPositionW){\n\n\t\t// ?????????(??????????????¨??°)?????\\???????????°\n\t\tint tankPosition = 0;\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command){\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t// ?????¨??°????????????????????????????????????????????????\n\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°????????°???????????????\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t// ?§???????????????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH - 1;\n\n\t\t\t// ???????????°?????????????????°?????????????????´\n\t\t\t} else {\n\n\t\t\t\t// ???????????´\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ???????§????????????????\n\t\tcase 'D':\n\n\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionH + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'L':\n\n\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW - 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'R':\n\n\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// ?????´??????????????¨??°???????????????\n\t\treturn tankPosition;\n\n\t}\n\n\n\t// ???????????????????????????\n\tvoid shoot(String[][] townMap, int height, int width, int tankPositionH, int tankPositionW) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(townMap[tankPositionH][tankPositionW]) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPositionH - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°??????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPositionH + 1; i < height; i++) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPositionW - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPositionW + 1; i < width; i++) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}*/\n\n//=======================================================================\n\n\t\t\t//???????????°?????????????????????\n\t\t\t/*for(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ?????????????????????????????§??????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\t// String direction = tank.changeDirection(commandArray[j]);\n\t\t\t\t\ttankPositionH = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttankPositionW = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t\t// ????????????????????????????????¨??????????????´\n\t\t\t\t\tswitch(direction) {\n\n\t\t\t\t\tcase \"^\":\n\n\t\t\t\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"v\":\n\n\t\t\t\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"<\":\n\n\t\t\t\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \">\":\n\n\t\t\t\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}*/\n\n\n\t\t\t\t//String direction = tank.changeDirection(commandArray[j]);\n\n\t\t\t\t//String direction = null;\n\n\t\t\t\t/*\n\t\t\t\tswitch(direction){\n\t\t\t\tcase 'U':\n\n\t\t\t\t\tdirection = \"^\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'D':\n\n\t\t\t\t\tdirection = \"v\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'L':\n\n\t\t\t\t\tdirection = \"<\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'R':\n\n\t\t\t\t\tdirection = \">\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn direction;\n\n\t\t\t}*/"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic void move_up ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]-1][tank_pos[0]] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]-1][tank_pos[0]] = '^';\n\t\t\ttank_pos[1]--;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '^';\n\t\t}\n\t}\n\n\tstatic void move_down ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]+1][tank_pos[0]] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]+1][tank_pos[0]] = 'v';\n\t\t\ttank_pos[1]++;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = 'v';\n\t\t}\n\t}\n\n\tstatic void move_left ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]][tank_pos[0]-1] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]][tank_pos[0]-1] = '<';\n\t\t\ttank_pos[0]--;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '<';\n\t\t}\n\t}\n\n\tstatic void move_right ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]][tank_pos[0]+1] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]][tank_pos[0]+1] = '>';\n\t\t\ttank_pos[0]++;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '>';\n\t\t}\n\t}\n\n\tstatic void shoot ( char[][] map, int tank_x, int tank_y ) {\n\n\t\tint missile_x = tank_x;\n\t\tint missile_y = tank_y;\n\n\t\twhile ( true ) {\n\t\t\tif ( map[tank_y][tank_x] == '^' ) {\n\t\t\t\tmissile_y--;\n\t\t\t} else if ( map[tank_y][tank_x] == 'v' ) {\n\t\t\t\tmissile_y++;\n\t\t\t} else if ( map[tank_y][tank_x] == '<' ) {\n\t\t\t\tmissile_x--;\n\t\t\t} else if ( map[tank_y][tank_x] == '>' ) {\n\t\t\t\tmissile_x++;\n\t\t\t}\n\n\t\t\tif ( map[missile_y][missile_x] == '*' ) {\n\t\t\t\tmap[missile_y][missile_x] = '.';\n\t\t\t\tbreak;\n\t\t\t} else if( map[missile_y][missile_x] == '#' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\t//データセット数\n\t\tint set_num_T;\n\n\t\tint map_H = 0;\n\t\tint map_W = 0;\n\t\tint input_op_length_N = 0;\n\t\tint[] tank_pos = new int[]{ 0, 0 };\n\t\tString[] str_buf;\n\t\tString str_op = \"\";\n\t\tchar[][] map;\n\t\tchar[] tank = new char[]{'^','>','v','<'};\n\n\t\tScanner sc= new Scanner( System.in );\n\n\t\tset_num_T = sc.nextInt();\n\n\t\tfor( int i = 0; i < set_num_T ; i++ ) {\n\n\t\t\t//データ読み込み\n\t\t\tmap_H = sc.nextInt();\n\t\t\tmap_W = sc.nextInt();\n\n\t\t\tstr_buf= new String[map_W+2];\n\t\t\tmap = new char[map_H+2][map_W+2];\n\n\t\t\tfor ( int j = 0 ; j < map_H ; j++ ) {\n\t\t\t\tstr_buf[j] =sc.next();\n\t\t\t}\n\n\t\t\tinput_op_length_N = sc.nextInt();\n\t\t\tstr_op = sc.next();\n\n\t\t\t//mapセット mapを#で囲む\n\t\t\tfor ( int j = 0 ; j < map.length ; j++ ) {\n\t\t\t\tfor ( int k = 0 ; k < map[j].length ; k++ ) {\n\t\t\t\t\tif( ( ( j+1 ) % ( map.length-1 ) ) == 1 || ( ( k+1 ) % ( map[i].length-1 ) ) == 1 ) {\n\t\t\t\t\t\tmap[j][k] = '#';\n\t\t\t\t\t}else {\n\t\t\t\t\t\tmap[j][k]=str_buf[j-1].charAt( k-1 );\n\t\t\t\t\t\t//読み込みデータが戦車の時、戦車の位置を取得\n\t\t\t\t\t\tfor( int l = 0 ; l < 4 ; l++ ) {\n\t\t\t\t\t\t\tif( map[j][k] == tank[l] ) {\n\t\t\t\t\t\t\t\ttank_pos[0] = k;\n\t\t\t\t\t\t\t\ttank_pos[1] = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//命令に従ってMAPと戦車を書き換える\n\t\t\tfor ( int j = 0 ; j < input_op_length_N; j++) {\n\t\t\t\tswitch( str_op.charAt(j) ) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tmove_up( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tmove_down( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tmove_left( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tmove_right( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tshoot( map, tank_pos[0], tank_pos[1] );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//結果処理\n\t\t\tfor ( int j = 1 ; j < map_H+1 ; j++ ) {\n\t\t\t\tfor ( int k = 1 ; k < map_W+1 ; k++ ) {\n\t\t\t\t\tSystem.out.print( map[j][k] );\n\t\t\t\t}\n\t\t\t\tSystem.out.print( \"\\n\" );\n\t\t\t}\n\n\t\t\tif(i != set_num_T-1) {\n\t\t\t\tSystem.out.print( \"\\n\" );\n\t\t\t}\n\n\t\t}\n\t\tsc.close();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main{\n\t\n\t/**\n\t * プログラムエントリポイント\n\t * @param args\n\t */\n\tpublic static void main (String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//データセット回数を入力\n\t\tint setCountData = sc.nextInt();\n\t\t//入力されたデータセット回数分繰り返す\n\t\tfor( int i = 0 ; i < setCountData ; i++ ){\n\t\t\t//繰り返す回数ごとに配列を作成して２次元配列の長さを入力\n\t\t\tchar[][] aryBattleArea = new char[sc.nextInt()][sc.nextInt()];\n\t\t\t//配列aryBattleAreaに市街戦の要素入力\n\t\t\tfor( int j = 0 ; j < aryBattleArea.length ; j++ ){\n\t\t\t\taryBattleArea[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\t//繰り返す回数ごとに配列を作成して１次元配列の長さを入力\n\t\t\tchar[] aryOperation = new char[sc.nextInt()];\n\t\t\t//配列aryOperationに操作分を入力したものを文字ごとに配列に格納\n\t\t\taryOperation = sc.next().toCharArray();\n\t\t\t\n\t\t\t//BattleTownをインスタンス化\n\t\t\tBattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n\t\t\t\n\t\t\taryBattleArea = insBt.runOperation();\n\t\t\t\n\t\t\tfor( int x = 0 ; x < aryBattleArea.length ; x++ ){\n\t\t\t\tfor( int y = 0 ; y < aryBattleArea[i].length ; y++ ){\n\t\t\t\t\tSystem.out.print(aryBattleArea[x][y]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\n/**\n * \n * 操作を実行する\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n\t\n\tprivate char[][] aryBattleArea;\n\tprivate char[] aryOperation;\n\t\n\t/**\n\t * コンストラクタ\n\t * @param aryBattleArea 戦場を表す二次元配列\n\t * @param aryOperation 命令を表す一次元配列\n\t */\n\tpublic BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n\t\t\n\t\tthis.aryBattleArea = aryBattleArea;\n\t\tthis.aryOperation = aryOperation;\n\t\t\n\t}\n\t/**\n\t * 指定された操作を順番にactionTankクラス渡し\n\t * 渡した操作は'0'にして読み取れないように\n\t */\n\tpublic char[][] runOperation(){\n\t\t\n\t\tfor( int k = 0 ; k < aryOperation.length ; k++ ){\n\t\t\t\n\t\t\tfor( int i = 0 ; i < aryBattleArea.length ; i++ ){\n\t\t\t\tfor( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n\t\t\t\t\t\t|| aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( aryOperation[k] != '0' ){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tactionTank( i , j , aryOperation[k] );\n\t\t\t\t\t\t\taryOperation[k] = '0';\n\t\t\t\t\t\t\trunOperation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn aryBattleArea;\n\t}\n\t\n\t/**\n\t * 指定された操作を実行する\n\t * @param i 戦車を発見した配列の位置\n\t * @param j 戦車を発見した配列の位置\n\t * @param c 操作命令\n\t */\n\tprivate void actionTank( int i , int j , char operation ) {\n\t\t\t\n\t\t\t//戦車上方向\n\t\tif( operation == 'U' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '^';\n\t\t\t\n\t\t\tif( i-1 >= 0 /*&& i+1 < aryBattleArea.length && j-1 >= 0 && j+1 < aryBattleArea[i].length*/){\n\t\t\t\tif( aryBattleArea[i-1][j] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i-1][j] = '^';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t//戦車下方向\n\t\t}else if( operation == 'D' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = 'v';\n\t\t\t\n\t\t\tif(/* i-1 >= 0 &&*/ i+1 < aryBattleArea.length /*&& j-1 >= 0 && j+1 < aryBattleArea[i].length*/){\n\t\t\t\tif( aryBattleArea[i+1][j] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i+1][j] = 'v';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//戦車左方向\n\t\t}else if( operation == 'L' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '<';\n\t\t\t\n\t\t\tif( /*i-1 >= 0 && i+1 < aryBattleArea.length &&*/ j-1 >= 0 /*&& j+1 < aryBattleArea[i].length*/){\n\t\t\t\tif( aryBattleArea[i][j-1] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i][j-1] = '<';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//戦車右方向\n\t\t}else if( operation == 'R' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '>';\n\t\t\t\n\t\t\tif( /*i-1 >= 0 && i+1 < 4 && j-1 >= 0 &&*/ j+1 < aryBattleArea[i].length ){\n\t\t\t\tif( aryBattleArea[i][j+1] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i][j+1] = '>';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}else if( operation == 'S' ){\n\t\t\n\t\t\tif(aryBattleArea[i][j] == '^'){\n\t\t\t\t\n\t\t\t\tfor( int x = i ; x >= 0 ; x-- ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[x][j] == '*' ){\n\t\t\t\t\t\taryBattleArea[x][j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == 'v'){\n\t\t\t\t\n\t\t\t\tfor( int x = i ; x < aryBattleArea.length ; x++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[x][j] == '*' ){\n\t\t\t\t\t\taryBattleArea[x][j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == '<'){\n\t\t\t\t\n\t\t\t\tfor( int x = j ; x >= 0 ; x-- ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][x] == '*' ){\n\t\t\t\t\t\taryBattleArea[i][x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == '>'){\n\t\t\t\t\n\t\t\t\tfor( int x = j ; x < aryBattleArea.length ; x++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][x] == '*' ){\n\t\t\t\t\t\taryBattleArea[i][x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * BattleTownで操作実行をのgetAryBattleAreaを返す\n\t * @return aryBattleAreaを返す\n\t */\n\t//public char[][] getAryBattleArea(){\n\t//\treturn aryBattleArea;\n\t//}\n}"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * プログラムエントリポイント\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        ArrayList<char[][]> listBattleArea = new ArrayList<char[][]>();\n        \n        //データセット回数を入力\n        int setCountData = sc.nextInt();\n        \n        //入力されたデータセット回数分繰り返す\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //繰り返す回数ごとに配列を作成\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //配列aryBattleAreaに市街戦の要素入力\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //繰り返す回数ごとに配列を作成\n            char[] aryOperation = new char[intOperationLength];\n            \n            //配列aryOperationに操作分を入力したものを文字ごとに配列に格納\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTownをインスタンス化\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            listBattleArea.add(aryBattleArea);\n            \n        }\n        \n        for( int i = 0 ; i < listBattleArea.size() ; i++ ){\n        \t\n        \tchar[][] output = listBattleArea.get(i);\n        \t\n        \tfor( int j = 0 ; j < output.length ; j++ ){\n        \t\tfor( int k = 0 ; k < output[j].length ; k++ ){\n        \t\t\t\n        \t\t\tSystem.out.print(output[j][k]);\n        \t\t\t\n        \t\t}\n        \t\tSystem.out.println();\n        \t}\n        \tif( i != listBattleArea.size()-1)\n        \tSystem.out.println();\n        }\n        \n    }\n}\n\n/**\n * \n * 操作を実行する\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    \n    /**\n     * コンストラクタ\n     * @param aryBattleArea 戦場を表す二次元配列\n     * @param aryOperation 命令を表す一次元配列\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * 指定された操作を順番にactionTankクラス渡し\n     * 渡した操作は'0'にして読み取れないように\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * 指定された操作を実行する\n     * @param i 戦車を発見した配列の位置\n     * @param j 戦車を発見した配列の位置\n     * @param c 操作命令\n     */\n\tprivate void actionTank(int tankI, int tankJ, char operation) {\n\t\t\n\t\tchar[] sousa =         { 'U' ,  'D' ,  'R' , 'L' };\n    \tchar[] muki =          { '^' ,  'v' ,  '>' , '<' };\n    \tint[][] susumikata =  {{-1,0},{+1,0},{0,+1},{0,-1}};\n    \t\n    \t\n    \tif( operation != 'S'){\n    \t\t\n    \t\tint Seigen1 = 0;\n        \tint Seigen2 = 0;\n    \t\t\n    \t\tfor( int i = 0 ; i < sousa.length ; i++ ){\n    \t\t\tif( operation == sousa[i]){\n    \t\t\t\t\n    \t\t\t\taryBattleArea[tankI][tankJ] = muki[i];\n    \t\t\t\t\n    \t\t\t\tif( operation == 'U' ){Seigen1 = tankI-1; Seigen2 = 0;};\n    \t\t\t\tif( operation == 'D' ){Seigen1 = aryBattleArea.length-1; Seigen2 = tankI+1;};\n    \t\t\t\tif( operation == 'R' ){Seigen1 = aryBattleArea[tankI].length-1; Seigen2 = tankJ+1;};\n    \t\t\t\tif( operation == 'L' ){Seigen1 = tankJ-1; Seigen2 = 0;};\n    \t\t\t\t\n    \t\t\t\t//if( 0 <= tankI && tankI < aryBattleArea.length   &&   0 <= tankJ && tankJ < aryBattleArea[tankI].length){\n    \t\t\t\tif( Seigen1 >= Seigen2){\n    \t                if( aryBattleArea[ tankI + susumikata[i][0] ][ tankJ + susumikata[i][1] ] == '.' ){\n    \t                \t\n    \t                    aryBattleArea[ tankI ][ tankJ ] = '.';\n    \t                    aryBattleArea[ tankI + susumikata[i][0] ][ tankJ + susumikata[i][1] ] = muki[i];\n    \t                    \n    \t                }\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t}else if(operation == 'S'){\n    \t\t\n    \t\tint TI = tankI;\n    \t\tint TJ = tankJ;\n    \t\t//int Seigen1 = 0;\n        \t//int Seigen2 = 0;\n    \t\t\n    \t\tfor( int i = 0 ; i < muki.length ; i++ ){\n    \t\t\t\n    \t\t\tif( aryBattleArea[TI][TJ] == muki[i]){\n    \t\t\t\t\n    \t\t\t\t//if( operation == 'U' ){Seigen1 = TI; Seigen2 = 0;};\n    \t\t\t\t//if( operation == 'D' ){Seigen1 = aryBattleArea.length-1; Seigen2 = TI;};\n    \t\t\t\t//if( operation == 'R' ){Seigen1 = aryBattleArea[TI].length-1; Seigen2 = TJ;};\n    \t\t\t\t//if( operation == 'L' ){Seigen1 = TJ; Seigen2 = 0;};\n    \t\t\n    \t\t\t\t//while(Seigen1 >= Seigen2){\n    \t\t\t\twhile( 0 <= TI && TI < aryBattleArea.length   &&   0 <= TJ && TJ < aryBattleArea[TI].length){\n            \t\n    \t\t\t\t\tif(aryBattleArea[ TI ][ TJ  ]=='*'){\n    \t\t\t\t\t\taryBattleArea[ TI ][ TJ  ] = '.';\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}else if(aryBattleArea[ TI ][ TJ ]=='#'){\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tTI += susumikata[i][0];\n    \t\t\t\t\tTJ += susumikata[i][1];\n    \t\t\t\t}\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\t\n    \t\t\n    \t\t/*\n            if(aryBattleArea[tankI][tankJ] == '^'){\n                \n                for( int x = tankI ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][tankJ] == '*' ){\n                        aryBattleArea[x][tankJ] = '.';\n                        break;\n                    }else if( aryBattleArea[x][tankJ] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[tankI][tankJ] == 'v'){\n                \n                for( int x = tankI ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][tankJ] == '*' ){\n                        aryBattleArea[x][tankJ] = '.';\n                        break;\n                    }else if( aryBattleArea[x][tankJ] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[tankI][tankJ] == '<'){\n                \n                for( int x = tankJ ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[tankI][x] == '*' ){\n                        aryBattleArea[tankI][x] = '.';\n                        break;\n                    }else if( aryBattleArea[tankI][x] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[tankI][tankJ] == '>'){\n                \n                for( int x = tankJ ; x < aryBattleArea[tankI].length ; x++ ){\n                    \n                    if( aryBattleArea[tankI][x] == '*' ){\n                        aryBattleArea[tankI][x] = '.';\n                        break;\n                    }else if( aryBattleArea[tankI][x] == '#' ){\n                        break;\n                    }\n                }\n            }*/\n    \t\t\n    \t\t\n    \t\t\n    \t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tchar[][] map;\n\tint dir;\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint t = scan.nextInt();\n\t\tint n;\n\t\tchar[] op;\n\t\tfor(int data = 0;data < t;data++){\n\t\t\th = scan.nextInt();\n\t\t\tw = scan.nextInt();\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tmap[i] = scan.next().toCharArray();\n\t\t\t}\n\t\t\tn = scan.nextInt();\n\t\t\top = scan.next().toCharArray();\n\t\t\tboolean fl = false;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(map[i][j] == '^'){\n\t\t\t\t\t\tdir = 0; x = j; y = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(map[i][j] == '<'){\n\t\t\t\t\t\tdir = 3; x = j; y = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(map[i][j] == '>'){\n\t\t\t\t\t\tdir = 2; x = j; y = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(map[i][j] == 'v'){\n\t\t\t\t\t\tdir = 1; x = j; y = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fl){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tswitch(op[i]){\n\t\t\t\tcase 'U': up(); break;\n\t\t\t\tcase 'D': down(); break;\n\t\t\t\tcase 'R': right(); break;\n\t\t\t\tcase 'L': left(); break;\n\t\t\t\tcase 'S': shoot(); break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(data != t-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void up(){\n\t\tdir = 0;\n\t\tif(y != 0){\n\t\t\tif(map[y-1][x] == '.'){\n\t\t\t\tmap[y--][x] = '.';\n\t\t\t\tmap[y][x] = '^';\t\t\t\t\n\t\t\t}\n\t\t}else{\n\t\t\tmap[y][x] = '^';\n\t\t}\n\t}\n\tpublic void down(){\n\t\tdir = 1;\n\t\tif(y != h-1){\n\t\t\tif(map[y+1][x] == '.'){\n\t\t\t\tmap[y++][x] = '.';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t}\n\t\t}else{\n\t\t\tmap[y][x] = 'v';\n\t\t}\n\t}\n\tpublic void right(){\n\t\tdir = 2;\n\t\tif(x != w-1){\n\t\t\tif(map[y][x+1] == '.'){\n\t\t\t\tmap[y][x++] = '.';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t}\n\t\t}else{\n\t\t\tmap[y][x] = '>';\n\t\t}\n\t}\n\tpublic void left(){\n\t\tdir = 3;\n\t\tif(x != 0){\n\t\t\tif(map[y][x-1] == '.'){\n\t\t\t\tmap[y][x--] = '.';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t}\n\t\t}else{\n\t\t\tmap[y][x] = '<';\n\t\t}\n\t}\n\tpublic void shoot(){\n\t\tif(dir == 0){\n\t\t\tfor(int i = y;i >= 0;i--){\n\t\t\t\tif(map[i][x] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[i][x] == '*'){\n\t\t\t\t\tmap[i][x] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir == 1){\n\t\t\tfor(int i = y;i < h;i++){\n\t\t\t\tif(map[i][x] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[i][x] == '*'){\n\t\t\t\t\tmap[i][x] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir == 2){\n\t\t\tfor(int i = x;i < w;i++){\n\t\t\t\tif(map[y][i] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[y][i] == '*'){\n\t\t\t\t\tmap[y][i] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir == 3){\n\t\t\tfor(int i = x;i >= 0;i--){\n\t\t\t\tif(map[y][i] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[y][i] == '*'){\n\t\t\t\t\tmap[y][i] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\n//\t\t ???????????????????¨????\n\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t// ??????????????????????????????\n\t\tswitch (tank.getDir()) {\n\t\t// ('^', { -1, 0 });\n\t\tcase '^':\n\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[cnt][shell[1]]== '*') {\n\t\t\t\t\tgame_Map[cnt][shell[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[cnt][shell[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('v',{ 1, 0 });\n\t\tcase 'v':\n\t\t\tfor (int cnt = 1; cnt < game_Map[0].length  - shell[0]; cnt++) {\n\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]]== '*') {\n\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('<', { 0, -1 });\n\t\tcase '<':\n\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[shell[0]][cnt]== '*') {\n\t\t\t\t\tgame_Map[shell[0]][cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[shell[0]][cnt] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('>', { 0, 1 });\n\t\tcase '>':\n\t\t\tfor (int cnt = 1; cnt < game_Map[1].length - shell[1]; cnt++) {\n\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt]== '*') {\n\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n//\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n//\t\tint[] addr = { -1, 1 };\n//\t\twhile (true) {\n//\t\t\tif (tank.getDir() == '^') {\n//\t\t\t\tpos[0] += addr[0];\n//\t\t\t\tif (pos[0] - 1 >= 0) {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t} else if (tank.getDir() == 'v') {\n//\t\t\t\tpos[0] += addr[1];\n//\t\t\t\tif (pos[0] + 1 < game_Map[0].length) {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t} else if (tank.getDir() == '<') {\n//\t\t\t\tpos[1] += addr[0];\n//\t\t\t\tif (pos[1] - 1 >= 0) {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t} else if (tank.getDir() == '>') {\n//\t\t\t\tpos[1] += addr[1];\n//\t\t\t\tif (pos[1] + 1 < game_Map[1].length) {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tswitch (game_Map[pos[0]][pos[1]]) {\n//\t\t\tcase '.':\n//\t\t\tcase '-':\n//\t\t\t\tcontinue;\n//\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n//\t\t\tcase '*':\n//\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n//\t\t\tcase '#':\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t}\n\t}// canon_Shot????????????????????????\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\tint[] addr = { -1, 1 };\n\n\t\tif (tank.getDir() == '^') {\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == 'v') {\n\t\t\tif (move[0] + 1 < game_Map[0].length) {\n\t\t\t\tmove[0] += addr[1];\n\t\t\t}\n\t\t} else if (tank.getDir() == '<') {\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == '>') {\n\t\t\tif (move[1] + 1 < game_Map[1].length) {\n\t\t\t\tmove[1] += addr[1];\n\t\t\t}\n\t\t}\n\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\ttank.setPos(move);\n\t\t}\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\n\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\n\t\t// ??????????????????????????????\n\t\tswitch (tank.getDir()) {\n\t\t// ('^', { -1, 0 });\n\t\tcase '^':\n\t\t\tfor (int cnt = pos[0]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[cnt][pos[1]] == '*') {\n\t\t\t\t\tgame_Map[cnt][pos[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[cnt][pos[1]]== '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('v',{ 1, 0 });\n\t\tcase 'v':\n\t\t\tfor (int cnt = 1; cnt < game_Map[0].length - pos[0]; cnt++) {\n\t\t\t\tif (game_Map[pos[0] + cnt][pos[1]] == '*') {\n\t\t\t\t\tgame_Map[pos[0] + cnt][pos[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0] + cnt][pos[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('<', { 0, -1 });\n\t\tcase '<':\n\t\t\tfor (int cnt = pos[1]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[pos[0]][cnt]== '*') {\n\t\t\t\t\tgame_Map[pos[0]][cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0]][cnt]== '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('>', { 0, 1 });\n\t\tcase '>':\n\t\t\tfor (int cnt = 1; cnt < game_Map[1].length - pos[1]; cnt++) {\n\t\t\t\tif (game_Map[pos[0]][pos[1] + cnt] == '*') {\n\t\t\t\t\tgame_Map[pos[0]][pos[1] + cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0]][pos[1] + cnt]== '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}// canon_Shot????????????????????????\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\n\t\tswitch (tank.getDir()) {\n\t\tcase '^':\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0]--;\n\t\t\t\tif (game_Map[move[0]][move[1]]== '.') {\n\t\t\t\t\ttank.setPos(move);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tif (move[0] + 1 < game_Map[0].length) {\n\t\t\t\tmove[0] ++;\n\t\t\t\tif (game_Map[move[0]][move[1]]== '.') {\n\t\t\t\t\ttank.setPos(move);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1]--;\n\t\t\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\t\t\ttank.setPos(move);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tif (move[1] + 1 < game_Map[1].length) {\n\t\t\t\tmove[1] ++;\n\t\t\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\t\t\ttank.setPos(move);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\t//?????£?????????????????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString[] area = insBR.readLine().split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±???????´?\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\t//?????£??????????????±?????????\n\t\t\t\tString[] fieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\n\t\t\t//?????????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\n\t\t\tField insField = aryIns[k];\n\t\t\t//????????????????????????????????????????????¨????????????\n\t\t\tint intHeight = insField.field.length;\n\t\t\tint intWidth = insField.field[0].length;\n\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != aryIns.length -1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£????????????????????¨???????????????????????°*/\n\t\tprivate int intHeight;\n\t\tprivate int intWidth;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.intHeight = field.length;\n\t\t\tthis.intWidth = field[0].length;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tString[][] result = new String[N][];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint H = stdIn.nextInt();\n\t\t\tint W = stdIn.nextInt();\n\t\t\tString[] str = new String[H];\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tstr[j] = stdIn.next();\n\t\t\t}\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tmap[j] = str[j].toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint[] now = new int[2];\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif( map[j][k] == '<' || map[j][k] == '>' || map[j][k] == '^' || map[j][k] == 'v' ){\n\t\t\t\t\t\tnow[0] = k;\n\t\t\t\t\t\tnow[1] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint com = stdIn.nextInt();\n\t\t\tString s = stdIn.next();\n\t\t\tchar[] c = s.toCharArray();\n\t\t\tfor(int j = 0; j < com; j++){\n\t\t\t\tif( c[j] == 'U' ){\n\t\t\t\t\tif( now[1] > 0 && map[now[1]-1][now[0]] == '.' ){\n\t\t\t\t\t\tmap[now[1]-1][now[0]] = '^';\n\t\t\t\t\t\tmap[now[1]][now[0]] = '.';\n\t\t\t\t\t\tnow[1]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[now[1]][now[0]] = '^';\n\t\t\t\t\t}\n\t\t\t\t} else if( c[j] == 'D' ){\n\t\t\t\t\tif( now[1] < map.length-1 && map[now[1]+1][now[0]] == '.' ){\n\t\t\t\t\t\tmap[now[1]+1][now[0]] = 'v';\n\t\t\t\t\t\tmap[now[1]][now[0]] = '.';\n\t\t\t\t\t\tnow[1]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[now[1]][now[0]] = 'v';\n\t\t\t\t\t}\n\t\t\t\t} else if( c[j] == 'L' ){\n\t\t\t\t\tif( now[0] > 0 && map[now[1]][now[0]-1] == '.' ){\n\t\t\t\t\t\tmap[now[1]][now[0]-1] = '<';\n\t\t\t\t\t\tmap[now[1]][now[0]] = '.';\n\t\t\t\t\t\tnow[0]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[now[1]][now[0]] = '<';\n\t\t\t\t\t}\n\t\t\t\t} else if( c[j] == 'R' ){\n\t\t\t\t\tif( now[0] < map[now[1]].length-1 && map[now[1]][now[0]+1] == '.' ){\n\t\t\t\t\t\tmap[now[1]][now[0]+1] = '>';\n\t\t\t\t\t\tmap[now[1]][now[0]] = '.';\n\t\t\t\t\t\tnow[0]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[now[1]][now[0]] = '>';\n\t\t\t\t\t}\n\t\t\t\t} else if( c[j] == 'S' ){\n\t\t\t\t\tif( map[now[1]][now[0]] == '>' ){\n\t\t\t\t\t\tfor(int k = now[0]+1; k < map[now[1]].length; k++){\n\t\t\t\t\t\t\tif( map[now[1]][k] == '*' ){\n\t\t\t\t\t\t\t\tmap[now[1]][k] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if( map[now[1]][k] == '#' ){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if( map[now[1]][now[0]] == '<' ){\n\t\t\t\t\t\tfor(int k = now[0]-1; k >= 0; k--){\n\t\t\t\t\t\t\tif( map[now[1]][k] == '*' ){\n\t\t\t\t\t\t\t\tmap[now[1]][k] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if( map[now[1]][k] == '#' ){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\n\t\t\t\t\t} else if( map[now[1]][now[0]] == 'v' ){\n\t\t\t\t\t\tfor(int k = now[1]+1; k < map.length; k++){\n\t\t\t\t\t\t\tif( map[k][now[0]] == '*' ){\n\t\t\t\t\t\t\t\tmap[k][now[0]] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if( map[k][now[0]] == '#' ){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if( map[now[1]][now[0]] == '^' ){\n\t\t\t\t\t\tfor(int k = now[1]-1; k >= 0; k--){\n\t\t\t\t\t\t\tif( map[k][now[0]] == '*' ){\n\t\t\t\t\t\t\t\tmap[k][now[0]] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if( map[k][now[0]] == '#' ){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult[i] = new String[H];\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tresult[i][j] = new String(map[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int j = 0; j < result[i].length; j++){\n\t\t\t\tSystem.out.println(result[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tfor(int i = 0; i < result[N-1].length; i++){\n\t\t\tSystem.out.println(result[N-1][i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    final double EPS = 1.0e-10;\n    final int INF = 1 << 28;\n\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while (true) {\n            if (t == 0)\n                break;\n            int h = sc.nextInt();\n            int w = sc.nextInt();\n            char[][] map = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                map[i] = sc.next().toCharArray();\n            }\n            int n = 0;\n            char[] ord = new char[n = sc.nextInt()];\n            ord = sc.next().toCharArray();\n            // . 平地\n            // * レンガの壁\n            // # 鉄の壁\n            // - 水\n            // ^ 戦車（上向き）\n            // v 戦車（下向き）\n            // < 戦車（左向き）\n            // > 戦車（右向き）\n            //\n            // プレイヤーの入力は文字の列で与えられる． 各文字に対応する動作は表2の通りである．\n            // 表2: プレイヤーの入力に対する動作 文字 動作\n\n            int x = 0;\n            int y = 0;\n            int d = 0;\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    if (map[i][j] == '^') {\n                        x = j;\n                        y = i;\n                        d = 0;\n                        break;\n                    } else if (map[i][j] == '>') {\n                        x = j;\n                        y = i;\n                        d = 1;\n                        break;\n                    } else if (map[i][j] == '<') {\n                        x = j;\n                        y = i;\n                        d = 2;\n                        break;\n                    } else if (map[i][j] == 'v') {\n                        x = j;\n                        y = i;\n                        d = 3;\n                        break;\n                    }\n                }\n            }\n            int dx[] = { 0, 1, -1, 0 };\n            int dy[] = { -1, 0, 0, 1 };\n            for (int i = 0; i < n; i++) {\n                switch (ord[i]) {\n                // U Up: 戦車を上向きに方向転換し，さらに一つ上のマスが平地ならばそのマスに移動する\n                // D Down: 戦車を下向きに方向転換し，さらに一つ下のマスが平地ならばそのマスに移動する\n                // L Left: 戦車を左向きに方向転換し，さらに一つ左のマスが平地ならばそのマスに移動する\n                // R Right: 戦車を右向きに方向転換し，さらに一つ右のマスが平地ならばそのマスに移動する\n                // S Shoot: 戦車が現在向いている方向に砲弾を発射する\n                case 'U':\n                    map[y][x] = '^';\n                    d = 0;\n                    if (y - 1 >= 0 && map[y - 1][x] == '.') {\n                        map[y--][x] = '.';\n                        map[y][x] = '^';\n                    }\n                    break;\n                case 'D':\n                    map[y][x] = 'v';\n                    d = 3;\n                    if (y + 1 < h && map[y + 1][x] == '.') {\n                        map[y++][x] = '.';\n                        map[y][x] = 'v';\n                    }\n                    break;\n                case 'L':\n                    map[y][x] = '<';\n                    d = 2;\n                    if (x - 1 >= 0 && map[y][x - 1] == '.') {\n                        map[y][x--] = '.';\n                        map[y][x] = '<';\n                    }\n                    break;\n                case 'R':\n                    map[y][x] = '>';\n                    d = 1;\n                    if (x + 1 < w && map[y][x + 1] == '.') {\n                        map[y][x++] = '.';\n                        map[y][x] = '>';\n                    }\n                    break;\n                case 'S':\n                    int nx = x;\n                    int ny = y;\n                    while (true) {\n                        nx = nx + dx[d];\n                        ny = ny + dy[d];\n                        if (nx < 0 || nx >= w || ny < 0 || ny >= h)\n                            break;\n                        if (map[ny][nx] == '#')\n                            break;\n                        if (map[ny][nx] == '*') {\n                            map[ny][nx] = '.';\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    System.out.print(map[i][j]);\n                }\n                System.out.println();\n            }\n            t--;\n            if (t != 0)\n                System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\n\t\tsc = new Scanner(System.in);\n\t\ttry {\n\n\t\t\t//???????????°???????????????\n\t\t\tint input = Integer.parseInt(sc.next());\n\t\t\tfor (int i = 0; i < input; i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\n\t\t\t\t//??????????????????\n\t\t\t\tint depth = sc.nextInt();\n\t\t\t\tint width = sc.nextInt();\n\t\t\t\tString[][] map = new String[depth][width];\n\t\t\t\tString line = \"\";//sc.nextLine();\n\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\t//?????????????????????\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\tString[] list = line.split(\"\");\n\t\t\t\t\t//????????????????´???????\n\t\t\t\t\tfor (int k = 0; k < map[0].length; k++) {\n\t\t\t\t\t\tmap[j][k] = list[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//?????????????????????\n\t\t\t\tint commNum = Integer.parseInt(sc.next());\n\t\t\t\tline = sc.next();\n\t\t\t\tString[] command = line.split(\"\");\n\n\t\t\t\tmap = command(map,command);\n\n\t\t\t\t//???????????????\n\t\t\t\tString output = \"\";\n\t\t\t\tfor (String[] gamemap : map) {\n\n\t\t\t\t\tfor (String cel : gamemap) {\n\t\t\t\t\t\toutput += cel;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\toutput = \"\";\n\t\t\t\t}\n\n\t\t\t}\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n\t//???????????????????????????????????????\n\tpublic static String[][] command(String[][] map, String[] comm) {\n\n\t\tint dep = 0;\n\t\tint wid = 0;\n\t\tString player = \"\";\n\t\tString[][] playmap;\n\t\tString[] command;\n\n\t\tplaymap = map;\n\t\tcommand = comm;\n\n\t\t\t//?????????????????¨???????????????\n\t\tfor (int i = 0; i < playmap.length; i++) {\n\t\t\tif (player.equals(\"\")) {\n\n\t\t\t\tfor (int j = 0; j < playmap[0].length; j++) {\n\t\t\t\t\t//?????????????????§??????\n\t\t\t\t\tif (playmap[i][j].equals(\"^\")) {\n\t\t\t\t\t\tplayer = \"^\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"v\")) {\n\t\t\t\t\t\tplayer = \"v\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\">\")) {\n\t\t\t\t\t\tplayer = \">\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"<\")) {\n\t\t\t\t\t\tplayer = \"<\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//?????????????????????\n\t\tfor (int i = 0; i < command.length; i++) {\n\t\t\t//??????????????§????????????\n\t\t\tswitch (command[i]) {\n\t\t\tcase \"U\":\n\t\t\t\tplaymap[dep][wid] = \"^\";\n\t\t\t\tplayer = \"^\";\n\t\t\t\tif (dep != 0 && playmap[dep - 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep - 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tplaymap[dep][wid] = \"v\";\n\t\t\t\tplayer = \"v\";\n\t\t\t\tif (dep != playmap.length - 1 && playmap[dep + 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep + 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"R\":\n\t\t\t\tplaymap[dep][wid] = \">\";\n\t\t\t\tplayer = \">\";\n\t\t\t\tif (wid != playmap[0].length - 1 && playmap[dep][wid + 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid + 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tplaymap[dep][wid] = \"<\";\n\t\t\t\tplayer = \"<\";\n\t\t\t\tif (wid != 0 && playmap[dep][wid - 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid - 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\t//???????????????????????´???\n\t\t\t\tif (player.equals(\"^\")) {\n\t\t\t\t\tint count = dep;\n\t\t\t\t\tfor (int k = 0; k <= dep; k++) {\n\t\t\t\t\t\tif (playmap[count][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[count][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"v\")) {\n\t\t\t\t\tfor (int k = dep; k < playmap.length; k++) {\n\t\t\t\t\t\tif (playmap[k][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[k][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\">\")) {\n\t\t\t\t\tfor (int k = wid; k < playmap[0].length; k++) {\n\t\t\t\t\t\tif (playmap[dep][k].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][k] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][k].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"<\")) {\n\t\t\t\t\tint count = wid;\n\t\t\t\t\tfor (int k = 0; k <= wid; k++) {\n\t\t\t\t\t\tif (playmap[dep][count].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][count] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][count].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"othercCommand\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn playmap;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map2> map_list = new ArrayList<map2>();\n\n\n\n\t\t// 入力の回数\n        Scanner sc = new Scanner(System.in);\n        int input_length = sc.nextInt();\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t// マップの高さ\n\t\t\theight = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\twidth = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap2 map = new map2();\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank2 tank = new tank2();\n\t\t\tmap.setMap(height, width);\n\n\t\t\tString line = null;\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tline = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint command_number = 0;\n\t\t\tString command_attack = \"\";\n\t\t\t// コマンド入力回数\n\t\t\tcommand_number = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\n\t\t\tcommand_attack = sc.next();\n\t\t\t// ひとつずつ配列に入れる\n\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (map2 obj : map_list) {\n\t\t\tobj.out_map();\n\t\t\t// 改行\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\n\t}\n\n}\n\nclass tank2 {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map2 {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// ?????????????§???????????????????\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ????????????????????????\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tTank2[][] game_Map = new Tank2[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank2 tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], new Tank2('W'));\n\t\t\t}\n\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (game_Map[mh][mw + 1].getMap_info() == '^' || game_Map[mh][mw + 1].getMap_info() == 'v'\n\t\t\t\t\t\t\t|| game_Map[mh][mw + 1].getMap_info() == '<' || game_Map[mh][mw + 1].getMap_info() == '>') {\n\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank2(game_Map[mh][mw + 1].getMap_info(), new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\tcommand(tank, game_Map, cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ??????????????£????§?????????????????????????????????????\n\t *\n\t * @param game_Map\n\t * @param tank\n\t *\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void command(Tank2 tank, Tank2[][] game_Map, char cmd) {\n\t\t// ?§????\n\t\tif (cmd != 'S') {\n\t\t\t// ??????????????±?????????\n\t\t\ttank.setDir(tank.getMove_Cmd().get(cmd));\n\t\t\tint[] next = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tnext[0] += tank.getMove_Dir().get(tank.getDir())[0];\n\t\t\tnext[1] += tank.getMove_Dir().get(tank.getDir())[1];\n\t\t\t// ?????°???????§??????????\n\t\t\tif (game_Map[next[0]][next[1]].getMap_info() == '.') {\n\t\t\t\ttank.setPos(next);\n\t\t\t}\n\t\t\t// ??????\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\twhile (true) {\n\t\t\t\t// ????????????????????¢\n\t\t\t\tshell[0] += tank.getMove_Dir().get(tank.getDir())[0];\n\t\t\t\tshell[1] += tank.getMove_Dir().get(tank.getDir())[1];\n\t\t\t\tswitch (game_Map[shell[0]][shell[1]].getMap_info()) {\n\t\t\t\tcase '.':\n\t\t\t\tcase '-':\n\t\t\t\t\tcontinue;\n\t\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\t\tcase '*':\n\t\t\t\t\tgame_Map[shell[0]][shell[1]] = new Tank2('.');\n\t\t\t\tcase '#':\n\t\t\t\t\t// ??????????£???¨??¶????????£????????????????¶????\n\t\t\t\tcase 'W':\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}// command????????????????????????\n\n\tprivate static void last_tankLocate(Tank2 tank, Tank2[][] game_Map) {\n\t\t// ?????????????????¨??°?????°????????¨?¨???????\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Tank2(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n}\n\nclass Tank2 {\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] pos) {\n\t\tthis.pos = pos;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char dir) {\n\t\tthis.dir = dir;\n\t}\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\t/*\n\t * ????????????????????????\n\t */\n\tpublic Tank2(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Tank2(char dir, int[] tank_pos) {\n\t\tthis.dir = dir;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/*\n\t * ?§??????????\n\t */\n\tprivate HashMap<Character, Character> move_Cmd = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t/*\n\t * ?§??????¢???\n\t */\n\tprivate HashMap<Character, int[]> move_Dir = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\tpublic HashMap<Character, Character> getMove_Cmd() {\n\t\treturn move_Cmd;\n\t}\n\n\t// public void setMove_Cmd(HashMap<Character, Character> move_Cmd) {\n\t// this.move_Cmd = move_Cmd;\n\t// }\n\n\tpublic HashMap<Character, int[]> getMove_Dir() {\n\t\treturn move_Dir;\n\t}\n\n\t// public void setMove_Dir(HashMap<Character, int[]> move_Dir) {\n\t// this.move_Dir = move_Dir;\n\t// }\n\n}// tank2 ?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);String o,e=\"\";for(int t=s.nextInt(),i,j,p,q,d,h,w;t-->0;){char[]m=new char[(h=s.nextInt())*(w=s.nextInt()+2)],x,a={60,62,94,118},b={76,82,85,68};int[]r={-1,1,-w,w};for(i=p=0;i<h;++i)for(j=0,x=s.next().toCharArray();j<w-2;++j)for(q=0;q<4;++q)if(a[q]==(m[i*w+j+1]=x[j]))p=i*w+j+1;s.next();o=s.next();for(char c:o.toCharArray())if(c==83){for(i=0;a[i]!=m[p];++i);d=r[i];for(q=p+d;0<q&&q<h*w&&(m[q]==45||m[q]==46);q+=d);if(0<q&&q<h*w&&m[q]==42)m[q]=46;}else for(i=4;i-->0;)if(c==b[i]){d=r[i];q=p+d;if(!(0<q&&q<h*w&&m[q]==46))q-=d;m[p]=46;m[p=q]=a[i];}for(i=0;i<h;++i,e+=\"\\n\")for(j=1;j<w-1;++j)e+=m[i*w+j];e+=\"\\n\";}System.out.print(e.replaceAll(\"\\n$\",\"\"));}}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tStringBuilder result = new StringBuilder();\n\t\tScanner scan = new Scanner(System.in);\n\t\tint setCount = scan.nextInt();\n\n\t\t// setCount????????°??°???????????????\n\t\tfor(int i=0;i<setCount;i++){\n\n\t\t// PlayerControl??????????????????????????????\n\t\tPlayerControl pc = new PlayerControl(scan.nextInt(), scan.nextInt());\n\t\t// ????????????????????????\n\t\tpc.mapBuild(scan);\n\n\t\t// System.out.println(pc.map[3][0]);\n\n\t\t// ?????¬???????????\\??????????????°?????????\n\t\tint playerControlCount = scan.nextInt();\n\t\t// ?????¬???????????\\??????????????????????????????\n\t\tString setPlayerControl = scan.next();\n\t\tfor (int k = 0; k < playerControlCount; k++) {\n\t\t\tif (String.valueOf(setPlayerControl.charAt(k)).equals(\"S\")) {\n\t\t\t\t// ???????????????????????????????????????????°??????????\n\t\t\t\tpc.tankShoot();\n\t\t\t} else {\n\t\t\t\t// ?????????????????¢??????????????????????????°??§????????°?§??????????\n\t\t\t\tpc.tankMove(String.valueOf(setPlayerControl.charAt(k)));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//???????????¨????????????????????????result????????????????????????\n\t\tresult.append(pc.mapOutput()).append(\"\\n\");\n\t\t}\n\t\t\n\t\tresult.deleteCharAt(result.length() - 2);\n\t\tSystem.out.print(new String(result));\n\n\t\t\n\n\t}\n}\n\n/**\n * ?????¬????????????????????????????????????????????????\n * \n * @author SS\n *\n */\nclass PlayerControl {\n\t// ??????????????????\n\tString map[][];\n\n\t// ??????????????±\n\tint tankHeight;\n\tint tankWidth;\n\tString tankState;\n\n\t// ?????????????????????????????¨????????????????¨????\n\tPlayerControl(int height, int width) {\n\t\tmap = new String[height][width];\n\t\ttankHeight = 0;\n\t\ttankWidth = 0;\n\t\ttankState = \"\";\n\t}\n\n\t/**\n\t * ??????????????????\n\t * \n\t * @param main???Scanner??????????¶????\n\t */\n\tpublic void mapBuild(Scanner scan) {\n\t\t// height * width ??????????????§??????????????????????????????\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tString setObject = scan.next();\n\t\t\tfor (int j = 0; j < map[0].length; j++) {\n\t\t\t\t// ?????????????????¨??¶???????????±????¨????\n\t\t\t\tswitch (map[i][j] = String.valueOf(setObject.charAt(j))) {\n\t\t\t\tcase \"^\":\n\n\t\t\t\t\ttankInfo(i, j, \"^\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"v\":\n\t\t\t\t\ttankInfo(i, j, \"v\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \">\":\n\t\t\t\t\ttankInfo(i, j, \">\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"<\":\n\t\t\t\t\ttankInfo(i, j, \"<\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * ?????????????????¨??¶???????¨??????????\n\t * \n\t * @param height\n\t *            ????????§?¨?\n\t * @param width\n\t *            ?¨??????§?¨?\n\t * @param state\n\t *            ??¶?????????????????????\n\t */\n\tprivate void tankInfo(int height, int width, String state) {\n\n\t\ttankHeight = height;\n\t\ttankWidth = width;\n\t\ttankState = state;\n\n\t}\n\n\t/**\n\t * \n\t * @param ?????¬???????????????????????????????????????\n\t */\n\tpublic void Control(String instruction) {\n\t\tswitch (instruction) {\n\t\tcase \"S\":// ???????????????????????¨???\n\t\t\tSystem.out.println(\"tankShoot()???????????????\");\n\t\t\ttankShoot();\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tpublic void tankMove(String move) {\n\t\tswitch (move) {\n\t\tcase \"U\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"^\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????????§????????¨?????????????????????\n\t\t\tif (tankHeight - 1 >= 0) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight - 1][tankWidth].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight - 1][tankWidth] = \"^\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight - 1, tankWidth, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"D\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"v\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\t\t\t\n\t\t\t// ?????????????????????????¶????????????¨?????????????????????\n\t\t\tif (tankHeight + 1 < map.length) {\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight + 1][tankWidth].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight + 1][tankWidth] = \"v\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight + 1, tankWidth, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"L\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"<\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????????§????????¨?????????????????????\n\t\t\tif (tankWidth - 1 >= 0) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight][tankWidth - 1].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight][tankWidth - 1] = \"<\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight, tankWidth - 1, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"R\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \">\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????¶????????????¨?????????????????????\n\t\t\tif (tankWidth + 1 < map[0].length) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight][tankWidth + 1].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight][tankWidth + 1] = \">\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight, tankWidth + 1, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * S?????????????????¨??????????????????????????????????????????????°????????????? ??¬?????¬????£??????¶????????£?????¨???????????¬?????¬????£?????????°??¨?????????\n\t */\n\tpublic void tankShoot() {\n\t\t\tswitch (tankState) {\n\t\t\tcase \"^\":// ???????????????????????????\n\n\t\t\t\tfor (int i = 1; i <= tankHeight; i++) {\n\t\t\t\t\tif (map[tankHeight - i][tankWidth].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight - i][tankWidth] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight - i][tankWidth].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase \"v\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= (map.length - 1) - tankHeight; i++) {\n\t\t\t\t\tif (map[tankHeight + i][tankWidth].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight + i][tankWidth] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight + i][tankWidth].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \">\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= (map[0].length - 1) - tankWidth; i++) {\n\t\t\t\t\tif (map[tankHeight][tankWidth + i].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight][tankWidth + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight][tankWidth + i].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"<\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= tankWidth; i++) {\n\t\t\t\t\tif (map[tankHeight][tankWidth - i].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight][tankWidth - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight][tankWidth - i].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t}\n\n\tpublic StringBuilder mapOutput() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tfor (int j = 0; j < map[0].length; j++) {\n\t\t\t\tsb.append(map[i][j]);\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\t\n\t\treturn sb;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\t// ???????????????\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tString[][] game_Map = new String[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], \"W\");\n\t\t\t}\n\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = String.valueOf(tmp_row.charAt(mw));\n\n\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t// ???????????????????????°????????????\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw + 1]) > -1) {\n\t\t\t\t\t\t// init tank.\n\t\t\t\t\t\ttank = new Tank(game_Map, game_Map[mh][mw + 1], new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = \".\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray()) tank.command(cmd);\n\t\t\t//????????????????????????????????±?????¨?¨???????\n\t\t\ttank.last_tankLocate();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\t// ???????????????????????°????????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n}// ???????????????????????????????????????\n\nclass Tank {\n\n    /*\n\t * ?§??????????\n\t */\n\tstatic HashMap<String, String> move_Cmd = new HashMap<String, String>() {\n\t\t{\n\t\t\tput(\"U\", \"^\");\n\t\t\tput(\"D\", \"v\");\n\t\t\tput(\"L\", \"<\");\n\t\t\tput(\"R\", \">\");\n\t\t}\n\t};\n   /*\n\t * ?§??????¢???\n\t */\n\tstatic HashMap<String, int[]> move_Dir = new HashMap<String, int[]>() {\n\t\t{\n\t\t\tput(\"^\", new int[] { -1, 0 });\n\t\t\tput(\"v\", new int[] { 1, 0 });\n\t\t\tput(\"<\", new int[] { 0, -1 });\n\t\t\tput(\">\", new int[] { 0, 1 });\n\t\t}\n\t};\n\n   /**\n\t * ?????????\n\t */\n\tprivate String[][] map;\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate String dir;\n\n\t/*\n\t * ????????????????????????\n\t */\n\tTank(String[][] game_Map, String tank_dir, int[] tank_pos) {\n\t\tthis.map = game_Map;\n\t\tthis.pos = tank_pos;\n\t\tthis.dir = tank_dir;\n\t}\n\n\n   // ???????????????????????°????????????\n\tvoid command(char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\tmove_tank(String.valueOf(cmd));\n\t\t} else {\n\t\t\tcannon_Shot();\n\t\t}\n\t}\n\n    /**\n\t * <pre>\n\t *?????????????§????\n\t *\n\t *???????????°???????§??????????\n\t *???????????¬??????????????????????????£????§???????????????¨?????????\n\t * </pre>\n\t *\n\t * @param cmd\n\t *            ?????¬??????????????????\n\t * @param move\n\t *            ??????????§????\n\t */\n\tprivate void move_tank(String cmd) {\n       this.dir = move_Cmd.get(cmd);\n\t\tint[] move = new int[] { this.pos[0], this.pos[1] };\n\t\tmove[0] += move_Dir.get(this.dir)[0];\n\t\tmove[1] += move_Dir.get(this.dir)[1];\n\t\tif (map[move[0]][move[1]] == \".\") {\n\t\t\tthis.pos[0] = move[0];\n\t\t\tthis.pos[1] = move[1];\n\t\t}\n\t}// move_tank????????????????????????\n\n    /**\n\t * <pre>\n\t * ?????????????????????\n\t * ????????¬?????¬????£??????¶????????£???????????°?????????\n\t * ?????????????£??????°?????????\n\t * ????????°??????????????¨??§?????£????????????????¶????\n\t * </pre>\n\t *\n\t * @param shell\n\t *            ??????\n\t */\n\tprivate void cannon_Shot() {\n        int[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\twhile (true) {\n\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\tcase \".\":\n\t\t\tcase \"-\":\n\t\t\t\tcontinue;\n\t\t\tcase \"*\":\n\t\t\t\tmap[shell[0]][shell[1]] = \".\";\n\t\t\tcase \"#\":\n\t\t\tcase \"W\":\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n    }// cannon_Shoot????????????????????????\n\n    void last_tankLocate() {\n// ?????????????????¨??°?????°????????¨?¨???????\n        map[this.pos[0]][this.pos[1]] = this.dir;\n    }\n\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\tstatic ArrayList<String> print = new ArrayList<String>();\n\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\t\tString str;\n\t\tint x;\n\t\tint y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tenum ActionType {\n\t\tU, D, L, R, S;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint dataSetsCount=Integer.parseInt(sc.nextLine());\n\t\tfor(int count=0;count<dataSetsCount;count++) {\n\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\n\t\t\tmap.Print();\n\t\t\tif(count<dataSetsCount-1)print.add(\"\\n\");\n\t\t}\n\t\tfor(String str:print) {\n\t\t\tSystem.out.print(str);\n\t\t}\n\n\t}\n\n\tstatic void ExecuteAction(ActionType action) {\n\t\tTank tank = map.tank;\n\t\tTile tile;\n\t\tswitch (action) {\n\t\tcase U:\n\t\t\ttile =map.getTile(tank.X, tank.Y - 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Up;\n\t\t\tbreak;\n\t\tcase D:\n\t\t\ttile =map.getTile(tank.X, tank.Y + 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Down;\n\t\t\tbreak;\n\t\tcase L:\n\t\t\ttile =map.getTile(tank.X-1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Left;\n\t\t\tbreak;\n\t\tcase R:\n\t\t\ttile =map.getTile(tank.X+1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Right;\n\t\t\tbreak;\n\t\tcase S:\n\t\t\tint x = tank.X ;\n\t\t\tint y = tank.Y ;\n\t\t\ttile = map.getTile(x, y);\n\t\t\twhile (tile != null &&( tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\tx += tank.State.x;\n\t\t\t\ty += tank.State.y;\n\t\t\t\ttile = map.getTile(x, y);\n\t\t\t}\n\t\t\tif (tile != null && tile.Type == TileType.Brick) {\n\t\t\t\ttile.Type = TileType.Field;\n\t\t\t\tmap.setTile(x, y, tile);\n\n\t\t\t}\n\n\t\t}\n\t\tmap.tank = tank;\n\t}\n\n\tstatic class Map {\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\n\t\tint[][] coordinate;\n\t\tint height;\n\t\tint width;\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tcoordinate = new int[height][width];\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvoid setTile(int x, int y, Tile tile) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, tile);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\n\t\t\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\t\t\tif (tt.str.equals(line[x])) {\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\t\t\t\t\tif (ts.str.equals(line[x])) {\n\t\t\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Print() {\n\t\t\t\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString str=\"\";\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\tif (tank.Y == y && tank.X == x) {\n\t\t\t\t\t\tstr+=tank.State.str;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTile t = getTile(x, y);\n\t\t\t\t\t\tstr+=t.Type.str;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr+=\"\\n\";\n\t\t\t\tprint.add(str);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Tile {\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\tstatic class Tank {\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\t\t//ArrayList<Field> list = new ArrayList<Field>();\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\tint[] aryArea = new int[2];\n\t\t//?????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\t\t\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\t\t\t//?????£??????????????§??????????????????????´?\n\t\t\t//aryArea[0] = intHeight;\n\t\t\t//aryArea[1] = intWidth;\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\t\t\t//System.out.println(\"field.length:\" + field.length);\n\t\t\t//System.out.println(\"field[0].length:\" + field[0].length);\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\t//????????\\???????????????????????????????????????????´?\n\t\t\t\t//String[] fieldLine = new String[intWidth];\n\t\t\t\tString[] fieldLine = insBR.readLine().split(\"\");\n\t\t\t\t//System.out.println(\"fieldLine.length:\" + fieldLine.length);\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\t\t\t\t\t\n\t\t\t\t\tfield[j][i] = fieldLine[i+1];\n\t\t\t\t\t//System.out.print(field[j][i]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\t\t\t//System.out.println(\"commond.length:\" + commond.length);\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\t\t\t//??????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\t\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\t\t\t\n\t\t\tField insField = aryIns[k];\n\t\t\tint intHeight = insField.field.length;\n\t\t\tint intWidth = insField.field[0].length;\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != aryIns.length-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£??????????????§???????????????????????????*/\n\t\tprivate int[] aryArea;\n\t\tint intHeight;\n\t\tint intWidth;\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond ){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.intHeight = field.length;\n\t\t\tthis.intWidth = field[0].length;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????£????????????????????¨???????????£??\\\n\t\t\t//int intHeight = aryArea[0];\n\t\t\t//int intWidth = aryArea[1];\n\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\t\t\t\t//System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\t\t\t\t//System.out.println(\"tank:\" + j + i);\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\t\t\t//?????£??????????????§??????\n\t\t\t//int intHeight = aryArea[0];\n\t\t\t//int intWidth = aryArea[1];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\t//???????????????????????°??????\n\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\t\t\t//?????£??????????????§??????????????????????´?\n\t\t\tint[] aryArea = {intHeight,intWidth};\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tString[] fieldLine = new String[intWidth];\n\t\t\t\tfieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond,aryArea);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\n\t\t\t//?????£??????????????????\n\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(deta != setNum-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£??????????????§???????????????????????????*/\n\t\tprivate int[] aryArea;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond ,int[] aryArea){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.aryArea = aryArea;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????£????????????????????¨???????????£??\\\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\t\t\t\t//System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\t\t\t\t//System.out.println(\"tank:\" + j + i);\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\t\t\t//?????£??????????????§??????\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int t, h, w;\n\tstatic char[][] field;\n\tstatic String order;\n\tstatic int[] dx = {0, 1, 0, -1}, dy = {-1, 0, 1, 0};\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tif(!sc.hasNext())return false;\n\t\tt = sc.nextInt();\n\t\tfor(int i = 0; i < t; i++){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tfield = new char[h][w];\n\t\t\tfor(int j = 0; j < field.length; j++){\n\t\t\t\tfield[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint no_use = sc.nextInt();\n\t\t\torder = sc.next();\n\t\t\tsolve();\n\t\t\tprintField();\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tint sx = 0, sy = 0;\n\t\tchar tank = '-';\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tif(field[i][j] == '^'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '>'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '<'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == 'v'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nx = sx, ny = sy;\n\t\tfor(int i = 0; i < order.length(); i++){\n\t\t\tchar c = order.charAt(i);\n\t\t\tswitch(c){\n\t\t\tcase 'U':\n\t\t\t\ttank = '^';\n\t\t\t\tnx += dx[0]; ny += dy[0];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '^';\n\t\t\t\t\tfield[ny-dy[0]][nx-dx[0]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[0]; ny -= dy[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\ttank = 'v';\n\t\t\t\tnx += dx[2]; ny += dy[2];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = 'v';\n\t\t\t\t\tfield[ny-dy[2]][nx-dx[2]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[2]; ny -= dy[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttank = '<';\n\t\t\t\tnx += dx[3]; ny += dy[3];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '<';\n\t\t\t\t\tfield[ny-dy[3]][nx-dx[3]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[3]; ny -= dy[3];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\ttank = '>';\n\t\t\t\tnx += dx[1]; ny += dy[1];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '>';\n\t\t\t\t\tfield[ny-dy[1]][nx-dx[1]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[1]; ny -= dy[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshot(nx, ny, tank);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void printField(){\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tstatic void shot(int x, int y, char t){\n\t\tint vector = 0;\n\t\tswitch(t){\n\t\tcase '^':\n\t\t\tvector = 0; break;\n\t\tcase '>':\n\t\t\tvector = 1; break;\n\t\tcase 'v':\n\t\t\tvector = 2; break;\n\t\tcase '<':\n\t\t\tvector = 3; break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tint nx = x + dx[vector], ny = y + dy[vector];\n\t\twhile(true){\n\t\t\tif(nx < 0 || nx >= field[0].length || ny < 0 || ny >= field.length)break;\n\t\t\tif(field[ny][nx] == '#')break;\n\t\t\tif(field[ny][nx] == '*'){field[ny][nx] = '.'; break;}\n\t\t\tnx += dx[vector]; ny += dy[vector];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\t// マップの高さ\n\t\t\t\theight = sc.nextInt();\n\t\t\t\t// マップの幅\n\t\t\t\twidth = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap map = new map();\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank tank = new tank();\n\t\t\tmap.setMap(height, width);\n\n\t\t\tString line = null;\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint command_number = 0;\n\t\t\tString command_attack = \"\";\n\t\t\t// コマンド入力回数\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_number = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\tcommand_at = command_attack.toCharArray();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (map obj : map_list) {\n\t\t\tobj.out_map();\n\t\t\t// 改行\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int[] di = {0,-1,0,1};\n\tstatic int[] dj = {1,0,-1,0};\n\tstatic char[] tank = {'>','^','<','v'};\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tpublic static void solve() {\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tchar[][] m = new char[h][];\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t}\n\t\tint n = sc.nextInt();\n\t\tchar[] c = sc.next().toCharArray();\n\t\tint ni = -1,nj = -1;\n\t\tint dir = -1;\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\tchar cc = m[i][j];\n\t\t\t\tif (cc == '^' || cc == 'v' || cc == '<' || cc == '>') {\n\t\t\t\t\tswitch (cc) {\n\t\t\t\t\tcase '^':\n\t\t\t\t\t\tdir = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tdir = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdir = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\tdir = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tni = i;\n\t\t\t\t\tnj = j;\n\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int t=0;t<n;t++) {\n\t\t\tswitch (c[t]) {\n\t\t\tcase 'U':\n\t\t\t\tdir = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tdir = 3;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tdir = 2;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tdir = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c[t] != 'S') {\n\t\t\t\tint xi = ni + di[dir];\n\t\t\t\tint xj = nj + dj[dir];\n\t\t\t\tif (xi < 0 || xi >= h || xj < 0 || xj >= w || m[xi][xj] != '.') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tni = xi;\n\t\t\t\tnj = xj;\n\t\t\t}else{\n\t\t\t\tint bi = ni;\n\t\t\t\tint bj = nj;\n\t\t\t\twhile(0 <= bi && bi < h && 0 <= bj && bj < w) {\n\t\t\t\t\tif (m[bi][bj] == '*') {\n\t\t\t\t\t\tm[bi][bj] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(m[bi][bj] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbi += di[dir];\n\t\t\t\t\tbj += dj[dir];\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\tm[ni][nj] = tank[dir];\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tsb.append(m[i]);\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Mass {\n\tint x;\n\tint y;\n\t/*\n\t * 1 = 平地 2 = レンガの壁 3 = 鉄の壁 4 = 水 5 = 戦車\n\t */\n\tint state;\n\n\tpublic Mass(int x, int y, char state) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tif (state == '.')\n\t\t\tthis.state = 1;\n\t\telse if (state == '*')\n\t\t\tthis.state = 2;\n\t\telse if (state == '#')\n\t\t\tthis.state = 3;\n\t\telse if (state == '-')\n\t\t\tthis.state = 4;\n\t\telse\n\t\t\tthis.state = 1;\n\t}\n\n\tpublic Mass(int x, int y, int state) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.state = state;\n\t}\n\n\tpublic boolean shoot() {\n\t\tif (this.state == 2)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic char printMass() {\n\t\tif (state == 1)\n\t\t\treturn '.';\n\t\tif (state == 2)\n\t\t\treturn '*';\n\t\tif (state == 3)\n\t\t\treturn '#';\n\t\tif (state == 4)\n\t\t\treturn '-';\n\t\telse\n\t\t\treturn 'x';\n\t}\n}\n\nclass Area {\n\tMass[][] mass;\n\tSensya sensya;\n\tint x_max;\n\tint y_max;\n\n\tpublic Area(int x_max, int y_max) {\n\n\t\tMass[][] m = new Mass[x_max][y_max];\n\t\tthis.mass = m;\n\t\tthis.x_max = x_max;\n\t\tthis.y_max = y_max;\n\t}\n\n\tpublic void printArea() {\n\t\tchar print[][] = new char[this.x_max][this.y_max];\n\t\tfor (int i = 0; i < x_max; i++) {\n\t\t\tfor (int j = 0; j < y_max; j++) {\n\t\t\t\tprint[i][j] = this.mass[i][j].printMass();\n\t\t\t}\n\t\t}\n\n\t\tprint[this.sensya.mass.x][this.sensya.mass.y] = sensya.printSensya();\n\t\tfor (int i = 0; i < this.x_max; i++) {\n\t\t\tfor (int j = 0; j < this.y_max; j++) {\n\t\t\t\tSystem.out.print(print[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t}\n\n\tpublic void doMessage(int mesNum, String mes) {\n\t\tfor (int i = 0; i < mesNum; i++) {\n\t\t\tchar a = mes.charAt(i);\n\t\t\tswitch (a) {\n\t\t\tcase 'U':\n\t\t\t\tif (this.sensya.mass.x == 0)\n\t\t\t\t\tthis.sensya.move(a, null);\n\t\t\t\telse\n\t\t\t\t\tthis.sensya\n\t\t\t\t\t\t\t.move(a,\n\t\t\t\t\t\t\t\t\tthis.mass[this.sensya.mass.x - 1][this.sensya.mass.y]);\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tif (this.sensya.mass.x == x_max - 1)\n\t\t\t\t\tthis.sensya.move(a, null);\n\t\t\t\telse\n\t\t\t\t\tthis.sensya\n\t\t\t\t\t\t\t.move(a,\n\t\t\t\t\t\t\t\t\tthis.mass[this.sensya.mass.x + 1][this.sensya.mass.y]);\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tif (this.sensya.mass.y == 0)\n\t\t\t\t\tthis.sensya.move(a, null);\n\t\t\t\telse\n\t\t\t\t\tthis.sensya\n\t\t\t\t\t\t\t.move(a,\n\t\t\t\t\t\t\t\t\tthis.mass[this.sensya.mass.x][this.sensya.mass.y - 1]);\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tif (this.sensya.mass.y == y_max - 1)\n\t\t\t\t\tthis.sensya.move(a, null);\n\t\t\t\telse\n\t\t\t\t\tthis.sensya\n\t\t\t\t\t\t\t.move(a,\n\t\t\t\t\t\t\t\t\tthis.mass[this.sensya.mass.x][this.sensya.mass.y + 1]);\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tif (this.sensya.direction == 1) {\n\t\t\t\t\tint f = 0;\n\t\t\t\t\tfor (int i1 = sensya.mass.x; i1 >= 0; i1--) {\n\t\t\t\t\t\tf = this.mass[i1][sensya.mass.y].state;\n\t\t\t\t\t\tif (f == 2) {\n\t\t\t\t\t\t\tthis.mass[i1][sensya.mass.y].state = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (f == 3) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (this.sensya.direction == 3) {\n\t\t\t\t\tint f = 0;\n\t\t\t\t\tfor (int i1 = sensya.mass.x; i1 < x_max; i1++) {\n\t\t\t\t\t\tf = this.mass[i1][sensya.mass.y].state;\n\t\t\t\t\t\tif (f == 2) {\n\t\t\t\t\t\t\tthis.mass[i1][sensya.mass.y].state = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (f == 3) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (this.sensya.direction == 4) {\n\t\t\t\t\tint f = 0;\n\t\t\t\t\tfor (int i1 = sensya.mass.y; i1 >= 0; i1--) {\n\t\t\t\t\t\tf = this.mass[sensya.mass.x][i1].state;\n\t\t\t\t\t\tif (f == 2) {\n\t\t\t\t\t\t\tthis.mass[sensya.mass.x][i1].state = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (f == 3) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (this.sensya.direction == 2) {\n\t\t\t\t\tint f = 0;\n\t\t\t\t\tfor (int i1 = sensya.mass.y; i1 < y_max; i1++) {\n\t\t\t\t\t\tf = this.mass[sensya.mass.x][i1].state;\n\t\t\t\t\t\tif (f == 2) {\n\t\t\t\t\t\t\tthis.mass[sensya.mass.x][i1].state = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (f == 3) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Mass search_mass(int x, int y) {\n\t\treturn this.mass[x][y];\n\t}\n\n}\n\nclass Sensya {\n\tMass mass;\n\t/*\n\t * 1 = 上 2 = 右 3 = 下 4 = 左\n\t */\n\tint direction;\n\n\tpublic Sensya(int x, int y, char direction) {\n\t\tthis.mass = new Mass(x, y, direction);\n\t\tif (direction == '^')\n\t\t\tthis.direction = 1;\n\t\telse if (direction == 'v')\n\t\t\tthis.direction = 3;\n\t\telse if (direction == '<')\n\t\t\tthis.direction = 4;\n\t\telse if (direction == '>')\n\t\t\tthis.direction = 2;\n\t}\n\n\tpublic void direction_change(char s) {\n\t\tif (s == 'U') {\n\t\t\tdirection = 1;\n\t\t}\n\t\tif (s == 'D') {\n\t\t\tdirection = 3;\n\t\t}\n\t\tif (s == 'L') {\n\t\t\tdirection = 4;\n\t\t}\n\t\tif (s == 'R') {\n\t\t\tdirection = 2;\n\t\t}\n\t}\n\n\tpublic char printSensya() {\n\t\tif (direction == 1)\n\t\t\treturn '^';\n\t\tif (direction == 2)\n\t\t\treturn '>';\n\t\tif (direction == 3)\n\t\t\treturn 'v';\n\t\tif (direction == 4)\n\t\t\treturn '<';\n\t\telse\n\t\t\treturn 'y';\n\t}\n\n\tpublic void move(char s, Mass mass) {\n\t\tswitch (s) {\n\t\tcase 'U':\n\t\t\tif (mass == null)\n\t\t\t\tdirection_change(s);\n\t\t\telse {\n\t\t\t\tdirection_change(s);\n\t\t\t\tif (mass.state == 1)\n\t\t\t\t\tthis.mass.x -= 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (mass == null)\n\t\t\t\tdirection_change(s);\n\t\t\telse {\n\t\t\t\tdirection_change(s);\n\t\t\t\tif (mass.state == 1)\n\t\t\t\t\tthis.mass.x += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (mass == null)\n\t\t\t\tdirection_change(s);\n\t\t\telse {\n\t\t\t\tdirection_change(s);\n\t\t\t\tif (mass.state == 1)\n\t\t\t\t\tthis.mass.y -= 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif (mass == null)\n\t\t\t\tdirection_change(s);\n\t\t\telse {\n\t\t\t\tdirection_change(s);\n\t\t\t\tif (mass.state == 1)\n\t\t\t\t\tthis.mass.y += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tfor (int z = 0; z < N; z++) {\n\t\t\tint x_max = sc.nextInt();\n\t\t\tint y_max = sc.nextInt();\n\t\t\tArea area = new Area(x_max, y_max);\n\t\t\tfor (int i = 0; i < x_max; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < y_max; j++) {\n\t\t\t\t\tchar mes = s.charAt(j);\n\t\t\t\t\tif (mes == '^' || mes == 'v' || mes == '<' || mes == '>')\n\t\t\t\t\t\tarea.sensya = new Sensya(i, j, mes);\n\t\t\t\t\tarea.mass[i][j] = new Mass(i, j, mes);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint mes_num = sc.nextInt();\n\t\t\tString mes = sc.next();\n\t\t\tarea.doMessage(mes_num, mes);\n\t\t\tarea.printArea();\n\t\t\tif (z != N - 1)\n\t\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        ArrayList<char[][]> listBattleArea = new ArrayList<char[][]>();\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        \n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            \n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            listBattleArea.add(aryBattleArea);\n            \n        }\n        \n        for( int i = 0 ; i < listBattleArea.size() ; i++ ){\n        \t\n        \tchar[][] output = listBattleArea.get(i);\n        \t\n        \tfor( int j = 0 ; j < output.length ; j++ ){\n        \t\tfor( int k = 0 ; k < output[j].length ; k++ ){\n        \t\t\t\n        \t\t\tSystem.out.print(output[j][k]);\n        \t\t\t\n        \t\t}\n        \t\tSystem.out.println();\n        \t}\n        \tif( i != listBattleArea.size()-1)\n        \tSystem.out.println();\n        }\n        \n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    //private ArrayList<char[][]> list = new ArrayList<char[][]>();\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                              //  continue;\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    public void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n        //??????????°?  \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[i][x] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea[i].length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[i][x] == '#' ){\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map3> map_list = new ArrayList<map3>();\n\n\t\ttry{\n\t\t\t//\n\t\tScanner sc = new Scanner(System.in);\n\t\t// 入力の回数\n\t\tint input_length = sc.nextInt();\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap3 map = new map3();\n\t\t\tmap.setMap(height, width);\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank3 tank = new tank3();\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// コマンド入力回数\n\t\t\tint command_number = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\tString command_attack = sc.next();\n\t\t\t// ひとつずつ配列に入れる\n\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\tmap_list.get(f).out_map();\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\t\t}catch(NoSuchElementException e){\n\t\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\t\tmap_list.get(f).out_map();\n\t\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t\t// 改行\n\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t}\n\t}\n}\n\nclass tank3{\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\nclass map3{\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\t\t\n\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t//???????????????\n\t\tint[] addr = { -1, 1 };\n\t\twhile (true) {\n\t\t\tif (tank.getDir() == '^') {\n\t\t\t\tpos[0] += addr[0];\n\t\t\t\tif (pos[0] == -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == 'v') {\n\t\t\t\tpos[0] += addr[1];\n\t\t\t\tif (pos[0] >= game_Map[0].length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '<') {\n\t\t\t\tpos[1] += addr[0];\n\t\t\t\tif (pos[1] == -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '>') {\n\t\t\t\tpos[1] += addr[1];\n\t\t\t\tif (pos[1] >= game_Map[0].length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (game_Map[pos[0]][pos[1]]) {\n\t\t\tcase '.':\n\t\t\tcase '-':\n\t\t\t\tcontinue;\n\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\tcase '*':\n\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t\tcase '#':\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\n\t}// canon_Shot????????????????????????\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\tint[] addr = { -1, 1 };\n\n\t\tif (tank.getDir() == '^') {\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == 'v') {\n\t\t\tif (move[0] + 1 < game_Map[0].length) {\n\t\t\t\tmove[0] += addr[1];\n\t\t\t}\n\t\t} else if (tank.getDir() == '<') {\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == '>') {\n\t\t\tif (move[1] + 1 < game_Map[1].length) {\n\t\t\t\tmove[1] += addr[1];\n\t\t\t}\n\t\t}\n\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\ttank.setPos(move);\n\t\t}\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ??????????????????????????±?????¶???????????????\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ????????????????????¨?????????????????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('U', '^');\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// ('D', 'v');\n\t\t\t// ('v', { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('L', '<');\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('R', '>');\n\t\t\t// ('>',{ 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\t// ??????????????????????????????\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('v',{ 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('>', { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "package qLast;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\tint[] aryArea = new int[2];\n\n\t\t//?????£?????????????????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tString[] fieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\n\t\t\t//?????????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\n\t\t\tField insField = aryIns[k];\n\t\t\t//????????????????????????????????????????????¨????????????\n\t\t\tint intHeight = insField.field.length;\n\t\t\tint intWidth = insField.field[0].length;\n\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != setNum-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£????????????????????¨???????????????????????°*/\n\t\tprivate int intHeight;\n\t\tprivate int intWidth;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.intHeight = field.length;\n\t\t\tthis.intWidth = field[0].length;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package battletown;\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class battleTown3 {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\n\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\n\t\t// ??????????????????????????????\n\t\tswitch (tank.getDir()) {\n\t\t// ('^', { -1, 0 });\n\t\tcase '^':\n\t\t\tfor (int cnt = pos[0]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[cnt][pos[1]] == '*') {\n\t\t\t\t\tgame_Map[cnt][pos[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[cnt][pos[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('v',{ 1, 0 });\n\t\tcase 'v':\n\t\t\tfor (int cnt = 1; cnt < game_Map[0].length - pos[0]; cnt++) {\n\t\t\t\tif (game_Map[pos[0] + cnt][pos[1]] == '*') {\n\t\t\t\t\tgame_Map[pos[0] + cnt][pos[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0] + cnt][pos[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('<', { 0, -1 });\n\t\tcase '<':\n\t\t\tfor (int cnt = pos[1]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[pos[0]][cnt] == '*') {\n\t\t\t\t\tgame_Map[pos[0]][cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0]][cnt] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('>', { 0, 1 });\n\t\tcase '>':\n\t\t\tfor (int cnt = 1; cnt < game_Map[1].length - pos[1]; cnt++) {\n\t\t\t\tif (game_Map[pos[0]][pos[1] + cnt] == '*') {\n\t\t\t\t\tgame_Map[pos[0]][pos[1] + cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0]][pos[1] + cnt] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}// canon_Shot????????????????????????\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\n\t\tif(tank.getDir() == '^'){\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0]--;\n\t\t\t}\n\t\t}else if (tank.getDir() == 'v'){\n\t\t\tif (move[0] + 1 < game_Map[0].length) {\n\t\t\t\tmove[0]++;\n\t\t\t}\n\t\t}else if (tank.getDir() == '<'){\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1]--;\n\t\t\t}\n\t\t}else if (tank.getDir() == '>'){\n\t\t\tif (move[1] + 1 < game_Map[1].length) {\n\t\t\t\tmove[1]++;\n\t\t\t}\n\t\t}\n\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\ttank.setPos(move);\n\t\t}\n\n\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tint input_length = 0;\n\t\t\t// マップの高さ\n\t\t\tint height = 0;\n\t\t\t// マップの幅\n\t\t\tint width = 0;\n\t\t\t// 各完成マップを入れる配列\n\t\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t\t// 入力の回数\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tinput_length = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 入力回数分ゲームをする\n\t\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\t// マップの高さ\n\t\t\t\t\theight = sc.nextInt();\n\t\t\t\t\t// マップの幅\n\t\t\t\t\twidth = sc.nextInt();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// マップのインスタンスを作る\n\t\t\t\tmap map = new map();\n\t\t\t\t// 戦車のインスタンスを作る\n\t\t\t\ttank tank = new tank();\n\t\t\t\tmap.setMap(height, width);\n\n\t\t\t\tString line = null;\n\t\t\t\t// マップ作成\n\t\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t\t// マップ一列\n\t\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\t\tline = sc.next();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 一文字ずつに分解\n\t\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t\t//\n\t\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t\t// マップを作る\n\t\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint command_number = 0;\n\t\t\t\tString command_attack = \"\";\n\t\t\t\t// コマンド入力回数\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tcommand_number = sc.nextInt();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// コマンドの文字列\n\t\t\t\tchar[] command_at = null;\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\t\tcommand_at = command_attack.toCharArray();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// コマンド回数分まわす\n\t\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t\t// タンクの現在位置を把握\n\t\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t\t// 砲弾発射だったら\n\t\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 移動の場合\n\t\t\t\t\t\tmap.move_tank(tank.getNow_height(),\n\t\t\t\t\t\t\t\ttank.getNow_width(),\n\t\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// リストにできたマップを格納\n\t\t\t\tmap_list.add(map);\n\t\t\t}\n\t\t\t// 結果を出力\n\t\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\t\tmap_list.get(f).out_map();\n\t\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t\t// 改行\n\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.getStackTrace();\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\n\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\n\t\t// ??????????????????????????????\n\t\tswitch (tank.getDir()) {\n\t\t// ('^', { -1, 0 });\n\t\tcase '^':\n\t\t\tfor (int cnt = pos[0]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[cnt][pos[1]] == '*') {\n\t\t\t\t\tgame_Map[cnt][pos[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[cnt][pos[1]]== '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('v',{ 1, 0 });\n\t\tcase 'v':\n\t\t\tfor (int cnt = 1; cnt < game_Map[0].length - pos[0]; cnt++) {\n\t\t\t\tif (game_Map[pos[0] + cnt][pos[1]] == '*') {\n\t\t\t\t\tgame_Map[pos[0] + cnt][pos[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0] + cnt][pos[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('<', { 0, -1 });\n\t\tcase '<':\n\t\t\tfor (int cnt = pos[1]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[pos[0]][cnt]== '*') {\n\t\t\t\t\tgame_Map[pos[0]][cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0]][cnt]== '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('>', { 0, 1 });\n\t\tcase '>':\n\t\t\tfor (int cnt = 1; cnt < game_Map[1].length - pos[1]; cnt++) {\n\t\t\t\tif (game_Map[pos[0]][pos[1] + cnt] == '*') {\n\t\t\t\t\tgame_Map[pos[0]][pos[1] + cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[pos[0]][pos[1] + cnt]== '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}// canon_Shot????????????????????????\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\n\t\tswitch (tank.getDir()) {\n\t\tcase '^':\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0]--;\n\t\t\t\tif (game_Map[move[0]][move[1]]== '.') {\n\t\t\t\t\ttank.setPos(move);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tif (move[0] + 1 < game_Map[0].length) {\n\t\t\t\tmove[0] ++;\n\t\t\t\tif (game_Map[move[0]][move[1]]== '.') {\n\t\t\t\t\ttank.setPos(move);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1]--;\n\t\t\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\t\t\ttank.setPos(move);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tif (move[1] + 1 < game_Map[1].length) {\n\t\t\t\tmove[1] ++;\n\t\t\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\t\t\ttank.setPos(move);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tif(i != 0){\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tfinal int H = sc.nextInt();\n\t\t\tfinal int W = sc.nextInt();\n\t\t\t\n\t\t\tchar[][] map = new char[H+2][W+2];\n\t\t\t\n\t\t\tint p_x = 0, p_y = 0;\n\t\t\t\n\t\t\tfor(int j = 0; j < (H + 2); j++){\n\t\t\t\tchar[] str = null;\n\t\t\t\tif(!(j == 0 || j == H + 1)){\n\t\t\t\t\tstr = sc.next().toCharArray();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < (W + 2); k++){\n\t\t\t\t\tif(j == 0 || j == H + 1 || k == 0 || k == W + 1){\n\t\t\t\t\t\tmap[j][k] = '#';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[j][k] = str[k-1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(map[j][k] == '<' || map[j][k] == '>' || map[j][k] == '^' || map[j][k] == 'v'){\n\t\t\t\t\t\t\tp_x = k;\n\t\t\t\t\t\t\tp_y = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc.next();\n\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\tfor(char c : input){\n\t\t\t\tif(c == 'U'){\n\t\t\t\t\tmap[p_y][p_x] = '^';\n\t\t\t\t\tif(map[p_y-1][p_x] == '.'){\n\t\t\t\t\t\tmap[p_y-1][p_x] = '^';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_y--;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'D'){\n\t\t\t\t\tmap[p_y][p_x] = 'v';\n\t\t\t\t\tif(map[p_y+1][p_x] == '.'){\n\t\t\t\t\t\tmap[p_y+1][p_x] = 'v';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_y++;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'L'){\n\t\t\t\t\tmap[p_y][p_x] = '<';\n\t\t\t\t\tif(map[p_y][p_x-1] == '.'){\n\t\t\t\t\t\tmap[p_y][p_x-1] = '<';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_x--;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'R'){\n\t\t\t\t\tmap[p_y][p_x] = '>';\n\t\t\t\t\tif(map[p_y][p_x+1] == '.'){\n\t\t\t\t\t\tmap[p_y][p_x+1] = '>';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_x++;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'S'){\n\t\t\t\t\tint s_x = 0, s_y = 0;\n\t\t\t\t\t\n\t\t\t\t\tif(map[p_y][p_x] == '^'){\n\t\t\t\t\t\ts_y = -1;\n\t\t\t\t\t}else if(map[p_y][p_x] == 'v'){\n\t\t\t\t\t\ts_y = 1;\n\t\t\t\t\t}else if(map[p_y][p_x] == '<'){\n\t\t\t\t\t\ts_x = -1;\n\t\t\t\t\t}else if(map[p_y][p_x] == '>'){\n\t\t\t\t\t\ts_x = 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint xx = p_x + s_x;\n\t\t\t\t\tint yy = p_y + s_y;\n\t\t\t\t\t\n\t\t\t\t\twhile(!(map[yy][xx] == '*' || map[yy][xx] == '#')){\n\t\t\t\t\t\tyy += s_y;\n\t\t\t\t\t\txx += s_x;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(map[yy][xx] == '*'){\n\t\t\t\t\t\tmap[yy][xx] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 1; j < H + 1; j++){\n\t\t\t\tfor(int k = 1; k < W + 1; k++){\n\t\t\t\t\tSystem.out.print(map[j][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(j != H){\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\tstatic ArrayList<String> print = new ArrayList<String>();\n\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\t\tString str;\n\t\tint x;\n\t\tint y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tenum ActionType {\n\t\tU, D, L, R, S;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint dataSetsCount=Integer.parseInt(sc.nextLine());\n\t\tfor(int count=0;count<dataSetsCount;count++) {\n\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\n\t\t\tmap.Print();\n\t\t\tprint.add(\"\\n\");\n\t\t}\n\t\tfor(String str:print) {\n\t\t\tSystem.out.print(str);\n\t\t}\n\n\t}\n\n\tstatic void ExecuteAction(ActionType action) {\n\t\tTank tank = map.tank;\n\t\tTile tile;\n\t\tswitch (action) {\n\t\tcase U:\n\t\t\ttile =map.getTile(tank.X, tank.Y - 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Up;\n\t\t\tbreak;\n\t\tcase D:\n\t\t\ttile =map.getTile(tank.X, tank.Y + 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Down;\n\t\t\tbreak;\n\t\tcase L:\n\t\t\ttile =map.getTile(tank.X-1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Left;\n\t\t\tbreak;\n\t\tcase R:\n\t\t\ttile =map.getTile(tank.X+1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Right;\n\t\t\tbreak;\n\t\tcase S:\n\t\t\tint x = tank.X ;\n\t\t\tint y = tank.Y ;\n\t\t\ttile = map.getTile(x, y);\n\t\t\twhile (tile != null &&( tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\tx += tank.State.x;\n\t\t\t\ty += tank.State.y;\n\t\t\t\ttile = map.getTile(x, y);\n\t\t\t}\n\t\t\tif (tile != null && tile.Type == TileType.Brick) {\n\t\t\t\ttile.Type = TileType.Field;\n\t\t\t\tmap.setTile(x, y, tile);\n\n\t\t\t}\n\n\t\t}\n\t\tmap.tank = tank;\n\t}\n\n\tstatic class Map {\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\n\t\tint[][] coordinate;\n\t\tint height;\n\t\tint width;\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tcoordinate = new int[height][width];\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvoid setTile(int x, int y, Tile tile) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, tile);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\n\t\t\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\t\t\tif (tt.str.equals(line[x])) {\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\t\t\t\t\tif (ts.str.equals(line[x])) {\n\t\t\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Print() {\n\t\t\t\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString str=\"\";\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\tif (tank.Y == y && tank.X == x) {\n\t\t\t\t\t\tstr+=tank.State.str;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTile t = getTile(x, y);\n\t\t\t\t\t\tstr+=t.Type.str;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr+=\"\\n\";\n\t\t\t\tprint.add(str);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Tile {\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\tstatic class Tank {\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\t\tString str;\n\t\tint x;\n\t\tint y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tenum ActionType {\n\t\tU, D, L, R, S;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint dataSetsCount=Integer.parseInt(sc.nextLine());\n\t\tfor(int count=0;count<dataSetsCount;count++) {\n\t\t\t\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\t\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\t\n\t\t\tmap.Print();\n\t\t}\n\n\t}\n\n\tstatic void ExecuteAction(ActionType action) {\n\t\tTank tank = map.tank;\n\t\tTile tile;\n\t\tswitch (action) {\n\t\tcase U:\n\t\t\ttile =map.getTile(tank.X, tank.Y - 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Up;\n\t\t\tbreak;\n\t\tcase D:\n\t\t\ttile =map.getTile(tank.X, tank.Y + 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Down;\n\t\t\tbreak;\n\t\tcase L:\n\t\t\ttile =map.getTile(tank.X-1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Left;\n\t\t\tbreak;\n\t\tcase R:\n\t\t\ttile =map.getTile(tank.X+1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Right;\n\t\t\tbreak;\n\t\tcase S:\n\t\t\tint x = tank.X ;\n\t\t\tint y = tank.Y ;\n\t\t\ttile = map.getTile(x, y);\n\t\t\twhile (tile != null &&( tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\tx += tank.State.x;\n\t\t\t\ty += tank.State.y;\n\t\t\t\ttile = map.getTile(x, y);\n\t\t\t}\n\t\t\tif (tile != null && tile.Type == TileType.Brick) {\n\t\t\t\ttile.Type = TileType.Field;\n\t\t\t\tmap.setTile(x, y, tile);\n\n\t\t\t}\n\n\t\t}\n\t\tmap.tank = tank;\n\t}\n\n\tstatic class Map {\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\n\t\tint[][] coordinate;\n\t\tint height;\n\t\tint width;\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tcoordinate = new int[height][width];\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvoid setTile(int x, int y, Tile tile) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, tile);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\n\t\t\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\t\t\tif (tt.str.equals(line[x])) {\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\t\t\t\t\tif (ts.str.equals(line[x])) {\n\t\t\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Print() {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\tif (tank.Y == y && tank.X == x) {\n\t\t\t\t\t\tSystem.out.print(tank.State.str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTile t = getTile(x, y);\n\t\t\t\t\t\tSystem.out.print(t.Type.str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Tile {\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\tstatic class Tank {\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n//データセット入力\n//マップの縦と横の値を入力\n//マップの地形を入力\n//操作回数を入力\n//操作を入力\n//すべてのマップと操作を入力後、全てのマップを改行おきに出力\npublic class Main{\n public static void main(String[] args) {\n\n  //インスタンス生成\n  Scanner sc=new Scanner(System.in);\n  BT_Map btm=new BT_Map();\n\n  //変数、配列宣言\n  ArrayList<ArrayList<ArrayList<String>>> maps=new ArrayList<ArrayList<ArrayList<String>>>();\n  int data_set=sc.nextInt();\n  int[] H_num_memory=new int[data_set];\n  int[] W_num_memory=new int[data_set];\n\n  for(int i=0;i<data_set;i++) {\n   //map 縦と横入力\n   int map_H=sc.nextInt();\n   H_num_memory[i]=map_H;\n   int map_W=sc.nextInt();\n   W_num_memory[i]=map_W;\n   String[][] map=new String[map_H][map_W];\n   //map作成\n   for(int j1=0;j1<map_H;j1++) {\n    String W_words=sc.next();\n    for(int j2=0;j2<map_W;j2++) {\n     map[j1][j2]=W_words.substring(j2,j2+1);\n    }\n   }\n\n   //debug\n   /*for(int debug_i=0;debug_i<map_H;debug_i++){\n\t   for(int debug_j=0;debug_j<map_W;debug_j++){\n\t\t   System.out.print(map[debug_i][debug_j]);\n\t   }\n\t   System.out.println();\n   }\n   System.out.println();*/\n\n   //操作回数を入力\n   int com_nums=sc.nextInt();\n   //操作入力\n   String commands=sc.next();\n   for(int j=0;j<com_nums;j++) {\n    //commandsから1文字抜き出す\n    String com=commands.substring(j,j+1);\n    //打ち込まれた文字によって操作を行い、マップを変化させる\n    //変化後のmapを返すメソッド\n    if(com.equals(\"U\")) {\n     map=BT_Map.com_U(map,map_H,map_W);\n    }else if(com.equals(\"D\")) {\n     map=BT_Map.com_D(map,map_H,map_W);\n    }else if(com.equals(\"L\")) {\n     map=BT_Map.com_L(map,map_H,map_W);\n    }else if(com.equals(\"R\")) {\n     map=BT_Map.com_R(map,map_H,map_W);\n    }else if(com.equals(\"S\")) {\n     map=BT_Map.com_S(map,map_H,map_W);\n    }\n   }\n\n   //debug\n   /*for(int debug_i=0;debug_i<map_H;debug_i++){\n\t   for(int debug_j=0;debug_j<map_W;debug_j++){\n\t\t   System.out.print(map[debug_i][debug_j]);\n\t   }\n\t   System.out.println();\n   }\n   System.out.println();*/\n\n   //mapをArrayList化し、mapsに加える\n   ArrayList<ArrayList<String>> Hight=new ArrayList<ArrayList<String>>();\n   for(int j=0;j<map_H;j++) {\n    ArrayList<String> Wide=new ArrayList<String>();\n    for(int k=0;k<map_W;k++) {\n     Wide.add(map[j][k]);\n    }\n    Hight.add(Wide);\n   }\n   maps.add(Hight);\n  }\n  //mapsを出力\n  //System.out.println(maps.get(0).get(0).get(0));\n  for(int i=0;i<data_set;i++){\n\t  for(int j=0;j<H_num_memory[i];j++){\n\t\t  for(int k=0;k<W_num_memory[i];k++){\n\t\t\t  System.out.print(maps.get(i).get(j).get(k));\n\t\t  }\n\t\t  System.out.println();\n\t  }\n\t  if(i==maps.size()-1){\n\t  }else{\n\t\t  System.out.println();\n\t  }\n  }\n }\n\n}\nclass BT_Map{\n //上に移動するメソッド\n public static String[][] com_U(String map[][],int H,int W){\n  //自機を探す\n  for(int i=0;i<H;i++) {\n   for(int j=0;j<W;j++) {\n    //自機を見つけたら\n    if(map[i][j].equals(\"^\") || map[i][j].equals(\"v\") || map[i][j].equals(\"<\") || map[i][j].equals(\">\")) {\n     map[i][j]=\"^\";\n     if(i==0) {\n     }else if(map[i-1][j].equals(\".\")) {\n      map[i-1][j]=\"^\";\n      map[i][j]=\".\";\n      break;\n     }\n    }\n   }\n  }\n  return map;\n }\n //下に移動するメソッド\n public static String[][] com_D(String map[][],int H,int W){\n  //自機を探す\n  for(int i=0;i<H;i++) {\n   for(int j=0;j<W;j++) {\n    //自機を見つけたら\n    if(map[i][j].equals(\"^\") || map[i][j].equals(\"v\") || map[i][j].equals(\"<\") || map[i][j].equals(\">\")) {\n     map[i][j]=\"v\";\n     if(i==H-1) {\n     }else if(map[i+1][j].equals(\".\")) {\n      map[i+1][j]=\"v\";\n      map[i][j]=\".\";\n      i=H;\n      break;\n     }\n    }\n   }\n  }\n  return map;\n }\n //左に移動するメソッド\n public static String[][] com_L(String map[][],int H,int W){\n  //自機を探す\n  for(int i=0;i<H;i++) {\n   for(int j=0;j<W;j++) {\n    //自機を見つけたら\n    if(map[i][j].equals(\"^\") || map[i][j].equals(\"v\") || map[i][j].equals(\"<\") || map[i][j].equals(\">\")) {\n     map[i][j]=\"<\";\n     if(j==0) {\n     }else if(map[i][j-1].equals(\".\")) {\n      map[i][j-1]=\"<\";\n      map[i][j]=\".\";\n      break;\n     }\n    }\n   }\n  }\n  return map;\n }\n //右に移動するメソッド\n public static String[][] com_R(String map[][],int H,int W){\n  //自機を探す\n  for(int i=0;i<H;i++) {\n   for(int j=0;j<W;j++) {\n    //自機を見つけたら\n    if(map[i][j].equals(\"^\") || map[i][j].equals(\"v\") || map[i][j].equals(\"<\") || map[i][j].equals(\">\")) {\n     map[i][j]=\">\";\n     if(j==W-1) {\n     }else if(map[i][j+1].equals(\".\")) {\n      map[i][j+1]=\">\";\n      map[i][j]=\".\";\n      i=H;\n      break;\n     }\n    }\n   }\n  }\n  return map;\n }\n //撃つメソッド\n public static String[][] com_S(String map[][],int H,int W){\n  //自機を探す\n  for(int i=0;i<H;i++) {\n   for(int j=0;j<W;j++) {\n    //自機を見つけたら自機の向きによって撃つ方向を変える\n    if(map[i][j].equals(\"^\")) {\n     for(int s=0;i-s>=0;s++) {\n      if(map[i-s][j].equals(\"*\")) {\n       map[i-s][j]=\".\";\n       break;\n      }else if(map[i-s][j].equals(\"#\")) {\n       break;\n      }\n     }\n    }else if(map[i][j].equals(\"v\")) {\n     for(int s=0;i+s<H;s++) {\n      if(map[i+s][j].equals(\"*\")) {\n       map[i+s][j]=\".\";\n       break;\n      }else if(map[i+s][j].equals(\"#\")) {\n       break;\n      }\n     }\n    }else if(map[i][j].equals(\"<\")) {\n     for(int s=0;j-s>=0;s++) {\n      if(map[i][j-s].equals(\"*\")) {\n       map[i][j-s]=\".\";\n       break;\n      }else if(map[i][j-s].equals(\"#\")) {\n       break;\n      }\n     }\n    }else if(map[i][j].equals(\">\")) {\n     for(int s=0;j+s<W;s++) {\n      if(map[i][j+s].equals(\"*\")) {\n       map[i][j+s]=\".\";\n       break;\n      }else if(map[i][j+s].equals(\"#\")) {\n       break;\n      }\n     }\n    }\n   }\n  }\n  return map;\n }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint t = sc.nextInt();\n\t\tfor(int k=0;k<t;k++){\n\t\t\tif(k!=0) System.out.println();\n\t\t\t\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++) map[i] = sc.next().toCharArray();\n\t\t\tint n = sc.nextInt();\n\t\t\tchar[] s = new char[n];\n\t\t\ts = sc.next().toCharArray();\n\t\t\t\n\t\t\t\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tint d = 0;\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[i][j]=='^'){\n\t\t\t\t\t\td = 0;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else if(map[i][j]=='>'){\n\t\t\t\t\t\td = 1;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else if(map[i][j]=='v'){\n\t\t\t\t\t\td = 2;\t\t\t\t\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}else if(map[i][j]=='<'){\n\t\t\t\t\t\td = 3;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==true){\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ti = h;\n\t\t\t\t\t\tj = w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s[i]=='U'){\n\t\t\t\t\td = 0;\n\t\t\t\t\tif(y>0 && map[y-1][x]=='.') y--;\n\t\t\t\t}else if(s[i]=='R'){\n\t\t\t\t\td = 1;\n\t\t\t\t\tif(x<w-1 && map[y][x+1]=='.') x++;\n\t\t\t\t}else if(s[i]=='D'){\n\t\t\t\t\td = 2;\n\t\t\t\t\tif(y<h-1 && map[y+1][x]=='.') y++;\n\t\t\t\t}else if(s[i]=='L'){\n\t\t\t\t\td = 3;\n\t\t\t\t\tif(x>0 && map[y][x-1]=='.') x--;\n\t\t\t\t}else{\n\t\t\t\t\tif(d==0){\n\t\t\t\t\t\tfor(int j=y;j>=0;j--){\n\t\t\t\t\t\t\tif(map[j][x]=='#') break;\n\t\t\t\t\t\t\tif(map[j][x]=='*'){\n\t\t\t\t\t\t\t\tmap[j][x]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(d==1){\n\t\t\t\t\t\tfor(int j=x;j<w;j++){\n\t\t\t\t\t\t\tif(map[y][j]=='#') break;\n\t\t\t\t\t\t\tif(map[y][j]=='*'){\n\t\t\t\t\t\t\t\tmap[y][j]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(d==2){\n\t\t\t\t\t\tfor(int j=y;j<h;j++){\n\t\t\t\t\t\t\tif(map[j][x]=='#') break;\n\t\t\t\t\t\t\tif(map[j][x]=='*'){\n\t\t\t\t\t\t\t\tmap[j][x]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(d==3){\n\t\t\t\t\t\tfor(int j=x;j>=0;j--){\n\t\t\t\t\t\t\tif(map[y][j]=='#') break;\n\t\t\t\t\t\t\tif(map[y][j]=='*'){\n\t\t\t\t\t\t\t\tmap[y][j]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==0) map[y][x] = '^';\n\t\t\telse if(d==1) map[y][x] = '>';\n\t\t\telse if(d==2) map[y][x] = 'v';\n\t\t\telse if(d==3) map[y][x] = '<';\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<Map> map_list = new ArrayList<Map>();\n\t\t// 入力クラス\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// 入力の回数\n\t\tint input_length = 0;\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tMap map = new Map();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// 戦車のインスタンスを作る\n\t\t\tTank tank = new Tank();\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// コマンド入力回数\n\t\t\tint command_number = sc.nextInt();\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\tString command_attack = sc.next();\n\n\t\t\t// ひとつずつ配列に入れる\n\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// 戦車の現在位置を調べる\n\t\t\t\ttank.now_position(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap = tank.shuttGun(map);\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\ttank.move_tank(String.valueOf(command_at[c]), map);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// できたマップリストにを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\tmap_list.get(f).out_map();\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n// 戦車について扱ったクラス\nclass Tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す\n\tpublic void now_position(String[][] map_all) {\n\t\t// マップ全体を探す\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 自分(戦車)がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 自分(戦車)の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// // 戦車行動によるマップ変更 現在位置 向き\n\tpublic Map shuttGun(Map map) {\n\t\t// 左向き\n\t\tif (situation.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_width; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (situation.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map.getMap()[0].length - now_width); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (situation.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_height; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height - i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (situation.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.getMap().length - now_height); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height + i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic Map move_tank(String s, Map map) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\t\t\t} else if (map.getMap()[now_height + 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height + 1][now_width] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height - 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height - 1][now_width] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t}\n\t\treturn map;\n\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\n// マップについて扱ったクラス\nclass Map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\t//?????£?????????????????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString[] area = insBR.readLine().split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±???????´?\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\t//?????£??????????????±?????????\n\t\t\t\tString[] fieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\n\t\t\t//?????????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\n\t\t\tField insField = aryIns[k];\n\t\t\t//????????????????????????????????????????????¨????????????\n\t\t\tint intHeight = insField.field.length;\n\t\t\tint intWidth = insField.field[0].length;\n\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != aryIns.length -1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£????????????????????¨???????????????????????°*/\n\t\tprivate int intHeight;\n\t\tprivate int intWidth;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.intHeight = field.length;\n\t\t\tthis.intWidth = field[0].length;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tint input_length = 0;\n\t\t\t// マップの高さ\n\t\t\tint height = 0;\n\t\t\t// マップの幅\n\t\t\tint width = 0;\n\t\t\t// 各完成マップを入れる配列\n\t\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t\t// 入力の回数\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tinput_length = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 入力回数分ゲームをする\n\t\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\t// マップの高さ\n\t\t\t\t\theight = sc.nextInt();\n\t\t\t\t\t// マップの幅\n\t\t\t\t\twidth = sc.nextInt();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// マップのインスタンスを作る\n\t\t\t\tmap map = new map();\n\t\t\t\t// 戦車のインスタンスを作る\n\t\t\t\ttank tank = new tank();\n\t\t\t\tmap.setMap(height, width);\n\n\t\t\t\tString line = null;\n\t\t\t\t// マップ作成\n\t\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t\t// マップ一列\n\t\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\t\tline = sc.next();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 一文字ずつに分解\n\t\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t\t//\n\t\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t\t// マップを作る\n\t\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint command_number = 0;\n\t\t\t\tString command_attack = \"\";\n\t\t\t\t// コマンド入力回数\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tcommand_number = sc.nextInt();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// コマンドの文字列\n\t\t\t\tchar[] command_at = null;\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\t\tcommand_at = command_attack.toCharArray();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// コマンド回数分まわす\n\t\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t\t// タンクの現在位置を把握\n\t\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t\t// 砲弾発射だったら\n\t\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 移動の場合\n\t\t\t\t\t\tmap.move_tank(tank.getNow_height(),\n\t\t\t\t\t\t\t\ttank.getNow_width(),\n\t\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// リストにできたマップを格納\n\t\t\t\tmap_list.add(map);\n\t\t\t}\n\t\t\t// 結果を出力\n\t\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\t\tmap_list.get(f).out_map();\n\t\t\t\tif (f != map_list.size() - 1) {\n\t\t\t\t\t// 改行\n\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.getStackTrace();\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\ttry{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map2> map_list = new ArrayList<map2>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\n\t\t\t// 入力回数分ゲームをする\n\t\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t\t// マップの高さ\n\t\t\t\theight = sc.nextInt();\n\t\t\t\t// マップの幅\n\t\t\t\twidth = sc.nextInt();\n\n\t\t\t\t// マップのインスタンスを作る\n\t\t\t\tmap2 map = new map2();\n\t\t\t\t// 戦車のインスタンスを作る\n\t\t\t\ttank2 tank = new tank2();\n\t\t\t\tmap.setMap(height, width);\n\n\t\t\t\tString line = null;\n\t\t\t\t// マップ作成\n\t\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t\t// マップ一列\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\t// 一文字ずつに分解\n\t\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t\t//\n\t\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t\t// マップを作る\n\t\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint command_number = 0;\n\t\t\t\tString command_attack = \"\";\n\t\t\t\t// コマンド入力回数\n\t\t\t\tcommand_number = sc.nextInt();\n\n\t\t\t\t// コマンドの文字列\n\t\t\t\tchar[] command_at = null;\n\n\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t\t// コマンド回数分まわす\n\t\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t\t// タンクの現在位置を把握\n\t\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t\t// 砲弾発射だったら\n\t\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 移動の場合\n\t\t\t\t\t\tmap.move_tank(tank.getNow_height(),\n\t\t\t\t\t\t\t\ttank.getNow_width(),\n\t\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// リストにできたマップを格納\n\t\t\t\tmap_list.add(map);\n\t\t\t}\n\t\t\tsc.close();\n\t\t\t// 結果を出力\n\t\t\tfor (map2 obj : map_list) {\n\t\t\t\tobj.out_map();\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\t\t}catch(Exception e){\n\t\t\te.getStackTrace();\n\t\t}\n\t}\n\n}\n\nclass tank2 {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map2 {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\n//\t\t// ???????????????????¨????\n//\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n//\t\t// ??????????????????????????????\n//\t\tswitch (tank.getDir()) {\n//\t\t// ('^', { -1, 0 });\n//\t\tcase '^':\n//\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n//\t\t\t\tif (game_Map[cnt][shell[1]] == '*') {\n//\t\t\t\t\tgame_Map[cnt][shell[1]] = '.';\n//\t\t\t\t\tbreak;\n//\t\t\t\t} else if (game_Map[cnt][shell[1]] == '#') {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t// ('v',{ 1, 0 });\n//\t\tcase 'v':\n//\t\t\tfor (int cnt = 1; cnt < game_Map.length - shell[0]; cnt++) {\n//\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]] == '*') {\n//\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = '.';\n//\t\t\t\t\tbreak;\n//\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]] == '#') {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t// ('<', { 0, -1 });\n//\t\tcase '<':\n//\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n//\t\t\t\tif (game_Map[shell[0]][cnt] == '*') {\n//\t\t\t\t\tgame_Map[shell[0]][cnt] = '.';\n//\t\t\t\t\tbreak;\n//\t\t\t\t} else if (game_Map[shell[0]][cnt] == '#') {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t// ('>', { 0, 1 });\n//\t\tcase '>':\n//\t\t\tfor (int cnt = 1; cnt < game_Map[1].length - shell[1]; cnt++) {\n//\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt] == '*') {\n//\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = '.';\n//\t\t\t\t\tbreak;\n//\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt] == '#') {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t}\n//\n\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t// ???????????????\n\t\tint[] addr = { -1, 1 };\n\n\t\twhile (true) {\n\t\t\tif (tank.getDir() == '^') {\n\t\t\t\tif (pos[0] - 1 >= 0) {\n\n\t\t\t\t\tpos[0] += addr[0];\n\t\t\t\t\tif (game_Map[pos[0]][pos[1]] == '*') {\n\t\t\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[pos[0]][pos[1]] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == 'v') {\n\t\t\t\tif (pos[0] + 1 < game_Map.length) {\n\n\t\t\t\t\tpos[0] += addr[1];\n\t\t\t\t\tif (game_Map[pos[0]][pos[1]] == '*') {\n\t\t\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[pos[0]][pos[1]] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '<') {\n\t\t\t\tif (pos[1] - 1 >= 0) {\n\n\t\t\t\t\tpos[1] += addr[0];\n\t\t\t\t\tif (game_Map[pos[0]][pos[1]] == '*') {\n\t\t\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[pos[0]][pos[1]] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '>') {\n\t\t\t\tif (pos[1] + 1 < game_Map[0].length) {\n\n\t\t\t\t\tpos[1] += addr[1];\n\t\t\t\t\tif (game_Map[pos[0]][pos[1]] == '*') {\n\t\t\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[pos[0]][pos[1]] == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}// canon_Shot????????????????????????\n\n\tprivate static void road_MapInfo(char[][] game_Map, int[] pos) {\n\n\t\tif(game_Map[pos[0]][pos[1]] == '*'){\n\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t}\n\t}\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\tint[] addr = { -1, 1 };\n\n\t\tif (tank.getDir() == '^') {\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == 'v') {\n\t\t\tif (move[0] + 1 < game_Map.length) {\n\t\t\t\tmove[0] += addr[1];\n\t\t\t}\n\t\t} else if (tank.getDir() == '<') {\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == '>') {\n\t\t\tif (move[1] + 1 < game_Map[0].length) {\n\t\t\t\tmove[1] += addr[1];\n\t\t\t}\n\t\t}\n\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\ttank.setPos(move);\n\t\t}\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\tstatic ArrayList<String> printList = new ArrayList<String>();\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint dataSetsCount = Integer.parseInt(sc.nextLine());\n\t\tfor (int count = 0; count < dataSetsCount; count++) {\n\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tmap.tank.ExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\n\t\t\tPrint();\n\t\t\tif (count < dataSetsCount - 1)\n\t\t\t\tSystem.out.println();\n\t\t}\n\t\t/*for (String str : printList) {\n\t\t\tSystem.out.print(str);\n\t\t}*/\n\t}\n\n\tstatic void Print() {\n\n\t\tfor (int y = 0; y < map.height; y++) {\n\t\t\tString str = \"\";\n\t\t\tfor (int x = 0; x < map.width; x++) {\n\t\t\t\tif (map.tank.Y == y && map.tank.X == x) {\n\t\t\t\t\tstr += map.tank.State.str;\n\t\t\t\t} else {\n\t\t\t\t\tTile t = map.getTile(x, y);\n\t\t\t\t\tstr += t.Type.str;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr += \"\\n\";\n\t\t\tSystem.out.print(str);\n\t\t}\n\t}\n\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\tstatic class Tile {\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\tenum ActionType {\n\t\tU(\"Up\"), D(\"Down\"), L(\"Left\"), R(\"Right\"), S;\n\n\t\tTankState ts;\n\n\t\tActionType() {\n\n\t\t}\n\n\t\tActionType(String str) {\n\t\t\tthis.ts = TankState.valueOf(str);\n\t\t}\n\t}\n\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\t\tString str;\n\t\tint x;\n\t\tint y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic class Tank {\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\n\t\tvoid ExecuteAction(ActionType action) {\n\t\t\tif (action == ActionType.S) {\n\t\t\t\tthis.Shoot();\n\t\t\t} else {\n\t\t\t\tif (map.MobilityCheck(this.X + action.ts.x, this.Y + action.ts.y)) {\n\t\t\t\t\tthis.X += action.ts.x;\n\t\t\t\t\tthis.Y += action.ts.y;\n\t\t\t\t}\n\t\t\t\tthis.State = action.ts;\n\t\t\t}\n\t\t}\n\n\t\tvoid Shoot() {\n\t\t\tint x = this.X;\n\t\t\tint y = this.Y;\n\t\t\tTile tile = map.getTile(x, y);\n\t\t\twhile (tile != null && (tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\tx += this.State.x;\n\t\t\t\ty += this.State.y;\n\t\t\t\ttile = map.getTile(x, y);\n\t\t\t}\n\t\t\tif (tile != null && tile.Type == TileType.Brick) {\n\t\t\t\tmap.BreakBrickTile(x, y);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Map {\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\n\t\tint height;\n\t\tint width;\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvoid BreakBrickTile(int x, int y) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, new Tile(x, y, TileType.Field));\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\n\t\t\t\t\tTileType tt = TileDiscrimination(line[x]);\n\t\t\t\t\tif (tt != null) {\n\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTankState ts = TankDiscrimination(line[x]);\n\t\t\t\t\t\tif (ts != null) {\n\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTileType TileDiscrimination(String str) {\n\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\tif (tt.str.equals(str)) {\n\t\t\t\t\treturn tt;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tTankState TankDiscrimination(String str) {\n\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\tif (ts.str.equals(str)) {\n\t\t\t\t\treturn ts;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean MobilityCheck(int x, int y) {\n\t\t\tTile t = getTile(x, y);\n\t\t\tif (t != null && t.Type == TileType.Field) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString cmd_row = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, cmd_row.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/*\n\t * ???????????????????????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/*\n\t * ????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\t\t// ?????¨??°\n\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t// ???????????????\n\t\tint[] addr = { -1, 1 };\n\n\t\twhile (true) {\n\t\t\tif (tank.getDir() == '^') {\n\t\t\t\tif (pos[0] - 1 >= 0) {\n\t\t\t\t\t// [-1,0]\n\t\t\t\t\tpos[0] += addr[0];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == 'v') {\n\t\t\t\tif (pos[0] + 1 < game_Map.length) {\n\t\t\t\t\t// [+1,0]\n\t\t\t\t\tpos[0] += addr[1];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '<') {\n\t\t\t\tif (pos[1] - 1 >= 0) {\n\t\t\t\t\t// [0,-1]\n\t\t\t\t\tpos[1] += addr[0];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '>') {\n\t\t\t\tif (pos[1] + 1 < game_Map[0].length) {\n\t\t\t\t\t// [0,+1]\n\t\t\t\t\tpos[1] += addr[1];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (game_Map[pos[0]][pos[1]]) {\n\t\t\tcase '.':\n\t\t\tcase '-':\n\t\t\t\tcontinue;\n\n\t\t\tcase '*':\n\t\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t\tcase '#':\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}// canon_Shot????????????????????????\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\tint[] addr = { -1, 1 };\n\n\t\tif (tank.getDir() == '^') {\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == 'v') {\n\t\t\tif (move[0] + 1 < game_Map.length) {\n\t\t\t\tmove[0] += addr[1];\n\t\t\t}\n\t\t} else if (tank.getDir() == '<') {\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == '>') {\n\t\t\tif (move[1] + 1 < game_Map[0].length) {\n\t\t\t\tmove[1] += addr[1];\n\t\t\t}\n\t\t}\n\t\t// ?????????????§????\n\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\ttank.setPos(move);\n\t\t}\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// ?????????????§???????????????????\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ????????????????????????\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tTank2[][] game_Map = new Tank2[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank2 tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], new Tank2('W'));\n\t\t\t}\n\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (game_Map[mh][mw + 1].getMap_info() == '^' || game_Map[mh][mw + 1].getMap_info() == 'v'\n\t\t\t\t\t\t\t|| game_Map[mh][mw + 1].getMap_info() == '<' || game_Map[mh][mw + 1].getMap_info() == '>') {\n\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank2(game_Map[mh][mw + 1].getMap_info(), new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\tcommand(tank, game_Map, cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void command(Tank2 tank, Tank2[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ??????????????±?????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] next = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tnext[0] += tank.getDir_Map().get(tank.getDir())[0];\n\t\t\tnext[1] += tank.getDir_Map().get(tank.getDir())[1];\n\t\t\t// ?????°???????§??????????\n\t\t\tif (game_Map[next[0]][next[1]].getMap_info() == '.') {\n\t\t\t\ttank.setPos(next);\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\twhile (true) {\n\t\t\t\tshell[0] += tank.getDir_Map().get(tank.getDir())[0];\n\t\t\t\tshell[1] += tank.getDir_Map().get(tank.getDir())[1];\n\t\t\t\tswitch (game_Map[shell[0]][shell[1]].getMap_info()) {\n\t\t\t\tcase '.':\n\t\t\t\tcase '-':\n\t\t\t\t\tcontinue;\n\t\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\t\tcase '*':\n\t\t\t\t\tgame_Map[shell[0]][shell[1]] = new Tank2('.');\n\t\t\t\tcase '#':\n\t\t\t\tcase 'W':\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}// command????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t *\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t */\n\tprivate static void last_tankLocate(Tank2 tank, Tank2[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Tank2(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n}\n\nclass Tank2 {\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/*\n\t * ???????????????????????????????????????\n\t */\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\t/*\n\t * ????????????????????????\n\t */\n\tpublic Tank2(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Tank2(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/*\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n\t/*\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// tank2 ?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ??????????????????????????±?????¶???????????????\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ????????????????????¨?????????????????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('U', '^');\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// ('D', 'v');\n\t\t\t// ('v', { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('L', '<');\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('R', '>');\n\t\t\t// ('>',{ 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\t// ??????????????????????????????\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('v',{ 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('>', { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0){\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\t\t\t// ????????°??????????????????\n\t\t// sc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfinal int T = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < T; i++){\n\t\t\tif(i != 0){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tfinal int H = sc.nextInt();\n\t\t\tfinal int W = sc.nextInt();\n\t\t\t\n\t\t\tchar[][] map = new char[H+2][W+2];\n\t\t\t\n\t\t\tint p_x = 0, p_y = 0;\n\t\t\t\n\t\t\tfor(int j = 0; j < (H + 2); j++){\n\t\t\t\tchar[] str = null;\n\t\t\t\tif(!(j == 0 || j == H + 1)){\n\t\t\t\t\tstr = sc.next().toCharArray();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < (W + 2); k++){\n\t\t\t\t\tif(j == 0 || j == H + 1 || k == 0 || k == W + 1){\n\t\t\t\t\t\tmap[j][k] = '#';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[j][k] = str[k-1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(map[j][k] == '<' || map[j][k] == '>' || map[j][k] == '^' || map[j][k] == 'v'){\n\t\t\t\t\t\t\tp_x = k;\n\t\t\t\t\t\t\tp_y = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc.next();\n\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\tfor(char c : input){\n\t\t\t\tif(c == 'U'){\n\t\t\t\t\tmap[p_y][p_x] = '^';\n\t\t\t\t\tif(map[p_y-1][p_x] == '.'){\n\t\t\t\t\t\tmap[p_y-1][p_x] = '^';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_y--;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'D'){\n\t\t\t\t\tmap[p_y][p_x] = 'v';\n\t\t\t\t\tif(map[p_y+1][p_x] == '.'){\n\t\t\t\t\t\tmap[p_y+1][p_x] = 'v';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_y++;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'L'){\n\t\t\t\t\tmap[p_y][p_x] = '<';\n\t\t\t\t\tif(map[p_y][p_x-1] == '.'){\n\t\t\t\t\t\tmap[p_y][p_x-1] = '<';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_x--;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'R'){\n\t\t\t\t\tmap[p_y][p_x] = '>';\n\t\t\t\t\tif(map[p_y][p_x+1] == '.'){\n\t\t\t\t\t\tmap[p_y][p_x+1] = '>';\n\t\t\t\t\t\tmap[p_y][p_x] = '.';\n\t\t\t\t\t\tp_x++;\n\t\t\t\t\t}\n\t\t\t\t}else if(c == 'S'){\n\t\t\t\t\tint s_x = 0, s_y = 0;\n\t\t\t\t\t\n\t\t\t\t\tif(map[p_y][p_x] == '^'){\n\t\t\t\t\t\ts_y = -1;\n\t\t\t\t\t}else if(map[p_y][p_x] == 'v'){\n\t\t\t\t\t\ts_y = 1;\n\t\t\t\t\t}else if(map[p_y][p_x] == '<'){\n\t\t\t\t\t\ts_x = -1;\n\t\t\t\t\t}else if(map[p_y][p_x] == '>'){\n\t\t\t\t\t\ts_x = 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint xx = p_x + s_x;\n\t\t\t\t\tint yy = p_y + s_y;\n\t\t\t\t\t\n\t\t\t\t\twhile(!(map[yy][xx] == '*' || map[yy][xx] == '#')){\n\t\t\t\t\t\tyy += s_y;\n\t\t\t\t\t\txx += s_x;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(map[yy][xx] == '*'){\n\t\t\t\t\t\tmap[yy][xx] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 1; j < H + 1; j++){\n\t\t\t\tfor(int k = 1; k < W + 1; k++){\n\t\t\t\t\tSystem.out.print(map[j][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        \n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            \n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            for( int x = 0 ; x < aryBattleArea.length ; x++ ){\n                for( int y = 0 ; y < aryBattleArea[i].length ; y++ ){\n                \t\n                    System.out.print(aryBattleArea[x][y]);\n                    \n                }\n                System.out.println();\n            }\n            \n        }\n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                              //  continue;\n                             \n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    public void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n        //??????????°?  \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t// マップの高さ\n\t\t\theight = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\twidth = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap map = new map();\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank tank = new tank();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint command_number = 0;\n\t\t\tString command_attack = \"\";\n\t\t\t// コマンド入力回数\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_number = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; i < command_number; c++) {\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//砲弾発射だったら\n\t\t\t\tif(command_attack.equals(\"S\")){\n\t\t\t\t\t//マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(), tank.getSituation());\n\t\t\t\t}else{\n\t\t\t\t\t//移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(), tank.getSituation());\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (map obj : map_list) {\n\t\t\tobj.out_map();\n\t\t\t// 改行\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(int height, int width, String[][] map) {\n\t\tfor (int h = 0; h < height; h++) {\n\t\t\tfor (int w = 0; w < width; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map[h][w] == val) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\t// マップの高さ\n\tprivate int height = 0;\n\t// マップの幅さ\n\tprivate int width = 0;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t\theight = h;\n\t\twidth = w;\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t//\n\t\t\tfor (int i = 0; i < now_w; i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\tfor (int i = 0; i < (width - 1 - now_w); i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\tfor (int i = 0; i < (height - 1 - now_h); i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\tfor (int i = 0; i < now_h; i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更 現在位置 向き\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w + 1] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\t\tString str;\n\t\tint x;\n\t\tint y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tenum ActionType {\n\t\tU, D, L, R, S;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint dataSetsCount=Integer.parseInt(sc.nextLine());\n\t\tfor(int count=0;count<dataSetsCount;count++) {\n\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\n\t\t\tmap.Print();\n\t\t\tSystem.out.println();\n\t\t}\n\n\t}\n\n\tstatic void ExecuteAction(ActionType action) {\n\t\tTank tank = map.tank;\n\t\tTile tile;\n\t\tswitch (action) {\n\t\tcase U:\n\t\t\ttile =map.getTile(tank.X, tank.Y - 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Up;\n\t\t\tbreak;\n\t\tcase D:\n\t\t\ttile =map.getTile(tank.X, tank.Y + 1);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.Y += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Down;\n\t\t\tbreak;\n\t\tcase L:\n\t\t\ttile =map.getTile(tank.X-1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X -= 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Left;\n\t\t\tbreak;\n\t\tcase R:\n\t\t\ttile =map.getTile(tank.X+1, tank.Y);\n\t\t\tif (tile!=null && tile.Type == TileType.Field) {\n\t\t\t\ttank.X += 1;\n\t\t\t}\n\t\t\ttank.State = TankState.Right;\n\t\t\tbreak;\n\t\tcase S:\n\t\t\tint x = tank.X ;\n\t\t\tint y = tank.Y ;\n\t\t\ttile = map.getTile(x, y);\n\t\t\twhile (tile != null &&( tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\tx += tank.State.x;\n\t\t\t\ty += tank.State.y;\n\t\t\t\ttile = map.getTile(x, y);\n\t\t\t}\n\t\t\tif (tile != null && tile.Type == TileType.Brick) {\n\t\t\t\ttile.Type = TileType.Field;\n\t\t\t\tmap.setTile(x, y, tile);\n\n\t\t\t}\n\n\t\t}\n\t\tmap.tank = tank;\n\t}\n\n\tstatic class Map {\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\n\t\tint[][] coordinate;\n\t\tint height;\n\t\tint width;\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tcoordinate = new int[height][width];\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvoid setTile(int x, int y, Tile tile) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, tile);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\n\t\t\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\t\t\tif (tt.str.equals(line[x])) {\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\t\t\t\t\tif (ts.str.equals(line[x])) {\n\t\t\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Print() {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\tif (tank.Y == y && tank.X == x) {\n\t\t\t\t\t\tSystem.out.print(tank.State.str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTile t = getTile(x, y);\n\t\t\t\t\t\tSystem.out.print(t.Type.str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Tile {\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\tstatic class Tank {\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t// マップの高さ\n\t\t\theight = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\twidth = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap map = new map();\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank tank = new tank();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint command_number = 0;\n\t\t\tString command_attack = \"\";\n\t\t\t// コマンド入力回数\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_number = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\tcommand_at = command_attack.toCharArray();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (map obj : map_list) {\n\t\t\tobj.out_map();\n\t\t\t// 改行\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main (String args[]){\n\n\t\t//??\\??????????????????????????????Scanner???????????§???????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tint i = 0;\n\n\t\tfor(i = 0; i < T; i++){\n\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tchar[][] map = new char[H][W];\n\n\t\t\t//???0??????1??????2??????3\n\t\t\tchar tank;\n\n\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tString line = sc.next();\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tmap[j][k] = line.charAt(k);\n\n\t\t\t\t\tif(map[j][k] == '^' || map[j][k] == 'v' || map[j][k] == '<' || map[j][k] == '>'){\n\t\t\t\t\t\tif(map[j][k] == '^'){\n\t\t\t\t\t\t\ttank = '^';\n\t\t\t\t\t\t}else if(map[j][k] == 'v'){\n\t\t\t\t\t\t\ttank = 'v';\n\t\t\t\t\t\t}else if(map[j][k] == '<'){\n\t\t\t\t\t\t\ttank = '<';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttank = '>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint t = j;\n\t\t\t\t\t\tint y = k;\n\t\t\t\t\t\tBattle BT = new Battle(t,y,tank,map);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint N = sc.nextInt();\n\t\t\tString com = sc.next();\n\t\t\tchar[] command = new char[N];\n\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tcommand[j] = com.charAt(j);\n\t\t\t\tBattle.check(command[j]);\n\t\t\t}\n\n\t\t\tSystem.out.println(Battle.output());\n\t\t}\n\t\twhile(i != T){\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t\tsc.close();\n\t}\n}\n\nclass Battle{\n\tstatic int tate;\n\tstatic int yoko;\n\tstatic char tank;\n\tstatic char[][] map;\n\n\t//????????\\??????\n\tBattle(int t, int y, char tankk, char[][] mapp){\n\t\ttate = t;\n\t\tyoko = y;\n\t\tmap = mapp;\n\t\ttank = tankk;\n\t}\n\n\tpublic static String output(){\n\t\tStringBuffer str = new StringBuffer();\n\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\tstr.append(map[i][j]);\n\t\t\t}\n\t\t\tstr.append(System.getProperty(\"line.separator\"));\n\t\t}\n\t\tString ans = new String(str);\n\t\treturn ans;\n\t}\n\n\tpublic static void check(char command){\n\n\t\tswitch (command){\n\n\t\tcase 'U':\n\t\t\ttank = '^';\n\t\t\tif(map[tate-1][yoko] == '.'){\n\t\t\t\ttate = tate - 1;\n\t\t\t\tmap[tate][yoko] = '^';\n\t\t\t\tmap[tate+1][yoko] = '.';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\ttank = 'v';\n\t\t\tif(map[tate+1][yoko] == '.'){\n\t\t\t\ttate = tate + 1;\n\t\t\t\tmap[tate][yoko] = 'v';\n\t\t\t\tmap[tate-1][yoko] = '.';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\ttank = '<';\n\t\t\tif(map[tate][yoko-1] == '.'){\n\t\t\t\tyoko = yoko - 1;\n\t\t\t\tmap[tate][yoko] = '<';\n\t\t\t\tmap[tate][yoko+1] = '.';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\ttank = '>';\n\t\t\tif(map[tate][yoko+1] == '.'){\n\t\t\t\tyoko = yoko + 1;\n\t\t\t\tmap[tate][yoko] = '>';\n\t\t\t\tmap[tate][yoko-1] = '.';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tswitch (tank){\n\t\t\tcase '^':\n\t\t\t\tfor(int i = tate; i >= 0; i--){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tfor(int i = tate; i < map.length; i++){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '<':\n\t\t\t\tfor(int i = yoko; i >= 0; i--){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = -1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tfor(int i = yoko; i < map[tate].length; i++){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = map[tate].length +1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tif (data_set > 0)\n\t\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class BattleTown {\n\n\t// マップ\n\n\t// 戦車\n\tclass Tank {\n\n\t\tchar[][] map;\n\n\t\tint x, y; \t  // 座標\n\t\tchar dir; \t  // 向いてる方角\n\n\t\tint bx=-1, by=-1;   // 砲弾の座標\n\n\t\tpublic Tank(int x, int y,  int dir, char[][] map) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.map = map;\n\t\t\tif(dir == 0) this.dir = 'L';\n\t\t\telse if(dir == 1) this.dir = 'U';\n\t\t\telse if(dir == 2) this.dir = 'R';\n\t\t\telse if(dir == 3) this.dir = 'D';\n\t\t}\n\n\t\t// 命令\n\t\t// rの取りうる値: UDLR\n\t\tpublic void order(char r) {\n\n\t\t\t// 回転し、進めるのであれば進む\n\t\t\tif(r == 'U') {\n\t\t\t\tdir = 'U';\n\t\t\t\tmap[y][x] = '^';\n\t\t\t\tif(isMovable(x, y-1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty -= 1;\n\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = '^';\n\t\t\t\t} else {\n\t\t\t\t\t// 方向転換だけ行う\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'D') {\n\t\t\t\tdir = 'D';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t\tif(isMovable(x, y+1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty += 1;\n\t\t\t\t\t//\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = 'v';\n\t\t\t\t}\n\t\t\t} else if(r == 'L') {\n\t\t\t\tdir = 'L';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t\tif(isMovable(x-1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx -= 1;\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'R') {\n\t\t\t\tdir = 'R';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t\tif(isMovable(x+1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx += 1;\n\t\t\t\t\tmap[y][x] = '>';\n\t\t\t\t}\n\t\t\t} else if(r == 'S') {\n\t\t\t\tshot(dir);\n\t\t\t}\n\n\t\t}\n\n\t\t// 砲撃\n\t\tpublic void shot(char dir) {\n\n\t\t\t// 砲弾の位置初期化\n\t\t\tbx = x;\n\t\t\tby = y;\n\n\t\t\t// 方向を設定し発射\n\t\t\tmoveBullet(dir);\n\n\t\t}\n\n\t\t// 砲弾の移動\n\t\tpublic void moveBullet(char dir) {\n\n\t\t\t// 移動先座標\n\t\t\tint toX = -1;\n\t\t\tint toY = -1;\n\t\t\tif(dir == 'L') {\n\t\t\t\ttoX = bx-1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx -= 1;\n\t\t\t} else if(dir == 'U') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by-1;\n\t\t\t\tby -= 1;\n\t\t\t} else if(dir == 'R') {\n\t\t\t\ttoX = bx+1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx += 1;\n\t\t\t} else if(dir == 'D') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by+1;\n\t\t\t\tby += 1;\n\t\t\t}\n\n\t\t\t// 指定座標に移動できれば破壊し移動する\n\t\t\tif(map[toY][toX] == '*') {\n\t\t\t\t// 破壊\n\t\t\t\tmap[toY][toX] = '.';\n\t\t\t\treturn;\n\t\t\t} else if(map[toY][toX] == '#') {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmoveBullet(dir);\n\t\t\t}\n\t\t}\n\n\t\t// 指定の座標に戦車が進めるか\n\t\tpublic boolean isMovable(int x, int y) {\n\n\t\t\tif(map[y][x] == '.') return true;\n\t\t\telse return false;\n\n\t\t}\n\n\t\t// マップを表示\n\t\tpublic void drawMap() {\n\t\t\tfor(int i=1; i<map.length-1; i++) {\n\t\t\t\tfor(int j=1; j<map[i].length-1; j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップから戦車の位置と向きを取得する\n\t// @return int[] [0]戦車のx座標, [1]戦車のy座標, [2]戦車の向き(左から時計回りに0~3)\n\tpublic int[] getTankDir(char[][] map) {\n\n\t\tint[] ret = new int[3];\n\t\tfor(int i=0; i<map.length; i++) {\n\t\t\tfor(int j=0; j<map[i].length; j++){\n\t\t\t\tif(map[i][j] == '<') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 0;\n\t\t\t\t} else if(map[i][j] == '^') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 1;\n\t\t\t\t} else if(map[i][j] == '>') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 2;\n\t\t\t\t} else if(map[i][j] == 'v') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// マップセットの個数入力\n\t\tint num = sc.nextInt();\n\n\t\tfor(int n=0; n<num; n++) {\n\n\t\t\t// 地図データの入力\n\t\t\tint y = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\n\t\t\tchar[][] map = new char[y+2][x+2];\n\n\t\t\t// 外を埋める\n\t\t\tfor(int i=0; i<y+2; i++) {\n\t\t\t\tfor(int j=0; j<x+2; j++) {\n\t\t\t\t\tif(i == 0 || i == y+1 || j == 0 || j == x+1) map[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t\t\tmap[i][j] = line.toCharArray()[j-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 命令を入力\n\t\t\tint orderNum = sc.nextInt();\n\t\t\tString orders = sc.next();\n\t\t\tchar[] orderArr = orders.toCharArray();\n\n\t\t\tMain b = new Main();\n\n\t\t\t// 戦車の初期位置と向きを取得\n\t\t\tint[] tankPos = b.getTankDir(map);\n\n\n\t\t\t// 戦車を生成\n\t\t\tTank t = new Main().new Tank(tankPos[0], tankPos[1], tankPos[2], map);\n\n\t\t\t// 命令を実行\n\t\t\tfor(int i=0; i<orderNum; i++) {\n\t\t\t\tt.order(orderArr[i]);\n\t\t\t}\n\n\n\t\t\t// debug\n\t\t\t// 戦車の移動テスト\n\t\t\t//\t\tt.rotate('L');\n\n\t\t\t// マップを再表示\n\t\t\tt.drawMap();\n\t\t\tif(n != num-1) System.out.println(\"\");\n\n\t\t}\n\n\t\tsc.close();\n\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint h, w;\n\tchar[][] map;\n\tint x, y;\n\tchar d;\n\tint[] dx, dy;\n\tchar[] tank;\n\n\tvoid init() {\n\t\tint max = 0;\n\t\tmax = Math.max(max, '^');\n\t\tmax = Math.max(max, 'v');\n\t\tmax = Math.max(max, '>');\n\t\tmax = Math.max(max, '<');\n\t\tmax++;\n\t\tdx = new int[max];\n\t\tdy = new int[max];\n\t\tdy['^'] = -1;\n\t\tdy['v'] = 1;\n\t\tdx['>'] = 1;\n\t\tdx['<'] = -1;\n\t\ttank = new char['Z'];\n\t\ttank['U'] = '^';\n\t\ttank['D'] = 'v';\n\t\ttank['R'] = '>';\n\t\ttank['L'] = '<';\n\t}\n\n\tvoid shot() {\n\t\tint gx = x;\n\t\tint gy = y;\n\n\t\twhile (true) {\n\t\t\tint nx = gx + dx[d];\n\t\t\tint ny = gy + dy[d];\n\t\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (map[ny][nx] == '*') {\n\t\t\t\tmap[ny][nx] = '.';\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (map[ny][nx] == '#') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgx = nx;\n\t\t\tgy = ny;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tvoid move(char c) {\n\t\tmap[y][x] = tank[c];\n\t\td = tank[c];\n\t\tint nx = x + dx[tank[c]];\n\t\tint ny = y + dy[tank[c]];\n\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n\t\t\treturn;\n\t\t}\n\t\tif (map[ny][nx] == '.') {\n\t\t\tchar tmp = map[y][x];\n\t\t\tmap[y][x] = map[ny][nx];\n\t\t\tmap[ny][nx] = tmp;\n\t\t\tx = nx;\n\t\t\ty = ny;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\t\tinit();\n\t\tString tab = \"\";\n\n\t\tfor (int T = sc.nextInt() - 1; 0 <= T; T--) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tmap = new char[h][];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tchar[] o = sc.next().toCharArray();\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar c = map[i][j];\n\t\t\t\t\tif (c == '^' || c == 'v' || c == '>' || c == '<') {\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\td = map[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tchar c = o[i];\n\t\t\t\tif (c == 'S') {\n\t\t\t\t\tshot();\n\t\t\t\t} else {\n\t\t\t\t\tmove(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(tab);\n\t\t\ttab = \"\\r\\n\";\n\t\t\tprint();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tchar[][] map;\n\tchar[] dir = {'<', '^', '>', 'v'};\n\tP player;\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(int c=0;;c++) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tmap = new char[h+2][w+2];\n\t\t\tfor(char[] a: map) fill(a, '#');\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tmap[i][j] = str.charAt(j-1);\n\t\t\t\t\tif(map[i][j] == '<' ) {\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t\tplayer = new P(j, i, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse if( map[i][j] == '>' ) {\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t\tplayer = new P(j, i, 2);\n\t\t\t\t\t}\n\t\t\t\t\telse if( map[i][j] == '^' ) {\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t\tplayer = new P(j, i, 1);\n\t\t\t\t\t}\n\t\t\t\t\telse if( map[i][j] == 'v' ) {\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t\tplayer = new P(j, i, 3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tString ops = sc.next();\n\t\t\tfor(int op=0;op<n;op++) {\n\t\t\t\tint nx = player.x, ny = player.y;\n\t\t\t\tswitch (ops.charAt(op)) {\n\t\t\t\tcase 'S':\n\t\t\t\t\tfor(int i=1;;i++) {\n\t\t\t\t\t\tint x = player.x+dx[player.d]*i;\n\t\t\t\t\t\tint y = player.y+dy[player.d]*i;\n\t\t\t\t\t\tif(map[y][x] == '*') {\n\t\t\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map[y][x] == '#') break;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tnx = player.x + dx[0];\n\t\t\t\t\tny = player.y + dy[0];\n\t\t\t\t\tplayer.d = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'U':\n\t\t\t\t\tnx = player.x + dx[1];\n\t\t\t\t\tny = player.y + dy[1];\n\t\t\t\t\tplayer.d = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tnx = player.x + dx[2];\n\t\t\t\t\tny = player.y + dy[2];\n\t\t\t\t\tplayer.d = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tnx = player.x + dx[3];\n\t\t\t\t\tny = player.y + dy[3];\n\t\t\t\t\tplayer.d = 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[ny][nx] != '*' && map[ny][nx] != '#' &&\n\t\t\t\t   map[ny][nx] != '-') {\n\t\t\t\t\tplayer.x = nx;\n\t\t\t\t\tplayer.y = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[player.y][player.x] = dir[player.d];\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(c < t-1) System.out.println();\n\t\t\telse break;\n\t\t}\n\t}\n\t\n\tclass P {\n\t\tint x, y, d;\n\t\tP(int x, int y, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.d = d;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tString[][] result = new String[N][];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint H = stdIn.nextInt();\n\t\t\tint W = stdIn.nextInt();\n\t\t\tString[] str = new String[H];\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tstr[j] = stdIn.next();\n\t\t\t}\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tmap[j] = str[j].toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint[] now = new int[2];\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif( map[j][k] == '<' || map[j][k] == '>' || map[j][k] == '^' || map[j][k] == 'v' ){\n\t\t\t\t\t\tnow[0] = k;\n\t\t\t\t\t\tnow[1] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint com = stdIn.nextInt();\n\t\t\tString s = stdIn.next();\n\t\t\tchar[] c = s.toCharArray();\n\t\t\tfor(int j = 0; j < com; j++){\n\t\t\t\tif( c[j] == 'U' ){\n\t\t\t\t\tif( now[1] > 0 && map[now[1]-1][now[0]] == '.' ){\n\t\t\t\t\t\tmap[now[1]-1][now[0]] = '^';\n\t\t\t\t\t\tmap[now[1]][now[0]] = '.';\n\t\t\t\t\t\tnow[1]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[now[1]][now[0]] = '^';\n\t\t\t\t\t}\n\t\t\t\t} else if( c[j] == 'D' ){\n\t\t\t\t\tif( now[1] < map.length-1 && map[now[1]+1][now[0]] == '.' ){\n\t\t\t\t\t\tmap[now[1]+1][now[0]] = 'v';\n\t\t\t\t\t\tmap[now[1]][now[0]] = '.';\n\t\t\t\t\t\tnow[1]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[now[1]][now[0]] = 'v';\n\t\t\t\t\t}\n\t\t\t\t} else if( c[j] == 'L' ){\n\t\t\t\t\tif( now[0] > 0 && map[now[1]][now[0]-1] == '.' ){\n\t\t\t\t\t\tmap[now[1]][now[0]-1] = '<';\n\t\t\t\t\t\tmap[now[1]][now[0]] = '.';\n\t\t\t\t\t\tnow[0]--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[now[1]][now[0]] = '<';\n\t\t\t\t\t}\n\t\t\t\t} else if( c[j] == 'R' ){\n\t\t\t\t\tif( now[0] < map[now[1]].length-1 && map[now[1]][now[0]+1] == '.' ){\n\t\t\t\t\t\tmap[now[1]][now[0]+1] = '>';\n\t\t\t\t\t\tmap[now[1]][now[0]] = '.';\n\t\t\t\t\t\tnow[0]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[now[1]][now[0]] = '>';\n\t\t\t\t\t}\n\t\t\t\t} else if( c[j] == 'S' ){\n\t\t\t\t\tif( map[now[1]][now[0]] == '>' ){\n\t\t\t\t\t\tfor(int k = now[0]+1; k < map[now[0]].length; k++){\n\t\t\t\t\t\t\tif( map[now[1]][k] == '*' ){\n\t\t\t\t\t\t\t\tmap[now[1]][k] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if( map[now[1]][k] == '#' ){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if( map[now[1]][now[0]] == '<' ){\n\t\t\t\t\t\tfor(int k = now[0]-1; k >= 0; k--){\n\t\t\t\t\t\t\tif( map[now[1]][k] == '*' ){\n\t\t\t\t\t\t\t\tmap[now[1]][k] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if( map[now[1]][k] == '#' ){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\t\n\t\t\t\t\t} else if( map[now[1]][now[0]] == 'v' ){\n\t\t\t\t\t\tfor(int k = now[1]+1; k < map.length; k++){\n\t\t\t\t\t\t\tif( map[k][now[0]] == '*' ){\n\t\t\t\t\t\t\t\tmap[k][now[0]] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if( map[k][now[0]] == '#' ){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if( map[now[1]][now[0]] == '^' ){\n\t\t\t\t\t\tfor(int k = now[1]-1; k >= 0; k--){\n\t\t\t\t\t\t\tif( map[k][now[0]] == '*' ){\n\t\t\t\t\t\t\t\tmap[k][now[0]] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if( map[k][now[0]] == '#' ){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult[i] = new String[H];\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tresult[i][j] = new String(map[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int j = 0; j < result[i].length; j++){\n\t\t\t\tSystem.out.println(result[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tfor(int i = 0; i < result[N-1].length; i++){\n\t\t\tSystem.out.println(result[N-1][i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "class Main{\n\t\n\t/**\n\t * プログラムエントリポイント\n\t * @param args\n\t */\n\tpublic static void main (String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//データセット回数を入力\n\t\tint setCountData = sc.nextInt();\n\t\t//入力されたデータセット回数分繰り返す\n\t\tfor( int i = 0 ; i < setCountData ; i++ ){\n\t\t\t//繰り返す回数ごとに配列を作成して２次元配列の長さを入力\n\t\t\tchar[][] aryBattleArea = new char[sc.nextInt()][sc.nextInt()];\n\t\t\t//配列aryBattleAreaに市街戦の要素入力\n\t\t\tfor( int j = 0 ; j < aryBattleArea.length ; j++ ){\n\t\t\t\taryBattleArea[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\t//繰り返す回数ごとに配列を作成して１次元配列の長さを入力\n\t\t\tchar[] aryOperation = new char[sc.nextInt()];\n\t\t\t//配列aryOperationに操作分を入力したものを文字ごとに配列に格納\n\t\t\taryOperation = sc.next().toCharArray();\n\t\t\t\n\t\t\t//BattleTownをインスタンス化\n\t\t\tBattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n\t\t\t\n\t\t\taryBattleArea = insBt.runOperation();\n\t\t\t\n\t\t\tfor( int x = 0 ; x < aryBattleArea.length ; x++ ){\n\t\t\t\tfor( int y = 0 ; y < aryBattleArea[i].length ; y++ ){\n\t\t\t\t\tSystem.out.print(aryBattleArea[x][y]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\n/**\n * \n * 操作を実行する\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n\t\n\tprivate char[][] aryBattleArea;\n\tprivate char[] aryOperation;\n\t\n\t/**\n\t * コンストラクタ\n\t * @param aryBattleArea 戦場を表す二次元配列\n\t * @param aryOperation 命令を表す一次元配列\n\t */\n\tpublic BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n\t\t\n\t\tthis.aryBattleArea = aryBattleArea;\n\t\tthis.aryOperation = aryOperation;\n\t\t\n\t}\n\t\n\t/**\n\t * 指定された操作を順番にactionTankクラス渡し\n\t * 渡した操作は'0'にして読み取れないように\n\t */\n\tpublic char[][] runOperation(){\n\t\t\n\t\tfor( int k = 0 ; k < aryOperation.length ; k++ ){\n\t\t\t\n\t\t\tif( aryOperation[k] != '0' ){\n\t\t\t\n\t\t\t\tfor( int i = 0 ; i < aryBattleArea.length ; i++ ){\n\t\t\t\t\tfor( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n\t\t\t\t\t\t\t|| aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tactionTank( i , j , aryOperation[k] );\n\t\t\t\t\t\t\t\taryOperation[k] = '0';\n\t\t\t\t\t\t\t\t//runOperation();\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn aryBattleArea;\n\t}\n\t\n\t/**\n\t * 指定された操作を実行する\n\t * @param i 戦車を発見した配列の位置\n\t * @param j 戦車を発見した配列の位置\n\t * @param c 操作命令\n\t */\n\tprivate void actionTank( int i , int j , char operation ) {\n\t\t\t\n\t\t//戦車上方向\n\t\tif( operation == 'U' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '^';\n\t\t\t\n\t\t\tif( i-1 >= 0 ){\n\t\t\t\tif( aryBattleArea[i-1][j] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i-1][j] = '^';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t//戦車下方向\n\t\t}else if( operation == 'D' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = 'v';\n\t\t\t\n\t\t\tif( i+1 < aryBattleArea.length ){\n\t\t\t\tif( aryBattleArea[i+1][j] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i+1][j] = 'v';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//戦車左方向\n\t\t}else if( operation == 'L' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '<';\n\t\t\t\n\t\t\tif( j-1 >= 0 ){\n\t\t\t\tif( aryBattleArea[i][j-1] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i][j-1] = '<';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//戦車右方向\n\t\t}else if( operation == 'R' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '>';\n\t\t\t\n\t\t\tif( j+1 < aryBattleArea[i].length ){\n\t\t\t\tif( aryBattleArea[i][j+1] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i][j+1] = '>';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}else if( operation == 'S' ){\n\t\t\n\t\t\tif(aryBattleArea[i][j] == '^'){\n\t\t\t\t\n\t\t\t\tfor( int x = i ; x >= 0 ; x-- ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[x][j] == '*' ){\n\t\t\t\t\t\taryBattleArea[x][j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == 'v'){\n\t\t\t\t\n\t\t\t\tfor( int x = i ; x < aryBattleArea.length ; x++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[x][j] == '*' ){\n\t\t\t\t\t\taryBattleArea[x][j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == '<'){\n\t\t\t\t\n\t\t\t\tfor( int x = j ; x >= 0 ; x-- ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][x] == '*' ){\n\t\t\t\t\t\taryBattleArea[i][x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == '>'){\n\t\t\t\t\n\t\t\t\tfor( int x = j ; x < aryBattleArea.length ; x++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][x] == '*' ){\n\t\t\t\t\t\taryBattleArea[i][x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\n\t\tsc = new Scanner(System.in);\n\t\ttry {\n\n\t\t\t//???????????°???????????????\n\t\t\tint input = Integer.parseInt(sc.next());\n\t\t\tfor (int i = 0; i < input; i++) {\n\n\t\t\t\t//??????????????????\n\t\t\t\tint depth = sc.nextInt();\n\t\t\t\tint width = sc.nextInt();\n\t\t\t\tString[][] map = new String[depth][width];\n\t\t\t\tString line = \"\";//sc.nextLine();\n\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\t//?????????????????????\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\tString[] list = line.split(\"\");\n\t\t\t\t\t//????????????????´???????\n\t\t\t\t\tfor (int k = 0; k < map[0].length; k++) {\n\t\t\t\t\t\tmap[j][k] = list[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//?????????????????????\n\t\t\t\tint commNum = Integer.parseInt(sc.next());\n\t\t\t\tline = sc.next();\n\t\t\t\tString[] command = line.split(\"\");\n\n\t\t\t\tmap = command(map,command);\n\t\t\t\tfor (String[] gamemap : map) {\n\t\t\t\t\tfor (String cel : gamemap) {\n\t\t\t\t\t\tSystem.out.print(cel);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\n\t\t\t\tif (i != input - 1) {\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n\t//???????????????????????????????????????\n\tpublic static String[][] command(String[][] map, String[] comm) {\n\n\t\tint dep = 0;\n\t\tint wid = 0;\n\t\tString player = \"\";\n\t\tString[][] playmap;\n\t\tString[] command;\n\n\t\tplaymap = map;\n\t\tcommand = comm;\n\n\t\t\t//?????????????????¨???????????????\n\t\tfor (int i = 0; i < playmap.length; i++) {\n\t\t\tif (player.equals(\"\")) {\n\n\t\t\t\tfor (int j = 0; j < playmap[0].length; j++) {\n\t\t\t\t\t//?????????????????§??????\n\t\t\t\t\tif (playmap[i][j].equals(\"^\")) {\n\t\t\t\t\t\tplayer = \"^\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"v\")) {\n\t\t\t\t\t\tplayer = \"v\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\">\")) {\n\t\t\t\t\t\tplayer = \">\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"<\")) {\n\t\t\t\t\t\tplayer = \"<\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//?????????????????????\n\t\tfor (int i = 0; i < command.length; i++) {\n\t\t\t//??????????????§????????????\n\t\t\tswitch (command[i]) {\n\t\t\tcase \"U\":\n\t\t\t\tplaymap[dep][wid] = \"^\";\n\t\t\t\tplayer = \"^\";\n\t\t\t\tif (dep != 0 && playmap[dep - 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep - 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tplaymap[dep][wid] = \"v\";\n\t\t\t\tplayer = \"v\";\n\t\t\t\tif (dep != playmap.length - 1 && playmap[dep + 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep + 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"R\":\n\t\t\t\tplaymap[dep][wid] = \">\";\n\t\t\t\tplayer = \">\";\n\t\t\t\tif (wid != playmap[0].length - 1 && playmap[dep][wid + 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid + 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tplaymap[dep][wid] = \"<\";\n\t\t\t\tplayer = \"<\";\n\t\t\t\tif (wid != 0 && playmap[dep][wid - 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid - 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\t//???????????????????????´???\n\t\t\t\tif (player.equals(\"^\")) {\n\t\t\t\t\tint count = dep;\n\t\t\t\t\tfor (int k = 0; k <= dep; k++) {\n\t\t\t\t\t\tif (playmap[count][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[count][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"v\")) {\n\t\t\t\t\tfor (int k = dep; k < playmap.length; k++) {\n\t\t\t\t\t\tif (playmap[k][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[k][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\">\")) {\n\t\t\t\t\tfor (int k = wid; k < playmap[0].length; k++) {\n\t\t\t\t\t\tif (playmap[dep][k].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][k] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][k].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"<\")) {\n\t\t\t\t\tint count = wid;\n\t\t\t\t\tfor (int k = 0; k <= wid; k++) {\n\t\t\t\t\t\tif (playmap[dep][count].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][count] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][count].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"othercCommand\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn playmap;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§????????????????????????????????????????????°\n\t\tint sysout_cnt = data_set;\n\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??????????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ????????????????????¨?????????????????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('U', '^');\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// ('D', 'v');\n\t\t\t// ('v', { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('L', '<');\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('R', '>');\n\t\t\t// ('>',{ 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\t// ??????????????????????????????\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('v',{ 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('>', { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int t, h, w;\n\tstatic char[][] field;\n\tstatic String order;\n\tstatic int[] dx = {0, 1, 0, -1}, dy = {-1, 0, 1, 0};\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tif(!sc.hasNext())return false;\n\t\tt = sc.nextInt();\n\t\tfor(int i = 0; i < t; i++){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tfield = new char[h][w];\n\t\t\tfor(int j = 0; j < field.length; j++){\n\t\t\t\tfield[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint no_use = sc.nextInt();\n\t\t\torder = sc.next();\n\t\t\tsolve();\n\t\t\tif(i != t-1){\n\t\t\t\tprintField();\n\t\t\t}else{\n\t\t\t\tfor(int k = 0; k < field.length; k++){\n\t\t\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\t\t\tSystem.out.print(field[k][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tint sx = 0, sy = 0;\n\t\tchar tank = '-';\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tif(field[i][j] == '^'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '>'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == '<'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}else if(field[i][j] == 'v'){\n\t\t\t\t\tsx = j; sy = i; tank = field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nx = sx, ny = sy;\n\t\tfor(int i = 0; i < order.length(); i++){\n\t\t\tchar c = order.charAt(i);\n\t\t\tswitch(c){\n\t\t\tcase 'U':\n\t\t\t\ttank = '^';\n\t\t\t\tnx += dx[0]; ny += dy[0];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '^';\n\t\t\t\t\tfield[ny-dy[0]][nx-dx[0]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[0]; ny -= dy[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\ttank = 'v';\n\t\t\t\tnx += dx[2]; ny += dy[2];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = 'v';\n\t\t\t\t\tfield[ny-dy[2]][nx-dx[2]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[2]; ny -= dy[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttank = '<';\n\t\t\t\tnx += dx[3]; ny += dy[3];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '<';\n\t\t\t\t\tfield[ny-dy[3]][nx-dx[3]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[3]; ny -= dy[3];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\ttank = '>';\n\t\t\t\tnx += dx[1]; ny += dy[1];\n\t\t\t\tif(0 <= nx && nx < field[0].length && 0 <= ny && ny < field.length && field[ny][nx] == '.'){\n\t\t\t\t\tfield[ny][nx] = '>';\n\t\t\t\t\tfield[ny-dy[1]][nx-dx[1]] = '.';\n\t\t\t\t}else{\n\t\t\t\t\tnx -= dx[1]; ny -= dy[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tshot(nx, ny, tank);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void printField(){\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic void shot(int x, int y, char t){\n\t\tint vector = 0;\n\t\tswitch(t){\n\t\tcase '^':\n\t\t\tvector = 0; break;\n\t\tcase '>':\n\t\t\tvector = 1; break;\n\t\tcase 'v':\n\t\t\tvector = 2; break;\n\t\tcase '<':\n\t\t\tvector = 3; break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tint nx = x + dx[vector], ny = y + dy[vector];\n\t\twhile(true){\n\t\t\tif(nx < 0 || nx >= field[0].length || ny < 0 || ny >= field.length)break;\n\t\t\tif(field[ny][nx] == '#')break;\n\t\t\tif(field[ny][nx] == '*'){field[ny][nx] = '.'; break;}\n\t\t\tnx += dx[vector]; ny += dy[vector];\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\n//\t\t ???????????????????¨????\n\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t// ??????????????????????????????\n\t\tswitch (tank.getDir()) {\n\t\t// ('^', { -1, 0 });\n\t\tcase '^':\n\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[cnt][shell[1]]== '*') {\n\t\t\t\t\tgame_Map[cnt][shell[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[cnt][shell[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('v',{ 1, 0 });\n\t\tcase 'v':\n\t\t\tfor (int cnt = 1; cnt < game_Map[0].length  - shell[0]; cnt++) {\n\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]]== '*') {\n\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('<', { 0, -1 });\n\t\tcase '<':\n\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\tif (game_Map[shell[0]][cnt]== '*') {\n\t\t\t\t\tgame_Map[shell[0]][cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[shell[0]][cnt] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t// ('>', { 0, 1 });\n\t\tcase '>':\n\t\t\tfor (int cnt = 1; cnt < game_Map[1].length - shell[1]; cnt++) {\n\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt]== '*') {\n\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt] == '#') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n//\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n//\t\tint[] addr = { -1, 1 };\n//\t\twhile (true) {\n//\t\t\tif (tank.getDir() == '^') {\n//\t\t\t\tpos[0] += addr[0];\n//\t\t\t\tif (pos[0] - 1 >= 0) {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t} else if (tank.getDir() == 'v') {\n//\t\t\t\tpos[0] += addr[1];\n//\t\t\t\tif (pos[0] + 1 < game_Map[0].length) {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t} else if (tank.getDir() == '<') {\n//\t\t\t\tpos[1] += addr[0];\n//\t\t\t\tif (pos[1] - 1 >= 0) {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t} else if (tank.getDir() == '>') {\n//\t\t\t\tpos[1] += addr[1];\n//\t\t\t\tif (pos[1] + 1 < game_Map[1].length) {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tswitch (game_Map[pos[0]][pos[1]]) {\n//\t\t\tcase '.':\n//\t\t\tcase '-':\n//\t\t\t\tcontinue;\n//\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n//\t\t\tcase '*':\n//\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n//\t\t\tcase '#':\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t}\n\t}// canon_Shot????????????????????????\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\tint[] addr = { -1, 1 };\n\n\t\tif (tank.getDir() == '^') {\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == 'v') {\n\t\t\tif (move[0] + 1 < game_Map[0].length) {\n\t\t\t\tmove[0] += addr[1];\n\t\t\t}\n\t\t} else if (tank.getDir() == '<') {\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == '>') {\n\t\t\tif (move[1] + 1 < game_Map[1].length) {\n\t\t\t\tmove[1] += addr[1];\n\t\t\t}\n\t\t}\n\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\ttank.setPos(move);\n\t\t}\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int[] dx = {0, 0, -1, 1};\n        int[] dy = {-1, 1, 0, 0};\n        char[] dirc = {'^', 'v', '<', '>'};\n\n        int dataNum = sc.nextInt();\n        while(dataNum-->0){\n            int h = sc.nextInt(), w = sc.nextInt();\n            char[][] map = new char[h][w];\n\n            int x = 0, y = 0, dir = 0;\n            for(int i=0; i<h; i++){\n                char[] line = sc.next().toCharArray();\n                for(int j=0; j<w; j++){\n                    map[i][j] = line[j];\n                    if(map[i][j]=='^'){ x = j; y = i; dir = 0;}\n                    if(map[i][j]=='v'){ x = j; y = i; dir = 1;}\n                    if(map[i][j]=='<'){ x = j; y = i; dir = 2;}\n                    if(map[i][j]=='>'){ x = j; y = i; dir = 3;}\n                }\n            }\n\n            int n = sc.nextInt();\n            char[] command = sc.next().toCharArray();\n            for(int i=0; i<n; i++){\n                if(command[i]=='U') dir = 0;\n                if(command[i]=='D') dir = 1;\n                if(command[i]=='L') dir = 2;\n                if(command[i]=='R') dir = 3;\n                if(command[i]!='S'){\n                    map[y][x] = dirc[dir];\n                    int nx = x + dx[dir], ny = y + dy[dir];\n                    if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                    if(map[ny][nx]=='.'){\n                        map[ny][nx] = dirc[dir];\n                        map[y][x] = '.';\n                        x = nx; y = ny;\n                    }\n                }else{\n                    int nx = x, ny = y;\n                    while(true){\n                        nx += dx[dir]; ny += dy[dir];\n                        if(nx<0 || nx>=w || ny<0 || ny>=h || map[ny][nx]=='#') break;\n                        if(map[ny][nx]=='*'){\n                            map[ny][nx] = '.';\n                            break;\n                        }\n                    }\n                }                \n            }\n            for(int i=0; i<h; i++) System.out.println(String.valueOf(map[i]));\n            if(dataNum!=0) System.out.println();\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\n\t\tsc = new Scanner(System.in);\n\t\ttry {\n\n\t\t\t//???????????°???????????????\n\t\t\tint input = Integer.parseInt(sc.next());\n\t\t\tfor (int i = 0; i < input; i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\n\t\t\t\t//??????????????????\n\t\t\t\tint depth = sc.nextInt();\n\t\t\t\tint width = sc.nextInt();\n\t\t\t\tString[][] map = new String[depth][width];\n\t\t\t\tString line = \"\";//sc.nextLine();\n\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\t//?????????????????????\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\tString[] list = line.split(\"\");\n\t\t\t\t\t//????????????????´???????\n\t\t\t\t\tfor (int k = 0; k < map[0].length; k++) {\n\t\t\t\t\t\tmap[j][k] = list[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//?????????????????????\n\t\t\t\tint commNum = Integer.parseInt(sc.next());\n\t\t\t\tline = sc.next();\n\t\t\t\tString[] command = line.split(\"\");\n\n\t\t\t\tmap = command(map,command);\n\n\t\t\t\t//???????????????\n\t\t\t\tString output = \"\";\n\t\t\t\tfor (String[] gamemap : map) {\n\n\t\t\t\t\tfor (String cel : gamemap) {\n\t\t\t\t\t\toutput += cel;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\toutput = \"\";\n\t\t\t\t}\n\n\t\t\t}\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n\t//???????????????????????????????????????\n\tpublic static String[][] command(String[][] map, String[] comm) {\n\n\t\tint dep = 0;\n\t\tint wid = 0;\n\t\tString player = \"\";\n\t\tString[][] playmap;\n\t\tString[] command;\n\n\t\tplaymap = map;\n\t\tcommand = comm;\n\n\t\t\t//?????????????????¨???????????????\n\t\tfor (int i = 0; i < playmap.length; i++) {\n\t\t\tif (player.equals(\"\")) {\n\n\t\t\t\tfor (int j = 0; j < playmap[0].length; j++) {\n\t\t\t\t\t//?????????????????§??????\n\t\t\t\t\tif (playmap[i][j].equals(\"^\")) {\n\t\t\t\t\t\tplayer = \"^\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"v\")) {\n\t\t\t\t\t\tplayer = \"v\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\">\")) {\n\t\t\t\t\t\tplayer = \">\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"<\")) {\n\t\t\t\t\t\tplayer = \"<\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//?????????????????????\n\t\tfor (int i = 0; i < command.length; i++) {\n\t\t\t//??????????????§????????????\n\t\t\tswitch (command[i]) {\n\t\t\tcase \"U\":\n\t\t\t\tplaymap[dep][wid] = \"^\";\n\t\t\t\tplayer = \"^\";\n\t\t\t\tif (dep != 0 && playmap[dep - 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep - 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tplaymap[dep][wid] = \"v\";\n\t\t\t\tplayer = \"v\";\n\t\t\t\tif (dep != playmap.length - 1 && playmap[dep + 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep + 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"R\":\n\t\t\t\tplaymap[dep][wid] = \">\";\n\t\t\t\tplayer = \">\";\n\t\t\t\tif (wid != playmap[0].length - 1 && playmap[dep][wid + 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid + 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tplaymap[dep][wid] = \"<\";\n\t\t\t\tplayer = \"<\";\n\t\t\t\tif (wid != 0 && playmap[dep][wid - 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid - 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\t//???????????????????????´???\n\t\t\t\tif (player.equals(\"^\")) {\n\t\t\t\t\tint count = dep;\n\t\t\t\t\tfor (int k = 0; k <= dep; k++) {\n\t\t\t\t\t\tif (playmap[count][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[count][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[count][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"v\")) {\n\t\t\t\t\tfor (int k = dep; k < playmap.length; k++) {\n\t\t\t\t\t\tif (playmap[k][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[k][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\">\")) {\n\t\t\t\t\tfor (int k = wid; k < playmap[0].length; k++) {\n\t\t\t\t\t\tif (playmap[dep][k].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][k] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][k].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"<\")) {\n\t\t\t\t\tint count = wid;\n\t\t\t\t\tfor (int k = 0; k <= wid; k++) {\n\t\t\t\t\t\tif (playmap[dep][count].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][count] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][count].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"othercCommand\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn playmap;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力クラス\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// 入力の回数\n\t\tint input_length = 0;\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap map = new map();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank tank = new tank();\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// コマンド入力回数\n\t\t\tint command_number = sc.nextInt();\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\tString command_attack = sc.next();\n\n\t\t\t// ひとつずつ配列に入れる\n\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// 戦車の現在位置を調べる\n\t\t\t\ttank.now_position(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap = tank.shuttGun(tank.getSituation(), map);\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\ttank.move_tank(String.valueOf(command_at[c]), map);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// できたマップリストにを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\tmap_list.get(f).out_map();\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n// 戦車について扱ったクラス\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す\n\tpublic void now_position(String[][] map_all) {\n\t\t// マップ全体を探す\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 自分(戦車)がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 自分(戦車)の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// // 砲弾発射によるマップ変更 現在位置 向き\n\tpublic map shuttGun(String s, map map) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_width; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map.getMap()[0].length - now_width); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_height; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height - i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.getMap().length - now_height); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height + i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic map move_tank(String s, map map) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\t\t\t} else if (map.getMap()[now_height + 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height + 1][now_width] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height - 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height - 1][now_width] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t}\n\t\treturn map;\n\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\n// マップについて扱ったクラス\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\t\tSystem.out.println();\n\t\t\t\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 1行目を取得\n\t\tBufferedReader insBR = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString strNum = insBR.readLine();\n\n\t\t// データセット数\n\t\tint DataSetNum = Integer.parseInt(strNum);\n\n\t\t//データセットの数の分、答えがあるので\n\t\t//答えを保存する為、配列を作成し初期化\n\t\tField[] fieldAnswer = new Field[DataSetNum];\n\n\t\t// 判断する回数まわす\n\t\tfor (int i = 0; i < DataSetNum; i++) {\n\n\t\t\t// 2行目取得\n\t\t\tString strLine2 = insBR.readLine();\n\n\t\t\t// 分解\n\t\t\tString[] strLineAry = strLine2.split(\" \");\n\n\t\t\t// マップの高さ\n\t\t\tint intHeight = Integer.parseInt(strLineAry[0]);\n\n\t\t\t// マップの幅\n\t\t\tint intWidth = Integer.parseInt(strLineAry[1]);\n\n\t\t\t// フィールド情報を引数で渡す配列を作成\n\t\t\tchar[][] charBlock = new char[intHeight][intWidth];\n\n\t\t\t// フィールド情報を1列づつ読み込む\n\t\t\tfor (int j = 0; j < intHeight; j++) {\n\n\t\t\t\tString strBlock = insBR.readLine();\n\n\t\t\t\t// 分解\n\t\t\t\tchar[] chBlock = strBlock.toCharArray();\n\n\t\t\t\t// 格納\n\t\t\t\tfor (int k = 0; k < intWidth; k++) {\n\t\t\t\t\tcharBlock[j][k] = chBlock[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// フィールドを作成\n\t\t\tField field = new Field(charBlock);\n\n\t\t\t// 行動がいくつあるか読み込み\n\t\t\tString strLine3 = insBR.readLine();\n\n\t\t\tint ActionNum = Integer.parseInt(strLine3);\n\n\t\t\t// 行動を読み込み\n\t\t\tString strAction = insBR.readLine();\n\n\t\t\t// 分解\n\t\t\tchar chAction[] = strAction.toCharArray();\n\n\t\t\t// 戦車を作成\n\t\t\tTank tank = new Tank(chAction);\n\n\t\t\ttankAction(field, tank);\n\n\t\t\tfieldAnswer[i] = field;\n\n\t\t}\n\n\t\t//出力\n\t\tfor (int i = 0; i < fieldAnswer.length; i++) {\n\n\t\t\tif(i != 0) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\n\t\t\tfieldAnswer[i].fieldPrint();\n\t\t}\n\n\t}\n\n\t/**\n\t * 入力値通り戦車を動かす\n\t * @param field　フィールドのインスタンス\n\t * @param tank　戦車のインスタンス\n\t */\n\tpublic static void tankAction(Field field, Tank tank) {\n\n\t\t// 戦車の位置を把握\n\t\tint[] intPosion = field.LookPosition();\n\n\t\tint ActionNum = tank.getActionNum();\n\n\t\tfor(int i = 0; i < ActionNum; i++) {\n\t\tchar chAction = tank.getAction(i);\n\n\t\tif (chAction == 'S') {\n\n\t\t\t//ポジションを覚えておく\n\t\t\tint intPosionBeforeHeight = intPosion[0];\n\t\t\tint intPosionBeforeWidth= intPosion[1];\n\n\t\t\t//大砲を撃つ\n\t\t\tfield.actionS(intPosion, 0);\n\n\t\t\t//ポジションを覚えておいた場所に戻す\n\t\t\tintPosion[0] = intPosionBeforeHeight;\n\t\t\tintPosion[1] = intPosionBeforeWidth;\n\n\t\t}else if (chAction == 'U') {\n\n\t\t\tintPosion = field.actionU(intPosion);\n\n\t\t}else if (chAction == 'D') {\n\n\t\t\tintPosion = field.actionD(intPosion);\n\n\t\t}else if (chAction == 'R') {\n\n\t\t\tintPosion = field.actionR(intPosion);\n\n\t\t}else if (chAction == 'L') {\n\n\t\t\tintPosion = field.actionL(intPosion);\n\n\t\t}\n\t\t}\n\n\t}\n\n\tpublic static class Field {\n\n\t\tchar[][] Block;\n\n\t\t// 平地\n\t\tchar chFlatland = '.';\n\n\t\t// レンガの壁\n\t\tchar chBrickWall = '*';\n\n\t\t// 鉄の壁\n\t\tchar chWallIron = '#';\n\n\t\t// 水\n\t\tchar chWater = '-';\n\n\t\t// 戦車（上向き）\n\t\tchar chUpTank = '^';\n\n\t\t// 戦車（下向き）\n\t\tchar chDownTank = 'v';\n\n\t\t// 戦車（右向き）\n\t\tchar chRightTank = '>';\n\n\t\t// 戦車（左向き）\n\t\tchar chLeftTank = '<';\n\n\t\t// 戦車が動く前のフィールドの状態\n\t\tchar chBefore = '.';\n\n\t\tchar[] chTank = { chUpTank, chDownTank, chRightTank, chLeftTank };\n\n\t\tField(char[][] Block) {\n\n\t\t\tthis.Block = Block;\n\n\t\t}\n\n\t\t// //戦車の位置\n\t\tint[] LookPosition() {\n\n\t\t\tint[] intPosition = new int[2];\n\n\t\t\tfor (int i = 0; i < Block.length; i++) {\n\t\t\t\tfor (int j = 0; j < Block[0].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < chTank.length; k++) {\n\t\t\t\t\t\tif (chTank[k] == Block[i][j]) {\n\n\t\t\t\t\t\t\tintPosition[0] = i;\n\t\t\t\t\t\t\tintPosition[1] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn intPosition;\n\t\t}\n\n\t\t/**\n\t\t * 行動S　大砲を撃つ\n\t\t * '.'平地なら通り過ぎる\n\t\t * '*'レンガの壁なら、壊れて'.'平地になる\n\t\t * '#'鉄の壁なら大砲が消える\n\t\t * '-'水なら通り過ぎる\n\t\t * ポジションが通り過ぎたり、フィールド値が変更になったりする\n\t\t * @param intPosion int[]型でint[0]に上下位置(下へいくとプラス、上へ行くとマイナス)\n\t\t * int[1]に左右位置(右へいくとプラス、左へ行くとマイナス)が入っている\n\t\t * @param intDirection 0は向き不明 1は戦車上向き 2は戦車下向き 3は戦車右向き 4は戦車左向き\n\t\t */\n\t\tvoid actionS(int[] intPosion, int intDirection) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intHeight < 0 ||\n\t\t\t\t\tBlock.length <= intHeight ||\n\t\t\t\t\tintWidth < 0 ||\n\t\t\t\t\tBlock[0].length <= intWidth) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//まず戦車の向きを調べる\n\t\t\t//intDirectionは最初0で来る\n\t\t\t//intDirectionが0の時の動きになる\n\n\t\t\t//戦車が上向きなら\n\t\t\tif(Block[intHeight][intWidth] == '^') {\n\n\t\t\t\t//ポジションを上に移動\n\t\t\t\t//intDirectionが1\n\t\t\t\t//回帰する\n\t\t\t\tgoUpPosion(intPosion,1);\n\t\t\t\treturn;\n\n\t\t\t}else if(Block[intHeight][intWidth] == 'v') {\n\n\t\t\t\t//ポジションを下に移動\n\t\t\t\t//intDirectionが2\n\t\t\t\t//回帰する\n\t\t\t\tgoDowmPosion(intPosion,2);\n\t\t\t\treturn;\n\n\t\t\t}else if(Block[intHeight][intWidth] == '>') {\n\n\t\t\t\t//ポジションを右に移動\n\t\t\t\t//intDirectionが3\n\t\t\t\t//回帰する\n\t\t\t\tgoRightPosion(intPosion,3);\n\t\t\t\treturn;\n\n\t\t\t}else if(Block[intHeight][intWidth] == '<') {\n\n\t\t\t\t//ポジションを左に移動\n\t\t\t\t//intDirectionが4\n\t\t\t\t//回帰する\n\t\t\t\tgoLeftPosion(intPosion,4);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//フィールド値によって行動\n\t\t\t//回帰で戻ってきたらココへ来る\n\t\t\t//intDirectionが1〜4の時の動きになる\n\n\t\t\t//平地と水の時\n\t\t\tif(Block[intHeight][intWidth] == '.' || Block[intHeight][intWidth] == '-') {\n\n\t\t\t\tswitch(intDirection) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\t//ポジションを上に移動\n\t\t\t\t\tgoUpPosion(intPosion,1);\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\t//ポジションを下に移動\n\t\t\t\t\tgoDowmPosion(intPosion,2);\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 3:\n\n\t\t\t\t\t//ポジションを右に移動\n\t\t\t\t\tgoRightPosion(intPosion,3);\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 4:\n\n\t\t\t\t\t//ポジションを左に移動\n\t\t\t\t\tgoLeftPosion(intPosion,4);\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\t\t\t}else if(Block[intHeight][intWidth] == '*') {\n\n\t\t\t\tBlock[intHeight][intWidth] = '.';\n\n\t\t\t}else if(Block[intHeight][intWidth] == '#') {\n\n\t\t\t\t//何もなし\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * 行動U　戦車が上に行ければ移動\n\t\t * @param intPosion\n\t\t */\n\t\tint[] actionU(int[] intPosion) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//ポジションを上に移動\n\t\t\tintHeight--;\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intHeight < 0 || Block.length <= intHeight) {\n\n\t\t\t\tBlock[intHeight + 1][intWidth] = '^';\n\n\t\t\t\treturn intPosion;\n\t\t\t}\n\n\t\t\tif(Block[intHeight][intWidth] == '.') {\n\n\t\t\t\t//上に移動した後は戦車があった場所にフィールド値を与える\n\t\t\t\tBlock[intHeight + 1][intWidth] = chBefore;\n\n\t\t\t\tBlock[intHeight][intWidth] = '^';\n\n\t\t\t\tintPosion[0]--;\n\n\t\t\t} else {\n\t\t\t\tBlock[intHeight + 1][intWidth] = '^';\n\t\t\t}\n\n\t\t\treturn intPosion;\n\n\t\t}\n\n\t\t/**\n\t\t * 行動D　戦車が下に行ければ移動\n\t\t * @param intPosion\n\t\t */\n\t\tint[] actionD(int[] intPosion) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//ポジションを下に移動\n\t\t\tintHeight++;\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intHeight < 0 || Block.length <= intHeight ) {\n\n\t\t\t\tBlock[intHeight - 1][intWidth] = 'v';\n\t\t\t\treturn intPosion;\n\t\t\t}\n\n\t\t\tif(Block[intHeight][intWidth] == '.') {\n\n\t\t\t\t//上に移動した後は戦車があった場所にフィールド値を与える\n\t\t\t\tBlock[intHeight - 1][intWidth] = chBefore;\n\n\t\t\t\tBlock[intHeight][intWidth] = 'v';\n\n\t\t\t\tintPosion[0]++;\n\n\t\t\t} else {\n\t\t\t\tBlock[intHeight - 1][intWidth] = 'v';\n\t\t\t}\n\n\t\t\treturn intPosion;\n\n\t\t}\n\n\t\t/**\n\t\t * 行動R　戦車が右に行ければ移動\n\t\t * @param intPosion\n\t\t */\n\t\tint[] actionR(int[] intPosion) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//ポジションを右に移動\n\t\t\tintWidth++;\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intWidth < 0 || Block[0].length <= intWidth) {\n\n\t\t\t\tBlock[intHeight][intWidth - 1] = '>';\n\t\t\t\treturn intPosion;\n\t\t\t}\n\n\t\t\tif(Block[intHeight][intWidth] == '.') {\n\n\t\t\t\t//右に移動した後は戦車があった場所にフィールド値を与える\n\t\t\t\tBlock[intHeight][intWidth - 1] = chBefore;\n\n\t\t\t\tBlock[intHeight][intWidth] = '>';\n\n\t\t\t\tintPosion[1]++;\n\n\t\t\t} else {\n\t\t\t\tBlock[intHeight][intWidth - 1] = '>';\n\t\t\t}\n\n\t\t\treturn intPosion;\n\t\t}\n\n\t\t/**\n\t\t * 行動L　戦車が左に行ければ移動\n\t\t * @param intPosion\n\t\t */\n\t\tint[] actionL(int[] intPosion) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//ポジションを左に移動\n\t\t\tintWidth--;\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intWidth < 0 || Block[0].length <= intWidth) {\n\n\t\t\t\tBlock[intHeight][intWidth + 1] = '<';\n\t\t\t\treturn intPosion;\n\t\t\t}\n\n\t\t\tif(Block[intHeight][intWidth] == '.') {\n\n\t\t\t\t//左に移動した後は戦車があった場所にフィールド値を与える\n\t\t\t\tBlock[intHeight][intWidth + 1] = chBefore;\n\n\t\t\t\tBlock[intHeight][intWidth] = '<';\n\n\t\t\t\tintPosion[1]--;\n\n\t\t\t} else {\n\t\t\t\tBlock[intHeight][intWidth + 1] = '<';\n\t\t\t}\n\n\t\t\treturn intPosion;\n\t\t}\n\n\t\t/**\n\t\t * ポジションを１つ上に移動\n\t\t * @param intPosion\n\t\t * @param intDirection\n\t\t */\n\t\tvoid goUpPosion(int[] intPosion, int intDirection) {\n\n\t\t\t//上のブロックを参照するので\n\t\t\t//ポジションを1個上へ変更\n\t\t\tintPosion[0]--;\n\n\t\t\t//回帰処理\n\t\t\tactionS(intPosion, intDirection);\n\t\t}\n\n\t\t/**\n\t\t * ポジションを１つ下に移動\n\t\t * @param intPosion\n\t\t * @param intDirection\n\t\t */\n\t\tvoid goDowmPosion(int[] intPosion, int intDirection) {\n\n\t\t\t//上のブロックを参照するので\n\t\t\t//ポジションを1個上へ変更\n\t\t\tintPosion[0]++;\n\n\t\t\t//回帰処理\n\t\t\tactionS(intPosion, intDirection);\n\t\t}\n\n\t\t/**\n\t\t * ポジションを１つ右に移動\n\t\t * @param intPosion\n\t\t * @param intDirection\n\t\t */\n\t\tvoid goRightPosion(int[] intPosion, int intDirection) {\n\n\t\t\t//上のブロックを参照するので\n\t\t\t//ポジションを1個上へ変更\n\t\t\tintPosion[1]++;\n\n\t\t\t//回帰処理\n\t\t\tactionS(intPosion, intDirection);\n\t\t}\n\n\t\t/**\n\t\t * ポジションを１つ左に移動\n\t\t * @param intPosion\n\t\t * @param intDirection\n\t\t */\n\t\tvoid goLeftPosion(int[] intPosion, int intDirection) {\n\n\t\t\t//上のブロックを参照するので\n\t\t\t//ポジションを1個上へ変更\n\t\t\tintPosion[1]--;\n\n\t\t\t//回帰処理\n\t\t\tactionS(intPosion, intDirection);\n\t\t}\n\n\t\tvoid fieldPrint() {\n\n\t\t\tfor (int i = 0; i < Block.length; i++) {\n\t\t\t\tfor (int j = 0; j < Block[0].length; j++) {\n\t\t\t\t\tSystem.out.print(Block[i][j]);\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static class Tank {\n\n\t\tchar[] chAction;\n\n\t\tTank(char[] chAction) {\n\n\t\t\tthis.chAction = chAction;\n\t\t}\n\n\t\t// 行動を提供\n\t\tchar getAction(int ActionNum) {\n\n\t\t\treturn chAction[ActionNum];\n\n\t\t}\n\n\t\tint getActionNum() {\n\t\t\treturn chAction.length;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\n// AOJ 2103\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W, N;\n\tstatic char[][] cs = new char[22][22];\n\tstatic int[] dx = {0, 1, 0, -1}, dy = {-1, 0, 1, 0};\n\tpublic static void main(String[] args) {\n\t\tint TC = sc.nextInt();\n\t\tfor (int tc = 0; tc < TC; tc++) {\n\t\t\tif (tc != 0) System.out.println();\n\t\t\tH = sc.nextInt(); W = sc.nextInt();\n\t\t\tint x = 0, y = 0, d = 0;\n\t\t\tfor (int i = 0; i < 22; i++) fill(cs[i], '#');\n\t\t\tfor (int i = 1; i <= H; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\t\tchar c = s.charAt(j - 1);\n\t\t\t\t\tcs[i][j] = c;\n\t\t\t\t\tif (c == '<' || c == '^' || c == 'v' || c == '>') { \n\t\t\t\t\t\tx = j; y = i;\n\t\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\tcase '^':\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '>':\n\t\t\t\t\t\t\td = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\td = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '<' :\n\t\t\t\t\t\t\td = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tN = sc.nextInt();\n\t\t\tString op = sc.next();\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tchar c = op.charAt(i);\n\t\t\t\tif (c == 'S') {\n\t\t\t\t\tint nx = x, ny = y;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tnx += dx[d];\n\t\t\t\t\t\tny += dy[d];\n\t\t\t\t\t\tchar cc = cs[ny][nx]; \n\t\t\t\t\t\tif (cc == '#') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (cc == '*') {\n\t\t\t\t\t\t\tcs[ny][nx] = '.';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\td = 0;\n\t\t\t\t\t\tcs[y][x] = '^';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\td = 1;\n\t\t\t\t\t\tcs[y][x] = '>';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\t\td = 2;\n\t\t\t\t\t\tcs[y][x] = 'v';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\td = 3;\n\t\t\t\t\t\tcs[y][x] = '<';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\t\tif (cs[ny][nx] == '.') {\n\t\t\t\t\t\tcs[ny][nx] = cs[y][x];\n\t\t\t\t\t\tcs[y][x] = '.';\n\t\t\t\t\t\tx = nx; \n\t\t\t\t\t\ty = ny;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i <= H; i++) {\n\t\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\t\tSystem.out.print(cs[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\t//???????????????????????°??????\n\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\t\t\t//?????£??????????????§??????????????????????´?\n\t\t\tint[] aryArea = {intHeight,intWidth};\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tString[] fieldLine = new String[intWidth];\n\t\t\t\tfieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond,aryArea);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\n\t\t\t//?????£??????????????????\n\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(deta != setNum-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£??????????????§???????????????????????????*/\n\t\tprivate int[] aryArea;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond ,int[] aryArea){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.aryArea = aryArea;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????£????????????????????¨???????????£??\\\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\t\t\t\t//System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\t\t\t\t//System.out.println(\"tank:\" + j + i);\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\t\t\t//?????£??????????????§??????\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.math.*;\nimport java.awt.geom.*;\nimport java.io.*;\n      \n      \npublic class Main {\t\n\tstatic char[] tank = new char[] {'^','>','v','<'};\n\tstatic int[] vx = new int[] {0,1,0,-1};\n\tstatic int[] vy = new int[] {-1,0,1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(int TIME = 0; TIME < t; TIME++) {\n\t\t\tif(TIME != 0) \t\t\tSystem.out.println();\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tchar[] cmd = new char[n];\n\t\t\tcmd = sc.next().toCharArray();\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tint d = 0;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(map[i][j] == '^') {\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\td = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == '>') {\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\td = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == 'v') {\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\td = 2;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j] == '<') {\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\td = 3;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tchar CMD = cmd[i];\n\t\t\t\tif(CMD == 'U') {\n\t\t\t\t\tdChange(map,y,x,0);\n\t\t\t\t\td = 0;\n\t\t\t\t\tboolean check = rangeCheck(map,y-1,x);\n\t\t\t\t\tboolean change = false;\n\t\t\t\t\tif(check) change = move(map,y,x,0);\n\t\t\t\t\tif(change) {\n\t\t\t\t\t\ty = y + vy[d];\n\t\t\t\t\t\tx = x + vx[d]; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(CMD == 'D') {\n\t\t\t\t\tdChange(map,y,x,2);\n\t\t\t\t\td = 2;\n\t\t\t\t\tboolean check = rangeCheck(map,y+1,x);\n\t\t\t\t\tboolean change = false;\n\t\t\t\t\tif(check) change = move(map,y,x,2);\n\t\t\t\t\tif(change) {\n\t\t\t\t\t\ty = y + vy[d];\n\t\t\t\t\t\tx = x + vx[d]; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(CMD == 'R') {\n\t\t\t\t\tdChange(map,y,x,1);\n\t\t\t\t\td = 1;\n\t\t\t\t\tboolean check = rangeCheck(map,y,x+1);\n\t\t\t\t\tboolean change = false;\n\t\t\t\t\tif(check) change = move(map,y,x,1);\n\t\t\t\t\tif(change) {\n\t\t\t\t\t\ty = y + vy[d];\n\t\t\t\t\t\tx = x + vx[d]; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(CMD == 'L') {\n\t\t\t\t\tdChange(map,y,x,3);\n\t\t\t\t\td = 3;\n\t\t\t\t\tboolean check = rangeCheck(map,y,x-1);\n\t\t\t\t\tboolean change = false;\n\t\t\t\t\tif(check) change = move(map,y,x,3);\n\t\t\t\t\tif(change) {\n\t\t\t\t\t\ty = y + vy[d];\n\t\t\t\t\t\tx = x + vx[d]; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(CMD == 'S') {\n\t\t\t\t\tshot(map,y,x,d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tSystem.out.println(String.valueOf(map[i]));\n\t\t\t}\n\t\t}\n\t}\n\tstatic void dChange(char[][] map, int y, int x, int d) {\n\t\tmap[y][x] = tank[d];\n\t}\n\tstatic boolean rangeCheck(char[][] map, int y, int x) {\n\t\tif(y < 0 || x < 0 || y >= map.length || x >= map[y].length) return false;\n\t\treturn true;\n\t}\n\tstatic boolean move(char[][] map ,int y, int x, int d) {\n\t\tint ty = y + vy[d];\n\t\tint tx = x + vx[d];\n\t\tif(map[ty][tx] == '.') {\n\t\t\tmap[y][x] = '.';\n\t\t\tmap[ty][tx] = tank[d];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tstatic void shot(char[][] map, int y, int x, int d) {\n\t\tint Y = y + vy[d];\n\t\tint X = x + vx[d];\n\t\twhile(true) {\n\t\t\tif(!rangeCheck(map,Y,X)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(map[Y][X] == '*') {\n\t\t\t\tmap[Y][X] = '.';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(map[Y][X] == '#') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tY = Y + vy[d];\n\t\t\tX = X + vx[d];\n\t\t}\n\t}\n\t\n }"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t// マップ\n\n\t// 戦車\n\tclass Tank {\n\n\t\tchar[][] map;\n\n\t\tint x, y; \t  // 座標\n\t\tchar dir; \t  // 向いてる方角\n\n\t\tint bx=-1, by=-1;   // 砲弾の座標\n\n\t\tpublic Tank(int x, int y,  int dir, char[][] map) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.map = map;\n\t\t\tif(dir == 0) this.dir = 'L';\n\t\t\telse if(dir == 1) this.dir = 'U';\n\t\t\telse if(dir == 2) this.dir = 'R';\n\t\t\telse if(dir == 3) this.dir = 'D';\n\t\t}\n\n\t\t// 命令\n\t\t// rの取りうる値: UDLR\n\t\tpublic void order(char r) {\n\n\t\t\t// 回転し、進めるのであれば進む\n\t\t\tif(r == 'U') {\n\t\t\t\tdir = 'U';\n\t\t\t\tmap[y][x] = '^';\n\t\t\t\tif(isMovable(x, y-1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty -= 1;\n\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = '^';\n\t\t\t\t} else {\n\t\t\t\t\t// 方向転換だけ行う\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'D') {\n\t\t\t\tdir = 'D';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t\tif(isMovable(x, y+1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty += 1;\n\t\t\t\t\t//\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = 'v';\n\t\t\t\t}\n\t\t\t} else if(r == 'L') {\n\t\t\t\tdir = 'L';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t\tif(isMovable(x-1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx -= 1;\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'R') {\n\t\t\t\tdir = 'R';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t\tif(isMovable(x+1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx += 1;\n\t\t\t\t\tmap[y][x] = '>';\n\t\t\t\t}\n\t\t\t} else if(r == 'S') {\n\t\t\t\tshot(dir);\n\t\t\t}\n\n\t\t}\n\n\t\t// 砲撃\n\t\tpublic void shot(char dir) {\n\n\t\t\t// 砲弾の位置初期化\n\t\t\tbx = x;\n\t\t\tby = y;\n\n\t\t\t// 方向を設定し発射\n\t\t\tmoveBullet(dir);\n\n\t\t}\n\n\t\t// 砲弾の移動\n\t\tpublic void moveBullet(char dir) {\n\n\t\t\t// 移動先座標\n\t\t\tint toX = -1;\n\t\t\tint toY = -1;\n\t\t\tif(dir == 'L') {\n\t\t\t\ttoX = bx-1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx -= 1;\n\t\t\t} else if(dir == 'U') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by-1;\n\t\t\t\tby -= 1;\n\t\t\t} else if(dir == 'R') {\n\t\t\t\ttoX = bx+1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx += 1;\n\t\t\t} else if(dir == 'D') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by+1;\n\t\t\t\tby += 1;\n\t\t\t}\n\n\t\t\t// 指定座標に移動できれば破壊し移動する\n\t\t\tif(map[toY][toX] == '*') {\n\t\t\t\t// 破壊\n\t\t\t\tmap[toY][toX] = '.';\n\t\t\t\treturn;\n\t\t\t} else if(map[toY][toX] == '#') {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmoveBullet(dir);\n\t\t\t}\n\t\t}\n\n\t\t// 指定の座標に戦車が進めるか\n\t\tpublic boolean isMovable(int x, int y) {\n\n\t\t\tif(map[y][x] == '.') return true;\n\t\t\telse return false;\n\n\t\t}\n\n\t\t// マップを表示\n\t\tpublic void drawMap() {\n\t\t\tfor(int i=1; i<map.length-1; i++) {\n\t\t\t\tfor(int j=1; j<map[i].length-1; j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップから戦車の位置と向きを取得する\n\t// @return int[] [0]戦車のx座標, [1]戦車のy座標, [2]戦車の向き(左から時計回りに0~3)\n\tpublic int[] getTankDir(char[][] map) {\n\n\t\tint[] ret = new int[3];\n\t\tfor(int i=0; i<map.length; i++) {\n\t\t\tfor(int j=0; j<map[i].length; j++){\n\t\t\t\tif(map[i][j] == '<') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 0;\n\t\t\t\t} else if(map[i][j] == '^') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 1;\n\t\t\t\t} else if(map[i][j] == '>') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 2;\n\t\t\t\t} else if(map[i][j] == 'v') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// マップセットの個数入力\n\t\tint num = sc.nextInt();\n\n\t\tfor(int n=0; n<num; n++) {\n\n\t\t\t// 地図データの入力\n\t\t\tint y = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\n\t\t\tchar[][] map = new char[y+2][x+2];\n\n\t\t\t// 外を埋める\n\t\t\tfor(int i=0; i<y+2; i++) {\n\t\t\t\tfor(int j=0; j<x+2; j++) {\n\t\t\t\t\tif(i == 0 || i == y+1 || j == 0 || j == x+1) map[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t\t\tmap[i][j] = line.toCharArray()[j-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 命令を入力\n\t\t\tint orderNum = sc.nextInt();\n\t\t\tString orders = sc.next();\n\t\t\tchar[] orderArr = orders.toCharArray();\n\n\t\t\tMain b = new Main();\n\n\t\t\t// 戦車の初期位置と向きを取得\n\t\t\tint[] tankPos = b.getTankDir(map);\n\n\n\t\t\t// 戦車を生成\n\t\t\tTank t = new Main().new Tank(tankPos[0], tankPos[1], tankPos[2], map);\n\n\t\t\t// 命令を実行\n\t\t\tfor(int i=0; i<orderNum; i++) {\n\t\t\t\tt.order(orderArr[i]);\n\t\t\t}\n\n\n\t\t\t// debug\n\t\t\t// 戦車の移動テスト\n\t\t\t//\t\tt.rotate('L');\n\n\t\t\t// マップを再表示\n\t\t\tt.drawMap();\n\t\t\tif(n != num-1) System.out.println(\"\");\n\n\t\t}\n\n\t\tsc.close();\n\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\t\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\t\t\t// ??????4 6 ???????????¢??????????????°???????????¢??????????´?????????????????????°\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\t// ???????????????\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], 'W');\n\t\t\t}\n\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw + 1]) > -1) {\n\t\t\t\t\t\t//????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map, game_Map[mh][mw + 1], new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\ttank.command(cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\ttank.last_tankLocate();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n}// ???????????????????????????????????????\n\nclass Tank {\n\n\t/**\n\t * ?????????\n\t */\n\tprivate char[][] map;\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/*\n\t * ????????????????????????\n\t */\n\tTank(char[][] map_info, char tank_dir, int[] tank_pos) {\n\t\tthis.dir = tank_dir;\n\t\tthis.map = map_info;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/*\n\t * ?§??????????\n\t */\n\tHashMap<Character, Character> move_Cmd = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t/*\n\t * ?§??????¢???\n\t */\n\tHashMap<Character, int[]> move_Dir = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ???????????????????????°????????????\n\tvoid command(char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\tmove_tank(cmd);\n\t\t} else {\n\t\t\tcannon_Shot();\n\t\t}\n\t}\n\n\t/**\n\t * <pre>\n\t * ?????????????????????\n\t * ????????¬?????¬????£??????¶????????£???????????°?????????\n\t * ?????????????£??????°?????????\n\t * ????????°??????????????¨??§?????£????????????????¶????\n\t * </pre>\n\t *\n\t * @param shell\n\t *            ??????\n\t */\n\tprivate void cannon_Shot() {\n\t\t//???????????????????¨????\n\t\tint[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\twhile (true) {\n\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\tcase '.':\n\t\t\tcase '-':\n\t\t\t\tcontinue;\n\t\t\t\t//??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\tcase '*':\n\t\t\t\tmap[shell[0]][shell[1]] = '.';\n\t\t\tcase '#':\n\t\t\t\t//??????????£???¨??¶????????£????????????????¶????\n\t\t\tcase 'W':\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}// cannon_Shoot????????????????????????\n\n\t/**\n\t * <pre>\n\t *?????????????§????\n\t *\n\t *???????????°???????§??????????\n\t *???????????¬??????????????????????????£????§???????????????¨?????????\n\t * </pre>\n\t *\n\t * @param cmd\n\t *            ?????¬??????????????????\n\t * @param move\n\t *            ??????????§????\n\t */\n\tprivate void move_tank(char cmd) {\n\n\t\tthis.dir = move_Cmd.get(cmd);\n\t\tint[] next = new int[] { this.pos[0], this.pos[1] };\n\t\tnext[0] += move_Dir.get(this.dir)[0];\n\t\tnext[1] += move_Dir.get(this.dir)[1];\n\t\tif (map[next[0]][next[1]] == '.') {\n\t\t\tthis.pos[0] = next[0];\n\t\t\tthis.pos[1] = next[1];\n\t\t}\n\t}// move_tank????????????????????????\n\n\tvoid last_tankLocate() {\n\t\t// ?????????????????¨??°?????°????????¨?¨???????\n\t\tmap[this.pos[0]][this.pos[1]] = this.dir;\n\t}\n\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t// 戦車\n\tclass Tank {\n\n\t\tchar[][] map;\n\n\t\tint x, y; \t  // 座標\n\t\tchar dir; \t  // 向いてる方角\n\n\t\tint bx=-1, by=-1;   // 砲弾の座標\n\n\t\tpublic Tank(int x, int y,  int dir, char[][] map) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.map = map;\n\t\t\tif(dir == 0) this.dir = 'L';\n\t\t\telse if(dir == 1) this.dir = 'U';\n\t\t\telse if(dir == 2) this.dir = 'R';\n\t\t\telse if(dir == 3) this.dir = 'D';\n\t\t}\n\n\t\t// 命令\n\t\tpublic void order(char r) {\n\n\t\t\t// 回転し、進めるのであれば進む\n\t\t\tif(r == 'U') {\n\t\t\t\tdir = 'U';\n\t\t\t\tmap[y][x] = '^';\n\t\t\t\tif(isMovable(x, y-1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty -= 1;\n\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = '^';\n\t\t\t\t}\n\t\t\t} else if(r == 'D') {\n\t\t\t\tdir = 'D';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t\tif(isMovable(x, y+1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty += 1;\n\t\t\t\t\t//\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = 'v';\n\t\t\t\t}\n\t\t\t} else if(r == 'L') {\n\t\t\t\tdir = 'L';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t\tif(isMovable(x-1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx -= 1;\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'R') {\n\t\t\t\tdir = 'R';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t\tif(isMovable(x+1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx += 1;\n\t\t\t\t\tmap[y][x] = '>';\n\t\t\t\t}\n\t\t\t} else if(r == 'S') {\n\t\t\t\tshot(dir);\n\t\t\t}\n\n\t\t}\n\n\t\t// 砲撃\n\t\tpublic void shot(char dir) {\n\n\t\t\t// 砲弾の位置初期化\n\t\t\tbx = x;\n\t\t\tby = y;\n\n\t\t\t// 方向を設定し発射\n\t\t\tmoveBullet(dir);\n\n\t\t}\n\n\t\t// 砲弾の移動\n\t\tpublic void moveBullet(char dir) {\n\n\t\t\t// 移動先座標\n\t\t\tint toX = -1;\n\t\t\tint toY = -1;\n\t\t\tif(dir == 'L') {\n\t\t\t\ttoX = bx-1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx -= 1;\n\t\t\t} else if(dir == 'U') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by-1;\n\t\t\t\tby -= 1;\n\t\t\t} else if(dir == 'R') {\n\t\t\t\ttoX = bx+1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx += 1;\n\t\t\t} else if(dir == 'D') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by+1;\n\t\t\t\tby += 1;\n\t\t\t}\n\n\t\t\t// 指定座標に移動できれば破壊し移動する\n\t\t\tif(map[toY][toX] == '*') {\n\t\t\t\t// 破壊\n\t\t\t\tmap[toY][toX] = '.';\n\t\t\t\treturn;\n\t\t\t} else if(map[toY][toX] == '#') {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmoveBullet(dir);\n\t\t\t}\n\t\t}\n\n\t\t// 指定の座標に戦車が進めるか\n\t\tpublic boolean isMovable(int x, int y) {\n\n\t\t\tif(map[y][x] == '.') return true;\n\t\t\telse return false;\n\n\t\t}\n\n\t\t// マップを表示\n\t\tpublic void drawMap() {\n\n\t\t\tfor(int i=1; i<map.length-1; i++) {\n\t\t\t\tfor(int j=1; j<map[i].length-1; j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// マップから戦車の位置と向きを取得する\n\t// @return int[] [0]戦車のx座標, [1]戦車のy座標, [2]戦車の向き(左から時計回りに0~3)\n\tpublic int[] getTankDir(char[][] map) {\n\n\t\tint[] ret = new int[3];\n\t\tfor(int i=0; i<map.length; i++) {\n\t\t\tfor(int j=0; j<map[i].length; j++){\n\t\t\t\tif(map[i][j] == '<') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 0;\n\t\t\t\t} else if(map[i][j] == '^') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 1;\n\t\t\t\t} else if(map[i][j] == '>') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 2;\n\t\t\t\t} else if(map[i][j] == 'v') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// マップセットの個数入力\n\t\tint num = sc.nextInt();\n\n\t\tfor(int n=0; n<num; n++) {\n\n\t\t\t// 地図データの入力\n\t\t\tint y = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\n\t\t\tchar[][] map = new char[y+2][x+2];\n\n\t\t\t// 外を埋める\n\t\t\tfor(int i=0; i<y+2; i++) {\n\t\t\t\tfor(int j=0; j<x+2; j++) {\n\t\t\t\t\tif(i == 0 || i == y+1 || j == 0 || j == x+1) map[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t\t\tmap[i][j] = line.toCharArray()[j-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 命令を入力\n\t\t\tint orderNum = sc.nextInt();\n\t\t\tString orders = sc.next();\n\t\t\tchar[] orderArr = orders.toCharArray();\n\n\t\t\tMain b = new Main();\n\n\t\t\t// 戦車の初期位置と向きを取得\n\t\t\tint[] tankPos = b.getTankDir(map);\n\n\n\t\t\t// 戦車を生成\n\t\t\tTank t = new Main().new Tank(tankPos[0], tankPos[1], tankPos[2], map);\n\n\t\t\t// 命令を実行\n\t\t\tfor(int i=0; i<orderNum; i++) {\n\t\t\t\tt.order(orderArr[i]);\n\t\t\t}\n\n\t\t\t// マップを再表示\n\t\t\tt.drawMap();\n\t\t\tif(n != num-1) System.out.println(\"\");\n\n\t\t}\n\n\t\tsc.close();\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t// マップ\n\n\t// 戦車\n\tclass Tank {\n\n\t\tchar[][] map;\n\n\t\tint x, y; \t  // 座標\n\t\tchar dir; \t  // 向いてる方角\n\n\t\tint bx=-1, by=-1;   // 砲弾の座標\n\n\t\tpublic Tank(int x, int y,  int dir, char[][] map) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.map = map;\n\t\t\tif(dir == 0) this.dir = 'L';\n\t\t\telse if(dir == 1) this.dir = 'U';\n\t\t\telse if(dir == 2) this.dir = 'R';\n\t\t\telse if(dir == 3) this.dir = 'D';\n\t\t}\n\n\t\t// 命令\n\t\t// rの取りうる値: UDLR\n\t\tpublic void order(char r) {\n\n\t\t\t// 回転し、進めるのであれば進む\n\t\t\tif(r == 'U') {\n\t\t\t\tdir = 'U';\n\t\t\t\tmap[y][x] = '^';\n\t\t\t\tif(isMovable(x, y-1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty -= 1;\n\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = '^';\n\t\t\t\t} else {\n\t\t\t\t\t// 方向転換だけ行う\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'D') {\n\t\t\t\tdir = 'D';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t\tif(isMovable(x, y+1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty += 1;\n\t\t\t\t\t//\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = 'v';\n\t\t\t\t}\n\t\t\t} else if(r == 'L') {\n\t\t\t\tdir = 'L';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t\tif(isMovable(x-1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx -= 1;\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'R') {\n\t\t\t\tdir = 'R';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t\tif(isMovable(x+1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx += 1;\n\t\t\t\t\tmap[y][x] = '>';\n\t\t\t\t}\n\t\t\t} else if(r == 'S') {\n\t\t\t\tshot(dir);\n\t\t\t}\n\n\t\t}\n\n\t\t// 砲撃\n\t\tpublic void shot(char dir) {\n\n\t\t\t// 砲弾の位置初期化\n\t\t\tbx = x;\n\t\t\tby = y;\n\n\t\t\t// 方向を設定し発射\n\t\t\tmoveBullet(dir);\n\n\t\t}\n\n\t\t// 砲弾の移動\n\t\tpublic void moveBullet(char dir) {\n\n\t\t\t// 移動先座標\n\t\t\tint toX = -1;\n\t\t\tint toY = -1;\n\t\t\tif(dir == 'L') {\n\t\t\t\ttoX = bx-1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx -= 1;\n\t\t\t} else if(dir == 'U') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by-1;\n\t\t\t\tby -= 1;\n\t\t\t} else if(dir == 'R') {\n\t\t\t\ttoX = bx+1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx += 1;\n\t\t\t} else if(dir == 'D') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by+1;\n\t\t\t\tby += 1;\n\t\t\t}\n\n\t\t\t// 指定座標に移動できれば破壊し移動する\n\t\t\tif(map[toY][toX] == '*') {\n\t\t\t\t// 破壊\n\t\t\t\tmap[toY][toX] = '.';\n\t\t\t\treturn;\n\t\t\t} else if(map[toY][toX] == '#') {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmoveBullet(dir);\n\t\t\t}\n\t\t}\n\n\t\t// 指定の座標に戦車が進めるか\n\t\tpublic boolean isMovable(int x, int y) {\n\n\t\t\tif(map[y][x] == '.') return true;\n\t\t\telse return false;\n\n\t\t}\n\n\t\t// マップを表示\n\t\tpublic void drawMap() {\n\t\t\tfor(int i=1; i<map.length-1; i++) {\n\t\t\t\tfor(int j=1; j<map[i].length-1; j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップから戦車の位置と向きを取得する\n\t// @return int[] [0]戦車のx座標, [1]戦車のy座標, [2]戦車の向き(左から時計回りに0~3)\n\tpublic int[] getTankDir(char[][] map) {\n\n\t\tint[] ret = new int[3];\n\t\tfor(int i=0; i<map.length; i++) {\n\t\t\tfor(int j=0; j<map[i].length; j++){\n\t\t\t\tif(map[i][j] == '<') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 0;\n\t\t\t\t} else if(map[i][j] == '^') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 1;\n\t\t\t\t} else if(map[i][j] == '>') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 2;\n\t\t\t\t} else if(map[i][j] == 'v') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// マップセットの個数入力\n\t\tint num = sc.nextInt();\n\n\t\tfor(int n=0; n<num; n++) {\n\n\t\t\t// 地図データの入力\n\t\t\tint y = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\n\t\t\tchar[][] map = new char[y+2][x+2];\n\n\t\t\t// 外を埋める\n\t\t\tfor(int i=0; i<y+2; i++) {\n\t\t\t\tfor(int j=0; j<x+2; j++) {\n\t\t\t\t\tif(i == 0 || i == y+1 || j == 0 || j == x+1) map[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t\t\tmap[i][j] = line.toCharArray()[j-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// マップを表示\n\t\t\t//\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t//\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t//\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\tSystem.out.println(\"\");\n\t\t\t//\t\t}\n\n\t\t\t// 命令を入力\n\t\t\tint orderNum = sc.nextInt();\n\t\t\tString orders = sc.next();\n\t\t\tchar[] orderArr = orders.toCharArray();\n\n\t\t\tMain b = new Main();\n\n\t\t\t// 戦車の初期位置と向きを取得\n\t\t\tint[] tankPos = b.getTankDir(map);\n\n//\t\t\tfor(int i=0; i<3; i++) {\n//\t\t\t\tSystem.out.println(tankPos[i]);\n//\t\t\t}\n\n\t\t\t// 戦車を生成\n\t\t\tTank t = new BattleTown().new Tank(tankPos[0], tankPos[1], tankPos[2], map);\n\n\t\t\t// 命令を実行\n\t\t\tfor(int i=0; i<orderNum; i++) {\n\t\t\t\tt.order(orderArr[i]);\n\t\t\t}\n\n\n\t\t\t// debug\n\t\t\t// 戦車の移動テスト\n\t\t\t//\t\tt.rotate('L');\n\n\t\t\t// マップを再表示\n\t\t\tSystem.out.println(\"\");\n\t\t\tt.drawMap();\n\n\t\t}\n\n\t\tsc.close();\n\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§????????????????????????????????????????????°\n\t\tint sysout_cnt = data_set;\n\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??????????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ????????????????????¨?????????????????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('U', '^');\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// ('D', 'v');\n\t\t\t// ('v', { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('L', '<');\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('R', '>');\n\t\t\t// ('>',{ 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\t// ??????????????????????????????\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('v',{ 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('>', { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map3> map_list = new ArrayList<map3>();\n\t\t//入力クラス\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t// 入力の回数\n\t\tint input_length =0;\n\t\twhile(sc.hasNext()){\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap3 map = new map3();\n\t\t\tmap.setMap(height, width);\n\t\t\t\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank3 tank = new tank3();\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// コマンド入力回数\n\t\t\tint command_number = sc.nextInt();\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\tString command_attack = sc.next();\n\t\t\t\n\t\t\t// ひとつずつ配列に入れる\n\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// 戦車の現在位置を調べる\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// できたマップリストにを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\tmap_list.get(f).out_map();\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n//戦車について扱ったクラス\nclass tank3 {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す \n\tpublic void searchTank(String[][] map_all) {\n\t\t//マップ全体を探す\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\n//マップについて扱ったクラス\nclass map3 {\n\t\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String args[]) {\n\t\tStringBuilder result = new StringBuilder();\n\t\tScanner scan = new Scanner(System.in);\n\t\tint setCount = scan.nextInt();\n\n\t\t// setCount????????°??°???????????????\n\t\tfor(int i=0;i<setCount;i++){\n\n\t\t// PlayerControl??????????????????????????????\n\t\tPlayerControl pc = new PlayerControl(scan.nextInt(), scan.nextInt());\n\t\t// ????????????????????????\n\t\tpc.mapBuild(scan);\n\n\t\t// System.out.println(pc.map[3][0]);\n\n\t\t// ?????¬???????????\\??????????????°?????????\n\t\tint playerControlCount = scan.nextInt();\n\t\t// ?????¬???????????\\??????????????????????????????\n\t\tString setPlayerControl = scan.next();\n\t\tfor (int k = 0; k < playerControlCount; k++) {\n\t\t\tif (String.valueOf(setPlayerControl.charAt(k)).equals(\"S\")) {\n\t\t\t\t// ???????????????????????????????????????????°??????????\n\t\t\t\tpc.tankShoot();\n\t\t\t} else {\n\t\t\t\t// ?????????????????¢??????????????????????????°??§????????°?§??????????\n\t\t\t\tpc.tankMove(String.valueOf(setPlayerControl.charAt(k)));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//???????????¨????????????????????????result????????????????????????\n\t\tresult.append(pc.mapOutput()).append(\"\\n\");\n\t\t}\n\t\t\n\t\tresult.deleteCharAt(result.length() - 2);\n\t\tSystem.out.println(new String(result));\n\n\t\t\n\n\t}\n}\n\n/**\n * ?????¬????????????????????????????????????????????????\n * \n * @author SS\n *\n */\nclass PlayerControl {\n\t// ??????????????????\n\tString map[][];\n\n\t// ??????????????±\n\tint tankHeight;\n\tint tankWidth;\n\tString tankState;\n\n\t// ?????????????????????????????¨????????????????¨????\n\tPlayerControl(int height, int width) {\n\t\tmap = new String[height][width];\n\t\ttankHeight = 0;\n\t\ttankWidth = 0;\n\t\ttankState = \"\";\n\t}\n\n\t/**\n\t * ??????????????????\n\t * \n\t * @param main???Scanner??????????¶????\n\t */\n\tpublic void mapBuild(Scanner scan) {\n\t\t// height * width ??????????????§??????????????????????????????\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tString setObject = scan.next();\n\t\t\tfor (int j = 0; j < map[0].length; j++) {\n\t\t\t\t// ?????????????????¨??¶???????????±????¨????\n\t\t\t\tswitch (map[i][j] = String.valueOf(setObject.charAt(j))) {\n\t\t\t\tcase \"^\":\n\n\t\t\t\t\ttankInfo(i, j, \"^\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"v\":\n\t\t\t\t\ttankInfo(i, j, \"v\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \">\":\n\t\t\t\t\ttankInfo(i, j, \">\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"<\":\n\t\t\t\t\ttankInfo(i, j, \"<\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * ?????????????????¨??¶???????¨??????????\n\t * \n\t * @param height\n\t *            ????????§?¨?\n\t * @param width\n\t *            ?¨??????§?¨?\n\t * @param state\n\t *            ??¶?????????????????????\n\t */\n\tprivate void tankInfo(int height, int width, String state) {\n\n\t\ttankHeight = height;\n\t\ttankWidth = width;\n\t\ttankState = state;\n\n\t}\n\n\t/**\n\t * \n\t * @param ?????¬???????????????????????????????????????\n\t */\n\tpublic void Control(String instruction) {\n\t\tswitch (instruction) {\n\t\tcase \"S\":// ???????????????????????¨???\n\t\t\tSystem.out.println(\"tankShoot()???????????????\");\n\t\t\ttankShoot();\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tpublic void tankMove(String move) {\n\t\tswitch (move) {\n\t\tcase \"U\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"^\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????????§????????¨?????????????????????\n\t\t\tif (tankHeight - 1 >= 0) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight - 1][tankWidth].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight - 1][tankWidth] = \"^\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight - 1, tankWidth, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"D\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"v\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\t\t\t\n\t\t\t// ?????????????????????????¶????????????¨?????????????????????\n\t\t\tif (tankHeight + 1 < map.length) {\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight + 1][tankWidth].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight + 1][tankWidth] = \"v\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight + 1, tankWidth, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"L\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \"<\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????????§????????¨?????????????????????\n\t\t\tif (tankWidth - 1 >= 0) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight][tankWidth - 1].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight][tankWidth - 1] = \"<\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight, tankWidth - 1, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"R\":// ??????????????¢???????????????????????°???????§??????????\n\t\t\t// ???????????????????????????????????????\n\t\t\ttankState = \">\";\n\t\t\tmap[tankHeight][tankWidth] = tankState;\n\n\t\t\t// ?????????????????????????¶????????????¨?????????????????????\n\t\t\tif (tankWidth + 1 < map[0].length) {\n\n\t\t\t\t// ?????????????????°??§????????°?§?????????????\n\t\t\t\tif (map[tankHeight][tankWidth + 1].equals(\".\")) {\n\t\t\t\t\t// ?§???????????????????????????????????±??????´???????????°?????????\n\t\t\t\t\tmap[tankHeight][tankWidth + 1] = \">\";\n\t\t\t\t\tmap[tankHeight][tankWidth] = \".\";\n\t\t\t\t\ttankInfo(tankHeight, tankWidth + 1, tankState);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * S?????????????????¨??????????????????????????????????????????????°????????????? ??¬?????¬????£??????¶????????£?????¨???????????¬?????¬????£?????????°??¨?????????\n\t */\n\tpublic void tankShoot() {\n\t\ttry {\n\t\t\tswitch (tankState) {\n\t\t\tcase \"^\":// ???????????????????????????\n\n\t\t\t\tfor (int i = 1; i <= tankHeight; i++) {\n\t\t\t\t\tif (map[tankHeight - i][tankWidth].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight - i][tankWidth] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight - i][tankWidth].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase \"v\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= (map.length - 1) - tankHeight; i++) {\n\t\t\t\t\tif (map[tankHeight + i][tankWidth].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight + i][tankWidth] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight + i][tankWidth].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \">\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= (map[0].length - 1) - tankWidth; i++) {\n\t\t\t\t\tif (map[tankHeight][tankWidth + i].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight][tankWidth + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight][tankWidth + i].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"<\":// ???????????????????????????\n\t\t\t\tfor (int i = 1; i <= tankWidth; i++) {\n\t\t\t\t\tif (map[tankHeight][tankWidth - i].equals(\"*\")) {// ??¬?????¬????£????????????£?????´????????????????????°?????????\n\t\t\t\t\t\tmap[tankHeight][tankWidth - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (map[tankHeight][tankWidth - i].equals(\"#\")) {// ???????£????????????£?????´???????????????????????????\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"??´??????????????????\");\n\t\t}\n\n\t}\n\n\tpublic StringBuilder mapOutput() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tfor (int j = 0; j < map[0].length; j++) {\n\t\t\t\tsb.append(map[i][j]);\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\t\n\t\treturn sb;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\tstatic ArrayList<String> printList = new ArrayList<String>();\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint dataSetsCount = Integer.parseInt(sc.nextLine());\n\t\tfor (int count = 0; count < dataSetsCount; count++) {\n\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tmap.tank.ExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\n\t\t\tPrint();\n\t\t\tif (count < dataSetsCount - 1)\n\t\t\t\tprintList.add(\"\\n\");\n\t\t}\n\t\tfor (String str : printList) {\n\t\t\tSystem.out.print(str);\n\t\t}\n\t}\n\n\tstatic void Print() {\n\n\t\tfor (int y = 0; y < map.height; y++) {\n\t\t\tString str = \"\";\n\t\t\tfor (int x = 0; x < map.width; x++) {\n\t\t\t\tif (map.tank.Y == y && map.tank.X == x) {\n\t\t\t\t\tstr += map.tank.State.str;\n\t\t\t\t} else {\n\t\t\t\t\tTile t = map.getTile(x, y);\n\t\t\t\t\tstr += t.Type.str;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr += \"\\n\";\n\t\t\tprintList.add(str);\n\t\t}\n\t}\n\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\tstatic class Tile {\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\tenum ActionType {\n\t\tU(\"Up\"), D(\"Down\"), L(\"Left\"), R(\"Right\"), S;\n\n\t\tTankState ts;\n\n\t\tActionType() {\n\n\t\t}\n\n\t\tActionType(String str) {\n\t\t\tthis.ts = TankState.valueOf(str);\n\t\t}\n\t}\n\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\t\tString str;\n\t\tint x;\n\t\tint y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tstatic class Tank {\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\n\t\tvoid ExecuteAction(ActionType action) {\n\t\t\tif (action == ActionType.S) {\n\t\t\t\tthis.Shoot();\n\t\t\t} else {\n\t\t\t\tif (map.MobilityCheck(this.X + action.ts.x, this.Y + action.ts.y)) {\n\t\t\t\t\tthis.X += action.ts.x;\n\t\t\t\t\tthis.Y += action.ts.y;\n\t\t\t\t}\n\t\t\t\tthis.State = action.ts;\n\t\t\t}\n\t\t}\n\n\t\tvoid Shoot() {\n\t\t\tint x = this.X;\n\t\t\tint y = this.Y;\n\t\t\tTile tile = map.getTile(x, y);\n\t\t\twhile (tile != null && (tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\tx += this.State.x;\n\t\t\t\ty += this.State.y;\n\t\t\t\ttile = map.getTile(x, y);\n\t\t\t}\n\t\t\tif (tile != null && tile.Type == TileType.Brick) {\n\t\t\t\tmap.BreakBrickTile(x, y);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Map {\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\n\t\tint height;\n\t\tint width;\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tvoid BreakBrickTile(int x, int y) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, new Tile(x, y, TileType.Field));\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\n\t\t\t\t\tTileType tt = TileDiscrimination(line[x]);\n\t\t\t\t\tif (tt != null) {\n\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTankState ts = TankDiscrimination(line[x]);\n\t\t\t\t\t\tif (ts != null) {\n\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTileType TileDiscrimination(String str) {\n\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\tif (tt.str.equals(str)) {\n\t\t\t\t\treturn tt;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tTankState TankDiscrimination(String str) {\n\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\tif (ts.str.equals(str)) {\n\t\t\t\t\treturn ts;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean MobilityCheck(int x, int y) {\n\t\t\tTile t = getTile(x, y);\n\t\t\tif (t != null && t.Type == TileType.Field) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Map map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// データセット数の入力\n\t\tint dataSetsCount = Integer.parseInt(sc.nextLine());\n\t\tfor (int count = 0; count < dataSetsCount; count++) {\n\n\t\t\t// マップの縦幅と横幅の入力\n\t\t\tString[] input = sc.nextLine().split(\"[\\\\s]+\");\n\t\t\tmap = new Map(Integer.parseInt(input[0]), Integer.parseInt(input[1]));\n\n\t\t\t// マップ情報の入力\n\t\t\tinput = new String[map.height];\n\t\t\tfor (int i = 0; i < map.height; i++) {\n\t\t\t\tinput[i] = sc.nextLine();\n\t\t\t}\n\t\t\tmap.InputMapDate(input);\n\n\t\t\t// 戦車の行動の入力・マップの更新\n\t\t\tint actionCount = Integer.parseInt(sc.nextLine());\n\t\t\tString[] actionLine = sc.nextLine().split(\"\");\n\t\t\tfor (int i = 0; i < actionCount; i++) {\n\t\t\t\tmap.tank.ExecuteAction(ActionType.valueOf(actionLine[i]));\n\t\t\t}\n\n\t\t\t// 表示\n\t\t\tPrint();\n\t\t\t// データセットの間に改行をいれる\n\t\t\tif (count < dataSetsCount - 1) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\t// マップ内容の表示\n\tstatic void Print() {\n\t\tfor (int y = 0; y < map.height; y++) {\n\t\t\tString str = \"\";\n\t\t\tfor (int x = 0; x < map.width; x++) {\n\t\t\t\t// 戦車がいる場所か\n\t\t\t\tif (map.tank.Y == y && map.tank.X == x) {\n\t\t\t\t\t// 戦車の文字を取り出す\n\t\t\t\t\tstr += map.tank.State.str;\n\t\t\t\t} else {\n\t\t\t\t\t// タイルの文字を取り出す\n\t\t\t\t\tTile t = map.getTile(x, y);\n\t\t\t\t\tstr += t.Type.str;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 出力\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n\n\t// タイルの種類\n\tenum TileType {\n\t\tField(\".\"), Brick(\"*\"), Iron(\"#\"), Water(\"-\");\n\n\t\tString str;\n\n\t\tTileType(String str) {\n\t\t\tthis.str = str;\n\t\t}\n\t}\n\n\t// タイル\n\tstatic class Tile {\n\t\t// タイルタイプ・座標\n\t\tTileType Type;\n\t\tint X;\n\t\tint Y;\n\n\t\tTile(int x, int y, TileType type) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.Type = type;\n\t\t}\n\t}\n\n\t// 戦車の向き\n\tenum TankState {\n\t\tUp(\"^\", 0, -1), Down(\"v\", 0, 1), Right(\">\", 1, 0), Left(\"<\", -1, 0);\n\n\t\t// 戦車の向き・向きを表す座標\n\t\tString str;\n\t\tint X;\n\t\tint Y;\n\n\t\tTankState(String str, int x, int y) {\n\t\t\tthis.str = str;\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t}\n\t}\n\n\t// 戦車の行動\n\tenum ActionType {\n\t\tU(\"Up\"), D(\"Down\"), L(\"Left\"), R(\"Right\"), S;\n\n\t\t// 行動後の戦車の状態\n\t\tTankState ts;\n\n\t\tActionType() {\n\t\t}\n\n\t\tActionType(String str) {\n\t\t\tthis.ts = TankState.valueOf(str);\n\t\t}\n\t}\n\n\t// 戦車\n\tstatic class Tank {\n\t\t// 戦車の向き・戦車の座標\n\t\tTankState State;\n\t\tint X;\n\t\tint Y;\n\n\t\tTank(int x, int y, TankState state) {\n\t\t\tthis.X = x;\n\t\t\tthis.Y = y;\n\t\t\tthis.State = state;\n\t\t}\n\n\t\t// 行動の実行\n\t\tvoid ExecuteAction(ActionType action) {\n\t\t\t// Sなら砲撃、S以外は移動\n\t\t\tif (action == ActionType.S) {\n\t\t\t\tthis.Shoot();\n\t\t\t} else {\n\t\t\t\tMove(action.ts);\n\t\t\t}\n\t\t}\n\n\t\t// 移動\n\t\tvoid Move(TankState ts) {\n\t\t\t// 戦車の向きを変更\n\t\t\tthis.State = ts;\n\t\t\t// 戦車の向きから移動先が移動可能であるか\n\t\t\tif (map.MobilityCheck(this.X + ts.X, this.Y + ts.Y)) {\n\t\t\t\tthis.X += ts.X;\n\t\t\t\tthis.Y += ts.Y;\n\t\t\t}\n\t\t}\n\n\t\t// 砲撃\n\t\tvoid Shoot() {\n\t\t\tint x = this.X + this.State.X;\n\t\t\tint y = this.Y + this.State.Y;\n\t\t\twhile (map.BombardmentProceedsCheck(x, y)) {\n\t\t\t\tx += this.State.X;\n\t\t\t\ty += this.State.Y;\n\t\t\t}\n\t\t\tmap.BreakBrickTile(x, y);\n\t\t}\n\t}\n\n\t// マップ\n\tstatic class Map {\n\t\t// タイルリスト\n\t\tArrayList<Tile> tileList = new ArrayList<Tile>();\n\t\t// 縦幅・横幅\n\t\tint height;\n\t\tint width;\n\t\t// 戦車\n\t\tTank tank;\n\n\t\tMap(int height, int width) {\n\t\t\tthis.height = height;\n\t\t\tthis.width = width;\n\t\t}\n\n\t\t// リストからタイルを取り出す\n\t\tTile getTile(int x, int y) {\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.X == x && t.Y == y) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t// マップデータの入力を反映する\n\t\tvoid InputMapDate(String[] str) {\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\t// 入力を1文字単位に分割\n\t\t\t\tString[] line = str[y].split(\"\");\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\t// タイルタイプへ変換\n\t\t\t\t\tTileType tt = TileDiscrimination(line[x]);\n\t\t\t\t\tif (tt != null) {\n\t\t\t\t\t\t// タイルをリストに追加\n\t\t\t\t\t\ttileList.add(new Tile(x, y, tt));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// タイルでないなら戦車へ変換\n\t\t\t\t\t\tTankState ts = TankDiscrimination(line[x]);\n\t\t\t\t\t\tif (ts != null) {\n\t\t\t\t\t\t\tthis.tank = new Tank(x, y, ts);\n\t\t\t\t\t\t\ttileList.add(new Tile(x, y, TileType.Field));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 1文字からタイルタイプへ\n\t\tTileType TileDiscrimination(String str) {\n\t\t\tfor (TileType tt : TileType.values()) {\n\t\t\t\tif (tt.str.equals(str)) {\n\t\t\t\t\treturn tt;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t// 1文字から戦車へ\n\t\tTankState TankDiscrimination(String str) {\n\t\t\tfor (TankState ts : TankState.values()) {\n\t\t\t\tif (ts.str.equals(str)) {\n\t\t\t\t\treturn ts;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t// 移動可能な場所であるか判定\n\t\tboolean MobilityCheck(int x, int y) {\n\t\t\tTile t = getTile(x, y);\n\t\t\tif (t != null && t.Type == TileType.Field) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// 砲弾が進むか判定\n\t\tboolean BombardmentProceedsCheck(int x, int y) {\n\t\t\tTile tile = this.getTile(x, y);\n\t\t\tif (tile != null && (tile.Type == TileType.Field || tile.Type == TileType.Water)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// レンガの壁を壊す\n\t\tvoid BreakBrickTile(int x, int y) {\n\t\t\tint i = 0;\n\t\t\tfor (Tile t : tileList) {\n\t\t\t\tif (t.Type == TileType.Brick && t.X == x && t.Y == y) {\n\t\t\t\t\ttileList.set(i, new Tile(x, y, TileType.Field));\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tchar[][] map;\n\tint dir;\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint t = scan.nextInt();\n\t\tint n;\n\t\tchar[] op;\n\t\tfor(int data = 0;data < t;data++){\n\t\t\th = scan.nextInt();\n\t\t\tw = scan.nextInt();\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tmap[i] = scan.next().toCharArray();\n\t\t\t}\n\t\t\tn = scan.nextInt();\n\t\t\top = scan.next().toCharArray();\n\t\t\tboolean fl = false;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(map[i][j] == '^'){\n\t\t\t\t\t\tdir = 0; x = j; y = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(map[i][j] == '<'){\n\t\t\t\t\t\tdir = 3; x = j; y = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(map[i][j] == '>'){\n\t\t\t\t\t\tdir = 2; x = j; y = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(map[i][j] == 'v'){\n\t\t\t\t\t\tdir = 1; x = j; y = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fl){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tswitch(op[i]){\n\t\t\t\tcase 'U': up(); break;\n\t\t\t\tcase 'D': down(); break;\n\t\t\t\tcase 'R': right(); break;\n\t\t\t\tcase 'L': left(); break;\n\t\t\t\tcase 'S': shoot(); break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(data != t-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void up(){\n\t\tdir = 0;\n\t\tif(y != 0){\n\t\t\tif(map[y-1][x] == '.'){\n\t\t\t\tmap[y--][x] = '.';\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tmap[y][x] = '^';\n\t}\n\tpublic void down(){\n\t\tdir = 1;\n\t\tif(y != h-1){\n\t\t\tif(map[y+1][x] == '.'){\n\t\t\t\tmap[y++][x] = '.';\n\t\t\t}\n\t\t}\n\t\tmap[y][x] = 'v';\n\t}\n\tpublic void right(){\n\t\tdir = 2;\n\t\tif(x != w-1){\n\t\t\tif(map[y][x+1] == '.'){\n\t\t\t\tmap[y][x++] = '.';\n\t\t\t}\n\t\t}\n\t\tmap[y][x] = '>';\n\t}\n\tpublic void left(){\n\t\tdir = 3;\n\t\tif(x != 0){\n\t\t\tif(map[y][x-1] == '.'){\n\t\t\t\tmap[y][x--] = '.';\n\t\t\t}\n\t\t}\n\t\tmap[y][x] = '<';\n\t}\n\tpublic void shoot(){\n\t\tif(dir == 0){\n\t\t\tfor(int i = y;i >= 0;i--){\n\t\t\t\tif(map[i][x] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[i][x] == '*'){\n\t\t\t\t\tmap[i][x] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir == 1){\n\t\t\tfor(int i = y;i < h;i++){\n\t\t\t\tif(map[i][x] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[i][x] == '*'){\n\t\t\t\t\tmap[i][x] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir == 2){\n\t\t\tfor(int i = x;i < w;i++){\n\t\t\t\tif(map[y][i] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[y][i] == '*'){\n\t\t\t\t\tmap[y][i] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir == 3){\n\t\t\tfor(int i = x;i >= 0;i--){\n\t\t\t\tif(map[y][i] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[y][i] == '*'){\n\t\t\t\t\tmap[y][i] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main{\n    public static void main(String[] args){\n        Scanner stdIn = new Scanner(System.in);\n         \n        int N = stdIn.nextInt();\n        String[][] result = new String[N][];\n        for(int i = 0; i < N; i++){\n            int H = stdIn.nextInt();\n            int W = stdIn.nextInt();\n            String[] str = new String[H];\n            for(int j = 0; j < H; j++){\n                str[j] = stdIn.next();\n            }\n            char[][] map = new char[H][W];\n            for(int j = 0; j < H; j++){\n                map[j] = str[j].toCharArray();\n            }\n             \n            int[] now = new int[2];\n            for(int j = 0; j < H; j++){\n                for(int k = 0; k < W; k++){\n                    if( map[j][k] == '<' || map[j][k] == '>' || map[j][k] == '^' || map[j][k] == 'v' ){\n                        now[0] = k;\n                        now[1] = j;\n                        break;\n                    }\n                }\n            }\n            int com = stdIn.nextInt();\n            String s = stdIn.next();\n            char[] c = s.toCharArray();\n            for(int j = 0; j < com; j++){\n                if( c[j] == 'U' ){\n                    if( now[1] > 0 && map[now[1]-1][now[0]] == '.' ){\n                        map[now[1]-1][now[0]] = '^';\n                        map[now[1]][now[0]] = '.';\n                        now[1]--;\n                    } else {\n                        map[now[1]][now[0]] = '^';\n                    }\n                } else if( c[j] == 'D' ){\n                    if( now[1] < map.length-1 && map[now[1]+1][now[0]] == '.' ){\n                        map[now[1]+1][now[0]] = 'v';\n                        map[now[1]][now[0]] = '.';\n                        now[1]++;\n                    } else {\n                        map[now[1]][now[0]] = 'v';\n                    }\n                } else if( c[j] == 'L' ){\n                    if( now[0] > 0 && map[now[1]][now[0]-1] == '.' ){\n                        map[now[1]][now[0]-1] = '<';\n                        map[now[1]][now[0]] = '.';\n                        now[0]--;\n                    } else {\n                        map[now[1]][now[0]] = '<';\n                    }\n                } else if( c[j] == 'R' ){\n                    if( now[0] < map[now[1]].length-1 && map[now[1]][now[0]+1] == '.' ){\n                        map[now[1]][now[0]+1] = '>';\n                        map[now[1]][now[0]] = '.';\n                        now[0]++;\n                    } else {\n                        map[now[1]][now[0]] = '>';\n                    }\n                } else if( c[j] == 'S' ){\n                    if( map[now[1]][now[0]] == '>' ){\n                        for(int k = now[0]+1; k < map[now[1]].length; k++){\n                            if( map[now[1]][k] == '*' ){\n                                map[now[1]][k] = '.';\n                                break;\n                            } else if( map[now[1]][k] == '#' ){\n                                break;\n                            }\n                        }\n                    } else if( map[now[1]][now[0]] == '<' ){\n                        for(int k = now[0]-1; k >= 0; k--){\n                            if( map[now[1]][k] == '*' ){\n                                map[now[1]][k] = '.';\n                                break;\n                            } else if( map[now[1]][k] == '#' ){\n                                break;\n                            }\n                        }   \n                    } else if( map[now[1]][now[0]] == 'v' ){\n                        for(int k = now[1]+1; k < map.length; k++){\n                            if( map[k][now[0]] == '*' ){\n                                map[k][now[0]] = '.';\n                                break;\n                            } else if( map[k][now[0]] == '#' ){\n                                break;\n                            }\n                        }\n                    } else if( map[now[1]][now[0]] == '^' ){\n                        for(int k = now[1]-1; k >= 0; k--){\n                            if( map[k][now[0]] == '*' ){\n                                map[k][now[0]] = '.';\n                                break;\n                            } else if( map[k][now[0]] == '#' ){\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            result[i] = new String[H];\n            for(int j = 0; j < H; j++){\n                result[i][j] = new String(map[j]);\n            }\n        }\n         \n        for(int i = 0; i < N-1; i++){\n            for(int j = 0; j < result[i].length; j++){\n                System.out.println(result[i][j]);\n            }\n            System.out.println();\n        }\n        for(int i = 0; i < result[N-1].length; i++){\n            System.out.println(result[N-1][i]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n \nimport static java.lang.Integer.parseInt;\n \n/**\n * Battle Town\n */\npublic class Main {\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n \n        int t = parseInt(br.readLine());\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n \n            int h = parseInt(line.substring(0, line.indexOf(' ')));\n            int w = parseInt(line.substring(line.indexOf(' ') + 1));\n \n            char map[][] = new char[h + 2][w + 2];\n            Tank tank = null;\n \n            for (int i = 0; i < h + 2; i++) {\n                Arrays.fill(map[i], 'x');\n            }\n \n            for (int i = 1; i < h + 1; i++) {\n                line = br.readLine();\n                for (int j = 0; j < w; j++) {\n                    map[i][j + 1] = line.charAt(j);\n                    if (\"^v<>\".indexOf(map[i][j + 1]) > -1) {\n                        // init tank.\n                        tank = new Tank(map[i][j + 1], map, new int[]{i, j + 1});\n                        map[i][j + 1] = '.';\n                    }\n                }\n            }\n \n            // sim\n            br.readLine();\n            line = br.readLine();\n            for (char c : line.toCharArray()) tank.command(c);\n            tank.finish();\n            t--;\n \n            // solve\n            for (int i = 1; i < h + 1; i++) {\n                for (int j = 1; j < w + 1; j++) {\n                    System.out.print(map[i][j]);\n                }\n                System.out.println();\n            }\n            if (t > 0) {\n                System.out.println();\n            }\n \n        } //end while\n    } //end main\n}\n \nclass Tank {\n \n    static HashMap<Character, Character> cmds = new HashMap<Character, Character>() {\n        {\n            put('U', '^');\n            put('D', 'v');\n            put('L', '<');\n            put('R', '>');\n        }\n    };\n    static HashMap<Character, int[]> dirs = new HashMap<Character, int[]>() {\n        {\n            put('^', new int[]{-1, 0});\n            put('v', new int[]{1, 0});\n            put('<', new int[]{0, -1});\n            put('>', new int[]{0, 1});\n        }\n    };\n \n    private char dir;\n    private char[][] map;\n    private int[] pos;\n \n    Tank(char dir, char[][] map, int[] pos) {\n        this.dir = dir;\n        this.map = map;\n        this.pos = pos;\n    }\n \n    void command(char cmd) {\n        if (cmd != 'S') {\n            move(cmd);\n        } else {\n            shoot();\n        }\n    }\n \n    private void move(char cmd) {\n        this.dir = cmds.get(cmd);\n        int[] next = new int[]{this.pos[0], this.pos[1]};\n        next[0] += dirs.get(this.dir)[0];\n        next[1] += dirs.get(this.dir)[1];\n        if (map[next[0]][next[1]] == '.') {\n            this.pos[0] = next[0];\n            this.pos[1] = next[1];\n        }\n    }\n \n    private void shoot() {\n        int[] shell = new int[]{this.pos[0], this.pos[1]};\n        while (true) {\n            shell[0] += dirs.get(this.dir)[0];\n            shell[1] += dirs.get(this.dir)[1];\n            switch (map[shell[0]][shell[1]]) {\n                case '.':\n                case '-':\n                    continue;\n                case '*':\n                    map[shell[0]][shell[1]] = '.';\n                case '#':\n                case 'x':\n            }\n            break;\n        }\n    }\n \n    void finish() {\n        map[this.pos[0]][this.pos[1]] = this.dir;\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic void move_up ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]-1][tank_pos[0]] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]-1][tank_pos[0]] = '^';\n\t\t\ttank_pos[1]--;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '^';\n\t\t}\n\t}\n\n\tstatic void move_down ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]+1][tank_pos[0]] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]+1][tank_pos[0]] = 'v';\n\t\t\ttank_pos[1]++;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = 'v';\n\t\t}\n\t}\n\n\tstatic void move_left ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]][tank_pos[0]-1] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]][tank_pos[0]-1] = '<';\n\t\t\ttank_pos[0]--;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '<';\n\t\t}\n\t}\n\n\tstatic void move_right ( char[][] map, int[] tank_pos ) {\n\n\t\tif ( map[tank_pos[1]][tank_pos[0]+1] == '.' ) {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '.';\n\t\t\tmap[tank_pos[1]][tank_pos[0]+1] = '>';\n\t\t\ttank_pos[0]++;\n\t\t}else {\n\t\t\tmap[tank_pos[1]][tank_pos[0]] = '>';\n\t\t}\n\t}\n\n\tstatic void shoot ( char[][] map, int tank_x, int tank_y ) {\n\n\t\tint missile_x = tank_x;\n\t\tint missile_y = tank_y;\n\n\t\twhile ( true ) {\n\t\t\tif ( map[tank_y][tank_x] == '^' ) {\n\t\t\t\tmissile_y--;\n\t\t\t} else if ( map[tank_y][tank_x] == 'v' ) {\n\t\t\t\tmissile_y++;\n\t\t\t} else if ( map[tank_y][tank_x] == '<' ) {\n\t\t\t\tmissile_x--;\n\t\t\t} else if ( map[tank_y][tank_x] == '>' ) {\n\t\t\t\tmissile_x++;\n\t\t\t}\n\n\t\t\tif ( map[missile_y][missile_x] == '*' ) {\n\t\t\t\tmap[missile_y][missile_x] = '.';\n\t\t\t\tbreak;\n\t\t\t} else if( map[missile_y][missile_x] == '#' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\t//データセット数\n\t\tint set_num_T;\n\n\t\tint map_H = 0;\n\t\tint map_W = 0;\n\t\tint input_op_length_N = 0;\n\t\tint[] tank_pos = new int[]{ 0, 0 };\n\t\tString str_buf = \"\";\n\t\tString str_op = \"\";\n\t\tchar[][] map;\n\t\tchar[] tank = new char[]{'^','>','v','<'};\n\n\t\tScanner sc= new Scanner( System.in );\n\n\t\tset_num_T = sc.nextInt();\n\t\tmap = new char[22][22];\n\n\t\tfor( int i = 0; i < set_num_T ; i++ ) {\n\n\t\t\t//データ読み込み\n\t\t\tmap_H = sc.nextInt();\n\t\t\tmap_W = sc.nextInt();\n\n\t\t\t//mapセット mapを#で囲む\n\t\t\tfor ( int j = 0 ; j < map_H+2 ; j++ ) {\n\t\t\t\tfor ( int k = 0 ; k < map_W+2 ; k++ ) {\n\t\t\t\t\tif ( ( ( j+1 ) % ( map_H+1 ) ) == 1 || ( ( k+1 ) % ( map_W+1 ) ) == 1 ) {\n\t\t\t\t\t\tmap[j][k] = '#';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( k== 1 ) {\n\t\t\t\t\t\t\tstr_buf =sc.next();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmap[j][k]=str_buf.charAt( k-1 );\n\n\t\t\t\t\t\t//読み込みデータが戦車の時、戦車の位置を取得\n\t\t\t\t\t\tfor( int l = 0 ; l < 4 ; l++ ) {\n\t\t\t\t\t\t\tif ( map[j][k] == tank[l] ) {\n\t\t\t\t\t\t\t\ttank_pos[0] = k;\n\t\t\t\t\t\t\t\ttank_pos[1] = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinput_op_length_N = sc.nextInt();\n\t\t\tstr_op = sc.next();\n\n\n\t\t\t//命令に従ってMAPと戦車を書き換える\n\t\t\tfor ( int j = 0 ; j < input_op_length_N; j++) {\n\t\t\t\tswitch( str_op.charAt(j) ) {\n\t\t\t\tcase 'U':\n\t\t\t\t\tmove_up( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tmove_down( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tmove_left( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tmove_right( map, tank_pos );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tshoot( map, tank_pos[0], tank_pos[1] );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//結果処理\n\t\t\tfor ( int j = 1 ; j < map_H+1 ; j++ ) {\n\t\t\t\tfor ( int k = 1 ; k < map_W+1 ; k++ ) {\n\t\t\t\t\tSystem.out.print( map[j][k] );\n\t\t\t\t}\n\t\t\t\tSystem.out.print( \"\\n\" );\n\t\t\t}\n\n\t\t\tif(i != set_num_T-1) {\n\t\t\t\tSystem.out.print( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\nclass Main {\nstatic class Amap {\nchar[][] field;\n\nAmap(int h, int w) {\n  this.field = new char[h + 2][w + 2];\n  Arrays.fill(field[0], SF);\n  Arrays.fill(field[h + 1], SF);\n  for (char[] line : field) {\n\tline[0] = SF;\n\tline[w + 1] = SF;\n  }\n}\n\nvoid setField(int x, int y, char c) {\n  if (dMap.containsValue(c)) c = GF;\n  field[y][x] = c;\n}\n\nchar getField(int[] xy) {\n  return field[xy[Y]][xy[X]];\n}\n\n}\n\nstatic class Tank {\nAmap  map;\nint[] posi = new int[2];\nchar  d;\n\nTank(Amap map) {\n  this.map = map;\n}\n\nvoid move(char order) {\n  this.d = dMap.get(order);\n  int[] movePoint = move(new int[] { posi[X], posi[Y] });\n  if (map.getField(movePoint) == GF) {\n\tposi = movePoint;\n  }\n}\n\nint[] move(int[] posi) {\n  if (d == '^') {\n\tposi[Y]--;\n  } else if (d == 'v') {\n\tposi[Y]++;\n  } else if (d == '<') {\n\tposi[X]--;\n  } else if (d == '>') {\n\tposi[X]++;\n  }\n  return posi;\n}\n\nvoid order(char o) {\n  if (dMap.containsKey(o)) {\n\tmove(o);\n  } else {\n\tshot();\n  }\n}\n\nvoid setPosi(int x, int y, char d) {\n  posi[X] = x;\n  posi[Y] = y;\n  this.d = d;\n}\n\nvoid shot() {\n  int[] beam = { posi[X], posi[Y] };\n  boolean isStop = false;\n  while (!isStop) {\n\tchar cf = map.getField(beam);\n\tswitch (cf) {\n\tcase RF:\n\t  map.setField(beam[X], beam[Y], GF);\n\tcase SF:\n\t  isStop = true;\n\t  break;\n\tdefault:\n\t  move(beam);\n\t  break;\n\t}\n  }\n}\n}\n\nstatic final int                 X  = 0;\nstatic final int                 Y  = 1;\nprivate static final char        GF = '.';\nprivate static final char        SF = '#';\nprivate static final char        RF = '*';\nprivate static final char        WF = '-';\nprivate static final char        UT = '^';\nprivate static final char        DT = 'v';\nprivate static final char        RT = '>';\nprivate static final char        LT = '<';\n\nstatic Map<Character, Character> dMap;\n\nstatic {\n  dMap = new HashMap<Character, Character>();\n  dMap.put('R', RT);\n  dMap.put('L', LT);\n  dMap.put('U', UT);\n  dMap.put('D', DT);\n}\n\npublic static void main(String[] args) {\n  Scanner in = new Scanner(System.in);\n  Amap map;\n  Tank tank;\n  while (in.hasNext()) {\n\tint t = in.nextInt();\n\tfor (int dataSet = 0; dataSet < t; dataSet++) {\n\t  final int h = in.nextInt();\n\t  final int w = in.nextInt();\n\t  tank = new Tank(map = new Amap(h, w));\n\t  for (int y = 1; y <= h; y++) {\n\t\tString line = in.next();\n\t\tfor (int x = 1; x <= w; x++) {\n\t\t  char field = line.charAt(x - 1);\n\t\t  if (dMap.containsValue(field)) {\n\t\t\ttank.setPosi(x, y, field);\n\t\t\tfield = GF;\n\t\t  }\n\t\t  map.setField(x, y, field);\n\n\t\t}\n\t  }\n\t  int len = in.nextInt();\n\t  String orders = in.next();\n\t  for (int n = 0; n < len; n++) {\n\t\tfinal char order = orders.charAt(n);\n\t\ttank.order(order);\n\t  }\n\t  int[] posi = new int[2];\n\t  for (int y = 1; y <= h; y++) {\n\t\tposi[Y] = y;\n\t\tfor (int x = 1; x <= w; x++) {\n\t\t  posi[X] = x;\n\t\t  if (tank.posi[X] == x && tank.posi[Y] == y) {\n\t\t\tSystem.out.print(tank.d);\n\t\t  } else {\n\t\t\tSystem.out.print(map.getField(posi));\n\t\t  }\n\t\t}\n\t\tSystem.out.println();\n\t  }\n\t  if (dataSet < t - 1) {\n\t\tSystem.out.println();\n\t  }\n\t}\n  }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\t//?????£?????????????????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString[] area = insBR.readLine().split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±???????´?\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\t//?????£??????????????±?????????\n\t\t\t\tString[] fieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\n\t\t\t//?????????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\n\t\t\tField insField = aryIns[k];\n\t\t\t//????????????????????????????????????????????¨????????????\n\t\t\tint intHeight = insField.field.length;\n\t\t\tint intWidth = insField.field[0].length;\n\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != aryIns.length -1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£????????????????????¨???????????????????????°*/\n\t\tprivate int intHeight;\n\t\tprivate int intWidth;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.intHeight = field.length;\n\t\t\tthis.intWidth = field[0].length;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\n\t\tsc = new Scanner(System.in);\n\t\ttry {\n\n\t\t\t//???????????°???????????????\n\t\t\tint input = Integer.parseInt(sc.next());\n\t\t\tfor (int i = 0; i < input; i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\n\t\t\t\t//??????????????????\n\t\t\t\tint depth = sc.nextInt();\n\t\t\t\tint width = sc.nextInt();\n\t\t\t\tString[][] map = new String[depth][width];\n\t\t\t\tString line = \"\";//sc.nextLine();\n\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\t//?????????????????????\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\tString[] list = line.split(\"\");\n\t\t\t\t\t//????????????????´???????\n\t\t\t\t\tfor (int k = 0; k < map[0].length; k++) {\n\t\t\t\t\t\tmap[j][k] = list[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//?????????????????????\n\t\t\t\tint commNum = Integer.parseInt(sc.next());\n\t\t\t\tline = sc.next();\n\t\t\t\tString[] command = line.split(\"\");\n\n\t\t\t\tmap = command(map,command);\n\n\t\t\t\t//???????????????\n\t\t\t\tString output = \"\";\n\t\t\t\tfor (String[] gamemap : map) {\n\n\t\t\t\t\tfor (String cel : gamemap) {\n\t\t\t\t\t\toutput += cel;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\toutput = \"\";\n\t\t\t\t}\n\n\t\t\t}\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n\t//???????????????????????????????????????\n\tpublic static String[][] command(String[][] map, String[] comm) {\n\n\t\tint dep = 0;\n\t\tint wid = 0;\n\t\tString player = \"\";\n\t\tString[][] playmap;\n\t\tString[] command;\n\n\t\tplaymap = map;\n\t\tcommand = comm;\n\n\t\t\t//?????????????????¨???????????????\n\t\tfor (int i = 0; i < playmap.length; i++) {\n\t\t\tif (player.equals(\"\")) {\n\n\t\t\t\tfor (int j = 0; j < playmap[0].length; j++) {\n\t\t\t\t\t//?????????????????§??????\n\t\t\t\t\tif (playmap[i][j].equals(\"^\")) {\n\t\t\t\t\t\tplayer = \"^\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"v\")) {\n\t\t\t\t\t\tplayer = \"v\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\">\")) {\n\t\t\t\t\t\tplayer = \">\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"<\")) {\n\t\t\t\t\t\tplayer = \"<\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//?????????????????????\n\t\tfor (int i = 0; i < command.length; i++) {\n\t\t\t//??????????????§????????????\n\t\t\tswitch (command[i]) {\n\t\t\tcase \"U\":\n\t\t\t\tplaymap[dep][wid] = \"^\";\n\t\t\t\tplayer = \"^\";\n\t\t\t\tif (dep != 0 && playmap[dep - 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep - 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tplaymap[dep][wid] = \"v\";\n\t\t\t\tplayer = \"v\";\n\t\t\t\tif (dep != playmap.length - 1 && playmap[dep + 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep + 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"R\":\n\t\t\t\tplaymap[dep][wid] = \">\";\n\t\t\t\tplayer = \">\";\n\t\t\t\tif (wid != playmap[0].length - 1 && playmap[dep][wid + 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid + 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tplaymap[dep][wid] = \"<\";\n\t\t\t\tplayer = \"<\";\n\t\t\t\tif (wid != 0 && playmap[dep][wid - 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid - 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\t//???????????????????????´???\n\t\t\t\tif (player.equals(\"^\")) {\n\t\t\t\t\tint count = dep;\n\t\t\t\t\tfor (int k = 0; k <= dep; k++) {\n\t\t\t\t\t\tif (playmap[count][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[count][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"v\")) {\n\t\t\t\t\tfor (int k = dep; k < playmap.length; k++) {\n\t\t\t\t\t\tif (playmap[k][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[k][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\">\")) {\n\t\t\t\t\tfor (int k = wid; k < playmap[0].length; k++) {\n\t\t\t\t\t\tif (playmap[dep][k].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][k] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][k].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"<\")) {\n\t\t\t\t\tint count = wid;\n\t\t\t\t\tfor (int k = 0; k <= wid; k++) {\n\t\t\t\t\t\tif (playmap[dep][count].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][count] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][count].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"othercCommand\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn playmap;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\n\t\tsc = new Scanner(System.in);\n\t\ttry {\n\n\t\t\t//???????????°???????????????\n\t\t\tint input = Integer.parseInt(sc.next());\n\t\t\tfor (int i = 0; i < input; i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\n\t\t\t\t//??????????????????\n\t\t\t\tint depth = sc.nextInt();\n\t\t\t\tint width = sc.nextInt();\n\t\t\t\tString[][] map = new String[depth][width];\n\t\t\t\tString line = \"\";//sc.nextLine();\n\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\t//?????????????????????\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\tString[] list = line.split(\"\");\n\t\t\t\t\t//????????????????´???????\n\t\t\t\t\tfor (int k = 0; k < map[0].length; k++) {\n\t\t\t\t\t\tmap[j][k] = list[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//?????????????????????\n\t\t\t\tint commNum = Integer.parseInt(sc.next());\n\t\t\t\tline = sc.next();\n\t\t\t\tString[] command = line.split(\"\");\n\n\t\t\t\tmap = command(map,command);\n\n\t\t\t\t//???????????????\n\t\t\t\tString output = \"\";\n\t\t\t\tfor (String[] gamemap : map) {\n\n\t\t\t\t\tfor (String cel : gamemap) {\n\t\t\t\t\t\toutput += cel;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(output);\n\t\t\t\t\toutput = \"\";\n\t\t\t\t}\n\n\t\t\t}\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n\t//???????????????????????????????????????\n\tpublic static String[][] command(String[][] map, String[] comm) {\n\n\t\tint dep = 0;\n\t\tint wid = 0;\n\t\tString player = \"\";\n\t\tString[][] playmap;\n\t\tString[] command;\n\n\t\tplaymap = map;\n\t\tcommand = comm;\n\n\t\t\t//?????????????????¨???????????????\n\t\tfor (int i = 0; i < playmap.length; i++) {\n\t\t\tif (player.equals(\"\")) {\n\n\t\t\t\tfor (int j = 0; j < playmap[0].length; j++) {\n\t\t\t\t\t//?????????????????§??????\n\t\t\t\t\tif (playmap[i][j].equals(\"^\")) {\n\t\t\t\t\t\tplayer = \"^\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"v\")) {\n\t\t\t\t\t\tplayer = \"v\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\">\")) {\n\t\t\t\t\t\tplayer = \">\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"<\")) {\n\t\t\t\t\t\tplayer = \"<\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//?????????????????????\n\t\tfor (int i = 0; i < command.length; i++) {\n\t\t\t//??????????????§????????????\n\t\t\tswitch (command[i]) {\n\t\t\tcase \"U\":\n\t\t\t\tplaymap[dep][wid] = \"^\";\n\t\t\t\tplayer = \"^\";\n\t\t\t\tif (dep != 0 && playmap[dep - 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep - 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tplaymap[dep][wid] = \"v\";\n\t\t\t\tplayer = \"v\";\n\t\t\t\tif (dep != playmap.length - 1 && playmap[dep + 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep + 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"R\":\n\t\t\t\tplaymap[dep][wid] = \">\";\n\t\t\t\tplayer = \">\";\n\t\t\t\tif (wid != playmap[0].length - 1 && playmap[dep][wid + 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid + 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tplaymap[dep][wid] = \"<\";\n\t\t\t\tplayer = \"<\";\n\t\t\t\tif (wid != 0 && playmap[dep][wid - 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid - 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\t//???????????????????????´???\n\t\t\t\tif (player.equals(\"^\")) {\n\t\t\t\t\tint count = dep;\n\t\t\t\t\tfor (int k = 0; k <= dep; k++) {\n\t\t\t\t\t\tif (playmap[count][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[count][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"v\")) {\n\t\t\t\t\tfor (int k = dep; k < playmap.length; k++) {\n\t\t\t\t\t\tif (playmap[k][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[k][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\">\")) {\n\t\t\t\t\tfor (int k = wid; k < playmap[0].length; k++) {\n\t\t\t\t\t\tif (playmap[dep][k].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][k] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][k].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"<\")) {\n\t\t\t\t\tint count = wid;\n\t\t\t\t\tfor (int k = 0; k <= wid; k++) {\n\t\t\t\t\t\tif (playmap[dep][count].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][count] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][count].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"othercCommand\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn playmap;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = null;\n\n\t\tsc = new Scanner(System.in);\n\t\ttry {\n\n\t\t\t//???????????°???????????????\n\t\t\tint input = Integer.parseInt(sc.next());\n\t\t\tfor (int i = 0; i < input; i++) {\n\n\t\t\t\t//??????????????????\n\t\t\t\tint depth = sc.nextInt();\n\t\t\t\tint width = sc.nextInt();\n\t\t\t\tString[][] map = new String[depth][width];\n\t\t\t\tString line = sc.nextLine();\n\n\t\t\t\tfor (int j = 0; j < map.length; j++) {\n\t\t\t\t\t//?????????????????????\n\t\t\t\t\tline = sc.nextLine();\n\t\t\t\t\tString[] list = line.split(\"\");\n\t\t\t\t\t//????????????????´???????\n\t\t\t\t\tfor (int k = 0; k < map[0].length; k++) {\n\t\t\t\t\t\tmap[j][k] = list[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//?????????????????????\n\t\t\t\tint commNum = Integer.parseInt(sc.nextLine());\n\t\t\t\tline = sc.nextLine();\n\t\t\t\tString[] command = line.split(\"\");\n\n\t\t\t\tmap = command(map,command);\n\t\t\t\tfor (String[] gamemap : map) {\n\t\t\t\t\tfor (String cel : gamemap) {\n\t\t\t\t\t\tSystem.out.print(cel);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\n\t\t\t\tif (i != input - 1) {\n\t\t\t\t\tSystem.out.println(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tsc.close();\n\t\t}\n\t}\n\t//???????????????????????????????????????\n\tpublic static String[][] command(String[][] map, String[] comm) {\n\n\t\tint dep = 0;\n\t\tint wid = 0;\n\t\tString player = \"\";\n\t\tString str;\n\t\tString[][] playmap;\n\t\tString[] command;\n\n\t\tplaymap = map;\n\t\tcommand = comm;\n\n\t\t\t//?????????????????¨???????????????\n\t\tfor (int i = 0; i < playmap.length; i++) {\n\t\t\tif (player.equals(\"\")) {\n\n\t\t\t\tfor (int j = 0; j < playmap[0].length; j++) {\n\t\t\t\t\t//?????????????????§??????\n\t\t\t\t\tif (playmap[i][j].equals(\"^\")) {\n\t\t\t\t\t\tplayer = \"^\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"v\")) {\n\t\t\t\t\t\tplayer = \"v\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\">\")) {\n\t\t\t\t\t\tplayer = \">\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//???\n\t\t\t\t\tif (playmap[i][j].equals(\"<\")) {\n\t\t\t\t\t\tplayer = \"<\";\n\t\t\t\t\t\tdep = i;\n\t\t\t\t\t\twid = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//?????????????????????\n\t\tfor (int i = 0; i < command.length; i++) {\n\t\t\t//??????????????§????????????\n\t\t\tswitch (command[i]) {\n\t\t\tcase \"U\":\n\t\t\t\tplaymap[dep][wid] = \"^\";\n\t\t\t\tplayer = \"^\";\n\t\t\t\tif (dep != 0 && playmap[dep - 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep - 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tplaymap[dep][wid] = \"v\";\n\t\t\t\tplayer = \"v\";\n\t\t\t\tif (dep != playmap.length - 1 && playmap[dep + 1][wid].equals(\".\")) {\n\t\t\t\t\tplaymap[dep + 1][wid] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\tdep++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"R\":\n\t\t\t\tplaymap[dep][wid] = \">\";\n\t\t\t\tplayer = \">\";\n\t\t\t\tif (wid != playmap[0].length - 1 && playmap[dep][wid + 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid + 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tplaymap[dep][wid] = \"<\";\n\t\t\t\tplayer = \"<\";\n\t\t\t\tif (wid != 0 && playmap[dep][wid - 1].equals(\".\")) {\n\t\t\t\t\tplaymap[dep][wid - 1] = playmap[dep][wid];\n\t\t\t\t\tplaymap[dep][wid] = \".\";\n\t\t\t\t\twid--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\t//???????????????????????´???\n\t\t\t\tif (player.equals(\"^\")) {\n\t\t\t\t\tint count = dep;\n\t\t\t\t\tfor (int k = 0; k <= dep; k++) {\n\t\t\t\t\t\tif (playmap[count][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[count][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"v\")) {\n\t\t\t\t\tfor (int k = dep; k < playmap.length; k++) {\n\t\t\t\t\t\tif (playmap[k][wid].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[k][wid] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[k][wid].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\">\")) {\n\t\t\t\t\tfor (int k = wid; k < playmap[0].length; k++) {\n\t\t\t\t\t\tif (playmap[dep][k].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][k] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][k].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//???????????????????????´???\n\t\t\t\telse if (player.equals(\"<\")) {\n\t\t\t\t\tint count = wid;\n\t\t\t\t\tfor (int k = 0; k <= wid; k++) {\n\t\t\t\t\t\tif (playmap[dep][count].equals(\"*\")) {\n\t\t\t\t\t\t\tplaymap[dep][count] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if (playmap[dep][count].equals(\"#\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"othercCommand\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn playmap;\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0){\n\t\t\t\tSystem.out.println();\n\t\t\t\t\n\t\t\t}\n\t\t} // for?????????????????????\n\t\t\t// ????????°??????????????????\n\t\t// sc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int height;\n\tstatic int width;\n\tstatic char unit[][];\n\tstatic char command[];\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner scanner = new Scanner(System.in);\n\t\t// データセット数\n\t\tint count = Integer.parseInt(scanner.nextLine());\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\t// 高さと幅の入力\n\t\t\theight = scanner.nextInt();\n\t\t\twidth = scanner.nextInt();\n\t\t\tString space = scanner.nextLine();\n\n\t\t\t// マップを配列unitに格納\n\t\t\tunit = new char[height][width];\n\t\t\tfor (int line = 0; line < height; line++) {\n\t\t\t\tString unitline = scanner.nextLine();\n\t\t\t\tfor (int calum = 0; calum < width; calum++) {\n\t\t\t\t\tunit[line][calum] = unitline.charAt(calum);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 操作列の長さと操作列\n\t\t\tint ordernum = scanner.nextInt();\n\t\t\tString space2 = scanner.nextLine();\n\t\t\tString order = scanner.nextLine();\n\t\t\tcommand = new char[ordernum];\n\t\t\t// 操作列を配列commandに格納\n\t\t\tfor (int index = 0; index < ordernum; index++) {\n\t\t\t\tcommand[index] = order.charAt(index);\n\t\t\t}\n\n\t\t\tfor (int index = 0; index < ordernum; index++) {\n\t\t\t\tflag: for (int line = 0; line < height; line++) {\n\t\t\t\t\tfor (int calum = 0; calum < width; calum++) {\n\t\t\t\t\t\tif (unit[line][calum] == '^' || unit[line][calum] == '<' ||\n\t\t\t\t\t\t\t\tunit[line][calum] == '>' || unit[line][calum] == 'v') {\n\n\t\t\t\t\t\t\tswitch (command[index]) {\n\t\t\t\t\t\t\tcase 'U':\n\t\t\t\t\t\t\t\tif (line == 0) {\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '^';\n\t\t\t\t\t\t\t\t} else if (line != 0 && unit[line - 1][calum] == '.') {\n\t\t\t\t\t\t\t\t\tunit[line - 1][calum] = '^';\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '.';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '^';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'D':\n\t\t\t\t\t\t\t\tif (line == height - 1) {\n\t\t\t\t\t\t\t\t\tunit[line][calum] = 'v';\n\t\t\t\t\t\t\t\t} else if (line != height - 1\n\t\t\t\t\t\t\t\t\t\t&& unit[line + 1][calum] == '.') {\n\t\t\t\t\t\t\t\t\tunit[line + 1][calum] = 'v';\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '.';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tunit[line][calum] = 'v';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\t\tif (calum == 0) {\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '<';\n\t\t\t\t\t\t\t\t} else if (calum != 0 && unit[line][calum - 1] == '.') {\n\t\t\t\t\t\t\t\t\tunit[line][calum - 1] = '<';\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '.';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '<';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\t\tif (calum == width - 1) {\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '>';\n\t\t\t\t\t\t\t\t} else if (calum != width - 1\n\t\t\t\t\t\t\t\t\t\t&& unit[line][calum + 1] == '.') {\n\t\t\t\t\t\t\t\t\tunit[line][calum + 1] = '>';\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '.';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tunit[line][calum] = '>';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'S':\n\t\t\t\t\t\t\t\tfire(line, calum);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int line = 0; line < height; line++) {\n\t\t\t\tfor (int calum = 0; calum < width; calum++) {\n\t\t\t\t\tif (calum == width - 1) {\n\t\t\t\t\t\tSystem.out.println(unit[line][calum]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.print(unit[line][calum]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i !=count - 1 ) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\t// fireメソッド for文で破壊できる壁などの判定、実行\n\tstatic void fire(int a, int b) {\n\t\tif (unit[a][b] == '^') {\n\t\t\tfor (int shell = a - 1; shell >= 0; shell--) {\n\t\t\t\tif (unit[shell][b] == '*') {\n\t\t\t\t\tunit[shell][b] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (unit[shell][b] == '#' || shell == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (unit[shell][b] == '-') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (unit[a][b] == 'v') {\n\t\t\tfor (int shell = a + 1; shell < height; shell++) {\n\t\t\t\tif (unit[shell][b] == '*') {\n\t\t\t\t\tunit[shell][b] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (unit[shell][b] == '#' || shell == height - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (unit[shell][b] == '-') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (unit[a][b] == '<') {\n\t\t\tfor (int shell = b - 1; shell >= 0; shell--) {\n\t\t\t\tif (unit[a][shell] == '*') {\n\t\t\t\t\tunit[a][shell] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (unit[a][shell] == '#' || shell == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (unit[a][shell] == '-') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (unit[a][b] == '>') {\n\t\t\tfor (int shell = b + 1; shell < width; shell++) {\n\t\t\t\tif (unit[a][shell] == '*') {\n\t\t\t\t\tunit[a][shell] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (unit[a][shell] == '#' || shell == width - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (unit[a][shell] == '-') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\t\t\t// ??????4 6 ???????????¢??????????????°???????????¢??????????´?????????????????????°\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\t// ???????????????\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], 'W');\n\t\t\t}\n\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw + 1]) > -1) {\n\t\t\t\t\t\t//????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map, game_Map[mh][mw + 1], new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\ttank.command(cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\ttank.last_tankLocate();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n}// ???????????????????????????????????????\n\nclass Tank {\n\n\t/**\n\t * ?????????\n\t */\n\tprivate char[][] map;\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/*\n\t * ????????????????????????\n\t */\n\tTank(char[][] map_info, char tank_dir, int[] tank_pos) {\n\t\tthis.dir = tank_dir;\n\t\tthis.map = map_info;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/*\n\t * ?§??????????\n\t */\n\tHashMap<Character, Character> move_Cmd = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t/*\n\t * ?§??????¢???\n\t */\n\tHashMap<Character, int[]> move_Dir = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ???????????????????????°????????????\n\tvoid command(char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\tmove_tank(cmd);\n\t\t} else {\n\t\t\tcannon_Shot();\n\t\t}\n\t}\n\n\t/**\n\t * <pre>\n\t * ?????????????????????\n\t * ????????¬?????¬????£??????¶????????£???????????°?????????\n\t * ?????????????£??????°?????????\n\t * ????????°??????????????¨??§?????£????????????????¶????\n\t * </pre>\n\t *\n\t * @param shell\n\t *            ??????\n\t */\n\tprivate void cannon_Shot() {\n\t\t//???????????????????¨????\n\t\tint[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\twhile (true) {\n\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\tcase '.':\n\t\t\tcase '-':\n\t\t\t\tcontinue;\n\t\t\t\t//??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\tcase '*':\n\t\t\t\tmap[shell[0]][shell[1]] = '.';\n\t\t\tcase '#':\n\t\t\t\t//??????????£???¨??¶????????£????????????????¶????\n\t\t\tcase 'W':\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t}// cannon_Shoot????????????????????????\n\n\t/**\n\t * <pre>\n\t *?????????????§????\n\t *\n\t *???????????°???????§??????????\n\t *???????????¬??????????????????????????£????§???????????????¨?????????\n\t * </pre>\n\t *\n\t * @param cmd\n\t *            ?????¬??????????????????\n\t * @param move\n\t *            ??????????§????\n\t */\n\tprivate void move_tank(char cmd) {\n\n\t\tthis.dir = move_Cmd.get(cmd);\n\t\tint[] next = new int[] { this.pos[0], this.pos[1] };\n\t\tnext[0] += move_Dir.get(this.dir)[0];\n\t\tnext[1] += move_Dir.get(this.dir)[1];\n\t\tif (map[next[0]][next[1]] == '.') {\n\t\t\tthis.pos[0] = next[0];\n\t\t\tthis.pos[1] = next[1];\n\t\t}\n\t}// move_tank????????????????????????\n\n\tvoid last_tankLocate() {\n\t\t// ?????????????????¨??°?????°????????¨?¨???????\n\t\tmap[this.pos[0]][this.pos[1]] = this.dir;\n\t}\n\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// ?????????????§???????????????????\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ????????????????????????\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tTank2[][] game_Map = new Tank2[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank2 tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], new Tank2('W'));\n\t\t\t}\n\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (game_Map[mh][mw + 1].getMap_info() == '^' || game_Map[mh][mw + 1].getMap_info() == 'v'\n\t\t\t\t\t\t\t|| game_Map[mh][mw + 1].getMap_info() == '<' || game_Map[mh][mw + 1].getMap_info() == '>') {\n\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank2(game_Map[mh][mw + 1].getMap_info(), new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = new Tank2('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\tcommand(tank, game_Map, cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ??????????????£????§?????????????????????????????????????\n\t *\n\t * @param game_Map\n\t * @param tank\n\t *\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void command(Tank2 tank, Tank2[][] game_Map, char cmd) {\n\t\t// ?§????\n\t\tif (cmd != 'S') {\n\t\t\t// ??????????????±?????????\n\t\t\ttank.setDir(tank.getMove_Cmd().get(cmd));\n\t\t\tint[] next = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tnext[0] += tank.getMove_Dir().get(tank.getDir())[0];\n\t\t\tnext[1] += tank.getMove_Dir().get(tank.getDir())[1];\n\t\t\t// ?????°???????§??????????\n\t\t\tif (game_Map[next[0]][next[1]].getMap_info() == '.') {\n\t\t\t\ttank.setPos(next);\n\t\t\t}\n\t\t\t// ??????\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\twhile (true) {\n\t\t\t\t// ????????????????????¢\n\t\t\t\tshell[0] += tank.getMove_Dir().get(tank.getDir())[0];\n\t\t\t\tshell[1] += tank.getMove_Dir().get(tank.getDir())[1];\n\t\t\t\tswitch (game_Map[shell[0]][shell[1]].getMap_info()) {\n\t\t\t\tcase '.':\n\t\t\t\tcase '-':\n\t\t\t\t\tcontinue;\n\t\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\t\tcase '*':\n\t\t\t\t\tgame_Map[shell[0]][shell[1]] = new Tank2('.');\n\t\t\t\tcase '#':\n\t\t\t\t\t// ??????????£???¨??¶????????£????????????????¶????\n\t\t\t\tcase 'W':\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}// command????????????????????????\n\n\tprivate static void last_tankLocate(Tank2 tank, Tank2[][] game_Map) {\n\t\t// ?????????????????¨??°?????°????????¨?¨???????\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Tank2(tank.getDir());\n\n\t}// last_tankLocate????????????????????????\n}\n\nclass Tank2 {\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] pos) {\n\t\tthis.pos = pos;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char dir) {\n\t\tthis.dir = dir;\n\t}\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\t/*\n\t * ????????????????????????\n\t */\n\tpublic Tank2(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Tank2(char dir, int[] tank_pos) {\n\t\tthis.dir = dir;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/*\n\t * ?§??????????\n\t */\n\tprivate HashMap<Character, Character> move_Cmd = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t/*\n\t * ?§??????¢???\n\t */\n\tprivate HashMap<Character, int[]> move_Dir = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\tpublic HashMap<Character, Character> getMove_Cmd() {\n\t\treturn move_Cmd;\n\t}\n\n\t// public void setMove_Cmd(HashMap<Character, Character> move_Cmd) {\n\t// this.move_Cmd = move_Cmd;\n\t// }\n\n\tpublic HashMap<Character, int[]> getMove_Dir() {\n\t\treturn move_Dir;\n\t}\n\n\t// public void setMove_Dir(HashMap<Character, int[]> move_Dir) {\n\t// this.move_Dir = move_Dir;\n\t// }\n\n}// tank2 ?????????????????????"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tint t = sc.nextInt();\n\t\tfor (int tc = 0; tc < t; tc++) {\n\t\t\tif (tc != 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tint h = sc.nextInt() + 2;\n\t\t\tint w = sc.nextInt() + 2;\n\n\t\t\tString ext = \"###########\";\n\t\t\text = ext + ext + ext + ext + ext;\n\n\t\t\tchar map[][] = new char[h][w];\n\n\t\t\tint dirc = -1;\n\t\t\tint x = -1;\n\t\t\tint y = -1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString buffer = \"\";\n\t\t\t\tif (i == 0 || i == h - 1) {\n\t\t\t\t\tbuffer = ext;\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = \"#\" + sc.next() + \"#\";\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = buffer.charAt(j);\n\t\t\t\t\tif (\"^v<>\".indexOf(map[i][j]) != -1) {\n\t\t\t\t\t\tdirc = \"^v<>\".indexOf(map[i][j]);\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sn = sc.nextInt();\n\t\t\tString sec = sc.next();\n\t\t\tint dx[] = { -1, 1, 0, 0 };\n\t\t\tint dy[] = { 0, 0, -1, 1 };\n\n\t\t\tString move = \"UDLR\";\n\t\t\tfor (int i = 0; i < sn; i++) {\n\t\t\t\tchar com = sec.charAt(i);\n\t\t\t\tif (move.indexOf(com) != -1) {\n\t\t\t\t\tdirc = move.indexOf(com);\n\t\t\t\t\tif (map[x + dx[dirc]][y + dy[dirc]] == '.') {\n\t\t\t\t\t\tx += dx[dirc];\n\t\t\t\t\t\ty += dy[dirc];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint nx = x;\n\t\t\t\t\tint ny = y;\n\t\t\t\t\tString kabe = \"#*\";\n\t\t\t\t\tfor (; kabe.indexOf(map[nx][ny]) == -1;) { // dangan\n\t\t\t\t\t\tnx += dx[dirc];\n\t\t\t\t\t\tny += dy[dirc];\n\t\t\t\t\t}\n\t\t\t\t\tif (kabe.indexOf(map[nx][ny]) == 1) {\n\t\t\t\t\t\tmap[nx][ny] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmap[x][y] = \"^v<>\".toCharArray()[dirc];\n\n\t\t\tfor (int i = 1; i < h - 1; i++) {\n\t\t\t\tfor (int j = 1; j < w - 1; j++) {\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\n\t\t\t// 入力回数分ゲームをする\n\t\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t\t// マップの高さ\n\t\t\t\theight = sc.nextInt();\n\t\t\t\t// マップの幅\n\t\t\t\twidth = sc.nextInt();\n\n\t\t\t\t// マップのインスタンスを作る\n\t\t\t\tmap map = new map();\n\t\t\t\t// 戦車のインスタンスを作る\n\t\t\t\ttank tank = new tank();\n\t\t\t\tmap.setMap(height, width);\n\n\t\t\t\tString line = null;\n\t\t\t\t// マップ作成\n\t\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t\t// マップ一列\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\t// 一文字ずつに分解\n\t\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t\t//\n\t\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t\t// マップを作る\n\t\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint command_number = 0;\n\t\t\t\tString command_attack = \"\";\n\t\t\t\t// コマンド入力回数\n\n\t\t\t\tcommand_number = sc.nextInt();\n\n\t\t\t\t// コマンドの文字列\n\t\t\t\tchar[] command_at = null;\n\n\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t\t// コマンド回数分まわす\n\t\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t\t// タンクの現在位置を把握\n\t\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t\t// 砲弾発射だったら\n\t\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 移動の場合\n\t\t\t\t\t\tmap.move_tank(tank.getNow_height(),\n\t\t\t\t\t\t\t\ttank.getNow_width(),\n\t\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// リストにできたマップを格納\n\t\t\t\tmap_list.add(map);\n\t\t\t}\n\t\t\t// 結果を出力\n\t\t\tfor (map obj : map_list) {\n\t\t\t\tobj.out_map();\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n                aryBattleArea[j] = sc.next().toCharArray();\n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            for( int x = 0 ; x < aryBattleArea.length ; x++ ){\n                for( int y = 0 ; y < aryBattleArea[i].length ; y++ ){\n                    System.out.print(aryBattleArea[x][y]);\n                }\n                System.out.println();\n            }\n            \n        }\n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                                continue;\n                            \n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    private void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n            \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\t\t\t// ??????4 6 ???????????¢??????????????°???????????¢??????????´?????????????????????°\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\t// ???????????????\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], 'W');\n\t\t\t}\n\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw + 1]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map, game_Map[mh][mw + 1], new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\ttank.command(cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\ttank.last_tankLocate();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n}// ???????????????????????????????????????\n\nclass Tank {\n\n\t/**\n\t * ?????????\n\t */\n\tprivate char[][] map;\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/*\n\t * ????????????????????????\n\t */\n\tTank(char[][] map_info, char tank_dir, int[] tank_pos) {\n\t\tthis.dir = tank_dir;\n\t\tthis.map = map_info;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/*\n\t * ?§??????????\n\t */\n\tHashMap<Character, Character> move_Cmd = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t/*\n\t * ?§??????¢???\n\t */\n\tHashMap<Character, int[]> move_Dir = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t/**\n\t * ??????????????£????§?????????????????????????????????????\n\t *\n\t * @param cmd\n\t *            ??????\n\t */\n\tvoid command(char cmd) {\n\t\t// ?§????\n\t\tif (cmd != 'S') {\n\t\t\t// ??????????????±?????????\n\t\t\tthis.dir = move_Cmd.get(cmd);\n\t\t\tint[] next = new int[] { this.pos[0], this.pos[1] };\n\t\t\tnext[0] += move_Dir.get(this.dir)[0];\n\t\t\tnext[1] += move_Dir.get(this.dir)[1];\n\t\t\t// ?????°???????§??????????\n\t\t\tif (map[next[0]][next[1]] == '.') {\n\t\t\t\tthis.pos[0] = next[0];\n\t\t\t\tthis.pos[1] = next[1];\n\t\t\t}\n\t\t\t// ??????\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\t\twhile (true) {\n\t\t\t\t// ????????????????????¢\n\t\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\t\tcase '.':\n\t\t\t\tcase '-':\n\t\t\t\t\tcontinue;\n\t\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\t\tcase '*':\n\t\t\t\t\tmap[shell[0]][shell[1]] = '.';\n\t\t\t\tcase '#':\n\t\t\t\t\t// ??????????£???¨??¶????????£????????????????¶????\n\t\t\t\tcase 'W':\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}// command????????????????????????\n\n\t// ?????????????????¨??°?????°????????¨?¨???????\n\tvoid last_tankLocate() {\n\n\t\tmap[this.pos[0]][this.pos[1]] = this.dir;\n\t}// last_tankLocate????????????????????????\n\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\t//???????????????????????°??????\n\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\t\t\t//?????£??????????????§??????????????????????´?\n\t\t\tint[] aryArea = {intHeight,intWidth};\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tString[] fieldLine = new String[intWidth];\n\t\t\t\tfieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond,aryArea);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\n\t\t\t//?????£??????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(deta != setNum-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£??????????????§???????????????????????????*/\n\t\tprivate int[] aryArea;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond ,int[] aryArea){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.aryArea = aryArea;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????£????????????????????¨???????????£??\\\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\t\t\t\t//System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\t\t\t\t//System.out.println(\"tank:\" + j + i);\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\t\t\t//?????£??????????????§??????\n\t\t\tint intHeight = aryArea[0];\n\t\t\tint intWidth = aryArea[1];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map3> map_list = new ArrayList<map3>();\n\t\t//\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length =0;\n\t\t// 入力の回数\n\t\twhile(sc.hasNext()){\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap3 map = new map3();\n\t\t\tmap.setMap(height, width);\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank3 tank = new tank3();\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// コマンド入力回数\n\t\t\tint command_number = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\tString command_attack = sc.next();\n\t\t\t// ひとつずつ配列に入れる\n\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\tmap_list.get(f).out_map();\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nclass tank3 {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\nclass map3 {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tclass Island {\n\n\t\tint[][] map = new int[12][12];\n\t\tint num = 2;\n\n\t\tpublic Island(int[][] map) {\n\t\t\tthis.map = map;\n\t\t}\n\n\t\tprivate void label(int row, int column) {\n\t\t\tmap[row][column] = num;\n\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\tif(i==0) {\n\t\t\t\t\tif(map[row][column-1] == 1) label(row, column-1);\n\t\t\t\t} else if(i == 1) {\n\t\t\t\t\tif(map[row-1][column] == 1) label(row-1, column);\n\t\t\t\t} else if(i == 2) {\n\t\t\t\t\tif(map[row][column+1] == 1) label(row, column+1);\n\t\t\t\t} else if(i == 3) {\n\t\t\t\t\tif(map[row+1][column] == 1) label(row+1, column);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tfor(int i=0; i<12; i++) {\n\t\t\t\tfor(int j=0; j<12; j++) {\n\t\t\t\t\tif(map[i][j] == 1) {\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tlabel(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn num-2;\n\t\t}\n\n\t}\n\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(sc.hasNext()) {\n\n\t\t\tint[][] map = new int[12][12];\n\n\t\t\t// 外を埋める\n\t\t\t/*\n\t\t\tfor(int i=0; i<14; i++) {\n\t\t\t\tmap[0][i] = 0;\n\t\t\t\tmap[13][i] = 0;\n\t\t\t\tmap[i][0] = 0;\n\t\t\t\tmap[i][13] = 0;\n\t\t\t}\n\t\t\t*/\n\n\t\t\tfor(int i=1; i<13; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=1; j<13; j++) {\n\t\t\t\t\tmap[i][j] = Integer.parseInt(line.split(\"\")[j-1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIsland island = new Main().new Island(map);\n\t\t\tSystem.out.println(island.count());\n\t\t}\n\n\t\tsc.close();\n\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t} // for?????????????????????\n\t\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tfor(int i = 0; i < t; i++){\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tString[][] map = new String[h][w];\n\t\t\tint[] x = new int[2];\n\t\t\tsc.nextLine();\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tfor(int k = 0; k < w; k++){\n\t\t\t\t\tmap[j][k] = String.valueOf(s.charAt(k));\n\t\t\t\t\tString _s = map[j][k];\n\t\t\t\t\tif(_s.equals(\"^\") || _s.equals(\"v\") || _s.equals(\"<\") || _s.equals(\">\")){\n\t\t\t\t\t\tx[0] = j;\n\t\t\t\t\t\tx[1] = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tString[] command = new String[n];\n\t\t\tsc.nextLine();\n\t\t\tString s = sc.nextLine();\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcommand[j] = String.valueOf(s.charAt(j));\n\t\t\t}\n\t\t\tplay(map, x, command);\n\t\t\tif(i < t-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic void play(String[][] map, int[] x, String[] command){\n\t\tfor(int i = 0; i < command.length; i++){\n\t\t\tif(command[i].equals(\"S\")){\n\t\t\t\tshoot(map, x);\n\t\t\t}else{\n\t\t\t\tmove(map, x, command[i]);\n\t\t\t}\n\t\t}\n\t\tprintMap(map);\n\t}\n\tstatic void move(String[][] map,int[] x, String s){\n\t\tint[] v = new int[2];\n\t\tif(s.equals(\"U\")){\n\t\t\tv[0] = -1;\n\t\t}else if(s.equals(\"D\")){\n\t\t\tv[0] = 1;\n\t\t}else if(s.equals(\"L\")){\n\t\t\tv[1] = -1;\n\t\t}else{\n\t\t\tv[1] = 1;\n\t\t}\n\t\tint[] nx = {x[0]+v[0], x[1]+v[1]};\n\t\tif(isInMap(map, nx) && map[nx[0]][nx[1]].equals(\".\")){\n\t\t\tmap[nx[0]][nx[1]] = v2p(v);\n\t\t\tmap[x[0]][x[1]] = \".\";\n\t\t\tx[0] = nx[0];\n\t\t\tx[1] = nx[1];\n\t\t}else{\n\t\t\tmap[x[0]][x[1]] = v2p(v);\n\t\t}\n\n\t}\n\tstatic String v2p(int[] v){\n\t\tif(v[0] == 0){\n\t\t\tif(v[1] == 1){\n\t\t\t\treturn \">\";\n\t\t\t}else{\n\t\t\t\treturn \"<\";\n\t\t\t}\n\t\t}else if(v[0] == -1){\n\t\t\treturn \"^\";\n\t\t}else{\n\t\t\treturn \"v\";\n\t\t}\n\t}\n\tstatic void shoot(String[][] map, int[] x){\n\t\tint[] v = new int[2];\n\t\tString s = map[x[0]][x[1]];\n\t\tif(s.equals(\"^\")){\n\t\t\tv[0] = -1;\n\t\t}else if(s.equals(\"v\")){\n\t\t\tv[0] = 1;\n\t\t}else if(s.equals(\"<\")){\n\t\t\tv[1] = -1;\n\t\t}else{\n\t\t\tv[1] = 1;\n\t\t}\n\t\tint[] bx = {x[0], x[1]};\n\t\twhile(isInMap(map, bx) && (!map[bx[0]][bx[1]].equals(\"*\") && !map[bx[0]][bx[1]].equals(\"#\"))){\n\t\t\tbx[0] += v[0];\n\t\t\tbx[1] += v[1];\n\t\t}\n\t\tif(isInMap(map, bx)){\n\t\t\tif(map[bx[0]][bx[1]].equals(\"*\")){\n\t\t\t\tmap[bx[0]][bx[1]] = \".\";\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean isInMap(String[][] map, int[] x){\n\t\treturn 0 <= x[0] && x[0] < map.length && 0 <= x[1] && x[1] < map[0].length;\n\t}\n\tstatic void printMap(String[][] map){\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tfor(int j = 0; j < map[0].length; j++){\n\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic class Tank {\n\t\t// 戦車の行座標\n\t\tprivate int tankRow;\n\n\t\t// 戦車の列座標\n\t\tprivate int tankColumn;\n\n\t\t// 戦車の向き\n\t\tprivate String tankDilection;\n\n\t\t// フィールド情報\n\t\tString[][] inputFirld;\n\n\t\t// 戦車の行座標のゲッター・セッター\n\t\tint getTankRow() {\n\t\t\treturn tankRow;\n\t\t}\n\n\t\tvoid setTankRow(int row) {\n\t\t\ttankRow = row;\n\t\t}\n\n\t\t// 戦車の列座標のゲッター・セッター\n\t\tint getTankColumn() {\n\t\t\treturn tankColumn;\n\t\t}\n\n\t\tvoid setTankColumn(int column) {\n\t\t\ttankColumn = column;\n\t\t}\n\n\t\t// 戦車の向きのゲッター・セッター\n\t\tString getTankDilection() {\n\t\t\treturn tankDilection;\n\t\t}\n\n\t\tvoid setTankDilection(String dilection) {\n\t\t\ttankDilection = dilection;\n\t\t}\n\n\t\t// フィールド情報\n\t\tString[][] getInputFirld() {\n\t\t\treturn inputFirld;\n\t\t}\n\n\t\tvoid setInputFirld(String[][] map) {\n\t\t\tinputFirld = map;\n\t\t}\n\n\t\t// 戦車のコンストラクタ\n\t\tTank(int row, int column, String[][] map) {\n\n\t\t\t// フィールドの情報を取得\n\t\t\tsetInputFirld(map);\n\n\t\t\t// 戦車の位置を検索\n\t\t\t for (int rowi = 0; rowi < row; rowi++) {\n\t\t\t\tfor (int columni = 0; columni < column; columni++) {\n\n\t\t\t\t\t// 戦車上向き\n\t\t\t\t\tif (map[rowi][columni].equals(\"^\")) {\n\t\t\t\t\t\t// 戦車の行座標\n\t\t\t\t\t\tsetTankRow(rowi);\n\t\t\t\t\t\t// 戦車の列座標\n\t\t\t\t\t\tsetTankColumn(columni);\n\t\t\t\t\t\t// 戦車の向き\n\t\t\t\t\t\tsetTankDilection(\"^\");\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\t// 戦車下向き\n\t\t\t\t\t} else if (map[rowi][columni].equals(\"v\")) {\n\t\t\t\t\t\t// 戦車の行座標\n\t\t\t\t\t\tsetTankRow(rowi);\n\t\t\t\t\t\t// 戦車の列座標\n\t\t\t\t\t\tsetTankColumn(columni);\n\t\t\t\t\t\t// 戦車の向き\n\t\t\t\t\t\tsetTankDilection(\"v\");\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\t// 戦車左向き\n\t\t\t\t\t} else if (map[rowi][columni].equals(\"<\")) {\n\t\t\t\t\t\t// 戦車の行座標\n\t\t\t\t\t\tsetTankRow(rowi);\n\t\t\t\t\t\t// 戦車の列座標\n\t\t\t\t\t\tsetTankColumn(columni);\n\t\t\t\t\t\t// 戦車の向き\n\t\t\t\t\t\tsetTankDilection(\"<\");\n\t\t\t\t\t\tbreak ;\n\n\t\t\t\t\t\t// 戦車右向き\n\t\t\t\t\t} else if (map[rowi][columni].equals(\">\")) {\n\t\t\t\t\t\t// 戦車の行座標\n\t\t\t\t\t\tsetTankRow(rowi);\n\t\t\t\t\t\t// 戦車の列座標\n\t\t\t\t\t\tsetTankColumn(columni);\n\t\t\t\t\t\t// 戦車の向き\n\t\t\t\t\t\tsetTankDilection(\">\");\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t// 戦車の向き変更,進行または発射\n\t\tpublic String[][] actionTank(String dilection) {\n\n\t\t\t// 上入力\n\t\t\tif (dilection.equals(\"U\")) {\n\t\t\t\tsetTankDilection(\"^\");\n\t\t\t\tinputFirld[getTankRow()][getTankColumn()] = getTankDilection();\n\n\t\t\t\t// 移動先が範囲内になるとき\n\t\t\t\tif (getTankRow() - 1 >= 0) {\n\t\t\t\t\t// 上のマスが平地ならに上に進む\n\t\t\t\t\tif (inputFirld[getTankRow() - 1][getTankColumn()].equals(\".\")) {\n\n\t\t\t\t\t\t// 戦車のいたマスが平地になり,平地に戦車が進む\n\t\t\t\t\t\tinputFirld[getTankRow()][getTankColumn()] = \".\";\n\t\t\t\t\t\tinputFirld[getTankRow() - 1][getTankColumn()] = getTankDilection();\n\t\t\t\t\t\tsetTankRow(getTankRow() - 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 右入力\n\t\t\t} else if (dilection.equals(\"R\")) {\n\t\t\t\tsetTankDilection(\">\");\n\t\t\t\tinputFirld[getTankRow()][getTankColumn()] = getTankDilection();\n\n\t\t\t\tif (getTankColumn() + 1 < inputFirld[1].length) {\n\t\t\t\t\t// 右のマスが平地ならに右に進む\n\t\t\t\t\tif (inputFirld[getTankRow()][getTankColumn() + 1].equals(\".\")) {\n\n\t\t\t\t\t\t// 戦車のいたマスが平地になり平地に戦車が進む\n\t\t\t\t\t\tinputFirld[getTankRow()][getTankColumn()] = \".\";\n\t\t\t\t\t\tinputFirld[getTankRow()][getTankColumn() + 1] = getTankDilection();\n\t\t\t\t\t\tsetTankColumn(getTankColumn() + 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 下入力\n\t\t\t} else if (dilection.equals(\"D\")) {\n\t\t\t\tsetTankDilection(\"v\");\n\t\t\t\tinputFirld[getTankRow()][getTankColumn()] = getTankDilection();\n\n\t\t\t\tif (getTankRow() + 1 < inputFirld.length) {\n\t\t\t\t\t// 下のマスが平地ならに下に進む\n\t\t\t\t\tif (inputFirld[getTankRow() + 1][getTankColumn()].equals(\".\")) {\n\n\t\t\t\t\t\t// 戦車のいたマスが平地になり平地に戦車が進む\n\t\t\t\t\t\tinputFirld[getTankRow()][getTankColumn()] = \".\";\n\t\t\t\t\t\tinputFirld[getTankRow() + 1][getTankColumn()] = getTankDilection();\n\t\t\t\t\t\tsetTankRow(getTankRow() + 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 左入力\n\t\t\t} else if (dilection.equals(\"L\")) {\n\t\t\t\tsetTankDilection(\"<\");\n\t\t\t\tinputFirld[getTankRow()][getTankColumn()] = getTankDilection();\n\n\t\t\t\tif (getTankColumn() - 1 >= 0) {\n\t\t\t\t\t// 左のマスが平地ならに左に進む\n\t\t\t\t\tif (inputFirld[getTankRow()][getTankColumn() - 1].equals(\".\")) {\n\n\t\t\t\t\t\t// 戦車のいたマスが平地になり平地に戦車が進む\n\t\t\t\t\t\tinputFirld[getTankRow()][getTankColumn()] = \".\";\n\t\t\t\t\t\tinputFirld[getTankRow()][getTankColumn() - 1] = getTankDilection();\n\t\t\t\t\t\tsetTankColumn(getTankColumn() - 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (dilection.equals(\"S\")) {\n\t\t\t\tshotShell(getInputFirld());\n\n\t\t\t}\n\n\t\t\treturn inputFirld;\n\t\t}\n\n\t\tvoid shotShell(String[][] inputFirld) {\n\t\t\t// 戦車が上方向を向いているとき\n\t\t\tif (getTankDilection().equals(\"^\")) {\n\t\t\t\t// 条件式 砲弾の飛ぶ距離\n\t\t\t\tfor (int lengthShell = 1; lengthShell < getTankRow() + 1; lengthShell++) {\n\n\t\t\t\t\t// 砲弾の進行方向にレンガの壁があったとき\n\t\t\t\t\tif (inputFirld[getTankRow() - lengthShell][getTankColumn()].equals(\"*\")) {\n\t\t\t\t\t\tinputFirld[getTankRow() - lengthShell][getTankColumn()] = \".\";\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// 進行方向に鉄の壁があったとき\n\t\t\t\t\t} else if (inputFirld[getTankRow() - lengthShell][getTankColumn()].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 戦車が右を向いているとき\n\t\t\t} else if (getTankDilection().equals(\">\")) {\n\t\t\t\t// 条件式 砲弾の飛ぶ距離\n\t\t\t\tfor (int lengthShell = 1; lengthShell < inputFirld[0].length - getTankColumn(); lengthShell++) {\n\n\t\t\t\t\t// 進行方向にレンガの壁があったとき\n\t\t\t\t\tif (inputFirld[getTankRow()][getTankColumn() + lengthShell].equals(\"*\")) {\n\t\t\t\t\t\tinputFirld[getTankRow()][getTankColumn() + lengthShell] = \".\";\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// 進行方向に鉄の壁があったとき\n\t\t\t\t\t} else if (inputFirld[getTankRow()][getTankColumn() + lengthShell].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 戦車が下を向いているとき\n\t\t\t} else if (getTankDilection().equals(\"v\")) {\n\t\t\t\t// 条件式 砲弾の飛ぶ距離\n\t\t\t\tfor (int lengthShell = 1; lengthShell < inputFirld.length - getTankRow(); lengthShell++) {\n\n\t\t\t\t\t// 進行方向にレンガの壁があったとき\n\t\t\t\t\tif (inputFirld[getTankRow() + lengthShell][getTankColumn()].equals(\"*\")) {\n\t\t\t\t\t\tinputFirld[getTankRow() + lengthShell][getTankColumn()] = \".\";\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// 進行方向に鉄の壁があったとき\n\t\t\t\t\t} else if (inputFirld[getTankRow() + lengthShell][getTankColumn()].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 戦車が左を向いているとき\n\t\t\t} else if (getTankDilection().equals(\"<\")) {\n\t\t\t\t// 条件式 砲弾の飛ぶ距離\n\t\t\t\tfor (int lengthShell = 1; lengthShell < getTankColumn() + 1; lengthShell++) {\n\n\t\t\t\t\t// 進行方向にレンガの壁があったとき\n\t\t\t\t\tif (inputFirld[getTankRow()][getTankColumn() - lengthShell].equals(\"*\")) {\n\t\t\t\t\t\tinputFirld[getTankRow()][getTankColumn() - lengthShell] = \".\";\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// 進行方向に鉄の壁があったとき\n\t\t\t\t\t} else if (inputFirld[getTankRow()][getTankColumn() - lengthShell].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\t// 入力回数\n\t\tint inputNum = scan.nextInt();\n\n\t\t// 入力回数分ループ\n\t\tfor (int playNum = 0; playNum < inputNum; playNum++) {\n\n\t\t\t// 行数を入力\n\t\t\tint row = scan.nextInt();\n\n\t\t\t// 列数を入力\n\t\t\tint column = scan.nextInt();\n\n\t\t\tscan.nextLine();\n\n\t\t\t// マップ(二次元配列)の入力\n\t\t\tString[][] map = new String[row][column];\n\n\t\t\tfor (int rowi = 0; rowi < row; rowi++) {\n\n\t\t\t\tString strLine = scan.nextLine();\n\n\t\t\t\tfor (int columni = 0; columni < column; columni++) {\n\t\t\t\t\tmap[rowi][columni] = String.valueOf(strLine.charAt(columni));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 戦車を作成\n\t\t\tTank tank = new Tank(row, column, map);\n\n\t\t\t// 戦車行動回数\n\t\t\tint commandNum = scan.nextInt();\n\n\t\t\t// 行の空読み\n\t\t\tscan.nextLine();\n\n\t\t\t// 入力コマンド\n\t\t\tString commandTank = scan.nextLine();\n\n\t\t\tfor (int commandTanki = 0; commandTanki < commandNum; commandTanki++) {\n\t\t\t\t// コマンドの入力\n\t\t\t\tmap = tank.actionTank(String.valueOf(commandTank.charAt(commandTanki)));\n\t\t\t}\n\n\t\t\t// 戦車行動後のマップを出力\n\t\t\tfor (int rowi = 0; rowi < row; rowi++) {\n\t\t\t\tfor (int columni = 0; columni < column; columni++) {\n\t\t\t\t\tSystem.out.print(map[rowi][columni]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t\tif (playNum < inputNum - 1) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\t\tscan.close();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "package BattleTown;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class BattleTown {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t// マップの高さ\n\t\t\theight = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\twidth = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap map = new map();\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank tank = new tank();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint command_number = 0;\n\t\t\tString command_attack = \"\";\n\t\t\t// コマンド入力回数\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_number = sc.nextInt();\n\t\t\t}\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; i < command_number; c++) {\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//砲弾発射だったら\n\t\t\t\tif(command_attack.equals(\"S\")){\n\t\t\t\t\t//マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(), tank.getSituation());\n\t\t\t\t}else{\n\t\t\t\t\t//移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(), tank.getSituation());\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (map obj : map_list) {\n\t\t\tobj.out_map();\n\t\t\t// 改行\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(int height, int width, String[][] map) {\n\t\tfor (int h = 0; h < height; h++) {\n\t\t\tfor (int w = 0; w < width; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map[h][w] == val) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\t// マップの高さ\n\tprivate int height = 0;\n\t// マップの幅さ\n\tprivate int width = 0;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t\theight = h;\n\t\twidth = w;\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t//\n\t\t\tfor (int i = 0; i < now_w; i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\tfor (int i = 0; i < (width - 1 - now_w); i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\tfor (int i = 0; i < (height - 1 - now_h); i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\tfor (int i = 0; i < now_h; i++) {\n\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更 現在位置 向き\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w + 1] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\tif (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main (String args[]){\n\n\t\t//??\\??????????????????????????????Scanner???????????§???????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tint i = 0;\n\n\t\tfor(i = 0; i < T; i++){\n\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tchar[][] map = new char[H][W];\n\n\t\t\t//???0??????1??????2??????3\n\t\t\tchar tank;\n\n\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tString line = sc.next();\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tmap[j][k] = line.charAt(k);\n\n\t\t\t\t\tif(map[j][k] == '^' || map[j][k] == 'v' || map[j][k] == '<' || map[j][k] == '>'){\n\t\t\t\t\t\tif(map[j][k] == '^'){\n\t\t\t\t\t\t\ttank = '^';\n\t\t\t\t\t\t}else if(map[j][k] == 'v'){\n\t\t\t\t\t\t\ttank = 'v';\n\t\t\t\t\t\t}else if(map[j][k] == '<'){\n\t\t\t\t\t\t\ttank = '<';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttank = '>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint t = j;\n\t\t\t\t\t\tint y = k;\n\t\t\t\t\t\tBattle BT = new Battle(t,y,tank,map);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint N = sc.nextInt();\n\t\t\tString com = sc.next();\n\t\t\tchar[] command = new char[N];\n\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tBattle.check(command[j] = com.charAt(j));\n\t\t\t}\n\n\t\t\tSystem.out.println(Battle.output());\n\n\t\t\tif(i != T){\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}\n\nclass Battle{\n\tstatic int tate;\n\tstatic int yoko;\n\tstatic char tank;\n\tstatic char[][] map;\n\n\t//????????\\??????\n\tBattle(int t, int y, char tankk, char[][] mapp){\n\t\ttate = t;\n\t\tyoko = y;\n\t\tmap = mapp;\n\t\ttank = tankk;\n\t}\n\n\tpublic static String output(){\n\t\tStringBuffer str = new StringBuffer();\n\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\tstr.append(map[i][j]);\n\t\t\t}\n\t\t\tstr.append(System.getProperty(\"line.separator\"));\n\t\t}\n\t\tString ans = new String(str);\n\t\treturn ans;\n\t}\n\n\tpublic static void check(char command){\n\n\t\tswitch (command){\n\n\t\tcase 'U':\n\t\t\ttank = '^';\n\t\t\tif(tate > 0){\n\t\t\t\tif(map[tate-1][yoko] == '.'){\n\t\t\t\t\ttate = tate - 1;\n\t\t\t\t\tmap[tate][yoko] = '^';\n\t\t\t\t\tmap[tate+1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\ttank = 'v';\n\t\t\tif((map.length - (tate+1)) > 0){\n\t\t\t\tif(map[tate+1][yoko] == '.'){\n\t\t\t\t\ttate = tate + 1;\n\t\t\t\t\tmap[tate][yoko] = 'v';\n\t\t\t\t\tmap[tate-1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\ttank = '<';\n\t\t\tif(yoko > 0){\n\t\t\t\tif(map[tate][yoko-1] == '.'){\n\t\t\t\t\tyoko = yoko - 1;\n\t\t\t\t\tmap[tate][yoko] = '<';\n\t\t\t\t\tmap[tate][yoko+1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\ttank = '>';\n\t\t\tif((map[tate].length - (yoko+1)) > 0){\n\t\t\t\tif(map[tate][yoko+1] == '.'){\n\t\t\t\t\tyoko = yoko + 1;\n\t\t\t\t\tmap[tate][yoko] = '>';\n\t\t\t\t\tmap[tate][yoko-1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tswitch (tank){\n\t\t\tcase '^':\n\t\t\t\tfor(int i = tate; i >= 0; i--){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tfor(int i = tate; i < map.length; i++){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '<':\n\t\t\t\tfor(int i = yoko; i >= 0; i--){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = -1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tfor(int i = yoko; i < map[tate].length; i++){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = map[tate].length +1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 1行目を取得\n\t\tBufferedReader insBR = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString strNum = insBR.readLine();\n\n\t\t// データセット数\n\t\tint DataSetNum = Integer.parseInt(strNum);\n\n\t\t//データセットの数の分、答えがあるので\n\t\t//答えを保存する為、配列を作成し初期化\n\t\tField[] fieldAnswer = new Field[DataSetNum];\n\n\t\t// 判断する回数まわす\n\t\tfor (int i = 0; i < DataSetNum; i++) {\n\n\t\t\t// 2行目取得\n\t\t\tString strLine2 = insBR.readLine();\n\n\t\t\t// 分解\n\t\t\tString[] strLineAry = strLine2.split(\" \");\n\n\t\t\t// マップの高さ\n\t\t\tint intHeight = Integer.parseInt(strLineAry[0]);\n\n\t\t\t// マップの幅\n\t\t\tint intWidth = Integer.parseInt(strLineAry[1]);\n\n\t\t\t// フィールド情報を引数で渡す配列を作成\n\t\t\tchar[][] charBlock = new char[intHeight][intWidth];\n\n\t\t\t// フィールド情報を1列づつ読み込む\n\t\t\tfor (int j = 0; j < intHeight; j++) {\n\n\t\t\t\tString strBlock = insBR.readLine();\n\n\t\t\t\t// 分解\n\t\t\t\tchar[] chBlock = strBlock.toCharArray();\n\n\t\t\t\t// 格納\n\t\t\t\tfor (int k = 0; k < intWidth; k++) {\n\t\t\t\t\tcharBlock[j][k] = chBlock[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// フィールドを作成\n\t\t\tField field = new Field(charBlock);\n\n\t\t\t// 行動がいくつあるか読み込み\n\t\t\tString strLine3 = insBR.readLine();\n\n\t\t\tint ActionNum = Integer.parseInt(strLine3);\n\n\t\t\t// 行動を読み込み\n\t\t\tString strAction = insBR.readLine();\n\n\t\t\t// 分解\n\t\t\tchar chAction[] = strAction.toCharArray();\n\n\t\t\t// 戦車を作成\n\t\t\tTank tank = new Tank(chAction);\n\n\t\t\ttankAction(field, tank);\n\n\t\t\tfieldAnswer[i] = field;\n\n\t\t}\n\n\t\t//出力\n\t\tfor (int i = 0; i < fieldAnswer.length; i++) {\n\t\t\tfieldAnswer[i].fieldPrint();\n\t\t}\n\n\t}\n\n\t/**\n\t * 入力値通り戦車を動かす\n\t * @param field　フィールドのインスタンス\n\t * @param tank　戦車のインスタンス\n\t */\n\tpublic static void tankAction(Field field, Tank tank) {\n\n\t\t// 戦車の位置を把握\n\t\tint[] intPosion = field.LookPosition();\n\n\t\tint ActionNum = tank.getActionNum();\n\n\t\tfor(int i = 0; i < ActionNum; i++) {\n\t\tchar chAction = tank.getAction(i);\n\n\t\tif (chAction == 'S') {\n\n\t\t\t//ポジションを覚えておく\n\t\t\tint intPosionBeforeHeight = intPosion[0];\n\t\t\tint intPosionBeforeWidth= intPosion[1];\n\n\t\t\t//大砲を撃つ\n\t\t\tfield.actionS(intPosion, 0);\n\n\t\t\t//ポジションを覚えておいた場所に戻す\n\t\t\tintPosion[0] = intPosionBeforeHeight;\n\t\t\tintPosion[1] = intPosionBeforeWidth;\n\n\t\t}else if (chAction == 'U') {\n\n\t\t\tintPosion = field.actionU(intPosion);\n\n\t\t}else if (chAction == 'D') {\n\n\t\t\tintPosion = field.actionD(intPosion);\n\n\t\t}else if (chAction == 'R') {\n\n\t\t\tintPosion = field.actionR(intPosion);\n\n\t\t}else if (chAction == 'L') {\n\n\t\t\tintPosion = field.actionL(intPosion);\n\n\t\t}\n\t\t}\n\n\t}\n\n\tpublic static class Field {\n\n\t\tchar[][] Block;\n\n\t\t// 平地\n\t\tchar chFlatland = '.';\n\n\t\t// レンガの壁\n\t\tchar chBrickWall = '*';\n\n\t\t// 鉄の壁\n\t\tchar chWallIron = '#';\n\n\t\t// 水\n\t\tchar chWater = '-';\n\n\t\t// 戦車（上向き）\n\t\tchar chUpTank = '^';\n\n\t\t// 戦車（下向き）\n\t\tchar chDownTank = 'v';\n\n\t\t// 戦車（右向き）\n\t\tchar chRightTank = '>';\n\n\t\t// 戦車（左向き）\n\t\tchar chLeftTank = '<';\n\n\t\t// 戦車が動く前のフィールドの状態\n\t\tchar chBefore = '.';\n\n\t\tchar[] chTank = { chUpTank, chDownTank, chRightTank, chLeftTank };\n\n\t\tField(char[][] Block) {\n\n\t\t\tthis.Block = Block;\n\n\t\t}\n\n\t\t// //戦車の位置\n\t\tint[] LookPosition() {\n\n\t\t\tint[] intPosition = new int[2];\n\n\t\t\tfor (int i = 0; i < Block.length; i++) {\n\t\t\t\tfor (int j = 0; j < Block[0].length; j++) {\n\t\t\t\t\tfor (int k = 0; k < chTank.length; k++) {\n\t\t\t\t\t\tif (chTank[k] == Block[i][j]) {\n\n\t\t\t\t\t\t\tintPosition[0] = i;\n\t\t\t\t\t\t\tintPosition[1] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn intPosition;\n\t\t}\n\n\t\t/**\n\t\t * 行動S　大砲を撃つ\n\t\t * '.'平地なら通り過ぎる\n\t\t * '*'レンガの壁なら、壊れて'.'平地になる\n\t\t * '#'鉄の壁なら大砲が消える\n\t\t * '-'水なら通り過ぎる\n\t\t * ポジションが通り過ぎたり、フィールド値が変更になったりする\n\t\t * @param intPosion int[]型でint[0]に上下位置(下へいくとプラス、上へ行くとマイナス)\n\t\t * int[1]に左右位置(右へいくとプラス、左へ行くとマイナス)が入っている\n\t\t * @param intDirection 0は向き不明 1は戦車上向き 2は戦車下向き 3は戦車右向き 4は戦車左向き\n\t\t */\n\t\tvoid actionS(int[] intPosion, int intDirection) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intHeight < 0 ||\n\t\t\t\t\tBlock.length <= intHeight ||\n\t\t\t\t\tintWidth < 0 ||\n\t\t\t\t\tBlock[0].length <= intWidth) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//まず戦車の向きを調べる\n\t\t\t//intDirectionは最初0で来る\n\t\t\t//intDirectionが0の時の動きになる\n\n\t\t\t//戦車が上向きなら\n\t\t\tif(Block[intHeight][intWidth] == '^') {\n\n\t\t\t\t//ポジションを上に移動\n\t\t\t\t//intDirectionが1\n\t\t\t\t//回帰する\n\t\t\t\tgoUpPosion(intPosion,1);\n\t\t\t\treturn;\n\n\t\t\t}else if(Block[intHeight][intWidth] == 'v') {\n\n\t\t\t\t//ポジションを下に移動\n\t\t\t\t//intDirectionが2\n\t\t\t\t//回帰する\n\t\t\t\tgoDowmPosion(intPosion,2);\n\t\t\t\treturn;\n\n\t\t\t}else if(Block[intHeight][intWidth] == '>') {\n\n\t\t\t\t//ポジションを右に移動\n\t\t\t\t//intDirectionが3\n\t\t\t\t//回帰する\n\t\t\t\tgoRightPosion(intPosion,3);\n\t\t\t\treturn;\n\n\t\t\t}else if(Block[intHeight][intWidth] == '<') {\n\n\t\t\t\t//ポジションを左に移動\n\t\t\t\t//intDirectionが4\n\t\t\t\t//回帰する\n\t\t\t\tgoLeftPosion(intPosion,4);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//フィールド値によって行動\n\t\t\t//回帰で戻ってきたらココへ来る\n\t\t\t//intDirectionが1〜4の時の動きになる\n\n\t\t\t//平地と水の時\n\t\t\tif(Block[intHeight][intWidth] == '.' || Block[intHeight][intWidth] == '-') {\n\n\t\t\t\tswitch(intDirection) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\t//ポジションを上に移動\n\t\t\t\t\tgoUpPosion(intPosion,1);\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\t//ポジションを下に移動\n\t\t\t\t\tgoDowmPosion(intPosion,2);\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 3:\n\n\t\t\t\t\t//ポジションを右に移動\n\t\t\t\t\tgoRightPosion(intPosion,3);\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 4:\n\n\t\t\t\t\t//ポジションを左に移動\n\t\t\t\t\tgoLeftPosion(intPosion,4);\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\t\t\t}else if(Block[intHeight][intWidth] == '*') {\n\n\t\t\t\tBlock[intHeight][intWidth] = '.';\n\n\t\t\t}else if(Block[intHeight][intWidth] == '#') {\n\n\t\t\t\t//何もなし\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * 行動U　戦車が上に行ければ移動\n\t\t * @param intPosion\n\t\t */\n\t\tint[] actionU(int[] intPosion) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//ポジションを上に移動\n\t\t\tintHeight--;\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intHeight < 0 || Block.length <= intHeight) {\n\n\t\t\t\tBlock[intHeight + 1][intWidth] = '^';\n\n\t\t\t\treturn intPosion;\n\t\t\t}\n\n\t\t\tif(Block[intHeight][intWidth] == '.') {\n\n\t\t\t\t//上に移動した後は戦車があった場所にフィールド値を与える\n\t\t\t\tBlock[intHeight + 1][intWidth] = chBefore;\n\n\t\t\t\tBlock[intHeight][intWidth] = '^';\n\n\t\t\t\tintPosion[0]--;\n\n\t\t\t} else {\n\t\t\t\tBlock[intHeight + 1][intWidth] = '^';\n\t\t\t}\n\n\t\t\treturn intPosion;\n\n\t\t}\n\n\t\t/**\n\t\t * 行動D　戦車が下に行ければ移動\n\t\t * @param intPosion\n\t\t */\n\t\tint[] actionD(int[] intPosion) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//ポジションを下に移動\n\t\t\tintHeight++;\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intHeight < 0 || Block.length <= intHeight ) {\n\n\t\t\t\tBlock[intHeight - 1][intWidth] = 'v';\n\t\t\t\treturn intPosion;\n\t\t\t}\n\n\t\t\tif(Block[intHeight][intWidth] == '.') {\n\n\t\t\t\t//上に移動した後は戦車があった場所にフィールド値を与える\n\t\t\t\tBlock[intHeight - 1][intWidth] = chBefore;\n\n\t\t\t\tBlock[intHeight][intWidth] = 'v';\n\n\t\t\t\tintPosion[0]++;\n\n\t\t\t} else {\n\t\t\t\tBlock[intHeight - 1][intWidth] = 'v';\n\t\t\t}\n\n\t\t\treturn intPosion;\n\n\t\t}\n\n\t\t/**\n\t\t * 行動R　戦車が右に行ければ移動\n\t\t * @param intPosion\n\t\t */\n\t\tint[] actionR(int[] intPosion) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//ポジションを右に移動\n\t\t\tintWidth++;\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intWidth < 0 || Block[0].length <= intWidth) {\n\n\t\t\t\tBlock[intHeight][intWidth - 1] = '>';\n\t\t\t\treturn intPosion;\n\t\t\t}\n\n\t\t\tif(Block[intHeight][intWidth] == '.') {\n\n\t\t\t\t//右に移動した後は戦車があった場所にフィールド値を与える\n\t\t\t\tBlock[intHeight][intWidth - 1] = chBefore;\n\n\t\t\t\tBlock[intHeight][intWidth] = '>';\n\n\t\t\t\tintPosion[1]++;\n\n\t\t\t} else {\n\t\t\t\tBlock[intHeight][intWidth - 1] = '>';\n\t\t\t}\n\n\t\t\treturn intPosion;\n\t\t}\n\n\t\t/**\n\t\t * 行動L　戦車が左に行ければ移動\n\t\t * @param intPosion\n\t\t */\n\t\tint[] actionL(int[] intPosion) {\n\n\t\t\t//ポジションの上下位置\n\t\t\tint intHeight = intPosion[0];\n\n\t\t\t//ポジションの左右位置\n\t\t\tint intWidth = intPosion[1];\n\n\t\t\t//ポジションを左に移動\n\t\t\tintWidth--;\n\n\t\t\t//フィールドからはみ出したら終わり\n\t\t\tif(intWidth < 0 || Block[0].length <= intWidth) {\n\n\t\t\t\tBlock[intHeight][intWidth + 1] = '<';\n\t\t\t\treturn intPosion;\n\t\t\t}\n\n\t\t\tif(Block[intHeight][intWidth] == '.') {\n\n\t\t\t\t//左に移動した後は戦車があった場所にフィールド値を与える\n\t\t\t\tBlock[intHeight][intWidth + 1] = chBefore;\n\n\t\t\t\tBlock[intHeight][intWidth] = '<';\n\n\t\t\t\tintPosion[1]--;\n\n\t\t\t} else {\n\t\t\t\tBlock[intHeight][intWidth + 1] = '<';\n\t\t\t}\n\n\t\t\treturn intPosion;\n\t\t}\n\n\t\t/**\n\t\t * ポジションを１つ上に移動\n\t\t * @param intPosion\n\t\t * @param intDirection\n\t\t */\n\t\tvoid goUpPosion(int[] intPosion, int intDirection) {\n\n\t\t\t//上のブロックを参照するので\n\t\t\t//ポジションを1個上へ変更\n\t\t\tintPosion[0]--;\n\n\t\t\t//回帰処理\n\t\t\tactionS(intPosion, intDirection);\n\t\t}\n\n\t\t/**\n\t\t * ポジションを１つ下に移動\n\t\t * @param intPosion\n\t\t * @param intDirection\n\t\t */\n\t\tvoid goDowmPosion(int[] intPosion, int intDirection) {\n\n\t\t\t//上のブロックを参照するので\n\t\t\t//ポジションを1個上へ変更\n\t\t\tintPosion[0]++;\n\n\t\t\t//回帰処理\n\t\t\tactionS(intPosion, intDirection);\n\t\t}\n\n\t\t/**\n\t\t * ポジションを１つ右に移動\n\t\t * @param intPosion\n\t\t * @param intDirection\n\t\t */\n\t\tvoid goRightPosion(int[] intPosion, int intDirection) {\n\n\t\t\t//上のブロックを参照するので\n\t\t\t//ポジションを1個上へ変更\n\t\t\tintPosion[1]++;\n\n\t\t\t//回帰処理\n\t\t\tactionS(intPosion, intDirection);\n\t\t}\n\n\t\t/**\n\t\t * ポジションを１つ左に移動\n\t\t * @param intPosion\n\t\t * @param intDirection\n\t\t */\n\t\tvoid goLeftPosion(int[] intPosion, int intDirection) {\n\n\t\t\t//上のブロックを参照するので\n\t\t\t//ポジションを1個上へ変更\n\t\t\tintPosion[1]--;\n\n\t\t\t//回帰処理\n\t\t\tactionS(intPosion, intDirection);\n\t\t}\n\n\t\tvoid fieldPrint() {\n\n\t\t\tfor (int i = 0; i < Block.length; i++) {\n\t\t\t\tfor (int j = 0; j < Block[0].length; j++) {\n\t\t\t\t\tSystem.out.print(Block[i][j]);\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static class Tank {\n\n\t\tchar[] chAction;\n\n\t\tTank(char[] chAction) {\n\n\t\t\tthis.chAction = chAction;\n\t\t}\n\n\t\t// 行動を提供\n\t\tchar getAction(int ActionNum) {\n\n\t\t\treturn chAction[ActionNum];\n\n\t\t}\n\n\t\tint getActionNum() {\n\t\t\treturn chAction.length;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\t\tSystem.out.println();\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\t\t\tdata_set--;\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\tif(data_set > 0){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t// マップ\n\n\t// 戦車\n\tclass Tank {\n\n\t\tchar[][] map;\n\n\t\tint x, y; \t  // 座標\n\t\tchar dir; \t  // 向いてる方角\n\n\t\tint bx=-1, by=-1;   // 砲弾の座標\n\n\t\tpublic Tank(int x, int y,  int dir, char[][] map) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.map = map;\n\t\t\tif(dir == 0) this.dir = 'L';\n\t\t\telse if(dir == 1) this.dir = 'U';\n\t\t\telse if(dir == 2) this.dir = 'R';\n\t\t\telse if(dir == 3) this.dir = 'D';\n\t\t}\n\n\t\t// 命令\n\t\t// rの取りうる値: UDLR\n\t\tpublic void order(char r) {\n\n\t\t\t// 回転し、進めるのであれば進む\n\t\t\tif(r == 'U') {\n\t\t\t\tdir = 'U';\n\t\t\t\tmap[y][x] = '^';\n\t\t\t\tif(isMovable(x, y-1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty -= 1;\n\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = '^';\n\t\t\t\t} else {\n\t\t\t\t\t// 方向転換だけ行う\n\t\t\t\t\tmap[y][x] = '^';\n\t\t\t\t}\n\t\t\t} else if(r == 'D') {\n\t\t\t\tdir = 'D';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t\tif(isMovable(x, y+1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty += 1;\n\t\t\t\t\t//\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = 'v';\n\t\t\t\t}\n\t\t\t} else if(r == 'L') {\n\t\t\t\tdir = 'L';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t\tif(isMovable(x-1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx -= 1;\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'R') {\n\t\t\t\tdir = 'R';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t\tif(isMovable(x+1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx += 1;\n\t\t\t\t\tmap[y][x] = '>';\n\t\t\t\t}\n\t\t\t} else if(r == 'S') {\n\t\t\t\tshot(dir);\n\t\t\t}\n\n\t\t}\n\n\t\t// 砲撃\n\t\tpublic void shot(char dir) {\n\n\t\t\t// 砲弾の位置初期化\n\t\t\tbx = x;\n\t\t\tby = y;\n\n\t\t\t// 方向を設定し発射\n\t\t\tmoveBullet(dir);\n\n\t\t}\n\n\t\t// 砲弾の移動\n\t\tpublic void moveBullet(char dir) {\n\n\t\t\t// 移動先座標\n\t\t\tint toX = -1;\n\t\t\tint toY = -1;\n\t\t\tif(dir == 'L') {\n\t\t\t\ttoX = bx-1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx -= 1;\n\t\t\t} else if(dir == 'U') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by-1;\n\t\t\t\tby -= 1;\n\t\t\t} else if(dir == 'R') {\n\t\t\t\ttoX = bx+1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx += 1;\n\t\t\t} else if(dir == 'D') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by+1;\n\t\t\t\tby += 1;\n\t\t\t}\n\n\t\t\t// 指定座標に移動できれば破壊し移動する\n\t\t\tif(map[toY][toX] == '*') {\n\t\t\t\t// 破壊\n\t\t\t\tmap[toY][toX] = '.';\n\t\t\t\treturn;\n\t\t\t} else if(map[toY][toX] == '#') {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmoveBullet(dir);\n\t\t\t}\n\t\t}\n\n\t\t// 指定の座標に戦車が進めるか\n\t\tpublic boolean isMovable(int x, int y) {\n\n\t\t\tif(map[y][x] == '.') return true;\n\t\t\telse return false;\n\n\t\t}\n\n\t\t// マップを表示\n\t\tpublic void drawMap() {\n\t\t\tfor(int i=1; i<map.length-1; i++) {\n\t\t\t\tfor(int j=1; j<map[i].length-1; j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップから戦車の位置と向きを取得する\n\t// @return int[] [0]戦車のx座標, [1]戦車のy座標, [2]戦車の向き(左から時計回りに0~3)\n\tpublic int[] getTankDir(char[][] map) {\n\n\t\tint[] ret = new int[3];\n\t\tfor(int i=0; i<map.length; i++) {\n\t\t\tfor(int j=0; j<map[i].length; j++){\n\t\t\t\tif(map[i][j] == '<') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 0;\n\t\t\t\t} else if(map[i][j] == '^') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 1;\n\t\t\t\t} else if(map[i][j] == '>') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 2;\n\t\t\t\t} else if(map[i][j] == 'v') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// マップセットの個数入力\n\t\tint num = sc.nextInt();\n\n\t\tfor(int n=0; n<num; n++) {\n\n\t\t\t// 地図データの入力\n\t\t\tint y = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\n\t\t\tchar[][] map = new char[y+2][x+2];\n\n\t\t\t// 外を埋める\n\t\t\tfor(int i=0; i<y+2; i++) {\n\t\t\t\tfor(int j=0; j<x+2; j++) {\n\t\t\t\t\tif(i == 0 || i == y+1 || j == 0 || j == x+1) map[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t\t\tmap[i][j] = line.toCharArray()[j-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 命令を入力\n\t\t\tint orderNum = sc.nextInt();\n\t\t\tString orders = sc.next();\n\t\t\tchar[] orderArr = orders.toCharArray();\n\n\t\t\tMain b = new Main();\n\n\t\t\t// 戦車の初期位置と向きを取得\n\t\t\tint[] tankPos = b.getTankDir(map);\n\n\n\t\t\t// 戦車を生成\n\t\t\tTank t = new Main().new Tank(tankPos[0], tankPos[1], tankPos[2], map);\n\n\t\t\t// 命令を実行\n\t\t\tfor(int i=0; i<orderNum; i++) {\n\t\t\t\tt.order(orderArr[i]);\n\t\t\t}\n\n\n\t\t\t// debug\n\t\t\t// 戦車の移動テスト\n\t\t\t//\t\tt.rotate('L');\n\n\t\t\t// マップを再表示\n\t\t\tt.drawMap();\n\t\t\tif(n != num-1) System.out.println(\"\");\n\n\t\t}\n\n\t\tsc.close();\n\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scanner = new Scanner(System.in);\n\n\n\t\tint T=scanner.nextInt();\n\n\t\tfor(int i=0;i<T;i++){\n\n\t\t\tTank tank=new Tank();\n\n\t\t\tint H=scanner.nextInt();\n\t\t\tint W=scanner.nextInt();\n\t\t\ttank.H=H;\n\t\t\ttank.W=W;//マップの最大値をTankクラスに引き渡す\n\n\t\t\t\n\t\t\t//マップを作ると同時に戦車の向きと現在地をTankクラスに渡す\n\t\t\t\n\t\t\tfor(int p=0;p<H;p++){\n\t\t\t\t\n\t\t\t\tString st=scanner.next();\n\n\t\t\t\tfor(int k=0;k<W;k++){\n\n\t\t\t\t\ttank.map[p][k]=st.charAt(k);\n\t\t\t\t\t\n\n\t\t\t\t\tswitch(tank.map[p][k]){\n\t\t\t\t\tcase '^':\n\t\t\t\t\t\ttank.positionH=p;\n\t\t\t\t\t\ttank.positionW=k;\n\t\t\t\t\t\ttank.direction='^';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\ttank.positionH=p;\n\t\t\t\t\t\ttank.positionW=k;\n\t\t\t\t\t\ttank.direction='v';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\ttank.positionH=p;\n\t\t\t\t\t\ttank.positionW=k;\n\t\t\t\t\t\ttank.direction='<';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\ttank.positionH=p;\n\t\t\t\t\t\ttank.positionW=k;\n\t\t\t\t\t\ttank.direction='>';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tint N=scanner.nextInt();\n\n\t\t\tString order=scanner.next();\n\n\t\t\t//各命令をtankクラスのメソッドに渡す\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tswitch(order.charAt(k)){\n\t\t\t\tcase'U':\n\t\t\t\t\ttank.Up();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase'D':\n\t\t\t\t\ttank.Down();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase'L':\n\t\t\t\t\ttank.Left();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase'R':\n\t\t\t\t\ttank.Right();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase'S':\n\t\t\t\t\ttank.Shot();\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor(int k=0;k<tank.H;k++){\n\t\t\t\tfor(int q=0;q<tank.W;q++){\n\t\t\t\t\tSystem.out.print(String.valueOf(tank.map[k][q]));\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t\tif(!(i==(T-1))){\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}\n\n\n\nclass Tank{\n\n\n\tint H=0;//マップの大きさ\n\tint W=0;\n\n\tint positionH=0;//戦車の現在地\n\tint positionW=0;\n\tchar direction='0';//戦車の向き\n\tchar map[][];//マップ\n\t\n\tTank(){map=new char[20][20];}\n\n\t\n\n//戦車の移動したい場所を判別して処理をする\n\tpublic void Up(){\n\n\n\n\t\tif((positionH>0)&&(map[positionH-1][positionW]=='.')){\n\n\t\t\tmap[positionH][positionW]='.';\n\t\t\tmap[positionH-1][positionW]='^';\n\t\t\tpositionH=positionH-1;\n\t\t\tdirection='^';\n\t\t}\n\n\t\tmap[positionH][positionW]='^';\n\t\tdirection='^';\n\n\t}\n\n\n\tpublic void Down(){\n\n\n\t\tif((positionH<H-1)&&(map[positionH+1][positionW]=='.')){\n\n\t\t\tmap[positionH][positionW]='.';\n\t\t\tmap[positionH+1][positionW]='v';\n\t\t\tpositionH=positionH+1;\n\t\t\tdirection='v';\n\n\t\t}\n\n\t\tmap[positionH][positionW]='v';\n\t\tdirection='v';\n\t}\n\n\n\tpublic void Left(){\n\n\t\tif((positionW>0)&&(map[positionH][positionW-1]=='.')){\n\n\t\t\tmap[positionH][positionW]='.';\n\t\t\tmap[positionH][positionW-1]='<';\n\t\t\tpositionW=positionW-1;\n\t\t\tdirection='<';\n\n\t\t}\n\n\t\tmap[positionH][positionW]='<';\n\t\tdirection='<';\n\t}\n\n\n\tpublic void Right(){\n\n\t\tif((positionW<W-1)&&(map[positionH][positionW+1]=='.')){\n\n\t\t\tmap[positionH][positionW]='.';\n\t\t\tmap[positionH][positionW+1]='>';\n\t\t\tpositionW=positionW+1;\n\t\t\tdirection='>';\n\n\t\t}\n\t\tmap[positionH][positionW]='>';\n\t\tdirection='>';\n\t}\n\n\n\t//戦車の向きと砲弾のぶつかる先を処理、壁でなければ砲弾を移動させてループする\n\n\tpublic void Shot(){\n\t\tint shot=0;\n\t\tswitch(direction){\n\n\t\tcase '^':\n\t\t\tshot=positionH;\n\n\t\t\twhile(true){\n\n\t\t\t\tif(shot==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if((map[shot-1][positionW]=='.')||(map[shot-1][positionW]=='-')){\n\n\t\t\t\t\tshot=shot-1;\n\n\t\t\t\t}\n\n\t\t\t\telse if(map[shot-1][positionW]=='#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[shot-1][positionW]=='*'){\n\t\t\t\t\tmap[shot-1][positionW]='.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\n\t\tcase 'v':\n\t\t\tshot=positionH;\n\n\n\t\t\twhile(true){\n\n\t\t\t\tif(shot==H-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if((map[shot+1][positionW]=='.')||(map[shot+1][positionW]=='-')){\n\n\t\t\t\t\tshot=shot+1;\n\n\t\t\t\t}\n\n\t\t\t\telse if(map[shot+1][positionW]=='#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[shot+1][positionW]=='*'){\n\t\t\t\t\tmap[shot+1][positionW]='.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tshot=positionW;\n\n\n\t\t\twhile(true){\n\n\t\t\t\tif(shot==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if((map[positionH][shot-1]=='.')||(map[positionH][shot-1]=='-')){\n\n\t\t\t\t\tshot=shot-1;\n\n\t\t\t\t}\n\n\t\t\t\telse if(map[positionH][shot-1]=='#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[positionH][shot-1]=='*'){\n\t\t\t\t\tmap[positionH][shot-1]='.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\n\t\tcase '>':\n\t\t\tshot=positionW;\n\n\n\t\t\twhile(true){\n\n\t\t\t\tif(shot==W-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if((map[positionH][shot+1]=='.')||(map[positionH][shot+1]=='-')){\n\n\t\t\t\t\tshot=shot+1;\n\n\t\t\t\t}\n\n\t\t\t\telse if(map[positionH][shot+1]=='#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[positionH][shot+1]=='*'){\n\t\t\t\t\tmap[positionH][shot+1]='.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map3> map_list = new ArrayList<map3>();\n\t\t// 入力の回数\n\t\tint input_length = sc.nextInt();\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap3 map = new map3();\n\t\t\tmap.setMap(height, width);\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank3 tank = new tank3();\n\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// コマンド入力回数\n\t\t\tint command_number = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\tString command_attack = sc.next();\n\t\t\t// ひとつずつ配列に入れる\n\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\tmap_list.get(f).out_map();\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass tank3 {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\nclass map3 {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main (String args[]){\n\n\t\t//??\\??????????????????????????????Scanner???????????§???????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tint i = 0;\n\n\t\tfor(i = 0; i < T; i++){\n\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tchar[][] map = new char[H][W];\n\n\t\t\t//???0??????1??????2??????3\n\t\t\tchar tank;\n\n\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tString line = sc.next();\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tmap[j][k] = line.charAt(k);\n\n\t\t\t\t\tif(map[j][k] == '^' || map[j][k] == 'v' || map[j][k] == '<' || map[j][k] == '>'){\n\t\t\t\t\t\tif(map[j][k] == '^'){\n\t\t\t\t\t\t\ttank = '^';\n\t\t\t\t\t\t}else if(map[j][k] == 'v'){\n\t\t\t\t\t\t\ttank = 'v';\n\t\t\t\t\t\t}else if(map[j][k] == '<'){\n\t\t\t\t\t\t\ttank = '<';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttank = '>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint t = j;\n\t\t\t\t\t\tint y = k;\n\t\t\t\t\t\tBattle BT = new Battle(t,y,tank,map);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint N = sc.nextInt();\n\t\t\tString com = sc.next();\n\t\t\tchar[] command = new char[N];\n\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tBattle.check(command[j] = com.charAt(j));\n\t\t\t}\n\n\t\t\tSystem.out.print(Battle.output());\n\n\t\t\tif(i != T){\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}\n\nclass Battle{\n\tstatic int tate;\n\tstatic int yoko;\n\tstatic char tank;\n\tstatic char[][] map;\n\n\t//????????\\??????\n\tBattle(int t, int y, char tankk, char[][] mapp){\n\t\ttate = t;\n\t\tyoko = y;\n\t\tmap = mapp;\n\t\ttank = tankk;\n\t}\n\n\tpublic static String output(){\n\t\tStringBuffer str = new StringBuffer();\n\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\tstr.append(map[i][j]);\n\t\t\t}\n\t\t\tstr.append(System.getProperty(\"line.separator\"));\n\t\t}\n\t\tString ans = new String(str);\n\t\treturn ans;\n\t}\n\n\tpublic static void check(char command){\n\n\t\tswitch (command){\n\n\t\tcase 'U':\n\t\t\ttank = '^';\n\t\t\tif(tate > 0){\n\t\t\t\tif(map[tate-1][yoko] == '.'){\n\t\t\t\t\ttate = tate - 1;\n\t\t\t\t\tmap[tate][yoko] = '^';\n\t\t\t\t\tmap[tate+1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\ttank = 'v';\n\t\t\tif((map.length - (tate+1)) > 0){\n\t\t\t\tif(map[tate+1][yoko] == '.'){\n\t\t\t\t\ttate = tate + 1;\n\t\t\t\t\tmap[tate][yoko] = 'v';\n\t\t\t\t\tmap[tate-1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\ttank = '<';\n\t\t\tif(yoko > 0){\n\t\t\t\tif(map[tate][yoko-1] == '.'){\n\t\t\t\t\tyoko = yoko - 1;\n\t\t\t\t\tmap[tate][yoko] = '<';\n\t\t\t\t\tmap[tate][yoko+1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\ttank = '>';\n\t\t\tif((map[tate].length - (yoko+1)) > 0){\n\t\t\t\tif(map[tate][yoko+1] == '.'){\n\t\t\t\t\tyoko = yoko + 1;\n\t\t\t\t\tmap[tate][yoko] = '>';\n\t\t\t\t\tmap[tate][yoko-1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tswitch (tank){\n\t\t\tcase '^':\n\t\t\t\tfor(int i = tate; i >= 0; i--){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tfor(int i = tate; i < map.length; i++){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '<':\n\t\t\t\tfor(int i = yoko; i >= 0; i--){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = -1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tfor(int i = yoko; i < map[tate].length; i++){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = map[tate].length +1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\t\t//ArrayList<Field> list = new ArrayList<Field>();\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\tint[] aryArea = new int[2];\n\t\t//?????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\t\t\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\t\t\t//?????£??????????????§??????????????????????´?\n\t\t\t//aryArea[0] = intHeight;\n\t\t\t//aryArea[1] = intWidth;\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\t\t\t//System.out.println(\"field.length:\" + field.length);\n\t\t\t//System.out.println(\"field[0].length:\" + field[0].length);\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\t//????????\\???????????????????????????????????????????´?\n\t\t\t\t//String[] fieldLine = new String[intWidth];\n\t\t\t\tString[] fieldLine = insBR.readLine().split(\"\");\n\t\t\t\t//System.out.println(\"fieldLine.length:\" + fieldLine.length);\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\t\t\t\t\t\n\t\t\t\t\tfield[j][i] = fieldLine[i+1];\n\t\t\t\t\t//System.out.print(field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\t\t\t//System.out.println(\"commond.length:\" + commond.length);\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\t\t\t//??????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\t\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\t\t\t\n\t\t\tField insField = aryIns[k];\n\t\t\tint intHeight = insField.field.length;\n\t\t\tint intWidth = insField.field[0].length;\n\t\t\t\n\t\t\t\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != aryIns.length-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£??????????????§???????????????????????????*/\n\t\tprivate int[] aryArea;\n\t\tint intHeight;\n\t\tint intWidth;\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond ){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.intHeight = field.length;\n\t\t\tthis.intWidth = field[0].length;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????£????????????????????¨???????????£??\\\n\t\t\t//int intHeight = aryArea[0];\n\t\t\t//int intWidth = aryArea[1];\n\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\t\t\t\t//System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\t\t\t\t//System.out.println(\"tank:\" + j + i);\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\t\t\t//?????£??????????????§??????\n\t\t\t//int intHeight = aryArea[0];\n\t\t\t//int intWidth = aryArea[1];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tstatic int intHight;//マップの縦の幅。\n\tstatic int intWidth;//マップの横の幅。\n\tstatic int intMaxTurn;//データセット数。\n\tstatic List<Integer> intSensyaPosition;//戦車の位置の数値リスト。\n\tstatic boolean[][] blExist;//戦車がいるかどうかの判定配列。\n\tstatic String[][] strMap;//マップ構成。\n\tstatic String[][][] strAnswer;//最終的なマップ。\n\n\tpublic static void main(String[] args){\n\n\t\tBufferedReader insBR = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> hightList = new ArrayList<Integer>();;\n\t\tList<Integer> widthList = new ArrayList<Integer>();;\n\n\t\ttry{\n\n\t\t\t//ターン数を読み取る。\n\t\t\tString strMaxTurn = insBR.readLine();\n\t\t\tintMaxTurn = Integer.parseInt(strMaxTurn);\n\n\t\t\t//答えのマップを配列で用意。\n\t\t\tstrAnswer = new String[intMaxTurn][20][20];\n\n\t\t\t//ターン数分マップを駆け巡る。\n\t\t\tfor(int intTurn = 0; intTurn < intMaxTurn; intTurn++){\n\n\t\t\t\t//マップの広さを読み取る。\n\t\t\t\tString[] strArea = insBR.readLine().split(\" \");\n\t\t\t\tintHight = Integer.parseInt(strArea[0]);\n\t\t\t\tintWidth = Integer.parseInt(strArea[1]);\n\n\t\t\t\t//後ほど答えを出すときに必要になるので、リストにマップの広さをそれぞれ格納。\n\t\t\t\thightList.add(intHight);\n\t\t\t\twidthList.add(intWidth);\n\n\t\t\t\t//マップの配列。\n\t\t\t\tstrMap = new String[intHight][intWidth];\n\n\t\t\t\t//戦車がいるかどうかの判定配列を初期化。\n\t\t\t\tblExist = new boolean[intHight][intWidth];\n\n\t\t\t\t//マップの構成要素を読み取る。\n\t\t\t\tfor(int intGyou = 0; intGyou < intHight; intGyou++){\n\t\t\t\t\tstrMap[intGyou]  = insBR.readLine().split(\"\");\n\t\t\t\t}\n\n\t\t\t\t//入力操作数。\n\t\t\t\tString strOperation = insBR.readLine();\n\t\t\t\tint intMaxOrder = Integer.parseInt(strOperation);\n\n\t\t\t\t//戦車の動作。\n\t\t\t\tString[] strAction = insBR.readLine().split(\"\");\n\n\t\t\t\t//戦車の位置を取得。\n\t\t\t\tintSensyaPosition = new ArrayList<Integer>();\n\t\t\t\tboolean blFind = false;\n\t\t\t\tfor(int first = 0; first < intHight; first++){\n\t\t\t\t\tfor(int second = 0; second < intWidth; second++){\n\t\t\t\t\t\tif(\"^\".equals(strMap[first][second]) || \"v\".equals(strMap[first][second])\n\t\t\t\t\t\t\t|| \"<\".equals(strMap[first][second]) || \">\".equals(strMap[first][second])){\n\n\t\t\t\t\t\t\t\tintSensyaPosition.add(first);\n\t\t\t\t\t\t\t\tintSensyaPosition.add(second);\n\t\t\t\t\t\t\t\tblFind = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(blFind){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint intSensyaY = intSensyaPosition.get(0);\n\t\t\t\tint intSensyaX = intSensyaPosition.get(1);\n\t\t\t\tString strSensya = strMap[intSensyaY][intSensyaX];\n\n\t\t\t\t//戦車を操作。\n\t\t\t\tfor(int intOrder = 0; intOrder < intMaxOrder; intOrder++){\n\t\t\t\t\torder(strAction[intOrder], intSensyaPosition, strSensya);\n\t\t\t\t}\n\n\t\t\t\t//答えを格納。\n\t\t\t\tfor(int intY = 0; intY < intHight; intY++){\n\t\t\t\t\tfor(int intX = 0; intX < intWidth; intX++){\n\t\t\t\t\t\tstrAnswer[intTurn][intY][intX] = strMap[intY][intX];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}catch(IOException e){\n\n\t\t}\n\n\t\t//出力\n\t\tfor(int i = 0; i < intMaxTurn; i++){\n\t\t\tfor(int j = 0; j < hightList.get(i); j++){\n\t\t\t\tfor(int k = 0; k < widthList.get(i); k++){\n\t\t\t\t\tSystem.out.print(strAnswer[i][j][k]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(i < intMaxTurn - 1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//オーダーの処理メソッド。\n\tpublic static void order(String strOrder, List<Integer> list, String strSensya){\n\n\t\tint intSensyaY = list.get(0);\n\t\tint intSensyaX = list.get(1);\n\n\t\t//砲弾を撃つとき。\n\t\tswitch(strOrder){\n\n\t\t\tcase \"S\":\n\t\t\t\tdestroy(intSensyaY, intSensyaX, strMap[intSensyaY][intSensyaX]);\n\t\t\t\tbreak;\n\n\n\t\t\t//方向転換\n\t\t\tcase \"U\":\n\t\t\t\tif(intSensyaY - 1 < 0){\n\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \"^\";\n\n\t\t\t\t}else{\n\n\t\t\t\t\tswitch(strMap[intSensyaY - 1][intSensyaX]){\n\n\t\t\t\t\t\tcase \".\":\n\t\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \".\";\n\t\t\t\t\t\t\tstrMap[intSensyaY - 1][intSensyaX] = \"^\";\n\t\t\t\t\t\t\tintSensyaPosition.clear();\n\t\t\t\t\t\t\tintSensyaPosition.add(intSensyaY - 1);\n\t\t\t\t\t\t\tintSensyaPosition.add(intSensyaX);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \"^\";\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tif(intHight <= intSensyaY + 1){\n\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \"v\";\n\n\t\t\t\t}else{\n\t\t\t\t\tif(\".\".equals(strMap[intSensyaY + 1][intSensyaX])){\n\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \".\";\n\t\t\t\t\t\tstrMap[intSensyaY + 1][intSensyaX] = \"v\";\n\t\t\t\t\t\tintSensyaPosition.clear();\n\t\t\t\t\t\tintSensyaPosition.add(intSensyaY + 1);\n\t\t\t\t\t\tintSensyaPosition.add(intSensyaX);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \"v\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"L\":\n\t\t\t\tif(intSensyaX - 1 < 0){\n\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \"<\";\n\n\t\t\t\t}else{\n\t\t\t\t\tswitch (strMap[intSensyaY][intSensyaX - 1]){\n\n\t\t\t\t\t\tcase \".\":\n\t\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \".\";\n\t\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX - 1] = \"<\";\n\t\t\t\t\t\t\tintSensyaPosition.clear();\n\t\t\t\t\t\t\tintSensyaPosition.add(intSensyaY);\n\t\t\t\t\t\t\tintSensyaPosition.add(intSensyaX - 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \"<\";\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"R\":\n\t\t\t\tif(intWidth <= intSensyaX + 1){\n\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \">\";\n\n\t\t\t\t}else{\n\t\t\t\t\tswitch(strMap[intSensyaY][intSensyaX + 1]){\n\n\t\t\t\t\t\tcase \".\":\n\t\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \".\";\n\t\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX + 1] = \">\";\n\t\t\t\t\t\t\tintSensyaPosition.clear();\n\t\t\t\t\t\t\tintSensyaPosition.add(intSensyaY);\n\t\t\t\t\t\t\tintSensyaPosition.add(intSensyaX + 1);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstrMap[intSensyaY][intSensyaX] = \">\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic static void destroy(int intY, int intX, String strSensya){\n\t\tboolean blDestroy = false;\n\t\tswitch(strSensya){\n\n\t\t\tcase \"^\":\n\t\t\t\tif(0 <= intY - 1 ){\n\t\t\t\t\tfor(int i = intY - 1; 0 <= i; i--){\n\t\t\t\t\t\tif(\"*\".equals(strMap[i][intX])){\n\t\t\t\t\t\t\tstrMap[i][intX] = \".\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(\"#\".equals(strMap[i][intX])){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"v\":\n\t\t\t\tif(intY + 1 < intHight){\n\t\t\t\t\tfor(int i = intY + 1; i < intHight; i++){\n\t\t\t\t\t\tswitch(strMap[i][intX]){\n\n\t\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\t\tstrMap[i][intX] = \".\";\n\t\t\t\t\t\t\t\tblDestroy = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"#\":\n\t\t\t\t\t\t\t\tblDestroy = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(blDestroy){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"<\":\n\t\t\t\tif(0 <= intX - 1){\n\t\t\t\t\tfor(int i = intX - 1; 0 <= i; i--){\n\t\t\t\t\t\tswitch(strMap[intY][i]){\n\n\t\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\t\tstrMap[intY][i] = \".\";\n\t\t\t\t\t\t\t\tblDestroy = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"#\":\n\t\t\t\t\t\t\t\tblDestroy = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(blDestroy){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \">\":\n\t\t\t\tif(intX + 1 < intWidth){\n\t\t\t\t\tfor(int i = intX + 1; i < intWidth; i++){\n\t\t\t\t\t\tswitch(strMap[intY][i]){\n\n\t\t\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\t\t\tstrMap[intY][i] = \".\";\n\t\t\t\t\t\t\t\tblDestroy = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"#\":\n\t\t\t\t\t\t\t\tblDestroy = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(blDestroy){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.Scanner;\n\nclass Main{\n\t\n\t/**\n\t * プログラムエントリポイント\n\t * @param args\n\t */\n\tpublic static void main (String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//データセット回数を入力\n\t\tint setCountData = sc.nextInt();\n\t\t//入力されたデータセット回数分繰り返す\n\t\tfor( int i = 0 ; i < setCountData ; i++ ){\n\t\t\t//繰り返す回数ごとに配列を作成して２次元配列の長さを入力\n\t\t\tchar[][] aryBattleArea = new char[sc.nextInt()][sc.nextInt()];\n\t\t\t//配列aryBattleAreaに市街戦の要素入力\n\t\t\tfor( int j = 0 ; j < aryBattleArea.length ; j++ ){\n\t\t\t\taryBattleArea[j] = sc.next().toCharArray();\n\t\t\t}\n\t\t\t//繰り返す回数ごとに配列を作成して１次元配列の長さを入力\n\t\t\tchar[] aryOperation = new char[sc.nextInt()];\n\t\t\t//配列aryOperationに操作分を入力したものを文字ごとに配列に格納\n\t\t\taryOperation = sc.next().toCharArray();\n\t\t\t\n\t\t\t//BattleTownをインスタンス化\n\t\t\tBattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n\t\t\t\n\t\t\taryBattleArea = insBt.runOperation();\n\t\t\t\n\t\t\tfor( int x = 0 ; x < aryBattleArea.length ; x++ ){\n\t\t\t\tfor( int y = 0 ; y < aryBattleArea[i].length ; y++ ){\n\t\t\t\t\tSystem.out.print(aryBattleArea[x][y]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\n/**\n * \n * 操作を実行する\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n\t\n\tprivate char[][] aryBattleArea;\n\tprivate char[] aryOperation;\n\t\n\t/**\n\t * コンストラクタ\n\t * @param aryBattleArea 戦場を表す二次元配列\n\t * @param aryOperation 命令を表す一次元配列\n\t */\n\tpublic BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n\t\t\n\t\tthis.aryBattleArea = aryBattleArea;\n\t\tthis.aryOperation = aryOperation;\n\t\t\n\t}\n\t/**\n\t * 指定された操作を順番にactionTankクラス渡し\n\t * 渡した操作は'0'にして読み取れないように\n\t */\n\tpublic char[][] runOperation(){\n\t\t\n\t\tfor( int k = 0 ; k < aryOperation.length ; k++ ){\n\t\t\t\n\t\t\tfor( int i = 0 ; i < aryBattleArea.length ; i++ ){\n\t\t\t\tfor( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n\t\t\t\t\t\t|| aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( aryOperation[k] != '0' ){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tactionTank( i , j , aryOperation[k] );\n\t\t\t\t\t\t\taryOperation[k] = '0';\n\t\t\t\t\t\t\trunOperation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn aryBattleArea;\n\t}\n\t\n\t/**\n\t * 指定された操作を実行する\n\t * @param i 戦車を発見した配列の位置\n\t * @param j 戦車を発見した配列の位置\n\t * @param c 操作命令\n\t */\n\tprivate void actionTank( int i , int j , char operation ) {\n\t\t\t\n\t\t\t//戦車上方向\n\t\tif( operation == 'U' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '^';\n\t\t\t\n\t\t\tif( i-1 >= 0 ){\n\t\t\t\tif( aryBattleArea[i-1][j] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i-1][j] = '^';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t//戦車下方向\n\t\t}else if( operation == 'D' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = 'v';\n\t\t\t\n\t\t\tif( i+1 < aryBattleArea.length ){\n\t\t\t\tif( aryBattleArea[i+1][j] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i+1][j] = 'v';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//戦車左方向\n\t\t}else if( operation == 'L' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '<';\n\t\t\t\n\t\t\tif( j-1 >= 0 ){\n\t\t\t\tif( aryBattleArea[i][j-1] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i][j-1] = '<';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//戦車右方向\n\t\t}else if( operation == 'R' ){\n\t\t\t\n\t\t\taryBattleArea[i][j] = '>';\n\t\t\t\n\t\t\tif( j+1 < aryBattleArea[i].length ){\n\t\t\t\tif( aryBattleArea[i][j+1] == '.' ){\n\t\t\t\t\taryBattleArea[i][j] = '.';\n\t\t\t\t\taryBattleArea[i][j+1] = '>';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}else if( operation == 'S' ){\n\t\t\n\t\t\tif(aryBattleArea[i][j] == '^'){\n\t\t\t\t\n\t\t\t\tfor( int x = i ; x >= 0 ; x-- ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[x][j] == '*' ){\n\t\t\t\t\t\taryBattleArea[x][j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == 'v'){\n\t\t\t\t\n\t\t\t\tfor( int x = i ; x < aryBattleArea.length ; x++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[x][j] == '*' ){\n\t\t\t\t\t\taryBattleArea[x][j] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == '<'){\n\t\t\t\t\n\t\t\t\tfor( int x = j ; x >= 0 ; x-- ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][x] == '*' ){\n\t\t\t\t\t\taryBattleArea[i][x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(aryBattleArea[i][j] == '>'){\n\t\t\t\t\n\t\t\t\tfor( int x = j ; x < aryBattleArea.length ; x++ ){\n\t\t\t\t\t\n\t\t\t\t\tif( aryBattleArea[i][x] == '*' ){\n\t\t\t\t\t\taryBattleArea[i][x] = '.';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if( aryBattleArea[x][j] == '#' ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n//\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\t\t\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<Field> map_list = new ArrayList<Field>();\n\t\t// 入力クラス\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// 入力の回数\n\t\tint input_length = sc.nextInt();\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t// マップの高さ\n\t\t\tint height = sc.nextInt();\n\t\t\t// マップの幅\n\t\t\tint width = sc.nextInt();\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tField map = new Field();\n\t\t\tmap.setMap(height, width);\n\n\t\t\t// 戦車のインスタンスを作る\n\t\t\tTank tank = new Tank();\n\n\t\t\t// マップ高さ分まわす\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\tString line = sc.next();\n\t\t\t\t// マップを作る\n\t\t\t\tmap.createMap(h, line);\n\t\t\t}\n\n\t\t\t// コマンド入力回数\n\t\t\tint no_use = sc.nextInt();\n\n\t\t\t// コマンドの文字列\n\t\t\tString command_row = sc.next();\n\n\t\t\t// 戦車の動き\n\t\t\ttank.Action(command_row, map);\n\n\t\t\t// できたマップリストにを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\n\t\t// 結果を出力\n\t\tfor (int f = 0; f < map_list.size(); f++) {\n\n\t\t\tmap_list.get(f).out_map();\n\n\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 戦車について扱ったクラス\nclass Tank {\n\n\t//戦車の要素\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す\n\tpublic void now_position(Field map) {\n\t\t// マップ全体を探す\n\t\tfor (int h = 0; h < map.getMap().length; h++) {\n\t\t\tfor (int w = 0; w < map.getMap()[0].length; w++) {\n\n\t\t\t\t// 自分(戦車)がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map.getMap()[h][w].equals(val)) {\n\t\t\t\t\t\t// 自分(戦車)の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 戦車行動によるマップ変更\n\tpublic Field Action(String command_row, Field map) {\n\t\t// 一文字づつに変換\n\t\tchar[] command_char = command_row.toCharArray();\n\n\t\t// コマンドがある分まわす\n\t\tfor (int i = 0; i < command_char.length; i++) {\n\n\t\t\t// 現在位置を把握\n\t\t\tnow_position(map);\n\n\t\t\t// ひとつのコマンド\n\t\t\tString one_command = String.valueOf(command_char[i]);\n\n\t\t\t// コマンド入力によって行動を変化\n\t\t\tswitch (one_command) {\n\t\t\t// 移動\n\t\t\tcase \"R\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"L\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"U\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\tcase \"D\":\n\t\t\t\tmove(one_command, map);\n\t\t\t\tbreak;\n\t\t\t// 砲撃\n\t\t\tcase \"S\":\n\t\t\t\tshuttGun(map);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車砲撃によるマップ変更\n\tpublic Field shuttGun(Field map) {\n\t\t// 場合わけ\n\t\tswitch (situation) {\n\n\t\t// 左向き\n\t\tcase \"<\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_width; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// 右向き\n\t\tcase \">\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map.getMap()[0].length - now_width); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height][now_width + i] = \".\";\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height][now_width + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// 上向き\n\t\tcase \"^\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_height; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"*\")) {\n\n\t\t\t\t\t\tmap.getMap()[now_height - i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height - i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\t// 下向き\n\t\tcase \"v\":\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.getMap().length - now_height); i++) {\n\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"*\")) {\n\t\t\t\t\t\tmap.getMap()[now_height + i][now_width] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map.getMap()[now_height + i][now_width].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic Field move(String s, Field map) {\n\n\t\t// ケース分け\n\t\tswitch (s) {\n\n\t\t// 左向き\n\t\tcase \"L\":\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"<\";\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 右向き\n\t\tcase \"R\":\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_width == (map.getMap()[0].length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height][now_width + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height][now_width + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \">\";\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 下向き\n\t\tcase \"D\":\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == (map.getMap().length - 1)) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\n\t\t\t} else if (map.getMap()[now_height + 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height + 1][now_width] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"v\";\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// 上向き\n\t\tcase \"U\":\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_height == 0) {\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map.getMap()[now_height - 1][now_width].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap.getMap()[now_height - 1][now_width] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap.getMap()[now_height][now_width] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap.getMap()[now_height][now_width] = \"^\";\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\n// マップについて扱ったクラス\nclass Field {\n\n\t// マップ構成要素\n\tfinal String[] Map_element = new String[] { \".\", \"*\", \"#\", \"-\" };\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, String map_row) {\n\t\t// 一文字づつに変換\n\t\tchar[] map_ele = map_row.toCharArray();\n\t\t// 一文字マップに構成要素を追加していく\n\t\tfor (int w = 0; w < map_ele.length; w++) {\n\t\t\tmap[height_i][w] = String.valueOf(map_ele[w]);\n\t\t}\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint times = sc.nextInt();\n\n\t\tfor(int i = 1; i <= times; i++){\n\t\t\tint lines = sc.nextInt();\n\t\t\tint xlength = sc.nextInt();\n\t\t\t\n\t\t\tString[] data = new String[lines];\n\t\t\tsc.nextLine();\n\t\t\tfor(int j = 0; j < data.length; j++){\n\t\t\t\tdata[j] = sc.nextLine();\n\t\t\t}\n\t\t\tMap mp = new Map(data);\n\n\t\t\tint inputtimes = sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tmp.doCommands(Map.CharsToCommands(sc.nextLine().toCharArray()));\n\n\t\t\tSystem.out.println(mp.toString(true));\n\t\t\tif(i != times){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass Map{\n\tElements[][] map;\n\t\n\tpublic Map(String[] data){\n\t\tint maxx = 0;\n\t\tfor(String s : data){\n\t\t\tmaxx = Math.max(maxx, s.length());\n\t\t}\n\t\t\n\t\tchar[][] m = new char[data.length][maxx];\n\n\t\tfor(int i = 0; i < data.length; i++){\n\t\t\tchar[] d = data[i].toCharArray();\n\t\t\tm[i] = d;\n\t\t}\n\n\t\tmap = CharsToElements(m);\n\t}\n\n\tpublic void doCommands(Commands[] c){\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\tdoCommands(c[i]);\n\t\t}\n\t}\n\n\tpublic void doCommands(Commands c){\n\t\tint[] nowpos = getNowPosition();\n\t\t\n\t\tswitch(c){\n\t\t\tcase Up:\n\t\t\t\tif(nowpos[0] != 0){\n\t\t\t\t\tint[] upper = {nowpos[0] - 1, nowpos[1]};\n\t\t\t\t\tif(getElement(upper) == Elements.Plain){\n\t\t\t\t\t\tsetElement(upper, Elements.TankUp);\n\t\t\t\t\t\tsetElement(nowpos, Elements.Plain);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsetElement(nowpos, Elements.TankUp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tsetElement(nowpos, Elements.TankUp);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Down:\n\t\t\t\tif(nowpos[0] != map.length - 1){\n\t\t\t\t\tint[] lower = {nowpos[0] + 1, nowpos[1]};\n\t\t\t\t\tif(getElement(lower) == Elements.Plain){\n\t\t\t\t\t\tsetElement(lower, Elements.TankDown);\n\t\t\t\t\t\tsetElement(nowpos, Elements.Plain);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsetElement(nowpos, Elements.TankDown);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tsetElement(nowpos, Elements.TankDown);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Left:\n\t\t\t\tif(nowpos[1] != 0){\n\t\t\t\t\tint[] lefter = {nowpos[0], nowpos[1] -1};\n\t\t\t\t\tif(getElement(lefter) == Elements.Plain){\n\t\t\t\t\t\tsetElement(lefter, Elements.TankLeft);\n\t\t\t\t\t\tsetElement(nowpos, Elements.Plain);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsetElement(nowpos, Elements.TankLeft);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tsetElement(nowpos, Elements.TankLeft);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Right:\n\t\t\t\tif(nowpos[1] != map[nowpos[0]].length - 1){\n\t\t\t\t\tint[] righter = {nowpos[0], nowpos[1] + 1};\n\t\t\t\t\tif(getElement(righter) == Elements.Plain){\n\t\t\t\t\t\tsetElement(righter, Elements.TankRight);\n\t\t\t\t\t\tsetElement(nowpos, Elements.Plain);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsetElement(nowpos, Elements.TankRight);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tsetElement(nowpos, Elements.TankRight);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Shoot:\n\t\t\t\tint lined = 0, xd = 0;\n\t\t\t\tswitch(getElement(nowpos)){\n\t\t\t\t\tcase TankUp:\n\t\t\t\t\t\tlined = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TankDown:\n\t\t\t\t\t\tlined = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TankLeft:\n\t\t\t\t\t\txd = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TankRight:\n\t\t\t\t\t\txd = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tattack(nowpos, lined, xd);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\n\tvoid attack(int[] nowpos, int linedir, int xdir){\n\t\tint[] nextpos = {nowpos[0] + linedir, nowpos[1] + xdir};\n\n\t\tif(isPostionExist(nextpos)){\n\t\t\tswitch(getElement(nextpos)){\n\t\t\t\tcase Plain:\n\t\t\t\tcase Water:\n\t\t\t\t\tattack(nextpos, linedir, xdir);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BlickWall:\n\t\t\t\t\tsetElement(nextpos, Elements.Plain);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean isPostionExist(int[] p){\n\t\tboolean res = true;\n\t\ttry{\n\t\t\tElements t = map[p[0]][p[1]];\n\t\t}catch(IndexOutOfBoundsException e){\n\t\t\tres = false;\n\t\t}finally{\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpublic int[] getNowPosition(){\n\t\tint[] res = {-1, -1};\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\tif (map[i][j] == Elements.TankUp || map[i][j] == Elements.TankDown || map[i][j] == Elements.TankLeft || map[i][j] == Elements.TankRight){\n\t\t\t\t\tres[0] = i;\n\t\t\t\t\tres[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic Elements getElement(int[] pos){\n\t\treturn map[pos[0]][pos[1]];\n\t}\n\t\n\tpublic void setElement(int[] pos, Elements e){\n\t\tmap[pos[0]][pos[1]] = e;\n\t}\n\tpublic String toString(boolean toMap){\n\t\tif(toMap){\n\t\t\tStringBuffer s = new StringBuffer();\n\t\t\tchar[][] output = Map.ElementsToChars(map);\n\t\t\t\n\t\t\tfor(int i = 0; i < output.length; i++){\n\t\t\t\ts.append(\"\\n\");\n\t\t\t\ts.append(output[i]);\n\t\t\t}\n\t\t\t\n\t\t\ts.delete(0, 1);\n\n\t\t\treturn s.toString();\n\t\t}else{\n\t\t\treturn this.toString();\n\t\t}\n\t}\n\t\n//------------------------\n\tpublic static enum Elements{\n\t\tPlain,\n\t\tBlickWall,\n\t\tIronWall,\n\t\tWater,\n\t\tTankUp,\n\t\tTankDown,\n\t\tTankLeft,\n\t\tTankRight,\n\t\tIllegalElement;\t\n\t}\n\n\t\n\tpublic static enum Commands{\n\t\tUp,\n\t\tDown,\n\t\tLeft,\n\t\tRight,\n\t\tShoot,\n\t\tIllegalCommand;\n\t}\n\n\tpublic static Map.Elements[][] CharsToElements(char[][] c){\n\t\tMap.Elements[][] res = new Map.Elements[c.length][];\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\tres[i] = new Elements[c[i].length];\n\t\t\tfor(int j = 0; j < c[i].length; j++){\n\t\t\t\tres[i][j] = CharsToElements(c[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static Map.Elements CharsToElements(char c){\n\t\tElements res = Map.Elements.IllegalElement;\n\t\t\n\t\tswitch(c){\n\t\t\tcase '.':\n\t\t\t\tres = Elements.Plain;\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tres = Elements.BlickWall;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tres = Elements.IronWall;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tres = Elements.Water;\n\t\t\t\tbreak;\n\t\t\tcase '^':\n\t\t\t\tres = Elements.TankUp;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tres = Elements.TankDown;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tres = Elements.TankLeft;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tres = Elements.TankRight;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tres = Elements.IllegalElement;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic static char[][] ElementsToChars(Map.Elements[][] e){\n\t\tchar[][] res = new char[e.length][];\n\t\tfor(int i = 0; i < e.length; i++){\n\t\t\tres[i] = new char[e[i].length];\n\t\t\tfor(int j = 0; j < e[i].length; j++){\n\t\t\t\tres[i][j] = ElementsToChars(e[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static char ElementsToChars(Map.Elements e){\n\t\tchar res = 'e';\n\n\t\tswitch(e){\n\t\t\tcase Plain:\n\t\t\t\tres = '.';\n\t\t\t\tbreak;\n\t\t\tcase BlickWall:\n\t\t\t\tres = '*';\n\t\t\t\tbreak;\n\t\t\tcase IronWall:\n\t\t\t\tres = '#';\n\t\t\t\tbreak;\n\t\t\tcase Water:\n\t\t\t\tres = '-';\n\t\t\t\tbreak;\n\t\t\tcase TankUp:\n\t\t\t\tres = '^';\n\t\t\t\tbreak;\n\t\t\tcase TankDown:\n\t\t\t\tres = 'v';\n\t\t\t\tbreak;\n\t\t\tcase TankLeft:\n\t\t\t\tres = '<';\n\t\t\t\tbreak;\n\t\t\tcase TankRight:\n\t\t\t\tres = '>';\n\t\t\t\tbreak;\n\t\t\tcase IllegalElement:\n\t\t\t\tres = 'e';\n\t\t\t\tbreak;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static Commands[] CharsToCommands(char[] c){\n\t\tCommands[] res = new Commands[c.length];\n\t\t\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\tres[i] = CharsToCommands(c[i]);\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tpublic static Commands CharsToCommands(char c){\n\t\tCommands res = Commands.IllegalCommand;\n\t\t\n\t\tswitch(c){\n\t\t\tcase 'U':\n\t\t\t\tres = Commands.Up;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tres = Commands.Down;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tres = Commands.Left;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tres = Commands.Right;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tres = Commands.Shoot;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tres =Commands.IllegalCommand;\n\t\t}\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        ArrayList<char[][]> list = new ArrayList<char[][]>();\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        \n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            \n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            list.add(aryBattleArea);\n        }\n        \n        for( int i = 0 ; i < list.size() ; i++ ){\n        \t\n        \tchar[][] s = list.get(i);\n        \t\n        \tfor( int j = 0 ; j < s.length ; j++ ){\n        \t\tfor( int k = 0 ; k < s[i].length ; k++ ){\n        \t\t\t\n        \t\t\tSystem.out.print(s[j][k]);\n        \t\t\t\n        \t\t}\n        \t\tSystem.out.println();\n        \t}\n        \tSystem.out.println();\n        }\n        \n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                              //  continue;\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    public void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n        //??????????°?  \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t// マップ\n\n\t// 戦車\n\tclass Tank {\n\n\t\tchar[][] map;\n\n\t\tint x, y; \t  // 座標\n\t\tchar dir; \t  // 向いてる方角\n\n\t\tint bx=-1, by=-1;   // 砲弾の座標\n\n\t\tpublic Tank(int x, int y,  int dir, char[][] map) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.map = map;\n\t\t\tif(dir == 0) this.dir = 'L';\n\t\t\telse if(dir == 1) this.dir = 'U';\n\t\t\telse if(dir == 2) this.dir = 'R';\n\t\t\telse if(dir == 3) this.dir = 'D';\n\t\t}\n\n\t\t// 命令\n\t\t// rの取りうる値: UDLR\n\t\tpublic void order(char r) {\n\n\t\t\t// 回転し、進めるのであれば進む\n\t\t\tif(r == 'U') {\n\t\t\t\tdir = 'U';\n\t\t\t\tmap[y][x] = '^';\n\t\t\t\tif(isMovable(x, y-1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty -= 1;\n\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = '^';\n\t\t\t\t} else {\n\t\t\t\t\t// 方向転換だけ行う\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'D') {\n\t\t\t\tdir = 'D';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t\tif(isMovable(x, y+1)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\ty += 1;\n\t\t\t\t\t//\t\t\t\t\t// マップ情報を更新する\n\t\t\t\t\tmap[y][x] = 'v';\n\t\t\t\t}\n\t\t\t} else if(r == 'L') {\n\t\t\t\tdir = 'L';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t\tif(isMovable(x-1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx -= 1;\n\t\t\t\t\tmap[y][x] = '<';\n\t\t\t\t}\n\t\t\t} else if(r == 'R') {\n\t\t\t\tdir = 'R';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t\tif(isMovable(x+1, y)) {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tx += 1;\n\t\t\t\t\tmap[y][x] = '>';\n\t\t\t\t}\n\t\t\t} else if(r == 'S') {\n\t\t\t\tshot(dir);\n\t\t\t}\n\n\t\t}\n\n\t\t// 砲撃\n\t\tpublic void shot(char dir) {\n\n\t\t\t// 砲弾の位置初期化\n\t\t\tbx = x;\n\t\t\tby = y;\n\n\t\t\t// 方向を設定し発射\n\t\t\tmoveBullet(dir);\n\n\t\t}\n\n\t\t// 砲弾の移動\n\t\tpublic void moveBullet(char dir) {\n\n\t\t\t// 移動先座標\n\t\t\tint toX = -1;\n\t\t\tint toY = -1;\n\t\t\tif(dir == 'L') {\n\t\t\t\ttoX = bx-1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx -= 1;\n\t\t\t} else if(dir == 'U') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by-1;\n\t\t\t\tby -= 1;\n\t\t\t} else if(dir == 'R') {\n\t\t\t\ttoX = bx+1;\n\t\t\t\ttoY = by;\n\t\t\t\tbx += 1;\n\t\t\t} else if(dir == 'D') {\n\t\t\t\ttoX = bx;\n\t\t\t\ttoY = by+1;\n\t\t\t\tby += 1;\n\t\t\t}\n\n\t\t\t// 指定座標に移動できれば破壊し移動する\n\t\t\tif(map[toY][toX] == '*') {\n\t\t\t\t// 破壊\n\t\t\t\tmap[toY][toX] = '.';\n\t\t\t\treturn;\n\t\t\t} else if(map[toY][toX] == '#') {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tmoveBullet(dir);\n\t\t\t}\n\t\t}\n\n\t\t// 指定の座標に戦車が進めるか\n\t\tpublic boolean isMovable(int x, int y) {\n\n\t\t\tif(map[y][x] == '.') return true;\n\t\t\telse return false;\n\n\t\t}\n\n\t\t// マップを表示\n\t\tpublic void drawMap() {\n\t\t\tfor(int i=1; i<map.length-1; i++) {\n\t\t\t\tfor(int j=1; j<map[i].length-1; j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップから戦車の位置と向きを取得する\n\t// @return int[] [0]戦車のx座標, [1]戦車のy座標, [2]戦車の向き(左から時計回りに0~3)\n\tpublic int[] getTankDir(char[][] map) {\n\n\t\tint[] ret = new int[3];\n\t\tfor(int i=0; i<map.length; i++) {\n\t\t\tfor(int j=0; j<map[i].length; j++){\n\t\t\t\tif(map[i][j] == '<') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 0;\n\t\t\t\t} else if(map[i][j] == '^') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 1;\n\t\t\t\t} else if(map[i][j] == '>') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 2;\n\t\t\t\t} else if(map[i][j] == 'v') {\n\t\t\t\t\tret[0] = j;\n\t\t\t\t\tret[1] = i;\n\t\t\t\t\tret[2] = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// マップセットの個数入力\n\t\tint num = sc.nextInt();\n\n\t\tfor(int n=0; n<num; n++) {\n\n\t\t\t// 地図データの入力\n\t\t\tint y = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\n\t\t\tchar[][] map = new char[y+2][x+2];\n\n\t\t\t// 外を埋める\n\t\t\tfor(int i=0; i<y+2; i++) {\n\t\t\t\tfor(int j=0; j<x+2; j++) {\n\t\t\t\t\tif(i == 0 || i == y+1 || j == 0 || j == x+1) map[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t\t\tmap[i][j] = line.toCharArray()[j-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// マップを表示\n\t\t\t//\t\tfor(int i=1; i<y+1; i++) {\n\t\t\t//\t\t\tfor(int j=1; j<x+1; j++) {\n\t\t\t//\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\tSystem.out.println(\"\");\n\t\t\t//\t\t}\n\n\t\t\t// 命令を入力\n\t\t\tint orderNum = sc.nextInt();\n\t\t\tString orders = sc.next();\n\t\t\tchar[] orderArr = orders.toCharArray();\n\n\t\t\tMain b = new Main();\n\n\t\t\t// 戦車の初期位置と向きを取得\n\t\t\tint[] tankPos = b.getTankDir(map);\n\n//\t\t\tfor(int i=0; i<3; i++) {\n//\t\t\t\tSystem.out.println(tankPos[i]);\n//\t\t\t}\n\n\t\t\t// 戦車を生成\n\t\t\tTank t = new Main().new Tank(tankPos[0], tankPos[1], tankPos[2], map);\n\n\t\t\t// 命令を実行\n\t\t\tfor(int i=0; i<orderNum; i++) {\n\t\t\t\tt.order(orderArr[i]);\n\t\t\t}\n\n\n\t\t\t// debug\n\t\t\t// 戦車の移動テスト\n\t\t\t//\t\tt.rotate('L');\n\n\t\t\t// マップを再表示\n\t\t\tt.drawMap();\n\t\t\tSystem.out.println(\"\");\n\n\t\t}\n\n\t\tsc.close();\n\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tint N, H, W;\n\tScanner sc=new Scanner(System.in);\n\n\tpublic void run(){\n\t\tN=sc.nextInt();\n\t\t\n\t\twhile (N-- != 0) {\n\t\t\tH=sc.nextInt();\n\t\t\tW=sc.nextInt();\n\t\t\tchar[][] map=new char[30][30];\n\t\t\t\n\t\t\tint ph=-1,pw=-1;\n\t\t\tsc.nextLine();\n\t\t\tfor(int h=0;h<H;h++){\n\t\t\t\tString s=sc.nextLine();\n\t\t\t\tmap[h]=s.toCharArray();\n\t\t\t\tfor(int w=0;w<W;w++) {\n\t\t\t\t\tif (map[h][w] == '^' || map[h][w] == '<' || map[h][w] == '>'\n\t\t\t\t\t\t\t|| map[h][w] == 'v') {\n\t\t\t\t\t\tph=h;pw=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint M=sc.nextInt();sc.nextLine();\n\t\t\tString ops=sc.nextLine();\n\t\t\tfor(int m=0;m<M;m++) {\n\t\t\t\tchar op=ops.charAt(m);\n\t\t\t\tswitch (op) {\n\t\t\t\tcase 'S':\n\t\t\t\t\tswitch (map[ph][pw]) {\n\t\t\t\t\tcase '^':\n\t\t\t\t\t\tfor (int h = ph - 1; h >= 0; h--) {\n\t\t\t\t\t\t\tif (map[h][pw] == '*') {\n\t\t\t\t\t\t\t\tmap[h][pw] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (map[h][pw] == '#') {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tfor (int h = ph + 1; h < H; h++) {\n\t\t\t\t\t\t\tif (map[h][pw] == '*') {\n\t\t\t\t\t\t\t\tmap[h][pw] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (map[h][pw] == '#') {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tfor (int w = pw - 1; w >= 0; w--) {\n\t\t\t\t\t\t\tif (map[ph][w] == '*') {\n\t\t\t\t\t\t\t\tmap[ph][w] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (map[ph][w] == '#') {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\tfor (int w = pw + 1; w < W; w++) {\n\t\t\t\t\t\t\tif (map[ph][w] == '*') {\n\t\t\t\t\t\t\t\tmap[ph][w] = '.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (map[ph][w] == '#') {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'U':\n\t\t\t\t\tmap[ph][pw] = '^';\n\t\t\t\t\tif (ph >= 1 && map[ph - 1][pw] == '.') {\n\t\t\t\t\t\tmap[ph][pw] = '.';\n\t\t\t\t\t\tmap[ph - 1][pw] = '^';\n\t\t\t\t\t\tph--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tmap[ph][pw] = 'v';\n\t\t\t\t\tif (ph < H - 1\n\t\t\t\t\t\t\t&& map[ph + 1][pw] == '.') {\n\t\t\t\t\t\tmap[ph][pw] = '.';\n\t\t\t\t\t\tmap[ph + 1][pw] = 'v';\n\t\t\t\t\t\tph++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'R':\n\t\t\t\t\tmap[ph][pw] = '>';\n\t\t\t\t\tif (pw < W - 1\n\t\t\t\t\t\t\t&& map[ph][pw + 1] == '.') {\n\t\t\t\t\t\tmap[ph][pw] = '.';\n\t\t\t\t\t\tmap[ph][pw + 1] = '>';\n\t\t\t\t\t\tpw++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tmap[ph][pw] = '<';\n\t\t\t\t\tif (pw >= 1 && map[ph][pw - 1] == '.') {\n\t\t\t\t\t\tmap[ph][pw] = '.';\n\t\t\t\t\t\tmap[ph][pw - 1] = '<';\n\t\t\t\t\t\tpw--;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int h=0;h<H;h++){ \n\t\t\t\tfor(int w=0;w<W;w++){\n\t\t\t\t\tpr(map[h][w]);\n\t\t\t\t}\n\t\t\t\tln();\n\t\t\t}\n\t\t\tif(N>0)ln();\n\t\t}\n\n\t}\t\n\tpublic static void main(String[]_){\n\t\tnew Main().run();\n\t}\n\t\n\t\n\tpublic static void pr(Object o){\n\t\tSystem.out.print(o);\n\t}\n\t\n\tpublic static void ln(Object o){\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void ln(){\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tchar[][] map;\n\tint dir;\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint t = scan.nextInt();\n\t\tint n;\n\t\tchar[] op;\n\t\tfor(int data = 0;data < t;data++){\n\t\t\th = scan.nextInt();\n\t\t\tw = scan.nextInt();\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tmap[i] = scan.next().toCharArray();\n\t\t\t}\n\t\t\tn = scan.nextInt();\n\t\t\top = scan.next().toCharArray();\n\t\t\tboolean fl = false;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(map[i][j] == '^'){\n\t\t\t\t\t\tdir = 0;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(map[i][j] == '<'){\n\t\t\t\t\t\tdir = 3;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t}else if(map[i][j] == '>'){\n\t\t\t\t\t\tdir = 2;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t}else if(map[i][j] == 'v'){\n\t\t\t\t\t\tdir = 1;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fl){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tswitch(op[i]){\n\t\t\t\tcase 'U':\n\t\t\t\t\tup();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdown();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tright();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tleft();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tshoot();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic void up(){\n\t\tdir = 0;\n\t\tif(y != 0){\n\t\t\tif(map[y-1][x] == '.'){\n\t\t\t\tmap[y--][x] = '.';\n\t\t\t\tmap[y][x] = '^';\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tpublic void down(){\n\t\tdir = 1;\n\t\tif(y != h-1){\n\t\t\tif(map[y+1][x] == '.'){\n\t\t\t\tmap[y++][x] = '.';\n\t\t\t\tmap[y][x] = 'v';\n\t\t\t}\n\t\t}\n\t}\n\tpublic void right(){\n\t\tdir = 2;\n\t\tif(x != w-1){\n\t\t\tif(map[y][x+1] == '.'){\n\t\t\t\tmap[y][x++] = '.';\n\t\t\t\tmap[y][x] = '>';\n\t\t\t}\n\t\t}\n\t}\n\tpublic void left(){\n\t\tdir = 3;\n\t\tif(x != 0){\n\t\t\tif(map[y][x-1] == '.'){\n\t\t\t\tmap[y][x--] = '.';\n\t\t\t\tmap[y][x] = '<';\n\t\t\t}\n\t\t}\n\t}\n\tpublic void shoot(){\n\t\tif(dir == 0){\n\t\t\tfor(int i = y;i >= 0;i--){\n\t\t\t\tif(map[i][x] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[i][x] == '*'){\n\t\t\t\t\tmap[i][x] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir == 1){\n\t\t\tfor(int i = y;i < h;i++){\n\t\t\t\tif(map[i][x] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[i][x] == '*'){\n\t\t\t\t\tmap[i][x] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir == 2){\n\t\t\tfor(int i = x;i < w;i++){\n\t\t\t\tif(map[y][i] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[y][i] == '*'){\n\t\t\t\t\tmap[y][i] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir == 3){\n\t\t\tfor(int i = x;i >= 0;i--){\n\t\t\t\tif(map[y][i] == '#'){\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(map[y][i] == '*'){\n\t\t\t\t\tmap[y][i] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\t// ?????????????????????????§?????????°\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§?????????????????????????????????????????¨\n\t\tint sysout_cnt = data_set;\n\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ?????????????????????????????? ???????????????????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ???????????????????????£?¨?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ??°??¢????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw], new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????°????????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??????????????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, char[][] game_Map) {\n\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = tank.getDir();\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Tank tank, char[][] game_Map, char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ?§????\n\t\t\tonly_flatland_Moving(game_Map, tank, cmd);\n\t\t} else {\n\t\t\t// ??????\n\t\t\tcanon_Shot(game_Map, tank);\n\t\t}\n\t} // tank_Action????????????????????????\n\n\t/**\n\t * ????????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t */\n\tprivate static void canon_Shot(char[][] game_Map, Tank tank) {\n\n//\t\t// ???????????????????¨????\n//\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n//\t\t// ??????????????????????????????\n//\t\tswitch (tank.getDir()) {\n//\t\t// ('^', { -1, 0 });\n//\t\tcase '^':\n//\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n//\t\t\t\tif (game_Map[cnt][shell[1]] == '*') {\n//\t\t\t\t\tgame_Map[cnt][shell[1]] = '.';\n//\t\t\t\t\tbreak;\n//\t\t\t\t} else if (game_Map[cnt][shell[1]] == '#') {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t// ('v',{ 1, 0 });\n//\t\tcase 'v':\n//\t\t\tfor (int cnt = 1; cnt < game_Map.length - shell[0]; cnt++) {\n//\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]] == '*') {\n//\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = '.';\n//\t\t\t\t\tbreak;\n//\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]] == '#') {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t// ('<', { 0, -1 });\n//\t\tcase '<':\n//\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n//\t\t\t\tif (game_Map[shell[0]][cnt] == '*') {\n//\t\t\t\t\tgame_Map[shell[0]][cnt] = '.';\n//\t\t\t\t\tbreak;\n//\t\t\t\t} else if (game_Map[shell[0]][cnt] == '#') {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t// ('>', { 0, 1 });\n//\t\tcase '>':\n//\t\t\tfor (int cnt = 1; cnt < game_Map[1].length - shell[1]; cnt++) {\n//\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt] == '*') {\n//\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = '.';\n//\t\t\t\t\tbreak;\n//\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt] == '#') {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tbreak;\n//\t\t}\n//\n\t\tint[] pos = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t// ???????????????\n\t\tint[] addr = { -1, 1 };\n\n\t\twhile (true) {\n\t\t\tif (tank.getDir() == '^') {\n\t\t\t\tif (pos[0] - 1 >= 0) {\n\n\t\t\t\t\tpos[0] += addr[0];\n//\t\t\t\t\tif (game_Map[pos[0]][pos[1]] == '*') {\n//\t\t\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t} else if (game_Map[pos[0]][pos[1]] == '#') {\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == 'v') {\n\t\t\t\tif (pos[0] + 1 < game_Map.length) {\n\n\t\t\t\t\tpos[0] += addr[1];\n//\t\t\t\t\tif (game_Map[pos[0]][pos[1]] == '*') {\n//\t\t\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t} else if (game_Map[pos[0]][pos[1]] == '#') {\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '<') {\n\t\t\t\tif (pos[1] - 1 >= 0) {\n\n\t\t\t\t\tpos[1] += addr[0];\n//\t\t\t\t\tif (game_Map[pos[0]][pos[1]] == '*') {\n//\t\t\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t} else if (game_Map[pos[0]][pos[1]] == '#') {\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (tank.getDir() == '>') {\n\t\t\t\tif (pos[1] + 1 < game_Map[0].length) {\n\n\t\t\t\t\tpos[1] += addr[1];\n//\t\t\t\t\tif (game_Map[pos[0]][pos[1]] == '*') {\n//\t\t\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t} else if (game_Map[pos[0]][pos[1]] == '#') {\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (game_Map[pos[0]][pos[1]]) {\n\t\t\tcase '.':\n\t\t\tcase '-':\n\t\t\t\tcontinue;\n\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\tcase '*':\n\t\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t\tcase '#':\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}// canon_Shot????????????????????????\n\n\tprivate static void road_MapInfo(char[][] game_Map, int[] pos) {\n\n\t\tif(game_Map[pos[0]][pos[1]] == '*'){\n\t\t\tgame_Map[pos[0]][pos[1]] = '.';\n\t\t}\n\t}\n\n\t/**\n\t * ?????°???????§??????????\n\t *\n\t * @param game_Map\n\t *            char???????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t * @param move\n\t *            ?????????????????¨??°\n\t */\n\tprivate static void only_flatland_Moving(char[][] game_Map, Tank tank, char cmd) {\n\n\t\t// ????????????????????¨?????????????????????\n\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\tint[] addr = { -1, 1 };\n\n\t\tif (tank.getDir() == '^') {\n\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\tmove[0] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == 'v') {\n\t\t\tif (move[0] + 1 < game_Map.length) {\n\t\t\t\tmove[0] += addr[1];\n\t\t\t}\n\t\t} else if (tank.getDir() == '<') {\n\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\tmove[1] += addr[0];\n\t\t\t}\n\t\t} else if (tank.getDir() == '>') {\n\t\t\tif (move[1] + 1 < game_Map[0].length) {\n\t\t\t\tmove[1] += addr[1];\n\t\t\t}\n\t\t}\n\t\tif (game_Map[move[0]][move[1]] == '.') {\n\t\t\ttank.setPos(move);\n\t\t}\n\t}// only_flatland_Moving????????????????????????\n\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "package BattleTown;\n\npublic class BattleTown {\n\t\n\tpublic static void main(String args[]){\n\t\t\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\tprivate String[][] position = null;\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// セッター\n\tpublic void setPosition(String[][] p) {\n\t\tposition = p;\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\tpublic String[][] getPosition() {\n\t\treturn position;\n\t}\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\t// 上向きに移動\n\tpublic void up() {\n\t\tposition = position;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tString[][] map = null;\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(String[][] p,String s){\n\t\t//左向き\n\t\tif(s.equals(\"<\")){\n\t\t\t//\n\t\t\tfor(int i =0; i < p[0].length;i++){\n\t\t\t\tif(map[p.][p.-1].equals(\"*\") || map[p.][p.-1].equals(\"#\")){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//右向き\n\t\tif(s.equals(\">\")){\n\t\t\t\n\t\t}\n\t\t//上向き\n\t\tif(s.equals(\"^\")){\n\t\t\t\n\t\t}\n\t\t//下向き\n\t\tif(s.equals(\"v\")){\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\t// 戦車の移動によるマップ変更 現在位置 向き\n\tpublic void move_tank(String[][] p, String s) {\n\t\t\n\t}\n\n\t// セッター\n\tpublic void setMap(int height, int width) {\n\t\tmap = new String[height][width];\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tstatic int H,W;\n\tstatic char field[][];\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint T=in.nextInt();\n\t\tfor(int I=0;I<T;I++)\n\t\t{\n\t\t\tif(I!=0)\n\t\t\t\tSystem.out.println();\n\t\t\tint H=in.nextInt();\n\t\t\tint W=in.nextInt();\n\t\t\tint sh=0;\n\t\t\tint sw=0;\n\t\t\tint dir=0;\n\t\t\tfield=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tchar ch[]=in.next().toCharArray();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tfield[i][j]=ch[j];\n\t\t\t\t\tif(ch[j]=='>'||ch[j]=='v'||ch[j]=='<'||ch[j]=='^')\n\t\t\t\t\t{\n\t\t\t\t\t\t sh=i;\n\t\t\t\t\t\t sw=j;\n\t\t\t\t\t\t field[i][j]='.';\n\t\t\t\t\t}\n\t\t\t\t\tif(ch[j]=='^')\n\t\t\t\t\t\tdir=1;\n\t\t\t\t\telse if(ch[j]=='>')\n\t\t\t\t\t\tdir=2;\n\t\t\t\t\telse if(ch[j]=='v')\n\t\t\t\t\t\tdir=3;\n\t\t\t\t\telse if(ch[j]=='<')\n\t\t\t\t\t\tdir=4;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint N=in.nextInt();\n\t\t\tchar d[]=in.next().toCharArray();\n\t\t\t\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(d[i]=='U')\n\t\t\t\t{\n\t\t\t\t\tdir=1;\n\t\t\t\t\tif(sh-1>=0&&field[sh-1][sw]=='.')\n\t\t\t\t\t\tsh--;\n\t\t\t\t}\n\t\t\t\telse if(d[i]=='R')\n\t\t\t\t{\n\t\t\t\t\tdir=2;\n\t\t\t\t\tif(sw+1<W&&field[sh][sw+1]=='.')\n\t\t\t\t\t\tsw++;\n\t\t\t\t}\n\t\t\t\telse if(d[i]=='D')\n\t\t\t\t{\n\t\t\t\t\tdir=3;\n\t\t\t\t\tif(sh+1<H&&field[sh+1][sw]=='.')\n\t\t\t\t\t\tsh++;\n\t\t\t\t}\n\t\t\t\telse if(d[i]=='L')\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tdir=4;\n\t\t\t\t\tif(sw-1>=0&&field[sh][sw-1]=='.')\n\t\t\t\t\t\tsw--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint nh=sh;\n\t\t\t\t\tint nw=sw;\n\t\t\t\t\tif(dir==1)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nh>=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnh--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(dir==2)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nw<W)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnw++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(dir==3)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nh<H)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnh++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(dir==4)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(nw>=0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[nh][nw]=='*')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfield[nh][nw]='.';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(field[nh][nw]=='#')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tnw--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dir==1)\n\t\t\t\tfield[sh][sw]='^';\n\t\t\telse if(dir==2)\n\t\t\t\tfield[sh][sw]='>';\n\t\t\telse if(dir==3)\n\t\t\t\tfield[sh][sw]='v';\n\t\t\telse if(dir==4)\n\t\t\t\tfield[sh][sw]='<';\n\t\t\t\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n \n \npublic class Main {\n \n    public static void main(String[] args) throws IOException {\n        // TODO ?????????????????????????????????????????????\n \n \n        BufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n        //ArrayList<Field> list = new ArrayList<Field>();\n        //?????????????????????°?????????\n        String strNum = insBR.readLine();\n        int setNum = Integer.parseInt(strNum);\n \n        int[] aryArea = new int[2];\n        //??????????????????????????´?????????????\n        Field[] aryIns = new Field[setNum];\n         \n        //????????????????????????°??????\n        for(int deta = 0; deta < setNum; deta++){\n            //??????£???????????????§???????????????\n            String strArea = insBR.readLine();\n            String[] area = strArea.split(\" \");\n            int intHeight= Integer.parseInt(area[0]);\n            int intWidth = Integer.parseInt(area[1]);\n            //??????£???????????????§???????????????????????´?\n            //aryArea[0] = intHeight;\n            //aryArea[1] = intWidth;\n \n            //??????£???????????????±?????????????????????\n            String[][] field = new String[intHeight][intWidth];\n            //System.out.println(\"field.length:\" + field.length);\n            //System.out.println(\"field[0].length:\" + field[0].length);\n \n            //??????£??????????????????±??????£??\\\n            for(int j = 0; j < intHeight; j++){\n                //????????\\????????????????????????????????????????????´?\n                //String[] fieldLine = new String[intWidth];\n                String[] fieldLine = insBR.readLine().split(\"\");\n                //System.out.println(\"fieldLine.length:\" + fieldLine.length);\n                for(int i = 0; i < intWidth; i++){\n                     \n                    field[j][i] = fieldLine[i+1];\n                    //System.out.print(field[j][i]);\n                }\n                 \n            }\n             \n \n \n            //????????\\???????????????°?????????\n            int intTimes = Integer.parseInt(insBR.readLine());\n \n            //????????????±?????????????????????????????´?\n            String[] commond = insBR.readLine().split(\"\");\n            //System.out.println(\"commond.length:\" + commond.length);\n \n            //field????????????????????????(??????°?????????£???????????????±???¨?????????????????????)\n            Field insField = new Field(field,commond);\n \n            //????????????????????????\n            insField.chageField();\n            //???????????????????????????????????´?\n            aryIns[deta] = insField;\n \n        }\n \n         \n        //??????£??????????????????\n        for(int k = 0; k < aryIns.length; k++){\n             \n            Field insField = aryIns[k];\n            int intHeight = insField.field.length;\n            int intWidth = insField.field[0].length;\n             \n             \n            for(int j = 0; j < intHeight; j++){\n \n                for(int i = 0; i < intWidth; i++){\n \n                    System.out.print(insField.field[j][i]);\n                }\n                System.out.println();\n            }\n            if(k != aryIns.length-1){\n                System.out.println();\n            }\n        }\n \n \n \n    }//Main??????????????????\n \n \n    /**\n     * ??????£??????????????????*/\n    static class Field{\n \n        /**??????£?????????\n         * ?????????£???????????????±?????????????????????*/\n        private String[][] field;\n        /**\n         * ????????????????????????????????????*/\n        private String[] commond;\n        /**\n         * ??????£???????????????§???????????????????????????*/\n        private int[] aryArea;\n        int intHeight;\n        int intWidth;\n \n \n        /**\n         * ?????????????????????*/\n        Field(String[][] field, String[] commond ){\n \n            this.field = field;\n            this.commond = commond;\n            this.intHeight = field.length;\n            this.intWidth = field[0].length;\n        }\n \n \n \n        /**Method\n         *?????????£???????????????±????????????????????????????????????????????????´??????\n         **/\n        public void chageField(){\n \n            //??????£?????????????????????¨????????????£??\\\n            //int intHeight = aryArea[0];\n            //int intWidth = aryArea[1];\n \n \n            //??????????????????°??????°?????????\n            for(int comNum = 0; comNum < commond.length; comNum++){\n                //System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n \n                //???????????????±???¨???????????????\n                int[] tank = getTank();\n                int j = tank[0];\n                int i = tank[1];\n                int tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n                //System.out.println(\"tank:\" + j + i);\n \n                //???????????????(?????¨????)\n                if(\"S\".equals(commond[comNum])){\n \n                    //???????????¬???????¨??????¢????????????????????????°\n                    String nextArea = \"\";\n \n                    //????????????????????????(?????????)\n                    if(tankHead == 1){// ^??????\n \n                        //??¬???????¨??????¢????????????¬??????¬???§????????????°??????¨??????¢????????????\n                        for(int k = j-1; 0 <= k; k--){\n \n                            nextArea = field[k][i];\n \n                            if(\"#\".equals(nextArea)){\n                                //?????????´???????????????????????????¬??????\n                                break;\n                            }else if(\"*\".equals(nextArea)){\n                                //???¬??????¬??????´????????????°?????????\n                                field[k][i] = \".\";\n                                break;\n                            }\n                        }\n                    }else if(tankHead == 2){// >??????\n \n                        //??¬???????¨??????¢????????????¬??????¬???§????????????°??????¨??????¢????????????\n                        for(int k = i+1; k <= intWidth -1; k++){\n                        nextArea = field[j][k];\n \n                            if(\"#\".equals(nextArea)){\n                                //?????????´???????????????????????????¬??????\n                                break;\n                            }else if(\"*\".equals(nextArea)){\n                                //???¬??????¬??????´????????????°?????????\n                                field[j][k] = \".\";\n                                break;\n                            }\n                        }\n \n                    }else if(tankHead == 3){// v??????\n \n                        //??¬???????¨??????¢????????????¬??????¬???§????????????°??????¨??????¢????????????\n                        for(int k = j+1; k <= intHeight -1; k++){\n                            nextArea = field[k][i];\n \n                            if(\"#\".equals(nextArea)){\n                                //?????????´???????????????????????????¬??????\n                                break;\n                            }else if(\"*\".equals(nextArea)){\n                                //???¬??????¬??????´????????????°?????????\n                                field[k][i] = \".\";\n                                break;\n                            }\n                        }\n \n                    }else if(tankHead == 4){// <??????\n \n                        //??¬???????¨??????¢????????????¬??????¬???§????????????°??????¨??????¢????????????\n                        for(int k = i-1; 0 <= k; k--){\n                            nextArea = field[j][k];\n \n                            if(\"#\".equals(nextArea)){\n                                //?????????´???????????????????????????¬??????\n                                break;\n                            }else if(\"*\".equals(nextArea)){\n                                //???¬??????¬??????´????????????°?????????\n                                field[j][k] = \".\";\n                                break;\n                            }\n                        }\n \n                    }//commond\"S\"end\n \n \n                }else if(\"U\".equals(commond[comNum])){\n \n \n                    //nextArea = field[j-1][i];\n                    if(j == 0 || !\".\".equals(field[j-1][i])){\n                        //??????????????????????????????´?????????????????¬???????¨??????¢?????????°???§??????????????????????????????´\n                        field[j][i] = \"^\";\n                    }else if(\".\".equals(field[j-1][i])) {\n                        //??¬???????¨??????¢????????????´??????????????????°??????´???\n \n                        field[j-1][i] = \"^\";//??????????????????\n                        field[j][i] = \".\";//?????????¨??????¢?????????°?????????\n                    }//commond\"U\"end\n \n                }else if(\"R\".equals(commond[comNum])){\n \n                    //nextArea = field[j][i+1];\n                    if(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n                        //??????????????????????????????´????????????????????????´\n                        field[j][i] = \">\";\n                    }else if(\".\".equals(field[j][i+1])){\n                        //??¬???????¨??????¢????????????´????????????°??????´???\n                        field[j][i+1] = \">\";//??????????????????\n                        field[j][i] = \".\";//?????????¨??????¢?????????°?????????\n                    }//commond\"R\"end\n \n \n                }else if(\"D\".equals(commond[comNum])){\n \n \n                    if(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n                        //??????????????????????????????´????????????????????????´\n                        field[j][i] = \"v\";\n                        }else if(\".\".equals(field[j+1][i])){\n \n                            field[j+1][i] = \"v\";\n                            field[j][i] = \".\";\n                    }//commond\"D\"end\n \n \n                }else if(\"L\".equals(commond[comNum])){\n \n \n                    if(i == 0 || !\".\".equals(field[j][i-1])){\n                        //???????????????????????????´????????????????????????´\n                        field[j][i] = \"<\";\n                    }else if(\".\".equals(field[j][i-1])){\n \n                        field[j][i-1] = \"<\";\n                        field[j][i] = \".\";\n                    }//commond\"L\"end\n \n                }\n \n \n                /*System.out.println(\"????????????\");\n                for(int jj = 0; jj < intHeight; jj++){\n                    for(int ii = 0; ii < intWidth; ii++){\n                        System.out.print(field[jj][ii]);\n                    }\n                    System.out.println();\n                }\n                System.out.println();*/\n            }\n \n        }//changeField End\n \n        /**\n         * ????????????????????????????????????\n         *\n         * */\n        public int[] getTank(){\n \n            //?????????????????????±???¨???????????????????????????\n            int[] tank = new int[3];\n            //??????£???????????????§??????\n            //int intHeight = aryArea[0];\n            //int intWidth = aryArea[1];\n \n            //for??????§??????????????????????????????\n            for(int j = 0; j < intHeight; j++){\n                for(int i = 0; i < intWidth; i++){\n \n                    if(\"^\".equals(field[j][i])){\n                        tank[0] = j;\n                        tank[1] = i;\n                        tank[2] = 1;\n                    }else if(\">\".equals(field[j][i])){\n                        tank[0] = j;\n                        tank[1] = i;\n                        tank[2] = 2;\n                    }else if(\"v\".equals(field[j][i])){\n                        tank[0] = j;\n                        tank[1] = i;\n                        tank[2] = 3;\n                    }else if(\"<\".equals(field[j][i])){\n                        tank[0] = j;\n                        tank[1] = i;\n                        tank[2] = 4;\n                    }\n \n                }\n            }\n            return tank;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\n\t\t// ?????????????????§????????????????????????????????????????????°\n\t\tint sysout_cnt = data_set;\n\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\n\t\t\t// ????????????????????¨???????????????\n\t\t\tMap mp = new Map(map_height, map_width);\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??????????????????\n\t\t\tsysout_cnt--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t// AOJ?????????????§?????????????????????????????????¨????????????\n\t\t\tif (sysout_cnt > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\n\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *            ??????????????????????????¶\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\t\t\t// ????????????????????¨?????????????????????\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('U', '^');\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n//\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n//\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]-1].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// ('D', 'v');\n\t\t\t// ('v', { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n//\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n//\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]+1][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('L', '<');\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n//\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n//\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]-1].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('R', '>');\n\t\t\t// ('>',{ 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n//\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n//\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]+1].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\t// ??????????????????????????????\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// ('^', { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('v',{ 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getHeight()) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('<', { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// ('>', { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt < (mp.getWidth()) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        \n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            \n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            for( int x = 0 ; x < aryBattleArea.length ; x++ ){\n                for( int y = 0 ; y < aryBattleArea[i].length ; y++ ){\n                \t\n                    System.out.print(aryBattleArea[x][y]);\n                    \n                }\n                System.out.println();\n            }\n        }\n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                              //  continue;\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    public void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n        //??????????°?  \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tint tankPositionH = 0;\n\t\t\tint tankPositionW = 0;\n\n\t\t\tfor(int j = 0; j < height; j++) {\n\n\t\t\t\tfor(int k = 0; k < width; k++) {\n\n\t\t\t\t\tif(townMap[j][k].equals(\"^\") || townMap[j][k].equals(\"v\")\n\t\t\t\t\t\t\t|| townMap[j][k].equals(\"<\") || townMap[j][k].equals(\">\")) {\n\n\t\t\t\t\t\ttankPositionH = j;\n\t\t\t\t\t\ttankPositionW = k;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ?????????????????????????????§??????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\tString direction = tank.changeDirection(commandArray[j]);\n\n\t\t\t\t\t// ????????????????????????????????¨??????????????´\n\t\t\t\t\tswitch(direction) {\n\n\t\t\t\t\tcase \"^\":\n\n\t\t\t\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"v\":\n\n\t\t\t\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"<\":\n\n\t\t\t\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \">\":\n\n\t\t\t\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 2) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(j < height -2) {\n\n\t\t\t\t\tSystem.out.println();\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// ???????????????\nclass Tank{\n\n\t// ?????????????????????????????????\n\tString changeDirection(char command){\n\n\t\tString direction = null;\n\n\t\tswitch(command){\n\n\t\tcase 'U':\n\n\t\t\tdirection = \"^\";\n\t\t\tbreak;\n\n\t\tcase 'D':\n\n\t\t\tdirection = \"v\";\n\t\t\tbreak;\n\n\t\tcase 'L':\n\n\t\t\tdirection = \"<\";\n\t\t\tbreak;\n\n\t\tcase 'R':\n\n\t\t\tdirection = \">\";\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn direction;\n\n\t}\n\n\tvoid shoot(String[][] townMap, int height, int width, int tankPositionH, int tankPositionW) {\n\n\t\tswitch(townMap[tankPositionH][tankPositionW]) {\n\n\t\tcase \"^\":\n\n\t\t\tfor(int i = tankPositionH - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPositionH + 1; i < height; i++) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPositionW - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPositionW + 1; i < width; i++) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ?????£????????????????????§????????????\n\t\t\tField field = new Field(townMap);\n\t\t\t// ??????????????????????????????\n\t\t\tint[] tankPosition = field.tankPosition();\n\t\t\t// ????????????????????????\n\t\t\tString tankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank(tankPosition, tankDirection);\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(tankDirection, field);\n\n\t\t\t\t// ?§???????????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ???????§????????????????\n\t\t\t\t\ttank.move(commandArray[j], field);\n\t\t\t\t\ttankPosition = field.tankPosition();\n\t\t\t\t\ttankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ?????£??????????????????\nclass Field{\n\n\t// ?????£??????????????°\n\tString[][] field;\n\n\t// ?????????????????????\n\tField(String[][] field){\n\n\t\tthis.field = new String[field.length][];\n\n\t\tfor(int i = 0; i < field.length; i++) {\n\n\t\t\tthis.field[i] = field[i];\n\n\t\t\tfor(int j = 0; j < field[i].length; j++) {\n\n\t\t\t\tthis.field[i][j] = field[i][j];\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// ??????????????????????´¢??????????????????\n\tint[] tankPosition() {\n\n\t\tint[] tankPosition = new int[2];\n\n\t\tfor(int i = 0; i < this.field.length; i++) {\n\n\t\t\tfor(int j = 0; j < this.field[i].length; j++) {\n\n\t\t\t\tif(field[i][j].equals(\"^\") || field[i][j].equals(\"v\")\n\t\t\t\t\t\t|| field[i][j].equals(\"<\") || field[i][j].equals(\">\")) {\n\n\t\t\t\t\ttankPosition[0] = i;\n\t\t\t\t\ttankPosition[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tankPosition;\n\n\t}\n}\n\n// ???????????????\nclass Tank{\n\n\t// ?????£??????????????°\n\tint[] tankPosition = new int[2];\n\tString tankDirection;\n\n\t// ?????????????????????\n\tTank(int[] tankPosition, String tankDirection) {\n\n\t\tthis.tankPosition[0] = tankPosition[0];\n\t\tthis.tankPosition[1] = tankPosition[1];\n\t\tthis.tankDirection = tankDirection;\n\t}\n\n\t// ??????????§??????????????????????\n\tvoid move(char command, Field field) {\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command) {\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != 0 && field.field[tankPosition[0] - 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] - 1][tankPosition[1]] = \"^\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[0] = tankPosition[0] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"^\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'D':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != field.field.length - 1 && field.field[tankPosition[0] + 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] + 1][tankPosition[1]] = \"v\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[0] = tankPosition[0] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"v\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'L':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != 0 && field.field[tankPosition[0]][tankPosition[1] - 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] - 1] = \"<\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[1] = tankPosition[1] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"<\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'R':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != field.field[0].length - 1 && field.field[tankPosition[0]][tankPosition[1] + 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] + 1] = \">\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\ttankPosition[1] = tankPosition[1] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \">\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\t// ???????????????????????????\n\tvoid shoot(String tankDirection, Field field) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(tankDirection) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPosition[0] - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPosition[0] + 1; i < field.field.length; i++) {\n\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPosition[1] - 1; i >= 0; i--) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPosition[1] + 1; i < field.field[0].length; i++) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}\n\n\n//===========================??????=============================================\n\n/*public class MainBatlleTown {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tint tankPositionH = 0;\n\t\t\tint tankPositionW = 0;\n\n\t\t\tfor(int j = 0; j < height; j++) {\n\n\t\t\t\tfor(int k = 0; k < width; k++) {\n\n\t\t\t\t\tif(townMap[j][k].equals(\"^\") || townMap[j][k].equals(\"v\")\n\t\t\t\t\t\t\t|| townMap[j][k].equals(\"<\") || townMap[j][k].equals(\">\")) {\n\n\t\t\t\t\t\ttankPositionH = j;\n\t\t\t\t\t\ttankPositionW = k;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t// ??????????§?????????´???\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?????????)\n\t\t\t\t\ttankPositionH = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t// ?¨????????§?????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?¨???????)\n\t\t\t\t\ttankPositionW = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// ???????????????\nclass Tank{\n\n\t// ??????????§??????????????????????\n\tint move(char command, String[][] townMap, int height, int width, int tankPositionH, int tankPositionW){\n\n\t\t// ?????????(??????????????¨??°)?????\\???????????°\n\t\tint tankPosition = 0;\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command){\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t// ?????¨??°????????????????????????????????????????????????\n\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°????????°???????????????\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t// ?§???????????????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH - 1;\n\n\t\t\t// ???????????°?????????????????°?????????????????´\n\t\t\t} else {\n\n\t\t\t\t// ???????????´\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ???????§????????????????\n\t\tcase 'D':\n\n\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionH + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'L':\n\n\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW - 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'R':\n\n\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// ?????´??????????????¨??°???????????????\n\t\treturn tankPosition;\n\n\t}\n\n\n\t// ???????????????????????????\n\tvoid shoot(String[][] townMap, int height, int width, int tankPositionH, int tankPositionW) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(townMap[tankPositionH][tankPositionW]) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPositionH - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°??????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPositionH + 1; i < height; i++) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPositionW - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPositionW + 1; i < width; i++) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}*/\n\n//=======================================================================\n\n\t\t\t//???????????°?????????????????????\n\t\t\t/*for(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ?????????????????????????????§??????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\t// String direction = tank.changeDirection(commandArray[j]);\n\t\t\t\t\ttankPositionH = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttankPositionW = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t\t// ????????????????????????????????¨??????????????´\n\t\t\t\t\tswitch(direction) {\n\n\t\t\t\t\tcase \"^\":\n\n\t\t\t\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"v\":\n\n\t\t\t\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"<\":\n\n\t\t\t\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \">\":\n\n\t\t\t\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}*/\n\n\n\t\t\t\t//String direction = tank.changeDirection(commandArray[j]);\n\n\t\t\t\t//String direction = null;\n\n\t\t\t\t/*\n\t\t\t\tswitch(direction){\n\t\t\t\tcase 'U':\n\n\t\t\t\t\tdirection = \"^\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'D':\n\n\t\t\t\t\tdirection = \"v\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'L':\n\n\t\t\t\t\tdirection = \"<\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'R':\n\n\t\t\t\t\tdirection = \">\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn direction;\n\n\t\t\t}*/"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\t//?????£?????????????????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString[] area = insBR.readLine().split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±???????´?\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\t//?????£??????????????±?????????\n\t\t\t\tString[] fieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i+1];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\n\t\t\t//?????????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\n\t\t\tField insField = aryIns[k];\n\t\t\t//????????????????????????????????????????????¨????????????\n\t\t\tint intHeight = insField.field.length;\n\t\t\tint intWidth = insField.field[0].length;\n\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != aryIns.length -1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£????????????????????¨???????????????????????°*/\n\t\tprivate int intHeight;\n\t\tprivate int intWidth;\n\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.intHeight = field.length;\n\t\t\tthis.intWidth = field[0].length;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tint input_length = 0;\n\t\t\t// マップの高さ\n\t\t\tint height = 0;\n\t\t\t// マップの幅\n\t\t\tint width = 0;\n\t\t\t// 各完成マップを入れる配列\n\t\t\tArrayList<map3> map_list = new ArrayList<map3>();\n\t\t\t// 入力の回数\n\t\t\t\tinput_length = sc.nextInt();\n\n\t\t\t// 入力回数分ゲームをする\n\t\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t\t\t// マップの高さ\n\t\t\t\t\theight = sc.nextInt();\n\t\t\t\t\t// マップの幅\n\t\t\t\t\twidth = sc.nextInt();\n\n\t\t\t\t// マップのインスタンスを作る\n\t\t\t\tmap3 map = new map3();\n\t\t\t\t// 戦車のインスタンスを作る\n\t\t\t\ttank3 tank = new tank3();\n\t\t\t\tmap.setMap(height, width);\n\n\t\t\t\tString line = null;\n\t\t\t\t// マップ作成\n\t\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t\t// マップ一列\n\t\t\t\t\t\tline = sc.next();\n\t\t\t\t\t// 一文字ずつに分解\n\t\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t\t//\n\t\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t\t// マップを作る\n\t\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint command_number = 0;\n\t\t\t\tString command_attack = \"\";\n\t\t\t\t// コマンド入力回数\n\t\t\t\t\tcommand_number = sc.nextInt();\n\n\t\t\t\t// コマンドの文字列\n\t\t\t\tchar[] command_at = null;\n\t\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t\t// コマンド回数分まわす\n\t\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t\t// タンクの現在位置を把握\n\t\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t\t// 砲弾発射だったら\n\t\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 移動の場合\n\t\t\t\t\t\tmap.move_tank(tank.getNow_height(),\n\t\t\t\t\t\t\t\ttank.getNow_width(),\n\t\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// リストにできたマップを格納\n\t\t\t\tmap_list.add(map);\n\t\t\t}\n\t\t\t// 結果を出力\n\t\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\t\tmap_list.get(f).out_map();\n\t\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t\t// 改行\n\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.getStackTrace();\n\t\t}\n\t}\n}\n\nclass tank3 {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\nclass map3 {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//AOJ BattleTown\n\nimport java.util.Scanner;\n\nclass Main{\n    \n    /**\n     * ????????°????????¨?????????????????????\n     * @param args\n     */\n    public static void main (String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        \n        //???????????????????????°?????\\???\n        int setCountData = sc.nextInt();\n        \n        //??\\???????????????????????????????????°?????°?????????\n        for( int i = 0 ; i < setCountData ; i++ ){\n        \t\n        \tint aryCountNum1 = sc.nextInt();\n        \tint aryCountNum2 = sc.nextInt();\n        \t\n            //??°??????????????°?????¨??????????????????\n            char[][] aryBattleArea = new char[aryCountNum1][aryCountNum2];\n            \n            //??????aryBattleArea???????????????????´???\\???\n            for( int j = 0 ; j < aryBattleArea.length ; j++ ){\n            \t\n                aryBattleArea[j] = sc.next().toCharArray();\n                \n            }\n            \n            int intOperationLength = sc.nextInt();\n            \n            //??°??????????????°?????¨??????????????????\n            char[] aryOperation = new char[intOperationLength];\n            \n            //??????aryOperation?????????????????\\?????????????????????????????¨????????????????´?\n            aryOperation = sc.next().toCharArray();\n            \n            //BattleTown????????????????????????\n            BattleTown insBt = new BattleTown( aryBattleArea , aryOperation );\n            \n            aryBattleArea = insBt.runOperation();\n            \n            for( int x = 0 ; x < aryBattleArea.length ; x++ ){\n                for( int y = 0 ; y < aryBattleArea[i].length ; y++ ){\n                \t\n                    System.out.print(aryBattleArea[x][y]);\n                    \n                }\n                System.out.println();\n            }\n            \n        }\n    }\n}\n\n/**\n * \n * ?????????????????????\n * @author SS-Internship01\n *\n */\nclass BattleTown{\n    \n    private char[][] aryBattleArea;\n    private char[] aryOperation;\n    \n    /**\n     * ?????????????????????\n     * @param aryBattleArea ?????´?????¨???????¬??????????\n     * @param aryOperation ???????????¨???????¬??????????\n     */\n    public BattleTown(char[][] aryBattleArea , char[] aryOperation ){\n        \n        this.aryBattleArea = aryBattleArea;\n        this.aryOperation = aryOperation;\n        \n    }\n    \n    /**\n     * ?????????????????????????????????actionTank???????????????\n     * ??????????????????'0'????????????????????????????????????\n     */\n    public char[][] runOperation(){\n        \n        for( int k = 0 ; k < aryOperation.length ; k++ ){\n            \n            if( aryOperation[k] != '0' ){\n            \n                for( int i = 0 ; i < aryBattleArea.length ; i++ ){\n                    for( int j = 0 ; j < aryBattleArea[i].length ; j++ ){\n                        \n                        if( aryBattleArea[i][j] == '^' || aryBattleArea[i][j] == 'v' \n                            || aryBattleArea[i][j] == '<'|| aryBattleArea[i][j] == '>'){\n                            \n                                actionTank( i , j , aryOperation[k] );\n                                aryOperation[k] = '0';\n                                continue;\n                            \n                        }\n                    }\n                }\n            }\n        }\n        return aryBattleArea;\n    }\n    \n    /**\n     * ????????????????????????????????????\n     * @param i ????????????????????????????????????\n     * @param j ????????????????????????????????????\n     * @param c ????????????\n     */\n    public void actionTank( int i , int j , char operation ) {\n            \n            //???????????????\n        if( operation == 'U' ){\n            \n            aryBattleArea[i][j] = '^';\n            \n            if( i-1 >= 0 ){\n                if( aryBattleArea[i-1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i-1][j] = '^';\n                }\n            }\n                \n        //???????????????\n        }else if( operation == 'D' ){\n            \n            aryBattleArea[i][j] = 'v';\n            \n            if( i+1 < aryBattleArea.length ){\n                if( aryBattleArea[i+1][j] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i+1][j] = 'v';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'L' ){\n            \n            aryBattleArea[i][j] = '<';\n            \n            if( j-1 >= 0 ){\n                if( aryBattleArea[i][j-1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j-1] = '<';\n                }\n            }\n            \n        //???????????????\n        }else if( operation == 'R' ){\n            \n            aryBattleArea[i][j] = '>';\n            \n            if( j+1 < aryBattleArea[i].length ){\n                if( aryBattleArea[i][j+1] == '.' ){\n                    aryBattleArea[i][j] = '.';\n                    aryBattleArea[i][j+1] = '>';\n                }\n            }\n            \n            \n        //??????????°?  \n        }else if( operation == 'S' ){\n        \n            if(aryBattleArea[i][j] == '^'){\n                \n                for( int x = i ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == 'v'){\n                \n                for( int x = i ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[x][j] == '*' ){\n                        aryBattleArea[x][j] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '<'){\n                \n                for( int x = j ; x >= 0 ; x-- ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n                \n            }else if(aryBattleArea[i][j] == '>'){\n                \n                for( int x = j ; x < aryBattleArea.length ; x++ ){\n                    \n                    if( aryBattleArea[i][x] == '*' ){\n                        aryBattleArea[i][x] = '.';\n                        break;\n                    }else if( aryBattleArea[x][j] == '#' ){\n                        //break;\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tint input_length = 0;\n\t\t\t// マップの高さ\n\t\t\tint height = 0;\n\t\t\t// マップの幅\n\t\t\tint width = 0;\n\t\t\t// 各完成マップを入れる配列\n\t\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t\t// 入力の回数\n\t\t\t\tinput_length = sc.nextInt();\n\n\t\t\t// 入力回数分ゲームをする\n\t\t\tfor (int i = 0; i < input_length; i++) {\n\t\t\t\t\t// マップの高さ\n\t\t\t\t\theight = sc.nextInt();\n\t\t\t\t\t// マップの幅\n\t\t\t\t\twidth = sc.nextInt();\n\n\t\t\t\t// マップのインスタンスを作る\n\t\t\t\tmap map = new map();\n\t\t\t\t// 戦車のインスタンスを作る\n\t\t\t\ttank tank = new tank();\n\t\t\t\tmap.setMap(height, width);\n\n\t\t\t\tString line = null;\n\t\t\t\t// マップ作成\n\t\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t\t// マップ一列\n\t\t\t\t\t\tline = sc.next();\n\t\t\t\t\t// 一文字ずつに分解\n\t\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t\t//\n\t\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t\t// マップを作る\n\t\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint command_number = 0;\n\t\t\t\tString command_attack = \"\";\n\t\t\t\t// コマンド入力回数\n\t\t\t\t\tcommand_number = sc.nextInt();\n\n\t\t\t\t// コマンドの文字列\n\t\t\t\tchar[] command_at = null;\n\t\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t\t// コマンド回数分まわす\n\t\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t\t// タンクの現在位置を把握\n\t\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t\t// 砲弾発射だったら\n\t\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 移動の場合\n\t\t\t\t\t\tmap.move_tank(tank.getNow_height(),\n\t\t\t\t\t\t\t\ttank.getNow_width(),\n\t\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// リストにできたマップを格納\n\t\t\t\tmap_list.add(map);\n\t\t\t}\n\t\t\t// 結果を出力\n\t\t\tfor (int f = 0; f < map_list.size(); f++) {\n\t\t\t\tmap_list.get(f).out_map();\n\t\t\t\tif (f != (map_list.size() - 1)) {\n\t\t\t\t\t// 改行\n\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.getStackTrace();\n\t\t}\n\t}\n}\n\nclass tank3 {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\nclass map3 {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\t// ???????????????\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], 'W');\n\t\t\t}\n\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = tmp_row.charAt(mw);\n\n\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t// ???????????????????????°????????????\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw + 1]) > -1) {\n\t\t\t\t\t\t// init tank.\n\t\t\t\t\t\ttank = new Tank(game_Map, game_Map[mh][mw + 1], new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\ttank.command(cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\ttank.last_tankLocate();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\t// ???????????????????????°????????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n}// ???????????????????????????????????????\n\nclass Tank {\n\n\t/**\n\t * ?????????\n\t */\n\tprivate char[][] map;\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/*\n\t * ????????????????????????\n\t */\n\tTank(char[][] map, char dir, int[] pos) {\n\t\tthis.dir = dir;\n\t\tthis.map = map;\n\t\tthis.pos = pos;\n\t}\n\n\t/*\n\t * ?§??????????\n\t */\n\tHashMap<Character, Character> move_Cmd = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t/*\n\t * ?§??????¢???\n\t */\n\tHashMap<Character, int[]> move_Dir = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ???????????????????????°????????????\n\tvoid command(char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\tmove_tank(cmd);\n\t\t} else {\n\t\t\tcannon_Shot();\n\t\t}\n\t}\n\n\t/**\n\t * <pre>\n\t * ?????????????????????\n\t * ????????¬?????¬????£??????¶????????£???????????°?????????\n\t * ?????????????£??????°?????????\n\t * ????????°??????????????¨??§?????£????????????????¶????\n\t * </pre>\n\t *\n\t * @param shell\n\t *            ??????\n\t */\n\tprivate void cannon_Shot() {\n\t\tint[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\twhile (true) {\n\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\tcase '.':\n\t\t\tcase '-':\n\t\t\t\tcontinue;\n\t\t\tcase '*':\n\t\t\t\tmap[shell[0]][shell[1]] = '.';\n\t\t\tcase '#':\n\t\t\tcase 'x':\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}// cannon_Shoot????????????????????????\n\n\t/**\n\t * <pre>\n\t *?????????????§????\n\t *\n\t *???????????°???????§??????????\n\t *???????????¬??????????????????????????£????§???????????????¨?????????\n\t * </pre>\n\t *\n\t * @param cmd\n\t *            ?????¬??????????????????\n\t * @param move\n\t *            ??????????§????\n\t */\n\tprivate void move_tank(char cmd) {\n\n\t\tthis.dir = move_Cmd.get(cmd);\n\t\tint[] next = new int[] { this.pos[0], this.pos[1] };\n\t\tnext[0] += move_Dir.get(this.dir)[0];\n\t\tnext[1] += move_Dir.get(this.dir)[1];\n\t\tif (map[next[0]][next[1]] == '.') {\n\t\t\tthis.pos[0] = next[0];\n\t\t\tthis.pos[1] = next[1];\n\t\t}\n\t}// move_tank????????????????????????\n\n\tvoid last_tankLocate() {\n\t\t// ?????????????????¨??°?????°????????¨?¨???????\n\t\tmap[this.pos[0]][this.pos[1]] = this.dir;\n\t}\n\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main {\n\t/*\n\t * ????????°???????????¨?????????????????????\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// ?????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint data_set = sc.nextInt();\n\t\t// ??????????????°????????????????§??????????\n\t\tfor (int game_cnt = 0; game_cnt < data_set; game_cnt++) {\n\t\t\t// ??????????????????,???????????????\n\t\t\tint map_height = sc.nextInt();\n\t\t\tint map_width = sc.nextInt();\n\n\t\t\t// ?????????????????????????????±???????´?\n\t\t\tTank tank = null;\n\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tMap[][] game_Map = new Map[map_height][map_width];\n\t\t\t//\n\t\t\tMap mp = new Map(map_height, map_width);\n\n\t\t\tfor (int mh = 0; mh < map_height; mh++) {\n\t\t\t\t// ????????????\n\t\t\t\tString tmp_row = sc.next();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw] = new Map(tmp_row.charAt(mw));\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw].getMap_info()) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map[mh][mw].getMap_info(), new int[] { mh, mw });\n\t\t\t\t\t\tgame_Map[mh][mw] = new Map('.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ???????????°\n\t\t\tint cmd_set = sc.nextInt();\n\t\t\t// ?????????????????????\n\t\t\tString tmp_cmdRow = sc.next();\n\t\t\tfor (int cnt = 0; cnt < cmd_set; cnt++) {\n\t\t\t\ttank_Action(mp, tank, game_Map, tmp_cmdRow.charAt(cnt));\n\t\t\t}\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\tlast_tankLocate(tank, game_Map);\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 0; ch < map_height; ch++) {\n\t\t\t\tfor (int cw = 0; cw < map_width; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw].getMap_info());\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} // for?????????????????????\n\t\t\t// ????????°??????????????????\n\t\tsc.close();\n\t}// ?????????????????????????????????\n\n\t/**\n\t * ?????????????????¨??°?????°????????¨?¨???????\n\t */\n\tprivate static void last_tankLocate(Tank tank, Map[][] game_Map) {\n\n\t\tchar tmp_dir = tank.getDir();\n\t\tgame_Map[tank.getPos()[0]][tank.getPos()[1]] = new Map(tmp_dir);\n\n\t}// last_tankLocate????????????????????????\n\n\t/**\n\t * ??????????????£????§????????????????????????????\n\t *\n\t * @param mp\n\t *\n\t * @param game_Map\n\t *            ??????????????°??????????????????\n\t * @param tank\n\t *            ??????????????????????????¶\n\t * @param cmd\n\t *            ??????\n\t */\n\tprivate static void tank_Action(Map mp, Tank tank, Map[][] game_Map, char cmd) {\n\t\t/*\n\t\t * ?§????\n\t\t */\n\t\tif (cmd != 'S') {\n\n\t\t\ttank.setDir(tank.getCmd_Map().get(cmd));\n\t\t\tint[] move = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('U', '^');\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tif (move[0] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// put('D', 'v');\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tif (move[0] + 1 < mp.getHeight()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('L', '<');\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tif (move[1] - 1 >= 0) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('R', '>');\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tif (move[1] + 1 < mp.getWidth()) {\n\t\t\t\t\tmove[0] += mp.getDir_Map().get(tank.getDir())[0];\n\t\t\t\t\tmove[1] += mp.getDir_Map().get(tank.getDir())[1];\n\t\t\t\t\tif (game_Map[move[0]][move[1]].getMap_info() == '.') {\n\t\t\t\t\t\ttank.setPos(move);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ??????\n\t\t\t *\n\t\t\t * ????????? ?????????????????¨??????????????£???if-else if???????????¨??? ??????????????£???????¬??????????????????§????????????????????????????¨????\n\t\t\t *\n\t\t\t */\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { tank.getPos()[0], tank.getPos()[1] };\n\t\t\tswitch (tank.getDir()) {\n\t\t\t// put('^', new int[] { -1, 0 });\n\t\t\tcase '^':\n\t\t\t\tfor (int cnt = shell[0]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('v', new int[] { 1, 0 });\n\t\t\tcase 'v':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getHeight() - 1) - shell[0]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0] + cnt][shell[1]] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0] + cnt][shell[1]].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('<', new int[] { 0, -1 });\n\t\t\tcase '<':\n\t\t\t\tfor (int cnt = shell[1]; cnt >= 0; cnt--) {\n\t\t\t\t\tif (game_Map[shell[0]][cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// put('>', new int[] { 0, 1 });\n\t\t\tcase '>':\n\t\t\t\tfor (int cnt = 1; cnt <= (mp.getWidth() - 1) - shell[1]; cnt++) {\n\t\t\t\t\tif (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '*') {\n\t\t\t\t\t\tgame_Map[shell[0]][shell[1] + cnt] = new Map('.');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (game_Map[shell[0]][shell[1] + cnt].getMap_info() == '#') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // tank_Action????????????????????????\n}// ??????????????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Tank {\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\tpublic int[] getPos() {\n\t\treturn pos;\n\t}\n\n\tpublic void setPos(int[] position) {\n\t\tthis.pos = position;\n\t}\n\n\tpublic char getDir() {\n\t\treturn dir;\n\t}\n\n\tpublic void setDir(char direction) {\n\t\tthis.dir = direction;\n\t}\n\n\tpublic Tank(char direction, int[] tank_pos) {\n\t\tthis.dir = direction;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/**\n\t * ?§??????????????????????\n\t */\n\tprivate HashMap<Character, Character> cmd_Map = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, Character> getCmd_Map() {\n\t\treturn cmd_Map;\n\t}\n\n}// Tank?????????????????????\n\n/**\n * <pre></pre>\n *\n */\nclass Map {\n\n\t/**\n\t * ??°??¢?????±\n\t */\n\tprivate char map_info;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int height;\n\n\t/**\n\t * ??????????????????\n\t */\n\tprivate int width;\n\n\tpublic char getMap_info() {\n\t\treturn map_info;\n\t}\n\n\tpublic void setMap_info(char map_info) {\n\t\tthis.map_info = map_info;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\n\tpublic Map() {\n\n\t}\n\n\tpublic Map(char info) {\n\t\tmap_info = info;\n\t}\n\n\tpublic Map(int map_height, int map_width) {\n\t\tthis.height = map_height;\n\t\tthis.width = map_width;\n\t}\n\n\t/**\n\t * ?§??????¢???????????????\n\t */\n\tprivate HashMap<Character, int[]> dir_Map = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t// ?????????????°???¨\n\tpublic HashMap<Character, int[]> getDir_Map() {\n\t\treturn dir_Map;\n\t}\n\n}// Map?????????????????????"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Battle Town\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tint t = parseInt(br.readLine());\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint h = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint w = parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tchar map[][] = new char[h + 2][w + 2];\n\t\t\tTank tank = null;\n\n\t\t\tfor (int i = 0; i < h + 2; i++) {\n\t\t\t\tArrays.fill(map[i], 'x');\n\t\t\t}\n\n\t\t\tfor (int i = 1; i < h + 1; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j + 1] = line.charAt(j);\n\t\t\t\t\tif (\"^v<>\".indexOf(map[i][j + 1]) > -1) {\n\t\t\t\t\t\t// init tank.\n\t\t\t\t\t\ttank = new Tank(map[i][j + 1], map, new int[]{i, j + 1});\n\t\t\t\t\t\tmap[i][j + 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// sim\n\t\t\tbr.readLine();\n\t\t\tline = br.readLine();\n\t\t\tfor (char c : line.toCharArray()) tank.command(c);\n\t\t\ttank.finish();\n\t\t\tt--;\n\n\t\t\t// solve\n\t\t\tfor (int i = 1; i < h + 1; i++) {\n\t\t\t\tfor (int j = 1; j < w + 1; j++) {\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (t > 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\n\t\t} //end while\n\t} //end main\n}\n\nclass Tank {\n\n\tstatic HashMap<Character, Character> cmds = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\tstatic HashMap<Character, int[]> dirs = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[]{-1, 0});\n\t\t\tput('v', new int[]{1, 0});\n\t\t\tput('<', new int[]{0, -1});\n\t\t\tput('>', new int[]{0, 1});\n\t\t}\n\t};\n\n\tprivate char dir;\n\tprivate char[][] map;\n\tprivate int[] pos;\n\n\tTank(char dir, char[][] map, int[] pos) {\n\t\tthis.dir = dir;\n\t\tthis.map = map;\n\t\tthis.pos = pos;\n\t}\n\n\tvoid command(char cmd) {\n\t\tif (cmd != 'S') {\n\t\t\tmove(cmd);\n\t\t} else {\n\t\t\tshoot();\n\t\t}\n\t}\n\n\tprivate void move(char cmd) {\n\t\tthis.dir = cmds.get(cmd);\n\t\tint[] next = new int[]{this.pos[0], this.pos[1]};\n\t\tnext[0] += dirs.get(this.dir)[0];\n\t\tnext[1] += dirs.get(this.dir)[1];\n\t\tif (map[next[0]][next[1]] == '.') {\n\t\t\tthis.pos[0] = next[0];\n\t\t\tthis.pos[1] = next[1];\n\t\t}\n\t}\n\n\tprivate void shoot() {\n\t\tint[] shell = new int[]{this.pos[0], this.pos[1]};\n\t\twhile (true) {\n\t\t\tshell[0] += dirs.get(this.dir)[0];\n\t\t\tshell[1] += dirs.get(this.dir)[1];\n\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\t\tcase '.':\n\t\t\t\tcase '-':\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '*':\n\t\t\t\t\tmap[shell[0]][shell[1]] = '.';\n\t\t\t\tcase '#':\n\t\t\t\tcase 'x':\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvoid finish() {\n\t\tmap[this.pos[0]][this.pos[1]] = this.dir;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\n\t\t\t// 入力回数分ゲームをする\n\t\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\t\t// マップの高さ\n\t\t\t\theight = sc.nextInt();\n\t\t\t\t// マップの幅\n\t\t\t\twidth = sc.nextInt();\n\n\t\t\t\t// マップのインスタンスを作る\n\t\t\t\tmap map = new map();\n\t\t\t\t// 戦車のインスタンスを作る\n\t\t\t\ttank tank = new tank();\n\t\t\t\tmap.setMap(height, width);\n\n\t\t\t\tString line = null;\n\t\t\t\t// マップ作成\n\t\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t\t// マップ一列\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\t// 一文字ずつに分解\n\t\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t\t//\n\t\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t\t// マップを作る\n\t\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint command_number = 0;\n\t\t\t\tString command_attack = \"\";\n\t\t\t\t// コマンド入力回数\n\n\t\t\t\tcommand_number = sc.nextInt();\n\n\t\t\t\t// コマンドの文字列\n\t\t\t\tchar[] command_at = null;\n\n\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\tcommand_at = command_attack.toCharArray();\n\n\t\t\t\t// コマンド回数分まわす\n\t\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t\t// タンクの現在位置を把握\n\t\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t\t// 砲弾発射だったら\n\t\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 移動の場合\n\t\t\t\t\t\tmap.move_tank(tank.getNow_height(),\n\t\t\t\t\t\t\t\ttank.getNow_width(),\n\t\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// リストにできたマップを格納\n\t\t\t\tmap_list.add(map);\n\t\t\t}\n\t\t\t// 結果を出力\n\t\t\tfor (map obj : map_list) {\n\t\t\t\tobj.out_map();\n\t\t\t\t// 改行\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t\tsc.close();\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main (String args[]){\n\n\t\t//??\\??????????????????????????????Scanner???????????§???????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tint i = 0;\n\n\t\tfor(i = 0; i < T; i++){\n\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tchar[][] map = new char[H][W];\n\n\t\t\t//???0??????1??????2??????3\n\t\t\tchar tank;\n\n\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tString line = sc.next();\n\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tmap[j][k] = line.charAt(k);\n\n\t\t\t\t\tif(map[j][k] == '^' || map[j][k] == 'v' || map[j][k] == '<' || map[j][k] == '>'){\n\t\t\t\t\t\tif(map[j][k] == '^'){\n\t\t\t\t\t\t\ttank = '^';\n\t\t\t\t\t\t}else if(map[j][k] == 'v'){\n\t\t\t\t\t\t\ttank = 'v';\n\t\t\t\t\t\t}else if(map[j][k] == '<'){\n\t\t\t\t\t\t\ttank = '<';\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttank = '>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint t = j;\n\t\t\t\t\t\tint y = k;\n\t\t\t\t\t\tBattle BT = new Battle(t,y,tank,map);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint N = sc.nextInt();\n\t\t\tString com = sc.next();\n\t\t\tchar[] command = new char[N];\n\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tBattle.check(command[j] = com.charAt(j));\n\t\t\t}\n\n\t\t\tSystem.out.println(Battle.output());\n\n\t\t\tif(i != T){\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t}\n}\n\nclass Battle{\n\tstatic int tate;\n\tstatic int yoko;\n\tstatic char tank;\n\tstatic char[][] map;\n\n\t//????????\\??????\n\tBattle(int t, int y, char tankk, char[][] mapp){\n\t\ttate = t;\n\t\tyoko = y;\n\t\tmap = mapp;\n\t\ttank = tankk;\n\t}\n\n\tpublic static String output(){\n\t\tStringBuffer str = new StringBuffer();\n\n\t\tfor(int i = 0; i < map.length; i++){\n\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\tstr.append(map[i][j]);\n\t\t\t}\n\t\t\tstr.append(System.getProperty(\"line.separator\"));\n\t\t}\n\t\tString ans = new String(str);\n\t\treturn ans;\n\t}\n\n\tpublic static void check(char command){\n\n\t\tswitch (command){\n\n\t\tcase 'U':\n\t\t\ttank = '^';\n\t\t\tif(tate > 0){\n\t\t\t\tif(map[tate-1][yoko] == '.'){\n\t\t\t\t\ttate = tate - 1;\n\t\t\t\t\tmap[tate][yoko] = '^';\n\t\t\t\t\tmap[tate+1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\ttank = 'v';\n\t\t\tif((map.length - tate+1) > 0){\n\t\t\t\tif(map[tate+1][yoko] == '.'){\n\t\t\t\t\ttate = tate + 1;\n\t\t\t\t\tmap[tate][yoko] = 'v';\n\t\t\t\t\tmap[tate-1][yoko] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\ttank = '<';\n\t\t\tif(yoko > 0){\n\t\t\t\tif(map[tate][yoko-1] == '.'){\n\t\t\t\t\tyoko = yoko - 1;\n\t\t\t\t\tmap[tate][yoko] = '<';\n\t\t\t\t\tmap[tate][yoko+1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\ttank = '>';\n\t\t\tif((map[tate].length - (yoko+1)) > 0){\n\t\t\t\tif(map[tate][yoko+1] == '.'){\n\t\t\t\t\tyoko = yoko + 1;\n\t\t\t\t\tmap[tate][yoko] = '>';\n\t\t\t\t\tmap[tate][yoko-1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tswitch (tank){\n\t\t\tcase '^':\n\t\t\t\tfor(int i = tate; i >= 0; i--){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'v':\n\t\t\t\tfor(int i = tate; i < map.length; i++){\n\t\t\t\t\tif(map[i][yoko] == '#'){\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}else if(map[i][yoko] == '*'){\n\t\t\t\t\t\tmap[i][yoko] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '<':\n\t\t\t\tfor(int i = yoko; i >= 0; i--){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = -1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tfor(int i = yoko; i < map[tate].length; i++){\n\t\t\t\t\tif(map[tate][i] == '#'){\n\t\t\t\t\t\ti = map[tate].length +1;\n\t\t\t\t\t}else if(map[tate][i] == '*'){\n\t\t\t\t\t\tmap[tate][i] = '.';\n\t\t\t\t\t\ti = map.length +1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tint tankPositionH = 0;\n\t\t\tint tankPositionW = 0;\n\n\t\t\tfor(int j = 0; j < height; j++) {\n\n\t\t\t\tfor(int k = 0; k < width; k++) {\n\n\t\t\t\t\tif(townMap[j][k].equals(\"^\") || townMap[j][k].equals(\"v\")\n\t\t\t\t\t\t\t|| townMap[j][k].equals(\"<\") || townMap[j][k].equals(\">\")) {\n\n\t\t\t\t\t\ttankPositionH = j;\n\t\t\t\t\t\ttankPositionW = k;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?????????)\n\t\t\t\t\ttankPositionH = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?¨???????)\n\t\t\t\t\ttankPositionW = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// ???????????????\nclass Tank{\n\n\t// ??????????§??????????????????????\n\tint move(char command, String[][] townMap, int height, int width, int tankPositionH, int tankPositionW){\n\n\t\t// ??????????????\\???????????°\n\t\tint tankPosition = 0;\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command){\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t// ?????¨??°????????????????????????????????????????????????\n\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°????????°???????????????\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t// ?§???????????????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH - 1;\n\n\t\t\t// ???????????°?????????????????°?????????????????´\n\t\t\t} else {\n\n\t\t\t\t// ???????????´\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ???????§????????????????\n\t\tcase 'D':\n\n\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionH + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'L':\n\n\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW - 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'R':\n\n\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// ?????´??????????????¨??°???????????????\n\t\treturn tankPosition;\n\n\t}\n\n\n\t// ???????????????????????????\n\tvoid shoot(String[][] townMap, int height, int width, int tankPositionH, int tankPositionW) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(townMap[tankPositionH][tankPositionW]) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPositionH - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°??????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPositionH + 1; i < height; i++) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPositionW - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPositionW + 1; i < width; i++) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}\n\n\n//===========================??????=============================================\n\n\t\t\t//???????????°?????????????????????\n\t\t\t/*for(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ?????????????????????????????§??????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\t// String direction = tank.changeDirection(commandArray[j]);\n\t\t\t\t\ttankPositionH = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttankPositionW = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t\t// ????????????????????????????????¨??????????????´\n\t\t\t\t\tswitch(direction) {\n\n\t\t\t\t\tcase \"^\":\n\n\t\t\t\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"v\":\n\n\t\t\t\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"<\":\n\n\t\t\t\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \">\":\n\n\t\t\t\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}*/\n\n\n\t\t\t\t//String direction = tank.changeDirection(commandArray[j]);\n\n\t\t\t\t//String direction = null;\n\n\t\t\t\t/*\n\t\t\t\tswitch(direction){\n\t\t\t\tcase 'U':\n\n\t\t\t\t\tdirection = \"^\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'D':\n\n\t\t\t\t\tdirection = \"v\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'L':\n\n\t\t\t\t\tdirection = \"<\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'R':\n\n\t\t\t\t\tdirection = \">\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn direction;\n\n\t\t\t}*/"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ?????????????????????????????£????????????????????§???????????????(???????????????)\n\t\t\tField field = new Field(townMap);\n\t\t\t// ??????????????????????????????\n\t\t\tint[] tankPosition = field.tankPosition();\n\t\t\t// ????????????????????????\n\t\t\tString tankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank(tankPosition, tankDirection);\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(tankDirection, field);\n\n\t\t\t\t// ?§???????????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ???????§????????????????\n\t\t\t\t\ttank.move(commandArray[j], field);\n\t\t\t\t\t// ?§????????????????????????????????????°?????´??°\n\t\t\t\t\ttankPosition = field.tankPosition();\n\t\t\t\t\t// ?§?????????????????????????????????´??°\n\t\t\t\t\ttankDirection = townMap[tankPosition[0]][tankPosition[1]];\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ?????£??????????????????\nclass Field{\n\n\t// ?????£??????????????°\n\tString[][] field;\n\n\t// ?????????????????????\n\tField(String[][] field){\n\n\t\tthis.field = new String[field.length][];\n\n\t\tfor(int i = 0; i < field.length; i++) {\n\n\t\t\tthis.field[i] = field[i];\n\n\t\t\tfor(int j = 0; j < field[i].length; j++) {\n\n\t\t\t\tthis.field[i][j] = field[i][j];\n\n\t\t\t}\n\t\t}\n\t}\n\n\t// ??????????????????????´¢??????????????????\n\tint[] tankPosition() {\n\n\t\tint[] tankPosition = new int[2];\n\n\t\tfor(int i = 0; i < this.field.length; i++) {\n\n\t\t\tfor(int j = 0; j < this.field[i].length; j++) {\n\n\t\t\t\tif(field[i][j].equals(\"^\") || field[i][j].equals(\"v\")\n\t\t\t\t\t\t|| field[i][j].equals(\"<\") || field[i][j].equals(\">\")) {\n\n\t\t\t\t\ttankPosition[0] = i;\n\t\t\t\t\ttankPosition[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tankPosition;\n\n\t}\n}\n\n// ???????????????\nclass Tank{\n\n\t// ?????£??????????????°\n\tint[] tankPosition = new int[2];\n\tString tankDirection;\n\n\t// ?????????????????????\n\tTank(int[] tankPosition, String tankDirection) {\n\n\t\tthis.tankPosition[0] = tankPosition[0];\n\t\tthis.tankPosition[1] = tankPosition[1];\n\t\tthis.tankDirection = tankDirection;\n\t}\n\n\t// ??????????§??????????????????????\n\tvoid move(char command, Field field) {\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command) {\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != 0 && field.field[tankPosition[0] - 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] - 1][tankPosition[1]] = \"^\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\t//tankPosition[0] = tankPosition[0] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"^\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'D':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[0] != field.field.length - 1 && field.field[tankPosition[0] + 1][tankPosition[1]].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0] + 1][tankPosition[1]] = \"v\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\t//tankPosition[0] = tankPosition[0] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"v\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'L':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != 0 && field.field[tankPosition[0]][tankPosition[1] - 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] - 1] = \"<\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\t//tankPosition[1] = tankPosition[1] - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \"<\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 'R':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPosition[1] != field.field[0].length - 1 && field.field[tankPosition[0]][tankPosition[1] + 1].equals(\".\")){\n\n\t\t\t\t// ??????????????´????????????????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1] + 1] = \">\";\n\t\t\t\t// ??????????????´???????????°???????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \".\";\n\t\t\t\t// ?????????????????¨??°?????£??\\\n\t\t\t\t//tankPosition[1] = tankPosition[1] + 1;\n\n\t\t\t} else {\n\n\t\t\t\t// ???????§?????????????????????¨??°??§????????????????????????\n\t\t\t\tfield.field[tankPosition[0]][tankPosition[1]] = \">\";\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\t// ???????????????????????????\n\tvoid shoot(String tankDirection, Field field) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(tankDirection) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPosition[0] - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPosition[0] + 1; i < field.field.length; i++) {\n\n\t\t\t\tif(field.field[i][tankPosition[1]].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[i][tankPosition[1]].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[i][tankPosition[1]] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPosition[1] - 1; i >= 0; i--) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPosition[1] + 1; i < field.field[0].length; i++) {\n\n\t\t\t\tif(field.field[tankPosition[0]][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(field.field[tankPosition[0]][i].equals(\"*\")) {\n\n\t\t\t\t\tfield.field[tankPosition[0]][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}\n\n\n//===========================??????=============================================\n\n/*public class MainBatlleTown {\n\n\tpublic static void main(String[] args) {\n\n\t\t// ????????????????????°?????\\???\n\t\tScanner in = new Scanner(System.in);\n\t\tint dataSet = in.nextInt();\n\n\t\t// ????????????????????°?????????????????????\n\t\tfor(int i = 0; i < dataSet; i++){\n\n\t\t\t// ?????????????????¨?¨????????????\\???\n\t\t\tint height = in.nextInt();\n\t\t\tint width = in.nextInt();\n\n\t\t\t// ????????????????????????????´???????????¬??????????\n\t\t\tString[][] townMap = new String[height][width];\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(int j = 0; j < height; j ++){\n\n\t\t\t\t// ???????????????????????\\???\n\t\t\t\tString mapData = in.next();\n\n\t\t\t\t// ??\\????????????????????????????????????\n\t\t\t\ttownMap[j] = mapData.split(\"\");\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tint tankPositionH = 0;\n\t\t\tint tankPositionW = 0;\n\n\t\t\tfor(int j = 0; j < height; j++) {\n\n\t\t\t\tfor(int k = 0; k < width; k++) {\n\n\t\t\t\t\tif(townMap[j][k].equals(\"^\") || townMap[j][k].equals(\"v\")\n\t\t\t\t\t\t\t|| townMap[j][k].equals(\"<\") || townMap[j][k].equals(\">\")) {\n\n\t\t\t\t\t\ttankPositionH = j;\n\t\t\t\t\t\ttankPositionW = k;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????°?????\\???\n\t\t\tint commandCount = in.nextInt();\n\n\t\t\t// ??\\????????????????????????????????\\??????????????????????????????1????????????????????????????????????????´?\n\t\t\tString commands = in.next();\n\t\t\tchar[] commandArray = commands.toCharArray();\n\n\t\t\t// ?????????????????§???????????????\n\t\t\tTank tank = new Tank();\n\n\t\t\t// ???????????°?????????????????????\n\t\t\tfor(int j = 0; j < commandCount; j++){\n\n\t\t\t\t// ??????????????????????????´???\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ???????????????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t// ??????????§?????????´???\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?????????)\n\t\t\t\t\ttankPositionH = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t// ?¨????????§?????????´???\n\t\t\t\t} else {\n\n\t\t\t\t\t// ?§??????????????????§??????????§????(?¨???????)\n\t\t\t\t\ttankPositionW = tank.move(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ????????????\n\t\t\tint j = 0;\n\t\t\tint k = 0;\n\n\t\t\t// ???????????????????????????\n\t\t\tfor(j = 0; j < height; j++) {\n\n\t\t\t\tfor(k = 0; k < width; k++) {\n\n\t\t\t\t\tif(k < width - 1) {\n\n\t\t\t\t\t\tSystem.out.print(townMap[j][k]);\n\n\t\t\t\t\t// ???????????¨??????????????\\??????\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tSystem.out.println(townMap[j][k]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??????????????????????????¨????????????????????\\??????\n\t\t\tif(i < dataSet - 1) {\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// ???????????????\nclass Tank{\n\n\t// ??????????§??????????????????????\n\tint move(char command, String[][] townMap, int height, int width, int tankPositionH, int tankPositionW){\n\n\t\t// ?????????(??????????????¨??°)?????\\???????????°\n\t\tint tankPosition = 0;\n\n\t\t// ??\\????????????????????¨?????????\n\t\tswitch(command){\n\n\t\t// ???????§????????????????\n\t\tcase 'U':\n\n\t\t\t// ???????????°???????§????\n\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t// ?????¨??°????????????????????????????????????????????????\n\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°????????°???????????????\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t// ?§???????????????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH - 1;\n\n\t\t\t// ???????????°?????????????????°?????????????????´\n\t\t\t} else {\n\n\t\t\t\t// ???????????´\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\t\t\t\t// ?????¨??°?????????????????£??\\\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ???????§????????????????\n\t\tcase 'D':\n\n\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionH + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\t\t\t\ttankPosition = tankPositionH;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'L':\n\n\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW - 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ??????????????????\n\t\tcase 'R':\n\n\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\ttankPosition = tankPositionW + 1;\n\n\t\t\t} else {\n\n\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\t\t\t\ttankPosition = tankPositionW;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t// ?????´??????????????¨??°???????????????\n\t\treturn tankPosition;\n\n\t}\n\n\n\t// ???????????????????????????\n\tvoid shoot(String[][] townMap, int height, int width, int tankPositionH, int tankPositionW) {\n\n\t\t// ??????????????¨??°??¨??????(????°???????)?????????????????????\n\t\tswitch(townMap[tankPositionH][tankPositionW]) {\n\n\t\t// ????°?????????????\n\t\tcase \"^\":\n\n\t\t\t// ????°????????????????????????????????????\\????§????\n\t\t\tfor(int i = tankPositionH - 1; i >= 0; i--) {\n\n\t\t\t\t// ???????£??????¶???????????¨???????¶???????\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// ??¬?????¬????£??????¶???????????¨??????????????°????????£??????????¶???????\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°??????????\n\t\tcase \"v\":\n\n\t\t\tfor(int i = tankPositionH + 1; i < height; i++) {\n\n\t\t\t\tif(townMap[i][tankPositionW].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[i][tankPositionW].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[i][tankPositionW] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \"<\":\n\n\t\t\tfor(int i = tankPositionW - 1; i >= 0; i--) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// ????°?????????????\n\t\tcase \">\":\n\n\t\t\tfor(int i = tankPositionW + 1; i < width; i++) {\n\n\t\t\t\tif(townMap[tankPositionH][i].equals(\"#\")) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if(townMap[tankPositionH][i].equals(\"*\")) {\n\n\t\t\t\t\ttownMap[tankPositionH][i] = \".\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n}*/\n\n//=======================================================================\n\n\t\t\t//???????????°?????????????????????\n\t\t\t/*for(int j = 0; j < commandCount; j++){\n\n\t\t\t\tif(commandArray[j] == 'S'){\n\n\t\t\t\t\t// ?????????????????????????????§??????????????????\n\t\t\t\t\ttank.shoot(townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t} else if(commandArray[j] == 'U' || commandArray[j] == 'D'){\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\t// String direction = tank.changeDirection(commandArray[j]);\n\t\t\t\t\ttankPositionH = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttankPositionW = tank.changeDirection(commandArray[j], townMap, height, width, tankPositionH, tankPositionW);\n\n\n\t\t\t\t\t// ????????????????????????????????¨??????????????´\n\t\t\t\t\tswitch(direction) {\n\n\t\t\t\t\tcase \"^\":\n\n\t\t\t\t\t\tif(tankPositionH != 0 && townMap[tankPositionH - 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH - 1][tankPositionW] = \"^\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"^\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"v\":\n\n\t\t\t\t\t\tif(tankPositionH != height - 1 && townMap[tankPositionH + 1][tankPositionW].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH + 1][tankPositionW] = \"v\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionH = tankPositionH + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"v\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"<\":\n\n\t\t\t\t\t\tif(tankPositionW != 0 && townMap[tankPositionH][tankPositionW - 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW - 1] = \"<\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW - 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \"<\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \">\":\n\n\t\t\t\t\t\tif(tankPositionW != width - 1 && townMap[tankPositionH][tankPositionW + 1].equals(\".\")) {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW + 1] = \">\";\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \".\";\n\n\t\t\t\t\t\t\ttankPositionW = tankPositionW + 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttownMap[tankPositionH][tankPositionW] = \">\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}*/\n\n\n\t\t\t\t//String direction = tank.changeDirection(commandArray[j]);\n\n\t\t\t\t//String direction = null;\n\n\t\t\t\t/*\n\t\t\t\tswitch(direction){\n\t\t\t\tcase 'U':\n\n\t\t\t\t\tdirection = \"^\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'D':\n\n\t\t\t\t\tdirection = \"v\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'L':\n\n\t\t\t\t\tdirection = \"<\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'R':\n\n\t\t\t\t\tdirection = \">\";\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn direction;\n\n\t\t\t}*/"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\t\t\t// ??????4 6 ???????????¢??????????????°???????????¢??????????´?????????????????????°\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\t// ???????????????\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tchar[][] game_Map = new char[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], 'W');\n\t\t\t}\n\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = tmp_row.charAt(mw);\n\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw + 1]) > -1) {\n\t\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t\ttank = new Tank(game_Map, game_Map[mh][mw + 1], new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray())\n\t\t\t\ttank.command(cmd);\n\n\t\t\t// ????????????????????????????????±?????¨?¨???????\n\t\t\ttank.last_tankLocate();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n}// ???????????????????????????????????????\n\nclass Tank {\n\n\t/**\n\t * ?????????\n\t */\n\tprivate char[][] map;\n\n\t/**\n\t * ??????????????¨??°\n\t */\n\tprivate int[] pos;\n\t/**\n\t * ??????\n\t */\n\tprivate char dir;\n\n\t/*\n\t * ????????????????????????\n\t */\n\tTank(char[][] map_info, char tank_dir, int[] tank_pos) {\n\t\tthis.dir = tank_dir;\n\t\tthis.map = map_info;\n\t\tthis.pos = tank_pos;\n\t}\n\n\t/*\n\t * ?§??????????\n\t */\n\tHashMap<Character, Character> move_Cmd = new HashMap<Character, Character>() {\n\t\t{\n\t\t\tput('U', '^');\n\t\t\tput('D', 'v');\n\t\t\tput('L', '<');\n\t\t\tput('R', '>');\n\t\t}\n\t};\n\n\t/*\n\t * ?§??????¢???\n\t */\n\tHashMap<Character, int[]> move_Dir = new HashMap<Character, int[]>() {\n\t\t{\n\t\t\tput('^', new int[] { -1, 0 });\n\t\t\tput('v', new int[] { 1, 0 });\n\t\t\tput('<', new int[] { 0, -1 });\n\t\t\tput('>', new int[] { 0, 1 });\n\t\t}\n\t};\n\n\t/**\n\t * ??????????????£????§?????????????????????????????????????\n\t * \n\t * @param cmd\n\t *            ??????\n\t */\n\tvoid command(char cmd) {\n\n\t\tif (cmd != 'S') {\n\t\t\t// ??????????????±?????????\n\t\t\tthis.dir = move_Cmd.get(cmd);\n\t\t\tint[] next = new int[] { this.pos[0], this.pos[1] };\n\t\t\tnext[0] += move_Dir.get(this.dir)[0];\n\t\t\tnext[1] += move_Dir.get(this.dir)[1];\n\t\t\t// ?????°???????§??????????\n\t\t\tif (map[next[0]][next[1]] == '.') {\n\t\t\t\tthis.pos[0] = next[0];\n\t\t\t\tthis.pos[1] = next[1];\n\t\t\t}\n\t\t} else {\n\t\t\t// ???????????????????¨????\n\t\t\tint[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\t\twhile (true) {\n\t\t\t\t//????????????????????¢\n\t\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\t\tcase '.':\n\t\t\t\tcase '-':\n\t\t\t\t\tcontinue;\n\t\t\t\t// ??¬?????¬????£???¨??¶????????£????????¬?????¬????????°?????????\n\t\t\t\tcase '*':\n\t\t\t\t\tmap[shell[0]][shell[1]] = '.';\n\t\t\t\tcase '#':\n\t\t\t\t\t// ??????????£???¨??¶????????£????????????????¶????\n\t\t\t\tcase 'W':\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}//command????????????????????????\n\t\n\t// ?????????????????¨??°?????°????????¨?¨???????\n\tvoid last_tankLocate() {\n\t\t\n\t\tmap[this.pos[0]][this.pos[1]] = this.dir;\n\t}// last_tankLocate????????????????????????\n\n}// Tank?????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// // 各完成マップを入れる配列\n\t\t// ArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\t// マップの高さ\n\t\t\t\theight = sc.nextInt();\n\t\t\t\t// マップの幅\n\t\t\t\twidth = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap map = new map();\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank tank = new tank();\n\t\t\tmap.setMap(height, width);\n\n\t\t\tString line = null;\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tline = sc.next();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint command_number = 0;\n\t\t\tString command_attack = \"\";\n\t\t\t// コマンド入力回数\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_number = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\tcommand_at = command_attack.toCharArray();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\t// map_list.add(map);\n\t\t\t// }\n\t\t\t// // 結果を出力\n\t\t\t// for (int f = 0; f < map_list.size(); f++) {\n\t\t\t// map_list.get(f).out_map();\n\t\t\t// if (f != (map_list.size() - 1)) {\n\t\t\t// // 改行\n\t\t\t// System.out.print(\"\\n\");\n\t\t\t// }\n\t\t}\n\t}\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\n\n\t\tBufferedReader insBR =  new BufferedReader(new InputStreamReader(System.in));\n\t\t//ArrayList<Field> list = new ArrayList<Field>();\n\t\t//????????????????????°?????????\n\t\tString strNum = insBR.readLine();\n\t\tint setNum = Integer.parseInt(strNum);\n\n\t\tint[] aryArea = new int[2];\n\t\t//?????????????????????????´?????????????\n\t\tField[] aryIns = new Field[setNum];\n\t\t//???????????????????????°??????\n\t\tfor(int deta = 0; deta < setNum; deta++){\n\t\t\t//?????£??????????????§???????????????\n\t\t\tString strArea = insBR.readLine();\n\t\t\tString[] area = strArea.split(\" \");\n\t\t\tint intHeight= Integer.parseInt(area[0]);\n\t\t\tint intWidth = Integer.parseInt(area[1]);\n\t\t\t//?????£??????????????§??????????????????????´?\n\t\t\taryArea[0] = intHeight;\n\t\t\taryArea[1] = intWidth;\n\n\t\t\t//?????£??????????????±?????????????????????\n\t\t\tString[][] field = new String[intHeight][intWidth];\n\n\t\t\t//?????£?????????????????±?????£??\\\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\t//????????\\???????????????????????????????????????????´?\n\t\t\t\tString[] fieldLine = new String[intWidth];\n\t\t\t\tfieldLine = insBR.readLine().split(\"\");\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tfield[j][i] = fieldLine[i];\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//????????\\??????????????°?????????\n\t\t\tint intTimes = Integer.parseInt(insBR.readLine());\n\n\t\t\t//???????????±????????????????????????????´?\n\t\t\tString[] commond = insBR.readLine().split(\"\");\n\n\t\t\t//field????????????????????????(?????°????????£??????????????±??¨?????????????????????)\n\t\t\tField insField = new Field(field,commond);\n\n\t\t\t//????????????????????????\n\t\t\tinsField.chageField();\n\t\t\t//??????????????????????????????????´?\n\t\t\taryIns[deta] = insField;\n\n\t\t}\n\n\t\tSystem.out.print(\"intHeight:\" + aryIns[0].field.length);\n\t\tSystem.out.println(\" intWidth:\" + aryIns[0].field[0].length);\n\t\t\n\t\t//?????£??????????????????\n\t\tfor(int k = 0; k < aryIns.length; k++){\n\n\t\t\tField insField = aryIns[k];\n\t\t\tint intHeight = insField.field.length;\n\t\t\tint intWidth = insField.field[0].length;\n\t\t\t\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tSystem.out.print(insField.field[j][i]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif(k != aryIns.length-1){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\n\n\n\t}//Main??????????????????\n\n\n\t/**\n\t * ?????£??????????????????*/\n\tstatic class Field{\n\n\t\t/**?????£?????????\n\t\t * ????????£??????????????±?????????????????????*/\n\t\tprivate String[][] field;\n\t\t/**\n\t\t * ????????????????????????????????????*/\n\t\tprivate String[] commond;\n\t\t/**\n\t\t * ?????£??????????????§???????????????????????????*/\n\t\tprivate int[] aryArea;\n\t\tint intHeight;\n\t\tint intWidth;\n\n\n\t\t/**\n\t\t * ?????????????????????*/\n\t\tField(String[][] field, String[] commond ){\n\n\t\t\tthis.field = field;\n\t\t\tthis.commond = commond;\n\t\t\tthis.intHeight = field.length;\n\t\t\tthis.intWidth = field[0].length;\n\t\t}\n\n\n\n\t\t/**Method\n\t\t *????????£??????????????±???????????????????????????????????????????????´??????\n\t\t **/\n\t\tpublic void chageField(){\n\n\t\t\t//?????£????????????????????¨???????????£??\\\n\t\t\t//int intHeight = aryArea[0];\n\t\t\t//int intWidth = aryArea[1];\n\n\n\t\t\t//?????????????????°?????°?????????\n\t\t\tfor(int comNum = 0; comNum < commond.length; comNum++){\n\t\t\t\t//System.out.println(\"commond[\" + comNum + \"]\" + commond[comNum]);\n\n\t\t\t\t//??????????????±??¨???????????????\n\t\t\t\tint[] tank = getTank();\n\t\t\t\tint j = tank[0];\n\t\t\t\tint i = tank[1];\n\t\t\t\tint tankHead = tank[2]; //1=^ 2=> 3=v 4=<\n\t\t\t\t//System.out.println(\"tank:\" + j + i);\n\n\t\t\t\t//???????????????(????¨????)\n\t\t\t\tif(\"S\".equals(commond[comNum])){\n\n\t\t\t\t\t//??????????¬??????¨?????¢???????????????????????°\n\t\t\t\t\tString nextArea = \"\";\n\n\t\t\t\t\t//????????????????????????(?????????)\n\t\t\t\t\tif(tankHead == 1){// ^??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j-1; 0 <= k; k--){\n\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(tankHead == 2){// >??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i+1; k <= intWidth -1; k++){\n\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 3){// v??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = j+1; k <= intHeight -1; k++){\n\t\t\t\t\t\t\tnextArea = field[k][i];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[k][i] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else if(tankHead == 4){// <??????\n\n\t\t\t\t\t\t//?¬??????¨?????¢???????????¬?????¬??§???????????°?????¨?????¢????????????\n\t\t\t\t\t\tfor(int k = i-1; 0 <= k; k--){\n\t\t\t\t\t\t\tnextArea = field[j][k];\n\n\t\t\t\t\t\t\tif(\"#\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//????????´??????????????????????????¬??????\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(\"*\".equals(nextArea)){\n\t\t\t\t\t\t\t\t//??¬?????¬?????´???????????°?????????\n\t\t\t\t\t\t\t\tfield[j][k] = \".\";\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}//commond\"S\"end\n\n\n\t\t\t\t}else if(\"U\".equals(commond[comNum])){\n\n\n\t\t\t\t\t//nextArea = field[j-1][i];\n\t\t\t\t\tif(j == 0 || !\".\".equals(field[j-1][i])){\n\t\t\t\t\t\t//?????????????????????????????´????????????????¬??????¨?????¢????????°??§?????????????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"^\";\n\t\t\t\t\t}else if(\".\".equals(field[j-1][i])) {\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´?????????????????°?????´???\n\n\t\t\t\t\t\tfield[j-1][i] = \"^\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"U\"end\n\n\t\t\t\t}else if(\"R\".equals(commond[comNum])){\n\n\t\t\t\t\t//nextArea = field[j][i+1];\n\t\t\t\t\tif(i == intWidth - 1 || !\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \">\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i+1])){\n\t\t\t\t\t\t//?¬??????¨?????¢???????????´???????????°?????´???\n\t\t\t\t\t\tfield[j][i+1] = \">\";//??????????????????\n\t\t\t\t\t\tfield[j][i] = \".\";//????????¨?????¢????????°?????????\n\t\t\t\t\t}//commond\"R\"end\n\n\n\t\t\t\t}else if(\"D\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(j == intHeight - 1 || !\".\".equals(field[j+1][i])){\n\t\t\t\t\t\t//?????????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"v\";\n\t\t\t\t\t\t}else if(\".\".equals(field[j+1][i])){\n\n\t\t\t\t\t\t\tfield[j+1][i] = \"v\";\n\t\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"D\"end\n\n\n\t\t\t\t}else if(\"L\".equals(commond[comNum])){\n\n\n\t\t\t\t\tif(i == 0 || !\".\".equals(field[j][i-1])){\n\t\t\t\t\t\t//??????????????????????????´???????????????????????´\n\t\t\t\t\t\tfield[j][i] = \"<\";\n\t\t\t\t\t}else if(\".\".equals(field[j][i-1])){\n\n\t\t\t\t\t\tfield[j][i-1] = \"<\";\n\t\t\t\t\t\tfield[j][i] = \".\";\n\t\t\t\t\t}//commond\"L\"end\n\n\t\t\t\t}\n\n\n\t\t\t\t/*System.out.println(\"????????????\");\n\t\t\t\tfor(int jj = 0; jj < intHeight; jj++){\n\t\t\t\t\tfor(int ii = 0; ii < intWidth; ii++){\n\t\t\t\t\t\tSystem.out.print(field[jj][ii]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println();*/\n\t\t\t}\n\n\t\t}//changeField End\n\n\t\t/**\n\t\t * ????????????????????????????????????\n\t\t *\n\t\t * */\n\t\tpublic int[] getTank(){\n\n\t\t\t//????????????????????±??¨???????????????????????????\n\t\t\tint[] tank = new int[3];\n\t\t\t//?????£??????????????§??????\n\t\t\t//int intHeight = aryArea[0];\n\t\t\t//int intWidth = aryArea[1];\n\n\t\t\t//for?????§??????????????????????????????\n\t\t\tfor(int j = 0; j < intHeight; j++){\n\t\t\t\tfor(int i = 0; i < intWidth; i++){\n\n\t\t\t\t\tif(\"^\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 1;\n\t\t\t\t\t}else if(\">\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 2;\n\t\t\t\t\t}else if(\"v\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 3;\n\t\t\t\t\t}else if(\"<\".equals(field[j][i])){\n\t\t\t\t\t\ttank[0] = j;\n\t\t\t\t\t\ttank[1] = i;\n\t\t\t\t\t\ttank[2] = 4;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tank;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * <pre>\n * ??????????????????\n * </pre>\n *\n * @author ?????????????????§???\n * @version 1.8_45\n * @since 1.8_45\n */\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ?????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 1?????????????????????????????????????§????????????????????????°\n\t\tint data_set = Integer.parseInt(br.readLine());\n\t\t// ??\\?????????????????????????????????????????£?¨?\n\t\tString tmp_row;\n\n\t\twhile ((tmp_row = br.readLine()) != null && !tmp_row.isEmpty()) {\n\t\t\tString[] tmp_line = tmp_row.split(\" \");\n\t\t\t// ??????????????????\n\t\t\tint map_height = Integer.parseInt(tmp_line[0]);\n\t\t\t// ???????????????\n\t\t\tint map_width = Integer.parseInt(tmp_line[1]);\n\t\t\t// ????????¨???????????£?????????????????????\n\t\t\tString[][] game_Map = new String[map_height + 2][map_width + 2];\n\t\t\t// ?????????????????????????????±???????´???´???\n\t\t\tTank tank = null;\n\n\t\t\t// ??°????????????????£?????????????\n\t\t\tfor (int wall = 0; wall < map_height + 2; wall++) {\n\t\t\t\tArrays.fill(game_Map[wall], \"W\");\n\t\t\t}\n\n\t\t\t// ????????????????????°??¢?????\\????????????\n\t\t\tfor (int mh = 1; mh < map_height + 1; mh++) {\n\t\t\t\ttmp_row = br.readLine();\n\t\t\t\tfor (int mw = 0; mw < map_width; mw++) {\n\t\t\t\t\t// ??°??????????£?\n\t\t\t\t\tgame_Map[mh][mw + 1] = String.valueOf(tmp_row.charAt(mw));\n\n\t\t\t\t\t// ????????????????????±????????????????´?\n\t\t\t\t\t// ???????????????????????°????????????\n\t\t\t\t\tif (\"^v<>\".indexOf(game_Map[mh][mw + 1]) > -1) {\n\t\t\t\t\t\t// init tank.\n\t\t\t\t\t\ttank = new Tank(game_Map, game_Map[mh][mw + 1], new int[] { mh, mw + 1 });\n\t\t\t\t\t\tgame_Map[mh][mw + 1] = \".\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbr.readLine();\n\t\t\t// ?????????????????????\n\t\t\ttmp_row = br.readLine();\n\t\t\tfor (char cmd : tmp_row.toCharArray()) {\n\t\t\t\ttank.command(cmd);\n\t\t\t}\n\n\t\t\ttank.last_tankLocate();\n\t\t\tdata_set--;\n\n\t\t\t// ??°??¢?????????\n\t\t\t// ???????????????????????°????????????\n\t\t\tfor (int ch = 1; ch < map_height + 1; ch++) {\n\t\t\t\tfor (int cw = 1; cw < map_width + 1; cw++) {\n\t\t\t\t\tSystem.out.print(game_Map[ch][cw]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\n\t\t\tif (data_set > 0)\n\t\t\t\tSystem.out.println();\n\t\t} // while?????????????????????\n\t}// ?????????????????????????????????\n\n\tstatic class Tank {\n\n\t\t/**\n\t\t * ?????????\n\t\t */\n\t\tprivate String[][] map;\n\t\t/**\n\t\t * ??????????????¨??°\n\t\t */\n\t\tprivate int[] pos;\n\t\t/**\n\t\t * ??????\n\t\t */\n\t\tprivate String dir;\n\n\t\t/*\n\t\t * ????????????????????????\n\t\t */\n\t\tTank(String[][] game_Map, String tank_dir, int[] tank_pos) {\n\t\t\tmap = game_Map;\n\t\t\tpos = tank_pos;\n\t\t\tdir = tank_dir;\n\t\t}\n\n\t\t/*\n\t\t * ?§??????????\n\t\t */\n\t\tstatic HashMap<String, String> move_Cmd = new HashMap<String, String>() {\n\t\t\t{\n\t\t\t\tput(\"U\", \"^\");\n\t\t\t\tput(\"D\", \"v\");\n\t\t\t\tput(\"L\", \"<\");\n\t\t\t\tput(\"R\", \">\");\n\t\t\t}\n\t\t};\n\n\t\t/*\n\t\t * ?§??????¢???\n\t\t */\n\t\tstatic HashMap<String, int[]> move_Dir = new HashMap<String, int[]>() {\n\t\t\t{\n\t\t\t\tput(\"^\", new int[] { -1, 0 });\n\t\t\t\tput(\"v\", new int[] { 1, 0 });\n\t\t\t\tput(\"<\", new int[] { 0, -1 });\n\t\t\t\tput(\">\", new int[] { 0, 1 });\n\t\t\t}\n\t\t};\n\n\t\t// ???????????????????????°????????????\n\t\tvoid command(char cmd) {\n\n\t\t\tif (cmd != 'S') {\n\t\t\t\tmove_tank(String.valueOf(cmd));\n\t\t\t} else {\n\t\t\t\tcannon_Shoot();\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * <pre>\n\t\t * ?????????????????????\n\t\t * ????????¬?????¬????£??????¶????????£???????????°?????????\n\t\t * ?????????????£??????°?????????\n\t\t * ????????°??????????????¨??§?????£????????????????¶????\n\t\t * </pre>\n\t\t *\n\t\t * @param shell\n\t\t *            ??????\n\t\t */\n\t\tprivate void cannon_Shoot() {\n\t\t\tint[] shell = new int[] { this.pos[0], this.pos[1] };\n\t\t\twhile (true) {\n\t\t\t\tshell[0] += move_Dir.get(this.dir)[0];\n\t\t\t\tshell[1] += move_Dir.get(this.dir)[1];\n\t\t\t\tswitch (map[shell[0]][shell[1]]) {\n\t\t\t\tcase \".\":\n\t\t\t\tcase \"-\":\n\t\t\t\t\tcontinue;\n\t\t\t\tcase \"*\":\n\t\t\t\t\tmap[shell[0]][shell[1]] = \".\";\n\t\t\t\tcase \"#\":\n\t\t\t\tcase \"W\":\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}// cannon_Shoot????????????????????????\n\n\t\t/**\n\t\t * <pre>\n\t\t *?????????????§????\n\t\t *\n\t\t *???????????°???????§??????????\n\t\t *???????????¬??????????????????????????£????§???????????????¨?????????\n\t\t * </pre>\n\t\t *\n\t\t * @param cmd\n\t\t *            ?????¬??????????????????\n\t\t * @param move\n\t\t *            ??????????§????\n\t\t */\n\t\tprivate void move_tank(String cmd) {\n\n\t\t\tthis.dir = move_Cmd.get(cmd);\n\t\t\tint[] move = new int[] { this.pos[0], this.pos[1] };\n\t\t\tmove[0] += move_Dir.get(this.dir)[0];\n\t\t\tmove[1] += move_Dir.get(this.dir)[1];\n\t\t\tif (map[move[0]][move[1]] == \".\") {\n\t\t\t\tthis.pos[0] = move[0];\n\t\t\t\tthis.pos[1] = move[1];\n\t\t\t}\n\t\t}// move_tank????????????????????????\n\n\t\tprivate void last_tankLocate() {\n\t\t\t// ?????????????????¨??°?????°????????¨?¨???????\n\t\t\tmap[this.pos[0]][this.pos[1]] = this.dir;\n\t\t}\n\n\t}// Tank?????????????????????\n}// ???????????????????????????????????????"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint input_length = 0;\n\t\t// マップの高さ\n\t\tint height = 0;\n\t\t// マップの幅\n\t\tint width = 0;\n\t\t// 各完成マップを入れる配列\n\t\tArrayList<map> map_list = new ArrayList<map>();\n\t\t// 入力の回数\n\t\twhile (sc.hasNext()) {\n\t\t\tinput_length = sc.nextInt();\n\t\t\tbreak;\n\t\t}\n\n\t\t// 入力回数分ゲームをする\n\t\tfor (int i = 0; i < input_length; i++) {\n\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\t// マップの高さ\n\t\t\t\theight = sc.nextInt();\n\t\t\t\t// マップの幅\n\t\t\t\twidth = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// マップのインスタンスを作る\n\t\t\tmap map = new map();\n\t\t\t// 戦車のインスタンスを作る\n\t\t\ttank tank = new tank();\n\t\t\tmap.setMap(height, width);\n\n\t\t\tString line = null;\n\t\t\t// マップ作成\n\t\t\tfor (int h = 0; h < height; h++) {\n\t\t\t\t// マップ一列\n\t\t\t\twhile (sc.hasNext()) {\n\t\t\t\t\tline = sc.next();\n\t\t\t\t}\n\t\t\t\t// 一文字ずつに分解\n\t\t\t\tchar[] line_char = line.toCharArray();\n\t\t\t\t//\n\t\t\t\tfor (int w = 0; w < width; w++) {\n\t\t\t\t\t// マップを作る\n\t\t\t\t\tmap.createMap(h, w, String.valueOf(line_char[w]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint command_number = 0;\n\t\t\tString command_attack = \"\";\n\t\t\t// コマンド入力回数\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_number = sc.nextInt();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// コマンドの文字列\n\t\t\tchar[] command_at = null;\n\t\t\twhile (sc.hasNext()) {\n\t\t\t\tcommand_attack = sc.next();\n\t\t\t\t// ひとつずつ配列に入れる\n\t\t\t\tcommand_at = command_attack.toCharArray();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// コマンド回数分まわす\n\t\t\tfor (int c = 0; c < command_number; c++) {\n\t\t\t\t// タンクの現在位置を把握\n\t\t\t\ttank.searchTank(map.getMap());\n\t\t\t\t// 砲弾発射だったら\n\t\t\t\tif (String.valueOf(command_at[c]).equals(\"S\")) {\n\t\t\t\t\t// マップを砲弾発射用に変更\n\t\t\t\t\tmap.shuttGun(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\ttank.getSituation());\n\t\t\t\t} else {\n\t\t\t\t\t// 移動の場合\n\t\t\t\t\tmap.move_tank(tank.getNow_height(), tank.getNow_width(),\n\t\t\t\t\t\t\tString.valueOf(command_at[c]));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// リストにできたマップを格納\n\t\t\tmap_list.add(map);\n\t\t}\n\t\t// 結果を出力\n\t\tfor (map obj : map_list) {\n\t\t\tobj.out_map();\n\t\t\t// 改行\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n}\n\nclass tank {\n\n\t// 戦車の位置\n\t// 現在の高さ\n\tprivate int now_height = 0;\n\t// 現在の幅\n\tprivate int now_width = 0;\n\n\t// 戦車をあらわす記号\n\tpublic static final String[] tank_element = { \"<\", \">\", \"^\", \"v\" };\n\n\t// 戦車の向き\n\tprivate String situation = null;\n\n\t// 現在位置と向きを探す 全体のマップの高さ\n\tpublic void searchTank(String[][] map_all) {\n\t\tfor (int h = 0; h < map_all.length; h++) {\n\t\t\tfor (int w = 0; w < map_all[0].length; w++) {\n\n\t\t\t\t// 戦車がどこかにいるはず\n\t\t\t\tfor (String val : tank_element) {\n\t\t\t\t\tif (map_all[h][w].equals(val)) {\n\t\t\t\t\t\t// 戦車の位置情報と向きを入力\n\t\t\t\t\t\tnow_height = h;\n\t\t\t\t\t\tnow_width = w;\n\t\t\t\t\t\tsituation = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void setSituation(String s) {\n\t\tsituation = s;\n\t}\n\n\t// ゲッター\n\n\tpublic String getSituation() {\n\t\treturn situation;\n\t}\n\n\tpublic int getNow_height() {\n\t\treturn now_height;\n\t}\n\n\tpublic int getNow_width() {\n\t\treturn now_width;\n\t}\n\n}\n\nclass map {\n\n\t// 現在のマップ\n\tprivate String[][] map = null;\n\n\t// セッター\n\tpublic void setMap(int h, int w) {\n\t\tmap = new String[h][w];\n\t}\n\n\t// マップを作る\n\tpublic void createMap(int height_i, int width_i, String m) {\n\t\tmap[height_i][width_i] = m;\n\t}\n\n\t// // 砲弾によるマップ変更 現在位置 向き\n\tpublic void shuttGun(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"<\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t} else\n\n\t\t\t\t//\n\t\t\t\tfor (int i = 0; i <= now_w; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w - i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w - i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\">\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= (map[0].length - now_w); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h][now_w + i] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h][now_w + i].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"^\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t} else\n\n\t\t\t\tfor (int i = 0; i <= now_h; i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h - i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h - i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"v\")) {\n\t\t\t// マップの先が何もない場合は、なにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t} else\n\t\t\t\tfor (int i = 0; i <= (map.length - now_h); i++) {\n\t\t\t\t\t// レンガ壁だったら平地に\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"*\")) {\n\t\t\t\t\t\tmap[now_h + i][now_w] = \".\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 鉄壁だったら変更なし\n\t\t\t\t\tif (map[now_h + i][now_w].equals(\"#\")) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t}\n\n\t// 戦車の移動によるマップ変更,向き変更 現在位置 方向\n\tpublic void move_tank(int now_h, int now_w, String s) {\n\t\t// 左向き\n\t\tif (s.equals(\"L\")) {\n\t\t\t// 左のマスが平地だったら左に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == 0) {\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w - 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w - 1] = \"<\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"<\";\n\t\t\t}\n\n\t\t}\n\t\t// 右向き\n\t\tif (s.equals(\"R\")) {\n\t\t\t// 右のマスが平地だったら右に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_w == (map[0].length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h][now_w + 1].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h][now_w + 1] = \">\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \">\";\n\t\t\t}\n\t\t}\n\t\t// 下向き\n\t\tif (s.equals(\"D\")) {\n\t\t\t// 下のマスが平地だったら下に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == (map.length - 1)) {\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t} else if (map[now_h + 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h + 1][now_w] = \"v\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"v\";\n\t\t\t}\n\t\t}\n\t\t// 上向き\n\t\tif (s.equals(\"U\")) {\n\t\t\t// 上のマスが平地だったら上に進む\n\t\t\t// マップの先がなにもないときはなにもしない\n\t\t\tif (now_h == 0) {\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t\t// 平地マスへ移動\n\t\t\telse if (map[now_h - 1][now_w].equals(\".\")) {\n\t\t\t\t// 戦車を進める\n\t\t\t\tmap[now_h - 1][now_w] = \"^\";\n\t\t\t\t// 元いた位置は平地\n\t\t\t\tmap[now_h][now_w] = \".\";\n\t\t\t} else {\n\t\t\t\t// 平地マス以外は向き変え\n\t\t\t\tmap[now_h][now_w] = \"^\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// マップを出力\n\tpublic void out_map() {\n\t\tfor (int h = 0; h < map.length; h++) {\n\t\t\tfor (int w = 0; w < map[0].length; w++) {\n\t\t\t\tSystem.out.print(map[h][w]);\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n\n\t// ゲッター\n\tpublic String[][] getMap() {\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var p = 0;\n        var t = int.Parse(Console.ReadLine().Trim());\n        while (p < t)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var h = int.Parse(line[0]);\n            var w = int.Parse(line[1]);\n            var map = new char[h, w];\n            var now = new P();\n            var pre = 0;\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    var a = s[j];\n                    if (a == '>') { map[i, j] = '.'; now.x = i; now.y = j; pre = 0; }\n                    else if (a == 'v') { map[i, j] = '.'; now.x = i; now.y = j; pre = 1; }\n                    else if (a == '<') { map[i, j] = '.'; now.x = i; now.y = j; pre = 2; }\n                    else if (a == '^') { map[i, j] = '.'; now.x = i; now.y = j; pre = 3; }\n                    else map[i, j] = a;\n                }\n            }\n            var n = int.Parse(Console.ReadLine().Trim());\n            var s2 = Console.ReadLine().Trim();\n            for (int i = 0; i < n; i++)\n            {\n                if (s2[i] == 'U')\n                {\n                    pre = 3;\n                    if (now.x - 1 >= 0)\n                    {\n                        var a = map[now.x - 1, now.y];\n                        if (a == '.') now.x -= 1;\n                    }\n                }\n                else if (s2[i] == 'R')\n                {\n                    pre = 0;\n                    if (now.y + 1 < w)\n                    {\n                        var a = map[now.x, now.y + 1];\n                        if (a == '.') now.y += 1;\n                    }\n                }\n                else if (s2[i] == 'L')\n                {\n                    pre = 2;\n                    if (now.y - 1 >= 0)\n                    {\n                        var a = map[now.x, now.y - 1];\n                        if (a == '.') now.y -= 1;\n                    }\n                }\n                else if (s2[i] == 'D')\n                {\n                    pre = 1;\n                    if (now.x + 1 < h)\n                    {\n                        var a = map[now.x + 1, now.y];\n                        if (a == '.') now.x += 1;\n                    }\n                }\n                else shot(map, pre, h, w, now);\n            }\n            print(map, now, pre);\n            if (p != t - 1) Console.WriteLine();\n            p++;\n        }\n    }\n\n    public static void print(char[,] map, P now, int pre)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        for (int i = 0; i < h; i++)\n        {\n            for (int j = 0; j < w; j++)\n            {\n                if (now.x == i && now.y == j)\n                {\n                    if (pre == 0) Console.Write('>');\n                    else if (pre == 1) Console.Write('v');\n                    else if (pre == 2) Console.Write('<');\n                    else Console.Write('^');\n                }\n                else  Console.Write(map[i,j]);\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void shot(char[,] map, int pre, int h, int w, P now)\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dy = new int[] { 1, 0, -1, 0 };\n        var nx = now.x;\n        var ny = now.y;\n        while (true)\n        {\n            nx += dx[pre];\n            ny += dy[pre];\n            if (nx < 0 | nx >= h | ny < 0 | ny >= w) return;\n            if (map[nx, ny] == '*') { map[nx, ny] = '.'; return; }\n            else if (map[nx, ny] == '#') return;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace number_of_island\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var map_temp = new List<string>();\n            var map_arry = new List<See_map>();\n            string read;\n            while (true)\n            {\n                map_temp.Clear();\n                for (var i = 0; i < 12; i++)\n                {\n                    read =Console.ReadLine();\n\n                    if (string.IsNullOrWhiteSpace(read)) map_arry.Add(new See_map(map_temp));\n                    else map_temp.Add(read);\n                    \n                }\n                read = Console.ReadLine();\n\n                if (read==null) break;\n\n            }\n            foreach(See_map map in map_arry)\n            {\n                Console.WriteLine(map.count_island());\n            }\n        }\n    }\n\n    class See_map\n    {\n        int[,] map_arry = new int[12, 12];\n        int count_temp=0,count=0;\n        public See_map(List<string> map_temp)\n        {\n            count_temp = 0;\n            foreach(string s in map_temp)\n            {\n                for(var i=0;i<12;i++)\n                {\n                    map_arry[count_temp,i]=int.Parse(s.Substring(i,1));\n                }\n                count_temp++;\n            }\n        }\n\n        public void draw_map()\n        {\n            for (var i = 0; i < 12; i++)\n            {\n                for (var j = 0; j < 12; j++)\n                {\n                    Console.Write(map_arry[i,j] == 1 ? \"???\":\"???\");\n                }\n                Console.WriteLine();\n            }\n        }\n\n        public int count_island()\n        {\n            for(var i=0;i<12;i++)\n            {\n                for(var j=0;j<12;j++)\n                {\n                    if (map_arry[i, j] == 1)\n                    {   \n                        delet_island(i, j);\n                        count++;\n                    }\n                }\n            }\n            return count;\n        }\n\n        void delet_island(int x,int y)\n        {\n            map_arry[x, y] = 0;\n            \n            if(x<11)\n                if (map_arry[x + 1, y] == 1) delet_island(x + 1, y);\n            \n            if(x>0)\n                if (map_arry[x - 1, y] == 1) delet_island(x - 1, y);\n            \n            if(y>0)\n                if (map_arry[x, y - 1] == 1) delet_island(x, y - 1);\n\n            if(y<11)\n                if (map_arry[x, y + 1] == 1) delet_island(x, y + 1);\n        }\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    /// <summary>\n    /// プログラムエントリポイント\n    /// </summary>\n    public static void Main()\n    {\n        //問題数入力\n        int countQ = int.Parse(Console.ReadLine());\n\n        //問題数分繰り返す\n        for (int i = 0; i < countQ; i++)\n        {\n            //戦車を動かすフィールドの２次元配列の大きさ入力\n            string[] inputData = Console.ReadLine().Split(' ');\n            \n            //入力されたフィールドの大きさの値をもとに char[][] の配列生成\n            char[ , ] aryChBattleArea = new char[ int.Parse(inputData[0]) , int.Parse(inputData[1]) ];\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n\n                char[] tmp = Console.ReadLine().ToCharArray();\n\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    aryChBattleArea[x, y] = tmp[y];\n                }\n\n            }\n\n            int countOperation = int.Parse(Console.ReadLine());\n\n            char[] aryChOperation = new char[countOperation];\n\n            aryChOperation = Console.ReadLine().ToCharArray();\n\n            BattleTown insBT = new BattleTown(aryChBattleArea, aryChOperation);\n\n            char[,] aryChAnswer = insBT.runOperation();\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    Console.Write(aryChAnswer[x, y]);\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n}\n\n/// <summary>\n/// BattleTownクラス\n/// </summary>\nclass BattleTown\n{\n\n    private char[,] aryChBattleArea;\n    private char[] aryChOperation;\n\n    /// <summary>\n    /// コンストラクタ\n    /// </summary>\n    /// <param name=\"aryChBattleArea\">文字２重配列</param>\n    /// <param name=\"aryChOperation\">文字配列</param>\n    public BattleTown(char[,] aryChBattleArea, char[] aryChOperation)\n    {\n        this.aryChBattleArea = aryChBattleArea;\n        this.aryChOperation = aryChOperation;\n    }\n\n    /// <summary>\n    /// 命令を実行する\n    /// </summary>\n    /// <returns></returns>\n    public char[,] runOperation()\n    {\n\n        foreach (char c in aryChOperation)\n        {\n            for (int pointX = 0; pointX < aryChBattleArea.GetLength(0); pointX++)\n            {\n                for (int pointY = 0; pointY < aryChBattleArea.GetLength(1); pointY++)\n                {\n                    if (aryChBattleArea[pointX, pointY] == '^' || aryChBattleArea[pointX, pointY] == 'v'\n                            || aryChBattleArea[pointX, pointY] == '<' || aryChBattleArea[pointX, pointY] == '>')\n                    {\n                        this.actionTank(pointX, pointY, c);\n                        pointX++;\n                        break;\n                    }\n\n                }\n\n            }\n        }\n\n        return this.aryChBattleArea;\n\n    }\n\n    /// <summary>\n    /// 戦車を命令に従って動かす\n    /// </summary>\n    /// <param name=\"pointX\">戦車の位置X</param>\n    /// <param name=\"pointY\">戦車の位置Y</param>\n    /// <param name=\"operation\">命令(文字)</param>\n    private void actionTank(int pointX, int pointY, char operation)\n    {\n        //命令、向き、動きがリンクしている。\n        char[] control = { 'U', 'D', 'R', 'L' };\n        char[] direction = { '^', 'v', '>', '<' };\n        int[,] move = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n        //移動用\n        if (operation != 'S')\n        {\n            //control[]の長さ分繰り返す\n            for (int i = 0; i < control.Length; i++ )\n            {\n                //命令が一致したら\n                if (operation == control[i])\n                {\n                    //戦車の向きをかえる\n                    aryChBattleArea[pointX, pointY] = direction[i];\n\n                    //戦車がX方向,Y方向に動いた先がaryChBattleArea[,]の範囲内だったら\n\n                    //if (pointX - 1 >= 0 && pointX + 1 < aryChBattleArea.Length\n                    //        && pointY - 1 >= 0 && pointY + 1 < aryChBattleArea.Length)\n\n                    if( pointX+move[i,0]>=0 && pointX+move[i,0]<aryChBattleArea.GetLength(0)\n                            && pointY+move[i,1]>=0 && pointY+move[i,1]<aryChBattleArea.GetLength(1) )\n                    {\n                        //戦車の移動先が '.'(平原) だったら\n                        if (aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] == '.')\n                        {\n                            //戦車がいた位置を'.'に変更\n                            aryChBattleArea[pointX, pointY] = '.';\n\n                            //戦車の移動先を向きにあわせて変更\n                            aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] = direction[i];\n\n                        }\n                    }\n                }\n            }\n\n        }\n\n        //射撃用\n        else\n        {\n            int pointXS = pointX;\n            int pointXY = pointY;\n\n            for (int i = 0; i < direction.Length; i++)\n            {\n\n                if (aryChBattleArea[pointXS,pointXY] == direction[i])\n                {\n\n                    while (0 <= pointXS && pointXS < aryChBattleArea.GetLength(0) &&\n                                0 <= pointXY && pointXY < aryChBattleArea.GetLength(1))\n                    {\n\n                        if (aryChBattleArea[pointXS, pointXY] == '*')\n                        {\n\n                            aryChBattleArea[pointXS, pointXY] = '.';\n                            break;\n\n                        }\n                        else if (aryChBattleArea[pointXS, pointXY] == '#')\n                        {\n\n                            break;\n                        }\n\n                        pointXS += move[i, 0];\n                        pointXY += move[i, 1];\n                    }\n\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    /// <summary>\n    /// プログラムエントリポイント\n    /// </summary>\n    public static void Main()\n    {\n        //問題数入力\n        int countQ = int.Parse(Console.ReadLine());\n\n        //問題数分繰り返す\n        for (int i = 0; i < countQ; i++)\n        {\n            //戦車を動かすフィールドの２次元配列の大きさ入力\n            string[] inputData = Console.ReadLine().Split(' ');\n\n            //入力されたフィールドの大きさの値をもとに char[][] の配列生成\n            char[,] aryChBattleArea = new char[int.Parse(inputData[0]), int.Parse(inputData[1])];\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n\n                char[] tmp = Console.ReadLine().ToCharArray();\n\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    aryChBattleArea[x, y] = tmp[y];\n                }\n\n            }\n\n            int countOperation = int.Parse(Console.ReadLine());\n\n            char[] aryChOperation = new char[countOperation];\n\n            aryChOperation = Console.ReadLine().ToCharArray();\n\n            BattleTown insBT = new BattleTown(aryChBattleArea, aryChOperation);\n\n            char[,] aryChAnswer = insBT.runOperation();\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    Console.Write(aryChAnswer[x, y]);\n                }\n                Console.WriteLine();\n            }\n            if (i != countQ - 1)\n            {\n                Console.WriteLine();\n            }\n\n        }\n    }\n}\n\n/// <summary>\n/// BattleTownクラス\n/// </summary>\nclass BattleTown\n{\n\n    private char[,] aryChBattleArea;\n    private char[] aryChOperation;\n\n    /// <summary>\n    /// コンストラクタ\n    /// </summary>\n    /// <param name=\"aryChBattleArea\">文字２重配列</param>\n    /// <param name=\"aryChOperation\">文字配列</param>\n    public BattleTown(char[,] aryChBattleArea, char[] aryChOperation)\n    {\n        this.aryChBattleArea = aryChBattleArea;\n        this.aryChOperation = aryChOperation;\n    }\n\n    /// <summary>\n    /// 命令を実行する\n    /// </summary>\n    /// <returns></returns>\n    public char[,] runOperation()\n    {\n\n        foreach (char c in aryChOperation)\n        {\n            for (int pointX = 0; pointX < aryChBattleArea.GetLength(0); pointX++)\n            {\n                for (int pointY = 0; pointY < aryChBattleArea.GetLength(1); pointY++)\n                {\n                    if (aryChBattleArea[pointX, pointY] == '^' || aryChBattleArea[pointX, pointY] == 'v'\n                            || aryChBattleArea[pointX, pointY] == '<' || aryChBattleArea[pointX, pointY] == '>')\n                    {\n                        this.actionTank(pointX, pointY, c);\n                        pointX++;\n                        break;\n                    }\n\n                }\n\n            }\n        }\n\n        return this.aryChBattleArea;\n\n    }\n\n    /// <summary>\n    /// 戦車を命令に従って動かす\n    /// </summary>\n    /// <param name=\"pointX\">戦車の位置X</param>\n    /// <param name=\"pointY\">戦車の位置Y</param>\n    /// <param name=\"operation\">命令(文字)</param>\n    private void actionTank(int pointX, int pointY, char operation)\n    {\n        //命令、向き、動きがリンクしている。\n        char[] control = { 'U', 'D', 'R', 'L' };\n        char[] direction = { '^', 'v', '>', '<' };\n        int[,] move = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n        //移動用\n        if (operation != 'S')\n        {\n            //control[]の長さ分繰り返す\n            for (int i = 0; i < control.Length; i++)\n            {\n                //命令が一致したら\n                if (operation == control[i])\n                {\n                    //戦車の向きをかえる\n                    aryChBattleArea[pointX, pointY] = direction[i];\n\n                    //戦車がX方向,Y方向に動いた先がaryChBattleArea[,]の範囲内だったら\n\n                    //if (pointX - 1 >= 0 && pointX + 1 < aryChBattleArea.Length\n                    //        && pointY - 1 >= 0 && pointY + 1 < aryChBattleArea.Length)\n\n                    if (pointX + move[i, 0] >= 0 && pointX + move[i, 0] < aryChBattleArea.GetLength(0)\n                            && pointY + move[i, 1] >= 0 && pointY + move[i, 1] < aryChBattleArea.GetLength(1))\n                    {\n                        //戦車の移動先が '.'(平原) だったら\n                        if (aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] == '.')\n                        {\n                            //戦車がいた位置を'.'に変更\n                            aryChBattleArea[pointX, pointY] = '.';\n\n                            //戦車の移動先を向きにあわせて変更\n                            aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] = direction[i];\n\n                        }\n                    }\n                }\n            }\n\n        }\n\n        //射撃用\n        else\n        {\n            int pointXS = pointX;\n            int pointXY = pointY;\n\n            for (int i = 0; i < direction.Length; i++)\n            {\n\n                if (aryChBattleArea[pointXS, pointXY] == direction[i])\n                {\n\n                    while (0 <= pointXS && pointXS < aryChBattleArea.GetLength(0) &&\n                                0 <= pointXY && pointXY < aryChBattleArea.GetLength(1))\n                    {\n\n                        if (aryChBattleArea[pointXS, pointXY] == '*')\n                        {\n\n                            aryChBattleArea[pointXS, pointXY] = '.';\n                            break;\n\n                        }\n                        else if (aryChBattleArea[pointXS, pointXY] == '#')\n                        {\n\n                            break;\n                        }\n\n                        pointXS += move[i, 0];\n                        pointXY += move[i, 1];\n                    }\n\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    /// <summary>\n    /// プログラムエントリポイント\n    /// </summary>\n    public static void Main()\n    {\n\n        List<char[,]> listBattleArea = new List<char[,]>();\n\n        //問題数入力\n        int countQ = int.Parse(Console.ReadLine());\n\n        //問題数分繰り返す\n        for (int i = 0; i < countQ; i++)\n        {\n            //戦車を動かすフィールドの２次元配列の大きさ入力\n            string[] inputData = Console.ReadLine().Split(' ');\n            \n            //入力されたフィールドの大きさの値をもとに char[][] の配列生成\n            char[ , ] aryChBattleArea = new char[ int.Parse(inputData[0]) , int.Parse(inputData[1]) ];\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n\n                char[] tmp = Console.ReadLine().ToCharArray();\n\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    aryChBattleArea[x, y] = tmp[y];\n                }\n\n            }\n\n            int countOperation = int.Parse(Console.ReadLine());\n\n            char[] aryChOperation = new char[countOperation];\n\n            aryChOperation = Console.ReadLine().ToCharArray();\n\n            BattleTown insBT = new BattleTown(aryChBattleArea, aryChOperation);\n\n            listBattleArea.Add(insBT.runOperation());\n\n        }\n\n        for( int i = 0 ; i < listBattleArea.Count ; i++ ){\n        \t\n        \tchar[,] output = listBattleArea[i];\n        \t\n        \tfor( int j = 0 ; j < output.GetLength(0) ; j++ ){\n        \t\tfor( int k = 0 ; k < output.GetLength(1) ; k++ ){\n        \t\t\t\n        \t\t\tConsole.Write(output[j, k]);\n        \t\t\t\n        \t\t}\n        \t\t\n        \t\tConsole.WriteLine();\n        \t}\n        \t\n        \tif( i != listBattleArea.Count-1)\n                Console.WriteLine();\n        }\n\n    }\n}\n\n/// <summary>\n/// BattleTownクラス\n/// </summary>\nclass BattleTown\n{\n\n    private char[,] aryChBattleArea;\n    private char[] aryChOperation;\n\n    /// <summary>\n    /// コンストラクタ\n    /// </summary>\n    /// <param name=\"aryChBattleArea\">文字２重配列</param>\n    /// <param name=\"aryChOperation\">文字配列</param>\n    public BattleTown(char[,] aryChBattleArea, char[] aryChOperation)\n    {\n        this.aryChBattleArea = aryChBattleArea;\n        this.aryChOperation = aryChOperation;\n    }\n\n    /// <summary>\n    /// 命令を実行する\n    /// </summary>\n    /// <returns></returns>\n    public char[,] runOperation()\n    {\n\n        foreach (char c in aryChOperation)\n        {\n            for (int pointX = 0; pointX < aryChBattleArea.GetLength(0); pointX++)\n            {\n                for (int pointY = 0; pointY < aryChBattleArea.GetLength(1); pointY++)\n                {\n                    if (aryChBattleArea[pointX, pointY] == '^' || aryChBattleArea[pointX, pointY] == 'v'\n                            || aryChBattleArea[pointX, pointY] == '<' || aryChBattleArea[pointX, pointY] == '>')\n                    {\n                        this.actionTank(pointX, pointY, c);\n                        pointX++;\n                        break;\n                    }\n\n                }\n\n            }\n        }\n\n        return this.aryChBattleArea;\n\n    }\n\n    /// <summary>\n    /// 戦車を命令に従って動かす\n    /// </summary>\n    /// <param name=\"pointX\">戦車の位置X</param>\n    /// <param name=\"pointY\">戦車の位置Y</param>\n    /// <param name=\"operation\">命令(文字)</param>\n    private void actionTank(int pointX, int pointY, char operation)\n    {\n        //命令、向き、動きがリンクしている。\n        char[] control = { 'U', 'D', 'R', 'L' };\n        char[] direction = { '^', 'v', '>', '<' };\n        int[,] move = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n        //移動用\n        if (operation != 'S')\n        {\n            //control[]の長さ分繰り返す\n            for (int i = 0; i < control.Length; i++ )\n            {\n                //命令が一致したら\n                if (operation == control[i])\n                {\n                    //戦車の向きをかえる\n                    aryChBattleArea[pointX, pointY] = direction[i];\n\n                    //戦車がX方向,Y方向に動いた先がaryChBattleArea[,]の範囲内だったら\n\n                    //if (pointX - 1 >= 0 && pointX + 1 < aryChBattleArea.Length\n                    //        && pointY - 1 >= 0 && pointY + 1 < aryChBattleArea.Length)\n\n                    if( pointX+move[i,0]>=0 && pointX+move[i,0]<aryChBattleArea.GetLength(0)\n                            && pointY+move[i,1]>=0 && pointY+move[i,1]<aryChBattleArea.GetLength(1) )\n                    {\n                        //戦車の移動先が '.'(平原) だったら\n                        if (aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] == '.')\n                        {\n                            //戦車がいた位置を'.'に変更\n                            aryChBattleArea[pointX, pointY] = '.';\n\n                            //戦車の移動先を向きにあわせて変更\n                            aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] = direction[i];\n\n                        }\n                    }\n                }\n            }\n\n        }\n\n        //射撃用\n        else\n        {\n            int pointXS = pointX;\n            int pointXY = pointY;\n\n            for (int i = 0; i < direction.Length; i++)\n            {\n\n                if (aryChBattleArea[pointXS,pointXY] == direction[i])\n                {\n\n                    while (0 <= pointXS && pointXS < aryChBattleArea.GetLength(0) &&\n                                0 <= pointXY && pointXY < aryChBattleArea.GetLength(1))\n                    {\n\n                        if (aryChBattleArea[pointXS, pointXY] == '*')\n                        {\n\n                            aryChBattleArea[pointXS, pointXY] = '.';\n                            break;\n\n                        }\n                        else if (aryChBattleArea[pointXS, pointXY] == '#')\n                        {\n\n                            break;\n                        }\n\n                        pointXS += move[i, 0];\n                        pointXY += move[i, 1];\n                    }\n\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    /// <summary>\n    /// プログラムエントリポイント\n    /// </summary>\n    public static void Main()\n    {\n        //問題数入力\n        int countQ = int.Parse(Console.ReadLine());\n\n        //問題数分繰り返す\n        for (int i = 0; i < countQ; i++)\n        {\n            //戦車を動かすフィールドの２次元配列の大きさ入力\n            string[] inputData = Console.ReadLine().Split(' ');\n            \n            //入力されたフィールドの大きさの値をもとに char[][] の配列生成\n            char[ , ] aryChBattleArea = new char[ int.Parse(inputData[0]) , int.Parse(inputData[1]) ];\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n\n                char[] tmp = Console.ReadLine().ToCharArray();\n\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    aryChBattleArea[x, y] = tmp[y];\n                }\n\n            }\n\n            int countOperation = int.Parse(Console.ReadLine());\n\n            char[] aryChOperation = new char[countOperation];\n\n            aryChOperation = Console.ReadLine().ToCharArray();\n\n            BattleTown insBT = new BattleTown(aryChBattleArea, aryChOperation);\n\n            char[,] aryChAnswer = insBT.runOperation();\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    Console.Write(aryChAnswer[x, y]);\n                }\n                Console.WriteLine();\n            }\n\n        }\n    }\n}\n\n/// <summary>\n/// BattleTownクラス\n/// </summary>\nclass BattleTown\n{\n\n    private char[,] aryChBattleArea;\n    private char[] aryChOperation;\n\n    /// <summary>\n    /// コンストラクタ\n    /// </summary>\n    /// <param name=\"aryChBattleArea\">文字２重配列</param>\n    /// <param name=\"aryChOperation\">文字配列</param>\n    public BattleTown(char[,] aryChBattleArea, char[] aryChOperation)\n    {\n        this.aryChBattleArea = aryChBattleArea;\n        this.aryChOperation = aryChOperation;\n    }\n\n    /// <summary>\n    /// 命令を実行する\n    /// </summary>\n    /// <returns></returns>\n    public char[,] runOperation()\n    {\n\n        foreach (char c in aryChOperation)\n        {\n            for (int pointX = 0; pointX < aryChBattleArea.GetLength(0); pointX++)\n            {\n                for (int pointY = 0; pointY < aryChBattleArea.GetLength(1); pointY++)\n                {\n                    if (aryChBattleArea[pointX, pointY] == '^' || aryChBattleArea[pointX, pointY] == 'v'\n                            || aryChBattleArea[pointX, pointY] == '<' || aryChBattleArea[pointX, pointY] == '>')\n                    {\n                        this.actionTank(pointX, pointY, c);\n                        break;\n                    }\n\n                }\n\n            }\n        }\n\n        return this.aryChBattleArea;\n\n    }\n\n    /// <summary>\n    /// 戦車を命令に従って動かす\n    /// </summary>\n    /// <param name=\"pointX\">戦車の位置X</param>\n    /// <param name=\"pointY\">戦車の位置Y</param>\n    /// <param name=\"operation\">命令(文字)</param>\n    private void actionTank(int pointX, int pointY, char operation)\n    {\n        //命令、向き、動きがリンクしている。\n        char[] control = { 'U', 'D', 'R', 'L' };\n        char[] direction = { '^', 'v', '>', '<' };\n        int[,] move = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n        //移動用\n        if (operation != 'S')\n        {\n            //control[]の長さ分繰り返す\n            for (int i = 0; i < control.Length; i++ )\n            {\n                //命令が一致したら\n                if (operation == control[i])\n                {\n                    //戦車の向きをかえる\n                    aryChBattleArea[pointX, pointY] = direction[i];\n\n                    //戦車がX方向,Y方向に動いた先がaryChBattleArea[,]の範囲内だったら\n\n                    //if (pointX - 1 >= 0 && pointX + 1 < aryChBattleArea.Length\n                    //        && pointY - 1 >= 0 && pointY + 1 < aryChBattleArea.Length)\n\n                    if( pointX+move[i,0]>=0 && pointX+move[i,0]<aryChBattleArea.GetLength(0)\n                            && pointY+move[i,1]>=0 && pointY+move[i,1]<aryChBattleArea.GetLength(1) )\n                    {\n                        //戦車の移動先が '.'(平原) だったら\n                        if (aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] == '.')\n                        {\n                            //戦車がいた位置を'.'に変更\n                            aryChBattleArea[pointX, pointY] = '.';\n\n                            //戦車の移動先を向きにあわせて変更\n                            aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] = direction[i];\n\n                        }\n                    }\n                }\n            }\n\n        }\n\n        //射撃用\n        else\n        {\n            int pointXS = pointX;\n            int pointXY = pointY;\n\n            for (int i = 0; i < direction.Length; i++)\n            {\n\n                if (aryChBattleArea[pointXS,pointXY] == direction[i])\n                {\n\n                    while (0 <= pointXS && pointXS < aryChBattleArea.GetLength(0) &&\n                                0 <= pointXY && pointXY < aryChBattleArea.GetLength(1))\n                    {\n\n                        if (aryChBattleArea[pointXS, pointXY] == '*')\n                        {\n\n                            aryChBattleArea[pointXS, pointXY] = '.';\n                            break;\n\n                        }\n                        else if (aryChBattleArea[pointXS, pointXY] == '#')\n                        {\n\n                            break;\n                        }\n\n                        pointXS += move[i, 0];\n                        pointXY += move[i, 1];\n                    }\n\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    /// <summary>\n    /// プログラムエントリポイント\n    /// </summary>\n    public static void Main()\n    {\n        //問題数入力\n        int countQ = int.Parse(Console.ReadLine());\n\n        //問題数分繰り返す\n        for (int i = 0; i < countQ; i++)\n        {\n            //戦車を動かすフィールドの２次元配列の大きさ入力\n            string[] inputData = Console.ReadLine().Split(' ');\n            \n            //入力されたフィールドの大きさの値をもとに char[][] の配列生成\n            char[ , ] aryChBattleArea = new char[ int.Parse(inputData[0]) , int.Parse(inputData[1]) ];\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n\n                char[] tmp = Console.ReadLine().ToCharArray();\n\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    aryChBattleArea[x, y] = tmp[y];\n                }\n\n            }\n\n            int countOperation = int.Parse(Console.ReadLine());\n\n            char[] aryChOperation = Console.ReadLine().ToCharArray();\n\n            BattleTown insBT = new BattleTown(aryChBattleArea, aryChOperation);\n\n            char[,] aryChAnswer = insBT.runOperation();\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    Console.Write(aryChAnswer[x, y]);\n                }\n                Console.WriteLine();\n            }\n\n        }\n    }\n}\n\n/// <summary>\n/// BattleTownクラス\n/// </summary>\nclass BattleTown\n{\n\n    private char[,] aryChBattleArea;\n    private char[] aryChOperation;\n\n    /// <summary>\n    /// コンストラクタ\n    /// </summary>\n    /// <param name=\"aryChBattleArea\">文字２重配列</param>\n    /// <param name=\"aryChOperation\">文字配列</param>\n    public BattleTown(char[,] aryChBattleArea, char[] aryChOperation)\n    {\n        this.aryChBattleArea = aryChBattleArea;\n        this.aryChOperation = aryChOperation;\n    }\n\n    /// <summary>\n    /// 命令を実行する\n    /// </summary>\n    /// <returns></returns>\n    public char[,] runOperation()\n    {\n\n        foreach (char c in aryChOperation)\n        {\n            for (int pointX = 0; pointX < aryChBattleArea.GetLength(0); pointX++)\n            {\n                for (int pointY = 0; pointY < aryChBattleArea.GetLength(1); pointY++)\n                {\n                    if (aryChBattleArea[pointX, pointY] == '^' || aryChBattleArea[pointX, pointY] == 'v'\n                            || aryChBattleArea[pointX, pointY] == '<' || aryChBattleArea[pointX, pointY] == '>')\n                    {\n                        this.actionTank(pointX, pointY, c);\n                        break;\n                    }\n\n                }\n\n            }\n        }\n\n        return this.aryChBattleArea;\n\n    }\n\n    /// <summary>\n    /// 戦車を命令に従って動かす\n    /// </summary>\n    /// <param name=\"pointX\">戦車の位置X</param>\n    /// <param name=\"pointY\">戦車の位置Y</param>\n    /// <param name=\"operation\">命令(文字)</param>\n    private void actionTank(int pointX, int pointY, char operation)\n    {\n        //命令、向き、動きがリンクしている。\n        char[] control = { 'U', 'D', 'R', 'L' };\n        char[] direction = { '^', 'v', '>', '<' };\n        int[,] move = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n        //移動用\n        if (operation != 'S')\n        {\n            //control[]の長さ分繰り返す\n            for (int i = 0; i < control.Length; i++ )\n            {\n                //命令が一致したら\n                if (operation == control[i])\n                {\n                    //戦車の向きをかえる\n                    aryChBattleArea[pointX, pointY] = direction[i];\n\n                    //戦車がX方向,Y方向に動いた先がaryChBattleArea[,]の範囲内だったら\n\n                    //if (pointX - 1 >= 0 && pointX + 1 < aryChBattleArea.Length\n                    //        && pointY - 1 >= 0 && pointY + 1 < aryChBattleArea.Length)\n\n                    if( pointX+move[i,0]>=0 && pointX+move[i,0]<aryChBattleArea.GetLength(0)\n                            && pointY+move[i,1]>=0 && pointY+move[i,1]<aryChBattleArea.GetLength(1) )\n                    {\n                        //戦車の移動先が '.'(平原) だったら\n                        if (aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] == '.')\n                        {\n                            //戦車がいた位置を'.'に変更\n                            aryChBattleArea[pointX, pointY] = '.';\n\n                            //戦車の移動先を向きにあわせて変更\n                            aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] = direction[i];\n\n                        }\n                    }\n                }\n            }\n\n        }\n\n        //射撃用\n        else\n        {\n            int pointXS = pointX;\n            int pointXY = pointY;\n\n            for (int i = 0; i < direction.Length; i++)\n            {\n\n                if (aryChBattleArea[pointXS,pointXY] == direction[i])\n                {\n\n                    while (0 <= pointXS && pointXS < aryChBattleArea.GetLength(0) &&\n                                0 <= pointXY && pointXY < aryChBattleArea.GetLength(1))\n                    {\n\n                        if (aryChBattleArea[pointXS, pointXY] == '*')\n                        {\n\n                            aryChBattleArea[pointXS, pointXY] = '.';\n                            break;\n\n                        }\n                        else if (aryChBattleArea[pointXS, pointXY] == '#')\n                        {\n\n                            break;\n                        }\n\n                        pointXS += move[i, 0];\n                        pointXY += move[i, 1];\n                    }\n\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    /// <summary>\n    /// プログラムエントリポイント\n    /// </summary>\n    public static void Main()\n    {\n        //問題数入力\n        int countQ = int.Parse(Console.ReadLine());\n\n        //問題数分繰り返す\n        for (int i = 0; i < countQ; i++)\n        {\n            //戦車を動かすフィールドの２次元配列の大きさ入力\n            string[] inputData = Console.ReadLine().Split(' ');\n            \n            //入力されたフィールドの大きさの値をもとに char[][] の配列生成\n            char[ , ] aryChBattleArea = new char[ int.Parse(inputData[0]) , int.Parse(inputData[1]) ];\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n\n                char[] tmp = Console.ReadLine().ToCharArray();\n\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    aryChBattleArea[x, y] = tmp[y];\n                }\n\n            }\n\n            int countOperation = int.Parse(Console.ReadLine());\n\n            char[] aryChOperation = new char[countOperation];\n\n            aryChOperation = Console.ReadLine().ToCharArray();\n\n            BattleTown insBT = new BattleTown(aryChBattleArea, aryChOperation);\n\n            char[,] aryChAnswer = insBT.runOperation();\n\n            for (int x = 0; x < aryChBattleArea.GetLength(0); x++)\n            {\n                for (int y = 0; y < aryChBattleArea.GetLength(1); y++)\n                {\n                    Console.Write(aryChAnswer[x, y]);\n                }\n                Console.WriteLine();\n            }\n\n        }\n    }\n}\n\n/// <summary>\n/// BattleTownクラス\n/// </summary>\nclass BattleTown\n{\n\n    private char[,] aryChBattleArea;\n    private char[] aryChOperation;\n\n    /// <summary>\n    /// コンストラクタ\n    /// </summary>\n    /// <param name=\"aryChBattleArea\">文字２重配列</param>\n    /// <param name=\"aryChOperation\">文字配列</param>\n    public BattleTown(char[,] aryChBattleArea, char[] aryChOperation)\n    {\n        this.aryChBattleArea = aryChBattleArea;\n        this.aryChOperation = aryChOperation;\n    }\n\n    /// <summary>\n    /// 命令を実行する\n    /// </summary>\n    /// <returns></returns>\n    public char[,] runOperation()\n    {\n\n        foreach (char c in aryChOperation)\n        {\n            for (int pointX = 0; pointX < aryChBattleArea.GetLength(0); pointX++)\n            {\n                for (int pointY = 0; pointY < aryChBattleArea.GetLength(1); pointY++)\n                {\n                    if (aryChBattleArea[pointX, pointY] == '^' || aryChBattleArea[pointX, pointY] == 'v'\n                            || aryChBattleArea[pointX, pointY] == '<' || aryChBattleArea[pointX, pointY] == '>')\n                    {\n                        this.actionTank(pointX, pointY, c);\n                        pointX++;\n                        break;\n                    }\n\n                }\n\n            }\n        }\n\n        return this.aryChBattleArea;\n\n    }\n\n    /// <summary>\n    /// 戦車を命令に従って動かす\n    /// </summary>\n    /// <param name=\"pointX\">戦車の位置X</param>\n    /// <param name=\"pointY\">戦車の位置Y</param>\n    /// <param name=\"operation\">命令(文字)</param>\n    private void actionTank(int pointX, int pointY, char operation)\n    {\n        //命令、向き、動きがリンクしている。\n        char[] control = { 'U', 'D', 'R', 'L' };\n        char[] direction = { '^', 'v', '>', '<' };\n        int[,] move = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n        //移動用\n        if (operation != 'S')\n        {\n            //control[]の長さ分繰り返す\n            for (int i = 0; i < control.Length; i++ )\n            {\n                //命令が一致したら\n                if (operation == control[i])\n                {\n                    //戦車の向きをかえる\n                    aryChBattleArea[pointX, pointY] = direction[i];\n\n                    //戦車がX方向,Y方向に動いた先がaryChBattleArea[,]の範囲内だったら\n\n                    //if (pointX - 1 >= 0 && pointX + 1 < aryChBattleArea.Length\n                    //        && pointY - 1 >= 0 && pointY + 1 < aryChBattleArea.Length)\n\n                    if( pointX+move[i,0]>=0 && pointX+move[i,0]<aryChBattleArea.GetLength(0)\n                            && pointY+move[i,1]>=0 && pointY+move[i,1]<aryChBattleArea.GetLength(1) )\n                    {\n                        //戦車の移動先が '.'(平原) だったら\n                        if (aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] == '.')\n                        {\n                            //戦車がいた位置を'.'に変更\n                            aryChBattleArea[pointX, pointY] = '.';\n\n                            //戦車の移動先を向きにあわせて変更\n                            aryChBattleArea[pointX + move[i, 0], pointY + move[i, 1]] = direction[i];\n\n                        }\n                    }\n                }\n            }\n\n        }\n\n        //射撃用\n        else\n        {\n            int pointXS = pointX;\n            int pointXY = pointY;\n\n            for (int i = 0; i < direction.Length; i++)\n            {\n\n                if (aryChBattleArea[pointXS,pointXY] == direction[i])\n                {\n\n                    while (0 <= pointXS && pointXS < aryChBattleArea.GetLength(0) &&\n                                0 <= pointXY && pointXY < aryChBattleArea.GetLength(1))\n                    {\n\n                        if (aryChBattleArea[pointXS, pointXY] == '*')\n                        {\n\n                            aryChBattleArea[pointXS, pointXY] = '.';\n                            break;\n\n                        }\n                        else if (aryChBattleArea[pointXS, pointXY] == '#')\n                        {\n\n                            break;\n                        }\n\n                        pointXS += move[i, 0];\n                        pointXY += move[i, 1];\n                    }\n\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "function move(y,x,str){\n   if(yx[tank[0]+y][tank[1]+x]==\".\"){\n      yx[tank[0]+y][tank[1]+x]=str;\n      yx[tank[0]][tank[1]]=\".\";\n      tank[0]+=y;\n      tank[1]+=x;\n   }else{\n     yx[tank[0]][tank[1]]=str;\n   }\n}\nfunction shot(y,x){\n   var i=0;\n   while(true){\n      i++;\n      if(yx[tank[0]+(y*i)][tank[1]+(x*i)]==\"#\")break;\n      else if(yx[tank[0]+(y*i)][tank[1]+(x*i)]==\"*\"){yx[tank[0]+(y*i)][tank[1]+(x*i)]=\".\";break;}\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\ninput=input.replace(/\\^/g,\"U\").replace(/v/g,\"D\").replace(/\\</g,\"L\").replace(/\\>/g,\"R\");\nvar arr=input.trim().split(\"\\n\");\nvar t=arr.shift()-0;\nfor(var i=0;i<t;i++){\n   if(i!=0)console.log(\"\");\n   var hw=arr.shift().split(\" \").map(Number);\n   var yx=[];\n   yx.push(\"####################\".split(\"\"));\n   var tank=[0,0];\n   for(var j=0;j<hw[0];j++){\n      var ary=arr.shift().split(\"\");\n      var w=-1;\n      ary.forEach(function(v,index){\n         if(v==\"U\" || v==\"D\" || v==\"L\" || v==\"R\")w=index;\n      });\n      if(w!=-1)tank=[j+1,w+1];\n      ary.unshift(\"#\");\n      ary.push(\"#\");\n      yx.push(ary);\n   }\n   yx.push(\"####################\".split(\"\"));\n   arr.shift();\n   var n=arr.shift().split(\"\");\n   n.forEach(function(v){\n      if(v==\"U\")move(-1,0,v);\n      else if(v==\"D\")move(1,0,v);\n      else if(v==\"L\")move(0,-1,v);\n      else if(v==\"R\")move(0,1,v);\n      else if(v==\"S\"){\n         var udlr=yx[tank[0]][tank[1]];\n         if(udlr==\"U\")shot(-1,0);\n         else if(udlr==\"D\")shot(1,0);\n         else if(udlr==\"L\")shot(0,-1);\n         else if(udlr==\"R\")shot(0,1);\n      }\n   });\n   yx.shift();\n   yx.pop();\n   var ans=yx.join(\"\\n\").replace(/\\,/g,\"\").replace(/^#|#$/mg,\"\");\n   console.log(ans.replace(/U/g,\"^\").replace(/D/g,\"v\").replace(/L/g,\"<\").replace(/R/g,\">\"));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function shot(y,x){\nvar i=0;\n\n\nwhile(true){\ni++;\nif(yx[tank[0]+(y*i)][tank[1]+(x*i)]==\"#\")break;\nelse if(yx[tank[0]+(y*i)][tank[1]+(x*i)]==\"*\"){yx[tank[0]+(y*i)][tank[1]+(x*i)]=\".\";break;}\n}\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\ninput=input.replace(/\\^/g,\"U\").replace(/v/g,\"D\").replace(/\\</g,\"L\").replace(/\\>/g,\"R\");\nvar arr=input.trim().split(\"\\n\");\nvar t=arr.shift()-0;\nfor(var i=0;i<t;i++){\nif(i!=0)console.log(\"\");\nvar hw=arr.shift().split(\" \").map(Number);\nvar yx=[];\nyx.push(\"####################\".split(\"\"));\nvar tank=[0,0];\nfor(var j=0;j<hw[0];j++){\nvar ary=arr.shift().split(\"\");\nvar w=-1;\nary.forEach(function(v,index){\n   if(v==\"U\" || v==\"D\" || v==\"L\" || v==\"R\")w=index;\n});\nif(w!=-1)tank=[j+1,w+1];\nary.unshift(\"#\");\nary.push(\"#\");\nyx.push(ary);\n}\nyx.push(\"####################\".split(\"\"));\narr.shift();\nvar n=arr.shift().split(\"\");\nn.forEach(function(v){\nif(v==\"U\" && yx[tank[0]-1][tank[1]]==\".\"){yx[tank[0]-1][tank[1]]=\"U\";yx[tank[0]][tank[1]]=\".\";tank[0]--;}\nelse if(v==\"U\" && yx[tank[0]-1][tank[1]]!=\".\")yx[tank[0]][tank[1]]=\"U\";\nelse if(v==\"D\" && yx[tank[0]+1][tank[1]]==\".\"){yx[tank[0]+1][tank[1]]=\"D\";yx[tank[0]][tank[1]]=\".\";tank[0]++;}\nelse if(v==\"D\" && yx[tank[0]+1][tank[1]]!=\".\")yx[tank[0]][tank[1]]=\"D\";\nelse if(v==\"L\" && yx[tank[0]][tank[1]-1]==\".\"){yx[tank[0]][tank[1]-1]=\"L\";yx[tank[0]][tank[1]]=\".\";tank[1]--;}\nelse if(v==\"L\" && yx[tank[0]][tank[1]-1]!=\".\")yx[tank[0]][tank[1]]=\"L\";\nelse if(v==\"R\" && yx[tank[0]][tank[1]+1]==\".\"){yx[tank[0]][tank[1]+1]=\"R\";yx[tank[0]][tank[1]]=\".\";tank[1]++;}\nelse if(v==\"R\" && yx[tank[0]][tank[1]+1]!=\".\")yx[tank[0]][tank[1]]=\"R\";\nelse if(v==\"S\"){\n   var udlr=yx[tank[0]][tank[1]];\n   if(udlr==\"U\")shot(-1,0);\n   else if(udlr==\"D\")shot(1,0);\n   else if(udlr==\"L\")shot(0,-1);\n   else if(udlr==\"R\")shot(0,1);\n}\n});\nyx.shift();\nyx.pop();\nconsole.log(yx.join(\"\\n\").replace(/^#/mg,\"\").replace(/#$/mg,\"\").replace(/\\,/g,\"\").replace(/U/g,\"^\").replace(/D/g,\"v\").replace(/L/g,\"<\").replace(/R/g,\">\"));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function move(y,x,str){\n   if(yx[tank[0]+y][tank[1]+x]==\".\"){\n      yx[tank[0]+y][tank[1]+x]=str;\n      yx[tank[0]][tank[1]]=\".\";\n      tank[0]+=y;\n      tank[1]+=x;\n   }else{\n     yx[tank[0]][tank[1]]=str;\n   }\n}\nfunction shot(y,x){\n   var i=0;\n   while(true){\n      i++;\n      if(yx[tank[0]+(y*i)][tank[1]+(x*i)]==\"#\")break;\n      else if(yx[tank[0]+(y*i)][tank[1]+(x*i)]==\"*\"){yx[tank[0]+(y*i)][tank[1]+(x*i)]=\".\";break;}\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar t=arr.shift()-0;\nfor(var i=0;i<t;i++){\n   if(i!=0)console.log(\"\");\n   var hw=arr.shift().split(\" \").map(Number);\n   var yx=[];\n   yx.push(\"######################\".split(\"\"));\n   var tank=[0,0];\n   for(var j=0;j<hw[0];j++){\n      var ary=arr.shift().split(\"\");\n      var w=-1;\n      ary.forEach(function(v,i){\n         if(v==\"^\" || v==\"v\" || v==\"<\" || v==\">\")w=i;\n      });\n      if(w!=-1)tank=[j+1,w+1];\n      ary.unshift(\"#\");\n      ary.push(\"#\");\n      yx.push(ary);\n   }\n   yx.push(\"######################\".split(\"\"));\n   arr.shift();\n   var n=arr.shift().split(\"\");\n   n.forEach(function(v){\n      if(v==\"U\")move(-1,0,\"^\");\n      else if(v==\"D\")move(1,0,\"v\");\n      else if(v==\"L\")move(0,-1,\"<\");\n      else if(v==\"R\")move(0,1,\">\");\n      else if(v==\"S\"){\n         var str=yx[tank[0]][tank[1]];\n         if(str==\"^\")shot(-1,0);\n         else if(str==\"v\")shot(1,0);\n         else if(str==\"<\")shot(0,-1);\n         else if(str==\">\")shot(0,1);\n      }\n   });\n   yx.shift();\n   yx.pop();\n   var ans=yx.join(\"\\n\").replace(/\\,/g,\"\").replace(/^#|#$/mg,\"\");\n   console.log(ans);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function shot(y,x){\nvar i=0;\n\n\nwhile(true){\ni++;\nif(yx[tank[0]+(y*i)][tank[1]+(x*i)]==\"#\")break;\nelse if(yx[tank[0]+(y*i)][tank[1]+(x*i)]==\"*\"){yx[tank[0]+(y*i)][tank[1]+(x*i)]=\".\";break;}\n}\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\ninput=input.replace(/\\^/g,\"U\").replace(/v/g,\"D\").replace(/\\</g,\"L\").replace(/\\>/g,\"R\");\nvar arr=input.trim().split(\"\\n\");\nvar t=arr.shift()-0;\nfor(var i=0;i<t;i++){\nif(i!=0)console.log(\"\\n\");\nvar hw=arr.shift().split(\" \").map(Number);\nvar yx=[];\nyx.push(\"####################\".split(\"\"));\nvar tank=[0,0];\nfor(var j=0;j<hw[0];j++){\nvar ary=arr.shift().split(\"\");\nvar w=-1;\nary.forEach(function(v,index){\n   if(v==\"U\" || v==\"D\" || v==\"L\" || v==\"R\")w=index;\n});\nif(w!=-1)tank=[j+1,w+1];\nary.unshift(\"#\");\nary.push(\"#\");\nyx.push(ary);\n}\nyx.push(\"####################\".split(\"\"));\narr.shift();\nvar n=arr.shift().split(\"\");\nn.forEach(function(v){\nif(v==\"U\" && yx[tank[0]-1][tank[1]]==\".\"){yx[tank[0]-1][tank[1]]=\"U\";yx[tank[0]][tank[1]]=\".\";tank[0]--;}\nelse if(v==\"U\" && yx[tank[0]-1][tank[1]]!=\".\")yx[tank[0]][tank[1]]=\"U\";\nelse if(v==\"D\" && yx[tank[0]+1][tank[1]]==\".\"){yx[tank[0]+1][tank[1]]=\"D\";yx[tank[0]][tank[1]]=\".\";tank[0]++;}\nelse if(v==\"D\" && yx[tank[0]+1][tank[1]]!=\".\")yx[tank[0]][tank[1]]=\"D\";\nelse if(v==\"L\" && yx[tank[0]][tank[1]-1]==\".\"){yx[tank[0]][tank[1]-1]=\"L\";yx[tank[0]][tank[1]]=\".\";tank[1]--;}\nelse if(v==\"L\" && yx[tank[0]][tank[1]-1]!=\".\")yx[tank[0]][tank[1]]=\"L\";\nelse if(v==\"R\" && yx[tank[0]][tank[1]+1]==\".\"){yx[tank[0]][tank[1]+1]=\"R\";yx[tank[0]][tank[1]]=\".\";tank[1]++;}\nelse if(v==\"R\" && yx[tank[0]][tank[1]+1]!=\".\")yx[tank[0]][tank[1]]=\"R\";\nelse if(v==\"S\"){\n   var udlr=yx[tank[0]][tank[1]];\n   if(udlr==\"U\")shot(-1,0);\n   else if(udlr==\"D\")shot(1,0);\n   else if(udlr==\"L\")shot(0,-1);\n   else if(udlr==\"R\")shot(0,1);\n}\n});\nyx.shift();\nyx.pop();\nconsole.log(yx.join(\"\\n\").replace(/^#/mg,\"\").replace(/#$/mg,\"\").replace(/\\,/g,\"\").replace(/U/g,\"^\").replace(/D/g,\"v\").replace(/L/g,\"<\").replace(/R/g,\">\"));\n}"
  },
  {
    "language": "Ruby",
    "code": "MV = {}\nMV['U'] = [-1, 0]; MV['D'] = [1, 0]; MV['L'] = [0, -1]; MV['R'] = [0, 1]\nTank = {}\nTank['^'] = 'U'; Tank['v'] = 'D'; Tank['<'] = 'L'; Tank['>'] = 'R'\n\ngets.to_i.times do |i|\n  puts if i > 0\n  h, w = gets.split.map(&:to_i)\n  fld = (h+2).times.map{''}\n  fld[0] = fld[h+1] = ' '*(w+2)\n  y, x = 0, 0 \n  z = ''\n  h.times do |i|\n    f = gets.chomp\n    Tank.keys.each do |t|\n      if f.include?(t)\n        y, x = i+1, f.index(t)+1\n        z = Tank[t]\n      end\n    end\n    fld[i+1] << ' ' + f + ' '\n  end \n\n  n = gets.to_i\n  tank = gets\n  n.times do |j|\n    if tank[j] == 'S'\n      my, mx = y, x\n      while fld[my][mx] != ' '\n        my += MV[z][0]; mx += MV[z][1]\n        if fld[my][mx] == '*'\n          fld[my][mx] = '.'\n          break\n        elsif fld[my][mx] == '#'\n          break\n        end\n      end\n    else\n      z = tank[j]\n      if fld[y + MV[z][0]][x + MV[z][1]] == '.'\n        fld[y][x] = '.'\n        y += MV[z][0]; x += MV[z][1]\n        fld[y][x] = Tank.key(z)\n      else\n        fld[y][x] = Tank.key(z)\n      end\n    end\n  end\n  (1..h).each{ |j| puts fld[j][1,w] }\nend"
  },
  {
    "language": "Ruby",
    "code": "MV = {}\nMV[\"U\"] = [-1, 0]; MV[\"D\"] = [1 ,0]; MV[\"L\"] = [0, -1]; MV[\"R\"] = [0, 1]\nTank = {}\nTank[\"^\"] = \"U\"; Tank[\"v\"] = \"D\"; Tank[\"<\"] = \"L\"; Tank[\">\"] = \"R\"\ngets.to_i.times do |i|\n  puts if i > 0\n  h, w = gets.split.map(&:to_i)\n  fld = (h+2).times.map{\"\"}\n  fld[0] = fld[h+1] = \" \"*(w+2)\n  y, x = 0, 0 \n  z = \"\"\n  h.times do |i|\n    f = gets.chomp\n    Tank.keys.each do |t|\n      if f.include?(t)\n        y, x = i + 1, f.index(t) + 1\n        z = Tank[t]\n      end\n    end\n    fld[i+1] << \" \" + f + \" \"\n  end \n\n  n = gets.to_i\n  tank = gets\n  n.times do |i|\n    if tank[i] == \"S\"\n      my, mx = y, x\n      while fld[my][mx] != \" \"\n        my += MV[z][0]; mx += MV[z][1]\n        if fld[my][mx] == \"*\"\n          fld[my][mx] = \".\"\n          break\n        elsif fld[my][mx] == \"#\"\n          break\n        end\n      end\n    else\n      z = tank[i]\n      if fld[y + MV[z][0]][x + MV[z][1]] == \".\"\n        fld[y][x] = \".\"\n        y += MV[z][0]; x += MV[z][1]\n        fld[y][x] = Tank.key(z)\n      end\n    end\n  end\n  (1..h).each{ |i| puts fld[i][1,w] }\nend"
  },
  {
    "language": "Ruby",
    "code": "MV = {}\nMV[\"U\"] = [-1, 0]; MV[\"D\"] = [1, 0]; MV[\"L\"] = [0, -1]; MV[\"R\"] = [0, 1]\nTank = {}\nTank[\"^\"] = \"U\"; Tank[\"v\"] = \"D\"; Tank[\"<\"] = \"L\"; Tank[\">\"] = \"R\"\ngets.to_i.times do |i|\n  puts if i > 0\n  h, w = gets.split.map(&:to_i)\n  fld = (h+2).times.map{\"\"}\n  fld[0] = fld[h+1] = \" \"*(w+2)\n  y, x = 0, 0 \n  z = \"\"\n  h.times do |i|\n    f = gets.chomp\n    Tank.keys.each do |t|\n      if f.include?(t)\n        y, x = i + 1, f.index(t) + 1\n        z = Tank[t]\n      end\n    end\n    fld[i+1] << \" \" + f + \" \"\n  end \n\n  n = gets.to_i\n  tank = gets\n  n.times do |i|\n    if tank[i] == \"S\"\n      my, mx = y, x\n      while fld[my][mx] != \" \"\n        my += MV[z][0]; mx += MV[z][1]\n        if fld[my][mx] == \"*\"\n          fld[my][mx] = \".\"\n          break\n        elsif fld[my][mx] == \"#\"\n          break\n        end\n      end\n    else\n      z = tank[i]\n      if fld[y + MV[z][0]][x + MV[z][1]] == \".\"\n        fld[y][x] = \".\"\n        y += MV[z][0]; x += MV[z][1]\n        fld[y][x] = Tank.key(z)\n      else\n        fld[y][x] = Tank.key(z)\n      end\n    end\n  end\n  (1..h).each{ |i| puts fld[i][1,w] }\nend"
  },
  {
    "language": "Ruby",
    "code": "MV = { 'U' => [-1, 0], 'D' => [1, 0], 'L' => [0, -1], 'R' => [0, 1] }\nTank = { '^' =>'U', 'v' => 'D', '<' => 'L', '>' => 'R' }\n\ngets.to_i.times do |i|\n  puts if i > 0\n  h, w = gets.split.map(&:to_i)\n  fld = (h+2).times.map{''}\n  fld[0] = fld[h+1] = ' '*(w+2)\n  y, x = 0, 0 \n  z = ''\n  h.times do |i|\n    f = gets.chomp\n    Tank.keys.each do |t|\n      if f.include?(t)\n        y, x = i+1, f.index(t)+1\n        z = Tank[t]\n      end\n    end\n    fld[i+1] << ' ' + f + ' '\n  end \n\n  n = gets.to_i\n  tank = gets\n  n.times do |j|\n    if tank[j] == 'S'\n      my, mx = y, x\n      while fld[my][mx] != ' '\n        my += MV[z][0]; mx += MV[z][1]\n        if fld[my][mx] == '*'\n          fld[my][mx] = '.'\n          break\n        elsif fld[my][mx] == '#'\n          break\n        end\n      end\n    else\n      z = tank[j]\n      if fld[y + MV[z][0]][x + MV[z][1]] == '.'\n        fld[y][x] = '.'\n        y += MV[z][0]; x += MV[z][1]\n        fld[y][x] = Tank.key(z)\n      else\n        fld[y][x] = Tank.key(z)\n      end\n    end\n  end\n  (1..h).each{ |j| puts fld[j][1,w] }\nend"
  },
  {
    "language": "Python",
    "code": "def move(act,y,x,direction):#戦車の動き\n    #print(\"x,y\",y,x)\n    #print(\"M,H\",M,H)\n    if x<0 or x == M or y<0 or y == H:\n        return s_map\n    if act == 'U':#Up\n        if y == 0:\n            s_map[y][x] = '^'\n        else:\n            if s_map[y-1][x] == '.':#下が平地なら\n                s_map[y][x],s_map[y-1][x] = '.','^'#現在地と下を入れ替える\n            else:\n                s_map[y][x] = '^'\n    elif act == 'D':#Down\n        if y == H-1:\n            s_map[y][x] = 'v'\n        else:\n            if s_map[y+1][x] == '.':#下が平地なら\n                s_map[y][x],s_map[y+1][x] = '.','v'#現在地と下を入れ替える\n            else:\n                s_map[y][x] = 'v'\n\n    elif act == 'L':#Left\n        if x == 0:\n            s_map[y][x] = '<'\n        else:\n            if s_map[y][x-1] == '.':#左が平地なら\n                s_map[y][x],s_map[y][x-1] = '.','<'#現在地と左を入れ替える\n            else:\n                s_map[y][x] = '<'\n\n    elif act == 'R':#Right\n        if x == M-1:\n            s_map[y][x] = '>'\n        else:\n            if s_map[y][x+1] == '.':#右が平地なら\n                s_map[y][x],s_map[y][x+1] = '.','>'#現在地と右を入れ替える\n            else:\n                s_map[y][x] = '>'\n\n    else:#Shoot\n        now_dir = s_map[y][x]\n        ma = shoot(y,x,now_dir)\n        return ma\n    \ndef shoot(y,x,now_dir):\n    if x<0 or y<0 or x==M or y==H:\n        return s_map\n    if now_dir == '>':#戦車が右を向いていたら\n        while True:\n            #再帰かな x+=1　右の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y,x+1,now_dir)\n            break\n\n    elif now_dir == '<':#戦車が左を向いていたら\n        while True:\n            #再帰かな x-=1　左の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y,x-1,now_dir)\n            break\n       \n    elif now_dir == '^':\n        while True:\n            #再帰かな y-=1　右の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y-1,x,now_dir)\n            break\n\n    elif now_dir == 'v':\n        while True:\n            #再帰かな y+=1　右の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y+1,x,now_dir)\n            break\n\ndef search_index(s_map):#現在地のインデックスと方向を確認\n    direction = ['^','v','>','<']\n    for i in range(len(direction)):\n        for j in range(len(s_map)):\n            for k in range(len(s_map[0])):\n                if direction[i] in s_map[j][k]:\n                    x,y,d = j,k,direction[i]\n\n    return x,y,d\n\n\nif __name__== '__main__':\n    T = int(input())#全体回数\n    all_map=[]\n    for i in range(T):\n        s_map = []\n        H,M = map(int,input().split())#マップの縦幅横幅\n        for j in range(H):#マップ作成\n            s_map.append([i for i in input()])\n        N = int(input())#何回処理を行うか\n        action = input()#アクション文字列\n        for k in action:\n            x,y,direction = search_index(s_map)\n            #print(\"Now state (x,y)\",y,x)\n            #print(direction)\n            #print(\"action = \",k)\n            m  = move(k,x,y,direction)\n        all_map.append(s_map)\n    for j in range(len(all_map)):\n        for i in range(len(all_map[j])):\n            print(''.join(all_map[j][i]))\n        if j != len(all_map)-1:\n            print(\" \")\n\n"
  },
  {
    "language": "Python",
    "code": "dx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ntanks = map(ord, \"<^>v\")\nflat = ord(\".\")\nbrick = ord(\"*\")\niron = ord(\"#\")\nwater = ord(\"-\")\n\nfor t in xrange(input()):\n    h, w = map(int, raw_input().split())\n    m = [map(ord, raw_input()) for i in xrange(h)]\n    n = input()\n    s = raw_input()\n    x, y = 0, 0\n    d = 0\n    for i in xrange(h):\n        for j in xrange(w):\n            if m[i][j] in tanks:\n                x = j\n                y = i\n                d = tanks.index(m[i][j])\n                m[i][j] = flat\n    for comm in s:\n        if comm==\"U\":\n            d = 1\n            if y>0 and m[y-1][x]==flat:\n                y -= 1\n        elif comm==\"D\":\n            d = 3\n            if y<h-1 and m[y+1][x]==flat:\n                y += 1\n        elif comm==\"L\":\n            d = 0\n            if x>0 and m[y][x-1]==flat:\n                x -= 1\n        elif comm==\"R\":\n            d = 2\n            if x<w-1 and m[y][x+1]==flat:\n                x += 1\n        else:\n            # \"S\"\n            nx = x + dx[d]\n            ny = y + dy[d]\n            while 0<=nx<=w-1 and 0<=ny<=h-1:\n                obj = m[ny][nx]\n                if obj==brick:\n                    m[ny][nx] = flat\n                    break\n                elif obj==iron:\n                    break\n                nx += dx[d]\n                ny += dy[d]\n    m[y][x] = tanks[d]\n    for i in xrange(h):\n        print \"\".join(map(chr, m[i]))"
  },
  {
    "language": "Python",
    "code": "dx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ntanks = \"<^>v\"\nflat = \".\"\nbrick = \"*\"\niron = \"#\"\nwater = \"-\"\n\ncase = input()\nfor t in xrange(case):\n    h, w = map(int, raw_input().split())\n    m = [list(raw_input()) for i in xrange(h)]\n    n = input()\n    s = raw_input()\n    x, y = 0, 0\n    d = 0\n    for i in xrange(h):\n        for j in xrange(w):\n            if m[i][j] in tanks:\n                x = j\n                y = i\n                d = tanks.index(m[i][j])\n                m[i][j] = flat\n    for comm in s:\n        if comm==\"U\":\n            d = 1\n            if y>0 and m[y-1][x]==flat:\n                y -= 1\n        elif comm==\"D\":\n            d = 3\n            if y<h-1 and m[y+1][x]==flat:\n                y += 1\n        elif comm==\"L\":\n            d = 0\n            if x>0 and m[y][x-1]==flat:\n                x -= 1\n        elif comm==\"R\":\n            d = 2\n            if x<w-1 and m[y][x+1]==flat:\n                x += 1\n        else:\n            # \"S\"\n            nx = x + dx[d]\n            ny = y + dy[d]\n            while 0<=nx<=w-1 and 0<=ny<=h-1:\n                obj = m[ny][nx]\n                if obj==brick:\n                    m[ny][nx] = flat\n                    break\n                elif obj==iron:\n                    break\n                nx += dx[d]\n                ny += dy[d]\n    m[y][x] = tanks[d]\n    for i in xrange(h):\n        print \"\".join(m[i])\n    if t<case-1:\n        print"
  },
  {
    "language": "Python",
    "code": "for _ in range(input()):\n\tif _ > 0: print\n\tH,W = map(int,raw_input().split())\n\tA = [list(raw_input()) for i in range(H)]\n\tfor h in range(H):\n\t\tfor w in range(W):\n\t\t\tif A[h][w] in \"^<v>\":\n\t\t\t\tx,y = w,h\n\t\t\t\td = A[h][w]\n\t\t\t\tA[h][w] = \".\"\n\tinput()\n\tcmd = raw_input()\n\tfor c in cmd:\n\t\tif   c == \"S\":\n\t\t\tif d == \"^\":\n\t\t\t\tfor h in range(y-1,-1,-1):\n\t\t\t\t\tif A[h][x] == \"*\":\n\t\t\t\t\t\tA[h][x] = \".\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif A[h][x] == \"#\":\n\t\t\t\t\t\tbreak\n\t\t\tif d == \"<\":\n\t\t\t\tfor w in range(x-1,-1,-1):\n\t\t\t\t\tif A[y][w] == \"*\":\n\t\t\t\t\t\tA[y][w] = \".\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif A[y][w] == \"#\":\n\t\t\t\t\t\tbreak\n\t\t\tif d == \"v\":\n\t\t\t\tfor h in range(y+1,H):\n\t\t\t\t\tif A[h][x] == \"*\":\n\t\t\t\t\t\tA[h][x] = \".\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif A[h][x] == \"#\":\n\t\t\t\t\t\tbreak\n\t\t\tif d == \">\":\n\t\t\t\tfor w in range(x+1,W):\n\t\t\t\t\tif A[y][w] == \"*\":\n\t\t\t\t\t\tA[y][w] = \".\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif A[y][w] == \"#\":\n\t\t\t\t\t\tbreak\n\t\telif c == \"U\":\n\t\t\td = \"^\"\n\t\t\tif y-1 >= 0 and A[y-1][x] == \".\":\n\t\t\t\ty = y-1\n\t\telif c == \"L\":\n\t\t\td = \"<\"\n\t\t\tif x-1 >= 0 and A[y][x-1] == \".\":\n\t\t\t\tx = x-1\n\t\telif c == \"D\":\n\t\t\td = \"v\"\n\t\t\tif y+1 <  H and A[y+1][x] == \".\":\n\t\t\t\ty = y+1\n\t\telif c == \"R\":\n\t\t\td = \">\"\n\t\t\tif x+1 <  W and A[y][x+1] == \".\":\n\t\t\t\tx = x+1\n\tA[y][x] = d\n\tfor h in range(H):\n\t\tprint \"\".join(A[h])"
  },
  {
    "language": "Python",
    "code": "def move(act,y,x,direction):#戦車の動き\n    #print(\"x,y\",y,x)\n    #print(\"M,H\",M,H)\n    if x<0 or x == M or y<0 or y == H:\n        return s_map\n    if act == 'U':#Up\n        if y == 0:\n            s_map[y][x] = '^'\n        else:\n            if s_map[y-1][x] == '.':#下が平地なら\n                s_map[y][x],s_map[y-1][x] = '.','^'#現在地と下を入れ替える\n            else:\n                s_map[y][x] = '^'\n    elif act == 'D':#Down\n        if y == H-1:\n            s_map[y][x] = 'v'\n        else:\n            if s_map[y+1][x] == '.':#下が平地なら\n                s_map[y][x],s_map[y+1][x] = '.','v'#現在地と下を入れ替える\n            else:\n                s_map[y][x] = 'v'\n\n    elif act == 'L':#Left\n        if x == 0:\n            s_map[y][x] = '<'\n        else:\n            if s_map[y][x-1] == '.':#左が平地なら\n                s_map[y][x],s_map[y][x-1] = '.','<'#現在地と左を入れ替える\n            else:\n                s_map[y][x] = '<'\n\n    elif act == 'R':#Right\n        if x == M-1:\n            s_map[y][x] = '>'\n        else:\n            if s_map[y][x+1] == '.':#右が平地なら\n                s_map[y][x],s_map[y][x+1] = '.','>'#現在地と右を入れ替える\n            else:\n                s_map[y][x] = '>'\n\n    else:#Shoot\n        now_dir = s_map[y][x]\n        ma = shoot(y,x,now_dir)\n        return ma\n    \ndef shoot(y,x,now_dir):\n    if x<0 or y<0 or x==M or y==H:\n        return s_map\n    if now_dir == '>':#戦車が右を向いていたら\n        while True:\n            #再帰かな x+=1　右の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y,x+1,now_dir)\n            break\n\n    elif now_dir == '<':#戦車が左を向いていたら\n        while True:\n            #再帰かな x-=1　左の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y,x-1,now_dir)\n            break\n       \n    elif now_dir == '^':\n        while True:\n            #再帰かな y-=1　右の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y-1,x,now_dir)\n            break\n\n    elif now_dir == 'v':\n        while True:\n            #再帰かな y+=1　右の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y+1,x,now_dir)\n            break\n\ndef search_index(s_map):#現在地のインデックスと方向を確認\n    direction = ['^','v','>','<']\n    for i in range(len(direction)):\n        for j in range(len(s_map)):\n            for k in range(len(s_map[0])):\n                if direction[i] in s_map[j][k]:\n                    x,y,d = j,k,direction[i]\n\n    return x,y,d\n\n\nif __name__== '__main__':\n    T = int(input())#全体回数\n    all_map=[]\n    for i in range(T):\n        s_map = []\n        H,M = map(int,input().split())#マップの縦幅横幅\n        for j in range(H):#マップ作成\n            s_map.append([i for i in input()])\n        N = int(input())#何回処理を行うか\n        action = input()#アクション文字列\n        for k in action:\n            x,y,direction = search_index(s_map)\n            #print(\"Now state (x,y)\",y,x)\n            #print(direction)\n            #print(\"action = \",k)\n            m  = move(k,x,y,direction)\n        all_map.append(s_map)\n    for j in range(len(all_map)):\n        for i in range(len(all_map[j])):\n            print(''.join(all_map[j][i]))\n        if j != len(all_map)-1:\n            print(\"\")\n\n"
  },
  {
    "language": "Python",
    "code": "t = int(input())\nfor i in range(t):\n  h, w = map(int, input().split())\n  mp = [list(\"#\" + input() + \"#\") for _ in range(h)]\n  mp.insert(0, [\"#\"] * (w + 2))\n  mp.append([\"#\"] * (w + 2))\n  for y in range(h + 2):\n    for x in range(w + 2):\n      if mp[y][x] == \">\":\n        sx, sy, sd = x, y, 0\n      if mp[y][x] == \"^\":\n        sx, sy, sd = x, y, 1\n      if mp[y][x] == \"<\":\n        sx, sy, sd = x, y, 2\n      if mp[y][x] == \"v\":\n        sx, sy, sd = x, y, 3\n  mp[sy][sx] = \".\"\n  n = int(input())\n  s = input()\n  vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n  dic = {\"R\":0, \"U\":1, \"L\":2, \"D\":3}\n  tank = {0:\">\", 1:\"^\", 2:\"<\", 3:\"v\"}\n  for c in s:\n    if c == \"S\":\n      dx, dy = vec[sd]\n      nx, ny = sx, sy\n      while mp[ny][nx] not in (\"#\", \"*\"):\n        nx += dx\n        ny += dy\n      if mp[ny][nx] == \"*\":\n        mp[ny][nx] = \".\"\n\n    else:\n      sd = dic[c]\n      dx, dy = vec[sd]\n      if mp[sy + dy][sx + dx] == \".\":\n        sx += dx\n        sy += dy\n\n  mp[sy][sx] = tank[sd]\n  for j in range(1, h + 1):\n    print(\"\".join(mp[j][1:-1]))\n  if i != t - 1:\n    print()\n"
  },
  {
    "language": "Python",
    "code": "T = int(input())\nfor i in range(T) :\n    H, W = map(int, input().split())\n    Map = []\n    for h in range(H) :\n        tmp = list(input())\n        Map.append(tmp)\n        if \"^\" in tmp :\n            Me_h = h\n            Me_w = tmp.index(\"^\")\n        if \">\" in tmp :\n            Me_h = h\n            Me_w = tmp.index(\">\")\n        if \"v\" in tmp :\n            Me_h = h\n            Me_w = tmp.index(\"v\")\n        if \"<\" in tmp :\n            Me_h = h\n            Me_w = tmp.index(\"<\")\n    N = int(input())\n    Meirei = list(input())\n    \n    for m in range(N) :\n        if Meirei[m] == \"U\" :\n            if Me_h > 0 and Map[Me_h - 1][Me_w] == \".\" :\n                Map[Me_h - 1][Me_w] = \"^\"\n                Map[Me_h][Me_w] = \".\"\n                Me_h -= 1\n            else :\n                Map[Me_h][Me_w] = \"^\"\n        elif Meirei[m] == \"D\" :\n            if Me_h < H-1 and Map[Me_h + 1][Me_w] == \".\" :\n                Map[Me_h + 1][Me_w] = \"v\"\n                Map[Me_h][Me_w] = \".\"\n                Me_h += 1\n            else :\n                Map[Me_h][Me_w] = \"v\"\n        elif Meirei[m] == \"L\" :\n            if Me_w > 0 and Map[Me_h][Me_w - 1] == \".\" :\n                Map[Me_h][Me_w - 1] = \"<\"\n                Map[Me_h][Me_w] = \".\"\n                Me_w -= 1\n            else :\n                Map[Me_h][Me_w] = \"<\"\n        elif Meirei[m] == \"R\" :\n            if Me_w < W-1 and Map[Me_h][Me_w + 1] == \".\" :\n                Map[Me_h][Me_w + 1] = \">\"\n                Map[Me_h][Me_w] = \".\"\n                Me_w += 1\n            else :\n                Map[Me_h][Me_w] = \">\"\n        else :\n            if Map[Me_h][Me_w] == \"^\" :\n                h = Me_h\n                w = Me_w\n                while Map[h][w] != \"*\" and Map[h][w] != \"#\" and 0 < h :\n                    h -= 1\n                if Map[h][w] == \"*\" :\n                    Map[h][w] = \".\"\n            elif Map[Me_h][Me_w] == \"v\" :\n                h = Me_h\n                w = Me_w\n                while Map[h][w] != \"*\" and Map[h][w] != \"#\" and h < H -1 :\n                    h += 1\n                if Map[h][w] == \"*\" :\n                    Map[h][w] = \".\"\n            elif Map[Me_h][Me_w] == \">\" :\n                h = Me_h\n                w = Me_w\n                while Map[h][w] != \"*\" and Map[h][w] != \"#\" and w < W -1 :\n                    w += 1\n                if Map[h][w] == \"*\" :\n                    Map[h][w] = \".\"\n            elif Map[Me_h][Me_w] == \"<\" :\n                h = Me_h\n                w = Me_w\n                while Map[h][w] != \"*\" and Map[h][w] != \"#\" and w > 0 :\n                    w -= 1\n                if Map[h][w] == \"*\" :\n                    Map[h][w] = \".\"\n                    \n    for h in range(H) :\n        for w in range(W) :\n            print(Map[h][w], sep=\"\", end=\"\")\n        print()\n    if i != T -1 :\n        print()\n                    \n            \n"
  },
  {
    "language": "Python",
    "code": "def move(y, x):\n    p[2], p[3] = y, x\n    if a[p[0] + y][p[1] + x] == \".\":p[0] += y;p[1] += x\n\ndef shoot():\n    th = p[0] + p[2]\n    tw = p[1] + p[3]\n    while 1:\n        if a[th][tw] == \"*\":a[th][tw] = \".\";break\n        elif a[th][tw] == \"#\":break\n        else: th += p[2]; tw += p[3]\n\nfor u in range(int(input())):\n    if u > 0:print()\n    h, w = map(int, input().split())\n    a = [[\"#\"] * (w + 2)] + [[\"#\"] + list(input()) + [\"#\"] for _ in range(h)] + [[\"#\"] * (w + 2)]\n    for i in range(1, h + 1):\n        for j in range(1, w + 1):\n            if a[i][j] == \">\":p = [i, j, 0, 1];a[i][j] = \".\";break\n            elif a[i][j] == \"^\":p = [i, j, -1, 0];a[i][j] = \".\";break\n            elif a[i][j] == \"<\":p = [i, j, 0, -1];a[i][j] = \".\";break\n            elif a[i][j] == \"v\":p = [i, j, 1, 0];a[i][j] = \".\";break\n    n, c = int(input()), input()\n    for i in range(n):\n        if c[i] == \"U\":move(-1, 0)\n        elif c[i] == \"R\":move(0, 1)\n        elif c[i] == \"L\":move(0, -1)\n        elif c[i] == \"D\":move(1, 0)\n        else:shoot()\n    if (p[2], p[3]) == (0, 1):a[p[0]][p[1]] = \">\"\n    elif (p[2], p[3]) == (-1, 0):a[p[0]][p[1]] = \"^\"\n    elif (p[2], p[3]) == (0, -1):a[p[0]][p[1]] = \"<\"\n    else:a[p[0]][p[1]] = \"v\"\n    for i in a[1:-1]:print(\"\".join(i[1:-1]))\n"
  },
  {
    "language": "Python",
    "code": "def move(act,y,x,direction):#戦車の動き\n    #print(\"x,y\",y,x)\n    #print(\"M,H\",M,H)\n    if x<0 or x == M or y<0 or y == H:\n        return s_map\n    if act == 'U':#Up\n        if y == 0:\n            s_map[y][x] = '^'\n        else:\n            if s_map[y-1][x] == '.':#下が平地なら\n                s_map[y][x],s_map[y-1][x] = '.','^'#現在地と下を入れ替える\n            else:\n                s_map[y][x] = '^'\n    elif act == 'D':#Down\n        if y == H-1:\n            s_map[y][x] = 'v'\n        else:\n            if s_map[y+1][x] == '.':#下が平地なら\n                s_map[y][x],s_map[y+1][x] = '.','v'#現在地と下を入れ替える\n            else:\n                s_map[y][x] = 'v'\n\n    elif act == 'L':#Left\n        if x == 0:\n            s_map[y][x] = '<'\n        else:\n            if s_map[y][x-1] == '.':#左が平地なら\n                s_map[y][x],s_map[y][x-1] = '.','<'#現在地と左を入れ替える\n            else:\n                s_map[y][x] = '<'\n\n    elif act == 'R':#Right\n        if x == M-1:\n            s_map[y][x] = '>'\n        else:\n            if s_map[y][x+1] == '.':#右が平地なら\n                s_map[y][x],s_map[y][x+1] = '.','>'#現在地と右を入れ替える\n            else:\n                s_map[y][x] = '>'\n\n    else:#Shoot\n        now_dir = s_map[y][x]\n        ma = shoot(y,x,now_dir)\n        return ma\n    \ndef shoot(y,x,now_dir):\n    if x<0 or y<0 or x==M or y==H:\n        return s_map\n    if now_dir == '>':#戦車が右を向いていたら\n        while True:\n            #再帰かな x+=1　右の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y,x+1,now_dir)\n            break\n\n    elif now_dir == '<':#戦車が左を向いていたら\n        while True:\n            #再帰かな x-=1　左の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y,x-1,now_dir)\n            break\n       \n    elif now_dir == '^':\n        while True:\n            #再帰かな y-=1　右の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y-1,x,now_dir)\n            break\n\n    elif now_dir == 'v':\n        while True:\n            #再帰かな y+=1　右の地面を見ていく\n            if s_map[y][x] == '*':\n                s_map[y][x] = '.'\n                break\n            elif s_map[y][x] == '#':\n                break\n            else:\n                shoot(y+1,x,now_dir)\n            break\n\ndef search_index(s_map):#現在地のインデックスと方向を確認\n    direction = ['^','v','>','<']\n    for i in range(len(direction)):\n        for j in range(len(s_map)):\n            for k in range(len(s_map[0])):\n                if direction[i] in s_map[j][k]:\n                    x,y,d = j,k,direction[i]\n\n    return x,y,d\n\n\nif __name__== '__main__':\n    T = int(input())#全体回数\n    all_map=[]\n    for i in range(T):\n        s_map = []\n        H,M = map(int,input().split())#マップの縦幅横幅\n        for j in range(H):#マップ作成\n            s_map.append([i for i in input()])\n        N = int(input())#何回処理を行うか\n        action = input()#アクション文字列\n        for k in action:\n            x,y,direction = search_index(s_map)\n            #print(\"Now state (x,y)\",y,x)\n            #print(direction)\n            #print(\"action = \",k)\n            m  = move(k,x,y,direction)\n        all_map.append(s_map)\n    for j in range(len(all_map)):\n        for i in range(len(all_map[j])):\n            print(''.join(all_map[j][i]))\n        if j != len(all_map)-1:\n            print(\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "def check(x,y):\n\tif A[y][x] == \"*\":\n\t\tA[y][x] = \".\"\n\t\treturn True\n\tif A[y][x] == \"#\":\n\t\treturn True\n\treturn False\n\nfor _ in range(input()):\n\tif _ > 0: print\n\tH,W = map(int,raw_input().split())\n\tA = [list(raw_input()) for i in range(H)]\n\tfor h in range(H):\n\t\tfor w in range(W):\n\t\t\tif A[h][w] in \"^<v>\":\n\t\t\t\tx,y = w,h\n\t\t\t\td = A[h][w]\n\t\t\t\tA[h][w] = \".\"\n\tinput()\n\tcmd = raw_input()\n\tfor c in cmd:\n\t\tif   c == \"S\":\n\t\t\tif d == \"^\":\n\t\t\t\tfor h in range(y-1,-1,-1):\n\t\t\t\t\tif check(x,h): break\n\t\t\tif d == \"<\":\n\t\t\t\tfor w in range(x-1,-1,-1):\n\t\t\t\t\tif check(w,y): break\n\t\t\tif d == \"v\":\n\t\t\t\tfor h in range(y+1,H):\n\t\t\t\t\tif check(x,h): break\n\t\t\tif d == \">\":\n\t\t\t\tfor w in range(x+1,W):\n\t\t\t\t\tif check(w,y): break\n\t\telif c == \"U\":\n\t\t\td = \"^\"\n\t\t\tif y-1 >= 0 and A[y-1][x] == \".\": y = y-1\n\t\telif c == \"L\":\n\t\t\td = \"<\"\n\t\t\tif x-1 >= 0 and A[y][x-1] == \".\": x = x-1\n\t\telif c == \"D\":\n\t\t\td = \"v\"\n\t\t\tif y+1 <  H and A[y+1][x] == \".\": y = y+1\n\t\telif c == \"R\":\n\t\t\td = \">\"\n\t\t\tif x+1 <  W and A[y][x+1] == \".\": x = x+1\n\tA[y][x] = d\n\tfor h in range(H):\n\t\tprint \"\".join(A[h])"
  },
  {
    "language": "Python",
    "code": "dx = [-1, 0, 1, 0]\ndy = [0, -1, 0, 1]\ntanks = map(ord, \"<^>v\")\nflat = ord(\".\")\nbrick = ord(\"*\")\niron = ord(\"#\")\nwater = ord(\"-\")\n\ncase = input()\nfor t in xrange(case):\n    h, w = map(int, raw_input().split())\n    m = [map(ord, raw_input()) for i in xrange(h)]\n    n = input()\n    s = raw_input()\n    x, y = 0, 0\n    d = 0\n    for i in xrange(h):\n        for j in xrange(w):\n            if m[i][j] in tanks:\n                x = j\n                y = i\n                d = tanks.index(m[i][j])\n                m[i][j] = flat\n    for comm in s:\n        if comm==\"U\":\n            d = 1\n            if y>0 and m[y-1][x]==flat:\n                y -= 1\n        elif comm==\"D\":\n            d = 3\n            if y<h-1 and m[y+1][x]==flat:\n                y += 1\n        elif comm==\"L\":\n            d = 0\n            if x>0 and m[y][x-1]==flat:\n                x -= 1\n        elif comm==\"R\":\n            d = 2\n            if x<w-1 and m[y][x+1]==flat:\n                x += 1\n        else:\n            # \"S\"\n            nx = x + dx[d]\n            ny = y + dy[d]\n            while 0<=nx<=w-1 and 0<=ny<=h-1:\n                obj = m[ny][nx]\n                if obj==brick:\n                    m[ny][nx] = flat\n                    break\n                elif obj==iron:\n                    break\n                nx += dx[d]\n                ny += dy[d]\n    m[y][x] = tanks[d]\n    for i in xrange(h):\n        print \"\".join(map(chr, m[i]))\n    if t<case-1:\n        print"
  },
  {
    "language": "Python",
    "code": "def move(y, x):\n    p[2], p[3] = y, x\n    if a[p[0] + y][p[1] + x] == \".\":p[0] += y;p[1] += x\n\ndef shoot():\n    th = p[0] + p[2]\n    tw = p[1] + p[3]\n    while 1:\n        if a[th][tw] == \"*\":a[th][tw] = \".\";break\n        elif a[th][tw] == \"#\":break\n        else: th += p[2]; tw += p[3]\n\nfor _ in range(int(input())):\n    h, w = map(int, input().split())\n    a = [[\"#\"] * (w + 2)] + [[\"#\"] + list(input()) + [\"#\"] for _ in range(h)] + [[\"#\"] * (w + 2)]\n    for i in range(1, h + 1):\n        for j in range(1, w + 1):\n            if a[i][j] == \">\":p = [i, j, 0, 1];a[i][j] = \".\";break\n            elif a[i][j] == \"^\":p = [i, j, -1, 0];a[i][j] = \".\";break\n            elif a[i][j] == \"<\":p = [i, j, 0, -1];a[i][j] = \".\";break\n            elif a[i][j] == \"v\":p = [i, j, 1, 0];a[i][j] = \".\";break\n    n, c = int(input()), input()\n    for i in range(n):\n        if c[i] == \"U\":move(-1, 0)\n        elif c[i] == \"R\":move(0, 1)\n        elif c[i] == \"L\":move(0, -1)\n        elif c[i] == \"D\":move(1, 0)\n        else:shoot()\n    if (p[2], p[3]) == (0, 1):a[p[0]][p[1]] = \">\"\n    elif (p[2], p[3]) == (-1, 0):a[p[0]][p[1]] = \"^\"\n    elif (p[2], p[3]) == (0, -1):a[p[0]][p[1]] = \"<\"\n    else:a[p[0]][p[1]] = \"v\"\n    for i in a[1:-1]:print(\"\".join(i[1:-1]))\n    print()\n"
  }
]