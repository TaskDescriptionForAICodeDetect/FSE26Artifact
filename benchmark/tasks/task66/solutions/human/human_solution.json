[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n};\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\nint main() {\n\tvector<Point>vec; Point p; char c;\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tvec.clear();\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p.px >> c >> p.py;\n\t\t\tvec.push_back(p);\n\t\t}\n\t\tcout << n - convex_hull(vec).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS )\n\n// Point, Vector class\nclass Point {\npublic:\n  double x, y;\n\n  Point( double x = 0, double y = 0 ): x(x), y(y){}\n\n  Point operator + ( Point p ){ return Point( x + p.x, y + p.y ); }\n  Point operator - ( Point p ){ return Point( x - p.x, y - p.y ); }\n  Point operator * ( double k ){ return Point( x * k, y * k ); }\n\n  double abs() { return sqrt( norm() ); }\n  double norm() { return x * x + y * y; }\n\n  bool operator < ( const Point& p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == ( const Point& p ) const {\n    return fabs( x - p.x ) < EPS && fabs( y - p.y ) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// Segment\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\n\ndouble norm( Point p ) {\n  return p.x * p.x + p.y * p.y;\n}\n\ndouble abs( Point p ) {\n  return sqrt( norm( p ) );\n}\n\ndouble dot( Vector a, Vector b ) {\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross( Vector a, Vector b ) {\n  return a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal( Vector a, Vector b ) {\n  return equals( dot(a, b), 0.0 );\n}\n\nbool isOrthogonal( Point a1, Point a2, Point b1, Point b2 ) {\n  return isOrthogonal( a1 - a2, b1 - b2 );\n}\n\nbool isOrthogonal( Segment s1, Segment s2 ) {\n  return equals( dot( s1.p2 - s1.p1, s2.p2 - s2.p1 ), 0.0 );\n}\n\nbool isParallel( Vector a, Vector b ) {\n  return equals( cross( a, b ), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2 ) {\n  return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ) {\n  return equals( cross( s1.p2-s1.p1, s2.p2 - s2.p1 ), 0.0 );\n}\n\nPoint project( Segment s, Point p ) {\n  Vector base = s.p2 - s.p1;\n  double t = dot( p - s.p1, base ) / base.norm();\n  return s.p1 + base * t;\n}\n\nPoint reflect( Segment s, Point p ) {\n  return p + ( project( s, p ) - p ) * 2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if ( cross( a, b ) > EPS ) return COUNTER_CLOCKWISE;\n  if ( cross( a, b ) < -EPS ) return CLOCKWISE;\n  if ( dot( a, b ) < -EPS ) return ONLINE_BACK;\n  if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect( Point p1, Point p2, Point p3, Point p4 ) {\n  return ( ccw( p1, p2, p3 ) * ccw( p1, p2, p4 ) <= 0 &&\n\t   ccw( p3, p4, p1 ) * ccw( p3, p4, p2 ) <= 0 );\n}\n\nbool isIntersect( Segment s1, Segment s2 ) {\n  return isIntersect( s1.p1, s1.p2, s2.p1, s2.p2 );\n}\n\nPoint getCrossPoint( Segment s1, Segment s2 ) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs( cross( base, s1.p1 - s2.p1 ) );\n  double d2 = abs( cross( base, s1.p2 - s2.p1 ) );\n  double t = d1 / ( d1 + d2 );\n  return s1.p1 + ( s1.p2 - s1.p1 ) * t;\n}\n\ndouble getDistance( Point a, Point b ) {\n  Point c = a - b;\n  return c.abs();\n}\n\ndouble getDistanceLP( Line s, Point p ) {\n  return abs( cross( s.p2 - s.p1, p - s.p1 ) / abs( s.p2 - s.p1 ) );\n}\n\ndouble getDistanceSP( Segment s, Point p ) {\n  Point c1 = p - s.p1;\n  Point c2 = p - s.p2;\n  if ( dot( s.p2 - s.p1, p - s.p1 ) < 0.0 ) return c1.abs();\n  if ( dot( s.p1 - s.p2, p - s.p2 ) < 0.0 ) return c2.abs();\n  return getDistanceLP( s, p );\n}\n\ndouble getDistance( Segment s1, Segment s2 ) {\n  if ( isIntersect( s1, s2 ) ) return 0.0;\n  return min( min( getDistanceSP( s1, s2.p1 ), getDistanceSP( s1, s2.p2 ) ),\n\t      min( getDistanceSP( s2, s1.p1 ), getDistanceSP( s2, s1.p2 ) ));\n}\n\nint main() {\n    string line;\n    while ( getline( cin, line ) ) {\n        istringstream isn( line );\n        int n;\n        isn >> n;\n        if ( n == 0 ) break;\n        Point P[101];\n        double L[101];\n        for ( int i = 0; i < n; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            istringstream is( line );\n            double x, y;\n            is >> x >> y;\n            P[i].x = x + 1005.0;\n            P[i].y = y + 1005.0;\n            L[i] = P[i].abs();\n        }\n        for ( int i = 0; i+1 < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( L[i] > L[j] ) {\n                    swap( P[i], P[j] );\n                    swap( L[i], L[j] );\n                }\n            }\n        }\n\n        int s = 0, t = n-1;\n        int answer = 0;\n        bool used[101];\n        for ( int i = 0; i < n; i++ ) used[i] = false;\n        used[s] = used[t] = true;\n\n        for ( int i = 0; i < n; i++ ) {\n            if ( used[i] ) continue;\n            for ( int j = 0; j < n; j++ ) {\n                if ( used[j] ) continue;\n                Vector a( P[s] - P[j] );\n                Vector b( P[i] - P[j] );\n                Vector c( P[t] - P[j] );\n                if ( ( cross( a, b ) > 0 && cross( b, c ) > 0 && cross( c, a ) > 0 ) ||\n                     ( cross( a, b ) < 0 && cross( b, c ) < 0 && cross( c, a ) < 0 ) ) {\n                    answer++;\n                    used[j] = true;\n                }\n            }\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void){\n\tint n;\n\tdouble v[101][2];\n\tdouble s[2];\n\tint ans;\n\n\ts[0] = 100000;\n\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tans = n;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%lf,%lf\", &v[i][0], &v[i][1]);\n\t\t\tif(s[0] > v[i][0]){\n\t\t\t\ts[0] = v[i][0];\n\t\t\t\ts[1] = v[i][1];\n\t\t\t}\n\t\t}\n\n\t\tdouble t[2];\n\t\tt[0] = s[0];\n\t\tt[1] = s[1];\n\t\tdouble next[2];\n\t\tdouble bias = -M_PI/2.0;\n\t\tdouble min;\n\t\tdo{\n\t\t\tmin = 2*M_PI;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(v[i][0] == -10000 || v[i][1] == -10000) continue;\n\t\t\t\tdouble theta = atan((t[1] - v[i][1]) / (t[0] - v[i][0]));\n\t\t\t\tif(t[0] > v[i][0]) theta += M_PI;\n\t\t\t\tif(bias <= theta && min > theta){\n\t\t\t\t\tmin = theta;\n\t\t\t\t\tnext[0] = v[i][0];\n\t\t\t\t\tnext[1] = v[i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans--;\n\t\t\tt[0] = next[0];\n\t\t\tt[1] = next[1];\n\t\t\tbias = min;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(v[i][0] == t[0] && v[i][1] == t[1]){\n\t\t\t\t\tv[i][0] = -10000;\n\t\t\t\t\tv[i][1] = -10000;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(t[0] != s[0] || t[1] != s[1]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <sstream>\n#include <istream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define vci vector<int>\n#define vcs vector<string>\n#define pb push_back\n#define sz size()\n#define mapii map<int, int>\n#define mapci map<char, int>\n#define mapsi map<string, int>\n#define all(x) x.begin(), x.end()\n#define minit(a, i) memset(a, i, sizeof(a));\n\n#define for_(i, a, b) for (int i=(int)a; i<(int)b; i++)\n#define for_d(i, a, b) for (int i=(int)a-1; i>=b; i--)\n#define for_r(i, a, b, c) for (int i=(int)a; i<(int)b; i += c)\n#define for_dr(i, a, b, c) for (int i=(int)a-1; i>=b; i -= c)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long ll;\ntypedef double D;\n\nconst int iINF = 2147483647;\nconst ll lINF = 9223372036854775807;\n\ntemplate <class T> inline void dbg(T t) { cout << t << endl; }\n\n\n\n// define eps\ndouble EPS = 1e-10;\n\nstruct Point2D { \n\tdouble x, y;\n\tPoint2D (double a=0, double b=0) : x(a), y(b) {}\n};\ntypedef Point2D Vector2D;\n\n// Point2D's and Vector2D's operator\nPoint2D operator + (Point2D a, Point2D b) { return Point2D(a.x + b.x, a.y + b.y); }\nPoint2D operator - (Point2D a, Point2D b) { return Point2D(a.x - b.x, a.y - b.y); }\nPoint2D operator * (Point2D a, double d) { return Point2D(a.x * d, a.y * d); }\nPoint2D operator / (Point2D a, double d) { return Point2D(a.x / d, a.y / d); }\n\nbool operator < (const Point2D& a, const Point2D& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool operator > (const Point2D& a, const Point2D& b) { return b.x != a.x ? b.x < a.x : b.y < a.y; }\nbool operator == (const Point2D& a, const Point2D& b) { return fabs(a.x-b.x)<EPS && fabs(a.y-b.y)<EPS; }\n\ndouble norm(Point2D a) { return a.x*a.x + a.y*a.y; }\ndouble dot2D(const Vector2D& a, const Vector2D& b) { return a.x * b.x + a.y * b.y; }\ndouble cross2D(const Vector2D& a, const Vector2D& b) { return a.x*b.y - a.y*b.x; }\n\n// 点の進行方向\ta -> b -> c\nint ccw(Point2D a, Point2D b, Point2D c) {\n\tb = b - a; c = c - a;\n\tif (cross2D(b, c) > 0) return +1;\t// counter clockwise\n\tif (cross2D(b, c) < 0) return -1;\t// clockwise\n\tif (dot2D(b, c) < 0) return +2;\t\t// c--a--b on line\n\tif (norm(b) < norm(c)) return -2;\t// a--b--c on line\n\treturn 0;\t// \n}\n\nvector<Point2D> convexHull(vector<Point2D> ps) {\n\tint n = (int)ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<Point2D> ch(2*n);\t\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\t// upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\tch.resize(k-1);\n\treturn ch;\n}\n\n\nint main() {\n\tint n;\n\t\n\twhile (cin>>n) {\n\t\tif (n==0) break;\n\t\n\t\tvector<Point2D> ps(n);\n\t\n\t\tfor_(i, 0, n) {\n\t\t\tD x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tps[i].x = x; ps[i].y = y;\n\t\t}\n\t\n\t\tvector<Point2D> ch = convexHull(ps);\n\t\tint k = (int)ch.sz;\n\t\n\t\tcout << n - k << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double PI = 3.14159;\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tvector<double> x; x.reserve(100);\n\t\tvector<double> y; y.reserve(100);\n\t\tdouble tmp_x, tmp_y;\n\t\tchar dummy;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tcin >> tmp_x >> dummy >> tmp_y;\n\t\t\tx.push_back(tmp_x); y.push_back(tmp_y);\n\t\t}\n\t\t\n\t\tdouble min_y = y[0];\n\t\tint min_y_index = 0;\n\t\tfor (int i=1; i<n; i++) {\n\t\t\tif (min_y > y[i]) { min_y = y[i]; min_y_index = i; }\n\t\t}\n\t\t\n\t\tint curr_index = min_y_index;\n\t\tint circumference_points = 0;\n\t\tdouble curr_deg = 0.0;\n\t\tdo {\n\t\t\tdouble min_deg = PI;\n\t\t\tdouble min_deg_index;\n\t\t\tdouble tmp_deg;\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tif (i == curr_index) continue;\n\t\t\t\ttmp_deg = atan2( y[i] - y[curr_index], x[i] - x[curr_index] );\n\t\t\t\ttmp_deg -= curr_deg;cout << min_deg_index << \" \" <<\n\t\t\t\tif (tmp_deg < 0) tmp_deg += 2*PI;\n\t\t\t\tif (min_deg > tmp_deg) {\n\t\t\t\t\tmin_deg = tmp_deg; min_deg_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr_deg += min_deg;\n\t\t\tcurr_index = min_deg_index;\n\t\t\tcircumference_points++;\n\t\t\t// cout << min_deg_index << \" \" << curr_deg * 180 / PI << endl;\n\t\t} while (curr_index != min_y_index);\n\t\t\n\t\tcout << n - circumference_points << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n// ------ Main ------ //\nint n; vector<Point> v;\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tv.resize(n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%Lf,%Lf\", &v[i].px, &v[i].py);\n\t\tprintf(\"%d\\n\", n - (int)convex_hull(v).size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>d>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.c < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG g(n);\n\t\tPIN(&g[0],n);\n\t\tG tmp=convex_hull(g);\n\t\tcout<<n-tmp.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n\nint main() {\n\tint n;\n\n\twhile(cin >> n, n) {\n\t\tvector<pair<double,double> > v;\n\t\tvector<pair<double,double> > a;\n\t\tpair<double,double> prev;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpair<double,double> tmp;\n\n\t\t\tscanf(\"%lf,%lf\", &tmp.first, &tmp.second);\n\t\t\tv.push_back(tmp);\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\t\ta.push_back(v[0]);\n\t\tprev.first = 0;\n\t\tprev.second = 1;\n\n\t\tdo {\n\t\t\tdouble theta = 10;\n\t\t\tint next_v = -1;\n\t\t\tpair<double,double> next_prev;\n\n\t\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\t\tpair<double,double> tmp;\n\t\t\t\tdouble tmp_cos;\n\t\t\t\tdouble tmp_theta;\n\n\t\t\t\ttmp.first = v[i].first - a[a.size() - 1].first;\n\t\t\t\ttmp.second = v[i].second - a[a.size() - 1].second;\n\n\t\t\t\tif(tmp.first == 0 && tmp.second == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmp_cos = (prev.first * tmp.first + prev.second * tmp.second) / (sqrt(sqr(prev.first) + sqr(prev.second)) * sqrt(sqr(tmp.first) + sqr(tmp.second)));\n\t\t\t\ttmp_theta = acos(tmp_cos);\n\n\t\t\t\tif(tmp_theta < theta) {\n\t\t\t\t\ttheta = tmp_theta;\n\t\t\t\t\tnext_v = i;\n\t\t\t\t\tnext_prev = tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert(next_v >= 0);\n\t\t\ta.push_back(v[next_v]);\n\t\t\tprev = next_prev;\n\t\t} while(a[0] != a[a.size() - 1]);\n\n\t\tcout << v.size() - a.size() + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<stack>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\n\n/*\nnamespace std{\n\tbool operator<(const P &a, const P &b){return a.X==b.X ? a.Y<b.Y : a.X<b.X;}\n}*/\nnamespace std{\n    bool operator<(const P &a, const P &b){\n        return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n    }\n}\n\ndouble cross(P a,P b){return a.X*b.Y-b.X*a.Y;}\nbool ccw(P a,P b,P c){return cross(b-a,c-a)>=0;}\nvector<P> convex_VP(vector<P> ps) {\n    int n = ps.size(), k = 0;\n     \n    if (n <= 1) return ps;\n     \n    sort(ps.begin(),ps.end());\n    vector<P> qs(n * 2);\n    for (int i = 0; i < n; qs[k++] = ps[i++]) {\n        while (k > 1 && !ccw(qs[k-2],qs[k-1],ps[i])) k--;\n    }\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--]) {\n        while (k > t && !ccw(qs[k-2],qs[k-1],ps[i])) k--;\n    }\n     \n    vector<P> res(qs.begin(), qs.begin() + k - 1);\n    return res;\n}\nint main(){\n\t\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\tvector<P> p;\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tp.push_back(P(a,b));\n\t\t}\n\t\t\n\t\tvector<P> convex = convex_VP(p);\n\t\t/*\n\t\trep(i,convex.size()){\n\t\t\tprintf(\"%lf %lf\\n\",convex[i].X,convex[i].Y);\n\t\t}*/\n\t\tcout<<(int)p.size()-(int)convex.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nconst double PI = 3.1415926535;\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\nint main(){\n    int n;\n    double x[100], y[100];\n    while( scanf(\"%d\", &n), n ){\n        double cx = 10000, cy = 10000;\n        int mem = 0;\n        for(int i = 0; i < n; i++){\n            scanf(\"%lf,%lf\", x+i, y+i);\n            if( x[i] < cx ){\n                cx = x[i]; cy = y[i];\n                mem = i;\n            }\n        }\n        vector<bool> used(100, false);\n        used[mem] = true;\n        double cang = atan2(1, 0);\n        double lv;\n        int ln = mem;\n        int i;\n        for(i = 0; i < n; i++){\n            lv = 100;\n            int can = ln;\n            for(int j = 0; j < n; j++){\n                if( ln == j ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ){\n                    lv = ang; can = j;\n                }\n            }\n            ln = can;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            if( used[ln] ) break;\n            used[ln] = true;\n        }\n        printf(\"%d\\n\", n-i-1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\ndouble EPS = 1e-7;\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n};\ndouble dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\nistream& operator>>(istream& is, Point& p) { char c; return is >> p.x >> c >> p.y; }\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n    if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\n/* 与えら れた点集合の凸包をかえす.\n * psは3つ以上の要素を持たねばならない. */\nbool operator<(const Point& a, const Point& b) { return a.x < b.x; }\nvoid convexHull(vector<Point> ps, vector<Point>& ans) {\n    sort(ps.begin(), ps.end());\n    int N = ps.size();\n    int k = 0;\n    ans.resize(N * 2);\n    for (int i = 0; i < N; ans[k++] = ps[i++])\n        while (k >= 2 && ccw(ans[k - 2], ans[k - 1], ps[i]) <= 0) k--;\n    for (int i = N - 2, t = k + 1; i >= 0; ans[k++] = ps[i--])\n        while (k >= t && ccw(ans[k - 2], ans[k - 1], ps[i]) <= 0) k--;\n    /* 返上の点も頂点としたい場合は上4行を\n     *     for (int i = 0; i < N; ans[k++] = ps[i++])\n     *         while (k >= 2 && ccw(ans[k - 2], ans[k - 1], ps[i]) == -1) k--;\n     *     for (int i = N - 2, t = k + 1; i >= 0; ans[k++] = ps[i--])\n     *         while (k >= t && ccw(ans[k - 2], ans[k - 1], ps[i]) == -1) k--;\n     * にする. */\n    ans.resize(k - 1);\n}\n\nint main() {\n    while (true) {\n        int N; cin >> N;\n        if (N == 0) break;\n        vector<Point> ps(N);\n        for (int i = 0; i < N; i++) {\n            cin >> ps[i];\n        }\n        vector<Point> hull;\n        convexHull(ps, hull);\n        cout << N - hull.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<complex>\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ALL( c ) (c).begin(), (c).end()\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 )\n\t{\n\t\treturn;\n\t}\n\n\tPoint( double x, double y ) : x( x ), y( y )\n\t{\n\t\treturn;\n\t}\n\n\tPoint operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x - a.x, y - a.y );\n\t}\n\n\tPoint operator * ( const double &a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint operator / ( const double &a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n};\n\n// ??????\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// Graham Scan\nvector< Point > getConvex( vector< Point > ps )\n{\n\tconst int N = ps.size();\n\n\tsort( ALL( ps ) );\n\n\tint k = 0;\n\tvector< Point > convex( N * 2 );\n\n\tfor ( int i = 0; i < N; i++ )\n\t{\n\t\twhile ( 2 <= k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tfor ( int i = N - 2, t = k; 0 <= i; i-- )\n\t{\n\t\twhile ( t < k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.resize( k - 1 );\n\n\treturn convex;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< Point > ps( n );\n\n\t\tEACH( p, ps )\n\t\t{\n\t\t\tchar d;\n\n\t\t\tcin >> p.x >> d >> p.y;\n\t\t}\n\n\t\tvector< Point > convex = getConvex( ps );\n\n\t\tcout << n - convex.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <climits>\n#include <cmath>\n\n#define EPS (1e-10)\n#define PI (acos(-1.0))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nusing namespace std;\ntypedef complex<double> P;\n\ndouble ccw(P& p1, P& p2, P& p3)\n{\n\treturn ((p2.real() - p1.real())*(p3.imag() - p1.imag()) \n\t\t\t\t- (p2.imag() - p1.imag())*(p3.real() - p1.real())) > 0;\n}// ccw>0 => ccw, ccw=0 => colinear, ccw<0, cw\n\nbool complex_pred(const P& a, const P& b)\n{\n    if (a.real() != b.real())\n\t\treturn a.real() < b.real();\n\telse\n\t\treturn a.imag() < b.imag();\n}\n\nvector<P> solve(vector<P>& vc)\n{\n\tsort(vc.begin(), vc.end(), complex_pred);\n\n\tint k = 0;\n\tvector<P> vc2(vc.size()*2);\n\t\n\tfor (int i = 0; i < (int)vc.size(); i++)\n\t{\n\t\twhile( k >= 2 && ccw(vc2[k-1], vc2[k-2], vc[i]) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\t\n\t\tvc2[k]=vc[i];\n\t\tk++;\n\t}\n\n\tint t = k;\n\t\n\tfor (int i = vc.size()-1; i >= 0; i--)\n\t{\n\t\twhile ( k > t && ccw(vc2[k-1], vc2[k-2], vc[i]) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\t\n\t\tvc2[k]=vc[i];\n\t\tk++;\n\t}\n\t\n\tvc2.resize(k-1);\n\treturn vc2;\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> vc;\n\t\tvc.clear();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tchar c;\n\t\t\tdouble a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> c;\n\t\t\tcin >> b;\n\t\t\tvc.push_back(P(a, b));\n\t\t}\n\t\t\n\t\tvector<P> vc2 = solve(vc);\n\t\tcout << int(n - vc2.size()) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define EPS (1e-10)\ntypedef complex<double> Po;\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() + x.imag()*y.real();}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,b-a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(int num){\n    int c = 0;\n    double max = 0;\n    Po a,b;\n    line l,s;\n    vector<int> tmp;\n\n    a = v[num];\n    for(int i=0;i<(int)v.size();i++){\n      if(i!=num){\n\tif(max < v[i].real())max = v[i].real();\n\tif(a.imag() == v[i].imag()){\n\t  tmp.push_back(1);\n\t  v[i].imag() += 1e-6;\n\t}else tmp.push_back(0);\n      }\n    }\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size();i++){\n      if(i+1==num){\n\tl.set(v[i],v[(i+2)%v.size()]);\n      }else if(i==num){\n\tif(!i)l.set(v[(int)v.size()-1],v[(i+1)%v.size()]);\n\telse l.set(v[i-1],v[(i+1)%v.size()]);\n      }else{\n\tl.set(v[i],v[(i+1)%v.size()]);\n      }\n      if(s.is_cross(l))c++;\n    }\n    for(int i=0;i<(int)v.size();i++){\n      if(tmp[i])v[i].imag() -= 1e-6;\n    }\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(void){\n  int n;\n  int ans;\n  Po p;\n  polygon poly;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    poly.set();\n    for(int i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&p.real(),&p.imag());\n      poly.Vadd(p);\n    }\n    poly.sort();\n\n    ans = 0;\n    for(int i=0;i<n;i++){\n      if(poly.inter(i))ans++;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\ntypedef double D;\nconst D EPS = 1e-8;\n\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\n\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\n\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\n\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD norm(P p) { return inp(p, p); }\nD abs(P p) { return sqrt(norm(p)); }\nP rot90(P p) { return P(-p.y, p.x); }\n\nP vec(P from, P to) { return to - from; }\n\nint ccw(P a, P b, P c) { // 重なっている点があるとうまく動かないと思われる\n  b = vec(a, b); c = vec(a, c);\n\n  // a - b - c が折れ曲がるとき\n  if(sig(outp(b, c),0.0) > 0) return +1; // 反時計回り\n  if(sig(outp(b, c),0.0) < 0) return -1; // 時計回り\n\n  // a - b - c が直線上に並ぶとき\n  // sigを使わない実装が主流っぽい？\n  if(sig(inp(b, c),0.0) < 0)   return +2; // c - a - b\n  if(sig(norm(b),norm(c)) < 0) return -2; // a - b - c\n  return 0;                               // a - c - b\n}\n\nbool operator <(P a, P b) {\n  if(sig(a.x, b.x) != 0) return a.x < b.x;\n  return a.y < b.y;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int N = ps.size();\n  int k = 0; // 凸包を構成する点の数\n  sort(ps.begin(), ps.end());\n  vector<P> res(N * 2);\n  for(int i = 0; i < N; i++) {\n    // 時計回りの折れ曲がりがあったら、折れ点を削除\n    while(k >= 2 && ccw(res[k - 2], res[k - 1], ps[i]) <= 0) k--;\n    res[k++] = ps[i];\n  }\n  int t = k + 1;\n  // 右端は取らない (重複するから)\n  // 左端は取る (重複するけど、あとから取り除いたほうが楽)\n  for(int i = N - 2; i >= 0; i--) {\n    while(k >= t && ccw(res[k - 2], res[k - 1], ps[i]) <= 0) k--;\n    res[k++] = ps[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\n\nint main() {\n  for(int N; cin >> N, N; ) {\n    vector<P> ps(N);\n    for(int i = 0; i < N; ++i) {\n      string S; cin >> S;\n      for(int j = 0; j < (int)S.size(); ++j)\n        if(S[j] == ',') S[j] = ' ';\n      istringstream iss(S);\n      iss >> ps[i].x >> ps[i].y;\n    }\n    vector<P> qs = convex_hull(ps);\n    cout << ps.size() - qs.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<vector>\n#include<algorithm>\n\n#define pb push_back\n#define sz size()\nusing namespace std;\n\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\nvector<P> convex_hull(vector<P> v){\n  int n = v.sz;\n  sort(v.begin(),v.end());\n  vector<P> r;\n  for(int i=0;i<n;i++){\n    while(r.sz>1 && cross(r[r.sz-1]-r[r.sz-2],v[i]-r[r.sz-1]) <= 0)r.pop_back();\n    r.pb(v[i]);\n  }\n  for(int i=n-2,t=r.sz;i>=0;i--){\n    while(r.sz>t && cross(r[r.sz-1]-r[r.sz-2],v[i]-r[r.sz-1]) <= 0)r.pop_back();\n    r.pb(v[i]);\n  }\n  r.pop_back();\n  return r;\n}\n\nint main(){\n  int n;\n  vector<P> v;\n  P tmp;\n\n  while(scanf(\"%d\",&n),n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      scanf(\"%lf,%lf\",&real(tmp),&imag(tmp));\n      v.pb(tmp);\n    }\n\n    printf(\"%d\\n\",n-(int)convex_hull(v).sz);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\ntypedef double P_type;\ntypedef complex<P_type> P;\nconst P_type P_eps = 1e-10; //??´??°???????????????\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n};\n\nP rotate(P p, double theta){\n  return p * P(cos(theta), sin(theta));\n}\n\n//??????\ndouble dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//??????\ndouble cross(P a, P b) {\n  return (a * conj(b)).imag();\n}\n\n//???????¨???????\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > P_eps) return 1; //COUNTER_CLOCKWISE\n  if(cross(b-a,c-a) < -P_eps) return -1; //CLOCKWISE\n  if(dot(b-a,c-a) < P_eps) return -2; //c -> a -> b\n  if(dot(a-b,c-b) < P_eps) return 2; //a -> b -> c\n  return 0; //a -> c -> b\n}\n\n/* ??????ab??¨???c????????¢ */\ndouble distanceSP(P a, P b, P c) {\n  if ( dot(b-a, c-a) < P_eps ) return abs(c-a);\n  if ( dot(a-b, c-b) < P_eps ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* ??´???ab??¨???c????????¢ */\ndouble distanceLP(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* ????????????????????? */\ndouble isContainedCP(P c, double r, P p){\n  return abs(c-p) < r - P_eps; //?????¨??????????????????\n  //return abs(c-p) < r + P_eps; //?????¨????????????\n}\n\n/* ??´??????????????? */\nbool isIntersectedLL(P a1, P a2, P b1, P b2){\n  return abs(cross(a1-a2, b1-b2)) > P_eps;\n}\n\n/* ?????????????????? */\nbool isIntersectedSS(P a1, P a2, P b1, P b2){\n  \n  //??????a ??¨ ??´???b\n  P_type a = ccw(b1,b2,a1);\n  P_type b = ccw(b1,b2,a2);\n  \n  //??????b ??¨ ??´???a\n  P_type c = ccw(a1,a2,b1);\n  P_type d = ccw(a1,a2,b2);\n  \n  return a*b < P_eps && c*d < P_eps; // T?????????????????? -P_eps\n}\n\n/* ??????????????? */\nbool isIntersectedCC(P c1, double r1, P c2, double r2){\n  double dist = abs(c1 - c2);\n  \n  return abs(r1 - r2) < dist + P_eps && dist - P_eps < r1 + r2; //?????\\?????\\?????????\n  //return abs(r1 - r2) < dist - P_eps && dist + P_eps < r1 + r2; //?????\\?????\\?????????\n}\n\n/* ?????´??????????????? */\nbool isIntersectedCL(P c, double r, P a1, P a2){\n  return distanceLP(a1, a2, c) < r + P_eps; //??\\????????´????????????????????´??? - P_eps\n}\n\n/* ????????????????????? */\nbool isIntersectedCS(P c, double r, P a1, P a2){\n  return isContainedCP(c,r,a1) &&\n    isContainedCP(c,r,a2) &&\n    distanceLP(a1, a2, c) < r + P_eps; //??\\????????´????????????????????´??? - P_eps\n}\n\n/* ??´???/???????????? */\nP getCrosspointLL(P a1, P a2, P b1, P b2) {\n  //assert(isIntersectedLL(a1, a2, b1, b2));\n  //assert(isIntersectedSS(a1, a2, b1, b2));\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nP getCrosspointSS(P a1, P a2, P b1, P b2){\n  return getCrosspointLL(a1, a2, b1, b2);\n}\n\n/* ????????? */\npair<P,P> getCrosspointCC(P c1, double r1, P c2, double r2){\n  //assert(isIntersectedCC(c1, r1, c2, r2));\n  \n  double dist = abs(c1 - c2);\n  double a = acos((r1*r1 + dist * dist - r2 * r2) / (2 * r1 * dist));\n  return {c1 + polar(r1, arg(c2 - c1) + a), c1 + polar(r1, arg(c2 - c1) - a)};\n}\n\n/* ??????????????? */\npair<P,P> getCrosspointCS(P c, double r, P a1, P a2){\n  //assert(isIntersectedCS(c1, r1, c2, r2));\n  \n  P base1 = a2 - a1;\n  P proj = a1 + base1 * dot(c - a1, base1) / norm(base1); //?°???±\n  P e = (a2 - a1) / abs(a2 - a1);\n  P base2 = sqrt(r*r - norm(proj - c));\n  return {proj + e*base2, proj - e*base2};\n}\n\n/* ConvexHull(??????) */\n\nvector<P> ConvexHull(vector<P> s){\n  vector<P> g;\n  int n = (int)s.size();\n  \n  if(n<3) return s;\n  \n  sort(s.begin(),s.end());\n  \n  for(int i=0;i<n;i++){\n    for(int m = (int)g.size();m>=2 && ccw(g[m-2],g[m-1],s[i]) != -1; m--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  \n  int t = (int)g.size();\n  \n  for(int i=n-2;i>=0;i--){\n    for(int m = (int)g.size();m>t && ccw(g[m-2],g[m-1],s[i]) != -1; m--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  \n  reverse(g.begin(),g.end());\n  g.pop_back();\n  \n  return g;\n}\n\n\nbool solve(){\n  int n;\n  \n  scanf(\"%d\",&n);\n\n  if(n == 0) return false;\n\n  vector<P> points;\n  \n  for(int i=0;i<n;i++){\n    double x,y;\n\n    scanf(\"%lf,%lf\",&x,&y);\n    points.push_back(P(x,y));\n  }\n\n  auto edge = ConvexHull(points);\n\n  printf(\"%d\\n\",n - (int)edge.size());\n  \n  return true;\n}\n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\ntypedef long long ll;\nusing namespace std;\nstruct point_t { double x, y; };\nbool operator < (point_t const & a, point_t const & b) { return make_pair(a.x,a.y) < make_pair(b.x,b.y); }\npoint_t operator + (point_t const & a, point_t const & b) { return { a.x + b.x, a.y + b.y }; }\npoint_t operator - (point_t const & a, point_t const & b) { return { a.x - b.x, a.y - b.y }; }\ndouble cross(point_t const & a, point_t const & b) { return a.x * b.y - a.y * b.x; }\ndouble ccw(point_t const & a, point_t const & b, point_t const & c) { return cross(b - a, c - a); }\nvector<point_t> convex_hull(vector<point_t> ps) {\n    int n = ps.size();\n    sort(ps.begin(), ps.end());\n    vector<point_t> ch(2*n);\n    int k = 0;\n    for (int i = 0; i < n; ch[k++] = ps[i++]) { // lower hull\n        while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) -- k;\n    }\n    const int t = k+1;\n    for (int i = n-2; i >= 0; ch[k++] = ps[i--]) { // upper hull\n        while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) -- k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\nint solve(vector<point_t> const & ps) {\n    vector<point_t> qs = convex_hull(ps);\n    return ps.size() - qs.size();\n}\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<point_t> ps(n);\n        char dummy;\n        for (auto && p : ps) cin >> p.x >> dummy >> p.y;\n        cout << solve(ps) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ndouble torad(int deg) {return (double)(deg) * PI / 180;}\ndouble todeg(double ang) {return ang * 180 / PI;}\n\nstruct Point {\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (Point p, Point q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (Point p, Point q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (Point p, double a) {return Point(p.x * a, p.y * a);}\nPoint operator * (double a, Point p) {return Point(a * p.x, a * p.y);}\nPoint operator * (Point p, Point q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (Point p, double a) {return Point(p.x / a, p.y / a);}\nPoint conj(Point p) {return Point(p.x, -p.y);}\nPoint rot(Point p, double ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(Point p) {return Point(-p.y, p.x);}\ndouble cross(Point p, Point q) {return p.x * q.y - p.y * q.x;}\ndouble dot(Point p, Point q) {return p.x * q.x + p.y * q.y;}\ndouble norm(Point p) {return dot(p, p);}\ndouble abs(Point p) {return sqrt(dot(p, p));}\nbool eq(Point p, Point q) {return abs(p - q) < EPS;}\ndouble amp(Point p) {double res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\nbool operator < (Point p, Point q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\nbool operator > (Point p, Point q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\nPoint operator / (Point p, Point q) {return p * conj(q) / norm(q);}\n\n\n// 粗\n// 1：a-bから見てcは左側(反時計回り)、-1：a-bから見てcは右側(時計回り)、0：一直線上\n//int ccw(Point a, Point b, Point c) {\n//    if (cross(b-a, c-a) > EPS) return 1;\n//    if (cross(b-a, c-a) < -EPS) return -1;\n//    return 0;\n//}\n\n// 精\n// 1：a-bから見てcは左側(反時計回り)、-1：a-bから見てcは右側(時計回り)、2：c-a-bの順に一直線上、-2：a-b-cの順に一直線上、0：a-c-bの順に一直線上\nint ccw(Point a, Point b, Point c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (norm(b-a) < norm(c-a)) return -2;\n    return 0;\n}\n\n\nvector<Point> convexhull(vector<Point> ps) {\n    int n = ps.size();\n    vector<Point> res(2*n);\n    sort(ps.begin(), ps.end());\n    int k = 0;\n    for (int i = 0; i < n; res[k++] = ps[i++]) {\n        while (k >= 2 && ccw(res[k-2], res[k-1], ps[i]) <= 0) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; res[k++] = ps[i--]) {\n        while (k >= t && ccw(res[k-2], res[k-1], ps[i]) <= 0) --k;\n    }\n    res.resize(k-1);\n    return res;\n}\n    \n\nint main() {\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        \n        vector<Point> ps(n), ch;\n        for (int i = 0; i < n; ++i) {\n            double x, y;\n            scanf(\"%lf,%lf\", &x, &y);\n            ps[i] = Point(x, y);\n        }\n        ch = convexhull(ps);\n    \n        cout << n - ch.size() << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\nstruct Coordinate {\n\tlong double x;\n\tlong double y;\n\tbool operator <(const Coordinate& c)const {\n\t\tif (y < c.y)return true;\n\t\tif (y > c.y)return false;\n\t\tif (x < c.x)return true;\n\t\treturn false;\n\t}\n\tbool operator >(const Coordinate& c)const {\n\t\tif (y > c.y)return true;\n\t\tif (y < c.y)return false;\n\t\tif (x > c.x)return true;\n\t\treturn false;\n\t}\n\tCoordinate operator +(const Coordinate& c)const {\n\t\tCoordinate box;\n\t\tbox.x = x + c.x;\n\t\tbox.y = y + c.y;\n\t\treturn box;\n\t}\n\tCoordinate operator -(const Coordinate& c)const {\n\t\tCoordinate box;\n\t\tbox.x = x - c.x;\n\t\tbox.y = y - c.y;\n\t\treturn box;\n\t}\n\tlong double det(Coordinate a) {\n\t\treturn x*a.y - y*a.x;\n\t}\n};\n\nstruct Convex_hull {\n\tvector<Coordinate>node;\n\tvector<Coordinate>ret;\n\tbool line;\n\tConvex_hull(bool l) {\n\t\tline = l;\n\t}\n\tvoid Add_node(Coordinate n) {\n\t\tnode.push_back(n);\n\t}\n\tvector<Coordinate>solve() {\n\t\tsort(node.begin(), node.end());\n\t\tint index = 0;\n\t\tint num = node.size();\n\t\tret.resize(num * 2);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (line) {\n\t\t\t\twhile (index > 1 && (ret[index - 1] - ret[index - 2]).det(node[i] - ret[index - 1]) < -EPS) {\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (index > 1 && (ret[index - 1] - ret[index - 2]).det(node[i] - ret[index - 1]) < EPS) {\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret[index++] = node[i];\n\t\t}\n\t\tint box = index;\n\t\tfor (int i = num - 2; i >= 0; i--) {\n\t\t\tif (line) {\n\t\t\t\twhile (index > box && (ret[index - 1] - ret[index - 2]).det(node[i] - ret[index - 1]) < -EPS) {\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (index > box && (ret[index - 1] - ret[index - 2]).det(node[i] - ret[index - 1]) < EPS) {\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret[index++] = node[i];\n\t\t}\n\t\tret.resize(index - 1);\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tlist<int>ans;\n\twhile (N) {\n\t\tConvex_hull ch(true);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tCoordinate c;\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstring t = s;\n\t\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\t\tif (s[i] == ',') {\n\t\t\t\t\ts.resize(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(t.begin(), t.end());\n\t\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\t\tif (t[i] == ',') {\n\t\t\t\t\tt.resize(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(t.begin(), t.end());\n\t\t\tc.x = stold(s);\n\t\t\tc.y = stold(t);\n\t\t\tch.Add_node(c);\n\t\t}\n\t\tauto box = ch.solve();\n\t\tans.push_back(N - box.size());\n\t\tcin >> N;\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=1){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p){\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\t\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i), 0) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i), 0) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(scanf(\"%d\", &n), n){\n\t\tG g;\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tscanf(\"%lf,%lf\", &p.X, &p.Y);\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcout << g.size() - g.convex_hull(true).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n   \nusing namespace std;\n   \ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef multimap<double,int> MDI;\ntypedef MDI::iterator MDII;\n   \n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n   \n   \nint main(){\n   \n    int n;\n    int main,st;\n    int num;\n    double x,y;\n    double ax,ay,bx,by,cx,cy;\n    double ans;\n\tdouble sita;\n    char gav;\n\tdouble bef;\n    VPBB pin;\n    MDI point;\n    MDII ite;\n \n    while(1){\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>gav>>y;\n\t\t\tpin.PUSH(PBB(x,y));\n\t\t}\n \n\t\tmain=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(pin[main].second<pin[i].second) main=i;\n\t\t\telse if(pin[main].second==pin[i].second&&pin[main].first<pin[i].first) main=i;\n\t\t}\n\t\tst=main;\n\t\tnum=0;\n\t\tbef=-1*PI;\n\t\twhile(1){\n\t\t\t///cout<<num<<\"\\\\\\\\\"<<main<<endl;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(pin[i].second!=pin[main].second) sita=atan2(pin[i].second-pin[main].second,pin[i].first-pin[main].first);\n\t\t\t\telse sita=-1*PI;\n\t\t\t\tif(i!=main&&sita>bef){\n\t\t\t\t\t///cout<<sita<<\"---\"<<i<<endl;\n\t\t\t\t\tpoint.insert(MDIVT(sita,i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tite=point.begin();\n\t\t\tbef=(*ite).first;\n\t\t\tmain=(*ite).second;\n\t\t\tpoint.clear();\n\t\t\tnum++;\n\t\t\tif(main==st) break;\n\t\t}\n\t\tcout<<n-num<<endl;\n\t\tpin.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator==(const Point &p)const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\t//Vector????????¢\n\tPoint rotate(double rad) { return Point(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nusing Vector = Point;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point(1, 1)) :p1(p1), p2(p2) {}\n\tVector vec() { return p2 - p1; }\n};\nusing Line = Segment;\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance_LP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance_SP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance_LP(s, p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance_SP(s1, s2.p1), get_distance_SP(s1, s2.p2)),\n\t\tmin(get_distance_SP(s2, s1.p1), get_distance_SP(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance_LP(l, c.c) <= c.r; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point getCrossPointLL(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//Graham scan\n//https://en.wikipedia.org/wiki/Graham_scan\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) > 0)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) < 0)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);//???????¨??????????\n\treturn down;\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tPolygon P(n);\n\t\tchar c;\n\t\trep(i, 0, n) cin >> P[i].x >> c >> P[i].y;\n\t\tPolygon CH = convex_hull(P);\n\t\tdumpc(CH);\n\t\tcout << (n - CH.size()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nint main(){\n\tfor(;;){\n\t\tint n;\n\t\tcin >>n;\n\t\tif(!n){break;}\n\t\tdouble pin[100][2] = {0},min_x =  10000;\n\t\tint rubber[2] = {0};\n\t\tbool done[100] = {false};\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%lf,%lf\",&pin[i][0],&pin[i][1]);\n\t\t\tif(min_x>pin[i][0]){min_x = pin[i][0];rubber[0] = i;}\n\t\t}\n\t\trubber[1] = rubber[0];\n\t\tfor(;;){\n\t\t\tint now,j;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(!done[i] && i!=rubber[1]){\n\t\t\t\t\tdouble ax = pin[i][0]-pin[rubber[1]][0];\n\t\t\t\t\tdouble ay = pin[i][1]-pin[rubber[1]][1];\n\t\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\t\tif(!done[j]){\n\t\t\t\t\t\t\tdouble bx = pin[j][0]-pin[rubber[1]][0];\n\t\t\t\t\t\t\tdouble by = pin[j][1]-pin[rubber[1]][1];\n\t\t\t\t\t\t\tif(ax*by-ay*bx<0){break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j == n){now = i;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone[now] = true;\n\t\t\trubber[1] = now;\n\t\t\tif(rubber[1] == rubber[0]){break;}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=0; i<n; i++){if(!done[i]){sum++;}}\n\t\tcout <<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define for1(i, n) for(int i = 1; i <= (n);i++)\n#define mp make_pair\n#define all(x) x.begin(),x.end()\nusing namespace std;\ndouble x, y;\nvector<pair<double, double>>v1;\nvector<pair<double, pair<double, double>>>v2;\nstack<pair<double, double>>st;\nvoid input() {\n\tstring s; cin >> s;\n\tdouble k = 1, r[3];\n\tr[0] = 0; r[1] = 0;\n\ts += ',';int c = 0;\n\tbool b = 0;\n\tint sign = 1;\n\tfor (char ch : s) {\n\t\tif (ch == ',') {\n\t\t\tr[c++] *= sign;\n\t\t\tb = 0; k = 1; sign = 1;\n\t\t}\n\t\telse if (ch == '.')b = 1;\n\t\telse if (ch == '-')sign = -1;\n\t\telse if (b) {\n\t\t\tk /= 10;\n\t\t\tr[c] += k * (ch - '0');\n\t\t}\n\t\telse {\n\t\t\tr[c] *= 10; r[c] += ch - '0';\n\t\t}\n\t}\n\tx = r[0]; y = r[1]; return;\n}\nsigned main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tfor0(i, n) { input(); v1.push_back(mp(x, y)); }\n\t\tsort(all(v1));\n\t\tfor1(i, n - 1) {\n\t\t\tv1[i].first -= v1[0].first;\n\t\t\tv1[i].second -= v1[0].second;\n\t\t}\n\t\tv1[0] = mp(0, 0);\n\t\tfor1(i, n - 1) {\n\t\t\tx = v1[i].first; y = v1[i].second;\n\t\t\tv2.push_back(mp(asin(y / sqrt(x * x + y * y)), v1[i]));\n\t\t}\n\t\tsort(all(v2));\n\t\tst.push(mp(0, 0));\n\t\tfor0(i, n - 1) {\n\t\t\tif (st.size() <= 1)st.push(v2[i].second);\n\t\t\telse {\n\t\t\t\tx = v2[i].second.first; y = v2[i].second.second;\n\t\t\t\tdouble x2 = st.top().first, y2 = st.top().second; st.pop();\n\t\t\t\tdouble x1 = st.top().first, y1 = st.top().second; st.pop();\n\t\t\t\twhile ((x - x1) * (y1 - y2) <= (y - y1) * (x1 - x2) && st.size()) {\n\t\t\t\t\tx2 = x1; y2 = y1;\n\t\t\t\t\tx1 = st.top().first, y1 = st.top().second; st.pop();\n\t\t\t\t}\n\t\t\t\tst.push(mp(x1, y1));\n\t\t\t\tst.push(mp(x2, y2));\n\t\t\t\tst.push(mp(x, y));\n\t\t\t}\n\t\t}\n\t\tcout << n - st.size() << endl;\n\t\tv1.clear(); v2.clear(); while (st.size())st.pop();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos(-1);\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    double cr = cross(b-a, c-a);\n    if (cr > EPS) return 1;\n    if (cr < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (dot(a-b, c-b) < -EPS) return -2;\n    return 0;\n}\n\ntypedef vector<P> Pol;\n\nPol convex(Pol p) {\n    sort(p.begin(), p.end());\n    if (p.size() <= 2) return p;\n    Pol up;\n    for (P d: p) {\n        while (up.size() > 1 && ccw(up[up.size()-2], up[up.size()-1], d) > 0) up.pop_back();\n        up.push_back(d);\n    }\n    reverse(up.begin(), up.end());\n    Pol down;\n    for (P d: p) {\n        while (down.size() > 1 && ccw(down[down.size()-2], down[down.size()-1], d) < 0) down.pop_back();\n        down.push_back(d);\n    }\n    down.insert(down.begin(), up.begin()+1, up.end()-1);\n    return down;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    Pol p;\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p.push_back(P(x, y));\n    }\n    cout << n-convex(p).size() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <cmath>\n#include <stdio.h>\n\nusing namespace std;\n\n//-------------------------------------------------------------------------\n// geometric library\n\nnamespace geometry {\n\n#define EPS 1E-10 ///< 0とみなすサイズ。適当\n\n\tstruct point {\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpoint& operator += (const point& rhs) { x += rhs.x; y += rhs.y; return *this; }\n\t\tpoint& operator -= (const point& rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n\t\tpoint& operator /= (double factor) { x /= factor; y /= factor; return *this; }\n\t\tpoint& operator *= (double factor) { x *= factor; y *= factor; return *this; }\n\t\tbool operator == (const point& rhs) const { return (std::abs(x - rhs.x) < EPS) && (std::abs(y - rhs.y) < EPS); }\n\t\tbool operator != (const point& rhs) const { return !(*this == rhs); }\n\t\tbool operator <= (const point& rhs) const { return x < rhs.x || (x == rhs.x && y <= rhs.y); }\n\t\tbool operator >= (const point& rhs) const { return x > rhs.x || (x == rhs.x && y >= rhs.y); }\n\t\tbool operator < (const point& rhs) const { return !(*this >= rhs); }\n\t\tbool operator > (const point& rhs) const { return !(*this <= rhs); }\n\t};\n\n\tstruct circle {\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct line {\n\t\t// ax + by + c = 0\n\t\tdouble a;\n\t\tdouble b;\n\t\tdouble c;\n\t};\n\n\tenum rotate_dir {\n\t\trotate_None = 0,\n\t\trotate_CW = 1,\n\t\trotate_CCW = -1\n\t};\n\n\tpoint operator + (const point& p1, const point& p2)\n\t{\n\t\tpoint p(p1);\n\t\tp += p2;\n\t\treturn p;\n\t}\n\n\tpoint operator / (const point& p1, double factor)\n\t{\n\t\tpoint p(p1);\n\t\tp /= factor;\n\t\treturn p;\n\t}\n\n\tpoint operator - (const point& p1, const point& p2)\n\t{\n\t\tpoint p(p1);\n\t\tp -= p2;\n\t\treturn p;\n\t}\n\n\tstd::istream& operator >> (std::istream& is, point& p)\n\t{\n\t\tis >> p.x >> p.y;\n\t\treturn is;\n\t}\n\n\t///! 2点の距離\n\tdouble get_distance(const point& p1, const point& p2)\n\t{\n\t\treturn sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n\t}\n\n\t///! 2直線の交点\n\tbool get_crosspoint(const line& l1, const line& l2, point *result)\n\t{\n\t\tdouble denominator = l1.a * l2.b - l1.b * l2.a;\n\t\tif (std::abs(denominator) < EPS) {\n\t\t\treturn false;\n\t\t}\n\t\tresult->x = (l1.b * l2.c - l2.b * l1.c) / denominator;\n\t\tresult->y = (l2.a * l1.c - l1.a * l2.c) / denominator;\n\t\treturn true;\n\t}\n\n\t///! 2点の垂直2等分線\n\tbool get_bisector(const point& p1, const point& p2, line *result)\n\t{\n\t\tif (p1 == p2) {\n\t\t\treturn false;\n\t\t}\n\t\tresult->a = 2 * (p1.x - p2.x);\n\t\tresult->b = 2 * (p1.y - p2.y);\n\t\tresult->c = -(p1.y - p2.y) * (p1.y + p2.y) - (p1.x - p2.x) * (p1.x + p2.x);\n\t\treturn true;\n\t}\n\n\tbool get_line(const point& p1, const point& p2, line *result)\n\t{\n\t\tif (p1 == p2) {\n\t\t\treturn false;\n\t\t}\n\t\tresult->a = p2.y - p1.y;\n\t\tresult->b = p1.x - p2.x;\n\t\tresult->c = p1.y * p2.x - p1.x * p2.y;\n\t\treturn true;\n\t}\n\n\t///! 外接円を求める\n\tbool get_circum_circle(const point& p1, const point& p2, const point& p3, circle *result)\n\t{\n\t\tdouble a = get_distance(p1, p2);\n\t\tdouble b = get_distance(p2, p3);\n\t\tdouble c = get_distance(p3, p1);\n\n\t\t// 半径の公式\n\t\tresult->radius = a * b * c / sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));\n\n\t\tline line_p1p2;\n\t\tline line_p2p3;\n\n\t\t// 頂点の垂直2等分線の交点が外心\n\t\treturn get_bisector(p1, p2, &line_p1p2) &&\n\t\t\tget_bisector(p2, p3, &line_p2p3) &&\n\t\t\tget_crosspoint(line_p1p2, line_p2p3, &result->center);\n\t}\n\n\tdouble cross_product(const point& p1, const point& p2)\n\t{\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tdouble inner_product(const point& p1, const point& p2)\n\t{\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\t///! p1-p2-p3が左右どちらの方向に折れているかを判定\n\trotate_dir direction(const point& p1, const point& p2, const point& p3)\n\t{\n\t\tpoint p1_p3 = p1 - p3;\n\t\tpoint p2_p3 = p2 - p3;\n\t\tdouble cross = cross_product(p1_p3, p2_p3);\n\n\t\tif (std::abs(cross) < EPS) {\n\t\t\treturn rotate_None;\n\t\t}\n\t\telse if (cross > 0) {\n\t\t\treturn rotate_CW;\n\t\t}\n\t\telse {\n\t\t\treturn rotate_CCW;\n\t\t}\n\t}\n\n\t// (p1s, p1e)と(p2s, p2e)の線分交差判定.EPS以下で接している場合はtrue、重なっている場合はfalse\n\tbool intersect(const point& p1s, const point& p1e, const point& p2s, const point& p2e)\n\t{\n\t\tassert(p1s != p1e && p2s != p2e);\n\t\treturn\n\t\t\t(direction(p1s, p1e, p2s) != direction(p1s, p1e, p2e)) &&\n\t\t\t(direction(p2s, p2e, p1s) != direction(p2s, p2e, p1e));\n\t}\n\n\t// targetが三角形p1,p2,p3の内部にあるかどうか\n\tbool is_inside_triangle(const point& p1, const point& p2, const point& p3, const point& target)\n\t{\n\t\tpoint center_of_gravity = (p1 + p2 + p3) / 3; // 重心\n\n\t\tif (center_of_gravity == target) return true;\n\n\t\t// 重心とtargetを結んだ線分が三角形の辺と交叉するなら、点は三角形の外部にある\n\t\tbool intersect_any =\n\t\t\tintersect(p1, p2, center_of_gravity, target) ||\n\t\t\tintersect(p2, p3, center_of_gravity, target) ||\n\t\t\tintersect(p3, p1, center_of_gravity, target);\n\n\t\treturn !intersect_any;\n\t}\n\n\tbool is_parallel(const point& p1, const point& p2, const point& p3, const point& p4)\n\t{\n\t\tline l1, l2;\n\t\tpoint cross;\n\n\t\tif (!get_line(p1, p2, &l1) || !get_line(p3, p4, &l2)) {\n\t\t\treturn false; // p1-p2, p3-p4で直線が作れない\n\t\t}\n\t\treturn get_crosspoint(l1, l2, &cross) == false;\n\t}\n\n\tbool is_convex(const point* points, int num_points) {\n\t\tassert(num_points >= 3);\n\n\t\trotate_dir base_dir = direction(points[0], points[1], points[2]);\n\t\tif (base_dir == rotate_None) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int i = 1; i < num_points; i++) {\n\t\t\tif (direction(points[i], points[(i + 1)%num_points], points[(i + 2)%num_points]) != base_dir) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool get_convex(const vector<point>& points, vector<point> *convex) {\n\t\tif (points.size() < 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvector<point> sorted_points(points);\n\t\tint n = 0;\n\t\tsort(sorted_points.begin(), sorted_points.end());\n\t\tconvex->resize(2*sorted_points.size()); // 最大2倍までの数の点が入る\n\n\t\t// 左から右\n\t\tfor (vector<point>::iterator it = sorted_points.begin(); it != sorted_points.end(); ++it) {\n\t\t\twhile (n >= 2 && direction((*convex)[n - 2], (*convex)[n - 1], *it) != rotate_CCW) {\n\t\t\t\tn--;\n\t\t\t}\n\t\t\t(*convex)[n++] = *it;\n\t\t}\n\t\tint n_ccw = n;\n\n\t\t// 右から左\n\t\tfor (vector<point>::reverse_iterator it = sorted_points.rbegin(); it != sorted_points.rend(); ++it) {\n\t\t\twhile (n >= n_ccw + 1 && direction((*convex)[n - 2], (*convex)[n - 1], *it) != rotate_CCW) {\n\t\t\t\tn--;\n\t\t\t}\n\t\t\t(*convex)[n++] = *it;\n\t\t}\n\t\tn--;// 左端の点が重複するため、最後の点を削除\n\t\tconvex->resize(n);\n\t\treturn true;\n\t}\n\n} // namespace geometry\n\n//-------------------------------------------------------------------------\n// solution\n\nusing namespace geometry;\n\n\n\nint main(void)\n{\n\tint n;\n\tchar sep;\n\tpoint pA, pB, pC, pD;\n\n\twhile ((cin >> n) && n) {\n\t\tvector<point> points(n), convex;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> points[i].x >> sep >> points[i].y;\n\t\t}\n\n\t\tget_convex(points, &convex);\n\t\tcout << (points.size() - convex.size()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string.h>\n#define P pair<double,double>\nusing namespace std;\ndouble EPS=1e-10;\ndouble add(double a, double b)\n{\n\tif(abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\nbool cmp_x(const P& p, const P& q)\n{\n\tif(p.first !=q.first) return p.first<q.first;\n\treturn p.second>q.second;\n}\ndouble det(P p,P q){\n\treturn add(p.first*q.second,-p.second*q.first);\n}\nP operator+(P p,P q){\n\treturn P(p.first+q.first,p.second+q.second);\n}\nP operator-(P p,P q){\n\treturn P(p.first-q.first,p.second-q.second);\n}\nP p[100];\nvector<P> v;\nvector<int> num;\nint n;\nbool used[100];\nvoid make_convex(int l,int r)\n{\n\tfor(int i=l ;(r>l ? i<r : i>=r);(r>l ? i++ : i--))\n\t{\n\t\tif(used[i]) continue;\n\t\tfor(bool loop=true;loop; )\n\t\t{\n\t\t\tloop=false;\n\t\t\tif(v.size()<2) {v.push_back(p[i]),num.push_back(i),used[i]=true; continue;}\n\t\t\tif(v.size()==2){\n\t\t\t\tif(det(v[1]-v[0],p[i]-v[1])<=0) v.push_back(p[i]),num.push_back(i),used[i]=true;\n\t\t\t\telse used[num[1]]=false,num.pop_back(),v.pop_back(),loop=true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint len=v.size();\n\t\t\tif(det(v[len-1]-v[len-2],p[i]-v[len-1])<=0) v.push_back(p[i]),num.push_back(i),used[i]=true;\n\t\t\telse used[num[len-1]]=false,num.pop_back(),v.pop_back(),loop=true;\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n; if(!n) break;\n\t\tv.clear(); num.clear(); memset(used,false,sizeof(used));\n\t\tfor(int i=0;i<n;i++) scanf(\"%lf,%lf\",&p[i].first,&p[i].second);\n\t\tsort(p,p+n,cmp_x);\n\t\t//pはxの昇順、yの降順。時計回りで見ること\n\t\tmake_convex(0,n);\n\t\tint tmp=v.size(); v.clear(),num.clear(); memset(used,false,sizeof(used));\n\t\tmake_convex(n-1,0);\n\t\tcout << n-(tmp+v.size()-2) << '\\n' ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nVP convex(VP v){\n    VP ret;\n    int n = v.size();\n    sort(v.begin(), v.end());\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if(!ret.empty()) ret.pop_back();\n    return ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tVP v(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv[i] = P(x,y);\n\t\t}\n\t\tVP ret = convex(v);\n\t\tcout << n -(int)ret.size() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<double, double>P;\n\nP p[100];\ndouble det(P a, P b) {\n\treturn a.first*b.second - a.second*b.first;\n}\nP operator-(P a, P b) { return P(a.first - b.first, a.second - b.second); }\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n)scanf(\"%lf,%lf\", &p[i].first, &p[i].second);\n\t\tif (n == 3) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tsort(p, p + n);\n\t\tvector<P>a;\n\t\trep(i, n) {\n\t\t\twhile (a.size() > 1 && det(a[a.size() - 1] - a[a.size() - 2], p[i] - a[a.size() - 2]) < 0)a.pop_back();\n\t\t\ta.push_back(p[i]);\n\t\t}\n\t\tfor (int i = n - 3; i > 0; i--) {\n\t\t\twhile (a.size() > 1 && det(a[a.size() - 1] - a[a.size() - 2], p[i] - a[a.size() - 2]) < 0)a.pop_back();\n\t\t\ta.push_back(p[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", n - a.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = 3.1415926535;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble ang(P a, P b) {        // xNg©çÝ½xNgÌpxÌvZ[0,2pi]\n  double arga = (arg(a) >= 0) ? arg(a) : arg(a) + 2*PI;\n  double argb = (arg(b) >= 0) ? arg(b) : arg(b) + 2*PI;\n  double ret = argb-arga;\n  return (ret>=0) ? ret : ret + 2*PI;\n}\n\nint main() {\n  int n;\n\n  while(cin >> n,n) {\n    vector<P> v;\n    REP(i,n) {\n      double x,y;\n      scanf(\"%lf,%lf\\n\", &x,&y);\n      v.push_back(P(x,y));\n    }\n    P np = *min_element(ALL(v)); // ÀWªêÔ¬³¢àÌ\n    P nv(0,-1);\n//    int mp = min_element(ALL(v))-v.begin();\n    int mp = 0;\n    P sp = np;\n    int ans = n;\n    do {\n      double ma = 2*PI;\n      REP(i,v.size()) {\n        if (v[i]==np) continue;\n        if(ma>ang(nv,v[i]-np)) {\n          ma = ang(nv,v[i]-np);\n          mp = i;\n        }\n      }\n      nv = v[mp]-np;\n      np = v[mp];\n      ans--;\n    } while(np!=sp);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nconst double PI = 3.1415926535;\n\ndouble angle(double cur, double next){\n    double r = cur - next + 2*PI;\n    while( r >= 2*PI ) r -= 2*PI;\n    return r;\n}\n\nint main(){\n    int n;\n    double x[100], y[100];\n    while( scanf(\"%d\", &n), n ){\n        double cx = 10000, cy = 10000;\n        int mem = 0;\n        for(int i = 0; i < n; i++){\n            scanf(\"%lf,%lf\", x+i, y+i);\n            if( x[i] < cx ){\n                cx = x[i]; cy = y[i];\n                mem = i;\n            }\n        }\n        printf(\"%lf, %lf\\n\", x[mem], y[mem]);\n        vector<bool> used(100, false);\n        used[mem] = true;\n        double cang = atan2(1, 0);\n        double lv;\n        int ln = mem;\n        int i;\n        for(i = 0; i < n-1; i++){\n            lv = 100;\n            int can = ln;\n            for(int j = 0; j < n; j++){\n                if( ln == j ) continue;\n                double ang = angle( cang,\n                                    atan2(y[j]-cy, x[j]-cx) );\n                if( ang < lv ){\n                    lv = ang; can = j;\n                }\n            }\n            ln = can;\n            cang = atan2(y[ln]-cy, x[ln]-cx);\n            cx = x[ln]; cy = y[ln];\n            if( used[ln] ) break;\n            used[ln] = true;\n        }\n        printf(\"%d\\n\", n-i-1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<stack>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\n\nbool operator<(const P &a, const P &b){return a.X==b.X ? a.Y<b.Y : a.X<b.X;}\n\n\ndouble cross(P a,P b){return a.X*b.Y-a.Y*b.X;}\nbool ccw(P a,P b,P c){return cross(b-a,c-a)>=0;}\n\nvector<P> convex_VP(vector<P> p){\n\t\n\tsort(p.begin(),p.end());\n\tvector<P> ret(p.size()*2);\n\t\n\tint k=0;\n\tfor(int i=0;i<p.size();i++){\n\t\twhile(k>1 && !ccw(ret[k-2],ret[k-1],p[i]))k--;\n\t\tret[k]=p[i];k++;\n\t}\n\t\n\tint t=k;\n\tfor(int i=p.size()-2;i>=0;i--){\n\t\twhile(k>t && !ccw(ret[k-2],ret[k-1],p[i]))k--;\n\t\tret[k]=p[i];k++;\n\t}\n\t\n\treturn vector<P>(ret.begin(), ret.begin()+k-1);\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\tvector<P> p;\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tp.push_back(P(a,b));\n\t\t}\n\t\t\n\t\tvector<P> convex = convex_VP(p);\n\t\trep(i,convex.size()){\n\t\t\tprintf(\"%lf %lf\\n\",convex[i].X,convex[i].Y);\n\t\t}\n\t\tcout<<(int)p.size()-(int)convex.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define EPS 1e-10\n\nstruct POINT_DOUBLE {\n  double x;\n  double y;\n\n  bool operator == (const POINT_DOUBLE& other) const {\n    return (std::abs(x - other.x) < EPS) && (std::abs(y - other.y) < EPS);\n  }\n\n  bool operator < (const POINT_DOUBLE& other) const {\n    return x < other.x || (x == other.x && y < other.y);\n  }\n};\n\nstruct LINE_DOUBLE {\n  LINE_DOUBLE() {}\n  LINE_DOUBLE(const POINT_DOUBLE& pt1, const POINT_DOUBLE& pt2) {\n    a = pt1.y - pt2.y;\n    b = pt2.x - pt1.x;\n    c = pt1.x * pt2.y - pt2.x * pt1.y;\n  }\n\n  double GetValue(const POINT_DOUBLE& pt) {\n    return a * pt.x + b * pt.y + c;\n  }\n\n  double a;\n  double b;\n  double c;\n};\n\nstd::istream& operator >> (std::istream& is, POINT_DOUBLE& p)\n{\n  is >> p.x >> p.y;\n  return is;\n}\n\nbool getConvex(const std::vector<POINT_DOUBLE>& pts, std::vector<POINT_DOUBLE>* pConvex)\n{\n  if (pts.size() <= 2) {\n    return false;\n  }\n\n  std::vector<POINT_DOUBLE> sorted;\n  sorted.assign(pts.begin(), pts.end());\n  std::sort(sorted.begin(), sorted.end());\n\n  pConvex->clear();\n  pConvex->push_back(*sorted.begin());\n\n  while (1) {\n    POINT_DOUBLE ref = *pConvex->rbegin();\n\n    for (auto pt1 : sorted) {\n      if (pt1 == ref) {\n        continue;\n      }\n      LINE_DOUBLE line(ref, pt1);\n      bool bOuterMost = true;\n      for (auto pt2 : sorted) {\n        if (pt2 == ref || pt2 == pt1) {\n          continue;\n        }\n        if (line.GetValue(pt2) < 0) {\n          bOuterMost = false;\n        }\n      }\n\n      if (bOuterMost) {\n        pConvex->push_back(pt1);\n        break;\n      }\n    }\n\n    if (pConvex->at(0) == *pConvex->rbegin()) {\n      pConvex->pop_back();\n      break;\n    }\n  }\n\n  return true;\n}\n\nint main(void)\n{\n  char c;\n  int n;\n\n  while (1) {\n    std::cin >> n;\n    if (n == 0) {\n      break;\n    }\n    std::vector<POINT_DOUBLE> pts(n);\n    for (int i = 0; i < n; i++) {\n      std::cin >> pts.at(i).x >> c >> pts.at(i).y;\n    }\n    std::vector<POINT_DOUBLE> convex;\n    getConvex(pts, &convex);\n    std::cout << pts.size() - convex.size() << std::endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <complex>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nconst double EPS = 1e-9;\n\ntypedef unsigned long long ull;\ntypedef std::complex<double> P;\n\nnamespace std{\n    bool operator<(const P& lp, const P& rp){\n        if(real(lp) != real(rp)){\n            return real(lp) < real(rp);\n        }\n        return imag(lp) < imag(rp);\n    }\n}    \n\ndouble dot(const P& lp, const P& rp){\n    return real(lp)*real(rp)+imag(lp)*imag(rp);\n}\n\ndouble cross(const P& lp, const P& rp){\n    return real(lp)*imag(rp)-imag(lp)*real(rp);\n}\n\nint ccw(P a, P b, P c){\n    b -= a; c -= a;\n    if(cross(b, c) > 0)return 1; // counter clock wise\n    if(cross(b, c) < 0)return -1; // clock wise\n    if(dot(b, c) < 0)return 2; // B A C\n    if(norm(b) < norm(c))return -2; // A B C\n    return 0; // A C B\n}\n\nstd::vector<P> convex_hull(std::vector<P> ps){\n    int n = ps.size(), k = 0;\n    std::sort(ps.begin(), ps.end());\n\n    std::vector<P> ch(2*n);\n    for(int i=0;i<n;ch[k++]=ps[i++]){ // 下\n        while(k>=2&&ccw(ch[k-2], ch[k-1], ps[i])<=0){--k;} // 反時計になるよう調整\n    }\n    for(int i=n-2, t=k+1;i>=0;ch[k++]=ps[i--]){ // 上\n        while(k>=t&&ccw(ch[k-2], ch[k-1], ps[i])<=0){--k;}\n    }\n    \n    ch.resize(k-1); // 輪を閉じる部分(最初と最後)の重複を除く\n    return ch;\n}\n\nint main(){\n    int N;\n    while(std::cin >> N, N){\n        std::vector<P> Nails;\n        REP(i, N){\n            double x, y;\n            scanf(\"%lf,%lf\", &x, &y);\n        \n            Nails.push_back({x, y});\n        }\n\n        auto ch = convex_hull(Nails);\n\n        std::cout << N - ch.size() << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nstruct point{\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y):x(x),y(y){}\n};\n\nconst double pi=3.1415926535897932;\nconst double rad=180/pi;\n\ndouble get_angle(point a, point b, int d, int& D)\n{\n\tdouble x = b.x - a.x;\n\tdouble y = b.y - a.y;\n\tdouble ret = atan2(x, y) * rad;\n\tD = (x < 0 ? (y < 0 ? (4) : (3)) : (y < 0 ? (1) : (2) )) -1;\n\treturn (180-ret);\n}\n\nint main(void)\n{\n\tint n;\n\tpoint p[100];\n\tbool used[100];\n\twhile(cin >> n, n){\n\t\tint f = -1;\n\t\trep(i,n){\n\t\t\tscanf(\"%lf,%lf\", &p[i].x, &p[i].y);\n\t\t\tused[i] = false;\n\t\t\tif(f == -1 || p[i].x < p[f].x) f = i;\n\t\t}\n\t\tint t = f, d = 0;\n\t\tfor(int l = 0;;l = 1){\n\t\t\tif(l && t == f) break;\n\t\t\tdouble mi;\n\t\t\tint tmp = -1,c = 100000000;\n\t\t\tint dd;\n\t\t\trep(i,n){\n\t\t\t\tif(used[i])continue;\n\t\t\t\tif(t == i)continue;\n\t\t\t\tint D;\n\t\t\t\tdouble ang = get_angle(p[t], p[i], d, D);\n\t\t\t\tint cc = 0,ddd = d;\n\t\t\t\twhile(D != ddd){\n\t\t\t\t\tddd = (ddd + 1) % 4;\n\t\t\t\t\tcc++;\n\t\t\t\t}\n\t\t\t\tif(tmp < 0 || cc < c || (c == cc && ang < mi)){\n\t\t\t\t\ttmp = i;\n\t\t\t\t\tc = cc;\n\t\t\t\t\tmi = ang;\n\t\t\t\t\tdd = D;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tmp < 0) break;\n\t\t\tt = tmp;\n\t\t\td = dd;\n\t\t\tused[t] = true;\n\t\t}\n\t\tprintf(\"%u\\n\",count(used, used+n, false));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <map>\nusing namespace std;\n\ntypedef pair<double, double> P;\nbool isIn(P a, P b, P c, P p)\n{\n\tP s1(b.first - a.first, b.second - a.second);\n\tP s2(c.first - b.first, c.second - b.second);\n\tP s3(a.first - c.first, a.second - c.second);\n\tP p1(p.first - a.first, p.second - a.second);\n\tP p2(p.first - b.first, p.second - b.second);\n\tP p3(p.first - c.first, p.second - c.second);\n\tdouble x = (s1.first * p1.second) - (s1.second * p1.first);\n\tdouble y = (s2.first * p2.second) - (s2.second * p2.first);\n\tdouble z = (s3.first * p3.second) - (s3.second * p3.first);\n\n\tif (x >= 0 && y >= 0 && z >= 0) return true;\n\tif (x <= 0 && y <= 0 && z <= 0) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tint count = 0;\n\tP pos[100];\n\n\twhile (true)\n\t{\n\t\tcount = 0;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lf,%lf\", &(pos[i].first), &(pos[i].second));\n\t\t}\n\t\tfor (int p = 0; p < n; p++)\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tfor (int a = 0; a < n; a++)\n\t\t\t{\n\t\t\t\tif (a == p) continue;\n\t\t\t\tfor (int b = 0; b < n; b++)\n\t\t\t\t{\n\t\t\t\t\tif (b == a || b == p) continue;\n\t\t\t\t\tfor (int c = 0; c < n; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (c == a || c == b || c == p) continue;\n\t\t\t\t\t\tif (isIn(pos[a], pos[b], pos[c], pos[p]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag) break;\n\t\t\t\t}\n\t\t\t\tif (flag) break;\n\t\t\t}\n\t}\n\t\tprintf(\"%d\\n\", count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ALL( c ) (c).begin(), (c).end()\n\nconst double EPS = 1e-9;\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 )\n\t{\n\t\treturn;\n\t}\n\n\tPoint( double x, double y ) : x( x ), y( y )\n\t{\n\t\treturn;\n\t}\n\n\tPoint operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x - a.x, y - a.y );\n\t}\n\n\tPoint operator * ( const double &a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint operator / ( const double &a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n};\n\n// 外積\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// グラハムスキャン\nvector< Point > getConvex( vector< Point > ps )\n{\n\tconst int N = ps.size();\n\n\tsort( ALL( ps ) );\n\n\tint k = 0;\n\tvector< Point > convex( N * 2 );\n\n\tfor ( int i = 0; i < N; i++ )\n\t{\n\t\twhile ( 2 <= k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= EPS )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tfor ( int i = N - 2, t = k; 0 <= i; i-- )\n\t{\n\t\twhile ( t < k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= EPS )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.resize( k - 1 );\n\n\treturn convex;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< Point > ps( n );\n\n\t\tEACH( p, ps )\n\t\t{\n\t\t\tchar d;\n\n\t\t\tcin >> p.x >> d >> p.y;\n\t\t}\n\n\t\tvector< Point > convex = getConvex( ps );\n\n\t\tcout << n - convex.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define EPS (1e-10)\ntypedef complex<double> Po;\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(int num){\n    int c = 0;\n    double max = 0;\n    Po a,b;\n    line l,s;\n    vector<int> tmp;\n\n    a = v[num];\n    for(int i=0;i<(int)v.size();i++){\n      if(i!=num){\n\tif(max < v[i].real())max = v[i].real();\n\tif(a.imag() == v[i].imag()){\n\t  tmp.push_back(1);\n\t  v[i].imag() += 1e-6;\n\t}else tmp.push_back(0);\n      }\n    }\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size();i++){\n      if(i == num){\n\tif(!i) l.set(v[(int)v.size()-1],v[i+1]);\n\telse l.set(v[i-1],v[(i+1)%(int)v.size()]);\n\tif(s.is_cross(l))c++;\n      }else if((i+1)%(int)v.size() != num){\n\tl.set(v[i],v[(i+1)%v.size()]);\n\tif(s.is_cross(l))c++;\n      }\n    }\n    for(int i=0;i<(int)v.size();i++){\n      if(tmp[i])v[i].imag() -= 1e-6;\n    }\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(void){\n  int n;\n  int ans;\n  Po p;\n  polygon poly;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    poly.set();\n    for(int i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&p.real(),&p.imag());\n      poly.Vadd(p);\n    }\n    poly.sort();\n\n    ans = 0;\n    for(int i=0;i<n;i++){\n      if(poly.inter(i))ans++;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\ntypedef long long ll;\nusing namespace std;\nstruct point_t { double x, y; };\nbool operator < (point_t const & a, point_t const & b) { return make_pair(a.x,a.y) < make_pair(b.x,b.y); }\npoint_t operator + (point_t const & a, point_t const & b) { return { a.x + b.x, a.y + b.y }; }\npoint_t operator - (point_t const & a, point_t const & b) { return { a.x - b.x, a.y - b.y }; }\ndouble cross(point_t const & a, point_t const & b) { return a.x * b.y - a.y * b.x; }\ndouble ccw(point_t const & a, point_t const & b, point_t const & c) { return cross(b - a, c - a); }\nvector<point_t> convex_hull(vector<point_t> ps) {\n    int n = ps.size();\n    sort(ps.begin(), ps.end());\n    vector<point_t> qs;\n    for (int i = 0; i < n; ++i) { // lower hull\n        int k = qs.size();\n        while (k >= 2 and ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            qs.pop_back();\n            k = qs.size();\n        }\n        qs.push_back(ps[i]);\n    }\n    const int t = qs.size();\n    for (int i = n-2; i >= 0; --i) { // upper hull\n        int k = qs.size();\n        while (k >= t and ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            qs.pop_back();\n            k = qs.size();\n        }\n        qs.push_back(ps[i]);\n    }\n    qs.pop_back();\n    return qs;\n}\nint solve(vector<point_t> const & ps) {\n    vector<point_t> qs = convex_hull(ps);\n    return ps.size() - qs.size();\n}\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<point_t> ps(n);\n        char dummy;\n        for (auto && p : ps) cin >> p.x >> dummy >> p.y;\n        cout << solve(ps) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <sstream>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-10;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nclass Point\n{\npublic:\n  double x,y;\n  Point(double x,double y): x(x),y(y){}\n  Point operator + (const Point &p)\n  {\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (const Point &p)\n  {\n    return Point(x-p.x,y-p.y);\n  }\n  Point operator * (double k)\n  {\n    return Point(x*k,y*k);\n  }\n  Point operator / (double k)\n  {\n    return Point(x/k,y/k);\n  }\n  bool operator < (const Point &p) const\n  {\n    return x!=p.x ? x<p.x : y<p.y;\n  }\n  bool operator == (const Point &p) const\n  {\n    return fabs(x-p.x)<eps && fabs(y-p.y) < eps;\n  }\n  double abs(){return sqrt(norm());}\n  double norm(){return x*x+y*y;}\n};\ntypedef Point Vector;\ndouble dot(Vector a,Vector b)\n{\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\ndouble norm(Point a)\n{\n  return a.x*a.x + a.y*a.y;\n}\ndouble abs(Vector a)\n{\n  return sqrt(norm(a));\n}\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1,Point p2): p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n  Point c;\n  double r;\n  Circle(Point c,double r):  c(c),r(r){}\n};\n\ntypedef vector<Point> Polygon;\n\n\nbool isorthogonal(Vector a,Vector b)\n{\n  return fabs(dot(a,b)-0.0)<eps;\n}\n\nbool isparallel(Vector a,Vector b)\n{\n  return fabs(cross(a,b)-0.0)<eps;\n}\nPoint project(Segment s,Point p)\n{\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return  s.p1 + base*r;\n}\nPoint reflect(Segment s,Point p)\n{\n  return p+ (project(s,p)-p)*2.0;\n}\ndouble getdistance(Point a,Point b)\n{\n  return abs(a-b);\n}\ndouble getdistanceLP(Line l,Point p)\n{\n  return abs(cross(l.p2-l.p1,p-l.p1) / abs(l.p2-l.p1));\n}\ndouble getdistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) <0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) <0.0) return abs(p-s.p2);\n  return getdistanceLP(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps) return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps) return CLOCKWISE;\n  if(dot(a,b)<-eps) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1) * ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1,Segment s2)\n{\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\nPoint getcrosspoint(Segment s1,Segment s2)\n{\n  Vector base =s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\ndouble getdistanceSS(Segment s1,Segment s2)\n{\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getdistanceSP(s1,s2.p1),getdistanceSP(s1,s2.p2)),min(getdistanceSP(s2,s1.p1),getdistanceSP(s2,s1.p2)));\n}\n\npair<Point,Point> getcrosspoints(Circle c,Line l)\n{\n  //assert(intersect(c,l));\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r - norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\npair <Point,Point> getcrosspoints(Circle c1,Circle c2)\n{\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r) / (2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\nint contains(Polygon g,Point p)\n{\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++)\n    {\n      Point a=g[i]-p,b=g[(i+1)%n]-p;\n      if(abs(cross(a,b)) < eps && dot(a,b)<eps) return 1;\n      if(a.y>b.y) swap(a,b);\n      if(a.y <eps && eps<b.y && cross(a,b)>eps) x=!x;\n    }\n  return (x ? 2 : 0);\n}\n\nPolygon andrewscan(Polygon s)\n{\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++)\n    {\n      for(int n=u.size();n>= 2 && ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE; n--)\n\t{\n\t  u.pop_back();\n\t}\n      u.push_back(s[i]);\n    }\n  for(int i=s.size()-3;i>=0;i--)\n    {\n      for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--)\n\t{\n\t  l.pop_back();\n\t}\n      l.push_back(s[i]);\n    }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n}\nint main(int argc,char const* argv[])\n{\n  int n;\n  while(cin >> n && n)\n    {\n      Polygon p;\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y;\n\t  char ch;\n\t  cin >> x >>ch >>  y;\n\t  p.push_back(Point(x,y));\n\t}\n      Polygon l=andrewscan(p);\n      cout << n-l.size() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\n#define EPS (1e-6)\ntypedef complex<double> Po;\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){return abs(cross(b-a,c-a)/2);}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) + EPS)return false;\n  else return true;\n}\n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int ans;\n  bool use[100];\n  Po p[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&p[i].real(),&p[i].imag());\n      use[i] = false;\n    }\n\n    ans = 0;\n    for(i=0;i<n-3;i++){\n      for(j=i+1;j<n-2;j++){\n\tfor(k=j+1;k<n-1;k++){\n\t  for(l=k+1;l<n;l++){\n\t    if(!use[l]){\n\t      if(inter(p[i],p[j],p[k],p[l])){\n\t\tans++;\n\t\tuse[l] = true;\n\t      }\n\t    }\n\t    if(!use[k]){\n\t      if(inter(p[i],p[j],p[l],p[k])){\n\t\tans++;\n\t\tuse[k] = true;\n\t      }\n\t    }\n\t    if(!use[j]){\n\t      if(inter(p[i],p[l],p[k],p[j])){\n\t\tans++;\n\t\tuse[j] = true;\n\t      }\n\t    }\n\t    if(!use[i]){\n\t      if(inter(p[l],p[j],p[k],p[i])){\n\t\tans++;\n\t\tuse[i] = true;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> P;\n#define X real\n#define Y imag\nvector<P> data;\n\nnamespace std{\n  bool operator<(P a,P b){\n    return a.X()!=b.X()? a.X()<b.X():a.Y()<b.Y(); \n  }\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\nint ccw(P a,P b,P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0)return 1;     //counter clockwise\n  if(cross(b,c)<0)return -1;    //clockwise\n  if(dot(b,c)<0)return 2;       //c--a--b on line\n  if(norm(b)<norm(c))return -2; //a--b--c on line\n  return 0;\n}\n\nint solve(){\n  sort(data.begin(),data.end());\n  vector<P> ch(data.size()*2);\n  int k=0;\n  for(int i=0;i<data.size();ch[k++]=data[i++]){\n    while(k>=2 && ccw(ch[k-2],ch[k-1],data[i])<=0)--k;\n  }\n  for(int i=data.size()-2,t=k+1;i>=0;ch[k++]=data[i--]){\n    while(k>=t&&ccw(ch[k-2],ch[k-1],data[i])<=0)--k;\n  }\n  ch.resize(k-1);\n  return ch.size();\n}\n\n\nint main(){\n  int n;\n  while(cin>>n){\n    if(n==0)break;\n    data.clear();\n    for(int i=0;i<n;i++){\n      ld a,b;\n      char c;\n      cin>>a>>c>>b;\n      data.push_back(P(a,b));\n    }\n    cout<<n-solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\n\ndouble area(double a, double b, double c)\n{\n\tdouble s = (a+b+c)/2;\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n}\ndouble distance(double x1, double y1, double x2, double y2)\n{\n\treturn sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\nbool isInTriangle(double x[3], double y[3], double xp, double yp)\n{\n\tdouble edge[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tedge[i] = distance(x[i], y[i], x[(i+1)%3], y[(i+1)%3]);\n\tdouble correctArea = area(edge[0], edge[1], edge[2]);\n\tdouble totalArea = 0;\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\ttotalArea += area(distance(x[i], y[i], xp, yp)\n\t\t\t, distance(x[(i+1)%3], y[(i+1)%3], xp, yp), edge[i]);\n\t}\n\treturn abs(correctArea - totalArea) < 0.0001;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\\n\", &n);\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tdouble x[100];\n\t\tdouble y[100];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tscanf(\"%lf,%lf\\n\", x+i, y+i);\n\n\t\tint res = 0;\n#define SUCC(w) ((w+1) % n)\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tdouble xp = x[i];\n\t\t\tdouble yp = y[i];\n\t\t\tbool isOutOfAnyTriangle = true;\n\t\t\tfor (int a = SUCC(i); a != i; a = SUCC(a))\n\t\t\t{\n\t\t\t\tfor (int b = SUCC(a); b != i; b = SUCC(b))\n\t\t\t\t{\n\t\t\t\t\tfor (int c = SUCC(b); c != i; c = SUCC(c))\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble xx[] = { x[a], x[b], x[c] };\n\t\t\t\t\t\tdouble yy[] = { y[a], y[b], y[c] };\n\t\t\t\t\t\tif (isInTriangle(xx, yy, xp, yp))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tisOutOfAnyTriangle = false;\n\t\t\t\t\t\t\tgoto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nEnd:\n\t\t\tif (!isOutOfAnyTriangle)\n\t\t\t\t++res;\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <numeric>\n#include <ctime>\n#include <algorithm>\n#include <set>\n#include <stdio.h>\n#include <map>\n\nusing namespace std;\ntypedef long long int lint;\n\nclass Point {\npublic:\n\tpair<double, double> p;\n\tdouble arg;\n\n\tPoint(){\n\t\tp.first = p.second = 0.0;\n\t\targ = 0.0;\n\t}\n};\n\nstruct LessPoint : public binary_function<Point, Point, bool> {\n\tbool operator () (const Point &pLeft, const Point &pRight) {\n\t\treturn pLeft.arg > pRight.arg;\n\t}\n};\n\nbool IsClockwise(Point p1, Point p2, Point p3)\n{\n\tpair<double, double> v1, v2;\n\n\tv1.first = p2.p.first - p1.p.first;\n\tv1.second = p2.p.second - p1.p.second;\n\tv2.first = p3.p.first - p1.p.first;\n\tv2.second = p3.p.second - p1.p.second;\n\n\tif(v1.first * v2.second - v2.first * v1.second < 0) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint n, i;\n\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tPoint *po;\n\t\tpo = new Point[n];\n\t\t\n\t\tint nmin;\t\t\t\t//最小のy座標を持つ点の番号\n\t\tdouble min = 2000.0;\t//最小のy座標\n\n\t\t//find p_0\n\t\tfor(i = 0; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\", &(po[i].p.first), &(po[i].p.second));\n\t\t\tif(po[i].p.second < min){\n\t\t\t\tnmin = i;\n\t\t\t\tmin = po[i].p.second;\n\t\t\t}\n\t\t}\n\t\t//sort by argument\n\t\tpriority_queue<Point, vector<Point>, LessPoint> qu;\n\t\tfor(i = 0; i < n; i++){\n\t\t\tif(i == nmin) continue;\n\n\t\t\tpo[i].arg = atan2(po[i].p.second - po[nmin].p.second, po[i].p.first - po[nmin].p.first);\n\t\t\tqu.push(po[i]);\n\t\t}\n\n\t\tstack<Point> st;\n\n\t\t//push p0 and p1\n\t\tst.push(po[nmin]);\n\t\tst.push(qu.top());\n\t\tqu.pop();\n\n\t\twhile(!qu.empty()){\n\t\t\tPoint top, under;\t// S[top] and S[top - 1]\n\t\t\twhile(1){\n\t\t\t\ttop = st.top();\n\t\t\t\tst.pop();\n\t\t\t\tunder = st.top();\n\t\t\t\tst.push(top);\n\t\t\t\tif(!IsClockwise(under, top, qu.top())) break;\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.push(qu.top());\n\t\t\tqu.pop();\n\t\t}\n\t\tcout << n - st.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef complex<double> p;\n\ndouble det(p a,p b)\n{\n\treturn a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool comp(p a,p b)\n{\n\tif(a.real()!=b.real()) return a.real()<b.real();\n\treturn a.imag()<b.imag();\n}\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tp ps[n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tscanf(\"%lf,%lf\",&ps[i].real(),&ps[i].imag());\n\t\t}\n\n\t\tsort(ps,ps+n,comp);\n\t\tint k=0;\n\t\tp qs[n*2];\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\twhile(k>1&&det(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) --k;\n\t\t\tqs[k++]=ps[i];\n\t\t}\n\n\t\tfor(int i = n-2, t=k; i >= 0; --i)\n\t\t{\n\t\t\twhile(k>t&&det(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) --k;\n\t\t\tqs[k++]=ps[i];\n\t\t}\n\n\t\tcout<<n-k+1<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<double,double> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nbool d[101][101];\nvector<P> p;\nint n;\nint cal(double x1,double y1,double x2,double y2,double x,double y)\n{\n\tdouble a,b;\n\ta=(y-y1)*(x1-x2);\n\tb=(y1-y2)*(x-x1);\n\tif(a>b)\n\t{\n\t\treturn 1;\n\t}\n\telse if(a<b)\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\nbool check(int a,int b)\n{\n\tint k;\n\tbool f=true;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(a==i||b==i)continue;\n\t\tif(f)\n\t\t{\n\t\t\tk=cal(p[a].fi,p[a].sec,p[b].fi,p[b].sec,p[i].fi,p[i].sec);\n\t\t\tf=false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(k!=cal(p[a].fi,p[a].sec,p[b].fi,p[b].sec,p[i].fi,p[i].sec))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tp.clear();\n\t\tmemset(d,false,sizeof(d));\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tP s;\n\t\t\tscanf(\"%lf,%lf\",&s.fi,&s.sec);\n\t\t\tp.pb(s);\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(check(i,j))\n\t\t\t\t{\n\t\t\t\t\td[i][j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(d[i][j])\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#define rep(i,n) for(int (i)=0;(i)<(int)n;(i)++)\n#define each(i,o) for (__typeof((o).begin()) i = (o).begin(); i != (o).end(); ++i)\n#define mp make_pair\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define SORT(x) sort((x).begin(), (x).end())\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\nclass Point\n{\npublic:\n  double y,x;\n  Point(){y = x = 0.0;}\n  Point(double iy, double ix){y = iy; x = ix;}\n  Point(double theta){y = sin(theta); x = cos(theta);}\n  Point operator+(const Point& p) const{return Point(y+p.y,x+p.x);}\n  Point operator-(const Point& p) const{return Point(y-p.y,x-p.x);}\n  void operator+=(const Point& p) {y+=p.y;x+=p.x;}\n  void operator-=(const Point& p) {y-=p.y;x-=p.x;}\n  Point operator*(double a) const{return Point(y*a,x*a);}\n  Point operator/(double a) const{return Point(y/a,x/a);}\n  bool operator<(const Point& p) const{return y!=p.y ? y<p.y : x<p.x;}\n  double length() const{return sqrt(x*x+y*y);}\n  double dist(const Point& p) const{return sqrt(pow(y-p.y,2)+pow(x-p.x,2));}\n  double dot(const Point& p) const{return y*p.y+x*p.x;}\n  double cross(const Point& p) const{return y*p.x-x*p.y;}\n  double angle() const{return atan2(y,x);}\n};\n\ndouble ccw(const Point& a, const Point& b, const Point& c){return (b-a).cross(c-a);}\n\ntemplate<class IN>\nvoid walk_cw(IN begin, IN end, vector<Point>& v) {\n    IN cur = begin;\n    v.push_back(*cur++);\n    vector<Point>::size_type s = v.size();\n    v.push_back(*cur++);\n    while(cur != end) {\n        if (v.size() == s || ccw(v[v.size()-2], v.back(), *cur) > EPS)\n            v.push_back(*cur++);\n        else\n            v.pop_back();\n    }\n    v.pop_back();\n}\n\nvector<Point> convex_hull(vector<Point> vp){\n  int n = vp.size();\n  int k = 0;\n  vector<Point> ret;\n  sort(vp.begin(),vp.end());\n\n  walk_cw(vp.begin(), vp.end(), ret);\n  walk_cw(vp.rbegin(), vp.rend(), ret);\n\n  return ret;\n}\n\nint main(int argc, char const *argv[]){\n  int n;\n  while(true){\n    cin >> n;\n    if(n==0) break;\n\n    vector<Point> vp(n);\n    rep(i,n) scanf(\"%lf,%lf\",&(vp[i].x),&(vp[i].y));\n\n    vector<Point> ans = convex_hull(vp);\n    cout << (vp.size()-ans.size()) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<double,double> pd;\nvector<pd>vec;\nvector<long>used;\n\nbool op(pd p1,pd p2){\n    if(p1.first*p2.second-p2.first*p1.second>0)return 1;\n    return 0;\n}\nbool com(pd p1,pd p2){\n    return p1.first==p2.first?p1.second>p2.second:p1.first<p2.first;\n}\n\npd minu(pd p1, pd p2){\n    return make_pair(p1.first-p2.first, p1.second-p2.second);\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vec.clear();\n        used.clear();\n        for(int i=0;i<n;i++){\n            double x,y;char c;\n            cin>>x>>c>>y;\n            vec.push_back(make_pair(x, y));\n        }\n        sort(vec.begin(),vec.end(),com);\n        pd last=minu(vec[1],vec[0]), cur;\n        used.push_back(0);\n        used.push_back(1);\n        for(int i=0;i<vec.size();i++){\n            cur=vec[i];\n            if(find(used.begin(),used.end(),i)!=used.end())\n                continue;\n            while(op(last,minu(cur,vec[used[used.size()-1]]))){\n                used.pop_back();\n                last=minu(vec[used[used.size()-1]],vec[used[used.size()-2]]);\n            }\n            last=minu(cur,vec[used[used.size()-1]]);\n            used.push_back(i);\n        }\n        for(long i=vec.size()-1;i>=0;i--){\n            cur=vec[i];\n            if(find(used.begin(),used.end(),i)!=used.end()&&i!=0)\n                continue;\n            while(op(last,minu(cur,vec[used[used.size()-1]]))){\n                used.pop_back();\n                last=minu(vec[used[used.size()-1]],vec[used[used.size()-2]]);\n            }\n            if(i!=0){\n                last=minu(cur,vec[used[used.size()-1]]);\n                used.push_back(i);\n            }\n        }\n        cout<<vec.size()-used.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n#define rep2(x,from,to) for(int x = (from); x < (to); ++(x))\n#define rep(x,to) rep2(x,0,to)\ntypedef pair<double, double> dpair;\nconst double EPS = 1e-10;\nbool isLeft(dpair p1, dpair p2, dpair p3) {\n\tint r = (p2.first - p1.first) * (p3.second - p2.second) - (p2.second - p1.second) * (p3.first - p2.first);\n \tif(r > -EPS)  return true;\n\treturn false;\n}\nstruct pairsort {\n\tbool operator()(const dpair& x, const dpair& y) const {\n\t\tif(x.first == y.first) return y.second < x.second;\n\t\treturn x.first < y.first;\n\t}\n};\nint main() {\n\tint n;\n\twhile(cin >> n && n) {\n\t\t/*if(n == 3) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}*/\n\t\tvector<dpair> v;\n\t\trep(i,n) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tsort(v.begin(), v.end(), pairsort());\n\t\tset<int> s;\n\t\tvector<pair<int, dpair> > v1;\n\t\tv1.push_back(make_pair(0, v[0]));\n\t\tv1.push_back(make_pair(1, v[1]));\n\t\trep2(i,2,n) {\n\t\t\tv1.push_back(make_pair(i, v[i]));\n\t\t\twhile(v1.size() >= 3 && isLeft(v1[v1.size()-3].second, v1[v1.size()-2].second, v1[v1.size()-1].second)) {\n\t\t\t\tv1.erase(--(--v1.end()));\n\t\t\t}\n\t\t}\n\t\trep(i,v1.size()) {\n\t\t\ts.insert(v1[i].first);\n\t\t}\n\t\tvector<pair<int, dpair> > v2;\n\t\tv2.push_back(make_pair(n-1, v[n-1]));\n\t\tv2.push_back(make_pair(n-2, v[n-2]));\n\t\tfor(int i = n - 3; i >= 0; --i) {\n\t\t\tv2.push_back(make_pair(i, v[i]));\n\t\t\twhile(v2.size() >= 3 && isLeft(v2[v2.size()-3].second, v2[v2.size()-2].second, v2[v2.size()-1].second)) {\n\t\t\t\tv2.erase(--(--v2.end()));\n\t\t\t}\n\t\t}\n\t\trep(i,v2.size()) {\n\t\t\ts.insert(v2[i].first);\n\t\t}\n\t\tcout << n - s.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//11\n#include<iostream>\n#include<complex>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble det(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool cmp(P a,P b){\n  if(a.real()!=b.real()){\n    return a.real()<b.real();\n  }else{\n    return a.imag()<b.imag();\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    P ps[100];\n    for(int i=0;i<n;i++){\n      double x,y;\n      (cin>>x).ignore()>>y;\n      ps[i]=P(x,y);\n    }\n    sort(ps,ps+n,cmp);\n    int k=0;\n    vector<P> qs(n*2);\n    for(int i=0;i<n;i++){\n      while(k>1&&det(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n      qs[k++]=ps[i];\n    }\n    for(int i=n-2,t=k;i>=0;i--){\n      while(k>t&&det(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n      qs[k++]=ps[i];\n    }\n    cout<<n-(k-1)<<endl;\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n//???????????¨\nbool lt(const complex<double>& a,const complex<double>& b){\n  return a.real()<b.real() || (a.real()==b.real() && a.imag()<b.imag());\n}\n\n//??????????¬????????????¢??????????????????????±??????????\ndouble cp(complex<double> a, complex<double> b){\n  return (conj(a)*b).imag();\n}\n\nint main(){\n  int n;\n  while(cin >> n && n>0){\n\n    //????????????\n    vector<complex<double> > v;\n    for(int i=0;i<n;i++){\n      double x, y;\n      cin >> x >> y;\n      v.push_back(complex<double>(x,y));\n    }\n\n    //C???R^2??¨???????????????????????§???????????????\n    sort(v.begin(),v.end(),lt);\n\n    //??????????????´????????´??????\n    vector<complex<double> > u,b;\n\n    //????????????????????§???v.front()??¨v.back()??????????????????????????§?????????\n    u.push_back(v[0]);\n    int i;\n    for(i=0;i<n;i++){\n      if(v[i].real()!=v[0].real()) break;\n    }\n    b.push_back(v[0]);\n    b.push_back(v[i]);\n\n    i=i+1;\n    while(b.back()!=v.back()){\n      b.push_back(v[i]);\n      i++;\n\n      int l=b.size();\n      if(l<3) continue;\n      if(cp(b[l-1]-b[l-2],b[l-3]-b[l-2])>0) continue;\n      else{\n\tb.pop_back();\n\tb.pop_back();\n\ti--;\n      }\n    }\n\n    i=1;\n    while(u.back()!=v.back()){\n      u.push_back(v[i]);\n      i++;\n\n      int l=u.size();\n      if(l<3) continue;\n      if(cp(u[l-1]-u[l-2],u[l-3]-u[l-2])<0) continue;\n      else{\n\tu.pop_back();\n\tu.pop_back();\n\ti--;\n      }\n    }\n\n    //u.front()==b.front()==v.front(), u.back()==b.back()==v.back()\n    //??§???????????????2????????????u,v??§??????????????????\n    cout << (b.size()+u.size()-2) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\ntypedef complex<double> P;\n\n#define EPS (1e-12)\n#define PI (acos(-1.0))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define POSARG(a) (arg(a) > 0.0? arg(a) : 2.0*PI + arg(a))\n\nint n;\nint re;\n\nvector<P>::iterator convex_hull(vector<P>& vc)\n{\n\tint undermost = 0;\n\t\n\tfor(int i = 1; i < (int)vc.size(); i++)\n\t{\n\t\tif( vc[i].imag() < vc[undermost].imag() \n\t\t\t||( EQ(vc[undermost].imag(), vc[i].imag()) && vc[undermost].real() < vc[i].real() ) )\n\t\t{\n\t\t\tundermost = i;\n\t\t}\n\t}\n\t\n\tswap(vc[0], vc[undermost]);\n\t\n\tdouble nowarg = 0.0;\n\tint j;\n\t\n\tfor( j = 0; j < (int)vc.size()-1; j++)\n\t{\n\t\tdouble minarg = 2.0*PI;\n\t\tdouble maxdst = 0.0;\n\t\tint candidx = 0;\n\t\t\n\t\tfor(int i = j+1; i < (int)vc.size(); i++)\n\t\t{\n\t\t\tdouble newarg = POSARG(vc[i] - vc[j]);\n\t\t\tdouble newdst = abs(vc[i] - vc[j]);\n\t\t\t\n\t\t\tif( newarg > nowarg)\n\t\t\t\tif( newarg < minarg || ( EQ(newarg, minarg) && newdst > maxdst) )\n\t\t\t\t{\n\t\t\t\t\tminarg = newarg;\n\t\t\t\t\tmaxdst = newdst;\n\t\t\t\t\tcandidx = i;\n\t\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif(candidx == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswap(vc[j+1], vc[candidx]);\n\t\t\tnowarg = minarg;\n\t\t}\n\t}\n\t\n\tre = j+1;\n\treturn vc.begin()+j+1;\n}\n\n\nint solve(vector<P> vc)\n{\n\tvector<P>::iterator r = convex_hull(vc);\n\treturn vc.size()-re;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> vc;\n\t\tvc.clear();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tchar c;\n\t\t\tdouble a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> c;\n\t\t\tcin >> b;\n\t\t\tvc.push_back(P(a, b));\n\t\t}\n\t\t\n\t\tcout << solve(vc) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<iomanip>\n#include<algorithm>\n#include<cmath>\n//////以上はこのライブラリで使うテンプレ\n\n#include<cstdio>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n/////テンプレここから\n\nconst double PI=acos(-1);\nconst double EPS=1e-5; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n  scanf(\"%lf,%lf\", &x, &y);\n  P p(x,y);\n  return p;\n}\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\nint main(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    G g = inG(n);\n    G t = convex_hull(g);\n    int ans = 0;\n    int i,j;\n    rep(i,n){\n      bool c = true;\n      int m = t.size();\n      rep(j,m){\n        if(ccw(t[j], t[(j+1)%m], g[i]) == 0) c=false;\n      }\n      if(c) ans++;\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ndouble EPS=1e-10;\nstruct P{\n\tdouble x,y;\n\tP(){};\n\tP(double x,double y):x(x),y(y){};\n\tdouble add(double a,double b){if(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;return a+b;}\n\tP operator +(P p){return P(add(x,p.x),add(y,p.y));}\n\tP operator -(P p){return P(add(x,-p.x),add(y,-p.y));}\n\tdouble dot(P p){return add(x*p.x,y*p.y);}\n\tdouble det(P p){return add(x*p.y,-y*p.x);}\n};\n\nP pos[105];\n\nbool cmp_p(const P &p,const P&q)\n{\n\tif(p.x!=q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\n\nvector<P> convex_hull(P *ps,int n)\n{\n\tsort(ps,ps+n,cmp_p);\n\tint k=0;\n\tvector<P> qs(n*n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(;k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0;)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--)\n\t{\n\t\tfor(;k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0;)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nint main()\n{\n\tint N;\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(pos,0,sizeof(pos));\n\t\tfor(int i=0;i<N;i++)\n\t\t\tscanf(\"%lf,%lf\",&pos[i].x,&pos[i].y);\n\t\tprintf(\"%d\\n\",N-convex_hull(pos,N).size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define fs first\n#define sc second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n#define tmp template<class t>\n\ntmp void chmax(t&a,t b){if(a<b)a=b;}\ntmp void chmin(t&a,t b){if(a>b)a=b;}\n\ntmp using vc=vector<t>;\ntmp using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.fs<<\",\"<<p.sc<<\"}\";\n}\n\ntmp ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\ntmp void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll read(){ll i;cin>>i;return i;}\n\nusing ld=long double;\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-7;\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nauto cmcmp=[](const cm&a,const cm&b){\n\tif(sgn(a.x-b.x))return a.x<b.x;\n\telse return sgn(a.y-b.y)<0;\n};\n\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\n\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\n\nld tri2(cm a,cm b,cm c){\n\treturn crs(b-a,c-a);\n}\n\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n\n//no point in edges\nvc<cm> convex(vc<cm> s){\n\tswap(s[0],*min_element(all(s),cmcmp));\n\tsort(s.bg+1,s.ed,[&](cm a,cm b){\n\t\tint c=ccw(s[0],a,b);\n\t\tif(c)return c==1;\n\t\telse return bet(s[0],a,b)==2;\n\t});\n\tvc<cm> t;\n\trep(i,s.size()){\n\t\tint ss;\n\t\twhile((ss=t.size())>=2){\n\t\t\tcm a=t[ss-2];\n\t\t\tcm b=t[ss-1];\n\t\t\tcm c=s[i];\n\t\t\tif(ccw(a,b,c)>0)\n\t\t\t\tbreak;\n\t\t\tt.pop_back();\n\t\t}\n\t\tt.pb(s[i]);\n\t}\n\treturn t;\n}\n\ncm readcm(){\n\tld a,b;\n\tchar c;\n\tcin>>a>>c>>b;\n\treturn cm(a,b);\n}\n\nld readld(){\n\tld a;\n\tcin>>a;\n\treturn a;\n}\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\twhile(1){\n\t\tint n=read();\n\t\tif(n==0)break;\n\t\tvc<cm> s(n);\n\t\trep(i,n)\n\t\t\ts[i]=readcm();\n\t\tcout<<n-convex(s).size()<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\nusing namespace std;\n#ifndef FAST_IO\n #define IOS ios_base::sync_with_stdio(false);cin.tie(nullptr);\n#endif\n\n#define FILE_IO freopen(\"input.txt\",\"r\",stdin)\n#define int long long\n#define f first\n#define s second\n#define endl '\\n'\n#define all(c) c.begin(),c.end()\n#define bp __builtin_popcount\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e18;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>void print(T t){for(auto &it : t)cout<<it<<\" \";}\ninline int powerexp(int a, int b, int m = MOD){ int res = 1;while(b){if(b&1)res = res * a % m;a = a * a % m,b >>= 1;}return res % m;}\ninline int modinv(int a){ return powerexp(a,MOD-2,MOD);}\ninline int lcm(int a, int b){ int g = __gcd(a,b);return a/g*b;}\ninline int add(int x, int y){ x += y; if (x >= MOD) x -=  MOD; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % MOD;}\ninline int sub(int x, int y){ x -= y; if (x<0) x += MOD; return x ;}\n\n//-------------------< start here >-------------------------// \n\nstatic const double PI = acos(-1);\n#define EPS 1e-10\n\n/*\n * yutaka geometry template inspired\n*/\nclass point{\n  public:\n  double x, y;\n  \n  point (double x = 0, double y = 0) : x(x), y(y) {}\n  point operator + (point p){ return point(x + p.x, y + p. y);}\n  point operator - (point p){ return point(x - p.x, y - p.y);}\n  point operator * (double a){ return point(x * a, y *a );}\n  point operator / (double a) { return point(x / a, y /a );}\n  bool operator < (const point &p) const {\n\t return x != p.x ? x < p.x : y < p.y; \n   }\n  bool operator == (const point &p){\n\treturn fabs(x - p. x) < EPS && fabs(y - p.y) < EPS; \n   }\n  double hypot(){ return x * x + y * y;}\n  double abs(){ return sqrt(hypot());}\t\n};\n\ndouble norm(point a){ return a.x * a.x + a.y * a.y;}\ndouble abs(point a){ return (double)sqrt(norm(a));}\npoint polar(double a, double r){ return point(cos(r) * a, sin(r) * a);}\ndouble dot_product(point a, point b){ return a.x * b.x + a.y * b. y;}\ndouble cross_product(point a, point b){ return a.x * b.y - a.y * b. x;}\n\nbool coordinatecmp(const point &p1, const point &p2){\n  if (p1.y == p2.y) return p1.x < p2.x;\n  else return p1.y < p2.y;\n  //overloaded comparison function\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if (cross_product(a, b) > EPS) return 1; //anti clock\n  if (cross_product(a, b) < EPS) return -1; // clock\n  else return 0; // on same segment\t\n}\n\n/*\n * Polar Sort \n * */\nclass PolarAngCmp{\n  public:\n  point p;\n  PolarAngCmp( point p) : p(p) {}\n  bool operator() (const point &p1, const point &p2) {\n\t  point a = point(p1.x - p.x, p1.y - p.y);\n\t  point b = point(p2.x - p.x, p2.y - p.y);\n\t  double c = cross_product(a, b);\n\t  if (c == 0) return abs(a) < abs(b);\n\t  return c > 0;\n  }\n};\n\nvector<point> GrahamScan(vector<point> s){\n  // for finding convex hull\n  vector<point> hull;\n  point x = *min_element(s.begin(), s.end(), coordinatecmp);\n  sort(s.begin(), s.end(), PolarAngCmp(x));\n  for(int i = 0; i <= 2; i++) hull.push_back(s[i]);\n  for(int i = 3; i < (int)s.size(); i++){\n\t  while(hull.size() >= 2 && ccw(hull[(int)hull.size() - 2], hull.back(), s[i]) == -1 ){\n\t\t hull.pop_back();\n\t }\n\t\t hull.push_back(s[i]);  \n\t}\n  return hull;\t\n}\n\nvoid solve(){\n   vector<point> pol, hull;\n   char ch;\n   int n;\n   while(cin >> n && n){\n\t   pol.clear();\n\t   double x, y;\n\t   for(int  i = 0; i < n; i++){\n\t\t   cin >> x >> ch >> y;\n\t\t   pol.push_back(point(x, y));  \n\t\t }\n\t  hull = GrahamScan(pol);\n\t  int ret = (int)pol.size() - (int)hull.size();\n\t  cout << ret << endl;  \n\t }\t\n}\n\n//-----------------------------\n//comment from here for TOPCODER \nint32_t main(){\n   IOS;\n   solve();\n   //find();\n   #ifdef LOCAL_DEFINE\n   cerr << \"time elapsed \" << (double)clock()/CLOCKS_PER_SEC << endl;\n   #endif\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\nconst double EPS = 1e-10;\n\nnamespace std{\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tdouble cross(const P& a, const P& b) {\n\t\treturn imag(conj(a)*b);\n\t}\n\tdouble dot(const P& a, const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n}\n\n//ツ点ツづ個進ツ行ツ陛サツ古シ\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//ツ禿環陛ッ\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  int n;\n\tdouble a,b;\n\tvector<P> points;\n\twhile(true){\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tpoints.push_back(P(a,b));\n\t\t}\n\n\t\tvector<P> hull = convex_hull(points);\n\t\tcout<<n-hull.size()<<endl;\n\t\t/*\n\n\t\tfor(int i = 0;i<points.size();i++){\n\t\t\tprintf(\"%lf %lf\\n\",points[i].real(),points[i].imag());\n\t\t}\n\t\tcout<<endl;\n\t\tfor(int i = 0;i<hull.size();i++){\n\t\t\tprintf(\"%lf %lf\\n\",hull[i].real(),hull[i].imag());\n\t\t}\n\t\t\tprintf(\"%lf %lf\\n\",hull[0].real(),hull[0].imag());\n\t\t*/\n\n\t}\n\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define PI (acos(-1.0))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define POSARG(a) (arg(a) > 0.0? arg(a) : 2.0*PI + arg(a))\n\nint n;\nint re;\n\nvector<P>::iterator convex_hull(vector<P>& vc)\n{\n\tint undermost = 0;\n\t\n\tfor(int i = 1; i < (int)vc.size(); i++)\n\t{\n\t\tif( vc[i].imag() < vc[undermost].imag() \n\t\t\t||( EQ(vc[undermost].imag(), vc[i].imag()) && vc[undermost].real() < vc[i].real() ) )\n\t\t{\n\t\t\tundermost = i;\n\t\t}\n\t}\n\t\n\tswap(vc[0], vc[undermost]);\n\t\n\tdouble nowarg = 0.0;\n\tint j;\n\t\n\tfor( j = 0; j < (int)vc.size()-1; j++)\n\t{\n\t\tdouble minarg = 2.0*PI;\n\t\tdouble maxdst = 0.0;\n\t\tint candidx = 0;\n\t\t\n\t\tfor(int i = j+1; i < (int)vc.size(); i++)\n\t\t{\n\t\t\tdouble newarg = POSARG(vc[i] - vc[j]);\n\t\t\tdouble newdst = abs(vc[i] - vc[j]);\n\t\t\t\n\t\t\tif( newarg > nowarg)\n\t\t\t\tif( newarg < minarg || ( EQ(newarg, minarg) && newdst > maxdst) )\n\t\t\t\t{\n\t\t\t\t\tminarg = newarg;\n\t\t\t\t\tmaxdst = newdst;\n\t\t\t\t\tcandidx = i;\n\t\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif(candidx == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswap(vc[j+1], vc[candidx]);\n\t\t\tnowarg = minarg;\n\t\t}\n\t}\n\t\n\tre = j+1;\n\treturn vc.begin()+j+1;\n}\n\n\nint solve(vector<P> vc)\n{\n\tvector<P>::iterator r = convex_hull(vc);\n\treturn vc.size()-re;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> vc;\n\t\tvc.clear();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tchar c;\n\t\t\tdouble a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> c;\n\t\t\tcin >> b;\n\t\t\tvc.push_back(P(a, b));\n\t\t}\n\t\t\n\t\tcout << solve(vc) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\nconst P INF = P(-1E8,-1E8);\nvector<P> v;\nint N;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool operator > (const P& a, const P& b){\n    return fabs(real(a)-real(b)) > EPS ? imag(a) > imag(b) : real(a) > real(b);\n  }\n}\n\n//  a -> b -> c ?????????????????? b -> c ?????????\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //???????¨???????\n  if(cross(b,c) < -EPS) return -1; // ????¨???????\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b ????????´???\n  if(norm(b) < norm(c)) return -2; // a -- b -- c ????????´???\n  return 0; // a -- c -- b ????????´????\n}\n\ndouble getAngle(P a,P b){\n  return atan2(b.imag()-a.imag(),b.real()-a.real());\n}\n\nP getNextP(P a,P b,int *flag){\n  double ang = getAngle(a,b);\n  if( ang < -EPS ) 2*M_PI + ang;\n  int p=-1;\n  double pa=0;\n  // cout << ang*180.0/M_PI << endl;\n  for(int i=0;i<N;i++){\n    if( ccw( a, b, v[i] ) == -1 ){\n      double na = getAngle(b,v[i]);\n      if( na < -EPS ) 2 * M_PI + ang;\n      // cout << b << \" -> \" << v[i] << \" \"<< na/M_PI*180.0 << endl;\n      double x = abs( ang - na );\n      double y = abs( ang - pa );\n      if( x > M_PI ) x = abs( ang + 2 * M_PI - na );\n      if( y > M_PI ) y = abs( ang + 2 * M_PI - pa );\n      if( p == -1 || x < y  ){\n        pa = na;\n        p = i;\n      }\n    }\n  }\n  if( flag[p] ) return INF;\n  flag[p] = 1;\n  return v[p];\n}\n\nint main(){\n  while( cin >> N && N ){\n    int px=0;\n    v.clear();\n    for(int i=0;i<N;i++){\n      double x,y;\n      scanf(\"%lf,%lf\",&x,&y);\n      v.push_back( P(x,y) );\n      //  cout << v[i] << endl;\n      if( v[i].real() < v[px].real() ) \n        px = i;\n    }\n\n    if(N < 4 ){\n      cout << 0 << endl;\n    } else {\n      P now = v[px];\n      P vn = v[px] + P(0,-1.0);\n      int flag[111]={};\n      flag[px] = 1;\n      vn = getNextP(vn,v[px],flag);\n      while(INF/10.0 < vn){\n        // cout << now << \" \"<< vn << endl;\n        P nex = getNextP(now,vn,flag);\n        now = vn; vn = nex;\n      }\n      int res = 0;\n      for(int i=0;i<N;i++)\n        if(!flag[i]) res++;      \n      printf(\"%d\\n\",res);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (Point a, Point b) {\n    if (a.X != b.X) return a.X < b.X;\n    return a.Y < b.Y;\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nbool ccw(Point a, Point b, Point c) {\n  return cross(c-b, a-b) > 0.0;\n}\n\nvector<Point> ps;\n\nvector<Point> Graham(vector<Point> &ps) {\n  vector<Point> qs;\n\n  qs.resize(ps.size()*2);\n  sort(ps.begin(), ps.end());\n\n  int k = 0;\n  for (int i=0; i<ps.size(); i++) {\n    while (k > 1 && !ccw(qs[k-2], qs[k-1], ps[i])) --k;\n    qs[k++] = ps[i];\n  }\n\n  int _k = k;\n  for (int i=ps.size()-1; i>=0; i--) {\n    while (k > _k && !ccw(qs[k-2], qs[k-1], ps[i])) --k;\n    qs[k++] = ps[i];\n  }\n\n  qs.resize(k-1);\n  return qs;\n}\n\nint main() {\n  while (1) {\n    int n;\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    ps.resize(n);\n    for (int i=0; i<n; i++) {\n      double x, y;\n      scanf(\"%lf,%lf\", &x, &y);\n      ps[i] = Point(x, y);\n    }\n\n    vector<Point> convs = Graham(ps);\n    printf(\"%d\\n\", n-(int)convs.size());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<sstream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<queue>\n#include<set>\n#include<numeric>\n\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define np string::npos\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define repc(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto n :(array))\n\ntypedef long long ll ;\ntypedef vector<int> vi ;\ntypedef vector<ll> vl ;\ntypedef map<string,int> dict;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\ndouble eps = 1e-10 ;\n\ntemplate <typename T>\nvoid out(vector < T > v)\n{\n  for(size_t i = 0; i < v.size(); i++)\n  {\n    debug(v[i]);\n  }\n}\n\ntemplate<typename T>\nstring ntos( T i ) {\n  ostringstream s ;\n  s << i ;\n  return s.str() ;\n}\n\ntemplate<typename T>\nT ston(string str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\n\ndouble EPS = 1e-10;\ndouble add(double a, double b){\n  if(abs(a+b) < EPS* (abs(a) + abs(b))) return 0;\n  return a+b;\n}\n\nstruct P{\n  double x,y;\n  P(){}\n  P(double _x,double _y):x(_x),y(_y){}\n  P operator + (P p){\n    return P(add(x,p.x) ,add(y,p.y));\n  }\n  P operator - (P p){\n    return P(add(x,-p.x) ,add(y,-p.y));\n  }\n  P operator * (double d){\n    return P(x * d,y * d);\n  }\n  double dot(P p){\n    return add(x * p.x,y*p.y);\n  }\n  double det(P p){\n    return add(x*p.y,-y*p.x);\n  }\n};\n//???????????????????????¨?????????\nbool on_seg(P p1,P p2,P q){\n  return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n//???????°????\nP intersection(P p1, P p2, P q1,P q2){\n  return p1 + (p2-p1) * ((q2 - q1).det(q1-p1) / (q2 - q1).det(p2-p1)) ;\n}\n\nbool cmp_x(const P& p, const P& q){\n  if(p.x != q.x) return p.x < q.x;\n  return p.y < q.y;\n}\nint ans = 0;\nvector<P> convex_hull(P *ps,int n){\n  sort(ps,ps+n,cmp_x);\n  int k = 0;\n  vector<P> qs(n*2);\n  rep(i,n){\n    while(k > 1 && (qs[k-1] -qs[k-2]).det(ps[i] - qs[k-1]) <= 0){\n      k--;\n    }\n    qs[k++] = ps[i];\n  }\n  for(int i = n-2,t = k; i >= 0; i--){\n    while(k>t && (qs[k-1] - qs[k-2]).det(ps[i]-qs[k-1]) <= 0){\n      k--;\n    }\n    qs[k++] = ps[i] ;\n  }\n  qs.resize(k-1);\n  cout << n-qs.size() << endl;\n  return qs;\n}\n\ndouble dist(P p,P q){\n  return (p - q).dot(p - q);\n}\n\nconstexpr int MAX_N = 100000;\nint N;\nP ps[MAX_N];\n\nvoid Solve(){\n  vector<P> qs = convex_hull(ps,N);\n  double res = 0;\n  rep(i,qs.size()){\n    rep(j,i){\n      res = max(res,dist(qs[i],qs[j]));\n    }\n  }\n  cout << res << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  double x,y;\n  char c;\n  while(cin >> N){\n    if(N == 0){\n      break;\n    }\n    rep(i,N){\n      cin >> x >>c >> y;\n      ps[i] = P(x,y);\n    }\n    convex_hull(ps,N);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define loop for(;;)\n#define inf (1e9)\n#define eps (1e-9)\n#define trace(var) cerr<<\">>> \"<<#var<<\" = \"<<var<<endl;\ntypedef long long Integer;\ntypedef long double Real;\ntypedef pair<Real, Real> P; // Point\ntypedef pair<P, P> L; // segment or line\nconst Real PI = acos(-1);\n\ntemplate<class S, class T> inline\nostream& operator<<(ostream&os, pair<S,T> p) {\n  os << '(' << p.first << \", \" << p.second << ')';\n  return os;\n}\n\ntemplate<class T> inline\nostream& operator<<(ostream&os, vector<T> v) {\n  if (v.size() == 0) {\n    os << \"(empty)\";\n    return os;\n  }\n  os << v[0];\n  for (int i=1, len=v.size(); i<len; ++i) os << ' ' << v[i];\n  return os;\n}\n\ntemplate<class T> inline\nistream& operator>>(istream&is, vector<T>&v) {\n  rep (i, v.size()) is >> v[i];\n  return is;\n}\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = {  0, -1, 0, 1 };\n\n/* inner dot */\nReal dot(P&a, P&b) {\n  return a.first * b.first + a.second * b.second;\n}\nReal operator*(P&a, P&b) {\n  return a.first * b.first + a.second * b.second;\n}\n\n/* scalar multiple */\nP operator*(P a, Real c) {\n  return {c * a.first, c * a.second};\n}\nP operator*(Real c, P a) {\n  return {c * a.first, c * a.second};\n}\n\nP operator/(P a, Real d) {\n  return {a.first / d, a.second / d};\n}\n\nReal det(P a, P b) {\n  return a.first * b.second - a.second * b.first;\n}\n\n/* vector operator */\nP operator+(P a, P b) {\n  return {a.first + b.first, a.second + b.second};\n}\n\nP operator-(P a) {\n  return {-a.first, -a.second};\n}\n\nP operator-(P a, P b) {\n  return {a.first - b.first, a.second - b.second};\n}\n\n/* distance */\nReal Manhattan(P a, P b) {\n  return abs(a.first - b.first) + abs(a.second - b.second);\n}\nReal Euclidean(P a, P b) {\n  P p = a - b;\n  return sqrt(p.first*p.first + p.second*p.second);\n}\n\n/* equality with eps (default: 1e-9) */\nbool eq(Real x, Real y) {\n  return abs(x - y) < eps;\n}\nbool operator==(P a, P b) {\n  return eq(a.first, b.first) && eq(a.second, b.second);\n}\n\nint sign(Real a) {\n  if (eq(a, 0)) return 0;\n  return a > 0 ? 1 : -1;\n}\n\nReal magnitude(P p) {\n  return sqrt(p.first*p.first + p.second*p.second);\n}\n\nReal arg(P a, P b) {\n  Real x = dot(a, b) / magnitude(a) / magnitude(b);\n  x = min<Real>(1, max<Real>(-1, x));\n  return acos(x);\n}\n\nvector<P> covex_hull(vector<P> ps) {\n  sort(begin(ps), end(ps));\n  const int n = ps.size();\n  vector<P> top, bot;\n  { // top-hull\n    rep (i, n) {\n      while (true) {\n        int m = top.size();\n        if (m > 1 and det(ps[i] - top[m-2], top[m-1] - top[m-2]) >= 0) {\n          top.pop_back();\n        } else break;\n      }\n      top.push_back(ps[i]);\n    }\n  }\n  { // bottom-hull\n    rep (i, n) ps[i].second *= -1;\n    sort(begin(ps), end(ps));\n    rep (i, n) {\n      while (true) {\n        int m = bot.size();\n        if (m > 1 and det(ps[i] - bot[m-2], bot[m-1] - bot[m-2]) >= 0) {\n          bot.pop_back();\n        } else break;\n      }\n      bot.push_back(ps[i]);\n    }\n    for (P&p: bot) p.second *= -1;\n  }\n  // trace(top); trace(bot);\n  vector<P> ret;\n  { // merge\n    for (auto&p: top) ret.push_back(p);\n    for (auto&p: bot) ret.push_back(p);\n    sort(begin(ret), end(ret));\n    ret.erase(unique(begin(ret), end(ret)), end(ret));\n  }\n  return ret;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout.setf(ios::fixed);\n  cout.precision(10);\n\n  loop {\n    int n; cin >> n;\n    if (n == 0) break;\n    vector<P> ps;\n    rep (i, n) {\n      Real x, y; char comma;\n      cin >> x >> comma >> y;\n      ps.push_back(P(x, y));\n    }\n    cout << (ps.size() - covex_hull(ps).size()) << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\n\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tBOOL online(const P &p){\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]);\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\t\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool includeOnLine = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && (ccw(r[k-2], r[k-1], at(i)) < 1 || \n\t\t\t\t\t!includeOnLine && ccw(r[k-2], r[k-1], at(i)) == 2)) k--;\n\t\t\tint t = 1;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && (ccw(r[k-2], r[k-1], at(i)) < 1 || \n\t\t\t\t\t!includeOnLine && ccw(r[k-2], r[k-1], at(i)) == 2)) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(scanf(\"%d\", &n), n){\n\t\tG g;\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tscanf(\"%lf,%lf\", &p.X, &p.Y);\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcout << g.size() - g.convex_hull(true).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint main(void){\n    int n;\n    bool deb=0;\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        double p[2][200];\n        double xmin=10000.0;\n        bool flg[200]={0};\n        int xi,first;\n        for(int i=0;i<n;i++){\n            scanf(\"%lf,%lf\",&p[0][i],&p[1][i]);\n            if(xmin>p[0][i])xmin=p[0][i],first=xi=i;\n            if(deb)cout<<\"first=\"<<first<<endl;\n        }\n        if(deb)for(int i=0;i<n;i++){\n            cout<<i<<\" ... (\"<<p[0][i]<<\",\"<<p[1][i]<<\")\"<<endl;\n        }\n        if(deb)cout<<\".\"<<endl;\n        double r=10000;\n        double next=270,ith=1000,now=0;\n        int nextnum;\n        int q=n;\n        while(q--){\n            for(int i=0;i<n;i++){\n                if(!flg[i]&&i!=xi){\n                    if(deb)cout<<i<<\"******\"<<endl;\n                    double xd=p[0][i]-p[0][xi],yd=p[1][i]-p[1][xi];\n                    double rd=hypot(xd,yd);\n                    now=atan2(yd/rd,xd/rd)/M_PI*180;\n                    if(deb)cout<<\"xd=\"<<xd<<\",yd=\"<<yd<<endl;\n                    if(deb)cout<<\"rd=\"<<rd<<endl;\n                    if(deb)cout<<\"atan2=\"<<now<<endl;\n                    if(deb)cout<<\"next-now=\"<<fabs(next-now)<<endl;\n                    if(fabs(next-now)<ith){\n                        nextnum=i;\n                        ith=fabs(next-now);\n                        if(deb)cout<<\"///\"<<nextnum<<endl;\n                    }\n                }\n            }\n            flg[nextnum]=1;\n            if(deb)cout<<\"<\"<<nextnum<<\">\"<<endl<<endl;\n            xi=nextnum;\n            next=now;\n            ith=1000;\n            if(flg[first])break;\n        }\n        int f=0;\n        for(int i=0;i<n;i++){\n            if(!flg[i])f++;\n            if(deb)cout<<\"flg[\"<<i<<\"] = \"<<flg[i]<<endl;\n        }\n        cout<<f<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "typedef struct{double x,y,k;}w;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){double k,t;for(;~scanf(\"%d\",&n),j=n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++){k=o(0,i,100);t=(p[i].x-b.x)*(p[i].x-b.x)+(p[i].y-b.y)*(p[i].y-b.y);k*=k/t;if(b.x>p[i].x)k=-k;p[i].k=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C++",
    "code": "//Enclose Pins with a Rubber Band\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> p;\n\nnamespace std{\n  bool operator<(const p& a, const p& b){\n    return real(a)!=real(b) ? real(a)<real(b) : imag(a)<imag(b);\n  }\n}\ndouble cross(const p&a, const p& b){\n  return imag(conj(a)*b);\n}\ndouble dot(const p& a, const p& b){\n  return real(conj(a)*b);\n}\nint ccw(p a, p b, p c){\n  b-=a; c-=a;\n  if(cross(b,c)>0)return +1;\n  if(cross(b,c)<0)return -1;\n  if(dot(b,c)<0)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\nvector<p> convex_hull(vector<p> ps){\n  int n=ps.size(), k=0;\n  sort(ps.begin(), ps.end());\n  vector<p> ch(2*n);\n  for(int i=0; i<n; ch[k++]=ps[i++])\n    while(k>=2 && ccw(ch[k-2], ch[k-1], ps[i])<=0) --k;\n  for(int i=n-2, t=k+1; i>=0; ch[k++]=ps[i--])\n    while(k>=t&&ccw(ch[k-2], ch[k-1], ps[i])<=0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  int n;\n  complex<double> pt;\n  vector<p> ps;\n  while(true){\n    cin>>n;\n    ps.clear();\n    if(n==0)break;\n    for(int i=0; i<n; i++){\n      scanf(\"%lf,%lf\", &real(pt), &imag(pt));\n      ps.push_back(pt);\n    }\n    cout<<n-convex_hull(ps).size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <sstream>\n#include <fstream>\n#include <tuple>\n#include <set>\n#include <functional> \n#include <string.h>\n\n#define X first\n#define Y second\n#define MP make_pair\n#define MT make_tuple\n#define FOR(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define REP(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\ntypedef long long ll;\ntypedef std::pair<int, int> pii;\ntypedef std::pair<ll, ll > pll;\nusing namespace std;\nconst int MAX = 101;\nconst double PI = 3.1415926535897932384;\n\ntemplate<class T, class U>\nvoid convert(T &t, U &u){\n\tstringstream ss;\n\tss << t;\n\tss >> u;\n}\n\ndouble cross(pair<double, double> &a, pair<double, double> &b, pair<double, double> &o){\n\treturn (a.first - o.first) * (b.second - o.second) - (b.first - o.first) * (a.second - o.second);\n}\n\nint main(){\n\tint n;\n\twhile (cin >> n && n != 0){\n\t\tvector<pair<double, double> > tb;\n\t\tFOR(i, n){\n\t\t\tchar c;\n\t\t\tdouble x, y; \n\t\t\tcin >> x >> c >> y;\n\t\t\ttb.push_back(MP(x, y));\n\t\t}\n\t\tsort(tb.begin(), tb.end());\n\n\t\tvector<pair<double, double> > ans(n * 2, MP(0, 0));\n\t\tint k = 0; //使ってる三点\n\t\t//常に2点目が使えるかどうかを判定してる\n\t\t//3点が凹になってる場合は、答えに入れた2点目を外して、次の3点を選択し直す\n\t\tfor (int i = 0; i < tb.size(); ans[k++] = tb[i++]){\n\t\t\twhile (k >= 2 && cross(ans[k - 2], ans[k - 1], tb[i]) <= 0){ k--; }\n\t\t}\n\n\t\tfor (int i = n - 2, t = k + 1; i >= 0; ans[k++] = tb[i--]){\n\t\t\twhile (k >= t && cross(ans[k - 2], ans[k - 1], tb[i]) <= 0){ k--; }\n\t\t}\n\n\t\tans.resize(k - 1);\n\t\tcout << n - ans.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)\treturn +1;\t// counter clockwise\n\tif (cross(b, c) < 0)\treturn -1;\t// clockwise\n\tif (dot(b, c) < 0)\t\treturn +2;\t// c--a--b on line\n\tif (norm(b) < norm(c))\treturn -2;\t// a--b--c on line\n\treturn 0;\n}\nvector<P> convex_hull(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2 * n);\n\tfor (int i = 0; i < n; i++, k++) { // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\t\tch[k] = ps[i];\n\t}\n\tfor (int i = n-2, t = k + 1; i >= 0; k++, i--) { // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\t\tch[k] = ps[i];\n\t}\n\tch.resize(k - 1);\n\treturn ch;\n}\nint main () {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<P> points(n);\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tpoints[i] = P(x, y);\n\t\t}\n\t\tcout << n - convex_hull(points).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<float.h>\n#include<algorithm>\nint main()\n{\n\tint n,i,j,k;\n\tdouble x[100],y[100],vx,vy,dx,dy,s,t;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tint a=n,f[100]={};\n\t\tfor(i=0;i<n;++i)scanf(\"%lf,%lf\",x+i,y+i);\n\t\tk=std::min_element(y,y+n)-y;\n\t\tvx=1,vy=0;\n\t\tfor(;;)\n\t\t{\n\t\t\tif(f[k]++)break;\n\t\t\t--a;\n\t\t\tfor(s=-DBL_MAX,i=0;i<n;++i)\n\t\t\t{\n\t\t\t\tif(k-i)\t\n\t\t\t\t{\n\t\t\t\t\tdx=x[i]-x[k];\n\t\t\t\t\tdy=y[i]-y[k];\n\t\t\t\t\tt=(vx*dx+vy*dy)/hypot(dx,dy);\n\t\t\t\t\tif(s<t)s=t,j=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvx=x[j]-x[k];\n\t\t\tvy=y[j]-y[k];\n\t\t\tk=j;\n\t\t}\n\t\tprintf(\"%d\\n\",a);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#include <complex>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\n// 許容する誤差ε\n#define EPS (1e-10)\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<double,double> PP;\n// 反時計順にソート\nbool cmp (P a, P b )\n{\n\tdouble arga = arg (a );\n\tdouble argb = arg (b );\n\tif (!EQ (arga, argb ) ){\n\t\treturn arga < argb;\n\t} // end if\n\n\treturn abs (a ) > abs (b );\n}\n/*\nbool cmp (P a, P b )\n{\n\tdouble cosa = a.real()/abs (a );\t\t\n\tdouble sina = a.imag()/abs (a );\n\tdouble cosb = b.real()/abs (b );\n\tdouble sinb = b.imag()/abs (b );\n\tif (sina >= 0. && sinb >= 0. ){\n\t\treturn cosa > cosb;\n\t}else\n\tif (sina < 0. && sinb < 0. ){\n\t\treturn cosa < cosb;\n\t}else\n\tif (sina >= 0. && sinb < 0. ){\n\t\treturn sina > sinb;\n\t}else\n\tif (sina < 0. && sinb >= 0. ){\n\t\treturn sina < sinb;\n\t} // end if\n\n\treturn abs (a ) > abs (b );\n}\n*/\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.EPRB\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tvector<P> p (n );\n\t\trep (i, n ){\n\t\t\tdouble x, y;\n\t\t\tscanf (\"%lf,%lf\", &x, &y );\n\t\t\tp[i].real() = x; p[i].imag() = y;\n\t\t} // end rep\n\t\t\t\t\t\t\t\t\t\t\n\t\t// 原点回りに反時計回りにソート\n\t\tsort (ALL (p ), cmp );\n/*\n\t\trep (i, n ){\n\t\t\tcerr << '(' << p[i].real() << ',' << p[i].imag() << ')' << endl;\n\t\t} // end rep\n*/\n\t\tset<PP> convex_hull; convex_hull.clear();\n\t\tfor (int i = 0; i < n; i++ ){\n\t\t\tfor (int j = i+1; j < n; j++ ){\n\t\t\t\tbool ok = true;\n\t\t\t\trep (k, n ){\n\t\t\t\t\tif (k == i || k == j ) continue;\n\t\t\t\t\tif (cross (p[j] - p[i], p[k] - p[i] ) > 0. ) continue;\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t} // end rep\n\t\t\t\tif (ok ){\n\t\t\t\t\tconvex_hull.insert (PP (p[i].real(), p[i].imag() ) );\n\t\t\t\t\tconvex_hull.insert (PP (p[j].real(), p[j].imag() ) );\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end for\n\t\tprintf (\"%d\\n\", n - (int)convex_hull.size() );\n/*\n\t\tset<PP>::iterator it = convex_hull.begin();\n\t\tfor (; it != convex_hull.end(); it++ ){\n\t\t\tcerr << '(' << (*it).first << ',' << (*it).second << ')' << endl;\n\t\t} // end for\n*/\t\t\n\t} // end loop\n\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<double, double> P;\n\nint cross(P a, P b, P c) {\n  int x0 = b.first - a.first, y0 = b.second - a.second;\n  int x1 = c.first - a.first, y1 = c.second - a.second;\n  return x0*y1 - x1*y0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  sort(ps.begin(), ps.end());\n  int n = ps.size();\n  vector<P> qs(2*n);\n  int k = 0;\n  for(int i=0; i<n; ++i) {\n    while(k>1 && cross(qs[k-2], qs[k-1], ps[i])<=0) --k;\n    qs[k++] = ps[i];\n  }\n  int t = k;\n  for(int i=n-1; i>=0; --i) {\n    while(k>t && cross(qs[k-2], qs[k-1], ps[i])<=0) --k;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k);\n  return qs;\n}\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    vector<P> ps, qs;\n    for(int i=0; i<n; ++i) {\n      double x, y; char dum;\n      cin >> x >> dum >> y;\n      ps.push_back(P(x, y));\n    }\n    qs = convex_hull(ps);\n    cout << (n - qs.size() + 1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define EPS (1e-8)\n\ntypedef complex<double> p;\n\ndouble cross(p a, p b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<p> point(n);\n\t\tREP(i, n) {\n\t\t\tdouble a, b;\n\t\t\tscanf(\"%lf,%lf\", &a, &b);\n\t\t\tpoint[i] = p(a, b);\n\t\t}\n\t\t\n\t\tvector<bool> done(n, false);\n\t\tREP(i, n) FOR(j, i + 1, n) FOR(k, j + 1, n) {\n\t\t\tif (done[i] || done[j] || done[k]) continue;\n\t\t\tp now[4];\n\t\t\tnow[0] = point[i]; now[1] = point[j]; now[2] = point[k];\n\t\t\t\n\t\t\tREP(l, n) {\n\t\t\t\tif (l == i || l == j || l == k || done[i] || done[j] || done[k]) continue;\n\t\t\t\tnow[3] = point[l];\n\t\t\t\t\n\t\t\t\tint cnt = 0;\n\t\t\t\tREP(m, 3) {\n\t\t\t\t\tp v[2];\n\t\t\t\t\tv[0] = now[(m + 1) % 3] - now[m];\n\t\t\t\t\tv[1] = now[3] - now[m];\n\t\t\t\t\tif (cross(v[0], v[1]) < -EPS) cnt++;\n\t\t\t\t}\n\t\t\t\tif (cnt == 0 || cnt == 3) done[l] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tREP(i, n) if (done[i]) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double, double> P;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(void){\n  int n;\n  while(cin>>n){\n    if(n==0) break;\n    double x,y;\n    vector<P> point;\n    REP(i,n){\n      scanf(\"%lf,%lf\",&x,&y);\n      point.push_back(P(y,x));\n    }\n    sort(point.begin(),point.end());\n    reverse(point.begin(),point.end());\n    REP(i,point.size()){\n      swap(point[i].first,point[i].second);\n    }\n    P f,n;\n    double arg;\n    f = point[0];\n    vector<pair<double,P> > tmp;\n    REP(i,point.size())if(point[i]!=f){\n      arg = atan2(point[i].second-f.second,point[i].first-f.first);\n      tmp.push_back(pair<double,P>(arg,point[i]));\n    }\n    sort(tmp.begin(),tmp.end());\n    n = tmp[0].second;\n    int ans = 2;\n    arg = tmp[0].first;\n    while(n!=f){\n      double arg2;\n      vector<pair<double,P> > argvec;\n      REP(i,point.size()){\n        if(n==point[i]) continue;\n        int nx = point[i].first; int ny = point[i].second;\n        arg2 = atan2(ny-n.second, nx-n.first);\n        argvec.push_back(pair<double,P>(arg2,point[i]));\n      }\n      vector<pair<double,P> >::iterator it;\n      sort(argvec.begin(),argvec.end());\n      it = lower_bound(argvec.begin(),argvec.end(),pair<double,P>(arg,n));\n      if(it==argvec.end()) it = argvec.begin();\n      if(f==(*it).second){\n        cout<<point.size()-ans<<endl;\n        break;\n      }else{\n        arg = (*it).first;\n        n = (*it).second;\n        ans++;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <climits>\n#include <cmath>\n \n// 許容する誤差ε\n#define EPS (1e-10)\n\n//浮動小数点演算の誤差を考慮した比較を行うマクロ\n//等しい(=)　!=を使いたい場合は、!EQとすればよい\n#define EQ(x,y) (fabs((x) - (y)) < EPS)\n//小なり(<)\n#define LT(x,y) ((x) - (y) <= -EPS)\n//小なりイコール(<=)\n#define LE(x,y) ((x) - (y) < EPS)\n//大なり(>)\n#define GT(x,y) ((x) - (y) >= EPS)\n//大なりイコール(<)\n#define GE(x,y) ((x) - (y) > -EPS)\n\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n// 円周率\n#define PI (acos(-1.0))\n//　0≦t＜PIの範囲で偏角を求める（通常のarg()は -PI≦t≦PI)\n#define POSARG(a) (arg((a)) > 0.0? arg((a)) : 2.0*PI + arg((a)))\n\nusing namespace std;\ntypedef complex<double> P;\n\nvector<P>::iterator wrapping_convex_hull(vector<P> vc)\n{\n\tint undermost = 0;\n\t\n\tfor(int i = 1; i < (int)vc.size(); i++)\n\t{\n\t\tif( LT(vc[i].imag(), vc[undermost].imag()) \n\t\t\t||( EQ(vc[undermost].imag(), vc[i].imag()) && vc[undermost].real() < vc[i].real() ) )\n\t\t{\n\t\t\tundermost = i;\n\t\t}\n\t}\t//get undermost(and rightmost) point of vc\n\t\n\tswap(vc[0], vc[undermost]); //now, vc[0] is the undermost point of vc\n\n\tdouble nowarg = 0.0;\n\tint j;\n\t\n\tfor( j = 0; j < (int)vc.size()-1; j++)\n\t{\n\t\tdouble minarg = 2.0*PI;\n\t\tdouble maxdst = 0.0;\n\t\tint candidx = 0;\n\t\t\n\t\tfor(int i = j+1; i < (int)vc.size(); i++)\n\t\t{\n\t\t\tdouble newarg = POSARG(vc[i] - vc[j]);\n\t\t\tdouble newdst = abs(vc[i] - vc[j]);\n\t\t\t\n\t\t\tif( GT(newarg, nowarg) )\n\t\t\t\tif( LT(newarg, minarg) || ( EQ(newarg, minarg) && newdst > maxdst) )\n\t\t\t\t{\n\t\t\t\t\tminarg = newarg;\n\t\t\t\t\tmaxdst = newdst;\n\t\t\t\t\tcandidx = i;\n\t\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif(candidx == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswap(vc[j+1], vc[candidx]);\n\t\t\tnowarg = minarg;\n\t\t}\n\t}\n\t\n\treturn vc.begin()+j;\n}\n\nvector<P> solve(vector<P> vc)\n{\n\tvector<P>::iterator it = wrapping_convex_hull(vc);\n\t\n\treturn vector<P>(vc.begin(), it);\n}\n\n\nint main()\n{\n    int n;\n     \n    while(cin >> n, n)\n    {\n        vector<P> vc;\n        vc.clear();\n         \n        for(int i = 0; i < n; i++)\n        {\n            char c;\n            double a, b;\n            cin >> a;\n            cin >> c;\n            cin >> b;\n            vc.push_back(P(a, b));\n        }\n         \n        vector<P> vc2 = solve(vc);\n        cout << int(n - vc2.size()) << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a,const complex<T> &b)\n  {\n    return a.real()== b.real() ? a.imag()<b.imag():a.real()<b.real();\n  }\n  /*\n template<class T> bool operator-(const complex<T> &a)\n  {\n     return complex<T>(real()-a.real(),imag()-a.imag());\n  }\n  */\n};\n\n#define X real()\n#define Y imag()\n\ndouble det(complex<double> a,complex<double> b)\n{\n  return a.X*b.Y-a.Y*b.X;\n}\n\nint count_data(vector<complex<double> > data)\n{\n  sort(data.begin(),data.end());\n  int k=0;\n  vector<complex<double> >ans(data.size()*2);\n  //  for(int i=0;i<data.size();i++)\n  //    {\n  //   cout<<data[i].X<<\" \"<<data[i].Y<<endl;\n  //  }\n  for(int i=0;i<data.size();i++)\n    {\n      while(k>1 && det(ans[k-1]-ans[k-2],data[i]-ans[k-1])<=0)\n\tk--;\n      ans[k++]=data[i];\n    }\n  for(int i=data.size()-2,t=k;i>=0;i--)\n    {\n      while(k>t && det(ans[k-1]-ans[k-2],data[i]-ans[k-1])<=0)\n\tk--;\n      ans[k++]=data[i];\n    }\n  return k-1;\n}\n\n\nint main()\n{\n  int n;\n  for(;cin>>n,n;)\n    {\n      double a,b;\n      char tmp;\n      vector<complex<double> >data;\n      for(int i=0;i<n;i++)\n\t{\n\t  cin>>a>>tmp>>b;\n\t  data.push_back(complex<double>(a,b));\n\t}\n      cout<<n-count_data(data)<<endl;\n    }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nclass point\n{\npublic:\n\tdouble x,y;\n\tbool used;\n\tpoint()\n\t{\n\t\tused=false;\n\t}\n\tvoid input()\n\t{\n\t\tchar c;\n\t\tcin>>x>>c>>y;\n\t}\n};\n\npoint *getmin(vector<point> *p)\n{\n\tint min=0;\n\tfor(int i=0;i<p->size();i++)\n\t{\n\t\tif(p->at(i).x<p->at(min).x)\n\t\t{\n\t\t\tmin=i;\n\t\t}\n\t}\n\treturn &p->at(min);\n}\n\npoint sub(point *a, point *b)\n{\n\tpoint ans;\n\tans.x=a->x-b->x;\n\tans.y=a->y-b->y;\n\treturn ans;\n}\n\ndouble cross(point a, point b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\nbool allleft(point *a, point *b, vector<point> *v)\n{\n\tfor(int i=0;i<v->size();i++)\n\t{\n\t\tif(&v->at(i)!=a&&&v->at(i)!=b)\n\t\t{\n\t\t\tif(cross(sub(b,a),sub(&v->at(i),a))<=0)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\npoint *getnextpoint(point *p,vector<point> *v)\n{\n\tfor(int i=0;i<v->size();i++)\n\t{\n\t\tif(p!=&v->at(i)&&allleft(p,&v->at(i),v))\n\t\t{\n\t\t\treturn &v->at(i);\n\t\t}\n\t}\n}\n\nint solve(vector<point> *p)\n{\n\tpoint *ptr=getmin(p);\n\twhile(ptr->used==false)\n\t{\n\t\tptr->used=true;\n\t\tptr=getnextpoint(ptr,p);\n\t}\n\tint n=0;\n\tfor(int i=0;i<p->size();i++)\n\t{\n\t\tif(p->at(i).used==false)n++;\n\t}\n\treturn n;\n}\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<point> p(n);\n\t\tfor(int i=0;i<n;i++) p[i].input();\n\t\tcout<<solve(&p)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\ntypedef long long ll;\nusing namespace std;\nstruct point_t { double x, y; };\nbool operator < (point_t const & a, point_t const & b) { return make_pair(a.x,a.y) < make_pair(b.x,b.y); }\npoint_t operator + (point_t const & a, point_t const & b) { return { a.x + b.x, a.y + b.y }; }\npoint_t operator - (point_t const & a, point_t const & b) { return { a.x - b.x, a.y - b.y }; }\ndouble cross(point_t const & a, point_t const & b) { return a.x * b.y - a.y * b.x; }\ndouble ccw(point_t const & a, point_t const & b, point_t const & c) { return cross(b - a, c - a); }\nvector<point_t> convex_hull(vector<point_t> ps) {\n    int n = ps.size();\n    sort(ps.begin(), ps.end());\n    vector<point_t> qs;\n    int d = 1;\n    for (int i = 0; i >= 0; i += d) { // lower hull\n        if (i == n-1) d = -1;\n        int k = qs.size();\n        while (k >= 2 and ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            qs.pop_back();\n            k = qs.size();\n        }\n        qs.push_back(ps[i]);\n    }\n    qs.pop_back();\n    return qs;\n}\nint solve(vector<point_t> const & ps) {\n    vector<point_t> qs = convex_hull(ps);\n    return ps.size() - qs.size();\n}\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<point_t> ps(n);\n        char dummy;\n        for (auto && p : ps) cin >> p.x >> dummy >> p.y;\n        cout << solve(ps) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<sstream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<queue>\n#include<set>\n#include<numeric>\n\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define np string::npos\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define repc(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto n :(array))\n\ntypedef long long ll ;\ntypedef vector<int> vi ;\ntypedef vector<ll> vl ;\ntypedef map<string,int> dict;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\ndouble eps = 1e-10 ;\n\ntemplate <typename T>\nvoid out(vector < T > v)\n{\n  for(size_t i = 0; i < v.size(); i++)\n  {\n    debug(v[i]);\n  }\n}\n\ntemplate<typename T>\nstring ntos( T i ) {\n  ostringstream s ;\n  s << i ;\n  return s.str() ;\n}\n\ntemplate<typename T>\nT ston(string str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\n\ndouble EPS = 1e-10;\ndouble add(double a, double b){\n  if(abs(a+b) < EPS* (abs(a) + abs(b))) return 0;\n  return a+b;\n}\n\nstruct P{\n  double x,y;\n  P(){}\n  P(double _x,double _y):x(_x),y(_y){}\n  P operator + (P p){\n    return P(add(x,p.x) ,add(y,p.y));\n  }\n  P operator - (P p){\n    return P(add(x,-p.x) ,add(y,-p.y));\n  }\n  P operator * (double d){\n    return P(x * d,y * d);\n  }\n  double dot(P p){\n    return add(x * p.x,y*p.y);\n  }\n  double det(P p){\n    return add(x*p.y,-y*p.x);\n  }\n};\n//???????????????????????¨?????????\nbool on_seg(P p1,P p2,P q){\n  return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n//???????°????\nP intersection(P p1, P p2, P q1,P q2){\n  return p1 + (p2-p1) * ((q2 - q1).det(q1-p1) / (q2 - q1).det(p2-p1)) ;\n}\n\nbool cmp_x(const P& p, const P& q){\n  if(p.x != q.x) return p.x < q.x;\n  return p.y < q.y;\n}\nint ans = 0;\nvector<P> convex_hull(P *ps,int n){\n  sort(ps,ps+n,cmp_x);\n  int k = 0;\n  vector<P> qs(n*2);\n  rep(i,n){\n    while(k > 1 && (qs[k-1] -qs[k-2]).det(ps[i] - qs[k-1]) <= 0){\n      k--;\n    }\n    qs[k++] = ps[i];\n  }\n  for(int i = n-2,t = k; i >= 0; i--){\n    while(k>t && (qs[k-1] - qs[k-2]).det(ps[i]-qs[k-1]) <= 0){\n      k--;\n    }\n    qs[k++] = ps[i] ;\n  }\n  qs.resize(k-1);\n  cout << n-qs.size() << endl;\n  return qs;\n}\n\ndouble dist(P p,P q){\n  return (p - q).dot(p - q);\n}\n\nconstexpr int MAX_N = 100000;\nint N;\nP ps[MAX_N];\n\nvoid Solve(){\n  vector<P> qs = convex_hull(ps,N);\n  double res = 0;\n  rep(i,qs.size()){\n    rep(j,i){\n      res = max(res,dist(qs[i],qs[j]));\n    }\n  }\n  cout << res << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  double x,y;\n  char c;\n  while(cin >> N){\n    rep(i,N){\n      cin >> x >>c >> y;\n      ps[i] = P(x,y);\n    }\n    convex_hull(ps,N);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define SAFE_DELETE( x ) { if ( x ){ delete x; x = NULL; } }\n\nclass Vector2{\npublic:\n\tVector2() : x( 0 ), y( 0 ), round( false ), check( false ), prev( NULL ), next( NULL ){}\n\tVector2( double aX, double aY ) : round( false ), check( false ), prev( NULL ), next( NULL ){\n\t\tx = aX;\n\t\ty = aY;\n\t}\n\n\tvoid operator=( Vector2& a ){\n\t\tx = a.x;\n\t\ty = a.y;\n\t}\n\n\tbool round, check;\n\tdouble x, y;\n\tVector2 *prev, *next;\n};\n\nclass VecList{\npublic:\n\tVecList() : mSize( 0 ), head( NULL ), tail( NULL ){\n\t\thead = new Vector2;\n\t\ttail = new Vector2;\n\t\thead->next = tail;\n\t\ttail->prev = head;\n\t}\n\t~VecList(){\n\t\tinit();\n\t\tSAFE_DELETE( tail );\n\t\tSAFE_DELETE( head );\n\t}\n\n\tvoid init(){\n\t\tfor ( int i = mSize; i > 0; --i ){\n\t\t\tVector2* a = tail->prev;\n\t\t\ta->prev->next = a->next;\n\t\t\ta->next->prev = a->prev;\n\t\t\tSAFE_DELETE( a );\n\t\t}\n\t\tmSize = 0;\n\t}\n\tvoid pushBack( Vector2 v ){\n\t\tVector2* a = new Vector2( v.x, v.y );\n\t\ta->prev = tail->prev;\n\t\ta->next = tail;\n\t\ta->prev->next = a;\n\t\ta->next->prev = a;\n\t\t++mSize;\n\t}\n\tint cntInner(){\n\t\tint cnt = 0;\n\t\tVector2 *it = head, *a = head->next, *start;\n\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\tit = it->next;\n\t\t\tif ( a->x > it->x ) a = it;\n\t\t}\n\t\tstart = a;\n\n\t\tVector2* b = head->next;\n\t\tif ( b == a ) b = b->next;\n\t\tdo {\n\t\t\tit = head;\n\t\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\t\tit = it->next;\n\t\t\t\tif ( it == a || it == b ) continue;\n\t\t\t\tif ( cross( a, b, it ) < 0 ){\n\t\t\t\t\tb = it;\n\t\t\t\t}\n\t\t\t}\n\t\t\tVector2* t = a;\n\t\t\ta = b;\n\t\t\tb = t;\n\t\t\t++cnt;\n\t\t}while ( !( a == start ) );\n\n\t\treturn mSize - cnt;\n\t}\n\nprivate:\n\tdouble cross( Vector2* a, Vector2* b, Vector2* c ){\n\t\treturn ( b->x - a->x ) * ( c->y - a->y ) - ( b->y - a->y ) * ( c->x - a->x );\n\t}\n\tint mSize;\n\tVector2 *head, *tail;\n};\n\nint main(){\n\tint n;\n\tchar c;\n\tVecList list;\n\n\twhile ( cin >> n && n ){\n\t\tlist.init();\n\t\tVector2 a;\n\t\tfor ( int i = 0; i < n; ++i ){\n\t\t\tcin >> a.x >> c >>a.y;\n\t\t\tlist.pushBack( a );\n\t\t}\n\n\t\tcout << list.cntInner() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 3000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real()*a.real() + a.imag()*a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(cosine);\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size();++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa > now_min) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint main(){\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return 0;\n\t\tvector<complex<double>> go;\n\t\tREP(i, n) {\n\t\t\tdouble a, b;\n\t\t\tscanf(\"%lf,%lf\", &a, &b);\n\t\t\tgo.push_back(complex<double>(a, b));\n\t\t}\n\t\tvector<int> s = convex_hull(go);\n\t\tcout << n - s.size() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n);\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); ++i)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define MIN(p1,p2)          (((p1)<(p2))?(p1):(p2))\n#define MAX(p1,p2)          (((p1)>(p2))?(p1):(p2))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define mp                  make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\n#define pf printf\n#define pr(n) do { cout << #n \" = \" << (n) << endl; } while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#endif\n\ninline D inprd(const P &a, const P &b){ return (conj(a) * b).X; }\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\n\nvoid doit(vector<P> &v){\n    int num = v.size();\n\n    int now = 0;\n    REP(i,num){\n        if(v[now].Y < v[i].Y || (v[now].Y == v[i].Y && v[now].X > v[i].X)){\n            now = i;\n        }\n    }\n    int start = now;\n    double tmin = -1e9;\n    int count = 0;\n\n    while(1){\n        double min = 1e9;\n        int minidx = now;\n        for(int j = 1; j < num; j++){\n            int k = (now+j)%num;\n            P vec = v[k] - v[now];\n            D arg1 = arg(vec);\n            if(tmin < arg1){\n                if(min > arg1){\n                    min = arg1;\n                    minidx = k;\n                }\n                pf(\"%d %d : (%+6.1f,%+6.1f) %+.3f\\n\", now+1, k+1, vec.X, vec.Y, arg1);\n            }\n        }\n        tmin = min;\n        now = minidx;\n        count++;\n        if(start == now) break;\n    }\n    cout << num-count << endl;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        vector<P> v;\n        string s;\n        REP(i,n){\n            cin >> s;\n            double a,b;\n            sscanf(s.c_str(), \"%lf,%lf\", &a, &b);\n            v.push_back(P(a,b));\n        }\n        doit(v);\n        v.clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define\t_USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cfloat>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <string>\n#include <set>\n#include <complex>\n#include <utility>\n#include <numeric>\n#define  rep(i,n) for(int i=0;i<(n);i++)\n#define  REP(i,a,n) for(int i=a;i<(n);i++)\n#define  rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define  VI\tvector<int>\n#define\t VS vector<string>\n#define  all(a) (a).begin(),(a).end()\n#define  debug(x) cout<<#x<<\": \"<<x<<endl\nusing namespace std;\ntypedef long long ll;\n\nconst int INF=1000000;\nchar fi[101][101];\nint d[21][21];\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\ndouble EPS = 1e-10;\nint N,M;\nint sx,sy;\nint gx,gy;\nint w,h;\nint ans;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nconst int MAX_V=100;\nconst int MAX_N=100;\nchar o[3]={'+','-','*'};\n#define md 1000003\n\n\nint dp[353][353]={0};\nint bow[353][353]={0};\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))\n\treturn 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\t\tP(double x,double y):x(x),y(y){\n\t\t}\n\t\tP operator + (P p){\n\t\t\treturn P(add(x,p.x),add(y,p.y));\n\t\t}\n\t\tP operator - (P p){\n\t\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t\t}\n\t\tP operator *(double d){\n\t\t\treturn P(x*d,y*d);\n\t\t}\n\t\tdouble dot(P p){\n\t\t\treturn add(x*p.x,y*p.y);\n\t\t}\n\t\tdouble det(P p){\n\t\t\treturn add(x*p.y,-y*p.x);\n\t\t}\n};\n\nbool cmp_x(const P& p,const P& q){\n\tif(p.x!=q.x) return p.x<q.x;\n\treturn p.y<q.y;\n}\n\nvector<P> convex_hull(P* ps, int n){\n\tsort(ps,ps+n,cmp_x);\n\tint k=0;\n\tvector<P> \tqs(n*2);\n\t\n\trep(i,n){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)\n\t\tk--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nint n;\nP ps[101];\n\nint main(){\n\t\n\twhile(cin>>n,n!=0){\n\t\tchar comma;\n\t\trep(i,n)\n\t\t\tcin>>ps[i].x>>comma>>ps[i].y;\n\t\t\n\t\tvector<P> qs=convex_hull(ps,n);\n\t\tcout<<n-qs.size()<<endl;\n\t}\n\t\n\t\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N_MAX 100\n#define sz stack.size()\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\nvector<P> v;\ndouble x,y;\nint n,ans;\nP a;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n \ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // テ」ツδ凖」ツつッテ」ツδ暗」ツδォ(b-a)テ」ツ?ョテ・ツキツヲテ・ツ?エテ」ツ?ォテ」ツδ凖」ツつッテ」ツδ暗」ツδォ(c-a)テ」ツ?古・ツュツ佚・ツ慊ィテ」ツ?凖」ツつ凝」ツ??\n  if(cross(b,c) < -EPS) return -1; // テ」ツδ凖」ツつッテ」ツδ暗」ツδォ(b-a)テ」ツ?ョテ・ツ渉ウテ・ツ?エテ」ツ?ォテ」ツδ凖」ツつッテ」ツδ暗」ツδォ(c-a)テ」ツ?古・ツュツ佚・ツ慊ィテ」ツ?凖」ツつ凝」ツ??\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nvector<P> convex_hull2(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      scanf(\"%lf,%lf\",&x,&y);\n      a.real()=x;\n      a.imag()=y;\n      v.push_back(a);\n    }\n    vector<P> r=convex_hull2(v);\n    for(int i=0;i<n;i++){\n      int f=0;\n      for(int j=0;j<r.size();j++)\n\tif(isIntersectSP(L(r[j],r[(j+1)%r.size()]),v[i]))f=1;\n      if(!f)ans++;\n    }\n    cout<<ans<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <complex>\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef complex<double> P;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\ndouble dot(const P& a,const P& b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\nbool cmp_x(const P& p, const P& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<P> convex_hull(P* ps, int n){\n  sort(ps, ps+n, cmp_x);\n  int k = 0;\n  vector<P> qs(n * 2);\n  for(int i=0; i < n; i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i=n - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble dist(const P& p,const P& q){\n  return dot(p-q,p-q);\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n\n    P ps[10001];\n    for(int i=0;i<N;i++){\n      double x,y;\n      scanf(\"%lf,%lf\",&x,&y);\n      ps[i] = P(x,y);\n    }\n    vector<P> qs = convex_hull(ps,N);\n    cout << N - qs.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long lint;\n\n//定数\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\nconst lint INFLL = 1001001001001001001ll;\n\n//初期化関連\n#define zclear(a) memset((a), 0 ,sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n//デバッグ出力\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nbool eq(double a, double b) //a == b\n{\n    return (fabs(a - b) <= EPS);\n}\n\nbool neq(double a, double b) //a != b\n{\n    return (!eq(a, b));\n}\n  \nbool lt(double a, double b) //a < b\n{\n    return (a - b < -EPS);\n}\n  \nbool leq(double a, double b) //a <= b\n{\n    return (lt(a, b) || eq(a, b));\n}\n  \nbool gt(double a, double b) //a > b\n{\n    return (a - b > +EPS);\n}\n  \nbool geq(double a, double b) //a >= b\n{\n    return (gt(a, b) || eq(a, b));\n}\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + (Point p){return Point(x + p.x, y + p.y);}\n\tPoint operator - (Point p){return Point(x - p.x, y - p.y);}\n\tPoint operator * (double a){return Point(x * a, y * a);}\n\tPoint operator / (double a){return Point(x / a, y / a);}\n\tPoint operator * (const Point &a){\n\t\treturn Point(x * a.x - y * a.y, x * a.y + y * a.x);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){return (a.x * a.x + a.y * a.y);}\ndouble abs(Vector a){return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b){return (sqrt(norm(a - b)));}\ndouble dot(Vector a, Vector b){return (a.x * b.x + a.y * b.y);}\ndouble cross(Vector a, Vector b){return (a.x * b.y - a.y * b.x);}\ndouble atan(Vector a){return atan2(a.y, a.x);}\nbool sortX(Point a, Point b){return (a.x != b.x ? lt(a.x, b.x) : lt(a.y, b.y));}\nbool sortY(Point a, Point b){return (a.y != b.y ? lt(a.y, b.y) : lt(a.x, b.x));}\nPoint p;\nbool sortT(Point a, Point b){return (gt(cross(a - p, b - p), 0));}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return (+1); //p0, p1, p2 が反時計周り\n\tif (cross(a, b) < -EPS) return (-1);//p0, p1, p2 が時計回り\n\tif (dot(a, b) < -EPS) return (+2); //p2--p0--p1 の順で一直線上\n\tif (norm(a) < norm(b)) return (-2); //p0--p1--p2 の順で一直線上\n\treturn (0); //p0--p2--p1 の順で一直線上\n}\n\nPolygon normalize(Polygon &v)\n{\n    int pt = 0;\n    for (int i = 1; i < v.size(); i++){\n        if (v[pt].y > v[i].y || (v[pt].y == v[i].y && v[pt].x > v[i].x)){\n            pt = i;\n        }\n    }\n    swap(v[pt], v[0]);\n    p = v[0];\n    sort(v.begin() + 1, v.end(), sortT);\n    return (v);\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = (int)ps.size();\n    Polygon qs(n * 2);\n      \n    for (int i = 0; i < n; i++){\n      while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    for (int i = n - 2, t = k; i >= 0; i--){\n      while (k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n      qs[k++] = ps[i];\n    }\n  \n    qs.resize(k - 1);\n    return (qs);\n}\n\ndouble getArea(Polygon t){\n    double ans = 0.0;\n\tt = normalize(t);\n    for (unsigned int i = 0; i < t.size(); i++)\n        ans += cross(t[i] , t[(i + 1) % t.size()]);\n    return (fabs(ans) / 2);\n}\n\nbool isIntersectLL(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線の場合は交差していると判定する.\n\treturn (abs(cross(p2 - p1, p4 - p3)) > EPS || // 傾きが異なる\n\t\tabs(cross(p2 - p1, p4 - p3)) < EPS); // 同じ直線である\n}\nbool isIntersectLS(Point p1, Point p2, Point p3, Point p4)\n{// 同一直線上にある場合も交差と判定\n\treturn (cross(p2 - p1, p3 - p1) * cross(p2 - p1, p4 - p1) < EPS);\n}\nbool isIntersectLP(Point p1, Point p2, Point p)\n{\n\treturn (neq(abs(ccw(p1, p2, p)), 1));\n}\nbool isIntersectSS(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n             ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isIntersectSP(Point p1, Point p2, Point p)\n{\n\treturn (eq(ccw(p1, p2, p), 0));\n}\nbool isInsideCP(Point c, double r, Point p)\n{\n\treturn (leq(abs(c - p), r));\n}\nbool isInsideCC(Point c1, double r1, Point c2, double r2)\n{\n\treturn (leq(abs(c1 - c2), r1 + r2) && geq(abs(c1 - c2), abs(r1 - r2)));\n}\nbool isInsidePolyP(Polygon gon, Point p)\n{\n    for (int i = 0; i < gon.size(); i++){\n        if (ccw(gon[i], gon[(i + 1) % gon.size()], p) == -1) return (false);\n    }\n    return (true);\n}\n\nPoint projection(Point p1, Point p2, Point p3) //直線p1p2 上への写像\n{\n\tdouble t = dot(p3 - p1, p2 - p1) / norm(p2 - p1);\n\treturn (p1 + (p2 - p1) * t);\n}\nPoint reflection(Point p1, Point p2, Point p3) //直線p1p2 上への反射\n{\n\treturn (p3 + (projection(p1, p2, p3) - p) * 2);\n}\ndouble distanceLP(Point p1, Point p2, Point p)\n{\n\treturn (abs(p - projection(p1, p2, p)));\n}\ndouble distanceLL(Point l1, Point l2, Point m1, Point m2)\n{\n\treturn (isIntersectLL(l1, l2, m1, m2) ? 0 : distanceLP(l1, l2, m1));\n}\ndouble distanceLS(Point l1, Point l2, Point s1, Point s2)\n{\n    if (isIntersectLS(l1, l2, s1, s2)) return (0);\n\treturn (min(distanceLP(l1, l2, s1), distanceLP(l1, l2, s2)));\n}\ndouble distanceSP(Point s1, Point s2, Point p)\n{\n\tPoint r = projection(s1, s2, p);\n\tif (isIntersectSP(s1, s2, r)) return (abs(r - p));\n\treturn (min(abs(s1 - p), abs(s2 - p)));\n}\ndouble distanceSS(Point s1, Point s2, Point t1, Point t2){\n\tif (isIntersectSS(s1, s2, t1, t2)) return (0);\n\treturn (min(min(distanceSP(s1, s2, t1), distanceSP(s1, s2, t2)),\n\t\t\tmin(distanceSP(t1, t2, s1), distanceSP(t1, t2, s2))));\n}\nPoint interPointLL(Point a1, Point a2, Point b1, Point b2)\n{\n\tdouble d = cross(a2 - a1, b2 - b1);\n\tif (abs(d) < EPS) throw \"Segment is Paralell!\";\n\tPoint a = a2 - a1, b = b2 - b1;\n    double t = cross(b, b1 - a1) / cross(b, a);\n    return (a1 + a * t);\n}\nvector<Point> interPointCC(Point c1, double r1, Point c2, double r2)\n{\n\tvector<Point> res;\n\tif (abs(c1 - c2) < EPS) return (vector<Point>()); // 交点が絶対にない\n\tdouble d = abs(c1 - c2);\n\tdouble rc = (d * d + r1 * r1 - r2 * r2) / (2 * d);\n\tdouble rs = sqrt(r1 * r1 - rc * rc);\n\tPoint diff = (c2 - c1) / d;\n\tres.push_back(Point(c1 + diff * Point(rc, rs)));\n\tres.push_back(Point(c1 + diff * Point(rc, -rs)));\n\treturn (res);\n}\nvector<Point> crosspointCL(Point a, double ra, Point b1, Point b2)\n{\n\tvector<Point> res;\n\tdouble dist = distanceLP(b1, b2, a);\n\tif (leq(dist, ra)){\n\t\tPoint s = projection(b1, b2, a);\n\t\tdist = sqrt(ra * ra - dist * dist);\n\t\tPoint t = (b2 - b1) / abs(b2 - b1);\n\t\tres.push_back(s + t * dist);\n\t\tres.push_back(s - t * dist);\n\t}\n\treturn (res);\n}\n\nPoint unitVector(Vector t)\n{\n    double u = abs(t);\n    return (Point(t.x / u , t.y / u));\n}\n\nPoint normalVector(Point p, Point a, Point b)\n{\n    Point v = unitVector(b - a);\n    v = cross(v, p - a) > 0 ? Point(v.y, -v.x) : Point(-v.y, v.x);\n    return v * distanceLP(p, a, b);\n}\n  \ndouble getCos(Vector a, Vector b)\n{\n    return (dot(a, b) / (abs(a) * abs(b)));\n}\n  \ndouble getSin(Vector a, Vector b)\n{\n    double t = getCos(a, b);\n    return (sqrt(1.0 - t * t));\n}\n  \ndouble getArg(Vector v)\n{\n    return (atan2(v.y, v.x));\n}\n\nPoint rotate(Point t, Point p, double r)\n{\n    double ta = cos(r) * (t.x - p.x) - sin(r) * (t.y - p.y) + p.x;\n    double tb = sin(r) * (t.x - p.x) + cos(r) * (t.y - p.y) + p.y;\n    return (Point(ta, tb));\n}\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) && n){\n\t\tPolygon p(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\", &p[i].x, &p[i].y);\n\t\t}\n\t\tprintf(\"%d\\n\", n - conhel(p).size());\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <cmath>\n#include <stdio.h>\n\nusing namespace std;\n\n//-------------------------------------------------------------------------\n// geometric library\n\nnamespace geometry {\n\n#define EPS 1E-10 ///< 0とみなすサイズ。適当\n\n\tstruct point {\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpoint& operator += (const point& rhs) { x += rhs.x; y += rhs.y; return *this; }\n\t\tpoint& operator -= (const point& rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n\t\tpoint& operator /= (double factor) { x /= factor; y /= factor; return *this; }\n\t\tpoint& operator *= (double factor) { x *= factor; y *= factor; return *this; }\n\t\tbool operator == (const point& rhs) const { return (std::abs(x - rhs.x) < EPS) && (std::abs(y - rhs.y) < EPS); }\n\t\tbool operator != (const point& rhs) const { return !(*this == rhs); }\n\t\tbool operator <= (const point& rhs) const { return x < rhs.x || (x == rhs.x && y <= rhs.y); }\n\t\tbool operator >= (const point& rhs) const { return x > rhs.x || (x == rhs.x && y >= rhs.y); }\n\t\tbool operator < (const point& rhs) const { return !(*this >= rhs); }\n\t\tbool operator > (const point& rhs) const { return !(*this <= rhs); }\n\t};\n\n\tstruct circle {\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct line {\n\t\t// ax + by + c = 0\n\t\tdouble a;\n\t\tdouble b;\n\t\tdouble c;\n\t};\n\n\tenum rotate_dir {\n\t\trotate_None = 0,\n\t\trotate_CW = 1,\n\t\trotate_CCW = -1\n\t};\n\n\tpoint operator + (const point& p1, const point& p2)\n\t{\n\t\tpoint p(p1);\n\t\tp += p2;\n\t\treturn p;\n\t}\n\n\tpoint operator / (const point& p1, double factor)\n\t{\n\t\tpoint p(p1);\n\t\tp /= factor;\n\t\treturn p;\n\t}\n\n\tpoint operator - (const point& p1, const point& p2)\n\t{\n\t\tpoint p(p1);\n\t\tp -= p2;\n\t\treturn p;\n\t}\n\n\tstd::istream& operator >> (std::istream& is, point& p)\n\t{\n\t\tis >> p.x >> p.y;\n\t\treturn is;\n\t}\n\n\t///! 2点の距離\n\tdouble get_distance(const point& p1, const point& p2)\n\t{\n\t\treturn sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n\t}\n\n\t///! 2直線の交点\n\tbool get_crosspoint(const line& l1, const line& l2, point *result)\n\t{\n\t\tdouble denominator = l1.a * l2.b - l1.b * l2.a;\n\t\tif (std::abs(denominator) < EPS) {\n\t\t\treturn false;\n\t\t}\n\t\tresult->x = (l1.b * l2.c - l2.b * l1.c) / denominator;\n\t\tresult->y = (l2.a * l1.c - l1.a * l2.c) / denominator;\n\t\treturn true;\n\t}\n\n\t///! 2点の垂直2等分線\n\tbool get_bisector(const point& p1, const point& p2, line *result)\n\t{\n\t\tif (p1 == p2) {\n\t\t\treturn false;\n\t\t}\n\t\tresult->a = 2 * (p1.x - p2.x);\n\t\tresult->b = 2 * (p1.y - p2.y);\n\t\tresult->c = -(p1.y - p2.y) * (p1.y + p2.y) - (p1.x - p2.x) * (p1.x + p2.x);\n\t\treturn true;\n\t}\n\n\tbool get_line(const point& p1, const point& p2, line *result)\n\t{\n\t\tif (p1 == p2) {\n\t\t\treturn false;\n\t\t}\n\t\tresult->a = p2.y - p1.y;\n\t\tresult->b = p1.x - p2.x;\n\t\tresult->c = p1.y * p2.x - p1.x * p2.y;\n\t\treturn true;\n\t}\n\n\t///! 外接円を求める\n\tbool get_circum_circle(const point& p1, const point& p2, const point& p3, circle *result)\n\t{\n\t\tdouble a = get_distance(p1, p2);\n\t\tdouble b = get_distance(p2, p3);\n\t\tdouble c = get_distance(p3, p1);\n\n\t\t// 半径の公式\n\t\tresult->radius = a * b * c / sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));\n\n\t\tline line_p1p2;\n\t\tline line_p2p3;\n\n\t\t// 頂点の垂直2等分線の交点が外心\n\t\treturn get_bisector(p1, p2, &line_p1p2) &&\n\t\t\tget_bisector(p2, p3, &line_p2p3) &&\n\t\t\tget_crosspoint(line_p1p2, line_p2p3, &result->center);\n\t}\n\n\tdouble cross_product(const point& p1, const point& p2)\n\t{\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tdouble inner_product(const point& p1, const point& p2)\n\t{\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\t///! p1-p2-p3が左右どちらの方向に折れているかを判定\n\trotate_dir direction(const point& p1, const point& p2, const point& p3)\n\t{\n\t\tpoint p1_p3 = p1 - p3;\n\t\tpoint p2_p3 = p2 - p3;\n\t\tdouble cross = cross_product(p1_p3, p2_p3);\n\n\t\tif (std::abs(cross) < EPS) {\n\t\t\treturn rotate_None;\n\t\t}\n\t\telse if (cross > 0) {\n\t\t\treturn rotate_CW;\n\t\t}\n\t\telse {\n\t\t\treturn rotate_CCW;\n\t\t}\n\t}\n\n\t// (p1s, p1e)と(p2s, p2e)の線分交差判定.EPS以下で接している場合はtrue、重なっている場合はfalse\n\tbool intersect(const point& p1s, const point& p1e, const point& p2s, const point& p2e)\n\t{\n\t\tassert(p1s != p1e && p2s != p2e);\n\t\treturn\n\t\t\t(direction(p1s, p1e, p2s) != direction(p1s, p1e, p2e)) &&\n\t\t\t(direction(p2s, p2e, p1s) != direction(p2s, p2e, p1e));\n\t}\n\n\t// targetが三角形p1,p2,p3の内部にあるかどうか\n\tbool is_inside_triangle(const point& p1, const point& p2, const point& p3, const point& target)\n\t{\n\t\tpoint center_of_gravity = (p1 + p2 + p3) / 3; // 重心\n\n\t\tif (center_of_gravity == target) return true;\n\n\t\t// 重心とtargetを結んだ線分が三角形の辺と交叉するなら、点は三角形の外部にある\n\t\tbool intersect_any =\n\t\t\tintersect(p1, p2, center_of_gravity, target) ||\n\t\t\tintersect(p2, p3, center_of_gravity, target) ||\n\t\t\tintersect(p3, p1, center_of_gravity, target);\n\n\t\treturn !intersect_any;\n\t}\n\n\tbool is_parallel(const point& p1, const point& p2, const point& p3, const point& p4)\n\t{\n\t\tline l1, l2;\n\t\tpoint cross;\n\n\t\tif (!get_line(p1, p2, &l1) || !get_line(p3, p4, &l2)) {\n\t\t\treturn false; // p1-p2, p3-p4で直線が作れない\n\t\t}\n\t\treturn get_crosspoint(l1, l2, &cross) == false;\n\t}\n\n\tbool is_convex(const point* points, int num_points) {\n\t\tassert(num_points >= 3);\n\n\t\trotate_dir base_dir = direction(points[0], points[1], points[2]);\n\t\tif (base_dir == rotate_None) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int i = 1; i < num_points; i++) {\n\t\t\tif (direction(points[i], points[(i + 1)%num_points], points[(i + 2)%num_points]) != base_dir) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool get_convex(const vector<point>& points, vector<point> *convex) {\n\t\tif (points.size() < 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvector<point> sorted_points(points);\n\t\tint n = 0;\n\t\tsort(sorted_points.begin(), sorted_points.end());\n\t\tconvex->resize(2*sorted_points.size()); // 最大2倍までの数の点が入る\n\n\t\t// 左から右\n\t\tfor (vector<point>::iterator it = sorted_points.begin(); it != sorted_points.end(); ++it) {\n\t\t\twhile (n >= 2 && direction((*convex)[n - 2], (*convex)[n - 1], *it) != rotate_CCW) {\n\t\t\t\tn--;\n\t\t\t}\n\t\t\t(*convex)[n++] = *it;\n\t\t}\n\t\tint n_ccw = n;\n\n\t\t// 右から左\n\t\tfor (vector<point>::reverse_iterator it = sorted_points.rbegin(); it != sorted_points.rend(); ++it) {\n\t\t\twhile (n >= n_ccw + 1 && direction((*convex)[n - 2], (*convex)[n - 1], *it) != rotate_CCW) {\n\t\t\t\tn--;\n\t\t\t}\n\t\t\t(*convex)[n++] = *it;\n\t\t}\n\t\tn--;// 左端の点が重複するため、最後の点を削除\n\t\tconvex->resize(n);\n\t\treturn true;\n\t}\n\n} // namespace geometry\n\n//-------------------------------------------------------------------------\n// solution\n\nusing namespace geometry;\n\n\n\nint main(void)\n{\n\tint n;\n\tchar sep;\n\tpoint pA, pB, pC, pD;\n\n\twhile (cin >> n) {\n\t\tvector<point> points(n), convex;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> points[i].x >> sep >> points[i].y;\n\t\t}\n\n\t\tget_convex(points, &convex);\n\t\tcout << (points.size() - convex.size()) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define deb 0\nusing namespace std;\nint main(void){\n    int n;\n    while(1){\n        cin>>n;\n        if(!n)break;\n        double p[2][200];\n        double xmin=10000.0;\n        bool flg[200]={0};\n        int xi,first;\n        for(int i=0;i<n;i++){\n            scanf(\"%lf,%lf\",&p[0][i],&p[1][i]);\n            if(xmin>p[0][i])xmin=p[0][i],first=xi=i;\n            if(deb)cout<<\"first=\"<<first<<endl;\n        }\n        if(deb)for(int i=0;i<n;i++){\n            cout<<i<<\" ... (\"<<p[0][i]<<\",\"<<p[1][i]<<\")\"<<endl;\n        }\n        if(deb)cout<<\".\"<<endl;\n        double r=10000;\n        double next=270,ith=1000,now=0;\n        int nextnum,nextnow;\n        int q=n;\n        while(q--){\n            if(deb)cout<<\"next=\"<<next<<endl;\n            for(int i=0;i<n;i++){\n                if(!flg[i]&&i!=xi){\n                    if(deb)cout<<i<<\"******\"<<endl;\n                    double xd=p[0][i]-p[0][xi],yd=p[1][i]-p[1][xi];\n                    double rd=hypot(xd,yd);\n                    now=atan2(yd/rd,xd/rd)/M_PI*180;\n                    if(now<0)now+=360;\n                    if(deb)cout<<\"xd=\"<<xd<<\",yd=\"<<yd<<endl;\n                    if(deb)cout<<\"rd=\"<<rd<<endl;\n                    if(deb)cout<<\"atan2=\"<<now<<endl;\n                    double fnow;\n                    next-now<0 ? fnow=next-now+360:fnow=next-now;\n                    if(deb)cout<<\"next-now=\"<<fnow<<endl;\n                    if(fnow<ith){\n                        nextnum=i;\n                        nextnow=now;\n                        ith=fnow;\n                        if(deb)cout<<\"///\"<<nextnum<<endl;\n                    }\n                }\n            }\n            flg[nextnum]=1;\n            if(deb)cout<<\"<\"<<nextnum<<\">\"<<endl<<endl;\n            xi=nextnum;\n            next=nextnow;\n            ith=1000;\n            if(flg[first])break;\n        }\n        int f=0;\n        for(int i=0;i<n;i++){\n            if(!flg[i])f++;\n            if(deb)cout<<\"flg[\"<<i<<\"] = \"<<flg[i]<<endl;\n        }\n        cout<<f<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nstatic constexpr real EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\n\nreal angle(Point A, Point B){\n    return acos(dot(A, B)/abs(A)/abs(B));\n}\n\n\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Circle{\n    Point c; real r;\n    Circle(Point c, real r): c(c), r(r) {};\n};\n\nusing Polygon = vector<Point>;\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool intersect(Segment s, Line t){\n    int a = ccw(t.a, t.b, s.a), b = ccw(t.a, t.b, s.b);\n    return (!(a&1) || !(b&1) || a != b);\n}\n\nPoint polar(double r, double t){\n    return Point(r*cos(t), r*sin(t));\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nstatic constexpr int CONTAIN = 0;\nstatic constexpr int INSCRIBE = 1;\nstatic constexpr int INTERSECT = 2;\nstatic constexpr int CIRCUMSCRIBED = 3;\nstatic constexpr int SEPARATE = 4;\n\nint intersect(Circle c1, Circle c2){\n    if(c1.r < c2.r) swap(c1, c2);\n    real d = abs(c1.c-c2.c);\n    real r = c1.r + c2.r;\n    if(fabs(d-r) < EPS) return CIRCUMSCRIBED;\n    if(d > r) return SEPARATE;\n    if(fabs(d+c2.r-c1.r) < EPS) return INSCRIBE;\n    if(d+c2.r < c1.r) return CONTAIN;\n    return INTERSECT;\n}\n\nreal distance(Line l, Point c){\n    return abs(cross(l.b-l.a, c-l.a)/abs(l.b-l.a));\n}\n\n\nreal distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\nreal distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\nPoint project(Line l, Point p){\n    Point Q = l.b-l.a;\n    return l.a + Q*(dot(p-l.a, Q) / dot(Q, Q));\n}\n\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint crossPoint(Line s, Line t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPolygon crossPoint(Circle c, Line l){\n    Point p = project(l, c.c), q = (l.b-l.a)/abs(l.b-l.a);\n    if(abs(distance(l, c.c)-c.r) < EPS){\n        return {p};\n    }\n    double k = sqrt(c.r*c.r-dot(p-c.c, p-c.c));\n    return {p-q*k, p+q*k};\n}\n\nPolygon crossPoint(Circle c, Segment s){\n    auto tmp = crossPoint(c, Line(s.a, s.b));\n    Polygon ret;\n    for (auto &&i : tmp) {\n        if(distance(s, i) < EPS) ret.emplace_back(i);\n    }\n    return ret;\n}\n\n\nPolygon crossPoint(Circle c1, Circle c2){\n    double d = abs(c1.c-c2.c);\n    double a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t = arg(c2.c-c1.c);\n    return {c1.c+polar(c1.r, t+a), c1.c+polar(c1.r, t-a)};\n}\n\nPolygon tangent(Circle c1, Point p){\n    Circle c2 = Circle(p, sqrt(dot(c1.c-p, c1.c-p)-c1.r*c1.r));\n    return crossPoint(c1, c2);\n}\nvector<Line> tangent(Circle c1, Circle c2){\n    vector<Line> ret;\n    if(c1.r < c2.r) swap(c1, c2);\n    double k = dot(c1.c-c2.c, c1.c-c2.c);\n    if(abs(k) < EPS) return {};\n    Point u = (c2.c-c1.c)/sqrt(k);\n    Point v(-u.y, u.x);\n    for (auto &&i : {-1, 1}) {\n        double h = (c1.r+i*c2.r)/sqrt(k);\n        if(abs(h*h-1) < EPS){\n            ret.emplace_back(c1.c+u*c1.r, c1.c+(u+v)*c1.r);\n        }else if(h*h < 1){\n            Point u2 = u*h, v2 = v*sqrt(1-h*h);\n            ret.emplace_back(c1.c+(u2+v2)*c1.r, c2.c-(u2+v2)*c2.r*i);\n            ret.emplace_back(c1.c+(u2-v2)*c1.r, c2.c-(u2-v2)*c2.r*i);\n        }\n    }\n    return ret;\n}\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nreal area(Circle c, Polygon &v){\n    int n = v.size();\n    real ans = 0.0;\n    Polygon u;\n    for (int i = 0; i < n; ++i) {\n        u.emplace_back(v[i]);\n        auto q = crossPoint(c, Segment(v[i], v[(i+1)%n]));\n        for (auto &&j : q) {\n            u.emplace_back(j);\n        }\n    }\n    for (int i = 0; i < u.size(); ++i) {\n        Point A = u[i]-c.c, B = u[(i+1)%u.size()]-c.c;\n        if(abs(A) >= c.r+EPS || abs(B) >= c.r+EPS){\n            Point C = polar(1, arg(B)-arg(A));\n            ans += c.r*c.r*arg(C)/2;\n        }else {\n            ans += cross(A, B)/2;\n        }\n    }\n    return ans;\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        Polygon P(n);\n        for (auto &&i : P) scanf(\"%lg,%lg\",&i.x, &i.y);\n        cout << n-convex_hull(P).size() << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> &s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> &g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\nint main(){\n\tint n;\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tvector<point> s(n);\n\t\tdouble x,y;\n\t\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf,%lf\",&x,&y);\n\t\ts[i]=point(x,y);\n\t\t}\n\t\tvector<point> ans = andrewscan(s);\n\t\tcout<<n-ans.size()<<endl;\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> P;\n#define X real\n#define Y imag\nvector<P> data;\nnamespace std{\nbool operator<(P a,P b){\nreturn a.X()!=b.X()? a.X()<b.X():a.Y()<b.Y();\n}\n}\ndouble cross(P a,P b){\nreturn imag(conj(a)*b);\n}\ndouble dot(P a,P b){\nreturn real(conj(a)*b);\n}\nint ccw(P a,P b,P c){\nb-=a;c-=a;\nif(cross(b,c)>0)return 1; //counter clockwise\nif(cross(b,c)<0)return -1; //clockwise\nif(dot(b,c)<0)return 2; //c--a--b on line\nif(norm(b)<norm(c))return -2; //a--b--c on line\nreturn 0;\n}\nvector<P> convex_hull(vector<P> ps){\nsort(ps.begin(),ps.end());\nvector<P> ch(ps.size()*2);\nint k=0;\nfor(int i=0;i<ps.size();ch[k++]=ps[i++]){\nwhile(k>=2 && ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n}\nfor(int i=ps.size()-2,t=k+1;i>=0;ch[k++]=ps[i--]){\nwhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n}\nch.resize(k-1);\nreturn ch;\n}\nint solve(){\nvector<P> res = convex_hull(data);\nreturn res.size();\n}\nint main(){\nint n;\nwhile(cin>>n){\nif(n==0)break;\ndata.clear();\nfor(int i=0;i<n;i++){\nld a,b;\nchar c;\ncin>>a>>c>>b;\ndata.push_back(P(a,b));\n}\ncout<<n-solve()<<endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <climits>\n#include <cmath>\n\n#define EPS (1e-10)\n#define PI (acos(-1.0))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\nusing namespace std;\ntypedef complex<double> P;\n\n//3つの点p1, p2, p3がp1->p2->p3->p1の順で反時計周りかどうか判定\ndouble ccw(P& p1, P& p2, P& p3)\n{\n\treturn ((p2.real() - p1.real())*(p3.imag() - p1.imag()) \n\t\t\t\t- (p2.imag() - p1.imag())*(p3.real() - p1.real())) > 0;\n}// ccw>0 => ccw, ccw=0 => colinear, ccw<0, cw\n\nbool complex_pred(const P& a, const P& b)\n{\n    if (a.real() != b.real())\n\t\treturn a.real() < b.real();\n\telse\n\t\treturn a.imag() < b.imag();\n}\n\nvector<P> solve(vector<P>& vc)\n{\n\tsort(vc.begin(), vc.end(), complex_pred);\n\n\tint k = 0;\n\tvector<P> vc2(vc.size()*2);\n\t\n\tfor (int i = 0; i < (int)vc.size(); i++)\n\t{\n\t\twhile( k >= 2 && ccw(vc2[k-1], vc2[k-2], vc[i]) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\t\n\t\tvc2[k]=vc[i];\n\t\tk++;\n\t}\n\n\tfor (int i = 0; i < (int)vc.size(); i++)//始点へのループを見つける\n\t{\n\t\tvector<P>::iterator it = find( vc2.begin(),vc2.end() , vc[i] );\n\t\t\n\t\tif(ccw(vc2[k-1], vc[i], vc2[0]) > 0 && it != vc2.end())\n\t\t{\n\t\t\tvc2[k] = vc[i];\n\t\t\tk++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvc2.resize(k);\n\treturn vc2;\n\t\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> vc;\n\t\tvc.clear();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tchar c;\n\t\t\tdouble a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> c;\n\t\t\tcin >> b;\n\t\t\tvc.push_back(P(a, b));\n\t\t}\n\t\t\n\t\tvector<P> vc2 = solve(vc);\n\t\tcout << n-vc2.size() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n#include <complex>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tvector<P> panai;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble b,c;\n\t\t\tscanf(\"%lf,%lf\",&b,&c);\n\t\t\tpanai.push_back(complex<double>(b,c));\n\t\t}\n\t\tprintf(\"%d\\n\",a-convex_hull(panai).size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n/*Graham Scan*/\n//凸多角形を求める\nG getConvex(G ps){\n\tconst int N =ps.size();\n\tsort(ps.begin(),ps.end());\n\tint k = 0;\n\tvector<P> convex(N*2);\n\tfor(int i =0;i < N;i++){\n\t\twhile(2 <=k&&cross(convex[k-1]-convex[k-2],ps[i]-convex[k-1])<=0){\n\t\t\tk--;\n\t\t}\n\t\tconvex[k++]=ps[i];\n\t}\n\tfor(int i =N-2,t = k;i >=0;i--){\n\t\twhile(t <k&& cross(convex[k-1]-convex[k-2],ps[i]-convex[k-1])<=0){\n\t\t\tk--;\n\t\t}\n\t\tconvex[k++]=ps[i];\n\t}\n\treturn convex;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG g;\n\t\tfor(int i =0; i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tchar c;\n\t\t\tcin>>x>>c>>y;\n\t\t\tg.push_back(P(x,y));\n\t\t}\n\t\tG convex =getConvex(g);\n\t\tcout <<n-convex.size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\n\nbool isInTriangle(double x[3], double y[3], double xp, double yp)\n{\n\tdouble c[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tc[i] = (x[(i+1)%3]-x[i]) * (yp - y[i]) - (y[(i+1)%3]-y[i]) * (xp - x[i]);\n\n\treturn c[0] > 0 && c[1] > 0 && c[2] > 0\n\t\t|| c[0] < 0 && c[1] < 0 && c[2] < 0;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\\n\", &n);\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tdouble x[100];\n\t\tdouble y[100];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tscanf(\"%lf,%lf\\n\", x+i, y+i);\n\n\t\tint res = 0;\n#define SUCC(w) ((w+1) % n)\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tdouble xp = x[i];\n\t\t\tdouble yp = y[i];\n\t\t\tbool isOutOfAnyTriangles = true;\n\t\t\tfor (int a = SUCC(i); a != i; a = SUCC(a))\n\t\t\t{\n\t\t\t\tfor (int b = SUCC(a); b != i; b = SUCC(b))\n\t\t\t\t{\n\t\t\t\t\tfor (int c = SUCC(b); c != i; c = SUCC(c))\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble xx[] = { x[a], x[b], x[c] };\n\t\t\t\t\t\tdouble yy[] = { y[a], y[b], y[c] };\n\t\t\t\t\t\tif (isInTriangle(xx, yy, xp, yp))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tisOutOfAnyTriangles = false;\n\t\t\t\t\t\t\tgoto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nEnd:\n\t\t\tif (!isOutOfAnyTriangles)\n\t\t\t\t++res;\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LB;\ntypedef pair<LB,LB> PBB;\ntypedef vector<PBB > VPBB;\ntypedef multimap<LB,LL> MDI;\ntypedef MDI::iterator MDII;\n\n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n\n\nint main(){\n\n\tLL n;\n\tLL max;\n\tLL ans;\n\tLL cnt;\n\tLB x,y;\n\tLB hx,hy,ix,iy,jx,jy;\n\tchar gav;\n\tVPBB pin;\n\tMDI point;\n\n\twhile(1){\n\n\t\t/*入力*/\n\t\tcin>>n;\n\n\t\t/*終了*/\n\t\tif(n==0) break;\n\n\t\t/*準備*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>gav>>y;\n\t\t\tpin.PUSH(PBB(x,y));\n\t\t}\n\t\tans=0;\n\n\t\t/*端の点を決める*/\n\t\tmax=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(pin[max].second<pin[i].second) max=i;\n\t\t\telse if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n\t\t}\n\n\t\t/*基準点との角度から順番を付ける*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i!=max){\n\t\t\t\tpoint.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n\t\t\t}\n\t\t}\n\t\tpoint.insert(MDIVT(-1*INF,max));\n\n\t\t/*3点の角度から凸包を求めていく*/\n\t\tMDII iH=point.begin(),iI=point.begin(),iJ=point.begin();\n\t\tiI++,iJ++,iJ++;\n\t\tcnt=0;\n\t\twhile(iJ!=point.end()){\n\t\t\thx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n\t\t\tix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n\t\t\tjx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n\n\t\t\t/*cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug*/\n\n\t\t\tif((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0){\n\t\t\t\tiH++,iI++,iJ++;\n\t\t\t\twhile(cnt--) iH++;\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tiI++;\n\t\t\t\tiJ++;\n\t\t\t\tcnt++;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\t/*出力*/\n\t\tcout<<ans<<endl;\n\n\t\t/*初期化*/\n\t\tpin.clear();\n\t\tpoint.clear();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// geometry\ntypedef long double Real;\n#define EPS 1e-12\ntypedef complex<Real> P;\nbool P_less(const P &a,const P &b){\n  if(a.real()!=b.real())return a.real()<b.real();\n  return a.imag()<b.imag();\n}\nReal dot(const P &a,const P &b){return real(conj(a)*b);}\nReal cross(const P &a,const P &b){return imag(conj(a)*b);}\nint ccw(const P &a,const P &b,const P &c){\n  Real x = cross(b-a,c-a);\n  if(abs(x)<EPS)return 0;\n  else if(x<0)return -1;\n  else return 1;\n}\n\nstruct ccw_less{\n  P x;\n  bool operator()(const P &a,const P &b) const{\n    int c = ccw(x,a,b);\n    if(c==0) return norm(a-x)<norm(b-x);\n    return c==1;\n  }\n};\nvector<P> createConvexHull(vector<P> p){\n  // Graham's scan\n  sort(ALL(p),P_less);\n  vector<P> ret(p.size());\n  ccw_less cw;\n  cw.x = p[0];\n  sort(p.begin()+1,p.end(),cw);\n  ret[0] = p[0];\n  int iter = 1;\n  REPR(i,p.size()){\n    while(iter>=2 && ccw(ret[iter-2],ret[iter-1],p[i])<=0)--iter;\n    ret[iter++] = p[i];\n  }\n  ret.resize(iter);\n  return ret;\n}\n\nint main(){\n  // verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0068\n  while(true){\n    int n;\n    scanf(\"%d\",&n);\n    if(!n)break;\n    vector<P> p(n);\n    REP(i,n){\n      Real x,y;\n      scanf(\"%Lf,%Lf\",&x,&y);\n      p[i] = P(x,y);\n    }\n    vector<P> conv = createConvexHull(p);\n    cout<< (n-conv.size()) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n//#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n//#include <stack>\n//#include <limits>\n#include <sstream>\n//#include <functional>\n#include <complex>\n\nusing namespace std;\n\n#define len(array)  (sizeof (array) / sizeof *(array))\n#define rep(i, s, e) for(int i = s;i < e;i++)\n#define rrep(i, e, s) for(int i = e;s <= i;i--)\n#define vrange(v) v.begin(), v.end()\n#define vrrange(v) v.rbegin(), v.rend()\n#define vsort(v) sort(vrange(v))\n#define vrsort(v) sort(vrrange(v))\n#define arange(a) a, a + len(a)\n#define asort(a) sort(arange(a))\n#define arsort(a, t) sort(arange(a), greater<t>())\n#define afill(a, v) fill(arange(a), v)\n#define afill2(a, v, t) fill((t *)a, (t *)(a + len(a)), v)\n#define fmax(a, b) (a < b? b : a)\n#define fmin(a, b) (a > b? b : a)\n#define fabs(a) (a < 0? -a : a)\n#define X real()\n#define Y imag()\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef complex<double> p;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-10;\n//const int dx[] = {1, -1, 0, 0, 1, -1, -1, 1};\n//const int dy[] = {0, 0, 1, -1, -1, -1, 1, 1};\n//const int weight[] = {0,1,10,100,1000,10000,100000,1000000,10000000};\n//priority_queue< int, vector<int>, greater<int> > q;\n\n\n//二次元座標(from 蟻本)\ntypedef struct _PT{\n  double x, y;\n  _PT() {}\n  _PT(double x, double y) : x(x), y(y){\n  }\n  _PT operator + (_PT p){\n\treturn _PT(x + p.x, y + p.y);\n  }\n  _PT operator - (_PT p){\n\treturn _PT(x - p.x, y - p.y);\n  }\n  _PT operator * (double d){\n\treturn _PT(d*x, d*y);\n  }\n  double dot(_PT p){ //pとの内積\n\treturn x * p.x + y * p.y;\n  }\n  double det(_PT p){ //pとの外積\n\treturn x * p.y - p.x * y;\n  }\n  double dist(_PT p){ //pとの距離の2乗\n\treturn (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);\n  }\n  bool operator <(const struct _PT &e) const{\n    return x == e.x? (y < e.y) : x < e.x;\n  }\n  bool operator >(const struct _PT &e) const{\n    return x == e.x? (y > e.y) : x > e.x;\n  }\n\n} pt;\n\nclass Polygon{\n\nprivate:\n\npublic:\n  vector<pt> pts;\n  int n;\n  Polygon(){}\n\n  Polygon(vector<pt> v){\n\tn = v.size();\n\tpts = v;\n  }\n  //凸包（蟻本ver）\n  vector<pt> convex_hull(){\n\tvector<pt> qs(n * 2);\n\tint k = 0;\n\tvsort(pts);\n\trep(i, 0, n){ //下側凸包の作成\n\t  while(k > 1 && (qs[k-1] - qs[k-2]).det(pts[i] - qs[k-1]) <= 0) k--;\n\t  qs[k++] = pts[i];\n\t}\n\tfor(int i = n - 2, t = k; i >= 0; i--){ //上側凸包の作成\n\t  while(k > t && (qs[k-1] - qs[k-2]).det(pts[i] - qs[k-1]) <= 0)\tk--;\n\t  qs[k++] = pts[i];\n\t}\n\tqs.resize(k-1);\n\tn = k-1;\n\tpts = qs;\n\treturn qs;\n  }\n\n  //点が図形を構成する順番に並んでないと駄目\n   double getArea(){\n\tdouble s = 0;\n\trep(i, 0, n-1){\n\t  s += pts[i].det(pts[i+1]);\n\t}\n\ts += pts[n-1].det(pts[0]);\n\treturn fabs(s) * 0.5;\n   }\n\n  //http://www004.upp.so-net.ne.jp/s_honma/urawaza/area2.htm\n  double _getArea(){\n\tdouble s = 0;\n\trep(i, 0, n-1){\n\t  s += (pts[i].x - pts[i+1].x) * (pts[i].y + pts[i+1].y);\n\t}\n\ts += (pts[n-1].x - pts[0].x) *( pts[n-1].y + pts[0].y);\n\treturn fabs(s) * 0.5;\n  }\n\n  //http://imagingsolution.net/math/calc_n_point_area/\n  //点が時計回りか反時計回りに並んでないと駄目\n  double getArea2(){\n\tdouble s = 0;\n\trep(i, 0, n-1){\n\t  s += pts[i].x * pts[i+1].y + pts[i+1].x * pts[i].y;\n\t}\n\ts += pts[n-1].x * pts[0].y + pts[0].x * pts[n-1].y;\n\treturn fabs(s) * 0.5;\n  }\n\n};\n\n//http://eternuement.blogspot.jp/2011/04/c-string-double-int.html\ndouble s2f(string str){\n  double rt;\n  stringstream ss;\n  ss << str;\n  ss >> rt;\n  return rt;\n}\nstring f2s(double d){\n  string rt;\n  stringstream ss;\n  ss << d;\n  ss >> rt;\n  return rt;\n}\n\nvector<string> split( string s, string c )\n{\n  vector<string> ret;\n  for(int i = 0, n; i <= s.length(); i = n + 1 ){\n\tn = s.find_first_of( c, i );\n\tif( n == string::npos ) n = s.length();\n\tstring tmp = s.substr( i, n-i );\n\tret.push_back(tmp);\n  }\n  return ret;\n}\n\nvoid doIt(){\n  int n;\n  vector<pt> v;\n  string s;\n  vector<string> ss;\n  Polygon pg;\n  while(true){\n\tcin >> n;\n\tv.clear();\n\tif(!n) break;\n\trep(i, 0, n){\n\t  cin >> s;\n\t  ss = split(s, \",\");\n\t  v.push_back(pt(s2f(ss[0]), s2f(ss[1])));\n\t}\n\tpg = Polygon(v);\n\tpg.convex_hull();\n\tcout << n - pg.n << endl;\n  }\n}\n\nint main() {\n  doIt();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef complex < double > P;\ntypedef vector< P > G;\nstruct L:public vector< P >{ // L:線分\n  L(const P& a,const P& b){push_back(a);push_back(b);}\n};\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std{\n  bool operator <(const P& a,const P& b){\n    return  real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return imag(conj(a) * b);\n}\ndouble dot(const P& a,const P& b){\n  return real(conj(a) * b);\n}\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c) > 0) return 1;\n  if(cross(b,c) < 0) return -1;\n  if(dot(b,c) < 0) return 2; // c--a--b\n  if(norm(b) < norm(c)) return -2; // a--b--c\n  return 0; // a--c--b\n}\nint n_covex_hull(vector<P> ps){\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0 ; i < n ; ch[k++] = ps[i++] ){\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for(int i = n-2, t = k+1 ; i >= 0 ; ch[k++] = ps[i--] ){\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  return k - 1;\n}\n\nint main(){\n  int n;\n  char o;\n  while(cin >> n, n){\n    vector< P > pts(n);\n    for(int i = 0 ; i < n ; i++ ){\n      cin >> pts[i].real() >> o >>pts[i].imag();\n    }\n    cout << n - n_covex_hull(pts) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\n#define EPS (1e-10)\ntypedef complex<double> Po;\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){return abs(cross(b-a,c-a)/2);}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if(abs( area(a,b,c) ) < EPS)return false;\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) + EPS)return false;\n  else return true;\n}\n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int ans;\n  bool use[100];\n  Po p[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&p[i].real(),&p[i].imag());\n      use[i] = false;\n    }\n\n    ans = 0;\n    for(i=0;i<n-3;i++){\n      for(j=i+1;j<n-2;j++){\n\tfor(k=j+1;k<n-1;k++){\n\t  for(l=k+1;l<n;l++){\n\t    if(!use[l]){\n\t      if(inter(p[i],p[j],p[k],p[l])){\n\t\tans++;\n\t\tuse[l] = true;\n\t\t//cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n\t\t//cout << p[l].real() << \" \" << p[l].imag() << endl;\n\t      }\n\t    }\n\t    if(!use[k]){\n\t      if(inter(p[i],p[j],p[l],p[k])){\n\t\tans++;\n\t\tuse[k] = true;\n\t\t//cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n\t\t//cout << p[k].real() << \" \" << p[k].imag() << endl;\n\t      }\n\t    }\n\t    if(!use[j]){\n\t      if(inter(p[i],p[l],p[k],p[j])){\n\t\tans++;\n\t\tuse[j] = true;\n\t\t//cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n\t\t//cout << p[j].real() << \" \" << p[j].imag() << endl;\n\t      }\n\t    }\n\t    if(!use[i]){\n\t      if(inter(p[l],p[j],p[k],p[i])){\n\t\tans++;\n\t\tuse[i] = true;\n\t\t//cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n\t\t//cout << p[i].real() << \" \" << p[i].imag() << endl;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef multimap<double,int> MDI;\ntypedef MDI::iterator MDII;\n\n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n\n\nint main(){\n\n\tint n;\n\tint max;\n\tint ans;\n\tdouble x,y;\n\tdouble hx,hy,ix,iy,jx,jy;\n\tchar gav;\n\tVPBB pin;\n\tMDI point;\n\n\twhile(1){\n\n\t\t/*入力*/\n\t\tcin>>n;\n\n\t\t/*終了*/\n\t\tif(n==0) break;\n\n\t\t/*準備*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>gav>>y;\n\t\t\tpin.PUSH(PBB(x,y));\n\t\t}\n\t\tans=0;\n\n\t\t/*端の点を決める*/\n\t\tmax=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(pin[max].second<pin[i].second) max=i;\n\t\t\telse if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n\t\t}\n\n\t\t/*基準点との角度から順番を付ける*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i!=max){\n\t\t\t\tpoint.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n\t\t\t}\n\t\t}\n\t\tpoint.insert(MDIVT(-1*INF,max));\n\n\t\t/*3点の角度から凸包を求めていく*/\n\t\tMDII iH=point.begin(),iI=point.begin(),iJ=point.begin();\n\t\tiI++,iJ++,iJ++;\n\t\twhile(iJ!=point.end()){\n\t\t\thx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n\t\t\tix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n\t\t\tjx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n\n\t\t\t/*cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug*/\n\n\t\t\tif((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0){\n\t\t\t\tiH++,iI++,iJ++;\n\t\t\t}\n\t\t\telse{\n\t\t\tiI=point.erase(iI);\n\t\t\tiJ++;\n\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\t/*出力*/\n\t\tcout<<ans<<endl;\n\n\t\t/*初期化*/\n\t\tpin.clear();\n\t\tpoint.clear();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double, double> P;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(void){\n  int n;\n  while(cin>>n){\n    if(n==0) break;\n    double x,y;\n    vector<P> point;\n    REP(i,n){\n      scanf(\"%lf,%lf\",&x,&y);\n      point.push_back(P(y,x));\n    }\n    sort(point.begin(),point.end());\n    reverse(point.begin(),point.end());\n    REP(i,point.size()){\n      swap(point[i].first,point[i].second);\n    }\n    P f,n;\n    double arg;\n    f = point[0];\n    REP(i,point.size()){\n      if(point[i].first<f.first) f = point[i];\n    }\n    vector<pair<double,P> > tmp;\n    REP(i,point.size())if(point[i]!=f){\n      arg = atan2(point[i].second-f.second,point[i].first-f.first);\n      tmp.push_back(pair<double,P>(arg,point[i]));\n    }\n    sort(tmp.begin(),tmp.end());\n    n = tmp[0].second;\n    int ans = 2;\n    arg = tmp[0].first;\n    while(n!=f){\n      double arg2;\n      vector<pair<double,P> > argvec;\n      REP(i,point.size()){\n        if(n==point[i]) continue;\n        int nx = point[i].first; int ny = point[i].second;\n        arg2 = atan2(ny-n.second, nx-n.first);\n        argvec.push_back(pair<double,P>(arg2,point[i]));\n      }\n      vector<pair<double,P> >::iterator it;\n      sort(argvec.begin(),argvec.end());\n      it = upper_bound(argvec.begin(),argvec.end(),pair<double,P>(arg,n));\n      if(it==argvec.end()) it = argvec.begin();\n      if(f==(*it).second){\n        cout<<point.size()-ans<<endl;\n        break;\n      }else{\n        arg = (*it).first;\n        n = (*it).second;\n        ans++;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <functional>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <typeinfo>\n#define PI 3.14159265359\n#define INF 99999999\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(n) rep(i, n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\nusing namespace std;\n//typedef pair<int, int> P;\n\nstruct point\n{\n\tdouble x, y;\n};\n\ninline void swap(point a[], int i, int j)\n{\n\tpoint t = a[i]; a[i] = a[j]; a[j] = t;\n}\n\ndouble theta(point p1, point p2)\n{\n\tint dx, dy, ax, ay;\n\tdouble t;\n\tdx = p2.x - p1.x; ax = abs(dx);\n\tdy = p2.y - p1.y; ay = abs(dy);\n\tt = (ax + ay == 0) ? 0 : (double) dy / (ax + ay);\n\tif (dx < 0) t = 2 - t; else if (dy < 0) t = 4 + t;\n\treturn t * 90.0;\n}\n\nint wrap(point p[], int N)\n{\n\tint i, min, M;\n\tdouble th, v;\n\tfor (min=0, i=1; i<N; i++)\n\t{\n\t\tif (p[i].y <p[min].y) min = i;\n\t}\n\tp[N] = p[min]; th = 0.0;\n\tfor (M=0; M<N; M++)\n\t{\n\t\tswap(p, M, min);\n\t\tmin = N; v = th; th = 360.0;\n\t\tfor (i=M+1; i<=N; i++)\n\t\t{\n\t\t\tif (theta(p[M], p[i]) > v)\n\t\t\t{\n\t\t\t\tif (theta(p[M], p[i]) < th)\n\t\t\t\t{\n\t\t\t\t\tmin = i; th = theta(p[M], p[min]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (min == N) return M;\n\t}\n}\n\nint n;\npoint P[100];\nchar comma;\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\trep(i, n)\n\t\t{\n\t\t\tcin >> P[i].x >> comma >> P[i].y;\n\t\t}\n\t\tcout << n - wrap(P, n) - 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#define EPS 1e-10\n#define EQ(a,b) (abs(a - b) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cross (P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool cmp_x (const P& p, const P& q) {\n    if (p.real() != q.real()) return p.real() < q.real();\n    else return p.imag() < q.imag();\n}\n\nvector<P> convex_hull (vector<P> ps) {\n    int n = ps.size(), k = 0;\n    vector<P> qs (n * 2);\n    sort(ps.begin(), ps.end(), cmp_x);\n    for (int i = 0; i < n; i++) {\n        while (k > 1 && cross (qs[k-1] - qs[k-2], ps[i] - qs[k-1]) <= 0) k--;\n        qs[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n        while (k > t && cross (qs[k-1] - qs[k-2], ps[i] - qs[k-1]) <= 0) k--;\n        qs[k++] = ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main ()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<P> ps;\n        for (int i = 0; i < n; i++) {\n            double a, b;\n            scanf(\"%lf,%lf\", &a, &b);\n            ps.push_back(P(a,b));\n        }\n\n        vector<P> qs = convex_hull (ps);\n        cout << (ps.size() - qs.size()) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<double,double>P;\n#define X first\n#define Y second\n#define pb push_back\n\ndouble mag(P p){\n\t//2次元ベクトルの大きさ\n\treturn sqrt(p.X*p.X+p.Y*p.Y);\n}\n\ndouble inner(P a,P b){\n\t//2次元ベクトルの内積\n\treturn a.X*b.X+a.Y*b.Y;\n}\n\ndouble inner_rad(P a,P b){\n\t//2つのベクトル間の角度\n\treturn acos(inner(a,b)/mag(a)/mag(b));\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<P>V;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf,%lf\",&x,&y);\n\t\t\tV.pb(P(x,y));\n\t\t\t\n\t\t\t//cout<<\"# \"<<x<<\",\"<<y<<endl;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tint st=0;\n\t\tfor(int i=1;i<V.size();i++){\n\t\t\tif(V[i].Y<V[st].Y ||( V[i].Y==V[st].Y && V[i].X>V[st].X))st=i;\n\t\t}\n\t\tint use=1;\n\t\tint now=st;\n\t\tP last=P(-10000,V[st].Y);\n\t\t\n\t\twhile(true){\n\t\t\t//if(use>7)break;\n\t\t\t//cout<<last.X<<\",\"<<last.Y<<\" : \"<<V[now].X<<\",\"<<V[now].Y<<\" : \";\n\t\t\tint next=now;\n\t\t\tdouble rad=0;\n\t\t\tfor(int i=0;i<V.size();i++){\n\t\t\t\tif(i!=now){\n\t\t\t\t\t//cout<<\"# \"<<last.X<<\",\"<<last.Y<<\" : \"<<V[now].X<<\",\"<<V[now].Y<<\" : \"<<V[i].X<<\",\"<<V[i].Y<<\" : \"<<inner_rad(P(last.X-V[now].X,last.Y-V[now].Y),P(V[i].X-V[now].X,V[i].Y-V[now].Y))<<endl;\n\t\t\t\t\tif(inner_rad(P(last.X-V[now].X,last.Y-V[now].Y),P(V[i].X-V[now].X,V[i].Y-V[now].Y))>rad){\n\t\t\t\t\t\tnext=i;\n\t\t\t\t\t\trad=inner_rad(P(last.X-V[now].X,last.Y-V[now].Y),P(V[i].X-V[now].X,V[i].Y-V[now].Y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<V[next].X<<\",\"<<V[next].Y<<endl;\n\t\t\tif(next==st){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuse++;\n\t\t\tlast=V[now];\n\t\t\tnow=next;\n\t\t}\n\t\t\n\t\tcout<<n-use<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n \n#define REP(i,s,e)\tfor(int i=(s); i<(e); i++)\n#define rep(i,n)\tREP(i,0,n)\n#define REPE(i,s,e)\tfor(int i=s; i>e; i--)\n#define repe(i,n)\tREPE(i,n,-1)\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef vector<vi> vii;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst int INF=100000000;\nconst double EPS=1e-10;\n//int mod=1000000007\n \n\n//??????????±???????\n\n// ??????????????????????¶????????????????\ndouble add(double a,double b){\n\tif(abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\n\n// ????¬?????????????????§???????\nstruct P {\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y) : x(x), y(y){\n\t}\n\tP operator + (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x * d, y * d);\n\t}\n\tdouble dot(P p){\t// ??????\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\tdouble det(P p){\t// ??????\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\n// ???????????§??????\nbool cmp_x(const P& p, const P& q){\n\tif(p.x != q.x) return p.x <q.x;\n\treturn p.y<q.y;\n}\n\n// ??????????±???????\t\nvector<P> convex_hull(P* ps, int n){\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;\t\t\t\t//?????????????????°\n\tvector<P> qs(n * 2);\t//?§????????????????\n\t// ?????´???????????????\n\tfor(int i = 0; i < n; i++){\n\t\twhile(k > 1 && (qs[k - 1] - qs[ k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\t// ?????´???????????????\n\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\twhile(k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <=0 ) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nint MAX_N =100;\nP ps[MAX_N];\n//vector<P> ps(MAX_N);\n\nint main(){\n\tint n;\n\n\twhile(cin>>n && n>0){\n\t\trep(i,n) cin>>ps[i].x>>ps[i].y;\n\t\tcout<<n-convex_hull(ps, n).size()<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n\nusing namespace std;\n\nstruct Point{\n\tbool operator<(const struct Point &arg) const{\n\t\tif(y != arg.y)return y < arg.y;\n\t\treturn x < arg.x;\n\t};\n\tdouble x,y;\n};\n\n//true?????????\nbool calcGaiseki(Point left,Point base, Point right){\n\tdouble gaiseki = (left.x-base.x)*(right.y - base.y)-(left.y-base.y)*(right.x-base.x);\n\tif(gaiseki < -0.00000001)return false;\n\telse{\n\t\treturn true;\n\t}\n}\n\nvoid func(int n){\n\tvector<Point> V,UP,DOWN;\n\tdouble x,y;\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%lf,%lf\",&x,&y);\n\t\tV.push_back(Point());\n\t\tV[i].x = x;\n\t\tV[i].y = y;\n\t}\n\n\tsort(V.begin(),V.end());\n\n\tUP.push_back(V[0]);\n\tUP.push_back(V[1]);\n\n\tDOWN.push_back(V[V.size()-1]);\n\tDOWN.push_back(V[V.size()-2]);\n\n\tfor(int i = 2; i < V.size(); i++){\n\t\twhile(UP.size() > 1 && calcGaiseki(UP[UP.size()-2],UP[UP.size()-1],V[i]) == false)UP.pop_back();\n\t\tUP.push_back(V[i]);\n\t}\n\n\tfor(int i = V.size()-3; i >= 0; i--){\n\t\twhile(DOWN.size() > 1 && calcGaiseki(DOWN[DOWN.size()-2],DOWN[DOWN.size()-1],V[i]) == false){\n\t\t\tDOWN.pop_back();\n\t\t}\n\t\tDOWN.push_back(V[i]);\n\t}\n\n\tprintf(\"%d\\n\",n-(UP.size()+DOWN.size()-2));\n}\n\nint main(){\n\n\tint n;\n\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\n\t\tfunc(n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int>T in() { T x; cin >> x; return x; }\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define _REP(i,n)for(int i=1;i<=(n);++i)\n#define REPC(i,c)for(auto i:c)\nstruct vec2d\n{\n\tdouble x, y;\n\tvec2d() {}\n\tvec2d(double _x, double _y) :x(_x), y(_y) {}\n\tdouble norm()const\n\t{\n\t\treturn hypot(x, y);\n\t}\n\tdouble operator*(const vec2d&v)const\n\t{\n\t\treturn x * v.x + y * v.y;\n\t}\n\tvec2d operator-(const vec2d&v)const\n\t{\n\t\treturn vec2d(x - v.x, y - v.y);\n\t}\n\tbool operator==(const vec2d&v)const\n\t{\n\t\treturn x == v.x && y == v.y;\n\t}\n\tbool operator!=(const vec2d&v)const\n\t{\n\t\treturn !operator==(v);\n\t}\n\tstatic double cos_arg(const vec2d&v1, const vec2d&v2)\n\t{\n\t\treturn v1 * v2 / v1.norm() / v2.norm();\n\t}\n};\nint main()\n{\n\tfor (int n = in(); n != 0; n = in())\n\t{\n\t\tvector<vec2d>v(n);\n\t\tint min_x_idx;\n\t\tdouble min_x = 2000;\n\t\tREP(i, n)\n\t\t{\n\t\t\tv[i].x = in<double>();\n\t\t\tin<char>();\n\t\t\tv[i].y = in<double>();\n\t\t\tif (min_x > v[i].x)\n\t\t\t{\n\t\t\t\tmin_x = v[i].x;\n\t\t\t\tmin_x_idx = i;\n\t\t\t}\n\t\t}\n\t\tvector<vec2d>wrap;\n\t\twrap.push_back(v[min_x_idx]);\n\t\tauto previous = vec2d(v[min_x_idx].x, -2000);\n\t\twhile (true)\n\t\t{\n\t\t\tint max_cos_idx;\n\t\t\tdouble max_cos = -10;\n\t\t\tREP(i, v.size())\n\t\t\t{\n\t\t\t\tif (v[i] != wrap.back() && v[i] != previous)\n\t\t\t\t{\n\t\t\t\t\tdouble cosine = vec2d::cos_arg(wrap.back() - previous, v[i] - wrap.back());\n\t\t\t\t\tif (max_cos < cosine)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax_cos = cosine;\n\t\t\t\t\t\tmax_cos_idx = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[max_cos_idx] == wrap.front())break;\n\t\t\tprevious = wrap.back();\n\t\t\twrap.push_back(v[max_cos_idx]);\n\t\t}\n\t\tcout << v.size() - wrap.size() << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> point;\n\nnamespace std {\n    bool operator < (const point& a, const point& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ndouble cross(const point& a, const point& b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n    return real(conj(a)*b);\n}\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\nvector<point> convex_hull(vector<point> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<point> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\nint main()\n{\n    int n;\n    char ch;\n\n    while (cin >> n, n) {\n        vector<point> input(n);\n        vector<point> convex;\n        \n        for (int i = 0; i < n; i++) \n            cin >> input[i].real() >> ch >> input[i].imag();\n        convex = convex_hull(input);\n        cout << n - convex.size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint main() {\n\tint n,i,k,p,cn;\n\tdouble x[100],y[100],dx,dy,sx,sy,a,b,c,d,e;\n\twhile(cin >> n) {\n     if (n==0) break;\n\t for (i=0;i<n;i++) scanf(\"%lf,%lf\",&x[i],&y[i]);\n     sy=-1000;\n\t for (i=0;i<n;i++) if (y[i]>sy) { sy=y[i]; k=i;}\n\t dx=x[k]-10; dy=y[k]; sx=x[k];  sy=y[k]; cn=0;\n\t do {\n        e=2; \n\t\tfor (i=0;i<n;i++) {\n\t\t\tif (!((x[i]==dx && y[i]==dy) || (x[i]==sx && y[i]==sy))) {\n            c=sqrt((sx-dx)*(sx-dx)+(sy-dy)*(sy-dy));\n\t\t\tb=sqrt((x[i]-sx)*(x[i]-sx)+(y[i]-sy)*(y[i]-sy));\n\t\t\ta=sqrt((x[i]-dx)*(x[i]-dx)+(y[i]-dy)*(y[i]-dy));\n            d=(b*b+c*c-a*a)/(2*b*c);\n\t\t\tif (d<e) { e=d; p=i; }\n\t\t\t}\n\t\t}\n\t\tdx=sx; dy=sy; sx=x[p]; sy=y[p];\n        cn++;\n\t } while(!(sx==x[k] && sy==y[k]));\n\t cout << n-cn << endl;\n\t}\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-9\n\nstruct P {\n\tdouble x, y;\n};\n\ndouble abs(P p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\ndouble dot(P p1, P p2) {\n\treturn p1.x * p2.x + p1.y * p2.y;\n}\ndouble xx(double r) {\n\treturn r*r;\n}\n\nint main() {\n\tint n; cin >> n;\n\tfor (int t = 0; t < n; ++t) {\n\t\tdouble x1, x2, x3, y1, y2, y3;\n\t\tcin >> x1 >> y1;\n\t\tcin >> x2 >> y2;\n\t\tcin >> x3 >> y3;\n\n\t\tP a = (P){ x2 - x1, y2 - y1 };\n\t\tP b = (P){ x3 - x2, y3 - y2 };\n\t\tP c = (P){ x1 - x3, y1 - y3 };\n\n\t\tdouble R =  abs(a) / (sqrt(1 - xx(dot(b, c) / abs(b) / abs(c))) * 2);\n\t\tdouble l = sqrt( R*R - xx(abs(c)/2) );\n\t\tdouble gx = (x1+x3)/2, gy = (y1+y3)/2;\n\t\tP e = (P){ -c.y/abs(c), c.x/abs(c) };\n\t\tP eg = (P){ e.x * l, e.y * l };\n\t\tP g1 = (P){ gx + eg.x, gy + eg.y };\n\t\tP g2 = (P){ gx - eg.x, gy - eg.y };\n\t\tif ( abs(xx(x1-g1.x) + xx(y1-g1.y) - R) < EPS ) gx = g1.x, gy = g1.y;\n\t\telse gx = g2.x, gy = g2.y;\n\t\tif ( abs(gx) < EPS ) gx = abs(gx);\n\t\tif ( abs(gy) < EPS ) gy = abs(gy);\n\t\tprintf(\"%.3f %.3f %.3f\\n\", gx, gy, R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x(0), y(0)\n\t{\n\t\treturn;\n\t}\n\n\tPoint(double x,double y) : x(x), y(y)\n\t{\n\t\treturn;\n\t}\n\n\tPoint operator - (const Point &a) const\n\t{\n\t\treturn Point(x - a.x,y - a.y);\n\t}\n\n\tbool operator < (const Point &a) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n\n\tvoid input()\n\t{\n\t\tchar c;\n\t\tcin >> x >> c >> y;\n\t}\n\n\tdouble det(const Point &a)\n\t{\n\t\treturn x * a.y - y * a.x;\n\t}\n};\n\n\nvector< Point > convex_hull(vector< Point > ps)\n{\n\tint N = ps.size();\n\tsort(ps.begin(),ps.end());\n\n\tint k = 0;\n\tvector<Point> convex(N*2);\n\n\trep(i,N)\n\t{\n\t\twhile (2 <= k && (convex[k-1] - convex[k-2]).det(ps[i] - convex[k-1]) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\tconvex[k++] = ps[i];\n\t}\n\n\tfor(int i = N-2,t = k; 0 <= i;i--)\n\t{\n\t\twhile (t < k && (convex[k-1] - convex[k-2]).det(ps[i] - convex[k-1]) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.resize(k-1);\n\treturn convex;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector< Point > ps( n );\n\n\t\trep(i,n)\n\t\t{\n\t\t\tps[i].input();\n\t\t}\n\n\t\tvector< Point > convex = convex_hull( ps );\n\n\t\tcout << n - convex.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS )\n\n// Point, Vector class\nclass Point {\npublic:\n  double x, y;\n\n  Point( double x = 0, double y = 0 ): x(x), y(y){}\n\n  Point operator + ( Point p ){ return Point( x + p.x, y + p.y ); }\n  Point operator - ( Point p ){ return Point( x - p.x, y - p.y ); }\n  Point operator * ( double k ){ return Point( x * k, y * k ); }\n\n  double abs() { return sqrt( norm() ); }\n  double norm() { return x * x + y * y; }\n\n  bool operator < ( const Point& p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == ( const Point& p ) const {\n    return fabs( x - p.x ) < EPS && fabs( y - p.y ) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// Segment\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\n\ndouble norm( Point p ) {\n  return p.x * p.x + p.y * p.y;\n}\n\ndouble abs( Point p ) {\n  return sqrt( norm( p ) );\n}\n\ndouble dot( Vector a, Vector b ) {\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross( Vector a, Vector b ) {\n  return a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal( Vector a, Vector b ) {\n  return equals( dot(a, b), 0.0 );\n}\n\nbool isOrthogonal( Point a1, Point a2, Point b1, Point b2 ) {\n  return isOrthogonal( a1 - a2, b1 - b2 );\n}\n\nbool isOrthogonal( Segment s1, Segment s2 ) {\n  return equals( dot( s1.p2 - s1.p1, s2.p2 - s2.p1 ), 0.0 );\n}\n\nbool isParallel( Vector a, Vector b ) {\n  return equals( cross( a, b ), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2 ) {\n  return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ) {\n  return equals( cross( s1.p2-s1.p1, s2.p2 - s2.p1 ), 0.0 );\n}\n\nPoint project( Segment s, Point p ) {\n  Vector base = s.p2 - s.p1;\n  double t = dot( p - s.p1, base ) / base.norm();\n  return s.p1 + base * t;\n}\n\nPoint reflect( Segment s, Point p ) {\n  return p + ( project( s, p ) - p ) * 2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if ( cross( a, b ) > EPS ) return COUNTER_CLOCKWISE;\n  if ( cross( a, b ) < -EPS ) return CLOCKWISE;\n  if ( dot( a, b ) < -EPS ) return ONLINE_BACK;\n  if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect( Point p1, Point p2, Point p3, Point p4 ) {\n  return ( ccw( p1, p2, p3 ) * ccw( p1, p2, p4 ) <= 0 &&\n\t   ccw( p3, p4, p1 ) * ccw( p3, p4, p2 ) <= 0 );\n}\n\nbool isIntersect( Segment s1, Segment s2 ) {\n  return isIntersect( s1.p1, s1.p2, s2.p1, s2.p2 );\n}\n\nPoint getCrossPoint( Segment s1, Segment s2 ) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs( cross( base, s1.p1 - s2.p1 ) );\n  double d2 = abs( cross( base, s1.p2 - s2.p1 ) );\n  double t = d1 / ( d1 + d2 );\n  return s1.p1 + ( s1.p2 - s1.p1 ) * t;\n}\n\ndouble getDistance( Point a, Point b ) {\n  Point c = a - b;\n  return c.abs();\n}\n\ndouble getDistanceLP( Line s, Point p ) {\n  return abs( cross( s.p2 - s.p1, p - s.p1 ) / abs( s.p2 - s.p1 ) );\n}\n\ndouble getDistanceSP( Segment s, Point p ) {\n  Point c1 = p - s.p1;\n  Point c2 = p - s.p2;\n  if ( dot( s.p2 - s.p1, p - s.p1 ) < 0.0 ) return c1.abs();\n  if ( dot( s.p1 - s.p2, p - s.p2 ) < 0.0 ) return c2.abs();\n  return getDistanceLP( s, p );\n}\n\ndouble getDistance( Segment s1, Segment s2 ) {\n  if ( isIntersect( s1, s2 ) ) return 0.0;\n  return min( min( getDistanceSP( s1, s2.p1 ), getDistanceSP( s1, s2.p2 ) ),\n\t      min( getDistanceSP( s2, s1.p1 ), getDistanceSP( s2, s1.p2 ) ));\n}\n\nint main() {\n    string line;\n    while ( getline( cin, line ) ) {\n        istringstream isn( line );\n        int n;\n        isn >> n;\n        if ( n == 0 ) break;\n        Point P[101];\n        for ( int i = 0; i < n; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            istringstream is( line );\n            double x, y;\n            is >> x >> y;\n            P[i].x = x;\n            P[i].y = y;\n        }\n        sort( P, P+n );\n\n        int s = 0, t = n-1;\n        int answer = 0;\n        bool used[101];\n        for ( int i = 0; i < n; i++ ) used[i] = false;\n        used[s] = used[t] = true;\n\n        for ( int i = 0; i < n; i++ ) {\n            if ( used[i] ) continue;\n            for ( int j = 0; j < n; j++ ) {\n                if ( used[j] ) continue;\n                Vector a( P[s] - P[j] );\n                Vector b( P[i] - P[j] );\n                Vector c( P[t] - P[j] );\n                if ( ( cross( a, b ) > 0 && cross( b, c ) > 0 && cross( c, a ) > 0 ) ||\n                     ( cross( a, b ) < 0 && cross( b, c ) < 0 && cross( c, a ) < 0 ) ) {\n                    answer++;\n                    used[j] = true;\n                }\n            }\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> Point;\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (a.real() == b.real())\n      return a.imag() < b.imag();\n    else\n      return a.real() < b.real();\n  }\n}\n\nint ccw(Point p1, Point p2, Point p3)\n{\n  p2 -= p1;\n  p3 -= p1;\n  double det = (conj(p2)*p3).imag();\n  if (det > 0) return 1;\n  if (det < 0) return -1;\n  return 0;\n}\n\nvector<Point> convex_hull(vector<Point>& ps)\n{\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main()\n{\n  int N;\n  while (scanf(\"%d\", &N), N) {\n    vector<Point> ps;\n    for (int i = 0; i < N; ++i) {\n      double x, y;\n      scanf(\"%lf,%lf\", &x, &y);\n      ps.push_back(Point(x, y));\n    }\n    vector<Point> ch(convex_hull(ps));\n    printf(\"%d\\n\", N - ch.size());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define each(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define chmin(a, b) a = min(a, b)\n#define chmax(a, b) a = max(a, b)\n#define pb push_back\n#define mp make_pair\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\ndouble SQ(double a){ return a * a; }\nbool EQ(double a, double b){ return abs(a - b) < EPS; }\nbool LT(double a, double b){ return a - b < -EPS; }\nbool LEQ(double a, double b){ return a - b < EPS; }\n\ndouble toRad(double t){ return t / 180 * PI; }\ndouble toDeg(double t){ return t * 180 / PI; }\n\ntypedef complex<double> Point;\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\tif (a.X != b.X) return a.X < b.X;\n\t\treturn a.Y < b.Y;\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point &a){\n\t\treturn os << a.X << \" \" << a.Y;\n\t}\n}\n\nstruct Line {\n\tPoint p1, p2;\n};\n\ntypedef Line Segment;\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n};\n\ntypedef vector<Point> Polygon;\n\n\ndouble norm(Point p){ return SQ(p.X) + SQ(p.Y); }\n\ndouble dot(Point a, Point b){ return (conj(a) * b).X; }\ndouble cross(Point a, Point b){ return (conj(a) * b).Y; }\n\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\nint ccw(Point p0, Point p1, Point p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool orthogonal(Line l1, Line l2){\n\treturn EQ(dot(l1.p2 - l1.p1, l2.p2 - l2.p1), 0.0);\n}\n\nbool parallel(Line l1, Line l2){\n\treturn EQ(cross(l1.p2 - l1.p1, l2.p2 - l2.p1), 0.0);\n}\n\nPoint project(Line l, Point p){\n\tPoint base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\nPoint reflect(Line &l, Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\nbool sameLine(Line l1, Line l2){\n\treturn abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)) < EPS;\n}\n\nbool intersectLP(Line l, Point p){\n\treturn LEQ(abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(Line l1, Line l2){\n\treturn !parallel(l1, l2) || sameLine(l1, l2);\n}\n\nbool intersectLS(Line l, Segment s){\n\treturn cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1) < -EPS;\n}\n\nbool intersectSP(Segment s, Point p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\nbool intersectSS(Segment s1, Segment s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0\n\t\t&& ccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\ndouble distanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)) / abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(Line l1, Line l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(Line l, Segment s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(Segment s, Point p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\ndouble distanceSS(Segment s1, Segment s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\nPoint crossPointLL(Line l1, Line l2){\n\tassert(intersectLL(l1, l2));\n\tassert(!sameLine(l1, l2));\n\tPoint base = l2.p2 - l2.p1;\n\tdouble d1 = abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(Line l, Segment s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(Segment s1, Segment s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointLL(s1, s2);\n}\n\nenum {\n\tIN = 2,\n\tON = 1,\n\tOUT = 0,\n};\n\nint contains(const Polygon &g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\trep(i, n){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y < EPS && EPS < b.Y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn x ? IN : OUT;\n}\n\nPolygon convexHull(Polygon &s){\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\t\n\tu.pb(s[0]); u.pb(s[1]);\n\tl.pb(s[s.size() - 1]); l.pb(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++){\n\t\tint n = u.size();\n\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\tu.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tu.pb(s[i]);\n\t}\n\t\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tint n = l.size();\n\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\tl.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tl.pb(s[i]);\n\t}\n\t\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.pb(u[i]);\n\t\n\treturn l;\n}\n\nint n;\nPolygon ps;\n\nint main()\n{\n\twhile (scanf(\"%d\", &n), n){\n\t\tps.resize(n);\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tps[i] = Point(x, y);\n\t\t}\n\t\t\n\t\tint res = n - convexHull(ps).size();\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<30;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-10;\n\ntypedef complex<double> P;\ntypedef complex<double> Vec;\n\ndouble cross(Vec a, Vec b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool comp(P a, P b) {\n\tif (a.real() != b.real()) return a.real() < b.real();\n\treturn a.imag() < b.imag();\n}\n\nvector<P> convex_full(vector<P> p) {\n\tsort(ALL(p), comp);\n\t\n\tvector<P> res(2 * p.size());\n\tint k = 0;\n\t\n\t// ?????´??????\n\tREP(i, p.size()) {\n\t\twhile (k > 1 && cross(res[k - 1] - res[k - 2], p[i] - res[k - 2]) <= 0) k--;\n\t\tres[k++] = p[i];\n\t}\n\t\n\t// ?????´??????\n\tfor (int i = (int)p.size() - 2, c1 = k; i >= 0; i--) {\n\t\twhile (k > c1 && cross(res[k - 1] - res[k - 2], p[i] - res[k - 2]) <= 0) k--;\n\t\tres[k++] = p[i];\n\t}\n\t\n\tres.resize(k - 1);\n\treturn res;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<P> p(n);\n\t\tREP(i, n) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tp[i] = P(x, y);\n\t\t}\n\t\t\n\t\tvector<P> cf = convex_full(p);\n\t\t\n\t\tprintf(\"%d %d\\n\", p.size(), cf.size());\n\t\t\n\t\tcout << p.size() - cf.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nstruct p{\n    double x,y;\n};\n\nvoid sort(struct p p[105], int n){\n    rep(i,n){\n        rep(j,n - 1){\n            if(p[j].x > p[j + 1].x){\n                struct p temp = p[j];\n                p[j] = p[j + 1];\n                p[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        struct p p[105];\n        vector<struct p> u;\n        vector<struct p> l;\n        rep(i, n){\n            char g;\n            cin >> p[i].x >> g >> p[i].y;\n        }\n        sort(p, n);\n\n        u.pb(p[0]);\n        u.pb(p[1]);\n        l.pb(p[n-1]);\n        l.pb(p[n-2]);\n\n        range(i,2,n){\n            while(u[u.size() - 2].y > u[u.size() - 1].y && u[u.size() - 1].y < p[i].y){\n                u.pop_back();\n            }\n            u.pb(p[i]);\n        }\n        for(int i = n - 1; i >= 2; i--){\n            while(l[l.size() - 2].y < l[l.size() - 1].y  && l[l.size() - 1].y > p[i].y){\n                l.pop_back();\n            }\n            l.pb(p[i]);\n        }\n\n        cout << n - u.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\ntypedef pair<double,double> pd;\n\npd D[100];\nint A[100];\nint n;\n\nint side(pd p1, pd p2){\n\tdouble dy=p2.first-p1.first,dx=p2.second-p1.second;\n\tfor(int i=0;i<n;i++){\n\t\tpd p3=D[i];\n\t\tif (p1==p3||p2==p3)continue;\n\t\tif ((p3.second-p1.second)*dy-dx*(p3.first-p1.first)<0) return 0;\n\t}\n    return 1;\n}\n\nint main(){\n\twhile (1){\n\t\tint i,s;\n\t\tpd p,p1,p2;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif (n==0) break;\n\t\tfor (i=0;i<n;i++){\n\t\t\tcin>>D[i].first>>c>>D[i].second;\n\t\t\tA[i]=0;\n\t\t}\n\t\tsort(D,D+n);\n\t\tp=D[0];\n\t\tp1=p;\n\t\ts=0;\n\t\twhile (1){\n\t\t\tfor (i=0;i<n;i++){\n\t\t\t\tp2=D[i];\n\t\t\t\tif (A[i]==0 && p1!=p2 && side(p1,p2)) break;\n\t\t\t}\n\t\t\tp1=p2;\n\t\t\tA[i]=1;\n\t\t\ts++;\n\t\t\tif (p2==p) break;\n\t\t}\n\t\tcout<<n-s<<\"\\n\";\n\t\tfor (i=0;i<n;i++){\n\t\t\tD[i]=make_pair(0,0);\n\t\t\tA[i]=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// 度->ラジアンの変換\n#define DEGtoRAD(X) (X*PI)/180.0\n// 円周率\nconst double PI = 2 * acos(0.0);\n// 許容誤差.問題によって変える\nconst double EPS = 1e-9;\n\nstruct point{\n    double x, y;\n    point(){ x = y = 0.0;}\n    point(double _x, double _y) : x(_x), y(_y) {}\n\n    // 不等号のオーバーロード.x座標,y座標で昇順ソート\n    bool operator < (const point other) const{\n        if(fabs(x - other.x) > EPS)\n            return x < other.x;\n        else\n            return y < other.y;\n    }\n\n    // 等号のオーバーロード.\n    bool operator == (const point other) const{\n        return fabs(x - other.x) < EPS &&\n                fabs(y - other.y) < EPS;\n    }\n};\n\n// 2つのpoint間の距離 std::hypotenuse(斜辺)を利用\ndouble dist(point p1, point p2){\n    return hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\n// ベクトル\nstruct vec{\n    double x, y;\n    vec(double _x, double _y) : x(_x), y(_y) {}\n};\n\n// 2つのpoint a,b をvec a->b に変換\nvec toVec(point a, point b){\n    return vec(b.x - a.x, b.y - a.y);\n}\n\n// vecの外積\ndouble cross(vec v1, vec v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\nbool ccw(point p, point q, point r){\n    return cross(toVec(p, q), toVec(p, r)) > 0;\n}\n\n// 3つのpointが単一直線上にあるかどうかの判定\nbool collinear(point p, point q, point r){\n    return fabs(cross(toVec(p, q), toVec(p, r))) < EPS;\n}\n\n// 凸包を求めるのに用いる一連の関数\npoint pivot(0.0, 0.0);\n\n// Graham's Scanの前準備で必要な,pivotからの偏角でソートするときに必要な比較関数\nbool angleCmp(point a, point b){\n    // 偏角が同じ(pivot,a,bが単一直線上に乗っている)場合は,pivotからの距離が近い方を優先\n    if(collinear(pivot, a, b)){\n        return dist(pivot, a) < dist(pivot, b);\n    }\n\n    double d1x = a.x - pivot.x, d1y = a.y - pivot.y;\n    double d2x = b.x - pivot.x, d2y = b.y - pivot.y;\n\n    return (atan2(d1y, d1x) - atan2(d2y, d2x)) < 0;\n}\n\n// 与えられた点群から凸包を求める(Graham's Scan)\nvector<point> ConvexHull(vector<point> P){\n    int i, j, n = (int)P.size();\n\n    // 点群が3つしかない場合,P[0]をPに加える(輪っかのイメージ)\n    if(n <= 3){\n        if(!(P[0] == P[n-1]))  P.push_back(P[0]);\n        return P;\n    }\n\n    // pivotを定める.最下,最右の点\n    int P0 = 0;\n    for(i = 1; i < n; i++){\n        if(P[i].y < P[P0].y || \n           (P[i].y == P[P0].y && P[i].x > P[P0].x)){\n               P0 = i;\n        }\n    }\n\n    // P[0]とpivotとして選ばれたP[P0]をスワップ\n    point temp = P[0];\n    P[0] = P[P0];\n    P[P0] = temp;\n\n    pivot = P[0];\n    sort(++P.begin(), P.end(), angleCmp);\n\n    vector<point> S;\n    S.push_back(P[n-1]);\n    S.push_back(P[0]);\n    S.push_back(P[1]);\n    \n    i = 2;\n    while(i < n){\n        j = (int)S.size() - 1;\n\n        if(ccw(S[j-1], S[j], P[i]))\n            S.push_back(P[i++]);\n        else\n            S.pop_back();\n    }\n\n    return S;\n}\n\nint main(){\n    int n;\n    vector<point> p, ch;\n    while(1){\n        scanf(\"%d\", &n);\n        if(n == 0)  break;\n\n        p.clear();\n        ch.clear();\n        double x, y;\n        for(int i = 0; i < n; i++){\n            scanf(\"%lf,%lf\", &x, &y);\n            p.push_back(point(x,y));\n        }\n\n        ch = ConvexHull(p);\n        \n        printf(\"%d\\n\", n-ch.size()+1);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n/*\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n*/\n// (B)\nenum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t三角形と点の包含判定\n\n\t説明\n\t\t三角形 abc が点 p を含むかどうかを判定する\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\t三角形は縮退していないこと\n\t\tすなわち、三点が同一直線上にないこと、（特に、どの二点も等しくないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形は CCW でも CW でもよい\n\t\t点が三角形の境界になるときは含むと判定する\n\t\tVerified: AOJ 0012: A Point in a Triangle\n\t\tVerified: AOJ 0143: Altair and Vega \n*/\ntemplate<class T>\nbool cover(const point<T> &a, const point<T> &b, const point<T> &c, const point<T> &p ){\n\tint d1 = ccw (p, a, b );\n\tint d2 = ccw (p, b, c );\n\tint d3 = ccw (p, c, a );\n\treturn !((d1 == CCW && d2 == CW ) || (d1 == CCW && d3 == CW ) || (d2 == CCW && d3 == CW ) || (d1 == CW && d2 == CCW ) || (d1 == CW && d3 == CCW ) || (d2 == CW && d3 == CCW ) );\n}\n\n/*\n\t内接円の半径\n\n\t説明\n\t\t辺長がそれぞれ、a, b, c である三角形の内接円の半径を求める\n\t引数\n\t\ta: 辺長\n\t\tb: 辺長\n\t\tc: 辺長\n\t戻り値\n\t\t内接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, c < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble inradius(double a, double b, double c ){\n\treturn sqrt ((b+c-a)*(c+a-b)*(a+b-c)/(a+b+c))/2.;\n}\n\n/*\n\t外接円\n\n\t説明\n\t\t三角形 abc の外接円を求める\n\t引数\n\t\ta: 頂点\n\t\tb: 頂点\n\t\tc: 頂点\n\t戻り値\n\t\t外接円\n\t制約\n\t\ta, b, c は同一直線上にないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\ta, b, c が同一直線上にあるときは外接円は存在しない\n\t\t頂点が整数座標のとき、外心の座標と半径の二乗は有理数となる\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ncircle<double> circumcircle(const point<double> &a, point<double> b, point<double> c ){\n\tb-=a; c-=a;\n\tdouble A2 = abs2(b-c), B2 = abs2(b), C2 = abs2(c);\n\tdouble d = 2*cross(b,c);\n\tdouble nx = c.y*B2-b.y*C2;\n\tdouble ny = b.x*C2-c.x*B2;\n\tdouble r2 = A2*B2*C2/(d*d);\n\treturn (circle<double>){a+(point<double>){nx/d, ny/d}, sqrt(r2)};\n}\n\n/*\n\t外接円の半径\n\t\n\t説明\n\t\t辺長がそれぞれ a, b, c である三角形の外接円の半径を求める\n\t引数\n\t\ta : 辺長\n\t\tb : 辺長\n\t\tc : 辺長\n\t戻り値\n\t\t外接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, b < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ndouble circumradius(double a, double b, double c ){\n\treturn a*b*c/sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c) );\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t凸性判定\n\t\n\t説明\n\t\t多角形が凸かどうかを判定する\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tG は単調かつ頂点の順番が CCW で与えられていること\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\ntemplate<class T>\nbool is_convex(const polygon<T> &G ){\n\tint n = G.size();\n\trep (i, n ) if (ccw (G[i], G[(i+1)%n], G[(i+2)%n])== CW ) return false;\n\treturn true;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079: Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t凸包\n\n\t説明\n\t\t点集合の凸包を求める\n\t引数\n\t\tP : 点集合\n\t戻り値\n\t\tP の凸包\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n log n )\n\t備考\n\t\tP は破壊される。\n\n\t\tsort は (x, y ) の辞書順。\n\n\t\t凸包の同じ直線上にある頂点は端のものだけを拾う。\n\t\t辺上になる頂点を全部拾うようにしたいときは != CCW を ==CW と修正すればよい。\n*/\n\ntemplate<class T>\npolygon<T> convex_hull(vector< point<T> > &P ){\n\tint n = P.size();\n\tpolygon<T> CH;\n\tif (n <= 1 ){\n\t\tCH.insert (CH.end(), P.begin(), P.end() );\n\t\treturn CH;\n\t} // end if\n\tsort (ALL (P ) );\n\trep (cnt, 2 ){\n\t\tint m = 0;\n\t\tvector< point<T> > half(n );\n\t\trep (i, n ){\n\t\t\thalf[m++] = P[i];\n\t\t\twhile (m >= 3 && ccw (half[m-3], half[m-2], half[m-1] ) == CW ){\n\t\t\t\thalf[m-2] = half[m-1];\n\t\t\t\tm--;\n\t\t\t} // end while\n\t\t} // end rep\n\t\tCH.insert (CH.end(), half.begin(), half.begin()+m-1 );\n\t\treverse (ALL (P ) );\n\t} // end rep\n\t\n\treturn CH;\n}\n\n/*\n\t多角形と線分の交差判定\n\n\t説明\n\t\t多角形と線分が交わるかどうかを判定する\n\t引数\n\t\tG : 多角形\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n)\n\t備考\n\t\tG は凸でなくていい。\n\t\tG は境界を含む\n\t\tS が G の内部にあるときは交わると判定する\n*/\ntemplate<class T>\nbool intersect(const polygon<T> &G, const segment<T> &S ){\n\tint n = G.size();\n\tif (cover(G, S.a ) || cover (G, S.b ) ) return true;\n\trep (i, n ) if (intersect((segment<T>){G[i], G[(i+1)%n]}, S ) ) return true;\n\treturn false;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.0068\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tpolygon<double> G(n );\n\t\trep (i, n ) scanf (\"%lf,%lf\", &G[i].x, &G[i].y );\n\t\tpolygon<double> convex = convex_hull (G );\n\t\tint res = n - convex.size();\n\t\tprintf (\"%d\\n\", res );\t\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nclass Point{\npublic:\n  double x,y;\n  Point (double x = 0,double y = 0): x(x),y(y){}\n  Point operator + (Point &p){ return Point(x+p.x,y+p.y);}\n  Point operator - (Point &p){ return Point(x-p.x,y-p.y);}\n  Point operator * (double k){ return Point(x*k,y*k);}\n  bool operator < (const Point &p)const {\n    if(x == p.x) return y < p.y;\n    else return x < p.x;\n  }\n\n};\ntypedef Point Vector;\n\ndouble cross(Vector a, Vector b){ return a.x * b.y - a.y * b.x;}\n\nint Convex_Hull(vector<Point> v){\n  vector<Point> c; //convex\n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n\n  for(int i=2;i<v.size();i++){\n    Vector a = c[c.size()-1] - c[c.size()-2];\n    Vector b = v[i] - c[c.size()-2];\n\n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n\n    c.push_back(v[i]);\n  }\n\n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n\n  for(int i=v.size()-3;i>=0;i--){\n    Vector a = c[c.size()-1] - c[c.size()-2];\n    Vector b = v[i] - c[c.size()-2];\n\n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n\n    c.push_back(v[i]);\n  }\n  c.pop_back();\n\n  return c.size();\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<Point> v(n);\n    for(int i=0;i<n;i++) scanf(\"%lf,%lf\",&v[i].x,&v[i].y);\n    cout << n - Convex_Hull(v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\n//?????¢?????¢???\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\nint main(){\n  Polygon p,pp;\n  Point s;\n  int n;char t;\n  cin>>n;\n  r(i,n){\n    cin>>s.x>>t>>s.y;\n    p.push_back(s);\n  }pp=andrewScan(p);\n  cout<<n-pp.size()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 凸包の構成について扱います\n *\n * @note  点集合Qの各点がその境界上か内部にある最小の凸多角形PをQの凸包(convex hull)と言い、CH(Q)で表す\n *        集合Qの点はすべて異なり、同一直線上にはない3点を少なくとも含むと仮定する\n *        直観的には、Qの各点を板から突き出した釘であると考えることができる. これらすべての釘を取り囲む、強い輪ゴムが作る形状が凸包である\n *\n * @date  2016/03/21\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <functional>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing coord_t    = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    coord_t x, y;\n    point() : x(0), y(0) {}\n    point(coord_t x, coord_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p)  { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p)  { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const coord_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const coord_t d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orientation {\n    cw    = -1,\n    ccw   = +1,\n    back  = +2,\n    front = -2,\n    on    = 0,\n};\n\n\n\n/**\n * @brief 述語オブジェクト\n */\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return coord_t det(A)    行列式|(a, b)|\n */\nstatic constexpr coord_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a x b      クロス積a x b\n */\nstatic constexpr coord_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return coord_t a・b       ドット積a・b\n */\nstatic constexpr coord_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return coord_t norm(v);\n */\nstatic constexpr coord_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return coord_t sqrt(norm(v))\n */\nstatic inline coord_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n/**\n * @brief  点pから線分sに下ろした垂線と線分sの交点を返します\n * @param  const segment& s 線分s\n * @param  const point& p   点p\n * @return 垂線と線分の交点\n */\nstatic inline point proj(const segment& s, const point& p)\n{\n    vector_t base = s.pd - s.ps;\n    vector_t hypo = p - s.ps;\n    coord_t r = dot(hypo, base) / norm(base);\n    return s.ps + base * r;\n}\n\n\n/**\n * @brief  点pと線対称の位置に存在する点を返します\n * @param  cosnt segment& s 線分s\n * @param  const point&   p 点p\n * @param  pと線対称な点\n */\nstatic inline point reflect(const segment& s, const point p)\n{\n    return p + (proj(s, p) - p) * 2.0;\n}\n\n\n/**\n * @brief COMBINED-TOLERANCE-COMPAREより少ない労力で行える近似的な判定\n */\nstatic inline bool approximate_combined_tolerance_compare(coord_t x, coord_t y) noexcept\n{\n    return std::fabs(x - y) <= limits::eps * (std::fabs(x) + std::fabs(y) + 1.0);\n}\n\n\n/**\n * @brief 手続きAPPROXIMATE-COMBINED-TOLERANCE-COMPAREの短い名前\n */\nstatic inline bool eq(coord_t x, coord_t y)\n{\n    return approximate_combined_tolerance_compare(x, y);\n}\n\n\n/**\n * @brinf 2点(p1, p2)のp0に関する偏角(polar angle)から、\n *        p0から見た2つのベクトルp0p1↑, p0p2↑の方向を返す\n */\nstatic inline orientation ccw(point p0, point p1, point p2)\n{\n    p1 -= p0; p2 -= p0;\n\n    if (cross(p1, p2) > limits::eps)  { return orientation::ccw;  }  // クロス積(p1-p0)x(p2-p0)が正の場合、ccw  ...(*1)\n    if (cross(p1, p2) < -limits::eps) { return orientation::cw;   }  // クロス積(p1-p0)x(p2-p0)が負の場合、cw   ...(*2)\n\n\n    // (*1), (*2)に当てはまらないとき、p2は直線p0p1|上(線分p0p1↑上とは限らない)に存在する\n\n    if (dot(p1, p2) < -limits::eps)   { return orientation::back;  }  // ドット積(p1-p0)・(p2-p0)が負の場合、p2->p0->p1(back) ...(*3)\n\n    // (*3)に当てはまらないとき、p2はp0->p1->p2またはp0->p2->p1の位置に存在する\n\n    if (eq(norm(p1), norm(p2)))       { return orientation::front; }  // p0p2↑の大きさがp0p1↑の大きさより大きい場合、p0->p1->p2(front) ...(*4)\n\n    // (*4)に当てはまらないとき、p0->p2->p1(on)\n    return orientation::on;\n}\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_xy { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x || (eq(pi.x, pj.x) && pi.y < pj.y); } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\npolygon_t andrew_scan(polygon_t& P, bool degenerate)\n{\n    index_t n = P.size(), k = 0;\n\n    // 与えられた点の中からすべての点を左から右に順序付けする\n    std::sort(P.begin(), P.end(), cmp_xy());  // NOTE: xが等しい場合、yの昇順とする\n\n    // 上側チェーンと下側チェーンを構成する(それぞれ凸包の上半分と下半分に相当する)\n    polygon_t L(2 * n);  // NOTE: Pの点を1点ずつ加えながら解を更新する\n\n    // 縮退を考慮するか否かを決定する述語を設定する\n    auto pred = degenerate\n        ? std::function<bool(index_t, index_t)>([&](index_t i, index_t k) -> bool { return ccw(L[k - 2], L[k - 1], P[i]) != orientation::ccw; })\n        : std::function<bool(index_t, index_t)>([&](index_t i, index_t k) -> bool { return ccw(L[k - 2], L[k - 1], P[i]) == orientation::cw;  });\n                            \n\n    // まず、凸包上の点の中で上部凸包(upper hull)上にあるものだけ求める\n    for (index_t i = 0; i < n; i++) {\n        while (k >= 2 && pred(i, k)) { k = k - 1; }\n        L[k] = P[i]; k = k + 1;\n    }\n\n    // 右から左へと実行される2番目の走査で、凸包の残りの部分、すなわち下部凸包(lower hull)を計算する\n    for (index_t i = n - 2, t = k + 1; i >= 0; i--) {\n        while (k >= t && pred(i, k)) { k = k - 1; }\n        L[k] = P[i]; k = k + 1;\n    }\n\n    L.resize(k - 1);  // CH(P)の頂点を時計回りの順に並べたリストL\n    return L;         // リストLを返す\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n    int n;\n    while (cin >> n, n) {\n        polygon_t P(n), CH;\n        coord_t x, y;\n        for (auto& p : P) {\n            char d;\n            cin >> p.x >> d >> p.y;\n        }\n        CH = andrew_scan(P, false);\n        cout << n - CH.size() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\n//Verified PKU 2812\ndouble cross(const Point &v1, const Point &v2) {\n    return (v1.real()*v2.imag()) - (v1.imag()*v2.real());\n}\n\n//Verified AOJ 0012\n//Verified PKU 3348\ndouble ccw(const Point &p1, const Point &p2, const Point &p3) {\n    return cross(p2-p1, p3-p1);\n}\n\n//Verified PKU 3348\nbool cmp(const Point &p1, const Point &p2) {\n    return p1.real() < p2.real();\n}\n\n//Verified PKU 3348\nvector<Point> convex_hull(const vector<Point> &points) {\n    int N = points.size();\n    vector<Point> v = points;\n    sort(v.begin(), v.end(), cmp);\n    vector<Point> hull(2*N);\n    int pos = 0;\n    for(int i = 0; i < N; ++i) {\n        while(pos >= 2 && ccw(hull[pos-2], hull[pos-1], v[i]) <= 0) --pos;\n        hull[pos++] = v[i];\n    }\n    int lim = pos;\n    for(int i = N-2; i >= 0; --i) {\n        while(pos >= lim+1 && ccw(hull[pos-2], hull[pos-1], v[i]) <= 0) --pos;\n        hull[pos++] = v[i];\n    }\n    hull.erase(hull.begin()+pos-1, hull.end());\n    return hull;\n}\n\nint main() {\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n        vector<Point> ps(N);\n        char comma;\n        for(int i = 0; i < N; ++i) cin >> ps[i].real() >> comma >> ps[i].imag();\n\n        vector<Point> hull = convex_hull(ps);\n        cout << N-hull.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <complex>\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\n\nbool cmp(const P &a, const P &b) {\n\tif (a.X != b.X) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\nvector<P> convex_hull(vector<P> ps){\n\tsort(ps.begin(), ps.end(), cmp);\n\tps.erase(unique(ps.begin(), ps.end()), ps.end());\n\tint n = ps.size(), k = 0;\n\tvector<P> ch(2 * n);\n\tP a;\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]){\n\t\twhile (k > 1 && imag(conj(ch[k - 1] - ch[k - 2]) * (ps[i] - ch[k - 1])) <= 0) --k;\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; ch[k++] = ps[i--]){\n\t\twhile (k > t && imag(conj(ch[k - 1] - ch[k - 2]) * (ps[i] - ch[k - 1])) <= 0) --k;\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main(){\n\tint n;\n\twhile (cin >> n, n){\n\t\tvector<P> ps;\n\t\twhile (n--){\n\t\t\tdouble x, y;\n\t\t\tchar c;\n\t\t\tcin >> x >> c >> y;\n\t\t\tps.emplace_back(x, y);\n\t\t}\n\n\t\tcout << ps.size()-convex_hull(ps).size() << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cstdio>\nusing namespace std;\ntypedef complex<double> p;\n\ndouble det(p a,p b)\n{\n\treturn a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool comp(p a,p b)\n{\n\tif(a.real()!=b.real()) return a.real()<b.real();\n\treturn a.imag()<b.imag();\n}\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tp ps[n];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tscanf(\"%lf,%lf\",&ps[i].real(),&ps[i].imag());\n\t\t}\n\n\t\tsort(ps,ps+n,comp);\n\t\tint k=0;\n\t\tp qs[n*2];\n\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\twhile(k>1&&det(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) --k;\n\t\t\tqs[k++]=ps[i];\n\t\t}\n\n\t\tfor(int i = n-2, t=k; i >= 0; --i)\n\t\t{\n\t\t\twhile(k>t&&det(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) --k;\n\t\t\tqs[k++]=ps[i];\n\t\t}\n\n\t\tcout<<n-k+1<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 9e18 + 1;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nstruct V2 {\n    double x, y;\n    V2() {}\n    V2(double x, double y) : x(x), y(y) {}\n    V2 operator+(V2 v) { return V2(x + v.x, y + v.y); }\n    V2 operator-(V2 v) { return V2(x - v.x, y - v.y); }\n    V2 operator*(double c) { return V2(c * x, c * y); }\n    double dot(V2 v) { return x * v.x + y * v.y; }\n    double det(V2 v) { return x * v.y - y * v.x; }\n};\n\nll N, K;\nvector<V2> xy;\n\nbool cmp_x(const V2 &v1, const V2 &v2) {\n    return (v1.x != v2.x ? v1.x < v2.x : v1.y < v2.y);\n}\nvector<V2> Graham(vector<V2> vs) {\n    sort(All(vs), cmp_x);\n    ll k = 0, n = vs.size();\n    vector<V2> ws(n * 2);\n    REP(i, n) {\n        while(k > 1 && (ws[k - 1] - ws[k - 2]).det(vs[i] - ws[k - 1]) <= 0) k--;\n        ws[k++] = vs[i];\n    }\n    for(ll i = n - 2, t = k; i >= 0; i--) {\n        while(k > t && (ws[k - 1] - ws[k - 2]).det(vs[i] - ws[k - 1]) <= 0) k--;\n        ws[k++] = vs[i];\n    }\n    ws.resize(k - 1);\n    return ws;\n}\n\ndouble dist(V2 v, V2 w) { return (v - w).dot(v - w); }\n\nll next_combination(ll sub) {\n    ll x = sub & -sub, y = sub + x;\n    return (((sub & ~y) / x) >> 1) | y;\n}\n\n// for program\nstd::vector<std::string> split(std::string str, char del) {\n    std::vector<std::string> result;\n    std::string subStr;\n\n    for(const char c : str) {\n        if(c == del) {\n            result.push_back(subStr);\n            subStr.clear();\n        } else {\n            subStr += c;\n        }\n    }\n\n    result.push_back(subStr);\n    return result;\n}\n\nsigned main() {\n    while(cin >> N) {\n        if(N == 0) break;\n        REP(i, N) {\n            SCIN(S);\n            auto s = split(S, ',');\n            xy.emplace_back(stod(s[0]), stod(s[1]));\n        }\n        auto conv = Graham(xy);\n        cout << N - conv.size() << \"\\n\";\n        xy.clear();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint a,s,d,j,i,k,lo,cc[1001],ss,sss;\ndouble f[101][2],g,h,z,x,c,v,b,q,w;\nint main(void)\n{\n\twhile(1){\n\t\tg=-10000.0;c=0.0;v=0.0;\n\t\tscanf(\"%d\",&a);\n\t\tif(a==0) break;\n\t\td=a-1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tscanf(\"%lf,%lf\",&f[i][0],&f[i][1]);\n\t\t\tcc[i]=0;\n\t\t\tif(g<f[i][0]){\n\t\t\t\tg=f[i][0]; h=f[i][1];\n\t\t\t\tz=g-1001.0; x=h;\n\t\t\t\ts=i;\n\t\t\t}\n\t\t}\n\t\tss=-1;\n\t\tcc[s]=1;\n\t\tq=g;\n\t\tw=h;\n\t/*\tfor(i=0;i<a;i++) printf(\"%d:%d |\",i,cc[i]);\n\t\tprintf(\"\\n\");*/\n\t\twhile(1){\n\t\t\tsss=s;\n\t\t\tfor(i=0;i<a;i++){\n\t\t\t\tif(sss!=i&&ss!=i){\n\t\t\t\t\tc=(((g-z)*(g-f[i][0])+(h-x)*(h-f[i][1]))/(sqrt((g-z)*(g-z)+(g-f[i][0])*(g-f[i][0]))*sqrt((h-x)*(h-x)+(h-f[i][1])*(h-f[i][1]))));\n\t\t\t\t\tc=acos(c);\n\t\t\t\t\tif(v<c){\n\t\t\t\t\t\tv=c;\n\t\t\t\t\t\ts=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(v==c){\n\t\t\t\t\t\tif(abs(f[i][0]-g)<abs(f[s][0]-g)) s=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tss=sss;\n\t\t\tcc[s]=1;\n\t\t\t/*for(i=0;i<a;i++) printf(\"%d:%d |\",i,cc[i]);\n\t\t\tprintf(\"\\n\");*/\n\t\t\tz=g; x=h;\n\t\t\tg=f[s][0]; h=f[s][1];\n\t//\t\tprintf(\"%lf %d %d\\n\",v,s,lo);\n\t\t\tlo=s;\n\t\t\td--;\n\t\t\tif(d==0) break;\n\t\t\tif(g==q&&h==w) break;\n\t\t\tv=0.0;\n\t\t\tc=0.0;\n\t\t}\n\t\tprintf(\"%d\\n\",d);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nnamespace D2\n{\nconst double eps = 1e-8;\nbool eq(const double &a, const double &b) { return std::abs(a-b)<eps;}\n\nstruct point\n{\n        double x, y;\n        point():x(0),y(0){}\n        point(double x, double y):x(x),y(y){}\n\n        point operator+=(const point &p){ x+=p.x; y+=p.y; return *this;}\n        point operator-=(const point &p){ x-=p.x; y-=p.y; return *this;}\n        point operator*=(const point &p){ double tx = x; x=x*p.x-y*p.y; y=y*p.x+tx*p.y; return *this;}\n        point operator*=(const double &d){ x*=d; y*=d; return *this;}\n        point operator/=(const double &d){ x/=d; y/=d; return *this;}\n        point operator+(const point &p)const{ return point(*this)+=p;}\n        point operator-(const point &p)const{ return point(*this)-=p;}\n        point operator*(const double &d)const{ return point(*this)*=d;}\n        point operator*(const point &p)const{ return point(*this)*=p;}\n        point operator/(const double &d)const{ return point(*this)/=d;}\n        point operator-()const{ return point(-x,-y);}\n        bool operator<(const point &p) const { return std::abs(x- p.x)>eps ? x < p.x-eps : y < p.y-eps;}\n        bool operator==(const point &p) const { return std::abs(x-p.x)<eps and std::abs(y-p.y)<eps;}\n        bool operator!=(const point &p) const { return !(point(*this)==p);}\n\n        double norm() const { return x*x+y*y;}\n        double abs() const { return sqrt(norm());}\n        double arg() const { return atan2(y, x);}\n        double dot(const point &p) const { return x*p.x+y*p.y;}\n        double cross(const point &p) const { return x*p.y-y*p.x;}\n        double det(const point &p) const { return x*p.y-y*p.x;}\n        point proj(const point &p) const { double k = dot(p)/norm(); return point(x*k,y*k);}\n};\npoint operator*(const double &d, const point &p){ point q = p*d; return q;}\nstd::ostream &operator<<(std::ostream &os, const point &p) { os << \"(\" << p.x << \",\" << p.y << \")\"; return os; }\n\npoint polar(const double &r, const double &th) { return point(r*std::cos(th),r*std::sin(th));}\ndouble abs(const point &p) { return p.abs();}\ndouble norm(const point &p) { return p.norm();}\ndouble dot(const point &a, const point &b) { return a.dot(b);}\ndouble cross(const point &a, const point &b) { return a.cross(b);}\ndouble det(const point &a, const point &b) { return a.det(b);}\ndouble arg(const point &a) { return a.arg();}\n/*\n *           1\n *  ------------------\n *    -2 |a  0  b| 2\n *  ------------------\n *          -1\n */\nint ccw(point a, point b, point c)\n{\n        b -= a, c -= a;\n        if (b.cross(c) > eps)        return +1;\n        if (b.cross(c) < -eps)       return -1;\n        if (b.dot(c) < -eps)         return -2; // c -- a -- b\n        if (b.norm() < c.norm()-eps) return +2; // a -- b -- c\n        return 0;\n}\n}\n\nnamespace D2 {\nstd::vector<point> convex_hull(std::vector<point> ps)\n{\n        int n = ps.size(), k = 0;\n        if(n < 3) return ps;\n        std::sort(begin(ps),end(ps));\n        std::vector<point> ret(2*n);\n\n        for (int i = 0; i < n; ret[k++] = ps[i++])\n                while (k >= 2 and ccw(ret[k-2], ret[k-1], ps[i]) < 1) k--;\n        for (int i = n-2, t = k+1; i >= 0; ret[k++] = ps[i--])\n                while (k >= t and ccw(ret[k-2], ret[k-1], ps[i]) < 1) k--;\n        ret.resize(k-1);\n        return ret;\n}\n}\n\nvoid solve(){\n    int n;\n    while(true){\n        cin >> n;\n        if(!n) break;\n        \n        vector<D2::point> ps;\n        rep(i,0,n){\n            string str;\n            cin >> str;\n            //stringstream ss;\n            //ss << str.substr(0,str.find(',')) << str.substr(str.find(',')+1);\n            //ss >> x >> y;\n            string tmp1=str.substr(0,str.find(',')),tmp2=str.substr(str.find(',')+1);\n            double x=stof(tmp1),y=stof(tmp2);\n            ps.push_back(D2::point(x,y));\n        }\n        \n        cout << n-D2::convex_hull(ps).size() << endl;\n    }\n}\n\nint main(){\n\t//std::ios::sync_with_stdio(false);\n\t//std::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double PI = 3.14159;\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tvector<double> x; x.reserve(100);\n\t\tvector<double> y; y.reserve(100);\n\t\tdouble tmp_x, tmp_y;\n\t\tchar dummy;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tcin >> tmp_x >> dummy >> tmp_y;\n\t\t\tx.push_back(tmp_x); y.push_back(tmp_y);\n\t\t}\n\t\t\n\t\tdouble min_y = y[0];\n\t\tint min_y_index = 0;\n\t\tfor (int i=1; i<n; i++) {\n\t\t\tif (min_y > y[i]) { min_y = y[i]; min_y_index = i; }\n\t\t}\n\t\t\n\t\tint curr_index = min_y_index;\n\t\tint circumference_points = 0;\n\t\tdouble curr_deg = 0.0;\n\t\tdo {\n\t\t\tdouble min_deg = PI;\n\t\t\tdouble min_deg_index;\n\t\t\tdouble tmp_deg;\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tif (i == curr_index) continue;\n\t\t\t\ttmp_deg = atan2( y[i] - y[curr_index], x[i] - x[curr_index] );\n\t\t\t\ttmp_deg -= curr_deg;cout << min_deg_index << \" \" <<;\n\t\t\t\tif (tmp_deg < 0) tmp_deg += 2*PI;\n\t\t\t\tif (min_deg > tmp_deg) {\n\t\t\t\t\tmin_deg = tmp_deg; min_deg_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr_deg += min_deg;\n\t\t\tcurr_index = min_deg_index;\n\t\t\tcircumference_points++;\n\t\t\t// cout << min_deg_index << \" \" << curr_deg * 180 / PI << endl;\n\t\t} while (curr_index != min_y_index);\n\t\t\n\t\tcout << n - circumference_points << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);//count common tangents\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nmain()\n{\n\tint N;\n\twhile(cin>>N,N)\n\t{\n\t\tPolygon P(N);\n\t\tchar c;\n\t\tfor(Point&p:P)cin>>p.x>>c>>p.y;\n\t\tcout<<N-convex_full(P).size()<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\nusing namespace std;\n\n#define reep(i,a,n) for(i=a,i<n;++i)\n#define rep(i,n) reep(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp male_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ndouble Add(double a,double b){\n\t//double EPS = 1e-10;\n\tif(abs(a+b)<1e-10*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y) :x(x),y(y){\n\t}\n\tP operator + (P p){\n\t\treturn P(Add(x,p.x),Add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(Add(x,-p.x),Add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){ //内積\n\t\treturn Add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn Add(x*p.y,-y*p.x);\n\t}\n};\n\nbool cmp_x(const P& p,const P& q){\n\tif(p.x!=q.x) return p.x<q.x;\n\treturn p.y<q.y;\n}\n\n#define DEBUG\n\nint main(){\n\tint n;\n\twhile(cin>>n,n!=0){\n\t\t//cout<<n<<endl;\n\t\t#ifdef DEBUG\n\t\tvector<P> ps(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar t;\n\t\t\tcin>>ps[i].x>>t>>ps[i].y;\n\t\t\t//cout<<ps[i].x<<\" \"<<ps[i].y<<endl;\n\t\t}\n\t\tsort(ps.begin(),ps.end(),cmp_x);\n\t\tvector<P> qs(n*2);\n\t\tint k=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)k--;\n\t\t\tqs[k++]=ps[i];\n\t\t}\n\t\tfor(int i=n-2,t=k;i>=0;i--){\n\t\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0) k--;\n\t\t\tqs[k++]=ps[i];\n\t\t}\n\t\tqs.resize(k-1);\n\t\tcout<<n-qs.size()<<endl;\n\t\t#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <math.h>\n#include <complex>\n#include <cstdio>\n#include <iomanip>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = (1e-10);    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;\n}\n\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\nVP convexHull(VP &ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main() {\n  int n;\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n\n    VP ps(n);\n    for (int i = 0; i < n; i++) {\n      D x, y;\n      scanf(\"%lf,%lf\", &x, &y);\n      ps[i] = P(x, y);\n    }\n    std::cout << n-convexHull(ps).size() << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<queue>\n#include<map>\n#include<set>\n#include<vector>\n#include<list>\n#include<stack>\n#include<cstring>\n#include<string>\n#include<cmath>\nusing namespace std;\n#define LATTE 100000\n\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n};\n \nstruct Line{\n    double x[2],y[2];\n    Line(){}\n    Line(Point p,Point q){\n        x[0]=p.x; x[1]=q.x;\n        y[0]=p.y; y[1]=q.y;\n    }\n};\n \nvoid RevXY(Point &p){\n    swap(p.x,p.y);\n}\n \nvoid RevXY(Line &l){\n    for(int i=0;i<2;i++) swap(l.x[i],l.y[i]);\n}\n \nbool Is_SameSide(Line l,Point p,Point q){\n    if(l.x[1]==l.x[0]){\n        RevXY(l); RevXY(p); RevXY(q);\n    }\n    double a,b;\n    a = (l.y[1]-l.y[0])/(l.x[1]-l.x[0]);\n    b = l.y[0]-a*l.x[0];\n    if((p.y-(a*p.x+b))*(q.y-(a*q.x+b))>0) return true;\n    else return false;\n}\n\nint main(){\n\tPoint P[100];\n\tint N,ans;\n\twhile(cin>>N,N){\n\t\tbool used[100]={};\n\t\tans = N;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%lf,%lf\",&P[i].x,&P[i].y);\n\t\t}\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tfor(int j=i+1;j<N;j++){\n\t\t\t\tPoint p(LATTE,LATTE);\n\t\t\t\tLine l(P[i],P[j]);\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k || j==k) continue;\n\t\t\t\t\tif(p.x==LATTE){\n\t\t\t\t\t\tp = P[k];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(Is_SameSide(l,p,P[k])==false){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==true){\n\t\t\t\t\tif(used[i]==false) ans--;\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tif(used[j]==false) ans--;\n\t\t\t\t\tused[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define EPS (1e-10)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point (double x = 0,double y = 0): x(x),y(y){}\n  Point operator + (Point &p){ return Point(x+p.x,y+p.y);}\n  Point operator - (Point &p){ return Point(x-p.x,y-p.y);}\n  Point operator * (double k){ return Point(x*k,y*k);}\n  bool operator < (const Point &p)const {\n    if(x == p.x) return y < p.y;\n    else return x < p.x;\n  }\n};\n\ndouble cross(Point a,Point b){\n  return a.x * b.y - a.y * b.x;\n}\n\nint main(){\n  int i,j,n,x,y;\n  Point p[100];\n  vector<Point> convex;\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    for(i=0;i<n;i++) scanf(\"%lf,%lf\",&p[i].x,&p[i].y);\n    sort(p,p+n);\n\n    convex.push_back(p[0]);\n    convex.push_back(p[1]);\n\n    j = 1;\n    for(i=2;i<n;i++){\n      Point a = convex[j] - convex[j-1];\n      Point b = p[i] - convex[j-1];\n      if(cross(a,b) > EPS){\n\tconvex.pop_back();\n\ti--;\n\tj--;\n      }\n      else{\n\tconvex.push_back(p[i]);\n\tj++;\n      }\n    }\n    \n    convex.push_back(p[n-2]);\n    for(i=n-3;i>=0;i--){\n      Point a = convex[j] - convex[j-1];\n      Point b = p[i] - convex[j-1];\n      if(cross(a,b) > EPS){\n\tconvex.pop_back();\n\ti++;\n\tj--;\n      }\n      else{\n\tconvex.push_back(p[i]);\n\tj++;\n      }\n    }\n\n    cout << n - (j + 1) << endl;//テδづつステδεつδ甘つ」1\n    convex.clear();\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef map<double,int> MDI;\ntypedef MDI::iterator MDII;\n\n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n\n\nint main(){\n\n\tint n;\n\tint max;\n\tint ans;\n\tdouble x,y;\n\tdouble hx,hy,ix,iy,jx,jy;\n\tchar gav;\n\tVPBB pin;\n\tMDI point;\n\n\twhile(1){\n\n\t\t/*入力*/\n\t\tcin>>n;\n\n\t\t/*終了*/\n\t\tif(n==0) break;\n\n\t\t/*準備*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>gav>>y;\n\t\t\tpin.PUSH(PBB(x,y));\n\t\t}\n\t\tans=0;\n\n\t\t/*端の点を決める*/\n\t\tmax=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(pin[max].second<pin[i].second) max=i;\n\t\t\telse if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n\t\t}\n\n\t\t/*基準点との角度から順番を付ける*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i!=max){\n\t\t\t\tpoint.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n\t\t\t}\n\t\t}\n\t\tpoint.insert(MDIVT(-1*INF,max));\n\n\t\t/*3点の角度から凸包を求めていく*/\n\t\tMDII iH=point.begin(),iI=point.begin(),iJ=point.begin();\n\t\tiI++,iJ++,iJ++;\n\t\twhile(iJ!=point.end()){\n\t\t\thx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n\t\t\tix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n\t\t\tjx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n\n\t\t\t/*cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug*/\n\n\t\t\tif((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0){\n\t\t\t\tiH++,iI++,iJ++;\n\t\t\t}\n\t\t\telse{\n\t\t\tiJ++;\n\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\t/*出力*/\n\t\tcout<<ans<<endl;\n\n\t\t/*初期化*/\n\t\tpin.clear();\n\t\tpoint.clear();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equal(a,b) (fabs((a)-(b)) < EPS)\n\nclass Point{\npublic:\n  double x,y;\n  \n  Point(double x = 0, double y = 0): x(x),y(y){}\n \n  Point operator + (Point p){\n    return Point( x+p.x , y+p.y );\n  }\n  Point operator - (Point p){\n    return Point( x-p.x , y-p.y );\n  }\n  Point operator * (double a){\n    return Point( a*x , a*y );\n  }\n \n  double abs(){\n    return sqrt(norm());\n  }\n  double norm(){\n    return x*x+y*y;\n  }\n \n  bool operator < (const Point &p)const{\n    return x != p.x ? x < p.x : y < p.y;\n  }\n \n  bool operator == (const Point &p)const{\n    return equal( x,p.x )&& equal( y,p.y );\n  }\n};\n\ntypedef Point Vector;\n \ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\n \ndouble cross(Vector a,Vector b){\n  return a.x*b.y - b.x*a.y;\n}\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nint ccw( Point p0 , Point p1 , Point p2 ){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) < -EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ntypedef vector<Point> Polygon;\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n\n  if(s.size() < 3) return s;\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i = 2 ; i < s.size() ; i++){\n    for(int n = u.size() ; n >=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n\n  for(int i = s.size()-3 ; i >= 0 ; i--){\n    for(int n = l.size() ; n >=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size() -2 ; i >= 1 ; i--){\n    l.push_back(u[i]);\n  }\n\n  return l;\n}\n\nint main(){\n  int n;\n \n  while(cin >> n ,n){\n    Polygon pp;\n    double a,b;\n    for(int i = 0 ; i < n ; i++){\n      scanf(\"%lf,%lf\" ,&a,&b);\n      pp.push_back(Point(a,b));\n    }\n    cout << n - andrewScan(pp).size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y):x(x),y(y){}\n \n  Point operator+(Point p){return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  \n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator<(const Point &p) const{\n    return x!=p.x? x< p.x : y < p.y;\n  }\n\n  bool operator==(const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS ;\n  }\n};\n\ntypedef Point Vector;\n\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\ntypedef vector<Point> Polygon;\n\nint andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s.size();\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l.size();\n} \nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p;\n    p.clear();\n    double x,y;\n    for(int i=0;i<n;i++){\n      //cin >> x >> y;\n      scanf(\"%lf,%lf\",&x,&y);\n      //cout << x << \":\" << y << endl;\n      p.push_back(Point(x,y));\n    }\n    cout << n-andrewScan(p) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ndouble EPS=1e-10;\ndouble add(double a, double b) {\n    if (abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n    return a+b;\n}\nstruct P {\n    double x, y;\n    P() {}\n    P(double x, double y) : x(x), y(y) {}\n    P operator - (P p) {\n        return P(add(x,-p.x),add(y,-p.y));\n    }\n    double dot(P p) {\n        return add(x*p.x,y*p.y);\n    }\n    double det(P p) {\n        return add(x*p.y,-y*p.x);\n    }\n};\nbool comp(const P& p, const P& q) {\n    if (p.x!=q.x) return p.x<q.x;\n    return p.y<q.y;\n}\nvector<P> grahamscan(P* ps, int n) {\n    sort(ps, ps+n, comp);\n    int k=0;\n    vector<P> qs(n*2);\n    for (int i=0; i<n; i++) {\n        while (k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0) k--;\n        qs[k++]=ps[i];\n    }\n    for (int i=n-2, t=k; i>=0; i--) {\n        while (k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\nP ps[100];\nint main() {\n    int n;\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        for (int i=0; i<n; i++) {\n            double x, y; scanf(\"%lf%*c%lf\",&x,&y);\n            ps[i]=P(x,y);\n        }\n        vector<P> qs=grahamscan(ps,n);\n        printf(\"%d\\n\",n-qs.size());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n\nconst double EPS = 1e-10;\n\ndouble add( double a, double b )\n{\n\tif( abs( a + b ) < EPS * ( abs( a ) + abs( b ) ) )\n\t\treturn 0;\n\n\treturn a + b;\n}\n\nstruct P\n{\n\tdouble x, y;\n\n\tP()\n\t:\tx( 0 ), y( 0 )\n\t{}\n\n\tP( double x, double y )\n\t:\tx( x ), y( y )\n\t{}\n\n\tP operator+ ( const P& p ) const\n\t{\n\t\treturn P( add( x, p.x ), add( y, p.y ) );\n\t}\n\n\tP operator- ( const P& p ) const\n\t{\n\t\treturn P( add( x, -p.x ), add( y, -p.y ) );\n\t}\n\n\tP operator* ( double d ) const\n\t{\n\t\treturn P( x * d, y * d );\n\t}\n\n\tdouble dot( const P& p ) const\n\t{\n\t\treturn add( x * p.x, y * p.y );\n\t}\n\n\tdouble cross( const P& p ) const\n\t{\n\t\treturn add( x * p.y, -y * p.x );\n\t}\n};\n\nbool compare( const P& p, const P& q )\n{\n\tif( p.x != q.x )\n\t\treturn p.x < q.x;\n\n\treturn p.y < q.y;\n}\n\nint n;\nP ps[100];\n\nint main()\n{\n\twhile( true )\n\t{\n\t\tscanf( \"%d\", &n );\n\t\tif( !n )\n\t\t\tbreak;\n\n\t\tfor( int i = 0; i != n; ++i )\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tscanf( \"%lf,%lf\", &x, &y );\n\t\t\tps[i] = P( x, y );\n\t\t}\n\n\t\tstd::sort( ps, ps + n, compare );\n\n\t\tint k = 0;\n\t\tstd::vector<P> qs( n * 2 );\n\n\t\tfor( int i = 0; i != n; ++i )\n\t\t{\n\t\t\twhile( k > 1 && ( qs[k-1] - qs[k-2] ).cross( ps[i] - qs[k-1] ) <= 0 )\n\t\t\t\t--k;\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\t\t\n\t\tfor( int i = n - 2, t = k; i >= 0; --i )\n\t\t{\n\t\t\twhile( k > t && ( qs[k-1] - qs[k-2] ).cross( ps[i] - qs[k-1] ) <= 0 )\n\t\t\t\t--k;\n\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\n\t\tstd::cout << n - k + 1 << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst double EPS = 1e-10;\nint sgn(double d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n \nstruct Point {\n  double x, y;\n  Point() {}\n  Point (const double& x, const double& y) : x(x), y(y) {}\n  Point& operator += (const Point& other) { x += other.x; y += other.y; return *this; }\n  Point& operator -= (const Point& other) { x -= other.x; y -= other.y; return *this; }\n  Point& operator *= (const double& factor) { x *= factor; y *= factor; return *this; }\n  Point& operator /= (const double& factor) { x /= factor; y /= factor; return *this; }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>;\n \nPoint operator + (const Point&lhs, const Point& rhs) { return Point(lhs.x + rhs.x, lhs.y + rhs.y); }\nPoint operator - (const Point& lhs, const Point& rhs) { return Point(lhs.x - rhs.x, lhs.y - rhs.y); }\nPoint operator * (const Point& lhs, const double& factor) { return Point(lhs.x * factor, lhs.y * factor); }\nPoint operator * (const double& factor, const Point& rhs) { return Point(factor * rhs.x, factor * rhs.y); }\nPoint operator / (const Point& lhs, const double& factor) { return Point(lhs.x / factor, lhs.y / factor); }\ndouble operator * (const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }\ndouble operator ^ (const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }\nbool operator == (const Point& lhs, const Point& rhs) { return sgn(lhs.x - rhs.x) == 0 && sgn(lhs.y - rhs.y) == 0; }\nbool operator != (const Point& lhs, const Point& rhs) { return !(lhs == rhs); }\nbool operator < (const Point& lhs, const Point& rhs) { return sgn(lhs.x - rhs.x) ? lhs.x < rhs.x : lhs.y < rhs.y; }\nbool operator > (const Point& lhs, const Point& rhs) { return rhs < lhs; }\nbool operator <= (const Point& lhs, const Point& rhs) { return !(lhs > rhs); }\nbool operator >= (const Point& lhs, const Point& rhs) { return !(lhs < rhs); }\nistream& operator >> (istream& is, Point& point) { return is >> point.x >> point.y; }\nostream& operator << (ostream& os, Point& point) { return os << \"(\" << point.x << \",\" << point.y << \")\"; }\ndouble norm(const Point& point) { return point.x * point.x + point.y * point.y; }\ndouble abs(const Point& point) { return sqrt(norm(point)); }\ndouble arg(const Point& point) { return atan2(point.y, point.x); }\nPoint polar(const double& a, const double& r) { return Point(cos(r) * a, sin(r) * a); }\nbool sort_x(Point lhs, Point rhs) { return sgn(lhs.x - rhs.x) ? lhs.x < rhs.x : lhs.y < rhs.y; }\nbool sort_y(Point lhs, Point rhs) { return sgn(lhs.y - rhs.y) ? lhs.y < rhs.y : lhs.x < rhs.x; }\n \nPolygon convex_hull(Polygon ps) {\n  int n = ps.size();\n  sort(ps.begin(), ps.end(), sort_x);\n  int k = 0;\n  Polygon qs(n * 2);\n  for (int i = 0; i < n; i++) {\n    while (k > 1 && ((qs[k - 1] - qs[k - 2]) ^ (ps[i] - qs[k - 1])) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for (int i = n - 2, t = k; i >= 0; i--) {\n    while (k > t && ((qs[k - 1] - qs[k - 2]) ^ (ps[i] - qs[k - 1])) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k - 1);\n  return qs;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n;\n  while (cin >> n, n) {\n    Polygon s(n);\n    for (int i = 0; i < n; i++) {\n      char ch;\n      cin >> s[i].x >> ch >> s[i].y;\n    }\n    cout << n - convex_hull(s).size() << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define Eps (1e-10)\n\nint N;\nbool flag[102];\ndouble x[102],y[102];\n\nint main() {\n  while (scanf(\"%d\",&N),N) {\n    rep(i,N) scanf(\"%lf,%lf\",x+i,y+i);\n    fill(flag, flag + N, false);\n    //rep(i,N) printf(\"%lf,%lf\\n\",x[i],y[i]);\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n          for (int l = 0; l < N; ++l) {\n            if (i == l || j == l || k == l) continue;\n            if (flag[i] | flag[j] | flag[k] | flag[l]) continue;\n            double S, subS[3], subSum = 0;\n            S = fabs((x[i]*y[j] + x[j]*y[k] + x[k]*y[i] -\n                      y[i]*x[j] - y[j]*x[k] - y[k]*x[i]) / 2);\n            subS[0] = fabs((x[l]*y[j] + x[j]*y[k] + x[k]*y[l] -\n                            y[l]*x[j] - y[j]*x[k] - y[k]*x[l]) / 2);\n            subS[1] = fabs((x[i]*y[l] + x[l]*y[k] + x[k]*y[i] -\n                            y[i]*x[l] - y[l]*x[k] - y[k]*x[i]) / 2);\n            subS[2] = fabs((x[i]*y[j] + x[j]*y[l] + x[l]*y[i] -\n                            y[i]*x[j] - y[j]*x[l] - y[l]*x[i]) / 2);\n            rep(ii,3) subSum += subS[ii];\n            if (fabs(S-subSum) < Eps) {\n              //printf(\"(%d,%d,%d) : %d | %.3lf %.3lf\\n\", i,j,k,l,S,subSum);\n              flag[l] = true;\n            }\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",count(flag, flag+N, true));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string.h>\n#define P pair<double,double>\nusing namespace std;\ndouble EPS=1e-10;\ndouble add(double a, double b)\n{\n\tif(abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\nbool cmp_x(const P& p, const P& q)\n{\n\tif(p.first !=q.first) return p.first<q.first;\n\treturn p.second>q.second;\n}\nP p[100];\nvector<P> v;\nvector<int> num;\nint n;\nbool used[100];\nvoid make_convex(int l,int r)\n{\n\tfor(int i=l ;(r>l ? i<r : i>=r);(r>l ? i++ : i--))\n\t{\n\t\tif(used[i]) continue;\n\t\tfor(bool loop=true;loop; )\n\t\t{\n\t\t\tloop=false;\n\t\t\tif(v.size()<3) {v.push_back(p[i]),num.push_back(i),used[i]=true; continue;}\n\t\t\tdouble vx[3],vy[3]; int len=v.size();\n\t\t\tvx[0]=v[len-2].first-v[len-3].first;\n\t\t\tvy[0]=v[len-2].second-v[len-3].second;\n\t\t\tvx[1]=v[len-1].first-v[len-2].first;\n\t\t\tvy[1]=v[len-1].second-v[len-2].second;\n\t\t\tvx[2]=p[i].first-v[len-1].first;\n\t\t\tvy[2]=p[i].second-v[len-1].second;\n\t\t\tif(add(vx[1]*vy[2],-vx[2]*vy[1])<=0) v.push_back(p[i]),num.push_back(i),used[i]=true;\n\t\t\telse used[num[len-1]]=false,num.pop_back(),v.pop_back(),loop=true;\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n; if(!n) break;\n\t\tv.clear(); memset(used,false,sizeof(used));\n\t\tfor(int i=0;i<n;i++) scanf(\"%lf,%lf\",&p[i].first,&p[i].second);\n\t\tsort(p,p+n,cmp_x);\n\t\t//pはxの昇順、yの降順。時計回りで見ること\n\t\tmake_convex(0,n);\n\t\tmake_convex(n-1,0);\n\t\tcout << n-v.size() << '\\n' ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\n\n\n// 以下 幾何部分\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex <D> P;\ntypedef vector <P> Pol;\n\n// ソートのキー\nbool cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}\nbool cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}\nbool cmp_a(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  norm(a) < norm(b) : a.X<b.X;}\n\n\n// \nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\n\nPol convex_hull(Pol pol){\n\tint n=pol.size();\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tPol res(2*n);\n\tint k=0;\n\t\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n, n){\n\t\tPol a(n);\n\t\trep(i,n){\n\t\t\tP tmp;\n\t\t\tchar buf;\n\t\t\tcin >> tmp.X >> buf >> tmp.Y;\n\t\t\ta[i]=tmp;\n\t\t}\n\t\tPol b=convex_hull(a);\n\t//\tdump(a.size())\n\t//\tdump(b.size())\n\t\tcout << a.size()-b.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <iterator>\n#include <stdlib.h>\n#include <map>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <set>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\n// vector cout\ntemplate<typename _Ty>\nostream& operator << (ostream& os, const vector<_Ty>& v) {\n\tos << \"{\";\n\tfor (size_t i = 0; i < v.size(); i++)\n\t{\n\t\tif (i != 0) os << \", \";\n\t\tos << v[i];\n\t}\n\tos << \"}\";\n\n\treturn os;\n}\n\n//point\nclass Point {\npublic:\n\tdouble x;\n\tdouble y;\n\n\tPoint() {\n\t\tx = 0; y = 0;\n\t}\n\tPoint(int x, int y) {\n\t\tthis->x = x; this->y = y;\n\t}\n\n\tbool operator<(const Point& a) const {\n\t\tif (x == a.x)\n\t\t\treturn y < a.y;\n\t\telse\n\t\t\treturn x < a.x;\n\t}\n};\n\n//point cout\nostream& operator << (ostream& os, const Point& p) {\n\treturn os << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\n\nvoid rec(list<Point*>& Hull, list<Point*>& Points, Point* p1, Point* p2, int sgn) {\n\n\tdouble MaxDistance = 0;\n\tPoint* pMaxDistance = NULL;\n\tlist<Point*>::iterator it; //iterator\n\n\t//sgn?????????????????¨?????????\n\tlist<Point*> sgnPoints;\n\n\t//sgn ????????????????????§??´??? p1-p2 ??????????????¢?????§??????????±???????\n\tfor (it = Points.begin(); it != Points.end(); it++)  // list???????°??????§\n\t{\n\t\tPoint* p = *it;\n\t\tdouble d = (p2->x - p1->x)*(p->y - p1->y) - (p2->y - p1->y)*(p->x - p1->x);\n\n\t\t//0 ????????´???????????£?????? sgn ??????????????¨\n\t\tdouble reg = sgn * d;\n\n\t\t//??´????????§????????°??????\n\t\tif (abs(reg) < 1e-8) {\n\t\t\tPoints.erase(it);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//??£?????????????????????????????¢?????????\n\t\tif (reg > 0) {\n\t\t\tsgnPoints.push_back(*it);\n\n\t\t\tif (abs(d) > MaxDistance) {\n\t\t\t\tMaxDistance = abs(d);\n\t\t\t\tpMaxDistance = p;\n\t\t\t}\n\t\t}\n\t}\n\n\t//?????¨??????????????°??????\n\tif (pMaxDistance == NULL) return;\n\n\t//p0 ??????????????????\n\tPoint* p0 = pMaxDistance;\n\tHull.push_back(p0);\n\tPoints.remove(p0);\n\tsgnPoints.remove(p0);\n\n\t//????§???¢ p0, p1, p2 ?????¨????????¨??????????????????\n\tfor (it = sgnPoints.begin(); it != sgnPoints.end(); it++) {\n\t\tPoint* pl = *it;\n\n\t\tPoint* p[3] = { p0, p1, p2 };\n\t\t//cross product\n\t\tdouble cp[3];\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcp[i] = (p[(i + 1) % 3]->x - p[i]->x)*(pl->y - p[i]->y) - (p[(i + 1) % 3]->y - p[i]->y)*(pl->x - p[i]->x);\n\t\t}\n\t\t//?????¨???????????????\n\t\tif ((cp[0] < 0 && cp[1] < 0 && cp[2] < 0) || (cp[0] > 0 && cp[1] > 0 && cp[2] > 0)) {\n\t\t\t//??????\n\t\t\tPoints.remove(*it);\n\t\t}\n\t}\n\n\t//??´??? (p0, p1) ???????????? p2 ????¬????\n\tdouble sp2 = (p1->x - p0->x)*(p2->y - p0->y) - (p1->y - p0->y)*(p2->x - p0->x);\n\tif (sp2 < 0) rec(Hull, Points, p0, p1, 1);\n\telse rec(Hull, Points, p0, p1, -1);\n\n\t//??´??? (p0, p2) ???????????? p1 ????¬????\n\tdouble sp1 = (p2->x - p0->x)*(p1->y - p0->y) - (p2->y - p0->y)*(p1->x - p0->x);\n\tif (sp1 < 0) rec(Hull, Points, p0, p2, 1);\n\telse rec(Hull, Points, p0, p2, -1);\n\n\treturn;\n}\n\nint convexhull(vector<Point>& vPoints)\n{\n\t//sort\n\tsort(vPoints.begin(), vPoints.end());\n\n\t//list ??? vPoints ??????????´???????????????????????´?\n\tlist<Point*> lPoints;\n\tfor (int i = 0; i < vPoints.size(); i++)\n\t{\n\t\tlPoints.push_back(&vPoints[i]);\n\t}\n\n\t//??????????§?????????????????????????\n\tlist<Point*> Hull;\n\n\t//x??§?¨?????°????????????§?????????????????????\n\tHull.push_back(lPoints.front());\n\tHull.push_back(lPoints.back());\n\n\t//p1, p2\n\tPoint* p1 = lPoints.front();\n\tPoint* p2 = lPoints.back();\n\n\t//??????\n\tlPoints.pop_front();\n\tlPoints.pop_back();\n\n\t//?¬??????£???????????¢?´¢\n\trec(Hull, lPoints, p1, p2, 1);\n\t//?¬??????????????????¢?´¢\n\trec(Hull, lPoints, p1, p2, -1);\n\n\treturn vPoints.size() - Hull.size();\n}\n\nint main() {\n\n\twhile (1) {\n\n\t\tint n;\n\t\tvector<Point> Points;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tPoint p;\n\t\t\tstring input;\n\t\t\tcin >> input;\n\n\t\t\tstringstream ss(input);\n\n\t\t\tss >> p.x;\n\t\t\tss.ignore();\n\t\t\tss >> p.y;\n\n\t\t\tPoints.push_back(p);\n\t\t}\n\t\tcout << convexhull(Points) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n#define rep2(x,from,to) for(int x = (from); x < (to); ++(x))\n#define rep(x,to) rep2(x,0,to)\ntypedef pair<double, double> dpair;\n\nbool isLeft(dpair p1, dpair p2, dpair p3) {\n\tint r = (p2.first - p1.first) * (p3.second - p2.second) - (p2.second - p1.second) * (p3.first - p2.first);\n \tif(r > 0)  return true;\n\treturn false;\n}\nstruct pairsort {\n\tbool operator()(const dpair& x, const dpair& y) const {\n\t\tif(x.first == y.first) return y.second < x.second;\n\t\treturn x.first < y.first;\n\t}\n};\nint main() {\n\tint n;\n\twhile(cin >> n && n) {\n\t\t/*if(n == 3) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}*/\n\t\tvector<dpair> v;\n\t\trep(i,n) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tsort(v.begin(), v.end(), pairsort());\n\t\tset<int> s;\n\t\tvector<pair<int, dpair> > v1;\n\t\tv1.push_back(make_pair(0, v[0]));\n\t\tv1.push_back(make_pair(1, v[1]));\n\t\trep2(i,2,n) {\n\t\t\tv1.push_back(make_pair(i, v[i]));\n\t\t\twhile(v1.size() >= 3 && isLeft(v1[v1.size()-3].second, v1[v1.size()-2].second, v1[v1.size()-1].second)) {\n\t\t\t\tv1.erase(--(--v1.end()));\n\t\t\t}\n\t\t}\n\t\trep(i,v1.size()) {\n\t\t\ts.insert(v1[i].first);\n\t\t}\n\t\tvector<pair<int, dpair> > v2;\n\t\tv2.push_back(make_pair(n-1, v[n-1]));\n\t\tv2.push_back(make_pair(n-2, v[n-2]));\n\t\tfor(int i = n - 3; i >= 0; --i) {\n\t\t\tv2.push_back(make_pair(i, v[i]));\n\t\t\twhile(v2.size() >= 3 && isLeft(v2[v2.size()-3].second, v2[v2.size()-2].second, v2[v2.size()-1].second)) {\n\t\t\t\tv2.erase(--(--v2.end()));\n\t\t\t}\n\t\t}\n\t\trep(i,v2.size()) {\n\t\t\ts.insert(v2[i].first);\n\t\t}\n\t\tcout << n - s.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\ntypedef complex < double > Point;\n/*\n    Pointの使い方\n    Point AにおけるX座標...real(A) or A.real()\n                   Y座標...imag(A) or A.imag() 状況によってちょいちょい使い分けとか\n\n    Point A,BにおいてA+B,A-B,(double)k * Aは定義済み\n    原点からの距離はsqrt(norm(A))\n    二点間の距離はsqrt(norm(A-B))\n    norm(A)はX^2+Y^2を返す\n*/\ntypedef vector < Point > Polygon;\nnamespace std {\n    bool operator < (Point a,Point b) {\n        //ここで座標の比較における\"大きい\"を定義\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n\n\nstruct Line : Polygon{\n    Line(Point p,Point q){ push_back(p);push_back(q); }\n};\nstruct Circle{\n    Point p;\n    double r;\n    Circle(Point a, double s){ p = a;r = s; }\n};\n\ndouble cross(Point p,Point q){\n    return imag(conj(p)*q);\n}\n\ndouble dot(Point p,Point q){\n    return real(conj(p)*q);\n}\n\nint ccw(Point a,Point b,Point c){\n    b-=a,c-=a;\n    if(cross(b,c)>0)return 1; //反時計回り\n    if(cross(b,c)<0)return -1; //時計回り\n    if(dot(b,c)<0)return 2; //直線上に c - a - b\n    if(norm(b)<norm(c))return -2; // 直線上に a - b - c\n    return 0; // 直線上に a - c - b\n}\n\nPoint normalize(Point P, double l){\n    double a = real(P), b = imag(P);\n    double y = sqrt(b*b/(a*a+b*b)*l*l);\n    double x = (a/b)*y;\n\n    return Point(x,y);\n}\n\ndouble heron(Point A, Point B, Point C){\n    double a = sqrt(norm(A-B));\n    double b = sqrt(norm(B-C));\n    double c = sqrt(norm(C-A));\n    double s = (a+b+c)/2;\n\n    return sqrt(s*(s-a)*(s-b)*(s-c));\n}\nbool intersectLL(Line l, Line m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // 平行でない\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // 同一の線\n}\nbool intersectLS(Line l, Line s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] が lの左\n           cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] が lの右\n}\nbool intersectLP(Line l, Point p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n//↓2円の交点二つを返す（ポインタ）,戻り値は交点の個数\nint intersectCC(Circle A, Circle B, Point *p, Point *q){\n\n    Point P,Q;\n    if(B.p<A.p)swap(A.p,B.p);\n    Point dv = B.p - A.p;//ベクトル\n\n\n    double L = sqrt(norm(dv));\n    int num;\n    //距離がLの場合\n    if( L==(A.r + B.r) ){\n        num = 1;\n        //交点1つ\n        //虚数軸に沿って並んでいるとバグる？\n        dv = normalize(dv,A.r);\n        P = Q = Point(real(dv)+real(A.p),imag(dv)+imag(A.p));\n    }\n    else if( L<(A.r + B.r) && L > fabs(A.r - B.r) ){\n        num = 2;\n        //交点2つ\n        /*\n        交点の一方Qからベクトルdvに垂線を下ろしたところをptとする\n        ふたつの直角三角形p0-pt-Q、p1-pt-Qができる\n        p0-pt間の長さをtとすると、これらの三角形のQ-ptの長さは等しいため、\n\n        r0*r0 - t*t = r1*r1 - (L-t)*(L-t)\n        r0*r0 - t*t = r1*r1 - L*L - t*t + 2*L*t\n        t = (r0*r0 - r1*r1 + L*L)/(2*L)\n\n        tから、p0-Qベクトルとdvベクトルとの角度aを求め、\n        dvベクトルから、+a,-aの座標を求めれば交点となる\n        */\n\n        //tを求める\n        double t = 0.5*( A.r*A.r - B.r*B.r + L*L)/L;\n\n        //p0-Qベクトルとdvベクトルの角度\n        double a = acos( t/A.r );\n\n        //dvベクトルの角度\n        double a0 = atan2( imag(dv), real(dv) );\n\n        //交点\n        P = Point( real(A.p) + A.r*cos(a0+a), imag(A.p) + A.r*sin(a0+a) );\n        Q = Point( real(A.p) + A.r*cos(a0-a), imag(A.p) + A.r*sin(a0-a) );\n\n    }\n    else{\n        num = 0;\n        //交点なし\n    }\n\n    *p = P;\n    *q = Q;\n\n    return num;\n}\nPoint projection(Line l, Point p) {//射影\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t * (l[0]-l[1]);\n}\nPoint reflection(Line l, Point p) {//反射\n    return p + (projection(l, p) - p) + (projection(l, p) - p);\n}\ndouble distanceLP(Line l, Point p) {\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(Line l, Line s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(Line s, Point p) {\n    const Point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(Line s, Line t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nPoint crosspoint(Line l, Line m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS);\n    return m[0] + B / A * (m[1] - m[0]);\n}\n/*\ndouble area(Polygon P) {//多角形の面積\n    double A = 0;\n    for (int i = 0; i < P.size(); ++i)\n        A += cross(curr(P, i), next(P, i));\n    return A;\n}\n*/\nPolygon convex_hull(Polygon ps) {//凸包\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        Polygon G;\n        for(int i = 0;i < n;i++){\n            Point p;\n            scanf(\"%lf,%lf\",&real(p),&imag(p));\n            G.push_back(p);\n        }\n       Polygon H = convex_hull(G);\n       cout<<G.size()-H.size()<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P; //Point\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> { // Line\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nstruct C {  //Circle\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\n//cross  L line  S senbun  P point\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n//distance\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0*(projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    P p[n];\n    for(int i=0; i<n; i++) scanf(\"%lf%*c%lf\",&p[i].real(),&p[i].imag());\n    sort(p,p+n);\n    P q[n*2];\n    int k=0;\n    for(int i=0; i<n; i++,k++) {\n      while(k>1 && ccw(q[k-2],q[k-1],p[i])<=0) k--;\n      q[k]=p[i];\n    }\n    int t=k+1;\n    for(int i=n-2; i>=0; i--,k++) {\n      while(k>=t && ccw(q[k-2],q[k-1],p[i])<=0) k--;\n      q[k]=p[i];\n    }\n    cout << n-(k-1) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <numeric>\n#include <queue>\n#include <climits>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <map>\nusing namespace std;\nusing ll = long long;\n#define MOD 1000000007\n#define INF 1LL << 59\n\nusing Point = complex<double>;\n\nistream &operator>>(istream &is, Point &p)\n{\n    double a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i + 1) % P.size()]\n#define prev(P, i) P[(i - 1 + P.size()) % P.size()]\n\nconst double EPS = 1e-10, PI = acos(-1);\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\n//二つのスカラーが等しいか\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n//二つのベクトルが等しいか\n#define EQV(a, b) (EQ((a), real(), (b).real()) && EQ((a), imag(), (b).imag()))\n\nnamespace std\n{\nbool operator<(const Point &a, const Point &b)\n{\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nstruct Line\n{\n    Point a, b;\n    Line() {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    //a, bはそれぞれ座標を指す. これより一つの「line」に対して二個の点を持つことになる\n    Line(double A, double B, double C) // Ax + By = C\n    {\n        if (eq(A, 0))\n            a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0))\n            b = Point(C / A, 0), b = Point(C / A, 1);\n        else\n            a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream &operator<<(ostream &os, Line &p)\n    {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream &operator>>(istream &is, Line &a)\n    {\n        return is >> a.a >> a.b;\n    }\n};\n\nstruct Segment : Line\n{\n    Segment() {}\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle\n{\n    Point p;\n    double r;\n\n    Circle() {}\n\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\n\ndouble dot(const Point a, const Point b)\n{\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(const Point a, const Point b)\n{\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nint ccw(const Point &a, Point b, Point c)\n{\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS)\n        return +1; // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -EPS)\n        return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0)\n        return +2; // \"ONLINE_BACK\"\n    if (norm(b) < norm(c))\n        return -2; // \"ONLINE_FRONT\"\n    return 0;      // \"ON_SEGMENT\"\n}\n\nenum\n{\n    OUT,\n    ON,\n    IN\n};\n\nint contains(const Polygon &Q, const Point &p)\n{\n    bool in = false;\n    for (int i = 0; i < Q.size(); ++i)\n    {\n        Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n        if (a.imag() > b.imag())\n            swap(a, b);\n        if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0)\n            in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0)\n            return ON;\n    }\n    return in ? IN : OUT;\n}\n\nPolygon convex_hull(Polygon &p)\n{\n    int n = (int)p.size(), k = 0;\n    if (n <= 2)\n        return p;\n    sort(p.begin(), p.end());\n    vector<Point> ch(n * 2);\n\n    for (int i = 0; i < n; ch[k++] = p[i++])\n    {\n        while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0)\n            --k;\n    }\n\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--])\n    {\n        while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0)\n            --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\nint main()\n{\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    //cout << fixed << setprecision(7);\n\n    int n;\n    while (cin >> n)\n    {\n        if (n == 0)\n            break;\n\n        Polygon Q;\n        for (int i = 0; i < n; ++i)\n        {\n            double px, py;\n            scanf(\"%lf,%lf\", &px, &py);\n            Point p(px, py);\n            Q.push_back(p);\n        }\n\n        Polygon P = convex_hull(Q);\n        cout << n - P.size() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(double x = 0, double y = 0): x(x),y(y){};\n  bool operator < (const Point& p) const{\n    if(x != p.x) return x < p.x;\n    return y < p.y;\n  }\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  double own_dot(){return x*x+y*y;};\n};\n\ndouble dot(Point a, Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Point a, Point b){\n  return a.x*b.y-a.y*b.x; \n}\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.own_dot() < b.own_dot()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nvector<Point> andrewScan(vector<Point> s){\n  vector<Point> u,l;\n  \n  if(s.size() < 3) return s;\n\n  sort(s.begin(),s.end());\n  \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  for(int i = 2; i < s.size(); i++){\n    for(int n = u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n      u.pop_back();\n    u.push_back(s[i]);\n  }\n\n  for(int i = s.size()-3; i >= 0; i--){\n    for(int n = l.size(); n>=2 && ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n      l.pop_back();\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(),l.end());\n  \n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n  return l;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<Point> V(n);\n    for(int i = 0; i < n; i++) scanf(\"%lf,%lf\",&V[i].x,&V[i].y);\n    cout << n-andrewScan(V).size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\n\n\nint main(){\n  Point in;\n  Polygon t;\n  int n,a,b;\n  char ch;\n  while(cin>>n&&n){\n    t.clear();\n    for(int i=0;i<n;i++){\n      cin>>in.x>>ch>>in.y;\n      t.push_back(in);\n    }\n    b=t.size();\n    t=andrewScan(t);\n    a=t.size();\n    cout<<b-a<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define rep2(x,from,to) for(int x = (from); x < (to); ++(x))\n#define rep(x,to) rep2(x,0,to)\ntypedef pair<double, double> dpair;\n\nbool isLeft(dpair p1, dpair p2, dpair p3) {\n\tint r = (p2.first - p1.first) * (p3.second - p2.second) - (p2.second - p1.second) * (p3.first - p2.first);\n \tif(r > 0)  return true;\n\treturn false;\n}\nstruct pairsort {\n\tbool operator()(const dpair& x, const dpair& y) const {\n\t\tif(x.first == y.first) return y.second < x.second;\n\t\treturn x.first < y.first;\n\t}\n};\nint main() {\n\tint n;\n\twhile(cin >> n && n) {\n\t\tvector<dpair> v;\n\t\trep(i,n) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tsort(v.begin(), v.end(), pairsort());\n\t\tvector<pair<int, dpair> > v1;\n\t\tv1.push_back(make_pair(0, v[0]));\n\t\tv1.push_back(make_pair(1, v[1]));\n\t\trep2(i,2,n) {\n\t\t\tv1.push_back(make_pair(i, v[i]));\n\t\t\twhile(v1.size() >= 3 && isLeft(v1[v1.size()-3].second, v1[v1.size()-2].second, v1[v1.size()-1].second)) {\n\t\t\t\tv1.erase(--(--v1.end()));\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, dpair> > v2;\n\t\tv2.push_back(make_pair(n-1, v[n-1]));\n\t\tv2.push_back(make_pair(n-2, v[n-2]));\n\t\tfor(int i = n - 3; i >= 0; --i) {\n\t\t\tv2.push_back(make_pair(i, v[i]));\n\t\t\twhile(v2.size() >= 3 && isLeft(v2[v2.size()-3].second, v2[v2.size()-2].second, v2[v2.size()-1].second)) {\n\t\t\t\tv2.erase(--(--v2.end()));\n\t\t\t}\n\t\t}\n\t\tcout << n - (v1.size() + v2.size() - 2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef complex<ld> P;\n#define X real\n#define Y imag\nvector<P> data;\n\nnamespace std{\n  bool operator<(P a,P b){\n    return a.X()!=b.X()? a.X()<b.X():a.Y()<b.Y(); \n  }\n}\n\ndouble cross(P a,P b){\n  return imag(conj(a)*b);\n}\n\ndouble dot(P a,P b){\n  return real(conj(a)*b);\n}\n\nint ccw(P a,P b,P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0)return 1;     //counter clockwise\n  if(cross(b,c)<0)return -1;    //clockwise\n  if(dot(b,c)<0)return 2;       //c--a--b on line\n  if(norm(b)<norm(c))return -2; //a--b--c on line\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> ps){\n  sort(ps.begin(),ps.end());\n  vector<P> ch(ps.size()*2);\n  int k=0;\n  for(int i=0;i<ps.size();ch[k++]=ps[i++]){\n    while(k>=2 && ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  for(int i=ps.size()-2,t=k+1;i>=0;ch[k++]=ps[i--]){\n    while(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])<=0)--k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\n\nint solve(){\n  vector<P> res = convex_hull(data);\n  return res.size();\n}\n\n\nint main(){\n  int n;\n  while(cin>>n){\n    if(n==0)break;\n    data.clear();\n    for(int i=0;i<n;i++){\n      ld a,b;\n      char c;\n      cin>>a>>c>>b;\n      data.push_back(P(a,b));\n    }\n    cout<<n-solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cfloat>\n#include <cmath>\nusing namespace std;\n\ndouble x[100];\ndouble y[100];\n\ndouble calcLength(int i, int j) {\n  return sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n}\n\ndouble calcGradient(int i, int j) {\n  return (y[j]-y[i])/(x[j]-x[i]);\n}\n\ndouble calcCos(int i, int j, int k) {\n  double t = (x[i]-x[j])*(x[k]-x[j]) + (y[i]-y[j])*(y[k]-y[j]);\n  return t / (calcLength(i, j) * calcLength(j, k));\n}\n\nint main() {\n  int n, v0, v1, v2, v3, vt, c;\n  double m = DBL_MAX, t;\n  while (1) {\n    scanf(\"%d\", &n);\n    if (!n) break;\n    for (int i=0; i<n; i++) {\n      scanf(\"%lf,%lf\", &x[i], &y[i]);\n      if (x[i] < m) {\n        m = x[i];\n        v0 = i;\n      }\n    }\n    v1 = v0;\n    m = 0;\n    for (int i=0; i<n; i++) {\n      if (i==v0) continue;\n      if (x[i]==x[v0]) {\n        if (y[i]>y[v0]) {\n          v2 = i;\n          break;\n        } else continue;\n      } else {\n        t = calcGradient(v0, i);\n        if (t > m) {\n          m = t;\n          v2 = i;\n        }\n      }\n    }\n\n    c = 2;\n    while (1) {\n      m = 1.0;\n      for (vt=0; vt<n; vt++) {\n        if (vt==v1 || vt==v2) continue;\n        t = calcCos(v1, v2, vt);\n        if (t < m) {\n          m = t;\n          v3 = vt;\n        }\n      }\n      if (v3 == v0) break;\n      v1 = v2;\n      v2 = v3;\n      ++c;\n    }\n    printf(\"%d\\n\", n-c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\n\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tBOOL online(const P &p){\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]);\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\t\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool includeOnLine = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && (ccw(r[k-2], r[k-1], at(i)) < 1 || \n\t\t\t\t\t!includeOnLine && ccw(r[k-2], r[k-1], at(i)) == 2)) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && (ccw(r[k-2], r[k-1], at(i)) < 1 || \n\t\t\t\t\t!includeOnLine && ccw(r[k-2], r[k-1], at(i)) == 2)) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(scanf(\"%d\", &n), n){\n\t\tG g;\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tscanf(\"%lf,%lf\", &p.X, &p.Y);\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcout << g.size() - g.convex_hull(true).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nstruct point{\n\tdouble x;\n\tdouble y;\n\n\tbool operator != ( point& p )\n\t{\n\t\treturn ( x != p.x || y != p.y );\n\t}\n\tbool operator == ( point& p )\n\t{\n\t\treturn ( x == p.x && y == p.y );\n\t}\n};\n\npoint getLeftPoint( int n , point *points );\ndouble getCrossProduct( const point& a , const point& b , const point& o );\npoint operator - ( const point& a , const point& b );\nistream& operator >> ( istream& s , point& p );\n\nint main(void)\n{\n\tpoint points[100];\n\tint n;\n\tint ans;\n\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif( cin.eof() )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> points[i];\n\t\t}\n\n\t\tpoint leftPoint = getLeftPoint( n , points );\n\t\tpoint stdPoint = leftPoint;\n\t\tpoint outsideLeftPoint;\n\t\tint vertexCounter = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t\t{\n\t\t\t\tint flag = 0;\n\t\t\t\tif( points[i] != stdPoint )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < n ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( points[j] != stdPoint )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( getCrossProduct( points[i] , points[j] , stdPoint ) > 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( flag == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\toutsideLeftPoint = points[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstdPoint = outsideLeftPoint;\n\t\t\tvertexCounter++;\n\t\t\tif( outsideLeftPoint == leftPoint )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans = n - vertexCounter;\n\t\tstd::cout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\npoint getLeftPoint( int n , point *points )\n{\n\tpoint leftPoint = points[0];\n\tfor( int i = 1 ; i < n ; i++ )\n\t{\n\t\tif( points[i].x < leftPoint.x )\n\t\t{\n\t\t\tleftPoint = points[i];\n\t\t}\n\t}\n\treturn leftPoint;\n}\n\ndouble getCrossProduct( const point& a , const point& b , const point& o )\n{\n\tpoint ao = a - o;\n\tpoint bo = b - o;\n\treturn (ao.x * bo.y) - (ao.y * bo.x);\n}\n\npoint operator - ( const point& a , const point& b )\n{\n\tpoint p;\n\tp.x = a.x - b.x;\n\tp.y = a.y - b.y;\n\treturn p;\n}\n\nistream& operator >> ( istream& s , point& p )\n{\n\tchar c;\n\treturn s >> p.x >> c >> p.y;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\n#define SIZE 100000\n\nstruct P{\n    typedef double Type;\n    \n    Type x,y;\n    \n    P(Type X,Type Y){\n        x = X;\n        y = Y;\n    }\n    \n    bool operator< (const P &B) const{\n        return x==B.x ? y < B.y : x < B.x;\n    }\n};\n\n/* ConvexHull(??????) */\n\nbool ccw(P &base,P &A,P &B){\n    //??´???????????????????????????\n    return (A.x-base.x)*(B.y-base.y) - (A.y-base.y)*(B.x-base.x) >= 0; //double?????? -EPS\n    \n    //??´?????????????????????\n    //return (A.x-base.x)*(B.y-base.y) - (A.y-base.y)*(B.x-base.x) > 0; //double?????? EPS\n}\n\nvector<P> ConvexHull(vector<P> s){\n    vector<P> g;\n    int n = (int)s.size();\n    \n    if(n<3) return s;\n    \n    sort(s.begin(),s.end());\n    \n    for(int i=0;i<n;i++){\n        for(int m = (int)g.size();m>=2 && ccw(g[m-2],g[m-1],s[i]); m--){\n            g.pop_back();\n        }\n        g.push_back(s[i]);\n    }\n    \n    int upper_n = g.size();\n    \n    for(int i=n-2;i>=0;i--){\n        for(int m = (int)g.size();m>upper_n && ccw(g[m-2],g[m-1],s[i]); m--){\n            g.pop_back();\n        }\n        g.push_back(s[i]);\n    }\n    \n    reverse(g.begin(),g.end());\n    g.pop_back();\n    \n    return g;\n}\n\nint calc(int n){\n    //int n;\n    double x,y;\n    vector<P> point;\n    vector<P> ans;\n    \n    //scanf(\"%d\",&n);\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%lf,%lf\",&x,&y);\n        point.push_back(P(x,y));\n    }\n    \n    ans = ConvexHull(point);\n    int m = (int)ans.size();\n    \n    \n    printf(\"%d\\n\",n-m);\n    \n    return 0;\n}\n\nint main(){\n    int n;\n    \n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        calc(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define PI acos(-1.0)\n#define POSARG(a) arg(a) > 0.0? arg(a) : 2.0*PI + arg(a)\n\nint n;\n\nvector<P>::iterator convex_hull(vector<P>& vc)\n{\n\tint undermost = 0;\n\t\n\tfor(int i = 1; i < (int)vc.size(); i++)\n\t{\n\t\tif( vc[i].imag() < vc[undermost].imag() \n\t\t\t||( EQ(vc[undermost].imag(), vc[i].imag()) && vc[undermost].real() < vc[i].real() ) )\n\t\t{\n\t\t\tundermost = i;\n\t\t}\n\t}\n\t\n\tswap(vc[0], vc[undermost]);\n\n\tdouble nowarg = 0.0;\n\tint j;\n\t\n\tfor( j = 0; j < (int)vc.size()-1; j++)\n\t{\n\t\tdouble minarg = 2.0*PI;\n\t\tdouble maxdst = 0.0;\n\t\tint candidx = 0;\n\t\t\n\t\tfor(int i = j+1; i < (int)vc.size(); i++)\n\t\t{\n\t\t\tdouble newarg = POSARG(vc[i] - vc[j]);\n\t\t\tdouble newdst = abs(vc[i] - vc[j]);\n\t\t\t\n\t\t\tif( newarg > nowarg)\n\t\t\t\tif( newarg < minarg || ( EQ(newarg, minarg) && newdst > maxdst) )\n\t\t\t\t{\n\t\t\t\t\tminarg = newarg;\n\t\t\t\t\tmaxdst = newdst;\n\t\t\t\t\tcandidx = i;\n\t\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif(candidx == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswap(vc[j+1], vc[candidx]);\n\t\t\tnowarg = minarg;\n\t\t}\n\t}\n\t\n\treturn vc.begin()+j+1;\n}\n\nint solve(vector<P> vc)\n{\n\tvector<P>::iterator r = convex_hull(vc);\n\n\treturn vc.end() - r;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> vc;\t\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tchar c;\n\t\t\tdouble a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> c;\n\t\t\tcin >> b;\n\t\t\tvc.push_back(P(a, b));\n\t\t}\n\t\t\n\t\tcout << solve(vc) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\nconst double EPS = 1e-10;\n\nnamespace std{\n\tbool operator < (const P& a, const P& b) {\n\t\treturn EQ(real(a) , real(b)) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tdouble cross(const P& a, const P& b) {\n\t\treturn imag(conj(a)*b);\n\t}\n\tdouble dot(const P& a, const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n}\n\n//ツ点ツづ個進ツ行ツ陛サツ古シ\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//ツ禿環陛ッ\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  int n;\n\tdouble a,b;\n\twhile(true){\n\t\tvector<P> points;\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tpoints.push_back(P(a,b));\n\t\t}\n\n\t\tvector<P> hull = convex_hull(points);\n\t\tcout<<n-hull.size()<<endl;\n\t\t/*\n\n\t\tfor(int i = 0;i<points.size();i++){\n\t\t\tprintf(\"%lf %lf\\n\",points[i].real(),points[i].imag());\n\t\t}\n\t\tcout<<endl;\n\t\tfor(int i = 0;i<hull.size();i++){\n\t\t\tprintf(\"%lf %lf\\n\",hull[i].real(),hull[i].imag());\n\t\t}\n\t\t\tprintf(\"%lf %lf\\n\",hull[0].real(),hull[0].imag());\n\t\t*/\n\n\t}\n\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n    Line(const Point& a, const Point& b)\n        : a(a), b(b)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (a == b)\n            this->b.real() += 1e-12;\n    }\n};\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> Poly;\n// struct Poly : public vector<Point>\n// {\n//     Poly() {}\n//     Poly(int n)\n//     {\n//         resize(n);\n//     }\n// };\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > EPS_FOR_LIB) return counter_clockwise;\n\telse if (cross(p, q) < -EPS_FOR_LIB) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.b - line1.a, line2.b - line2.a)) < 1e-9;\n}\n// AOJ0021\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.b - line1.a, line2.b - line2.a)) < 1e-9;\n}\n\nbool is_on_line(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.b - line.a, p - line.a)) < 1e-20;\n}\nbool is_on_seg(const Line& seg, const Point& p)\n{\n\treturn abs(seg.a - p) + abs(p - seg.b) < abs(seg.a - seg.b) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.b - line.a, seg.a - line.a)\n\t\t* cross(line.b - line.a, seg.b - line.a) < EPS_FOR_LIB;\n}\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.b - seg1.a, seg2.a - seg1.a) * cross(seg1.b - seg1.a, seg2.b - seg1.a) < -EPS_FOR_LIB\n            && cross(seg2.b - seg2.a, seg1.a - seg2.a) * cross(seg2.b - seg2.a, seg1.b - seg2.a) < -EPS_FOR_LIB)\n\t\t|| is_on_seg(seg1, seg2.a)\n\t\t|| is_on_seg(seg1, seg2.b)\n\t\t|| is_on_seg(seg2, seg1.a)\n\t\t|| is_on_seg(seg2, seg1.b);\n}\n\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.a - line.b, p - line.b) / abs(line.a - line.b));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.a) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.a), dist_LP(line, seg.b));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.b - seg.a, p - seg.a) < 0)\n\t\treturn abs(seg.a - p);\n\telse if (dot(seg.a - seg.b, p - seg.b) < 0)\n\t\treturn abs(seg.b - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.a), dist_SP(seg1, seg2.b))\n\t\t\t, min(dist_SP(seg2, seg1.a), dist_SP(seg2, seg1.b)));\n}\n\nPoint cross_point_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"cross_point_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.b - seg1.a, seg2.a - seg1.a));\n\tgtype b = abs(cross(seg1.b - seg1.a, seg2.b - seg1.a));\n\n\tgtype t = a / (a + b);\n\treturn seg2.a + t * (seg2.b - seg2.a);\n}\nPoint cross_point_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"cross_point_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.b - line1.a, b = line2.b - line2.a;\n\tgtype p = cross(b, line2.a - line1.a);\n\tgtype q = cross(b, a);\n\treturn line1.a + p / q * a;\n}\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.a - line.b;\n\tgtype t = dot(p - line.a, a) / norm(a);\n\treturn line.a + t * a;\n}\n\n// 線対称な点\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    Poly to_poly() const\n    {\n        Poly res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nPoly convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    Poly res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定\n// AOJ0035\nbool is_convex(const Poly& p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (ccw(p[(i - 1 + p.size()) % p.size()], p[i], p[(i + 1) % p.size()]) > 0)\n            return false;\n    }\n    return true;\n}\n\n// not verified\ngtype area(const Poly& p)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\ts += cross(p[i], p[(i + 1) % p.size()]);\n\treturn abs(s / 2);\n}\n\n// verify: AOJ0012\nenum res_contain{ IN, ON, OUT };\nres_contain contain(const Poly& poly, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)poly.size(); ++i)\n\t{\n\t\tPoint a = poly[i] - p, b = poly[(i + 1) % poly.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (is_on_seg(Line(poly[i], poly[(i + 1) % poly.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n\n// 円\nenum res_circle_rela\n{\n    a_in_b,\n    b_in_a,\n\n    tangent,\n    intersect,\n    not_intersect,\n};\n// verify: AOJ0023(feps = 0)\nres_circle_rela circle_rela(const Circle& a, const Circle& b)\n{\n    const gtype feps = 0;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\nvector<Point> intersect_points(const Circle& a, const Circle& b)\n{\n    Point ab = b.p - a.p;\n    Point c = a.p + ab * (a.r / (a.r + b.r));\n\n    gtype dis = abs(a.p - c);\n    if (dis > a.r)\n        return vector<Point>();\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - dis*dis));\n\n    Point u = ab * Point(0, 1) / abs(ab);\n    Point v = ab * Point(0, -1) / abs(ab);\n\n    Point p = c + u * h;\n    Point q = c + v * h;\n\n    vector<Point> res;\n    res.push_back(p);\n    if (abs(p - q) > 1e-9)\n        res.push_back(q); // 2点で交わっている\n\n    return res;\n}\n\nbool intersect_poly_circle(const Poly& poly, const Circle& c)\n{\n    for (int i = 0; i < (int)poly.size(); ++i)\n        if (dist_SP(Line(poly[i], poly[(i + 1) % poly.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain(poly, c.p) == IN;\n}\n\n\nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Poly p;\n        rep(i, n)\n        {\n            double x, y;\n            scanf(\"%lf,%lf\", &x, &y);\n            p.pb(Point(x, y));\n        }\n        Poly convex = convex_hull(p);\n        cout << p.size() - convex.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define X first\n#define Y second\nint main(){\n  vector<pair<double,double> > pin;\n  bool f[100];\n  int n;\n  while(cin >>n,n){\n    pin.clear();\n    for(int i=0; i<n; i++) f[i] = true;\n    for(int i=0; i<n; i++){\n      double a,b;\n      scanf(\"%lf,%lf\",&a,&b);\n      pin.push_back(make_pair(a,b));\n    }\n    sort(pin.begin(),pin.end());\n    int now = 0,next,ans = 0;\n    for(;;){\n      for(int i=0; i<n; i++){\n\tif(i == now || !f[i]) continue;\n\tnext = i;\n\tdouble ax = pin[i].X-pin[now].X;\n\tdouble ay = pin[i].Y-pin[now].Y;\n\tfor(int j=0; j<n; j++){\n\t  if(!f[j] || i == j) continue;\n\t  double bx = pin[j].X-pin[now].X;\n\t  double by = pin[j].Y-pin[now].Y;\n\t  if(ax*by-ay*bx<0){next = -1;break;}\n\t}\n\tif(next == i) break;\n      }\n      now = next;\n      f[now] = false;\n      if(now == 0) break;\n    }\n    for(int i=0; i<n; i++) if(f[i]) ans++;\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <vector>\n#include <iostream>\n#include <cstdio>\nstruct Point {\n\tdouble x, y;\n\tPoint(const double &argx = 0, const double &argy = 0) :x(argx), y(argy) {};\n\tPoint operator+(const Point &other) const { return Point(x + other.x, y + other.y); }\n\tPoint operator-(const Point &other) const { return Point(x - other.x, y - other.y); }\n\tPoint operator-() const { return Point(-x, -y); }\n\tbool operator>(const Point &other) const { return (y > other.y) || (y == other.y && x > other.x); }\n\tbool operator<(const Point &other) const { return (y < other.y) || (y == other.y && x < other.x); }\n\tbool operator==(const Point &other) const { return (y == other.y) && (x == other.x); }\n\tvoid inspect() const { std::cout << \"(\" << x << \",\" << y << \")\" << \"\\n\"; }\n};\nstruct Vector {\n\tVector(const int &x = 0, const int &y = 0) :origin(0, 0), vector(x, y) {};\n\tVector(const Point &p1, const Point &p2) :origin(p1), vector(p2 - p1) {};\n\tVector operator+(const Vector &other) const { return Vector(origin, origin + vector + other.vector); }\n\tVector operator-(const Vector &other) const { return Vector(origin, origin + vector - other.vector); }\n\tVector operator-() const { return Vector(origin, -vector); }\n\tdouble operator*(const Vector &other) const { return vector.x * other.vector.x + vector.y * other.vector.y; }\n\tdouble cross(const Vector &other) const { return vector.x * other.vector.y - vector.y * other.vector.x; }\n\tvoid inspect() const { vector.inspect(); }\n\tPoint origin, vector;\n};\ntemplate <class T>\nvoid sort(std::vector<T> &vector, const int &left, const int &right) {\n\tif (left < right) {\n\t\tauto pivot = vector.at(left + (right - left) / 2);\n\t\tauto l = left, r = right;\n\t\twhile (l < r) {\n\t\t\twhile (pivot < vector.at(l))++l;\n\t\t\twhile (pivot > vector.at(r))--r;\n\t\t\tif (l < r) {\n\t\t\t\tauto temp = vector.at(l);\n\t\t\t\tvector.at(l) = vector.at(r); vector.at(r) = temp;\n\t\t\t\t++l; --r;\n\t\t\t}\n\t\t}\n\t\tsort(vector, left, r); sort(vector, r + 1, right);\n\t}\n}\nint main() {\n\tconstexpr double LES = 0.0000000001;\n\tint n;\n\tstd::cin >> n;\n\twhile (n != 0) {\n\t\tstd::vector<Point> point(n);\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tstd::scanf(\"%lf,%lf\", &x, &y);\n\t\t\tpoint.at(i) = Point(x, y);\n\t\t}\n\t\tsort(point, 0, n - 1);\n\t\tauto func = [](const Point &p1, const Point &p2, const Point &p3) {\n\t\t\treturn Vector(p2, p1).cross(Vector(p2, p3));\n\t\t};\n\t\tint sum = 0;\n\t\tstd::vector<Point> stack(n + 2);\n\t\tstack.at(0) = point.at(0); stack.at(1) = point.at(0);\n\t\tauto idx = 1;\n\t\tfor (auto &p : point) {\n\t\t\twhile (func(stack.at(idx - 1), stack.at(idx), p) > LES) {\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tstack.at(++idx) = p;\n\t\t}\n\t\tsum += idx - 2;\n\t\tidx = 1;\n\t\tfor (auto &p : point) {\n\t\t\twhile (func(stack.at(idx - 1), stack.at(idx), p) < -LES) {\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tstack.at(++idx) = p;\n\t\t}\n\t\tsum += idx - 2;\n\t\tstd::cout << n - sum << std::endl;\n\t\tstd::cin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef map<double,int> MDI;\ntypedef MDI::iterator MDII;\n\n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n\n\nint main(){\n\n\tint n;\n\tint max;\n\tint ans;\n\tdouble x,y;\n\tdouble hx,hy,ix,iy,jx,jy;\n\tchar gav;\n\tVPBB pin;\n\tMDI point;\n\n\twhile(1){\n\n\t\t/*入力*/\n\t\tcin>>n;\n\n\t\t/*終了*/\n\t\tif(n==0) break;\n\n\t\t/*準備*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>gav>>y;\n\t\t\tpin.PUSH(PBB(x,y));\n\t\t}\n\t\tans=0;\n\n\t\t/*端の点を決める*/\n\t\tmax=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(pin[max].second<pin[i].second) max=i;\n\t\t\telse if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n\t\t}\n\n\t\t/*基準点との角度から順番を付ける*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i!=max){\n\t\t\t\tpoint.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n\t\t\t}\n\t\t}\n\t\tpoint.insert(MDIVT(-1*INF,max));\n\n\t\t/*3点の角度から凸包を求めていく*/\n\t\tMDII iH=point.begin(),iI=point.begin(),iJ=point.begin();\n\t\tiI++,iJ++,iJ++;\n\t\twhile(iJ!=point.end()){\n\t\t\thx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n\t\t\tix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n\t\t\tjx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n\n\t\t\t/*cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug*/\n\n\t\t\tif((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0){\n\t\t\t\tiH++,iI++,iJ++;\n\t\t\t}\n\t\t\telse{\n\t\t\tiI=point.erase(iI);\n\t\t\tiJ++;\n\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\t/*出力*/\n\t\tcout<<ans<<endl;\n\n\t\t/*初期化*/\n\t\tpin.clear();\n\t\tpoint.clear();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nmain(){\n\tint n,i,start,M;\n\tdouble x,y,dX,dY,dx,dy,dot,n1,n2,co,m;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<pair<pair<double,double>,int> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf,%lf\",&x,&y),v.push_back(make_pair(make_pair(x,y),i));\n\t\tpair<pair<double,double>,int>p=*min_element(v.begin(),v.end());\n\t\tdX=0,dY=-1;\n\t\tstart=p.second;\n\t\tvector<int>V;\n\t\tfor(;;){\n\t\t\tm=-1,M=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(i==p.second)continue;\n\t\t\t\tdx=v[i].first.first-p.first.first,dy=v[i].first.second-p.first.second;\n\t\t\t\tdot=dX*dx+dY*dy;\n\t\t\t\tn1=hypot(dX,dY),n2=hypot(dx,dy);\n\t\t\t\tco=dot/n1/n2;\n\t\t\t\t//printf(\"%f\\n\",co);\n\t\t\t\tif(m<co)m=co,M=i;\n\t\t\t}\n\t\t\tif(M==start)break;\n\t\t\tV.push_back(M);\n\t\t\t//printf(\"---%d %d\\n\",M,start);\n\t\t\tdX=v[M].first.first-p.first.first,dY=v[M].first.second-p.first.second;\n\t\t\tp=v[M];\n\t\t}\n\t\tprintf(\"%d\\n\",n-V.size()-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<double, double>P;\n\nP p[100];\ndouble det(P a, P b) {\n\treturn a.first*b.second - a.second*b.first;\n}\nP operator-(P a, P b) { return P(a.first - b.first, a.second - b.second); }\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n)scanf(\"%lf,%lf\", &p[i].first, &p[i].second);\n\t\tsort(p, p + n);\n\t\tvector<P>a(n * 2);\n\t\tint k = 0;\n\t\trep(i, n) {\n\t\t\twhile (k > 1 && det(a[k - 1] - a[k - 2], p[i] - a[k - 2]) < 0)k--;\n\t\t\ta[k++] = p[i];\n\t\t}\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\twhile (k > 1 && det(a[k - 1] - a[k - 2], p[i] - a[k - 2]) < 0)k--;\n\t\t\ta[k++] = p[i];\n\t\t}\n\t\tprintf(\"%d\\n\", n - k + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <complex>\nusing namespace std;\n\n#define _gp(l) const auto gcu{getchar##l}; const auto pcu{putchar##l}\n#ifdef __linux\n_gp(_unlocked);\n#else\n_gp();\n#endif\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n_T _DEF(T,in,int c){T n=0;int m=1;while(isspace(c)){c=gcu();}if(c=='-')m=-1,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n_T _DEF(T,in,){return in<T>(gcu());}\n_DEF(int,in,){return in<int>(gcu());}\nstruct _IN{inline operator int(){return in();}}IN;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n_T _SCAN(T &n){int c=gcu();return c==EOF?n=0,false:(n=in<T>(c),true);}\n_SCAN(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_SCAN(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=(char)c;}}\n#endif\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);} _OUT(const char *s){while(*s)pcu(*s++);} _OUT(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_OUT(string s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _OUT(vector<T> v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _OUTL(T&&... t){out(move(t)...);outl();}\nstruct range{\n\tint e,b=0,s=1; range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\tstruct it { int v, s; it (int _v, int _s) : v(_v), s(_s) {} operator int()const{return v;} operator int&(){return v;} int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin() {return {b, s};} it end() {return {e, s};}};\n\nusing P = complex<double>;\n\nint main() {\n\tfor (int n; (n = IN);) {\n\t\tvector<P> v(n), t;\n\t\tfor (P &i: v) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\ti = {x, y};\n\t\t}\n\t\tsort(begin(v), end(v), [](P a, P b) {return real(a) == real(b) ? imag(a) < imag(b) : real(a) < real(b);});\n\t\tauto f {[&](auto i, auto e, size_t s) {\n\t\t\tfor (;i != e; i++) {\n\t\t\t\twhile (t.size() > s && imag((t.back() - *(end(t) - 2)) * conj(*i - t.back())) <= 0)\n\t\t\t\t\tt.pop_back();\n\t\t\t\tt.push_back(*i);\n\t\t\t}\n\t\t}};\n\t\tf(begin(v), end(v), 1);\n\t\tf(rbegin(v) + 2, rend(v), t.size());\n\t\toutl(n - t.size() + 1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n \n \nmain(){\n  int n;\n  while(cin>>n,n){\n    double x[n],y[n];\n    double sx=100000;\n    int used[n];\n    int si;\n\n    rep(i,n){\n      cin>>x[i];\n      cin.get();\n      cin>>y[i];\n      used[i]=false;\n      if(x[i]<sx){\n\tsx=x[i];\n\tsi=i;\n      }\n    }\n\n    used[si]=true;\n\n    int ni=0;\n    sx=100000;\n    rep(i,n){\n      if(i==si)continue;\n      double dx=x[i]-x[si],dy=y[i]-y[si];\n      double t=atan2(dy,dx);\n      if(t<sx){\n\tsx=t;\n\tni=i;\n      }\n    }\n\n    used[ni]=true;\n\n    while(true){\n      double nt=-1000000;\n      int nni;\n      double dx1=x[ni]-x[si],dy1=y[ni]-y[si];\n      rep(i,n){\n\tif(i==si || i==ni)continue;\n\tdouble dx2=x[i]-x[ni],dy2=y[i]-y[ni];\n\n\tdouble t=(dx1*dx2+dy1*dy2)/sqrt(dx1*dx1+dy1*dy1)/sqrt(dx2*dx2+dy2*dy2);\n\tif(t>nt){\n\t  nt=t;\n\t  nni=i;\n\t}\n      }\n\n      if(used[nni])break;\n      used[nni]=true;\n      si=ni;\n      ni=nni;\n    }\n    int ans=0;\n    rep(i,n)if(used[i])++ans;\n\n    cout<<n-ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n\tfor(;;){\n\t\tint n;\n\t\tcin >>n;\n\t\tif(!n){break;}\n\t\tdouble pin[100][2] = {0},min_x =  10000;\n\t\tint rubber[2] = {0};\n\t\tbool done[100] = {false};\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%lf,%lf\",&pin[i][0],&pin[i][1]);\n\t\t\tif(min_x>pin[i][0]){min_x = pin[i][0];rubber[0] = i;}\n\t\t}\n\t\trubber[1] = rubber[0];\n\t\tfor(;;){\n\t\t\tint now,j;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(!done[i] && i!=rubber[1]){\n\t\t\t\t\tdouble ax = pin[i][0]-pin[rubber[1]][0];\n\t\t\t\t\tdouble ay = pin[i][1]-pin[rubber[1]][1];\n\t\t\t\t\tfor(j=0; j<n; j++){\n\t\t\t\t\t\tif(!done[j]){\n\t\t\t\t\t\t\tdouble bx = pin[j][0]-pin[rubber[1]][0];\n\t\t\t\t\t\t\tdouble by = pin[j][1]-pin[rubber[1]][1];\n\t\t\t\t\t\t\tif(ax*by-ay*bx<0){break;}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j == n){now = i;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone[now] = true;\n\t\t\trubber[1] = now;\n\t\t\tif(rubber[1] == rubber[0]){break;}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=0; i<n; i++){if(!done[i]){sum++;}}\n\t\tcout <<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n\nstruct P{\n    P(){}\n    P(double a, double b){\n\tx = a;y = b;\n    }\n    double x, y;\n    double det(P p){\n\treturn x * p.y - y * p.x;\n    }\n    P operator-(P p){\n\treturn P(x - p.x, y - p.y);\n    }\n};\n\nbool comp_p(const P &x, const P &y){\n    if(x.x == y.x)return x.y < y.y;\n    return x.x < y.x;\n}\n\nP ans[1050];\n\nint main(){\n    int n;\n    double a, b;\n    while(cin >> n, n){\n\tvector<P> ps;\n\tfor(int i = 0;i < n;i++){\n\t    scanf(\"%lf,%lf\", &a, &b);\n\t    ps.push_back(P(a, b));\n\t}\n\tsort(ps.begin(), ps.end(), comp_p);\n\tint res = 0;\n\tfor(int i = 0;i < ps.size();i++){\n\t    while(res > 1 && (ans[res - 1] - ans[res - 2]).det(ps[i] - ans[res - 1]) <= 0)res--;\n\t    ans[res++] = ps[i];\n\t}\n\tfor(int i = ps.size() - 2, t = res;i >= 0;i--){\n\t    while(res > t && (ans[res - 1] - ans[res - 2]).det(ps[i] - ans[res - 1]) <= 0)res--;\n\t    ans[res++] = ps[i];\n\t}\n\tres--;\n\tcout << n - res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <array>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nstatic constexpr long double PI = 3.1415926535897932;\nstruct angle {\n\tlong double r;\n\tangle() :r(0) {}\n\tangle(long double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic long double arr(const long double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const long double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const long double &o)const { return angle(r * o); }\n\tconst angle operator/(const long double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const long double &o) { return *this = *this * o; }\n\tangle &operator/=(const long double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator long double()const { return r; }\n\tconst long double sin()const { return std::sin(r); }\n\tconst long double cos()const { return std::cos(r); }\n\n\tconst long double degree()const { return r*(180.0 / PI); }\n\tconst long double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr long double eps = 0.000000001;\n};\nangle operator\"\" _deg(long  double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr long double eps = 0.0000000001;\n\tlong double x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(long double x_, long double y_) :x(x_), y(y_) {}\n\tpvec(long double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / abs2(); }\n\tconst pvec operator*(const long double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const long double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const long double &o) { return *this = *this * o; }\n\tpvec &operator/=(const long double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst long double abs()const { return mysqrt(abs2()); }\n\tconst long double abs2()const { return x*x + y*y; }\n\tconst angle arg()const {\n\t\tif (x > eps) return angle(std::atan(y / x));\n\t\tif (x < eps) return angle(std::atan(y / x) + PI);\n\t\treturn angle();\n\t}\n\tstatic const long double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const long double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\n\tfriend std::istream &operator>>(std::istream &is, pvec &o) {\n\t\tlong double x_, y_;is >> x_ >> y_;o = pvec(x_, y_);return (is);\n\t}\nprivate:\n\tstatic const long double mysqrt(const long double &x) {\n\t\tlong double h = 0.5*x;\n\t\tstd::uint_fast64_t t = 0x5FE6EB50C7B537AAl\n\t\t\t- (*(std::uint_fast64_t*)&x >> 1);\n\t\tlong double r = *(long double*)&t;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\treturn r*x;\n\t}\n};\n\nstd::vector<pvec> convex_hull(std::vector<pvec> &points) {\n\tstatic constexpr long double eps = 0;\n\tstd::sort(points.begin(), points.end(),pvec::C_x);\n\tuint32 k = 0;\n\tconst uint32 n = points.size();\n\tstd::vector<pvec> ret(n * 2);\n\tfor (uint32 i = 0;i < n;++i) {\n\t\twhile (k > 1 && pvec::cross(ret[k - 1] - ret[k - 2],\n\t\t\tpoints[i] - ret[k - 1]) < -eps)--k;\n\t\tret[k++] = points[i];\n\t}\n\tfor (uint32 i = n - 2, t = k;~i;--i) {\n\t\twhile (k > t && pvec::cross(ret[k - 1] - ret[k - 2],\n\t\t\tpoints[i] - ret[k - 1]) < -eps)--k;\n\t\tret[k++] = points[i];\n\t}\n\tret.resize(k - 1);\n\treturn ret;\n}\nint main(void) {\n\t//std::ios::sync_with_stdio(false);\n\t//std::cin.tie(0);\n\tuint32 n;\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (!n) break;\n\t\tstd::vector<pvec> p(n);\n\t\tfor (uint32 i = 0;i < n;++i) {\n\t\t\tscanf(\"%lf,%lf\", &p[i].x, &p[i].y);\n\t\t}\n\t\tp = convex_hull(p);\n\t\tstd::cout << n - p.size() << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#define EPS 1e-10\nusing namespace std;\n\nstruct P {\n  double x,y;\n  P(){}\n  P(double x,double y):x(x),y(y){\n\n  }\n\n  P operator - (P p){\n    return P(x-p.x,y-p.y);\n  }\n\n  double det(P p){\n    return x*p.y-y*p.x;\n  }\n\n};\n  \n \n  \n  \nbool comp(const P& p, const P& q){\n  if(p.x!=q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nvector<P> totu(P* ps,int n){\n  sort(ps,ps+n,comp);\n  int k=0;\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1 && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)k--;\n    qs[k++] = ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\n\n\nint main(){\n  int n;\n\n  while(\n\tcin >> n \n\t&& \n\tn \n\t)\n    {\n      P ps[n+1];\n      for(int i=0;i<n;i++){\n\tscanf(\"%lf,%lf\",&ps[i].x,&ps[i].y);\n      }\n      cout << n-totu(ps,n).size() << endl;\n      \n    }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\nconst double EPS = 1e-10;\n\nnamespace std{\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tdouble cross(const P& a, const P& b) {\n\t\treturn imag(conj(a)*b);\n\t}\n\tdouble dot(const P& a, const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n}\n\n//ツ点ツづ個進ツ行ツ陛サツ古シ\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//ツ禿環陛ッ\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  int n;\n\tdouble a,b;\n\tvector<P> points;\n\twhile(true){\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tpoints.push_back(P(a,b));\n\t\t}\n\t\tcout<<n-convex_hull(points).size()<<endl;\n\t}\n\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n};\ndouble dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\nistream& operator>>(istream& is, Point& p) { char c; return is >> p.x >> c >> p.y; }\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n    if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\n/* 与えら れた点集合の凸包をかえす.\n * psは3つ以上の要素を持たねばならない. */\nbool operator<(const Point& a, const Point& b) { return a.x == b.x ? a.y < b.y : a.x < b.x; }\nvoid convexHull(vector<Point> ps, vector<Point>& ans) {\n    sort(ps.begin(), ps.end());\n    int N = ps.size();\n    int k = 0;\n    ans.resize(N * 2);\n    for (int i = 0; i < N; ans[k++] = ps[i++])\n        while (k >= 2 && ccw(ans[k - 2], ans[k - 1], ps[i]) <= 0) k--;\n    for (int i = N - 2, t = k + 1; i >= 0; ans[k++] = ps[i--])\n        while (k >= t && ccw(ans[k - 2], ans[k - 1], ps[i]) <= 0) k--;\n    /* 返上の点も頂点としたい場合は上4行を\n     *     for (int i = 0; i < N; ans[k++] = ps[i++])\n     *         while (k >= 2 && ccw(ans[k - 2], ans[k - 1], ps[i]) == -1) k--;\n     *     for (int i = N - 2, t = k + 1; i >= 0; ans[k++] = ps[i--])\n     *         while (k >= t && ccw(ans[k - 2], ans[k - 1], ps[i]) == -1) k--;\n     * にする. */\n    ans.resize(k - 1);\n}\n\nint main() {\n    while (true) {\n        int N; cin >> N;\n        if (N == 0) break;\n        vector<Point> ps(N);\n        for (int i = 0; i < N; i++) {\n            cin >> ps[i];\n        }\n        vector<Point> hull;\n        convexHull(ps, hull);\n        cout << N - hull.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a,double b){\n  if(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct P{\n  double x,y;\n  P() {}\n  P(double x,double y):x(x),y(y){\n  }\n  P operator + (P p){\n    return P(add(x,p.x),add(y,p.y));\n  }\n  P operator - (P p){\n    return P(add(x,-p.x),add(y,-p.y));\n  }\n  P operator * (double d){\n    return P(x*d,y*d);\n  }\n  double dot(P p){\n    return add(x*p.x,y*p.y);\n  }\n  double det(P p){\n    return add(x*p.y, -y*p.x);\n  }\n};\n\nbool cmp_x(const P& p, const P& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nvector<P>convex_hull(P* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<P>qs(n*2);\n\n  for(int i=0;i<n;i++){\n    while(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(void){\n  int n;\n  double x,y;\n  P p[100];\n\n  while(cin >> n,n){\n    for(int i=0;i<n;i++)\n      scanf(\"%lf,%lf\",&p[i].x,&p[i].y);\n \n    vector<P>d=convex_hull(p,n);\n\n    cout << n-d.size() << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : aoj0068.cpp\n// Author      : afterCmidday\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nclass pri_x_y{\npublic:\n\tbool operator()(const pair<double,double>& l,const pair<double,double>& r){\n\t\tif(l.first != r.first){\n\t\t\treturn l.first > r.first;\n\t\t}\n\t\treturn l.second > r.second;\n\t}\n};\n\ndouble outer(pair<double,double> a,pair<double,double> b,pair<double,double> c){\n\treturn (a.first - b.first) * (c.second - b.second) - (a.second - b.second) * (c.first - b.first);\n}\n\nint main() {\n\tint n, k;\n\tdouble x, y;\n\tvector<pair<double,double> > v, s;\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> x;\n\t\t\tcin.get();\n\t\t\tcin >> y;\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tsort(v.begin(),v.end(),pri_x_y());\n\t\tk = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\twhile(1 < k && outer(s[k - 2],s[k - 1],v[i]) <= 0){\n\t\t\t\ts.pop_back();\n\t\t\t\tk--;\n\t\t\t}\n\t\t\ts.push_back(v[i]);\n\t\t\tk++;\n\t\t}\n\t\tint t = k;\n\t\tfor(int i = n - 2;i >= 0;i--){\n\t\t\twhile(t < k && outer(s[k - 2],s[k - 1],v[i]) <= 0){\n\t\t\t\ts.pop_back();\n\t\t\t\tk--;\n\t\t\t}\n\t\t\ts.push_back(v[i]);\n\t\t\tk++;\n\t\t}\n\t\ts.pop_back();\n\t\tcout << n - s.size() << endl;\n\t\ts.clear();\n\t\tv.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nusing coord_t = double;\nusing coord2_t = double;\n\nstruct Point {\n  coord_t x, y;\n\n  Point() {}\n  Point(coord_t x, coord_t y) : x(x), y(y) {}\n\n  bool operator<(const Point &p) const {\n    return x < p.x || (x == p.x && y < p.y);\n  }\n};\n\ncoord2_t cross(const Point &O, const Point &A, const Point &B) {\n  return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nvector<Point> convex_hull(vector<Point> P) {\n  int n = P.size(), k = 0;\n  if (n == 1) return P;\n  vector<Point> H(2 * n);\n\n  sort(P.begin(), P.end());\n\n  for (int i = 0; i < n; ++i) {\n    while (k >= 2 && cross(H[k - 2], H[k - 1], P[i]) <= 0) k--;\n    H[k++] = P[i];\n  }\n\n  for (int i = n - 2, t = k + 1; i >= 0; i--) {\n    while (k >= t && cross(H[k - 2], H[k - 1], P[i]) <= 0) k--;\n    H[k++] = P[i];\n  }\n\n  // cout << \"P\" << endl;\n  // for (int i = 0; i < P.size(); ++i) {\n  //   cout << fixed << setprecision(5) << P[i].x << \" \" << P[i].y << endl;\n  // }\n  // cout << \"H\" << endl;\n  // for (int i = 0; i < H.size(); ++i) {\n  //   cout << fixed << setprecision(5) << H[i].x << \" \" << H[i].y << endl;\n  // }\n\n  H.resize(k - 1);\n  return H;\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<Point> v;\n    for (int i = 0; i < n; ++i) {\n      double x, y;\n      scanf(\"%lf,%lf\", &x, &y);\n      // cout << x << \" \" << y << endl;\n      v.push_back(Point(x, y));\n    }\n\n    vector<Point> ConvexHull = convex_hull(v);\n    cout << n - ConvexHull.size() << endl;\n\n    // for (int i = 0; i < ConvexHull.size(); ++i) {\n    //   cout << fixed << setprecision(10) << ConvexHull[i].x << \" \" << ConvexHull[i].y << endl;\n    // }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define EPS (1e-10)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point (double x = 0,double y = 0): x(x),y(y){}\n  Point operator + (Point &p){ return Point(x+p.x,y+p.y);}\n  Point operator - (Point &p){ return Point(x-p.x,y-p.y);}\n  Point operator * (double k){ return Point(x*k,y*k);}\n  bool operator < (const Point &p)const {\n    if(x == p.x) return y < p.y;\n    else return x < p.x;\n  }\n};\n\ndouble cross(Point a,Point b){\n  return a.x * b.y - a.y * b.x;\n}\n\nint main(){\n  int i,j,n,x,y,k;\n  Point p[100];\n  vector<Point> convex,c2;\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    for(i=0;i<n;i++){\n      scanf(\"%lf,%lf\",&p[i].x,&p[i].y);\n    }\n    sort(p,p+n);\n\n    convex.push_back(p[0]);\n    convex.push_back(p[1]);\n\n    j = 2;\n    if(n > 3){\n      for(i=2;i<n;i++){\n\tPoint a = convex[j-1] - convex[j-2];\n\tPoint b = p[i] - convex[j-2];\n\twhile(cross(a,b) > EPS && j >= 2){ \n\t  convex.pop_back();\n\t  j--;\n\t  if(j >= 2){\n\t    a = convex[j-1] - convex[j-2];\n\t    b = p[i] - convex[j-2];\n\t  }\n\t}\n\tconvex.push_back(p[i]);\n\tj++;\n      }\n      \n      c2.push_back(p[n-1]);\n      c2.push_back(p[n-2]);\n      k = 2;\n      for(i=n-3;i>=0;i--){\n\tPoint a = c2[k-1] - c2[k-2];\n\tPoint b = p[i] - c2[k-2];\n\twhile(cross(a,b) > EPS && k >= 2){\n\t  c2.pop_back();\n\t  k--;\n\t  if(k >= 2){\n\t    a = c2[k-1] - c2[k-2];\n\t    b = p[i] - c2[k-2];\n\t  }\n\t}\n\tc2.push_back(p[i]);\n\tk++;\n      }\n    }\n    cout << n - (j + k - 2)<< endl;\n    convex.clear();\n    c2.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define range(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef struct {P s,t;} L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef vector <C> VC;\n\nconst D eps=1.0e-10;\nconst D pi=acos(-1.0);\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\n//template<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\ntemplate<class T> int sig(T a,T b = 0) {return a < b ? -1 : b > a ? 1 : 0;}\n#define X real()\n#define Y imag()\n\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sq(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.t-l.s;}\ninline P input(){D x,y;char c;cin >> x >> c >> y; return P(x,y);}\n\ninline B cmp_x(const P &a,const P &b){\n\treturn (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;\n}  // base x\n\nVP convex_hull(VP pol){\n\tint n=pol.size(),k=0;\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tVP res(2*n);\n\n\t//??\\??????while?????????????????????\n\t//????????????????????????????????????????????´??????<=0\n\t//???????????????????????????????????????????????´??????<0\n\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\nint main(void){\n    for(int n; cin >> n, n;){\n        VP p(n);\n        for(auto & e : p) e = input();\n\n        VP cp = convex_hull(p);\n\n        cout << p.size() - cp.size() << endl;\n    }\n\n\treturn 0;\n}\n\n// inline??????????????????\n// eps????°????????????????\n// double??????????????????"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define rep2(x,from,to) for(int x = (from); x < (to); ++(x))\n#define rep(x,to) rep2(x,0,to)\ntypedef pair<double, double> dpair;\n\ndouble det(dpair p1, dpair p2, dpair p3) {\n\treturn (p2.first - p1.first) * (p3.second - p2.second) - (p2.second - p1.second) * (p3.first - p2.first);\n}\nint main() {\n\tint n;\n\twhile(cin >> n && n) {\n\t\tvector<dpair> v;\n\t\trep(i,n) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back(make_pair(x,y));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tdpair conv[205];\n\t\tint k = 0;\n\t\trep(i,n) {\n\t\t\twhile(k > 1 && det(conv[k-2], conv[k-1], v[i]) <= 0) --k;\n\t\t\tconv[k++] = v[i];\n\t\t}\n\t\tfor(int i = n - 2, t = k; i >= 0; --i) {\n\t\t\twhile(k > t && det(conv[k-2], conv[k-1], v[i]) <= 0) --k;\n\t\t\tconv[k++] = v[i];\n\t\t}\n\t\tcout << n - k + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nnamespace std {\n  bool operator <(const P &a, const P &b) {\n    if(a.real() != b.real()) return a.real() < b.real();\n    return a.imag() < b.imag();\n  }\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main() {\n  int n;\n  while(scanf(\"%d\", &n) != EOF && n) {\n    vector<P> g(n);\n    for(int i = 0; i < n; ++i) {\n      P &p = g[i];\n      scanf(\"%lf,%lf\", &p.real(), &p.imag());\n    }\n    printf(\"%d\\n\", g.size() - convex_hull(g).size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing Point=complex<ld>;\nconst ld eps=1e-9;\nld dot(Point a,Point b){return real(conj(a)*b);}\nld cross(Point a,Point b){return imag(conj(a)*b);}\n\nbool comp(Point lhs,Point rhs){\n    return lhs.real()<rhs.real() || lhs.real()==rhs.real() && lhs.imag()<rhs.imag();\n}\nint ccw(Point a,Point b,Point c){\n    b-=a;c-=a;\n    if(cross(b,c)>eps) return 1;\n    if(cross(b,c)<eps) return -1;\n    if(dot(b,c)<0) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\n\nvector<Point> convexHull(vector<Point> &p){\n    int n=p.size();\n    int k=0;\n    vector<Point> ch(n*2);\n    sort(p.begin(),p.end(),comp);\n    for(int i=0;i<n;ch[k++]=p[i++]) \n        while(k>=2 && ccw(ch[k-2],ch[k-1],p[i])<=0) --k;\n    for(int i=n-2,t=k+1;i>=0;ch[k++]=p[i--]) \n        while(k>=t && ccw(ch[k-2],ch[k-1],p[i])<=0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<Point> xy(n);\n        for(int i=0;i<n;i++){\n            double x,y;\n            scanf(\"%lf,%lf\",&x,&y);\n            xy[i]=Point(x,y);\n        }\n        vector<Point> ch=convexHull(xy);\n        ld res=0;\n        for(int i=0;i<ch.size();i++){\n            res+=norm(ch[i]-ch[(i+1)%ch.size()]);\n        }\n        cout<<n-ch.size()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS 1e-9\n\n//typedef complex<double> P;\n\nstruct P {\n\tdouble x, y;\n};\n\ntypedef vector<P> polygon;\n\nbool operator <(const P& p1, const P& p2) {\n\treturn p1.x < p2.x;\n}\nP operator -(const P& p1, const P& p2) {\n\treturn (P){p1.x - p2.x, p1.y - p2.y};\n}\n\nint F(double v) {\n\tif ( abs(v) < EPS ) return 0;\n\treturn v < 0 ? -1 : v > 0 ? 1 : 0;\n}\n\ndouble cross(P p1, P p2) {\n\treturn p1.x * p2.y - p1.y * p2.x;\n}\n\nint ccw(P& p1, P& p2, P& p3) {\n\treturn F(cross(p2 - p1, p3 - p1));\n}\n\nbool check(polygon& t, int comp) {\n\tint n = t.size();\n\tif (n < 3) return true;\n\treturn ccw(t[n-3], t[n-2], t[n-1]) != comp;\n}\n\nint main() {\n\tint n;\n\twhile ( cin >> n, n ) {\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back( (P){x, y} );\n\t\t}\n\t\tsort( v.begin(), v.end() );\n\n\t\tint ans = n+2;\n\n\t\tpolygon t;\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tt.push_back(v[i]);\n\t\t\twhile ( !check(t, 1) ) t.erase( t.end()-2, t.end()-1 );\n\t\t}\n\t\tans -= t.size();\n\n\t\tt.clear();\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tt.push_back(v[i]);\n\t\t\twhile ( !check(t, -1) ) t.erase( t.end()-2, t.end()-1 );\n\t\t}\n\t\tans -= t.size();\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<double,double> pd;\nvector<pd>vec;\nvector<long>used;\n\nbool op(pd p1,pd p2){\n    if(p1.first*p2.second-p2.first*p1.second>0)return 0;\n    return 1;\n}\nbool com(pd p1,pd p2){\n    return p1.first==p2.first?p1.second<p2.second:p1.first<p2.first;\n}\n\npd minu(pd p1, pd p2){\n    return make_pair(p1.first-p2.first, p1.second-p2.second);\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vec.clear();\n        used.clear();\n        for(int i=0;i<n;i++){\n            double x,y;char c;\n            cin>>x>>c>>y;\n            vec.push_back(make_pair(x, y));\n        }\n        sort(vec.begin(),vec.end(),com);\n        pd last=minu(vec[1],vec[0]), cur;\n        used.push_back(0);\n        used.push_back(1);\n        for(int i=0;i<vec.size();i++){\n            cur=vec[i];\n            if(find(used.begin(),used.end(),i)!=used.end())\n                continue;\n            while(op(last,minu(cur,vec[used[used.size()-1]]))){\n                used.pop_back();\n                last=minu(vec[used[used.size()-1]],vec[used[used.size()-2]]);\n            }\n            last=minu(cur,vec[used[used.size()-1]]);\n            used.push_back(i);\n        }\n        for(long i=vec.size()-1;i>=0;i--){\n            cur=vec[i];\n            if(find(used.begin(),used.end(),i)!=used.end()&&i!=0)\n                continue;\n            while(op(last,minu(cur,vec[used[used.size()-1]]))){\n                used.pop_back();\n                last=minu(vec[used[used.size()-1]],vec[used[used.size()-2]]);\n            }\n            if(i!=0){\n                last=minu(cur,vec[used[used.size()-1]]);\n                used.push_back(i);\n            }\n        }\n        cout<<vec.size()-used.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstruct point {\n\tdouble x;\n\tdouble y;\n};\n\ndouble theta(point p0, point p1){\n\tdouble dx = p1.x - p0.x, ax = max(dx, -dx);\n\tdouble dy = p1.y - p0.y, ay = max(dy, -dy);\n\tdouble t = (ax + ay == 0) ? 0 : dy / (ax + ay);\n\tif(dx < 0) t = 2 - t;\n\telse if(dy < 0) t = 4 + t;\n\treturn t * 90.0;\n}\n\nvoid swap(point ps[], int i, int j){\n\tdouble tx = ps[i].x, ty = ps[i].y;\n\tps[i].x = ps[j].x; ps[i].y = ps[j].y;\n\tps[j].x = tx; ps[j].y = ty;\n}\n\n\nint wrap(point ps[], int n){\n\tint i, min, M;\n\tdouble th, v;\n\tfor(min = 0, i = 1; i < n; i++)\n\t\tif(ps[i].y < ps[min].y) min = i;\n\tps[n] = ps[min]; th = 0.0;\n\tfor(M = 0; M < n; M++){\n\t\tswap(ps, M, min);\n\t\tmin = n; v = th; th = 360.0;\n\t\tfor(i = M+1; i <= n; i++)\n\t\t\tif(theta(ps[M], ps[i]) > v)\n\t\t\t\tif(theta(ps[M], ps[i]) < th)\n\t\t\t\t{\n\t\t\t\t\tmin = i; th = theta(ps[M], ps[min]); \n\t\t\t\t}\n\t\tif ( min == n) return M + 1;\n\t}\n}\n\nint main(){\n\tint n;\n\tchar c;\n\tpoint ps[101];\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> ps[i].x >> c >> ps[i].y;\n\t\t}\n\t\tcout << n - wrap(ps, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) ((fabs(a)-(b)) < EPS)\n#define dle(a,b) (equals(a,b) || a<b)\n\nclass Point {\npublic:\n  double x, y;\n  \n  Point (double x = 0, double y = 0) : x(x), y(y) {}\n  \n  Point operator+ (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator- (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator* (double k) { return Point(x*k, y*k); }\n  Point operator/ (double k) { return Point(x/k, y/k); }\n  \n  double norm() { return x*x + y*y; }\n  double abs() { return sqrt(norm()); }\n\n  bool operator< (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n};\n\ntypedef Point Vector;\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ) { return a.x*a.x+a.y*a.y; }\ndouble abs( Vector a ) { return sqrt(norm(a)); }\nPoint polar( double a, double r ) { return Point(cos(r)*a, sin(r)*a); }\ndouble getDistance( Vector a, Vector b ) { return abs(a-b); }\ndouble dot( Vector a, Vector b ) { return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ) { return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n\n  if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a, b) < EPS ) return CLOCKWISE;\n  if( dot(a, b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b)  ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool yxCmp( const Point &p1, const Point &p2 ) {\n  return (p1.y == p2.y) ? p1.x < p2.x : p1.y < p2.y;\n}\n\nclass PolarAngleCmp {\npublic:\n  Point o;\n  PolarAngleCmp( Point o ) : o(o) {}\n  bool operator() ( const Point &p1, const Point &p2 ) const {\n    Vector a = Vector(p1.x-o.x, p1.y-o.y);\n    Vector b = Vector(p2.x-o.x, p2.y-o.y);\n    double c = cross(a, b);\n    if(c == 0) return abs(a) < abs(b);\n    return c > 0;\n  }\n};\n\nPolygon grahamScan( Polygon &s ) {\n  Polygon h;\n  Point lm = *min_element(s.begin(), s.end(), yxCmp);\n  sort(s.begin(), s.end(), PolarAngleCmp(lm));\n  for(int i=0; i<=2; i++) h.push_back(s[i]);\n  for(int i=3; i<s.size(); i++) {\n    while(h.size()>=2 && ccw(h[h.size()-2], h.back(), s[i]) == CLOCKWISE)\n      h.pop_back();\n    h.push_back(s[i]);\n  }\n  return h;\n}\n\nint main() {\n  char ch;\n  int n;\n  \n  while(cin>>n, n) {\n    Polygon pl, all;\n    double x,y;\n    for(int i=0; i<n; i++) {\n      cin >> x >> ch >> y;\n      pl.push_back(Point(x,y));\n    }\n    all = grahamScan(pl);\n    cout << pl.size() - all.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n \n#define REP(i,s,e)\tfor(int i=(s); i<(e); i++)\n#define rep(i,n)\tREP(i,0,n)\n#define REPE(i,s,e)\tfor(int i=s; i>e; i--)\n#define repe(i,n)\tREPE(i,n,-1)\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef vector<vi> vii;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst int INF=100000000;\nconst double EPS=1e-10;\n//int mod=1000000007\n \n\n//??????????±???????\n\n// ??????????????????????¶????????????????\ndouble add(double a,double b){\n\tif(abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\n\n// ????¬?????????????????§???????\nstruct P {\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y) : x(x), y(y){\n\t}\n\tP operator + (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x * d, y * d);\n\t}\n\tdouble dot(P p){\t// ??????\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\tdouble det(P p){\t// ??????\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\n// ???????????§??????\nbool cmp_x(const P& p, const P& q){\n\tif(p.x != q.x) return p.x <q.x;\n\treturn p.y<q.y;\n}\n\n// ??????????±???????\t\nvector<P> convex_hull(P* ps, int n){\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;\t\t\t\t//?????????????????°\n\tvector<P> qs(n * 2);\t//?§????????????????\n\t// ?????´???????????????\n\tfor(int i = 0; i < n; i++){\n\t\twhile(k > 1 && (qs[k - 1] - qs[ k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\t// ?????´???????????????\n\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\twhile(k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <=0 ) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nconst int MAX_N =100;\nP ps[MAX_N];\n//vector<P> ps(MAX_N);\n\nint main(){\n\tint n;\n\tchar c;\n\n\twhile(cin>>n && n>0){\n\t\trep(i,n) cin>>ps[i].x>>c>>ps[i].y;\n\t\tcout<<n-convex_hull(ps, n).size()<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n \nusing namespace std;\n \ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef multimap<double,int> MDI;\ntypedef MDI::iterator MDII;\n \n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n \n \nint main(){\n \n    int n;\n    int max;\n    int ans;\n    int cnt;\n    double x,y;\n    double hx,hy,ix,iy,jx,jy;\n    char gav;\n    VPBB pin;\n    MDI point;\n \n    while(1){\n \n        /*入力*/\n        cin>>n;\n \n        /*終了*/\n        if(n==0) break;\n \n        /*準備*/\n        for(int i=0;i<n;i++){\n            cin>>x>>gav>>y;\n            pin.PUSH(PBB(x,y));\n        }\n        ans=0;\n \n        /*端の点を決める*/\n        max=0;\n        for(int i=1;i<n;i++){\n            if(pin[max].second<pin[i].second) max=i;\n            else if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n        }\n \n        /*基準点との角度から順番を付ける*/\n        for(int i=0;i<n;i++){\n            if(i!=max){\n                point.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n            }\n        }\n        point.insert(MDIVT(-1*INF,max));\n \n        /*3点の角度から凸包を求めていく*/\n        MDII iH=point.begin(),iI=point.begin(),iJ=point.begin();\n        iI++,iJ++,iJ++;\n        cnt=0;\n        while(iJ!=point.end()){\n            hx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n            ix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n            jx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n \n            /*cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug*/\n \n            if((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0){\n                iH++,iI++,iJ++;\n                while(cnt--) iH++;\n                cnt=0;\n            }\n            else{\n                iI++;\n                iJ++;\n                cnt++;\n                ans++;\n            }\n        }\n \n        /*出力*/\n        cout<<ans<<endl;\n \n        /*初期化*/\n        pin.clear();\n        point.clear();\n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <iterator>\n#include <stdlib.h>\n#include <map>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <set>\n#include <list>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\n// vector cout\ntemplate<typename _Ty>\nostream& operator << (ostream& os, const vector<_Ty>& v) {\n\tos << \"{\";\n\tfor (size_t i = 0; i < v.size(); i++)\n\t{\n\t\tif (i != 0) os << \", \";\n\t\tos << v[i];\n\t}\n\tos << \"}\";\n\n\treturn os;\n}\n\n//point\nclass Point {\npublic:\n\tdouble x;\n\tdouble y;\n\n\tPoint() {\n\t\tx = 0; y = 0;\n\t}\n\tPoint(int x, int y) {\n\t\tthis->x = x; this->y = y;\n\t}\n\n\tbool operator== (const Point& a) {\n\t\tif (x != a.x) return false;\n\t\tif (y != a.y) return false;\n\t\treturn true;\n\t}\n\n\tbool operator !=(const Point& a) {\n\t\tif (x != a.x) return true;\n\t\tif (y != a.y) return true;\n\t\treturn false;\n\t}\n\n\tbool operator < (const Point& a) {\n\t\tif (x == a.x) return (y < a.y);\n\t\treturn x < a.x;\n\t}\n};\n\n\n//point cout\nostream& operator << (ostream& os, const Point& p) {\n\treturn os << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\n\n//AB ?? AC\ndouble crossProduct(Point A, Point B, Point C) {\n\treturn (B.x - A.x)*(C.y - A.y) - (B.y - A.y)*(C.x - A.x);\n}\n\ndouble distanceSquare(Point A, Point B) {\n\treturn (A.x - B.x)*(A.x - B.x) + (A.y - B.y)*(A.y - B.y);\n}\n\n//S:????????????????????????\nint convexhull(vector<Point>& S)\n{\n\t//L:??????????§?????????????????????????\n\tvector<Point> L;\n\n\t//sort\n\tsort(S.begin(), S.end());\n\n\tPoint A, B, C;\n\n\tA = S[0];\n\tdo {\n\t\tL.push_back(A);\n\t\tB = S[0];\n\t\tfor (int i = 1; i < S.size(); i++){\n\t\t\tC = S[i];\n\t\t\tif (B == A) B = C;\n\t\t\telse {\n\t\t\t\tdouble v = crossProduct(A, B, C);\n\t\t\t\tif (v > 0 || ((fabs(v) < 1e-8) && (distanceSquare(A, C) > distanceSquare(A, B)))) B = C;\n\t\t\t}\n\t\t}\n\t\tA = B;\n\t} while (A != L[0]);\n\n\treturn S.size() - L.size();\n}\n\nint main() {\n\n\twhile (1) {\n\n\t\tint n;\n\t\tvector<Point> Points;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tPoint p;\n\t\t\tstring input;\n\t\t\tcin >> input;\n\n\t\t\tstringstream ss(input);\n\n\t\t\tss >> p.x;\n\t\t\tss.ignore();\n\t\t\tss >> p.y;\n\n\t\t\tPoints.push_back(p);\n\t\t}\n\t\tcout << convexhull(Points) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint main(void)\n{\n\tint i,n,cnt,mi,ii;\n\tdouble x[100],y[100],x0,y0,x1,y1,mx,x2,y2,kos,mkos;\n\twhile(1)\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)\tbreak;\n\t\tfor(i=0;i<n;i++)\t{\n\t\t\tscanf(\"%lf,%lf\",&x[i],&y[i]);\n\t\t}\n\t\tmx=999.0;\n\t\tfor(i=0;i<n;i++)\t{\n\t\t\tif(mx>x[i])\t{\n\t\t\t\tmx=x[i];\tmi=i;\n\t\t\t}\n\t\t}\n\t\tcnt=1;\n\t\tx0=x[mi];\ty0=y[mi]+1.0;\tx1=x[mi];\ty1=y[mi];\tii=mi;\n\t\twhile(1)\t{\n//\t\t\tprintf(\"x1=%lf y1=%lf\\n\",x1,y1);\n\t\t\tmkos=2.0;\n\t\t\tfor(i=0;i<n;i++)\t{\n\t\t\t\tif(i!=ii)\t{\n\t\t\t\t\tx2=x[i];\ty2=y[i];\n\t\t\t\t\tkos=((double)(x0-x1)*(x2-x1)+(double)(y0-y1)*(y2-y1))/\n\t\t\t\t\t(sqrt((double)(x0-x1)*(x0-x1)+(double)(y0-y1)*(y0-y1))*\n\t\t\t\t\t sqrt((double)(x2-x1)*(x2-x1)+(double)(y2-y1)*(y2-y1)));\n\t\t\t\t\tif(mkos>kos)\t{\n\t\t\t\t\t\tmkos=kos;\n\t\t\t\t\t\tii=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mi==ii)\tbreak;\n\t\t\tx0=x1;\ty0=y1;\tx1=x[ii];\ty1=y[ii];\n\t\t\tcnt++;\n\t\t}\t\n\t\tprintf(\"%d\\n\",n-cnt);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nstruct comp\n{\n\tbool operator()(const P& a, const P& b) const\n\t{\n\t\treturn a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n};\n\nvector<P> convex_hull(vector<P>& ps)\n{\n\tsort(ps.begin(), ps.end(), comp());\n\tint k = 0, n = ps.size();\n\tvector<P> qs(n * 2);\n\t\n\tfor(int i = 0; i < n; ++i){\n\t\twhile(k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\t\n\tfor(int i = n - 2, t = k; i >= 0; --i){\n\t\twhile(k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nint main()\n{\n\tint n;\n\tdouble x, y;\n\tvector<P> ps;\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\t\n\t\tps.resize(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tps[i] = P(x,y);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", n - (int)convex_hull(ps).size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<climits>\n#include<cmath>\n#include<cassert>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<utility>\n#include<utility>\n#include<cmath>\nusing namespace std;\n#define INF (INT_MAX/3-10)\n\n#define X first\n#define Y second\n\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\n\nint out_pro(P a,P b) {\n  return (a.X * b.Y - b.X * a.Y);\n}\n\nint in_pro(P a,P b){\n  return (a.X * b.X + a.Y *b.Y);\n}\n\nld pow_len(P a) {\n  return a.X * a.X + a.Y * a.Y;\n}\n\nld sqrt_len(P a){\n  return sqrt(pow_len(a));\n}\n\nP mv(P a,P b) {\n  return P(a.X - b.X, a.Y - b.Y);\n}\n\n\n//凸法\nvector<P> convex(vector<P> list) {\n  if(list.size()<=3)return list;\n  sort(list.begin(),list.end());\n  vector<P> res;\n  res.clear();\n  res.push_back(list[0]);\n  res.push_back(list[1]);\n  res.push_back(list[2]);\n  bool v = (out_pro(mv(res[0],res[1]),mv(res[1],res[2]))>0) ;\n  for(int i=3;i<list.size();i++){\n    for(int j=0;j<res.size();j++){\n      int jj = (j+1)%(res.size()-1);\n      int jjj = (j+2)%(res.size()-2);\n      if(v == (out_pro(mv(res[j],res[jj]),mv(res[jj],list[i]))>0)){\n        while(v!=(out_pro(mv(res[jj],list[i]),mv(list[i],res[jjj])))>0&&res.size()>3){\n          res.erase(res.begin()+jjj);\n        }\n        res.insert(res.begin()+jj,list[i]);\n        break;\n      }\n    }\n  }/*\n  for(int i=0;i<res.size();i++){\n    cout<<res[i].X<<\" \"<<res[i].Y<<endl;\n  }*/\n  return res;\n}\n\n\n/*\ninput data\n*/\nvector<P> list;\nvoid init(){\n  list.clear();\n}\n\nbool input(){\n  int n;\n  cin>>n;\n  if(n==0)return false;\n  for(int i=0;i<n;i++){\n    ld x,y;char tmp;\n    cin>>x>>tmp>>y;\n    list.push_back(P(x,y));\n  }\n  return true;\n}\n\n\n/*\ndp とか\n*/\nint solve(){\n\treturn list.size()-convex(list).size();\n}\n\n\nint main(){\n\tfor(;init(),input();){\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntypedef complex<double> P;\n//typedef vector<P> G;\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n//(x,y)をx昇順にソート\nbool cmp(P a,P b){\n\tif(a.real()!=b.real()){\n\t\treturn a.real()<b.real();\n\t}else{\n\t\treturn a.imag()<b.imag();\n\t}\n}\n\n/*Graham Scan*/\n//凸多角形を求める\nint n;\nvector<P> getConvex(P *ps){\n\tsort(ps,ps+n,cmp);\n\tint k = 0;\n\tvector<P> convex(n*2);\n\tfor(int i =0;i < n;i++){\n\t\twhile(2 <=k&&cross(convex[k-1]-convex[k-2],ps[i]-convex[k-1])<=0){\n\t\t\tk--;\n\t\t}\n\t\tconvex[k++]=ps[i];\n\t}\n\tfor(int i =n-2,t = k;i >=0;i--){\n\t\twhile(t <k&& cross(convex[k-1]-convex[k-2],ps[i]-convex[k-1])<=0){\n\t\t\tk--;\n\t\t}\n\t\tconvex[k++]=ps[i];\n\t}\n\tconvex.resize(k-1);\n\treturn convex;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tP g[120];\n\t\tfor(int i =0; i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tchar c;\n\t\t\tcin>>x>>c>>y;\n\t\t\tg[i]=P(x,y);\n\t\t}\n\t\tvector<P> convex =getConvex(g);\n\t\tcout <<n-convex.size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nnamespace geo\n{\n  const double EPS = 1e-10;\n\n  class Point\n  {\n  public:\n    double x, y;\n    \n    Point(double _x = 0.0, double _y = 0.0)\n      :x(_x), y(_y) {}\n    \n    inline double abs() const\n    {\n      return sqrt(x*x + y*y);\n    }\n    \n    // 内積\n    inline double dot(const Point& p) const\n    {\n      return (x*p.x + y*p.y);\n    }\n    \n    // 外積\n    inline double cross(const Point& p) const\n    {\n      return (x*p.y - y*p.x);\n    }\n    \n    // 直交\n    /*\n      AOJ0058: EPS -> 0.0 \n    */\n    inline bool orthogonal(const Point& p) const\n    {\n      if (dot(p) < EPS)\n\treturn true;\n      return false;\n    }\n    \n    // 平行\n    inline bool parallel(const Point& p) const\n    {\n      if (cross(p) < EPS)\n\treturn true;\n      return false;\n    }\n    \n    Point operator +(const Point& p) const\n    {\n      return Point(x+p.x, y-p.y);\n    }\n    \n    Point operator -(const Point& p) const\n    {\n      return Point(x-p.x, y-p.y);\n    }\n    \n    Point operator =(const Point& p)\n    {\n      x = p.x;\n      y = p.y;\n    }\n    \n    bool operator ==(const Point& p) const\n    {\n      if ((*this - p).abs() < EPS)\n\treturn true;\n      return false;\n    }\n    \n    bool operator <(const Point& p) const\n    {\n      if (std::abs(x-p.x) < EPS)\n\treturn y < p.y;\n      return x < p.x;\n    }\n  };\n\n  // 凸包:graham scan(p.234) O(nlogn)\n  vector<Point> convex_hull_gs(vector<Point>& ps)\n  {\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    vector<Point> qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && (qs[k-1] - qs[k-2]).cross(ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && (qs[k-1] - qs[k-2]).cross(ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n  }\n}\n\nint main()\n{\n  int n;\n  while (~scanf(\"%d\", &n)) {\n    if (n == 0)\n      break;\n\n    vector<geo::Point> p(n);\n    for (int i = 0; i < n; ++i)\n      scanf(\"%lf,%lf\", &p[i].x, &p[i].y);\n\n    printf(\"%d\\n\", p.size() - geo::convex_hull_gs(p).size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ALL( c ) (c).begin(), (c).end()\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 )\n\t{\n\t\treturn;\n\t}\n\n\tPoint( double x, double y ) : x( x ), y( y )\n\t{\n\t\treturn;\n\t}\n\n\tPoint operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x - a.x, y - a.y );\n\t}\n\n\tPoint operator * ( const double &a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint operator / ( const double &a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n};\n\n// 外積\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// グラハムスキャン\nvector< Point > getConvex( vector< Point > ps )\n{\n\tconst int N = ps.size();\n\n\tsort( ALL( ps ) );\n\n\tint k = 0;\n\tvector< Point > convex( N * 2 );\n\n\tfor ( int i = 0; i < N; i++ )\n\t{\n\t\twhile ( 2 <= k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= EPS )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tfor ( int i = N - 2, t = k; 0 <= i; i-- )\n\t{\n\t\twhile ( t < k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= EPS )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.resize( k - 1 );\n\n\treturn convex;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< Point > ps( n );\n\n\t\tEACH( p, ps )\n\t\t{\n\t\t\tchar d;\n\n\t\t\tcin >> p.x >> d >> p.y;\n\t\t}\n\n\t\tvector< Point > convex = getConvex( ps );\n\n\t\tcout << n - convex.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef map<double,int> MDI;\ntypedef MDI::iterator MDII;\n\n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n\n\nint main(){\n\n\tint n;\n\tint max;\n\tint ans;\n\tint cnt;\n\tdouble x,y;\n\tdouble hx,hy,ix,iy,jx,jy;\n\tchar gav;\n\tVPBB pin;\n\tMDI point;\n\n\twhile(1){\n\n\t\t/*入力*/\n\t\tcin>>n;\n\n\t\t/*終了*/\n\t\tif(n==0) break;\n\n\t\t/*準備*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>gav>>y;\n\t\t\tpin.PUSH(PBB(x,y));\n\t\t}\n\t\tans=0;\n\n\t\t/*端の点を決める*/\n\t\tmax=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(pin[max].second<pin[i].second) max=i;\n\t\t\telse if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n\t\t}\n\n\t\t/*基準点との角度から順番を付ける*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i!=max){\n\t\t\t\tpoint.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n\t\t\t}\n\t\t}\n\t\tpoint.insert(MDIVT(-1*INF,max));\n\n\t\t/*3点の角度から凸包を求めていく*/\n\t\tMDII iH=point.begin(),iI=point.begin(),iJ=point.begin();\n\t\tiI++,iJ++,iJ++;\n\t\tcnt=0;\n\t\twhile(iJ!=point.end()){\n\t\t\thx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n\t\t\tix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n\t\t\tjx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n\n\t\t\t/*cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug*/\n\n\t\t\tif((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0){\n\t\t\t\tiH++,iI++,iJ++;\n\t\t\t\twhile(cnt--) iH++;\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tiI++;\n\t\t\t\tiJ++;\n\t\t\t\tcnt++;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\t/*出力*/\n\t\tcout<<ans<<endl;\n\n\t\t/*初期化*/\n\t\tpin.clear();\n\t\tpoint.clear();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "typedef struct{double x,y,k;}w;double k,t;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++)p[i].k=o(0,i,100)/hypot(p[i].x-b.x,p[i].y-b.y);qsort(p+1,n-1,sizeof(w),z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//誤差を考慮して足し算\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2次元ベクトル\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p)const{\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p)const{\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d)const{\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d)const{\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p)const{//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p)const{//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p)const{\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n\n\nbool cmp_x(const P& p,const P& q){\n\tif(p.x!=q.x)return p.x<q.x;\n\treturn p.y<q.y;\n}\nvector<P> convex_hull(vector<P> ps){\n\tsort(ps.begin(),ps.end(),cmp_x);\n\tint k=0;\n\tvector<P> qs(ps.size()*2);\n\tfor(int i=0;i<ps.size();i++){\n\t\twhile(k>1 && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1]) <= 0 )k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=ps.size()-2,t=k;i>=0;i--){\n\t\twhile(k>t && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1]) <= 0 )k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\n\nint main(){\n\tint n;\n\tchar _;\n\twhile(cin>>n&&n){\n\t\tvector<P> ps(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>ps[i].x>>_>>ps[i].y;\n\t\t}\n\t\tcout<<ps.size()-convex_hull(ps).size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Point {\n\tdouble x, y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tbool operator <(const Point &p) const {\n\treturn x < p.x || (x == p.x && y < p.y);\n\t}\n};\n\ndouble cross(const Point &O, const Point &A, const Point &B){\n\treturn (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nint convex_hull(vector<Point> P){\n\tint n = P.size(), k = 0;\n\tvector<Point> H(2*n);\n\tsort(P.begin(), P.end());\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0.0) k--;\n\t\tH[k++] = P[i];\n\t}\n\tfor (int i = n-2, t = k+1; i >= 0; i--) {\n\t\twhile (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0.0) k--;\n\t\tH[k++] = P[i];\n\t}\n\treturn k-1;\n}\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\tvector < Point > vp;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf,%lf\",&x,&y);\n\t\t\tvp.push_back(Point(x,y));\n\t\t}\n\t\tprintf(\"%d\\n\",n-convex_hull(vp));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){}\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    const Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x;\n    }\n    bool operator<(const Point& p) const{\n        return x < p.x || (x == p.x && y < p.y);\n    }\n};\n\nvoid convexHull(const vector<Point>& p1, vector<Point>& p2)\n{\n    vector<Point> p = p1;\n    sort(p.begin(), p.end());\n    int n = p.size();\n\n    int j = 0;\n    p2.clear();\n    for(int i=0; i<2*n-1; ++i){\n        Point tmp = (i<n? p[i]:p[2*(n-1)-i]);\n        while(j >= 2 && (tmp-p2[j-2]).cross(p2[j-1]-p2[j-2]) < 0){\n            p2.pop_back();\n            -- j;\n        }\n        p2.push_back(tmp);\n        ++ j;\n    }\n    p2.pop_back();\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        char c;\n        vector<Point> p1(n), p2;\n        for(int i=0; i<n; ++i)\n            cin >> p1[i].x >> c >> p1[i].y;\n\n        convexHull(p1, p2);\n        cout << (n-p2.size()) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <array>\n#include <climits>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\nstatic constexpr long double PI = 3.1415926535897932;\nstruct angle {\n\tlong double r;\n\tangle() :r(0) {}\n\tangle(long double r_) :r(arr(std::fmod(r_, 2.0 * PI) + 2.0 * PI)) {}\n\tstatic long double arr(const long double &o) { return o < 2.0 * PI - eps ? o : o - 2.0 * PI; }\n\tstatic angle make(const long double &o) { angle ret;ret.r = o;return ret; }\n\tconst angle operator+(const angle &o)const { return make(arr(r + o.r)); }\n\tconst angle operator-(const angle &o)const { return make(arr(r - o.r + 2.0 * PI)); }\n\tconst angle operator*(const long double &o)const { return angle(r * o); }\n\tconst angle operator/(const long double &o)const { return angle(r / o); }\n\tangle &operator+=(const angle &o) { return *this = *this + o; }\n\tangle &operator-=(const angle &o) { return *this = *this - o; }\n\tangle &operator*=(const long double &o) { return *this = *this * o; }\n\tangle &operator/=(const long double &o) { return *this = *this / o; }\n\tconst angle operator~()const { return make(arr(3.0 * PI - r)); }\n\tconst angle operator-()const { return make(arr(2.0 * PI - r)); }\n\tconst bool operator==(const angle &o)const { return std::abs(r - o.r) <= eps; }\n\tconst bool operator!=(const angle &o)const { return std::abs(r - o.r) > eps; }\n\tconst bool operator< (const angle &o)const { return r <  o.r; }\n\tconst bool operator<=(const angle &o)const { return r <= o.r; }\n\tconst bool operator> (const angle &o)const { return r >  o.r; }\n\tconst bool operator>=(const angle &o)const { return r >= o.r; }\n\texplicit operator bool()const { return r > eps; }\n\texplicit operator long double()const { return r; }\n\tconst long double sin()const { return std::sin(r); }\n\tconst long double cos()const { return std::cos(r); }\n\n\tconst long double degree()const { return r*(180.0 / PI); }\n\tconst long double ratio()const { return r / (2.0 * PI); }\nprivate:\n\tstatic constexpr long double eps = 0.000000001;\n};\nangle operator\"\" _deg(long  double x) { return angle(x*(PI / 180.0)); }\nangle operator\"\" _rat(long double x) { return angle(x * 2.0 * PI); }\nangle operator\"\" _rad(long double x) { return angle(x); }\nstruct pvec {\n\tstatic constexpr long double eps = 0.0000000001;\n\tlong double x, y;\n\tpvec() :x(0), y(0) {}\n\tpvec(long double x_, long double y_) :x(x_), y(y_) {}\n\tpvec(long double abs_, angle r) :x(abs_*r.cos()), y(abs_*r.sin()) {}\n\tconst pvec operator+(const pvec &o)const { return pvec(x + o.x, y + o.y); }\n\tconst pvec operator-(const pvec &o)const { return pvec(x - o.x, y - o.y); }\n\tconst pvec operator*(const pvec &o)const { return pvec(x*o.x - y*o.y, x*o.y + y*o.x); }\n\tconst pvec operator/(const pvec &o)const { return pvec(x*o.x + y*o.y, y*o.x - x*o.y) / abs2(); }\n\tconst pvec operator*(const long double &o)const { return pvec(x * o, y * o); }\n\tconst pvec operator/(const long double &o)const { return pvec(x / o, y / o); }\n\tpvec &operator+=(const pvec &o) { return *this = *this + o; }\n\tpvec &operator-=(const pvec &o) { return *this = *this - o; }\n\tpvec &operator*=(const pvec &o) { return *this = *this * o; }\n\tpvec &operator/=(const pvec &o) { return *this = *this / o; }\n\tpvec &operator*=(const long double &o) { return *this = *this * o; }\n\tpvec &operator/=(const long double &o) { return *this = *this / o; }\n\n\tconst pvec operator+()const { return *this; }\n\tconst pvec operator-()const { return pvec(-x, -y); }\n\tconst pvec operator~()const { return pvec(x, -y); }\n\n\texplicit operator bool()const { return std::abs(x) > eps || std::abs(y) > eps; }\n\tconst bool operator==(const pvec &o)const { return std::abs(x - o.x) <= eps&&std::abs(y - o.y) <= eps; }\n\tconst bool operator!=(const pvec &o)const { return std::abs(x - o.x) > eps || std::abs(y - o.y) > eps; }\n\n\tconst long double abs()const { return mysqrt(abs2()); }\n\tconst long double abs2()const { return x*x + y*y; }\n\tconst angle arg()const {\n\t\tif (x > eps) return angle(std::atan(y / x));\n\t\tif (x < eps) return angle(std::atan(y / x) + PI);\n\t\treturn angle();\n\t}\n\tstatic const long double dot(const pvec &l, const pvec &r) { return l.x*r.x + l.y*r.y; }\n\tstatic const long double cross(const pvec &l, const pvec &r) { return l.x*r.y - l.y*r.x; }\n\n\tstatic const bool C_x(const pvec &l, const pvec &r) {\n\t\tif (l.x != r.x) return l.x < r.x;\n\t\treturn l.y < r.y;\n\t}\n\tfriend std::istream &operator>>(std::istream &is, pvec &o) {\n\t\tlong double x_, y_;is >> x_ >> y_;o = pvec(x_, y_);return (is);\n\t}\nprivate:\n\tstatic const long double mysqrt(const long double &x) {\n\t\tlong double h = 0.5*x;\n\t\tstd::uint_fast64_t t = 0x5FE6EB50C7B537AAl\n\t\t\t- (*(std::uint_fast64_t*)&x >> 1);\n\t\tlong double r = *(long double*)&t;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\tr *= 1.5 - h*r*r;\n\t\treturn r*x;\n\t}\n};\n\nstd::vector<pvec> convex_hull(std::vector<pvec> &points) {\n\tstatic constexpr long double eps = 0;\n\tstd::sort(points.begin(), points.end(),pvec::C_x);\n\tuint32 k = 0;\n\tconst uint32 n = points.size();\n\tstd::vector<pvec> ret(n * 2);\n\tfor (uint32 i = 0;i < n;++i) {\n\t\twhile (k > 1 && pvec::cross(ret[k - 1] - ret[k - 2],\n\t\t\tpoints[i] - ret[k - 1]) < -eps)--k;\n\t\tret[k++] = points[i];\n\t}\n\tfor (uint32 i = n - 2, t = k;~i;--i) {\n\t\twhile (k > t && pvec::cross(ret[k - 1] - ret[k - 2],\n\t\t\tpoints[i] - ret[k - 1]) < -eps)--k;\n\t\tret[k++] = points[i];\n\t}\n\tret.resize(k - 1);\n\treturn ret;\n}\nint main(void) {\n\t//std::ios::sync_with_stdio(false);\n\t//std::cin.tie(0);\n\tuint32 n;\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (!n) break;\n\t\tstd::vector<pvec> p(n);\n\t\tfor (uint32 i = 0;i < n;++i) {\n\t\t\tscanf_s(\"%lf,%lf\", &p[i].x, &p[i].y);\n\t\t}\n\t\tp = convex_hull(p);\n\t\tstd::cout << n - p.size() << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// intersect Segment p1-p2 and Segment p3-p4 ?\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n// intersect Segment s1 and Segment s2 ?\n// verified by 920, 833, 866, uoa2062\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\nPolygon andrewScan( Polygon s ){\n    Polygon u, l;\n    if ( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    int n;\n    for ( int i = 2; i < s.size(); i++ ){\n\tfor ( int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) != CLOCKWISE; n--){\n\t    u.pop_back();\n\t}\n\tu.push_back(s[i]);\n    }\n\n    for ( int i = s.size()-3; i >= 0; i-- ){\n\tfor ( int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) != CLOCKWISE; n--){\n\t    l.pop_back();\n\t}\n\tl.push_back(s[i]);\n    }\n    reverse(l.begin(), l.end());\n    for ( int i = u.size()-2; i >= 1; i-- ) l.push_back(u[i]);\n    return l;\n}\n\nmain(){\n  int n;\n  char ch;\n  double x, y;\n  while( cin >> n && n ){\n    Polygon P, C;\n    for ( int i = 0; i < n; i++ ){\n      cin >> x >>ch>> y;\n      P.push_back(Point(x, y));\n    }\n\n    C = andrewScan(P);\n\n    cout << P.size() - C.size() << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nint main(void) {\n\tdouble x[100];\n\tdouble y[100];\n\tint n;\n\t\n\twhile(cin >> n) {\n\t\tif(n == 0)   break;\n\t\tdouble steep = 100000;\n\t\tdouble min_cos = 1;\n\t\tdouble naiseki;\n\t\tdouble line1, line2;\n\t\tdouble cos;\n\t\tint start;\n\t\tint min_x1 = 0;\n\t\tint min_x2 = 0;\n\t\tint next;\n\t\tint remove = 1;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tscanf(\"%lf,%lf\", &x[i], &y[i]);\n\t\t\tif(x[i] < x[min_x1])   min_x1 = i;\n\t\t\telse if(x[i] == x[min_x1] && y[i] < y[min_x1])   min_x1 = i;\n\t\t}\n\t\tstart = min_x1;\n\t\t\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(x[i] == x[min_x1])   continue;\n\t\t\tif((y[i] - y[min_x1]) / (x[i] - x[min_x1]) < steep) {\n\t\t\t\tsteep = (y[i] - y[min_x1]) / (x[i] - x[min_x1]);\n\t\t\t\tmin_x2 = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(next != start) {\n\t\t\tmin_cos = 1;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(i == min_x1 || i == min_x2)   continue;\n\t\t\t\tnaiseki = (x[i] - x[min_x2]) * (x[min_x1] - x[min_x2]) + (y[i] - y[min_x2]) * (y[min_x1] - y[min_x2]);\n\t\t\t\tline1 = sqrt(pow(x[i] - x[min_x2], 2.0) + pow(y[i] - y[min_x2], 2.0));\n\t\t\t\tline2 = sqrt(pow(x[min_x1] - x[min_x2], 2.0) + pow(y[min_x1] - y[min_x2], 2.0));\n\t\t\t\tcos = naiseki / (line1 * line2);\n\t\t\t\tif(cos < min_cos) {\n\t\t\t\t\tmin_cos = cos;\n\t\t\t\t\tnext = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin_x1 = min_x2;\n\t\t\tmin_x2 = next;\n\t\t\t++remove;\n\t\t}\n\t\t\n\t\tcout << n - remove << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <cmath>\n#include <climits>\n#include <set>\n#include <iostream>\n#include <map>\n#include <functional>\n#include <cstdlib>\n#include <complex>\n\nusing namespace std;\n\n#define reep(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reep(i,0,n)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator< (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return  1;\t// ½vñè\n\tif(cross(b, c) < 0)   return -1;\t// vñè\n\tif(dot(b, c) < 0)     return  2;\t// c--b--a Æê¼üãÉÀñÅ¢é\n\tif(norm(b) < norm(c)) return -2;\t// a--b--c Æê¼üãÉÀñÅ¢é\n\treturn 0;\t\t\t\t\t\t\t// bÆcÍ¯ê\n}\n\nvector<P> convex_hull(vector<P>& ps)\n{\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2*n);\n\n\tfor(int i=0; i<n; ch[k++] = ps[i++]){\n\t\twhile(2<=k && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\t}\n\tfor(int i=n-2, t=k+1; i>=0; ch[k++] = ps[i--]){\n\t\twhile(t<=k && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\t}\n\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main()\n{\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<P> p(n);\n\t\trep(i, n)\n\t\t\tscanf(\"%lf,%lf\", &p[i].real(), &p[i].imag());\n\n\t\tprintf(\"%d\\n\", n-convex_hull(p).size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cfloat>\nusing namespace std;\n\nint main(){\n\tint n, ans;\n\tint next, last, now, start;\n\tdouble vx0, vx1, vy0, vy1, a;\n\tdouble arg, tmp;\n\tdouble px[101], py[101];\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tans = n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf,%lf\", &px[i], &py[i]);\n\t\t}\n\t\tpx[100] = -999999;\n\t\tpy[100] = -999999;\n\t\t// select top point\n\t\tlast = now = next = 100;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (py[i] > py[last]) {\n\t\t\t\tlast = i;\n\t\t\t}\n\t\t}\n\t\t//cout << \"last: \" << last << endl;\n\t\tans--;\n\t\t// select 2nd point by getting lowest a in y = ax + b\n\t\ttmp = DBL_MAX;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == last) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ta = fabs(py[i] - py[last]); \n\t\t\tif(fabs(tmp*(px[i] - px[last])) > a){\n\t\t\t\ttmp = a/(px[i] - px[last]);\n\t\t\t\tnow = i;\n\t\t\t}\n\t\t}\n\t\tans--;\n\t\t// connect dots\n\t\tstart = last;\n\t\twhile (start != now) {\n\t\t\t// determine next point\n\t\t\targ = 10000;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif(i == now || i == last){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvx0 = px[i] - px[now];\n\t\t\t\tvy0 = py[i] - py[now];\n\t\t\t\tvx1 = px[last] - px[now];\n\t\t\t\tvy1 = px[last] - py[now];\n\n\t\t\t\ttmp = (vx0*vx1 + vy0*vy1) / (sqrt(vx0*vx0 + vy0*vy0) * sqrt(vx1*vx1 + vy1*vy1));\n\t\t\t\tif (arg > tmp) {\n\t\t\t\t\targ = tmp;\n\t\t\t\t\tnext = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << next << endl;\n\t\t\tlast = now;\n\t\t\tnow = next;\n\t\t\tans--;\n\t\t}\n\t\tans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P cent;double r;}; //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//?????????????????? verified\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble distance_l_p(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//????????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_point(P center, double r, L line){\n    if( distance_l_p(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nbool isPointInsidePolygon(vector<L> side,P p){\n    int c=0, sideSum=side.size();\n    \n    rep(i,sideSum){\n        if( cross(side[i].p2-side[i].p1,p-side[i].p1)>0 ) c++;\n    }\n    return !(c%sideSum);\n}\n\n#define MAX_N 100\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(P* ps, int n){\n    sort(ps,ps+n, cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????????????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint N;\nP ps[MAX_N];\n\n\nint main(){\n    while(cin>>N&&N){\n        rep(i,N){\n            char ch;\n            cin>>ps[i].x>>ch>>ps[i].y;\n        }\n        vector<P> res = convex_hull(ps, N);\n        cout<<N-res.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LB;\ntypedef pair<LB,LB> PBB;\ntypedef vector<PBB > VPBB;\ntypedef map<LB,LL> MDI;\ntypedef MDI::iterator MDII;\n\n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n\n\nint main(){\n\n\tLL n;\n\tLL max;\n\tLL ans;\n\tLL cnt;\n\tLB x,y;\n\tLB hx,hy,ix,iy,jx,jy;\n\tchar gav;\n\tVPBB pin;\n\tMDI point;\n\n\twhile(1){\n\n\t\t/*入力*/\n\t\tcin>>n;\n\n\t\t/*終了*/\n\t\tif(n==0) break;\n\n\t\t/*準備*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>gav>>y;\n\t\t\tpin.PUSH(PBB(x,y));\n\t\t}\n\t\tans=0;\n\n\t\t/*端の点を決める*/\n\t\tmax=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(pin[max].second<pin[i].second) max=i;\n\t\t\telse if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n\t\t}\n\n\t\t/*基準点との角度から順番を付ける*/\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i!=max){\n\t\t\t\tpoint.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n\t\t\t}\n\t\t}\n\t\tpoint.insert(MDIVT(-1*INF,max));\n\n\t\t/*3点の角度から凸包を求めていく*/\n\t\tMDII iH=point.begin(),iI=point.begin(),iJ=point.begin();\n\t\tiI++,iJ++,iJ++;\n\t\tcnt=0;\n\t\twhile(iJ!=point.end()){\n\t\t\thx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n\t\t\tix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n\t\t\tjx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n\n\t\t\t/*cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug*/\n\n\t\t\tif((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0){\n\t\t\t\tiH++,iI++,iJ++;\n\t\t\t\twhile(cnt--) iH++;\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tiI++;\n\t\t\t\tiJ++;\n\t\t\t\tcnt++;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\t/*出力*/\n\t\tcout<<ans<<endl;\n\n\t\t/*初期化*/\n\t\tpin.clear();\n\t\tpoint.clear();\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct node {\n  float x;\n  float y;\n  float t;\n};\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n\n    vector<node> vec(n);\n    for (int i = 0; i < n; ++i)\n      scanf(\"%f,%f\", &vec[i].x, &vec[i].y);\n\n    sort(vec.begin(), vec.end(),\n         [](node const &l, node const &r) { return l.x < r.x; });\n\n    for_each(vec.begin(), vec.end(), [&](node &ele) {\n      float x = ele.x - vec[0].x;\n      float y = ele.y - vec[0].y;\n      ele.t = y / sqrt(x * x + y * y);\n    });\n\n    sort(++vec.begin(), vec.end(),\n         [](node const &l, node const &r) { return l.t > r.t; });\n\n    vector<node> vec2;\n    for (auto &ele : vec) {\n      while (2 <= vec2.size()) {\n        auto itr1 = vec2.end() - 2;\n        auto itr2 = vec2.end() - 1;\n        float x1 = itr2->x - itr1->x;\n        float y1 = itr2->y - itr1->y;\n        float x2 = ele.x - itr1->x;\n        float y2 = ele.y - itr1->y;\n        if (x1 * y2 - y1 * x2 <= 0)\n          break;\n        vec2.erase(vec2.end() - 1);\n      }\n      vec2.push_back(ele);\n    }\n\n    cout << vec.size() - vec2.size() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\nnamespace FP {\n    bool isZero(double x) {\n        return (abs(x) <= EPS);\n    }\n};\n\nstruct Point {\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    Point(const Point &o) : x(o.x), y(o.y) {}\n    string to_s() {\n        ostringstream os;\n        os << \"(\" << x << \",\" << y << \")\";\n        return os.str();\n    }\n    bool operator<(const Point &o) const {\n        return x == o.x ? y < o.y : x < o.x;\n    }\n    bool operator==(const Point &o) const {\n        return x == o.x && y == o.y;\n    }\n    Point operator+(const Point &o) const {\n        return Point(x+o.x, y+o.y);\n    }\n    Point operator-(const Point &o) const {\n        return Point(x-o.x, y-o.y);\n    }\n    Point operator*(const double m) const {\n        return Point(x*m, y*m);\n    }\n    Point operator/(const double d) const {\n        return Point(x/d, y/d);\n    }\n    // 外積\n    double cross(const Point &o) const {\n        return x * o.y - y * o.x;\n    }\n    // 内積\n    double dot(const Point &o) const {\n        return x * o.x + y * o.y;\n    }\n    // ベクトルがx軸となす角\n    double atan() const {\n        return atan2(y, x);\n    }\n    // ベクトルの長さの二乗\n    double norm() const {\n        return dot(*this);\n    }\n};\n\nstruct Line {\n    double a, b, c;\n    Line(double a=0, double b=0, double c=0) :\n        a(a), b(b), c(c) {}\n    Point intersectionPoint(const Line &l) const {\n        double d = a * l.b - l.a * b;\n        if (!intersects(l)) {\n            throw string(\"The 2 Lines are parallel\");\n        }\n        double x = (b * l.c - l.b * c) / d;\n        double y = (l.a * c - a * l.c) / d;\n        return Point(x, y);\n    }\n    bool intersects(const Line &l) const {\n        return !FP::isZero(a * l.b - l.a * b);\n    }\n    string to_s() {\n        ostringstream os;\n        os << a << ' ' << b << ' ' << c;\n        return os.str();\n    }\n    static Line fromPoints(const Point &a, const Point &b) {\n        double dx = b.x - a.x;\n        double dy = b.y - a.y;\n        return Line(dy, -dx, dx * a.y - dy * a.x);\n    }\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n        return fromPoints(Point(x1, y1), Point(x2, y2));\n    }\n};\n\nstruct LineSegment {\n    Point start, end;\n    LineSegment(const Point &start, const Point &end) : start(start), end(end) {}\n    LineSegment(double x1, double y1, double x2, double y2) : start(Point(x1, y1)), end(Point(x2, y2)) {}\n    string to_s() {\n        ostringstream os;\n        os << '(' << start.x << ',' << start.y << ')' << '-' << '(' << end.x << ',' << end.y << ')' << endl;\n        return os.str();\n    }\n    Line toLine() const {\n        return Line::fromPoints(start, end);\n    }\n    bool intersects(const Line &l) const {\n        double t1 = l.a * start.x + l.b * start.y + l.c;\n        double t2 = l.a * end.x + l.b * end.y + l.c;\n        return t1 * t2 <= 0;\n    }\n    bool intersects(const LineSegment &s) const {\n        return intersects(s.toLine()) && s.intersects(toLine());\n    }\n    Line perpendicularBisector() const {\n        Point p1 = (start + end) / 2;\n        Point p2;\n        p2.x = -(end - p1).y;\n        p2.y = (end - p1).x;\n        p2 = p2 + p1;\n        return Line::fromPoints(p1, p2);\n    }\n};\n\nstruct Polygon {\n    vector<Point> vertex;\n    Polygon(){}\n    Polygon(vector<Point> vertex) : vertex(vertex) {}\n    void addVertex(Point v) {\n        vertex.push_back(v);\n    }\n    Point next(int v) const {\n        return vertex[(v+1) % vertex.size()];\n    }\n    Point prev(int v) const {\n        return vertex[(v-1+vertex.size()) % vertex.size()];\n    }\n    int size() const {\n        return vertex.size();\n    }\n    const double area() const {\n        double ret = 0;\n        for (int i = 0; i < vertex.size(); i++) {\n            ret += vertex[i].cross(next(i));\n        }\n        return abs(ret)*0.5;\n    }\n};\n\nconst int CCW = 1;\nconst int CW  = -1;\nconst int ON_SAME_LINE = 0;\nint ccw(Point a, Point b, Point c) {\n    b = b-a; c = c-a;\n    if (b.cross(c) > EPS) return +1;\n    if (b.cross(c) < -EPS) return -1;\n    return 0;\n}\n\nvector<Point> convexHull(vector<Point> ps) {\n    int n = ps.size();\n    sort(ps.begin(), ps.end());\n\n    vector<Point> upper;\n    upper.push_back(ps[0]);\n    upper.push_back(ps[1]);\n\n    for (int i = 2; i < n; i++) {\n        upper.push_back(ps[i]);\n        int j = upper.size();\n        while (j > 2 && ccw(upper[j-3], upper[j-2], upper[j-1]) == CCW) {\n            upper.erase(upper.begin()+j-2);\n            j = upper.size();\n        }\n    }\n\n    vector<Point> lower;\n    lower.push_back(ps[n-1]);\n    lower.push_back(ps[n-2]);\n    \n    for (int i = n-3; i >= 0; i--) {\n        lower.push_back(ps[i]);\n        int j = lower.size();\n        while (j > 2 && ccw(lower[j-3], lower[j-2], lower[j-1]) == CCW) {\n            lower.erase(lower.begin()+j-2);\n            j = lower.size();\n        }\n    }\n\n    vector<Point> hull;\n    for (int i = 0; i < upper.size(); i++) hull.push_back(upper[i]);\n    for (int i = 0; i < lower.size(); i++) hull.push_back(lower[i]);\n    sort(hull.begin(), hull.end());\n    hull.erase(unique(hull.begin(), hull.end()), hull.end());\n    return hull;\n}\n\nint main() {\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        vector<Point> ps;\n        for (int i = 0; i < n; i++) {\n            char d; double x, y; cin >> x >> d >> y;\n            ps.push_back(Point(x, y));\n        }\n        cout << ps.size() - convexHull(ps).size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\nstruct Point {\n\tdouble x, y;\n\tPoint(const double &argx = 0, const double &argy = 0) :x(argx), y(argy) {};\n\tPoint operator+(const Point &other) const { return Point(x + other.x, y + other.y); }\n\tPoint operator-(const Point &other) const { return Point(x - other.x, y - other.y); }\n\tPoint operator-() const { return Point(-x, -y); }\n\tbool operator>(const Point &other) const { return (y > other.y) || (y == other.y && x > other.x); }\n\tbool operator<(const Point &other) const { return (y < other.y) || (y == other.y && x < other.x); }\n\tbool operator==(const Point &other) const { return (y == other.y) && (x == other.x); }\n\tvoid inspect() const { std::cout << \"(\" << x << \",\" << y << \")\" << \"\\n\"; }\n};\nstruct Vector {\n\tVector(const int &x = 0, const int &y = 0) :origin(0, 0), vector(x, y) {};\n\tVector(const Point &p1, const Point &p2) :origin(p1), vector(p2 - p1) {};\n\tVector operator+(const Vector &other) const { return Vector(origin, origin + vector + other.vector); }\n\tVector operator-(const Vector &other) const { return Vector(origin, origin + vector - other.vector); }\n\tVector operator-() const { return Vector(origin, -vector); }\n\tdouble operator*(const Vector &other) const { return vector.x * other.vector.x + vector.y * other.vector.y; }\n\tdouble cross(const Vector &other) const { return vector.x * other.vector.y - vector.y * other.vector.x; }\n\tvoid inspect() const { vector.inspect(); }\n\tPoint origin, vector;\n};\ntemplate <class T>\nvoid sort(std::vector<T> &vector, const int &left, const int &right) {\n\tif (left < right) {\n\t\tauto pivot = vector.at(left + (right - left) / 2);\n\t\tauto l = left, r = right;\n\t\twhile (l < r) {\n\t\t\twhile (pivot < vector.at(l))++l;\n\t\t\twhile (pivot > vector.at(r))--r;\n\t\t\tif (l < r) {\n\t\t\t\tauto temp = vector.at(l);\n\t\t\t\tvector.at(l) = vector.at(r); vector.at(r) = temp;\n\t\t\t\t++l; --r;\n\t\t\t}\n\t\t}\n\t\tsort(vector, left, r); sort(vector, r + 1, right);\n\t}\n}\nint main() {\n\tconstexpr double LES = 0.0000000001;\n\tint n;\n\tstd::cin >> n;\n\twhile (n != 0) {\n\t\tstd::vector<Point> point(n);\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tstd::scanf(\"%lf,%lf\", &x, &y);\n\t\t\tpoint.at(i) = Point(x, y);\n\t\t}\n\t\tsort(point, 0, n - 1);\n\t\tauto func = [](const Point &p1, const Point &p2, const Point &p3) {\n\t\t\treturn Vector(p2, p1).cross(Vector(p2, p3));\n\t\t};\n\t\tint sum = 0;\n\t\tstd::vector<Point> stack(n + 2);\n\t\tstack.at(0) = point.at(0); stack.at(1) = point.at(0);\n\t\tauto idx = 1;\n\t\tfor (auto &p : point) {\n\t\t\twhile (func(stack.at(idx - 1), stack.at(idx), p) > LES) {\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tstack.at(++idx) = p;\n\t\t}\n\t\tsum += idx - 1;\n\t\tidx = 1;\n\t\tfor (auto &p : point) {\n\t\t\twhile (func(stack.at(idx - 1), stack.at(idx), p) < -LES) {\n\t\t\t\t--idx;\n\t\t\t}\n\t\t\tstack.at(++idx) = p;\n\t\t}\n\t\tsum += idx - 1;\n\t\tstd::cout << n - sum + 2 << std::endl;\n\t\tstd::cin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add (double a, double b) {\n\tif (abs(a + b) < EPS * (abs(a) + abs(b))) {\n\t\treturn 0;\n\t}\n\treturn a + b;\n}\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP (double x, double y) : x(x), y(y) {\n\t}\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d) {\n\t\treturn P(x * d, y * d);\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\tdouble det(P p) {\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\nbool cmp_x(const P& p, const P& q) {\n\tif(p.x != q.x) {\n\t\treturn p.x < q.x;\n\t}\n\treturn p.y < q.y;\n}\n\nvector<P> convex_hell(P* ps, int n) {\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;\n\tvector<P> qs(n * 2);\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tchar c;\n\t\tP ps[110];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> ps[i].x >> c >> ps[i].y;\n\t\t}\n\t\tvector<P> qs = convex_hell(ps, n);\n\t\tcout << n - qs.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 2???????????????????????????????±???????\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2???????????????????????????????±???????\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\nvector<P> convexHull(vector<P> ps) {\n    int n = ps.size();\n    // sort(ps.begin(),ps.end(), cmp_y);\n    sort(ps.begin(),ps.end());\n    int k = 0;\n    vector<P> convex(n*2);\n    for(int i=0; i<n; i++) {\n        while (k >= 2 && ccw(convex[k-2], convex[k-1], ps[i]) == -1 ) k--;\n        convex[ k++ ] = ps[i];\n    }\n    for(int i=n-2, t=k; i>=0; i--) {\n        while (k > t && ccw(convex[k-2], convex[k-1], ps[i]) == -1 ) k--;\n        convex[ k++ ] = ps[i];\n    }\n    convex.resize(k-1);\n    return convex;\n}\n\nint main() {\n    int n;\n    while(cin >> n) {\n        if(n == 0) break;\n        vector<P> ps;\n        P a;\n        rep(i,0,n) {\n            scanf(\"%lf,%lf\", &a.X, &a.Y);\n            ps.pb(a);\n        }\n        vector<P> ans = convexHull(ps);\n        cout << n - ans.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <complex>\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble stod (string str )\n{\n\tstringstream ss (str );\n\tdouble res;\n\n\tss >> res;\n\n\treturn res;\n}\n\nbool cmp (P a, P b )\n{\n\tif (a.real() != b.real() )\n\t\treturn a.real() < b.real();\n\n\treturn a.imag() > b.imag();\n}\n\n// OÏ (cross product) : a~b = |a||b|sinÆ\ndouble cross(P a, P b )\n{\n\tdouble res = a.real() * b.imag() - a.imag() * b.real();\n\n  return res;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.rubber\", \"r\", stdin );\n\tint n;\n\twhile (cin >> n, n ){\n\n\t\tif (n == 3 ){\n\t\t\tcout << n << endl;\n\t\t\treturn 0;\n\t\t} // end if\n\n\t\tvector <P> pos (n);\n\t\tfor (int i = 0; i < n; i++ ){\n\t\t\tstring str = \"\";\n\t\t\tcin >> str;\n\t\t\tdouble x = stod (str.substr (0, str.find (',') ) );\n\t\t\tdouble y = stod (str.substr (str.find (',') + 1) );\n\t\t\tP p; p.real() = x; p.imag() = y;\n\t\t\tpos[i] = p;\n\t\t} // end for\n\n\t\t// Åà¶[Ì_AxÀWª¯¶ÈçyÀWªå«¢_ÉÈéæ¤É\\[g\n\t\tsort (pos.begin(), pos.end(), cmp );\n\t\t\n\t\t// ã¼ªÌTõ\n\t\tvector <P> U;\n\t\tU.push_back (pos[0] ); U.push_back (pos[1] );\n\t\tfor (int i = 2; i < n; i++ ){\n\t\t\tU.push_back (pos[i] );\n\t\t\tif (U.size() >= 3 ){\n\t\t\t\tint last  = U.size() - 1;\n\t\t\t\tint mid   = U.size() - 2;\n\t\t\t\tint first = U.size() - 3;\n\t\t\t\t// ÅãÌ_ªEñèÈç½àµÈ¢\n\t\t\t\tif (cross (U[mid] - U[first], U[last] - U[first] ) > 0. ){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t// ÅãÌ_ª¼üãÉÚÁÄ¢éÜ½Í¶ñèÉ é\n\t\t\t\t}else{\n\t\t\t\t\tvector <P>::iterator it = U.begin();\n\t\t\t\t\tfor (; it != U.end(); ++it ){\n\t\t\t\t\t\tif ((*it) == U[mid] ){\n\t\t\t\t\t\t\tU.erase (it );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end for\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end for\n\n\t\t// º¼ªÌTõ\n\t\tvector <P> D;\n\t\tD.push_back (pos[n-1] ); D.push_back (pos[n-2] );\n\t\tfor (int i = n - 3; i >= 0 ; i-- ){\n\t\t\tD.push_back (pos[i] );\n\t\t\tif (D.size() >= 3 ){\n\t\t\t\tint last  = D.size() - 1;\n\t\t\t\tint mid   = D.size() - 2;\n\t\t\t\tint first = D.size() - 3;\n\t\t\t\t// ÅãÌ_ªEñèÈç½àµÈ¢\n\t\t\t\tif (cross (D[mid] - D[first], D[last] - D[first] ) > 0. ){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t// ÅãÌ_ª¼üãÉÚÁÄ¢éÜ½Í¶ñèÉ é\n\t\t\t\t}else{\n\t\t\t\t\tvector <P>::iterator jt = D.begin();\n\t\t\t\t\tfor (; jt != D.end(); ++jt ){\n\t\t\t\t\t\tif ((*jt) == D[mid] ){\n\t\t\t\t\t\t\tD.erase (jt );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end for\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end for\n\n\t\t// ã¼ªÆº¼ªð}[W\n\t\tvector <P> R;\n\t\tfor (int i = 0; i < U.size(); i++ )\n\t\t\tR.push_back (U[i] );\n\t\tfor (int i = 0; i < D.size(); i++ ){\n\t\t\tbool found = false;\n\t\t\tfor (int j = 0; j < R.size(); j++ ){\n\t\t\t\tif (EQ (R[j], U[i] ) ){\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t\tif (found ){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tR.push_back (D[i] );\n\t\t\t} // end if\n\t\t} // end for\n\n\t\tcout << ( pos.size() - R.size() - 1 ) << endl;\n\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\n#include<vector>\n#include<algorithm>\n\n#define pb push_back\n#define sz size()\nusing namespace std;\n\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\nvector<P> convex_hull(vector<P> v){\n  int n = v.sz, k = 0;\n  sort(v.begin(),v.end());\n  vector<P> r(2*n);\n  for(int i=0;i<n;i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= 0)k--;\n    r[k++] = v[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= 0)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nint main(){\n  int n;\n  vector<P> v;\n  P tmp;\n\n  while(scanf(\"%d\",&n),n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      scanf(\"%lf,%lf\",&real(tmp),&imag(tmp));\n      v.pb(tmp);\n    }\n\n    printf(\"%d\\n\",n-(int)convex_hull(v).sz);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n \nusing namespace std;\n \ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef multimap<double,int> MDI;\ntypedef MDI::iterator MDII;\n \n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n \n \nint main(){\n \n    int n;\n    int max;\n    int ans;\n    int cnt;\n    double x,y;\n    double hx,hy,ix,iy,jx,jy;\n    char gav;\n    VPBB pin;\n    MDI point;\n \n    while(1){\n \n        /*入力*/\n        cin>>n;\n \n        /*終了*/\n        if(n==0) break;\n \n        /*準備*/\n        for(int i=0;i<n;i++){\n            cin>>x>>gav>>y;\n            pin.PUSH(PBB(x,y));\n        }\n        ans=0;\n \n        /*端の点を決める*/\n        max=0;\n        for(int i=1;i<n;i++){\n            if(pin[max].second<pin[i].second) max=i;\n            else if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n        }\n \n        /*基準点との角度から順番を付ける*/\n        for(int i=0;i<n;i++){\n            if(i!=max){\n\t\t\t\tif(pin[i].second!=pin[max].second) point.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n\t\t\t\telse point.insert(MDIVT(-1*INF+100,i));\n            }\n        }\n        point.insert(MDIVT(-1*INF,max));\n \n        /*3点の角度から凸包を求めていく*/\n        MDII iH=point.begin(),iI=point.begin(),iJ=point.begin();\n        iI++,iJ++,iJ++;\n        cnt=0;\n        while(iJ!=point.end()){\n            hx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n            ix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n            jx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n \n            /*cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug*/\n \n            if((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0){\n                iH++,iI++,iJ++;\n                while(cnt--) iH++;\n                cnt=0;\n            }\n            else{\n                iI++;\n                iJ++;\n                cnt++;\n                ans++;\n            }\n        }\n \n        /*出力*/\n        cout<<ans<<endl;\n \n        /*初期化*/\n        pin.clear();\n        point.clear();\n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double PI = 3.14159;\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tvector<double> x; x.reserve(100);\n\t\tvector<double> y; y.reserve(100);\n\t\tdouble tmp_x, tmp_y;\n\t\tchar dummy;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tcin >> tmp_x >> dummy >> tmp_y;\n\t\t\tx.push_back(tmp_x); y.push_back(tmp_y);\n\t\t}\n\t\t\n\t\tdouble min_y = y[0];\n\t\tint min_y_index = 0;\n\t\tfor (int i=1; i<n; i++) {\n\t\t\tif (min_y > y[i]) { min_y = y[i]; min_y_index = i; }\n\t\t}\n\t\t\n\t\tint curr_index = min_y_index;\n\t\tint circumference_points = 0;\n\t\tdouble curr_deg = 0.0;\n\t\tdo {\n\t\t\tdouble min_deg = PI;\n\t\t\tdouble min_deg_index;\n\t\t\tdouble tmp_deg;\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tif (i == curr_index) continue;\n\t\t\t\ttmp_deg = atan2( y[i] - y[curr_index], x[i] - x[curr_index] );\n\t\t\t\ttmp_deg -= curr_deg;\n\t\t\t\tif (tmp_deg < 0) tmp_deg += 2*PI;\n\t\t\t\tif (min_deg > tmp_deg) {\n\t\t\t\t\tmin_deg = tmp_deg; min_deg_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr_deg += min_deg;\n\t\t\tcurr_index = min_deg_index;\n\t\t\tcircumference_points++;\n\t\t\t// cout << min_deg_index << \" \" << curr_deg * 180 / PI << endl;\n\t\t} while (curr_index != min_y_index);\n\t\t\n\t\tcout << n - circumference_points << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<complex>\n\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\nconst double EPS = 1e-10;\n\nnamespace std{\n\tbool operator < (const P& a, const P& b) {\n\t\treturn EQ(real(a) , real(b)) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tdouble cross(const P& a, const P& b) {\n\t\treturn imag(conj(a)*b);\n\t}\n\tdouble dot(const P& a, const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n}\n\n//ツ点ツづ個進ツ行ツ陛サツ古シ\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//ツ禿環陛ッ\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  int n;\n\tdouble a,b;\n\tvector<P> points;\n\twhile(true){\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tpoints.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tpoints.push_back(P(a,b));\n\t\t}\n\n\t\tvector<P> hull = convex_hull(points);\n\t\tcout<<n-hull.size()<<endl;\n\t}\n\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#define EPS 1e-10\nusing namespace std;\n\ndouble add(double a,double b){\n\tif(abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\n\nstruct vect{\n\tdouble x,y;\n\tvect(){}\n\tvect(double x,double y) : x(x),y(y){}\n\tvect operator + (vect v){\n\t\treturn vect(add(x,v.x),add(y,v.y));\n\t}\n\tvect operator - (vect v){\n\t\treturn vect(add(x,-v.x),add(y,-v.y));\n\t}\n\tvect operator * (double d){\n\t\treturn vect(x * d,y * d);\n\t}\n\tdouble dot(vect v){\n\t\treturn add(x * v.x,y * v.y);\n\t}\n\tdouble det(vect v){\n\t\treturn add(x * v.y,-y * v.x);\n\t}\n};\n\nbool comp_vect(const vect& v1,const vect& v2){\n\tif(v1.x != v2.x) return v1.x < v2.x;\n\treturn v1.y < v2.y;\n}\n\nvector<vect> convex(vect* ps,int n){\n\tsort(ps,ps + n,comp_vect);\n\tint k = 0;\n\tvector<vect> qs(n * 2);\n\tfor(int i = 0;i < n;i++){\n\t\twhile(k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0.0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i = n - 2,t = k;i >= 0;i--){\n\t\twhile(k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0.0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvect ps[100];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf,%lf\",&x,&y);\n\t\t\tps[i] = vect(x,y);\n\t\t}\n\t\tvector<vect> conv = convex(ps,n);\n\t\tcout << n - conv.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<point> pp(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\\n\",&pp[i].real(),&pp[i].imag());\n\t\t}\n\t\tcout << n-convex_hull(pp).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef complex<double> Point;\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point pos,Point dir):pos(pos),dir(dir){}\n};\n\nnamespace std\n{\n\tbool operator<(const Point& lhs,const Point& rhs)\n\t{\n\t\tif(real(lhs)==real(rhs))\n\t\t\treturn imag(lhs)<imag(rhs);\n\t\telse\n\t\t\treturn real(lhs)<real(rhs);\n\t}\n}\n\nconst double EPS=1.0e-10;\n\ninline int Signum(double x)\n{\n\treturn abs(x)<EPS?0:x>0?1:-1;\n}\n\ndouble Dot(Point p1,Point p2)\n{\n\treturn real(conj(p1)*p2);\n}\n\ndouble Cross(Point p1,Point p2)\n{\n\treturn imag(conj(p1)*p2);\n}\n\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tdouble sign=Signum(Cross(d1,d2));\n\t\n\tif(sign)\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nvoid ConvexHull(const vector<Point> _points,vector<Point>& vertices)\n{\n\tvector<Point> points(_points);\n\tvertices.clear();\n\t\n\tsort(allof(points));\n\t\n\tvector<Point> lv,uv;\n\trep(i,points.size()){\n\t\tPoint p=points[i];\n\t\tif(lv.size()<2){\n\t\t\tlv.push_back(p);\n\t\t\tcontinue;\n\t\t}\n\t\tPoint p0=lv[lv.size()-2];\n\t\tPoint p1=lv[lv.size()-1];\n\t\tif(CCW(p0,p1,p)==1)\n\t\t\tlv.push_back(p);\n\t\telse{\n\t\t\tlv.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\trep(i,points.size()){\n\t\tPoint p=points[points.size()-1-i];\n\t\tif(uv.size()<2){\n\t\t\tuv.push_back(p);\n\t\t\tcontinue;\n\t\t}\n\t\tPoint p0=uv[uv.size()-2];\n\t\tPoint p1=uv[uv.size()-1];\n\t\tif(CCW(p0,p1,p)==1)\n\t\t\tuv.push_back(p);\n\t\telse{\n\t\t\tuv.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\trep(i,lv.size()-1)\n\t\tvertices.push_back(lv[i]);\n\trep(i,uv.size()-1)\n\t\tvertices.push_back(uv[i]);\n\t//puts(\"lv\");\n\t//rep(i,lv.size())\n\t//\tcout<<real(lv[i])<<\" \"<<imag(lv[i])<<endl;\n\t//puts(\"uv\");\n\t//rep(i,uv.size())\n\t//\tcout<<real(uv[i])<<\" \"<<imag(uv[i])<<endl;\n\t//puts(\"finish\");\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Point> points(n);\n\t\trep(i,n)\n\t\t\tscanf(\"%lf,%lf\",&real(points[i]),&imag(points[i]));\n\t\tvector<Point> vertices;\n\t\tConvexHull(points,vertices);\n\t\t//rep(i,vertices.size())\n\t\t//\tcout<<real(vertices[i])<<\" \"<<imag(vertices[i])<<endl;\n\t\tcout<<points.size()-vertices.size()<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x;\n\tdouble y;\n};\n\nPoint pointStack[101];\nconst double esp = 1e-10;\n\nbool cmpPoint(Point p1, Point p2) {\n\tif (fabs(p1.y-p2.y) > esp) {\n\t\treturn p1.y < p2.y;\n\t}\n\telse {\n\t\treturn p1.x < p2.x;\n\t}\n}\n\nbool cmpAngle(Point p1, Point p2) {\n\tdouble k1, k2;\n\n\tk1 = atan2(p1.y - pointStack[0].y, p1.x - pointStack[0].x);\n\tk2 = atan2(p2.y - pointStack[0].y, p2.x - pointStack[0].x);\n\tif (fabs(k1-k2) > esp) {\n\t\treturn k1 < k2;\n\t}\n\telse {\n\t\tif (p1.x > 0 || p2.x > 0) {\n\t\t\treturn p1.x < p2.x;\n\t\t}\n\t\treturn p1.x > p2.x;\n\t}\n}\n\ndouble Cross(Point p0, Point p1, Point p2) {\n\tdouble result;\n\n\tresult = (p2.x - p0.x) * (p1.y - p0.y) - (p1.x - p0.x) * (p2.y - p0.y);\n\tif (fabs(result) < esp) {\n\t\treturn 0;\n\t}\n\telse if (result > esp) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n}\n\nint main(void) {\n\tint n, i, top;\n\tPoint pointSet[101];\n\tchar c;\n\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(pointSet, 0, sizeof(pointSet));\n\t\tmemset(pointStack, 0, sizeof(pointStack));\t\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tcin >> pointSet[i].x >> c >> pointSet[i].y;\n\t\t}\n\n\t\tsort(pointSet, pointSet + n, cmpPoint);\n\t\tpointStack[0] = pointSet[0];\n\n\t\tsort(pointSet + 1, pointSet + n, cmpAngle);\n\t\tpointStack[1] = pointSet[1];\n\t\tpointStack[2] = pointSet[2];\n\t\tpointSet[n] = pointSet[0];\n\n\t\ttop = 2;\n\t\tfor (i = 3; i <= n; i++) {\n\t\t\twhile (top > 1 && (Cross(pointStack[top - 1], pointStack[top], pointSet[i]) >= 0)) {\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\tpointStack[++top] = pointSet[i];\n\t\t}\n\n\t\tcout <<n - top << endl;\n\t}\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef pair<double, double> P;\n\ndouble cross_product(P p1, P p2, P p3)\n{\n\tP p[2];\n\tp[0].first = p2.first - p1.first;\n\tp[0].second = p2.second - p1.second;\n\tp[1].first = p3.first - p1.first;\n\tp[1].second = p3.second - p1.second;\n\treturn(p[0].first * p[1].second - p[1].first * p[0].second);\n}\n\nvoid solve()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tvector<P> Vec(N);\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tscanf(\"%lf,%lf\", &Vec[i].first, &Vec[i].second);\n\t\t}\n\t\tdouble min_x = Vec[0].first;\n\t\tint index = 0;\n\t\tfor(int i = 1; i < N; ++i)\n\t\t{\n\t\t\tif(min_x > Vec[i].first)\n\t\t\t{\n\t\t\t\tmin_x = Vec[i].first;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tvector<bool> used(N);\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tused[i] = false;\n\t\t}\n\t\tused[index] = true;\n\t\tint end = index;\n\t\twhile(true)\n\t\t{\n\t\t\tfor(int i = 0; i < N; ++i)\n\t\t\t{\n\t\t\t\tif(index == i)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t\t{\n\t\t\t\t\tif(index == j || i == j)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(cross_product(Vec[index], Vec[i], Vec[j]) <= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\n\t\t\t\t{\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end == index)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tif(!used[i])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nstruct P{\n\tdouble x,y;\n\tP(double x,double y) : x(x) , y(y) {}\n\tP(){}\n};\nbool operator <(const P &a,const P &b){ return a.x != b.x ? a.x < b.x : a.y < b.y; }\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ndouble fix(double p){\n\twhile( p < EPS ) p += PI;\n\treturn p;\n}\n\n\nvector<P> convex_hull( vector<P> g){\n\tsort(g.begin(),g.end());\n\tvector<P> r;\n\tint idx = 0;\n\tdouble deg = -PI/2;\n\tdo{\n\t\tr.push_back(g[idx]);\n\t\tint best = 0;\n\t\tdouble value = 1e10;\n\t\t\n\t\tfor(int i = 0 ; i < g.size() ; i++){\n\t\t\tif( i != idx){\n\t\t\t\tdouble next = fix( atan2(g[i].y-g[idx].y,g[i].x-g[idx].x) - deg );\n\t\t\t\tif( value > next ){\n\t\t\t\t\tvalue = next;\n\t\t\t\t\tbest = i;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tdeg = atan2(g[best].y-g[idx].y,g[best].x-g[idx].x);\n\t\tidx = best;\n\t}while(idx != 0);\n\n\treturn r;\n}\n\n\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<P> g(n);\n\t\tfor(int i = 0 ; i < n ; i++) scanf(\"%lf,%lf\",&g[i].x,&g[i].y);\n\t\tcout << n - convex_hull(g).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint a,s,d,j,i,k,lo,cc[10001],ss,sss;\ndouble f[1001][2],g,h,z,x,c,v,b,q,w;\nint main(void)\n{\n\twhile(1){\n\t\tg=-10000.0;c=0.0;v=0.0;\n\t\tscanf(\"%d\",&a);\n\t\tif(a==0) break;\n\t\td=a-1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tscanf(\"%lf,%lf\",&f[i][0],&f[i][1]);\n\t\t\tcc[i]=0;\n\t\t\tif(g<f[i][0]){\n\t\t\t\tg=f[i][0]; h=f[i][1];\n\t\t\t\tz=g-1001.0; x=h;\n\t\t\t\ts=i;\n\t\t\t}\n\t\t}\n\t\tss=-1;\n\t\tcc[s]=1;\n\t\tq=g;\n\t\tw=h;\n\t/*\tfor(i=0;i<a;i++) printf(\"%d:%d |\",i,cc[i]);\n\t\tprintf(\"\\n\");*/\n\t\twhile(1){\n\t\t\tsss=s;\n\t\t\tfor(i=0;i<a;i++){\n\t\t\t\tif(sss!=i&&ss!=i){\n\t\t\t\t\tc=(((g-z)*(g-f[i][0])+(h-x)*(h-f[i][1]))/(sqrt((g-z)*(g-z)+(g-f[i][0])*(g-f[i][0]))*sqrt((h-x)*(h-x)+(h-f[i][1])*(h-f[i][1]))));\n\t\t\t\t\tc=acos(c);\n\t\t\t\t\tif(v<c){\n\t\t\t\t\t\tv=c;\n\t\t\t\t\t\ts=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(v==c){\n\t\t\t\t\t\tif(abs(f[i][0]-g)<abs(f[s][0]-g)) s=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tss=sss;\n\t\t\tcc[s]=1;\n\t\t\t/*for(i=0;i<a;i++) printf(\"%d:%d |\",i,cc[i]);\n\t\t\tprintf(\"\\n\");*/\n\t\t\tz=g; x=h;\n\t\t\tg=f[s][0]; h=f[s][1];\n\t//\t\tprintf(\"%lf %d %d\\n\",v,s,lo);\n\t\t\tlo=s;\n\t\t\td--;\n\t\t\tif(d==0) break;\n\t\t\tif(g==q&&h==w) break;\n\t\t\tv=0.0;\n\t\t\tc=0.0;\n\t\t}\n\t\tprintf(\"%d\\n\",d);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<climits>\n#include<cfloat>\n#include<cmath>\n#include<map>\n#include<complex>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nusing namespace std;\n\n#define EPS 1e-10\n#define DBL(x) ((x)*(x))\n\nusing std::complex;\ntypedef complex<double> P; /* _ */\n\nstatic inline bool eq(const P &a, const P &b){\n  return abs(a-b) < EPS;\n}\n/* àÏ */\nstatic inline double inp(const P &a, const P &b){\n  return (conj(a)*b).real();\n}\n/* OÏ */\nstatic inline double outp(const P &a, const P &b){\n  return (conj(a)*b).imag();\n}\n\nclass Line{\npublic:\n  P p; /* position */\n  P d; /* direction */\n  Line(){}\n  Line(P pos, P dir){p=pos; d=dir/abs(dir);}\n};\n\n/* _Æûü©ç */\nLine LineDirect(P pos, P dir){\n  return Line(pos, dir);\n}\n/* 2_©ç */\nLine LinePos(P p1, P p2){\n  return Line(p1, p2-p1);\n}\n\n/* 2ÂÌ¼üÌð_ */\nP crossPoint(const Line &l1, const Line &l2){\n  double num = outp(l2.d, l2.p-l1.p);\n  double denom = outp(l2.d, l1.d);\n  return P(l1.p + l1.d * num/denom);\n}\n\n/* _Æ¼üÌ£ */\ndouble dist(const Line &l, const P &p){\n  return std::abs(outp(l.d, p-l.p) / abs(l.d));\n}\n\n//üª\nstruct S{\n  P p1;\n  P p2;\n  S(P p,P q) : p1(p), p2(q) {}\n};\n\n/* p0, p1, p2ª\n * ½vñè:  1\n * vñè  : -1\n *\n * R_ª¼üãÉ éê\n * p0ªp2Æp1ÌÔÉ é: -1\n * p2ªp0Æp1ÌÔÉ é:  0\n * p1ªp0Æp2ÌÔÉ é:  1\n */\nint ccw(P p0, P p1, P p2){\n  P d1 = p1-p0;\n  P d2 = p2-p0;\n  double dx1 = d1.real(), dx2 = d2.real();\n  double dy1 = d1.imag(), dy2 = d2.imag();\n\n  if(dx1*dy2 > dy1*dx2) return  1;//½vñè\n  if(dx1*dy2 < dy1*dx2) return -1;//vñè\n  if((dx1*dx2 < 0) || (dy1*dy2 < 0)) return -1;\n  if((dx1*dx1+dy1*dy1) < (dx2*dx2+dy2*dy2)) return 1;\n  return 0;\n}\n\nbool intersect(const S &s1, const S &s2){\n  return ((ccw(s1.p1, s1.p2, s2.p1)\n           *ccw(s1.p1, s1.p2, s2.p2)) <= 0)\n    &&((ccw(s2.p1, s2.p2, s1.p1)\n        *ccw(s2.p1, s2.p2, s1.p2)) <= 0);\n}\n\n/* Np`pÌÉtª é©Ç¤© */\nbool inside(P t, P *p, int N){\n  int count = 0, j = 0;\n  S lt(t, P(DBL_MAX,t.imag()));\n\n  P pj = p[N-1];\n  for(int i=1; i<=N; i++){\n    S lp(p[i-1],p[i-1]);\n    if(ccw(lt.p1, lt.p2, p[i-1]) != 0){\n      if(i == j+1){\n        lp.p2 = pj;\n        if(intersect(lp,lt)) count++;\n      }else if(ccw(lt.p1, lt.p2, p[i-1])*ccw(lt.p1, lt.p2, pj) < 0)\n        count++;\n      j = i;\n      if(j == N) pj = p[0];\n      else pj = p[j-1];\n    }\n  }\n  return count & 1 == 1;\n}\n\nstruct cmpTheta{\n  const P base;\n  cmpTheta(P p) : base(p) {}\n\n  bool operator () (const P &p1, const P &p2) const{\n    P ang1 = (p1 - base) / abs(p1 - base);\n    P ang2 = (p2 - base) / abs(p2 - base);\n    return (ang1 / ang2).imag() < 0;\n  }\n};\n\n#define PP(p, i, n) (p[((i)==-1 ? (n)-1 : (i))])\n\n/*\n * ÊÂïðßé\n * p[]ÌæªÌMvfª¦\n */\nint grahamscan(P *p, int N){\n  int min, M, i;\n  for(min=0, i=1; i<=N; i++)\n    if(p[i].imag() < p[min].imag())\n      min=i;\n\n  for(i=1; i<=N; i++)\n    if(p[i].imag() == p[min].imag())\n      if(p[i].real() > p[min].real())\n        min = i;\n\n  swap(p[min], p[0]);\n\n  sort(p+1, p+N, cmpTheta(p[0]));\n\n  for(M=2, i=3; i<=N; i++){\n    while(ccw(PP(p,M,N),PP(p,M-1,N),PP(p,i,N)) >= 0) M--;\n    M++; swap(p[i], p[M]);\n  }\n\n  return M;\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n),n){\n    P p[n];\n    REP(i,n)\n      scanf(\"%lf,%lf\",&p[i].real(),&p[i].imag());\n    cout << n - grahamscan(p,n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n\nusing namespace std;\n\n#define MAX_N 100\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint side(P start, P end, P point) {\n  double arg = cross(end - start, point - start);\n  if (arg > 0) return 1;  // left\n  if (arg < 0) return -1; // right\n  return 0; // center\n}\n\nint n;\nP p[MAX_N];\n\nint next_vertex(int start_index) {\n  for (int i = 0; i < n; ++i) {\n    if (start_index == i) continue;\n    bool right = false;\n    for (int j = 0; j < n; ++j) {\n      if (i == j) continue;\n      if (side(p[start_index], p[i], p[j]) == -1) right = true;\n    }\n    if (!right) return i;\n  }\n  return start_index;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\\n\", &n);\n    if (!n) break;\n    \n    for (int i = 0; i < n; ++i) {\n      double x, y;\n      scanf(\"%lf,%lf\\n\", &x, &y);\n      p[i] = P(x, y);\n    }\n    \n    int pm = 0;\n    for (int i = 0; i < n; ++i) {\n      if (p[pm].real() > p[i].real()) pm = i;\n    }\n    \n    int start = pm;\n    int current = next_vertex(start);\n    int count = 1;\n    \n    while (start != current) {\n      current = next_vertex(current);\n      count++;\n    }\n    printf(\"%d\\n\", n - count);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n \nusing namespace std;\n \ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef multimap<double,int> MDI;\ntypedef MDI::iterator MDII;\n \n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n \n \nint main(){\n \n    int n;\n    int max,min;\n    int ans[NMAX+1];\n    int cnt;\n    double x,y;\n    double hx,hy,ix,iy,jx,jy;\n    char gav;\n    VPBB pin;\n    MDI point;\n\tMDII iH,iI,iJ;\n \n    while(1){\n \n        /*入力*/\n        cin>>n;\n \n        /*終了*/\n        if(n==0) break;\n \n        /*準備*/\n        for(int i=0;i<n;i++){\n            cin>>x>>gav>>y;\n            pin.PUSH(PBB(x,y));\n        }\n        for(int i=0;i<NMAX;i++) ans[i]=0;\n \n        /*端の点を決める右上*/\n        max=0;\n        for(int i=1;i<n;i++){\n            if(pin[max].second<pin[i].second) max=i;\n            else if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n        }\n \n        /*基準点との角度から順番を付ける右上*/\n        for(int i=0;i<n;i++){\n            if(i!=max){\n\t\t\t\tif(pin[i].second!=pin[max].second) point.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n\t\t\t\telse point.insert(MDIVT(-1.0*PI,i));\n            }\n        }\n        point.insert(MDIVT(-1*INF,max));\n \n        /*3点の角度から凸包を求めていく右上*/\n        iH=point.begin(),iI=point.begin(),iJ=point.begin();\n        iI++,iJ++,iJ++;\n        cnt=0;\n        while(iJ!=point.end()){\n            hx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n            ix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n            jx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n \n\t\t\t//cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug\n \n            if((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0.0){\n                iH++,iI++,iJ++;\n                while(cnt--) iH++;\n                cnt=0;\n            }\n            else{\n\t\t\t\tans[(*iI).second]=1;\n                iI++;\n                iJ++;\n                cnt++;\n            }\n        }\n\t\t//cout<<endl;\n        /*初期化右上*/\n        point.clear();\n\n\t\t/*端の点を決める左下*/\n        min=0;\n        for(int i=1;i<n;i++){\n            if(pin[min].second>pin[i].second) min=i;\n            else if(pin[min].second==pin[i].second&&pin[min].first<pin[i].first) min=i;\n        }\n \n        /*基準点との角度から順番を付ける左下*/\n        for(int i=0;i<n;i++){\n            if(i!=min){\n\t\t\t\tpoint.insert(MDIVT(atan2(pin[i].second-pin[min].second,pin[i].first-pin[min].first),i));\n            }\n        }\n        point.insert(MDIVT(-1*INF,min));\n \n        /*3点の角度から凸包を求めていく左下*/\n        iH=point.begin(),iI=point.begin(),iJ=point.begin();\n        iI++,iJ++,iJ++;\n        cnt=0;\n        while(iJ!=point.end()){\n            hx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n            ix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n            jx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n \n\t\t\t//cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug\n \n            if((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0.0){\n                iH++,iI++,iJ++;\n                while(cnt--) iH++;\n                cnt=0;\n            }\n            else{\n\t\t\t\tans[(*iI).second]=1;\n                iI++;\n                iJ++;\n                cnt++;\n            }\n        }\n\t\t//cout<<endl;\n\t\t/*出力*/\n\t\tcnt=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(ans[i]==1){\n\t\t\t\t//cout<<i<<endl;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n \n        /*初期化左下*/\n        pin.clear();\n        point.clear();\n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint a, b;\n\tLine() {}\n    Line(const Point& a, const Point& b)\n        : a(a), b(b)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (a == b)\n            this->b.real() += 1e-12;\n    }\n};\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> Poly;\n// struct Poly : public vector<Point>\n// {\n//     Poly() {}\n//     Poly(int n)\n//     {\n//         resize(n);\n//     }\n// };\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > EPS_FOR_LIB) return counter_clockwise;\n\telse if (cross(p, q) < -EPS_FOR_LIB) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.b - line1.a, line2.b - line2.a)) < 1e-9;\n}\n// AOJ0021\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.b - line1.a, line2.b - line2.a)) < 1e-9;\n}\n\nbool is_on_line(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.b - line.a, p - line.a)) < 1e-20;\n}\nbool is_on_seg(const Line& seg, const Point& p)\n{\n\treturn abs(seg.a - p) + abs(p - seg.b) < abs(seg.a - seg.b) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.b - line.a, seg.a - line.a)\n\t\t* cross(line.b - line.a, seg.b - line.a) < EPS_FOR_LIB;\n}\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.b - seg1.a, seg2.a - seg1.a) * cross(seg1.b - seg1.a, seg2.b - seg1.a) < -EPS_FOR_LIB\n            && cross(seg2.b - seg2.a, seg1.a - seg2.a) * cross(seg2.b - seg2.a, seg1.b - seg2.a) < -EPS_FOR_LIB)\n\t\t|| is_on_seg(seg1, seg2.a)\n\t\t|| is_on_seg(seg1, seg2.b)\n\t\t|| is_on_seg(seg2, seg1.a)\n\t\t|| is_on_seg(seg2, seg1.b);\n}\n\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.a - line.b, p - line.b) / abs(line.a - line.b));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.a) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.a), dist_LP(line, seg.b));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.b - seg.a, p - seg.a) < 0)\n\t\treturn abs(seg.a - p);\n\telse if (dot(seg.a - seg.b, p - seg.b) < 0)\n\t\treturn abs(seg.b - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.a), dist_SP(seg1, seg2.b))\n\t\t\t, min(dist_SP(seg2, seg1.a), dist_SP(seg2, seg1.b)));\n}\n\nPoint cross_point_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"cross_point_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.b - seg1.a, seg2.a - seg1.a));\n\tgtype b = abs(cross(seg1.b - seg1.a, seg2.b - seg1.a));\n\n\tgtype t = a / (a + b);\n\treturn seg2.a + t * (seg2.b - seg2.a);\n}\nPoint cross_point_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"cross_point_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.b - line1.a, b = line2.b - line2.a;\n\tgtype p = cross(b, line2.a - line1.a);\n\tgtype q = cross(b, a);\n\treturn line1.a + p / q * a;\n}\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.a - line.b;\n\tgtype t = dot(p - line.a, a) / norm(a);\n\treturn line.a + t * a;\n}\n\n// 線対称な点\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    Poly to_poly() const\n    {\n        Poly res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nPoly convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    Poly res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定\n// AOJ0035\nbool is_convex(const Poly& p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (ccw(p[(i - 1 + p.size()) % p.size()], p[i], p[(i + 1) % p.size()]) > 0)\n            return false;\n    }\n    return true;\n}\n\n// not verified\ngtype area(const Poly& p)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\ts += cross(p[i], p[(i + 1) % p.size()]);\n\treturn abs(s / 2);\n}\n\n// verify: AOJ0012\nenum res_contain{ IN, ON, OUT };\nres_contain contain(const Poly& poly, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)poly.size(); ++i)\n\t{\n\t\tPoint a = poly[i] - p, b = poly[(i + 1) % poly.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (is_on_seg(Line(poly[i], poly[(i + 1) % poly.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n\n// 円\nenum res_circle_rela\n{\n    a_in_b,\n    b_in_a,\n\n    tangent,\n    intersect,\n    not_intersect,\n};\n// verify: AOJ0023(feps = 0)\nres_circle_rela circle_rela(const Circle& a, const Circle& b)\n{\n    const gtype feps = 0;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\nvector<Point> intersect_points(const Circle& a, const Circle& b)\n{\n    Point ab = b.p - a.p;\n    Point c = a.p + ab * (a.r / (a.r + b.r));\n\n    gtype dis = abs(a.p - c);\n    if (dis > a.r)\n        return vector<Point>();\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - dis*dis));\n\n    Point u = ab * Point(0, 1) / abs(ab);\n    Point v = ab * Point(0, -1) / abs(ab);\n\n    Point p = c + u * h;\n    Point q = c + v * h;\n\n    vector<Point> res;\n    res.push_back(p);\n    if (abs(p - q) > 1e-9)\n        res.push_back(q); // 2点で交わっている\n\n    return res;\n}\n\nbool intersect_poly_circle(const Poly& poly, const Circle& c)\n{\n    for (int i = 0; i < (int)poly.size(); ++i)\n        if (dist_SP(Line(poly[i], poly[(i + 1) % poly.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain(poly, c.p) == IN;\n}\n\n\nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Poly p;\n        rep(i, n)\n        {\n            double x, y;\n            scanf(\"%lf,%lf\", &x, &y);\n            p.pb(Point(x, y));\n        }\n        Poly convex = convex_hull(p, allow_line);\n        cout << p.size() - convex.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntypedef complex<double> P;\n//typedef vector<P> G;\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n//(x,y)をx昇順にソート\nbool cmp(P& a,P& b){\n\tif(a.real()!=b.real()){\n\t\treturn a.real()<b.real();\n\t}else{\n\t\treturn a.imag()<b.imag();\n\t}\n}\n\n/*Graham Scan*/\n//凸多角形を求める\nint n;\nvector<P> getConvex(P *ps){\n\tsort(ps,ps+n,cmp);\n\tint k = 0;\n\tvector<P> convex(n*2);\n\tfor(int i =0;i < n;i++){\n\t\twhile(2 <=k&&cross(convex[k-1]-convex[k-2],ps[i]-convex[k-1])<=0){\n\t\t\tk--;\n\t\t}\n\t\tconvex[k++]=ps[i];\n\t}\n\tfor(int i =n-2,t = k;i >=0;i--){\n\t\twhile(t <k&& cross(convex[k-1]-convex[k-2],ps[i]-convex[k-1])<=0){\n\t\t\tk--;\n\t\t}\n\t\tconvex[k++]=ps[i];\n\t}\n\treturn convex;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tP g[120];\n\t\tfor(int i =0; i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tchar c;\n\t\t\tcin>>x>>c>>y;\n\t\t\tg[i]=P(x,y);\n\t\t}\n\t\tvector<P> convex =getConvex(g);\n\t\tcout <<n-convex.size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string.h>\n#include <functional>\n#define P pair<double,double>\nusing namespace std;\ndouble EPS=1e-10;\ndouble add(double a, double b)\n{\n\tif(abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\nP p[100];\nvector<P> v;\nvector<int> num;\nint n;\nbool used[100];\nvoid make_convex(int l,int r)\n{\n\tfor(int i=l ;(r>l ? i<r : i>=r);(r>l ? i++ : i--))\n\t{\n\t\tif(used[i]) continue;\n\t\tbool loop=true;\n\t\twhile(loop)\n\t\t{\n\t\t\tloop=false;\n\t\t\tif(v.size()<3) {v.push_back(p[i]),num.push_back(i),used[i]=true; continue;}\n\t\t\tdouble vx[3],vy[3]; int len=v.size();\n\t\t\tvx[0]=v[len-2].first-v[len-3].first;\n\t\t\tvy[0]=v[len-2].second-v[len-3].second;\n\t\t\tvx[1]=v[len-1].first-v[len-2].first;\n\t\t\tvy[1]=v[len-1].second-v[len-2].second;\n\t\t\tvx[2]=p[i].first-v[len-1].first;\n\t\t\tvy[2]=p[i].second-v[len-1].second;\n\t\t\tif(add(vx[1]*vy[2],-vx[2]*vy[1])<=0) v.push_back(p[i]),num.push_back(i),used[i]=true;\n\t\t\telse /*if(add(vx[0]*vy[1],-vx[1]*vy[0])>0)*/ used[num[len-1]]=false,num.pop_back(),v.pop_back(),loop=true;\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n; if(!n) break;\n\t\tv.clear(); memset(used,false,sizeof(used));\n\t\tfor(int i=0;i<n;i++) scanf(\"%lf,%lf\",&p[i].second,&p[i].first);\n\t\tsort(p,p+n,greater<P>());\n\t\tfor(int i=0;i<n;i++) swap(p[i].first,p[i].second);\n\t\tsort(p,p+n);\n\t\t//pはxの昇順、yの降順。時計回りで見ること\n\t\tmake_convex(0,n);\n\t\tmake_convex(n-1,0);\n\t\tcout << n-v.size() << '\\n' ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<vector>\n#include<list>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\n#define EACH(v, c) for(auto&v:c)\n\ndouble EPS=1e-10;\n\nstruct P {\n    double x,y;\n    P() : x(0),y(0) {\n        return; \n    }\n    P(double x,double y) : x(x),y(y) {\n        return; \n    }\n\n    P operator + (const P &a) const {\n        return P(x+a.x,y+a.y);\n    }\n    P operator - (const P &a) const {\n        return P(x-a.x,y-a.y);\n    }\n    P operator * (const double &a) const {\n        return P(x*a,y*a);\n    }\n    P operator / (const double &a) const {\n        return P(x/a,y/a);\n    }\n\n    bool operator < (const P &a) const {\n        return x==a.x?y<a.y:x<a.x;\n    }\n};\n\ndouble cross(const P &a, const P &b) {\n   return a.x*b.y-a.y*b.x;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n    const int n=ps.size();\n    sort(ps.begin(),ps.end());\n    int k=0;\n\n    vector<P> convex(n*2);\n    for (int i=0;i<n;++i) {\n        while (k>1 && cross(convex[k-1]-convex[k-2], ps[i]-convex[k-1])<=0) k--;\n        convex[k++]=ps[i];\n    }\n\n    for (int i=n-2,t=k;i>=0;--i) {\n        while (k>t && cross(convex[k-1]-convex[k-2],ps[i]-convex[k-1])<=0) k--;\n        convex[k++]=ps[i];\n    }\n    convex.resize(k-1);\n    return convex;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    for (;;) {\n        int n;\n        cin>>n;\n        if (n==0) {\n            break;\n        }\n        vector<P> ps(n);\n        int tmp=10;\n        EACH(p, ps) {\n            char d;\n            cin >> p.x >> d >> p.y;\n        }\n        vector<P> convex=convex_hull(ps);\n        printf(\"%d\\n\",n-convex.size());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct point{\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tbool operator<(const point& p)const{\n\t\tif(x==p.x)return y<p.y;\n\t\treturn x<p.x;\n\t}\n\tpoint operator - (point p){\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\n\tdouble det(point p){\n\t\treturn x*p.y-y*p.x;\n\t}\n};\n\nint n;\n\npoint p[101];\n\nvector<point> convex_hull(){\n\tint k=0;\n\tvector<point> qs(n*2);\n\tfor(int i=0;i<n;i++){\n\t\twhile(k>1 && (qs[k-1]-qs[k-2]).det(p[i]-qs[k-1])<=0)k--;\n\t\tqs[k++]=p[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t && (qs[k-1]-qs[k-2]).det(p[i]-qs[k-1])<=0)k--;\n\t\tqs[k++]=p[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\",&p[i].x,&p[i].y);\n\t\t}\n\t\tsort(p,p+n);\n\t\tprintf(\"%d\\n\",n-convex_hull().size());\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) ( fabs((a) - (b)) < EPS )\n\n/*struct Point{ double x, y; }; //????????¨????§???????\ntypedef Point Vector; //?????????????????¨????§???????\nstruct Segment{ //???????????¨????§???????\n    Point p1, p2;\n};\ntypedef Segment Line; //???????????¨????§???????\n*/\nclass Point{\n    public:\n        double x, y;\n\n        Point(double x = 0, double y = 0): x(x), y(y) {}\n\n        Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n        Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n        Point operator * (double a) { return Point(a * x, a * y); }\n        Point operator / (double a) { return Point(x / a, y / a); }\n\n        double abs() { return sqrt(norm());}\n        double norm() { return x * x + y * y; }\n\n        bool operator < (const Point &p) const {\n            return x != p.x ? x < p.x : y < p.y;\n        }\n\n        bool operator == (const Point &p) const {\n            return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n        }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon; //????§???¢\n\ndouble dot(Vector a, Vector b){ //????????????a??¨b?????????\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){ //????????????a??¨b?????????\n    return a.x*b.y - a.y*b.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1; //???????¨???????\nstatic const int CLOCKWISE = -1; //????¨???????\nstatic const int ONLINE_BACK = 2; //2,0,1?????????????????????\nstatic const int ONLINE_FRONT = -2; //0,1,2?????????????????????\nstatic const int ON_SEGMENT = 0; //??????0,1????????????\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nPolygon andrewScan( Polygon s ){\n    Polygon u, l;\n    if( s.size() < 3) return s;\n    sort(s.begin(), s.end()); //x,y??????????????????????????????\n    //x????°?????????????????????????u?????????\n    u.pb(s[0]);\n    u.pb(s[1]);\n    //x?????§????????????????????????l?????????\n    l.pb(s[s.size() - 1]);\n    l.pb(s[s.size() - 2]);\n\n    for(int i = 2; i < s.size(); i++){\n        for(int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.pb(s[i]);\n    }\n\n    for(int i = s.size() - 3; i >= 0; i--){\n        for(int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.pb(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        Point p;\n        Polygon s;\n        char g;\n        rep(i,n){\n            cin >> p.x >> g >> p.y;\n            s.pb(p);\n        }\n        //debug(andrewScan(s).size());\n        cout << n - andrewScan(s).size() << endl;\n        s.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n// intersect Segment p1-p2 and Segment p3-p4 ?\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n// intersect Segment s1 and Segment s2 ?\n// verified by 920, 833, 866, uoa2062\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\nPolygon andrewScan( Polygon s ){\n    Polygon u, l;\n    if ( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    int n;\n    for ( int i = 2; i < s.size(); i++ ){\n\tfor ( int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) != CLOCKWISE; n--){\n\t    u.pop_back();\n\t}\n\tu.push_back(s[i]);\n    }\n\n    for ( int i = s.size()-3; i >= 0; i-- ){\n\tfor ( int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) != CLOCKWISE; n--){\n\t    l.pop_back();\n\t}\n\tl.push_back(s[i]);\n    }\n    reverse(l.begin(), l.end());\n    for ( int i = u.size()-2; i >= 1; i-- ) l.push_back(u[i]);\n    return l;\n}\n\nmain(){\n  int n;\n  char ch;\n  double x, y;\n  while( cin >> n && n ){\n    Polygon P, C;\n    for ( int i = 0; i < n; i++ ){\n      cin >> x >>ch>> y;\n      P.push_back(Point(x, y));\n    }\n\n    C = andrewScan(P);\n\n    cout << P.size() - C.size() << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<stack>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\n\n/*\nnamespace std{\n\tbool operator<(const P &a, const P &b){return a.X==b.X ? a.Y<b.Y : a.X<b.X;}\n}*/\nnamespace std{\n    bool operator<(const P &a, const P &b){\n        return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n    }\n}\n\ndouble cross(P a,P b){return a.X*b.Y-a.Y*b.X;}\nbool ccw(P a,P b,P c){return cross(b-a,c-a)>=0;}\nvector<P> convex_VP(vector<P> ps) {\n    int n = ps.size(), k = 0;\n     \n    if (n <= 1) return ps;\n     \n    sort(ps.begin(),ps.end());\n    vector<P> qs(n * 2);\n    for (int i = 0; i < n; qs[k++] = ps[i++]) {\n        while (k > 1 && !ccw(qs[k-2],qs[k-1],ps[i])) k--;\n    }\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--]) {\n        while (k > t && !ccw(qs[k-2],qs[k-1],ps[i])) k--;\n    }\n     \n    vector<P> res(qs.begin(), qs.begin() + k - 1);\n    return res;\n}\nint main(){\n\t\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\tvector<P> p;\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tp.push_back(P(a,b));\n\t\t}\n\t\t\n\t\tvector<P> convex = convex_VP(p);\n\t\trep(i,convex.size()){\n\t\t\tprintf(\"%lf %lf\\n\",convex[i].X,convex[i].Y);\n\t\t}\n\t\tcout<<(int)p.size()-(int)convex.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS 1e-9\n\n//typedef complex<double> P;\n\nstruct P {\n\tdouble x, y;\n};\n\ntypedef vector<P> polygon;\n\nbool operator <(const P& p1, const P& p2) {\n\treturn p1.x < p2.x;\n}\nP operator -(const P& p1, const P& p2) {\n\treturn (P){p1.x - p2.x, p1.y - p2.y};\n}\n\nint F(double v) {\n\tif ( abs(v) < EPS ) return 0;\n\treturn v < 0 ? -1 : v > 0 ? 1 : 0;\n}\n\ndouble cross(P p1, P p2) {\n\treturn p1.x * p2.y - p1.y * p2.x;\n}\n\nint ccw(P& p1, P& p2, P& p3) {\n\treturn F(cross(p2 - p1, p3 - p1));\n}\n\nbool check(polygon& t, int comp) {\n\tint n = t.size();\n\tif (n < 3) return true;\n\treturn ccw(t[n-3], t[n-2], t[n-1]) == comp;\n}\n\nint main() {\n\tint n;\n\twhile ( cin >> n, n ) {\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back( (P){x, y} );\n\t\t}\n\t\tsort( v.begin(), v.end() );\n\n\t\tint ans = n+2;\n\n\t\tpolygon t;\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tt.push_back(v[i]);\n\t\t\twhile ( !check(t, 1) ) t.erase( t.end()-2, t.end()-1 );\n\t\t}\n\t\tans -= t.size();\n\n\t\tt.clear();\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tt.push_back(v[i]);\n\t\t\twhile ( !check(t, -1) ) t.erase( t.end()-2, t.end()-1 );\n\t\t}\n\t\tans -= t.size();\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef long long int lli;\nconst double EPS = 1e-10;\ntemplate<class T>\nbool eq(const T& a, const T& b) {return abs(a - b) < EPS;}\n\nusing point = complex<double>;\n// sort/unique用、setではうまく動かないので使うべからず\nnamespace std {\n\tbool operator==(const point &a, const point &b){\n\t\treturn eq(a, b);\n\t}\n\tbool operator<(const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;  // counter clockwise\n\tif (cross(b, c) < 0)   return -1;  // clockwise\n\tif (dot(b, c) < 0)     return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;  // a--c--b on line or a----bc\n}\n\n\n//点集合 ps に対してその凸包を求める．\n//O(n log n)\nvector<point> convex_hull(vector<point> ps) {\n  int n=ps.size(), k=0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i=0; i < n; ch[k++]=ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i=n-2, t=k+1; i >= 0; ch[k++]=ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main()\n{\n  int n;\n  for(;cin>>n,n;)\n    {\n      vector<point> a;\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y;\n\t  char aa;\n\t  cin>>x>>aa>>y;\n\t  a.push_back(point(x,y));\n\t}\n      cout<<n-convex_hull(a).size()<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <climits>\n#include <cmath>\n \n// 許容する誤差ε\n#define EPS (1e-10)\n\n//浮動小数点演算の誤差を考慮した比較を行うマクロ\n//等しい(=)　!=を使いたい場合は、!EQとすればよい\n#define EQ(x,y) (fabs((x) - (y)) < EPS)\n//小なり(<)\n#define LT(x,y) ((x) - (y) <= -EPS)\n//小なりイコール(<=)\n#define LE(x,y) ((x) - (y) < EPS)\n//大なり(>)\n#define GT(x,y) ((x) - (y) >= EPS)\n//大なりイコール(<)\n#define GE(x,y) ((x) - (y) > -EPS)\n\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n// 円周率\n#define PI (acos(-1.0))\n//　0≦t＜PIの範囲で偏角を求める（通常のarg()は -PI≦t≦PI)\n#define POSARG(a) (arg((a)) > 0.0? arg((a)) : 2.0*PI + arg((a)))\n\nusing namespace std;\ntypedef complex<double> P;\n \ndouble ccw(P& p1, P& p2, P& p3)\n{\n    return ((p2.real() - p1.real())*(p3.imag() - p1.imag()) \n                - (p2.imag() - p1.imag())*(p3.real() - p1.real())) > 0;\n}// ccw>0 => ccw, ccw=0 => colinear, ccw<0, cw\n \nbool complex_pred(const P& a, const P& b)\n{\n    if (a.real() != b.real())\n        return a.real() < b.real();\n    else\n        return a.imag() < b.imag();\n}\n \nvector<P> solve(vector<P> vc)\n{\n\tsort(vc.begin(), vc.end(), complex_pred);\n\n\tint k = 0;\n\tvector<P> vc2(vc.size()*2);\n\t\n\tfor (int i = 0; i < (int)vc.size(); i++)\n\t{\n\t\twhile( k >= 2 && !ccw(vc2[k-1], vc2[k-2], vc[i]))\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\t\n\t\tvc2[k]=vc[i];\n\t\tk++;\n\t}\n\n\tint t = k;\n\t\n\tfor (int i = vc.size()-1; i >= 0; i--)\n\t{\n\t\twhile ( k > t && !ccw(vc2[k-1], vc2[k-2], vc[i]))\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\t\n\t\tvc2[k]=vc[i];\n\t\tk++;\n\t}\n\t\n\tvc2.resize(k-1);\n\treturn vc2;\n}\n\n \nint main()\n{\n    int n;\n     \n    while(cin >> n, n)\n    {\n        vector<P> vc;\n        vc.clear();\n         \n        for(int i = 0; i < n; i++)\n        {\n            char c;\n            double a, b;\n            cin >> a;\n            cin >> c;\n            cin >> b;\n            vc.push_back(P(a, b));\n        }\n         \n        vector<P> vc2 = solve(vc);\n        cout << int(n - vc2.size()) << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <algorithm>\nusing namespace std;\nbool cmp(complex<double> a,complex<double> b){\n  if(a.real()!=b.real()) return a.real()<b.real();\n  return a.imag()<b.imag();\n}\nint main(){\n  int n;\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0) return 0;\n    complex<double> p[n];\n    for(int i=0;i<n;++i){\n      scanf(\"%lf,%lf\",&p[i].real(),&p[i].imag());\n    }\n    sort(p,p+n,cmp);\n    int k=0;\n    complex<double> q[n*2];\n    for(int i=0;i<n;i++){\n      if(k>1&&arg(q[k-1]-q[k-2])>arg(p[i]-q[k-1])) k--;\n      q[k++]=p[i];\n    }\n    for(int i=n-2,t=k;i>=0;i--){\n      if(k>t&&arg(q[k-1]-q[k-2])<arg(p[i]-q[k-1])) k--;\n      q[k++]=p[i];\n    }\n    printf(\"%d\\n\",n-k+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <climits>\n#include <cmath>\n \n// 許容する誤差ε\n#define EPS (1e-10)\n\n//浮動小数点演算の誤差を考慮した比較を行うマクロ\n//等しい(=)　!=を使いたい場合は、!EQとすればよい\n#define EQ(x,y) (fabs((x) - (y)) < EPS)\n//小なり(<)\n#define LT(x,y) ((x) - (y) <= -EPS)\n//小なりイコール(<=)\n#define LE(x,y) ((x) - (y) < EPS)\n//大なり(>)\n#define GT(x,y) ((x) - (y) >= EPS)\n//大なりイコール(<)\n#define GE(x,y) ((x) - (y) > -EPS)\n\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n// 円周率\n#define PI (acos(-1.0))\n//　0≦t＜PIの範囲で偏角を求める（通常のarg()は -PI≦t≦PI)\n#define POSARG(a) (arg((a)) > 0.0? arg((a)) : 2.0*PI + arg((a)))\n\nusing namespace std;\ntypedef complex<double> P;\n\nvector<P>::iterator wrapping_convex_hull(vector<P> vc)\n{\n\tint undermost = 0;\n\t\n\tfor(int i = 1; i < (int)vc.size(); i++)\n\t{\n\t\tif( LT(vc[i].imag(), vc[undermost].imag()) \n\t\t\t||( EQ(vc[undermost].imag(), vc[i].imag()) && vc[undermost].real() < vc[i].real() ) )\n\t\t{\n\t\t\tundermost = i;\n\t\t}\n\t}\t//get undermost(and rightmost) point of vc\n\t\n\tswap(vc[0], vc[undermost]); //now, vc[0] is the undermost point of vc\n\n\tdouble nowarg = 0.0;\n\tint j;\n\t\n\tfor( j = 0; j < (int)vc.size()-1; j++)\n\t{\n\t\tdouble minarg = 2.0*PI;\n\t\tdouble maxdst = 0.0;\n\t\tint candidx = 0;\n\t\t\n\t\tfor(int i = j+1; i < (int)vc.size(); i++)\n\t\t{\n\t\t\tdouble newarg = POSARG(vc[i] - vc[j]);\n\t\t\tdouble newdst = abs(vc[i] - vc[j]);\n\t\t\t\n\t\t\tif( GT(newarg, nowarg) )\n\t\t\t\tif( LT(newarg, minarg) || ( EQ(newarg, minarg) && newdst > maxdst) )\n\t\t\t\t{\n\t\t\t\t\tminarg = newarg;\n\t\t\t\t\tmaxdst = newdst;\n\t\t\t\t\tcandidx = i;\n\t\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif(candidx == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswap(vc[j+1], vc[candidx]);\n\t\t\tnowarg = minarg;\n\t\t}\n\t}\n\t\n\treturn vc.begin()+j+1;\n}\n\nvector<P> solve(vector<P> vc)\n{\n\tvector<P>::iterator it = wrapping_convex_hull(vc);\n\t\n\treturn vector<P>(vc.begin(), it);\n}\n\n\nint main()\n{\n    int n;\n     \n    while(cin >> n, n)\n    {\n        vector<P> vc;\n        vc.clear();\n         \n        for(int i = 0; i < n; i++)\n        {\n            char c;\n            double a, b;\n            cin >> a;\n            cin >> c;\n            cin >> b;\n            vc.push_back(P(a, b));\n        }\n         \n        vector<P> vc2 = solve(vc);\n        cout << int(n - vc2.size()) << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<complex>\n\nusing namespace std;\n\n#define input_init stringstream ss; string strtoken, token; istringstream is\n#define input_line  getline(cin, strtoken);is.str(strtoken);is.clear(istringstream::goodbit)\n#define input_token(num) ss.str(\"\"); ss.clear(stringstream::goodbit); getline(is, token, ','); ss << token; ss >> num\n\n\nnamespace geo{\n#include<vector>\n#include<algorithm>\n#include<complex>\t\n\n\ttypedef complex<double> P;\n\ttypedef vector<P> Poly;\n\tconst double eps = 1e-8;\n\n\t//?????????????????????????????????????????¨???\n\tinline void x(P& p, double n){ p.real(n); }\n\tinline void y(P& p, double n){ p.imag(n); }\n\tinline double x(P& p){ p.real(); }\n\tinline double y(P& p){ p.imag(); }\n\n\t//????????????a??¨b?????????\n\tinline double dot(const P a, const  P b){//A dot B\n\t\treturn a.real()*b.real() + a.imag()*b.imag();\n\t}\n\n\t//????????????a??¨b?????????\n\tinline double cross(const P a, const P b){//A cross B\n\t\treturn a.real()*b.imag() - a.imag()*b.real();\n\t}\n\n\n\t// ?????????????????¨??????????????????????????????????????????\n\tint comp(const P &l, const P &r){\n\t\tif (l.real() == r.real())\n\t\t\treturn(l.imag() < r.imag());\n\t\treturn(l.real() < r.real());\n\t}\n\n\t// ??????p??????????????????????¨?????????§Poly???????´?\n\t// Poly p : ?????¨????????????\n\t// ???????????§O(nlogn)\n\tinline Poly convex_hull(Poly& p){\n\t\tint n = (int)p.size();\n\t\tPoly res(2 * n);\n\t\tint k = 0, t;\n\t\tsort(p.begin(), p.end(),comp);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\twhile (k > 1 && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1]) < eps))k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tt = k;\n\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\twhile (k > t && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1]) < eps))k--;\n\t\t\tres[k++] = p[i];\n\t\t}\n\t\tres.resize(k - 1);\n\t\treturn res;\n\t}\n\n\n\t// ???p?????????????????¨????????¨????????????true\n\t// Poly l : ???????¨????????????????,????????°n\n\t// P p    : ???????????????????????????\n\t// ?????¨??§????????¢?´¢ O(log n)\n\tinline bool convex_in(const Poly& l, const P& p){\n\t\tint a = 0, b = (int)l.size(), c;\n\t\tdouble A, C;\n\t\tconst P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n\t\twhile (b - a > 1){\n\t\t\tc = (a + b) / 2;\n\t\t\tA = cross(l[a] - g, p - l[a]);\n\t\t\tC = cross(l[c] - g, p - l[c]);\n\t\t\tif (cross(l[a] - g, l[c] - g) >= 0){\n\t\t\t\tif (A > -eps&&C < -eps)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (C < -eps || A > -eps)b = c;\n\t\t\t\telse a = c;\n\t\t\t}\n\t\t}\n\t\treturn(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -eps);\n\t}\n\n\n\t// ??????l?????¢????????????\n\t// Poly l : ???????¨????????????????,????????°n\n\t// O(n)\n\tinline double convex_area(const Poly& l){\n\t\tdouble res = 0;\n\t\tint n = (int)l.size();\n\t\tfor (int i = 2; i < n; i++)\n\t\t\tres += abs(cross(l[1] - l[0], l[i] - l[1]));\n\t\treturn res;\n\t}\n\n}\n\nint main(void){\n\tint n;\n\tdouble x, y;\n\tgeo::Poly p;\n\tinput_init;\n\twhile (true){\n\t\tinput_line;\n\t\tinput_token(n);\n\t\tif (n == 0)break;\n\t\tp.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tinput_line;\n\t\t\tinput_token(x);\n\t\t\tinput_token(y);\n\t\t\tp[i].real(x);\n\t\t\tp[i].imag(y);\n\t\t}\n\t\tauto q=geo::convex_hull(p);\n\t\tcout << n - q.size() << endl;\n\t}\n\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <iterator>\n#include <stdlib.h>\n#include <map>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <set>\n#include <list>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\n// vector cout\ntemplate<typename _Ty>\nostream& operator << (ostream& os, const vector<_Ty>& v) {\n\tos << \"{\";\n\tfor (size_t i = 0; i < v.size(); i++)\n\t{\n\t\tif (i != 0) os << \", \";\n\t\tos << v[i];\n\t}\n\tos << \"}\";\n\n\treturn os;\n}\n\n//point\nclass Point {\npublic:\n\tdouble x;\n\tdouble y;\n\n\tPoint() {\n\t\tx = 0; y = 0;\n\t}\n\tPoint(int x, int y) {\n\t\tthis->x = x; this->y = y;\n\t}\n\n\tbool operator<(const Point& a) const {\n\t\tif (x == a.x)\n\t\t\treturn y < a.y;\n\t\telse\n\t\t\treturn x < a.x;\n\t}\n};\n\n//point cout\nostream& operator << (ostream& os, const Point& p) {\n\treturn os << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\n\nvoid rec(list<Point*>& Hull, list<Point*>& Points, Point* p1, Point* p2, int sgn) {\n\n\tdouble MaxDistance = 0;\n\tPoint* pMaxDistance = NULL;\n\tlist<Point*>::iterator it; //iterator\n\n\t//sgn?????????????????¨?????????\n\tlist<Point*> sgnPoints;\n\n\t//sgn ????????????????????§??´??? p1-p2 ??????????????¢?????§??????????±???????\n\tfor (it = Points.begin(); it != Points.end(); it++)  // list???????°??????§\n\t{\n\t\tPoint* p = *it;\n\t\tdouble d = (p2->x - p1->x)*(p->y - p1->y) - (p2->y - p1->y)*(p->x - p1->x);\n\n\t\t//0 ????????´???????????£?????? sgn ??????????????¨\n\t\tdouble reg = sgn * d;\n\n\t\t//??´????????§????????°??????\n\t\tif (fabs(reg) < 1e-8) {\n\t\t\tPoints.erase(it);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//??£?????????????????????????????¢?????????\n\t\tif (reg > 0) {\n\t\t\tsgnPoints.push_back(*it);\n\n\t\t\tif (fabs(d) > MaxDistance) {\n\t\t\t\tMaxDistance = fabs(d);\n\t\t\t\tpMaxDistance = p;\n\t\t\t}\n\t\t}\n\t}\n\n\t//?????¨??????????????°??????\n\tif (pMaxDistance == NULL) return;\n\n\t//p0 ??????????????????\n\tPoint* p0 = pMaxDistance;\n\tHull.push_back(p0);\n\tPoints.remove(p0);\n\tsgnPoints.remove(p0);\n\n\t//????§???¢ p0, p1, p2 ?????¨????????¨??????????????????\n\tfor (it = sgnPoints.begin(); it != sgnPoints.end(); it++) {\n\t\tPoint* pl = *it;\n\n\t\tPoint* p[3] = { p0, p1, p2 };\n\t\t//cross product\n\t\tdouble cp[3];\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcp[i] = (p[(i + 1) % 3]->x - p[i]->x)*(pl->y - p[i]->y) - (p[(i + 1) % 3]->y - p[i]->y)*(pl->x - p[i]->x);\n\t\t}\n\t\t//?????¨???????????????\n\t\tif ((cp[0] < 0 && cp[1] < 0 && cp[2] < 0) || (cp[0] > 0 && cp[1] > 0 && cp[2] > 0)) {\n\t\t\t//??????\n\t\t\tPoints.remove(*it);\n\t\t}\n\t}\n\n\t//??´??? (p0, p1) ???????????? p2 ????¬????\n\tdouble sp2 = (p1->x - p0->x)*(p2->y - p0->y) - (p1->y - p0->y)*(p2->x - p0->x);\n\tif (sp2 < 0) rec(Hull, Points, p0, p1, 1);\n\telse rec(Hull, Points, p0, p1, -1);\n\n\t//??´??? (p0, p2) ???????????? p1 ????¬????\n\tdouble sp1 = (p2->x - p0->x)*(p1->y - p0->y) - (p2->y - p0->y)*(p1->x - p0->x);\n\tif (sp1 < 0) rec(Hull, Points, p0, p2, 1);\n\telse rec(Hull, Points, p0, p2, -1);\n\n\treturn;\n}\n\nint convexhull(vector<Point>& vPoints)\n{\n\t//sort\n\tsort(vPoints.begin(), vPoints.end());\n\n\t//list ??? vPoints ??????????´???????????????????????´?\n\tlist<Point*> lPoints;\n\tfor (int i = 0; i < vPoints.size(); i++)\n\t{\n\t\tlPoints.push_back(&vPoints[i]);\n\t}\n\n\t//??????????§?????????????????????????\n\tlist<Point*> Hull;\n\n\t//x??§?¨?????°????????????§?????????????????????\n\tHull.push_back(lPoints.front());\n\tHull.push_back(lPoints.back());\n\n\t//p1, p2\n\tPoint* p1 = lPoints.front();\n\tPoint* p2 = lPoints.back();\n\n\t//??????\n\tlPoints.pop_front();\n\tlPoints.pop_back();\n\n\t//?¬??????£???????????¢?´¢\n\trec(Hull, lPoints, p1, p2, 1);\n\t//?¬??????????????????¢?´¢\n\trec(Hull, lPoints, p1, p2, -1);\n\n\treturn vPoints.size() - Hull.size();\n}\n\nint main() {\n\n\twhile (1) {\n\n\t\tint n;\n\t\tvector<Point> Points;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tPoint p;\n\t\t\tstring input;\n\t\t\tcin >> input;\n\n\t\t\tstringstream ss(input);\n\n\t\t\tss >> p.x;\n\t\t\tss.ignore();\n\t\t\tss >> p.y;\n\n\t\t\tPoints.push_back(p);\n\t\t}\n\t\tcout << convexhull(Points) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<complex>\n\nusing namespace std;\n\n#define reE(i,a,b) for(auto (i)=(a);(i)<=(b);(i)++)\n#define rE(i,b) reE(i,0,b)\n#define reT(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rT(i,b) reT(i,0,b)\n#define rep(i,a,b) reE(i,a,b);\n\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\n#define itr(i,b) for(auto (i)=(b).begin();(i)!=(b).end();++(i))\n#define LL long long\n#define all(b) (b).begin(),(b).end()\n\n#define input_init stringstream ss; string strtoken, token; istringstream is\n#define input_line  getline(cin, strtoken);is.str(strtoken);is.clear(istringstream::goodbit)\n#define input_token(num) ss.str(\"\"); ss.clear(stringstream::goodbit); getline(is, token, ','); ss << token; ss >> num\n\ntypedef complex<double> P;\ntypedef vector<P> Poly;\n\nconst LL INF = 1 << 30;\nconst double eps = 1e-8;\n\n\ninline double dot(const P a, const  P b){//A dot B\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\n\ninline double cross(const P a, const P b){//A cross B\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\n\nbool less_P(const P& l, const P& r){\n\tif (l.real() == r.real())\n\t\treturn l.imag() < r.imag();\n\telse return l.real() < r.real();\n}\n\ninline void convex_hull(Poly p, Poly& res){\n\tint k = 0, t;\n\tres.resize(2 * p.size());\n\tsort(all(p),less_P);\n\treT(i, 0, (int)p.size()){\n\t\twhile (k > 1 && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1])<eps))k--;\n\t\tres[k++] = p[i];\n\t}\n\tt = k;\n\trev(i, 0, (int)p.size() - 1){\n\t\twhile (k > t && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1])<eps))k--;\n\t\tres[k++] = p[i];\n\t}\n\tres.resize(k-1);\n}\n\n\n\n\n\nint main(void){\n\tint n;\n\tdouble x, y;\n\tPoly p, q;\n\tinput_init;\n\twhile (true){\n\t\tinput_line;\n\t\tinput_token(n);\n\t\tif (n == 0)break;\n\t\tp.resize(n);\n\t\trT(i, n){\n\t\t\tinput_line;\n\t\t\tinput_token(x);\n\t\t\tinput_token(y);\n\t\t\tp[i].real(x);\n\t\t\tp[i].imag(y);\n\t\t}\n\t\tconvex_hull(p, q);\n\t\tcout << n - q.size() << endl;\n\t}\n\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std\n{\n\tbool operator < ( const P& a , const P& b )\n\t{\n\t\treturn real ( a ) != real ( b ) ? real ( a ) < real ( b ) : imag ( a ) < imag ( b );\n\t}\n}\ndouble cross ( const P& a , const P& b )\n{\n\treturn imag ( conj ( a )*b );\n}\ndouble dot ( const P& a , const P& b )\n{\n\treturn real ( conj ( a )*b );\n}\n\nstruct L : public vector < P >\n{\n\tL ( const P &a , const P &b )\n\t{\n\t\tpush_back ( a ); push_back ( b );\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C\n{\n\tP p; double r;\n\tC ( const P &p , double r ) : p ( p ) , r ( r )\n\t{\n\t}\n};\n\ntypedef complex<double> point;\n\nint ccw ( P a , P b , P c )\n{\n\tb -= a; c -= a;\n\tif( cross ( b , c ) > 0 )   return +1;       // counter clockwise\n\tif( cross ( b , c ) < 0 )   return -1;       // clockwise\n\tif( dot ( b , c ) < 0 )     return +2;       // c--a--b on line\n\tif( norm ( b ) < norm ( c ) ) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nvector<point> convex_hull ( vector<point> ps )\n{\n\tint n = ps.size () , k = 0;\n\tsort ( ps.begin () , ps.end () );\n\tvector<point> ch ( 2 * n );\n\tfor( int i = 0; i < n; ch[k++] = ps[i++] ) // lower-hull\n\t\twhile( k >= 2 && ccw ( ch[k - 2] , ch[k - 1] , ps[i] ) <= 0 ) --k;\n\tfor( int i = n - 2 , t = k + 1; i >= 0; ch[k++] = ps[i--] ) // upper-hull\n\t\twhile( k >= t && ccw ( ch[k - 2] , ch[k - 1] , ps[i] ) <= 0 ) --k;\n\tch.resize ( k - 1 );\n\treturn ch;\n}\n\nint main ()\n{\n\tint N;\n\twhile( cin >> N , N )\n\t{\n\t\tvector<point>data ( N );\n\t\tfor( size_t i = 0; i < N; i++ )\n\t\t{\n\t\t\tdouble a , b;\n\t\t\tchar x;\n\t\t\tcin >> a >> x >> b;\n\t\t\tdata[i] = P ( a , b );\n\t\t}\n\t\tauto y = convex_hull ( data );\n\t\tcout << ( N - y.size () ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<stack>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\n\n/*\nnamespace std{\n\tbool operator<(const P &a, const P &b){return a.X==b.X ? a.Y<b.Y : a.X<b.X;}\n}*/\nnamespace std{\n    bool operator<(const P &a, const P &b){\n        return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n    }\n}\n\ndouble cross(P a,P b){return a.X*b.Y-a.Y*b.X;}\nbool ccw(P a,P b,P c){return cross(b-a,c-a)>=0;}\nvector<P> convex_VP(vector<P> ps) {\n    int n = ps.size(), k = 0;\n     \n    if (n <= 1) return ps;\n     \n    sort(ps.begin(),ps.end());\n    vector<P> qs(n * 2);\n    for (int i = 0; i < n; qs[k++] = ps[i++]) {\n        while (k > 1 && ccw(qs[k-2],qs[k-1],ps[i])) k--;\n    }\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--]) {\n        while (k > t && ccw(qs[k-2],qs[k-1],ps[i])) k--;\n    }\n     \n    vector<P> res(qs.begin(), qs.begin() + k - 1);\n    return res;\n}\nint main(){\n\t\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\tvector<P> p;\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tp.push_back(P(a,b));\n\t\t}\n\t\t\n\t\tvector<P> convex = convex_VP(p);\n\t\trep(i,convex.size()){\n\t\t\tprintf(\"%lf %lf\\n\",convex[i].X,convex[i].Y);\n\t\t}\n\t\tcout<<(int)p.size()-(int)convex.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\ninline double det(const P &a, const P &b) {\n\treturn (conj(a) * b).imag();\n}\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){\n\t\treturn real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n\t}\n}\n\n\nvector<P> convexHull(vector<P> ps) {\n\tint n = ps.size(), k = 0;\n\t\n\tif (n <= 1) return ps;\n\t\n\tsort(all(ps));\n\tvector<P> qs(n * 2);\n\tfor (int i = 0; i < n; qs[k++] = ps[i++]) {\n\t\twhile (k > 1 && det(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--]) {\n\t\twhile (k > t && det(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < EPS) k--;\n\t}\n\t\n\tvector<P> res(qs.begin(), qs.begin() + k - 1);\n\treturn res;\n}\n\nint main() {\n\tfor (int n; cin >> n, n != 0; ) {\n\t\tvector<P> ps;\n\t\trep(i, n) {\n\t\t\tchar c;\n\t\t\tdouble x, y; cin >> x >> c >> y;\n\t\t\tps.pb(P(x, y));\n\t\t}\n\t\tcout << n - convexHull(ps).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<double,double> P;\n\ndouble d(P p1, P p2){\n\treturn (p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second);\n}\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n){\n\t\tP p[n];\n\t\tchar c;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> p[i].first >> c >> p[i].second;\n\t\t}\n\t\tsort(p, p+n);\n\t\tP* cp = p;\n\t\tint sum = 0;\n\t\tdouble prevT = 0;\n\t\tdo{\n\t\t\tsum++;\n\t\t\tdouble minT = 7;\n\t\t\tP *nextP = p;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(&p[i] != cp){\n\t\t\t\t\tdouble T = atan2(p[i].second-(*cp).second,p[i].first-(*cp).first)-prevT;\n\t\t\t\t\tif(T < 0){\n\t\t\t\t\t\tT += M_PI*2;\n\t\t\t\t\t}\n\t\t\t\t\tif(T == minT){\n\t\t\t\t\t\tif(d(*cp, p[i]) > d(*cp, *nextP)) nextP = &p[i];\n\t\t\t\t\t}else if(T < minT){\n\t\t\t\t\t\tminT = T;\n\t\t\t\t\t\tnextP = &p[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcp = nextP;\n\t\t\tprevT += minT;\n\t\t}while(cp != p);\n\t\tcout << n-sum-1 << endl;\n\t\tcin >> n;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <numeric>\n#include <ctime>\n#include <algorithm>\n#include <set>\n#include <stdio.h>\n#include <map>\n\nusing namespace std;\ntypedef long long int lint;\n\nclass Point {\npublic:\n\tpair<double, double> p;\n\tdouble arg;\n\n\tPoint(){\n\t\tp.first = p.second = 0.0;\n\t\targ = 0.0;\n\t}\n};\n\nstruct LessPoint : public binary_function<Point, Point, bool> {\n\tbool operator () (const Point &pLeft, const Point &pRight) {\n\t\treturn pLeft.arg > pRight.arg;\n\t}\n};\n\nbool IsClockwise(Point p1, Point p2, Point p3)\n{\n\tpair<double, double> v1, v2;\n\n\tv1.first = p2.p.first - p1.p.first;\n\tv1.second = p2.p.second - p1.p.second;\n\tv2.first = p3.p.first - p1.p.first;\n\tv2.second = p3.p.second - p1.p.second;\n\n\tif(v1.first * v2.second - v2.first * v1.second < 0) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint n, i;\n\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\n\t\tPoint *po;\n\t\tpo = new Point[n];\n\t\t\n\t\tint nmin;\t\t\t\t//最小のy座標を持つ点の番号\n\t\tdouble min = 2000.0;\t//最小のy座標\n\n\t\t//find p_0\n\t\tfor(i = 0; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\", &(po[i].p.first), &(po[i].p.second));\n\t\t\tif(po[i].p.second < min){\n\t\t\t\tnmin = i;\n\t\t\t\tmin = po[i].p.second;\n\t\t\t}\n\t\t}\n\t\t//sort by argument\n\t\tpriority_queue<Point, vector<Point>, LessPoint> qu;\n\t\tfor(i = 0; i < n; i++){\n\t\t\tif(i == nmin) continue;\n\n\t\t\tpo[i].arg = atan2(po[i].p.second - po[nmin].p.second, po[i].p.first - po[nmin].p.first);\n\t\t\tqu.push(po[i]);\n\t\t}\n\n\t\tstack<Point> st;\n\n\t\t//push p0 and p1\n\t\tst.push(po[nmin]);\n\t\tst.push(qu.top());\n\t\tqu.pop();\n\n\t\twhile(!qu.empty()){\n\t\t\tPoint top, under;\t// S[top] and S[top - 1]\n\t\t\twhile(1){\n\t\t\t\ttop = st.top();\n\t\t\t\tst.pop();\n\t\t\t\tunder = st.top();\n\t\t\t\tst.push(top);\n\t\t\t\tif(!IsClockwise(under, top, qu.top())) break;\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.push(qu.top());\n\t\t\tqu.pop();\n\t\t}\n\t\tcout << n - st.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS 1\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <sstream>\n#include <climits>\n#include <cmath>\n#include <map>\n#include <stack>\nusing namespace std;\n#define M_PI 3.141592\n#define toRad 2.0*M_PI/360.0\n#define inin(x) int x;cin>>x;\n#define all(x) x.begin(),x.end()\n#define debug(x) cout<<#x<<\" \"<<x<<endl;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define EPS 1e-12\n#define pri_max 60000\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n/*\nbool memo[pri_max] = {};\nvector<int> pri;\nvoid calc()\n{\n\tfor (int i = 2; i < pri_max; i++)\n\t{\n\t\tif (memo[i] == false)\n\t\t{\n\t\t\tpri.push_back(i);\n\t\t\tfor (int l = i; l < pri_max; l += i)\n\t\t\t{\n\t\t\t\tmemo[l] = true;\n\t\t\t}\n\t\t}\n\t}\n}*/\n\nint convex_hull(vector<pdd> a)\n{\n\tvector<pdd> u, d;\n\tsort(all(a));\n\tfor (int i = 0; i < a.size(); i++)\n\t{\n\t\tfor (int l = u.size() - 1; l >= 1; l--)\n\t\t{\n\t\t\tdouble v1, v2;\n\t\t\tv1 = atan2(u[l].first - u[l - 1].first, u[l].second - u[l - 1].second);\n\t\t\tv2 = atan2(a[i].first - u[l - 1].first, a[i].second - u[l - 1].second);\n\t\t\tif (v2 < v1)u.pop_back();\n\t\t}\n\t\tu.push_back(a[i]);\n\t}\n\n\tfor (int i = 0; i < a.size(); i++)\n\t{\n\t\tfor (int l = d.size() - 1; l >= 1; l--)\n\t\t{\n\t\t\tdouble v1, v2;\n\t\t\tv1 = atan2(d[l].first - d[l - 1].first, d[l].second - d[l - 1].second);\n\t\t\tv2 = atan2(a[i].first - d[l - 1].first, a[i].second - d[l - 1].second);\n\t\t\tif (v2 > v1)d.pop_back();\n\t\t}\n\t\td.push_back(a[i]);\n\t}\n\n\tfor (int i = 0; i < u.size(); i++)\n\t{\n\t\t//cout << u[i].first << \" \" << u[i].second << endl;\n\t}\n\treturn u.size()+d.size()-2;\n}\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n&&n)\n\t{\n\t\tvector<pdd> v;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back(pdd(x, y));\n\t\t}\n\t\tcout << n - convex_hull(v) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nint sig(double r){return (r<-EPS)?-1:(r>EPS)?1:0;}\nstruct Pt{\n\tdouble x,y;\n\tPt(){}\n\tPt(double x,double y):x(x),y(y){}\n\tPt operator+(const Pt &a)const{return Pt(x+a.x,y+a.y);}\n\tPt operator-(const Pt &a)const{return Pt(x-a.x,y-a.y);}\n\tPt operator*(const Pt &a)const{return Pt(x*a.x-y*a.y,x*a.y+y*a.x);}\n\tPt operator-()const{return Pt(-x,-y);}\n\tPt operator*(const double &k)const{return Pt(x*k,y*k);}\n\tPt operator/(const double &k)const{return Pt(x/k,y/k);}\n\tdouble abs()const{return sqrt(x*x+y*y);}\n\tdouble abs2()const{return x*x+y*y;}\n\tdouble arg()const{return atan2(y,x);}\n\tdouble dot(const Pt &a)const{return x*a.x+y*a.y;}\n\tdouble det(const Pt &a)const{return x*a.y-y*a.x;}\n\tbool operator<(const Pt &a)const{return x*a.x+y*a.y;}\n\tbool operator==(const Pt &a)const{return (sig(x-a.x)==0&&sig(y-a.y)==0);}\n};\nostream &operator<<(ostream &os,const Pt &a){os<<\"(\"<<a.x<<\", \"<<a.y<<\")\";return os;}\ndouble tri(Pt a,Pt b,Pt c){return (b-a).det(c-a);}\nbool iLS(Pt a,Pt b,Pt c,Pt d){\n\treturn (sig(tri(a,b,c))*sig(tri(a,b,d))<0);\n}\n\nint main() {\n\tint n;\n\twhile(n=in()){\n\t\tvector<Pt> vpt;\n\t\tdouble x,y;\n\t\tint i,j;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\",&x,&y);\n\t\t\tvpt.push_back(Pt(x,y));\n\t\t}\n\t\tint res=n;\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tint k=0;\n\t\t\tfor(j=i+1;j<n;j++){\n\t\t\t\tint a,b;\n\t\t\t\tfor(a=0;a<n-1;a++){\n\t\t\t\tif(a==i||a==j)continue;\n\t\t\t\t\tfor(b=a+1;b<n;b++){\n\t\t\t\t\t\tif(b==i||b==j)continue;\n\t\t\t\t\t\tif(iLS(vpt[i],vpt[j],vpt[a],vpt[b]))goto batsu;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tk++;\n\t\t\t\tif(k==2)break;\n\t\t\t\tbatsu:;\n\t\t\t}\n\t\t\tres-=k;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n#define repf(i, f, l) for(int i = f; i < (int)l; ++i)\n\n#ifdef ONLINE_JUDGE\n#define DEBUG false\n#else\n#define DEBUG true\n#endif\n\n#define pb emplace_back\n#define lb lower_bound\n#define ul unsigned long\n#define ull unsigned long long\n#define ll long long\n#define INF 1000000007\n#define MOD 1000000007\n#define fs first\n#define sd second\n\n#define ALL(c) (c).begin(),(c).end()\n\n#define DBG0(x)    {if(DEBUG){ cout << #x << \": \" << x << \"\\t\"; }}\n#define DBG(x)     {if(DEBUG){DBG0(x); cout << endl;}}\n#define DBG2(x, y) {if(DEBUG){DBG0(x); DBG(y);}}\n#define DBG3(x, y, z) {if(DEBUG){DBG0(x); DBG2(y, z);}}\n#define DBG4(w, x, y, z) {if(DEBUG){DBG0(w); DBG3(x, y, z);}}\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> xs){ for(T x: xs) os << x << ' '; return os; }\ntemplate <class S, class T>\nostream& operator<<(ostream& os, pair<S,T> st){ os << \"(\" << st.first << \",\" << st.second <<\")\"; return os; }\n\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<ul> vul;\ntypedef vector<ull> vull;\ntypedef vector<bool> vbl;\ntypedef pair<int, int> pii;\n\n/* Library starts here */\nconst double EPS = 1.0e-14;\ntypedef complex<double> Point;\n/* Line is represented as (a, b, c) of ax + by + c = 0 */\ntypedef tuple<double, double, double> Line;\n/* Circle is represented as ((a, b), r) of (x - a)^2 + (y - b)^2 = r^2 */\ntypedef tuple<Point, double> Circle;\n/* Line segment is represented as (P1, P2) */\ntypedef tuple<Point, Point> Line_segment;\n\nconst Point O(0.0,0.0);\n\nistream& operator>>(istream& is, Point &pt){\n    double a, b;\n    is >> a >> b;\n    pt.real(a); pt.imag(b);\n    return is;\n}\n\nostream& operator<<(ostream& os, const Point &pt){\n    os << make_pair(pt.real(), pt.imag());\n    return os;\n}\n\nostream& operator<<(ostream& os, const Line &l){\n    os << \"(\" << get<0>(l) << \",\" << get<1>(l) << \",\" << get<2>(l) << \")\";\n    return os;\n}\n\ninline double cross(const Point &a, const Point &b){\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\ninline double myarg(Point &a){\n    double ret = arg(a);\n    return (ret >= 0 ? ret : ret + 2*M_PI);\n}\n\ninline double signed_area(const Point &a, const Point &b, const Point &c){\n    Point ab = b - a;\n    Point ac = c - a;\n    return cross(ab, ac) / 2.0;\n}\n\n\nvoid sort_by_arg(vector<Point> &pts){\n    sort(pts.begin(), pts.end(), [](Point a, Point b){ return (myarg(a) < myarg(b)); });\n}\ninline Line make_line(const Point &a, const Point &b){\n    return make_tuple(a.imag() - b.imag() , b.real() - a.real(), -(a.imag() * b.real() - a.real() * b.imag()));\n}\n\ninline Line orthogonal_line(const Point &p, const Line &l){\n    return make_tuple(get<1>(l), -get<0>(l), get<0>(l) * p.imag() - get<1>(l) * p.real());\n}\n\ninline bool is_parallel(const Line &l0, const Line &l1){\n    return ((get<0>(l0)*get<1>(l1) - get<1>(l0)*get<0>(l1)) == 0.0);\n}\n\ninline Point intersection_point(const Line &l0, const Line &l1){\n    const double A = get<0>(l0);\n    const double B = get<1>(l0);\n    const double C = get<0>(l1);\n    const double D = get<1>(l1);\n    const double U = get<2>(l0);\n    const double V = get<2>(l1);\n    const double det = A*D - B*C;\n    return Point((-D*U + B*V) / det,\n                 ( U*C - A*V) / det);\n}\n\ninline Point rotate(const Point &p, const double theta){\n    double ct = cos(theta);\n    double st = sin(theta);\n    return Point(ct * p.real() - st*p.imag(), st*p.real() + ct*p.imag());\n}\n\n/* whether polygon is_included p. It is considered true if p is on the edge. */\n/* this function has not been validated */\nbool is_included(const Point &p, const vector<Point> &polygon){\n    int n = polygon.size();\n    int zero = 0;\n    int plus = 0;\n    rep(i, n){\n        const int di = (i + 1 == n ? 0 : i + 1);\n        double tmp = cross(polygon[di] - polygon[i], p - polygon[i]);\n        if(abs(tmp) <= 1e-14) zero++;\n        else if(tmp > 0.0) plus++;\n    }\n    if(zero || plus == 0 || plus == n) return true;\n    return false;\n}\n\n/* this function has not been validated */\ninline bool is_included(const Point &P, const Line &L){\n    return (P.real() * get<0>(L) + P.imag() * get<1>(L) + get<2>(L) == 0.0);\n}\n\n/* this function has not been validated */\nbool is_included(const Point &P, const Line_segment &AB){\n    const Point A = get<0>(AB), B = get<1>(AB);\n    return (abs(P - A) + abs(B - P) - abs(B - A) < EPS);\n}\n\n/* this function has not been validated */\ninline bool is_included(const Point &p, const Circle &cir){\n    return (abs(p - get<0>(cir)) <= get<1>(cir));\n}\n\ndouble distance(const Point &P, const Line &L){\n    return abs(P.real()*get<0>(L) + P.imag()*get<1>(L) + get<2>(L)) / abs(P);\n}\n\n/* distance between a point P and line segment AB */\n/* this function has not been validated */\ndouble distance(const Point &P, const Line_segment &AB){\n    Line LAB = make_line(get<0>(AB), get<1>(AB));\n    Line orth = orthogonal_line(P, LAB);\n    Point S = intersection_point(orth, LAB);\n    if(is_included(P, AB)) return abs(P - S);\n    return min(abs(P - get<0>(AB)), abs(P - get<1>(AB)));\n}\n\nbool intersect(const Line_segment &AB, const Line &L){\n    const Point A = get<0>(AB), B = get<1>(AB);\n    const double a = get<0>(L);\n    const double b = get<1>(L);\n    const double c = get<2>(L);\n    const double t = (a*A.real() + b*A.imag() + c) / (a*A.real() + b*A.imag() - (a*B.real() + b*B.imag()));\n    return (0.0 <= t && t <= 1.0);\n}\n\ninline bool intersect(const Line_segment &AB, const Line_segment &CD){\n    const Point A = get<0>(AB);\n    const Point B = get<1>(AB);\n    const Point C = get<0>(CD);\n    const Point D = get<1>(CD);\n    const Point VAB = B - A;\n    const Point VCD = D - C;\n    return ((cross(VAB, C - A) * cross(VAB, D - A) < 0.0) &&\n            (cross(VCD, A - C) * cross(VCD, B - C) < 0.0));\n}\n\n/* End of the Library */\nint main(void){\n    while(1){\n        int n;\n        scanf(\"%d\", &n);\n        if(!n) return 0;\n        vector<Point> pts(n);\n        rep(i, n){\n            double a, b;\n            scanf(\"%lf,%lf\\n\", &a, &b);\n            pts[i] = Point(a, b);\n        }\n        int ans = 0;\n        rep(i, n){\n            repf(j, i + 1, n){\n                const Line L = make_line(pts[i], pts[j]);\n                int left = 0;\n                rep(k, n){\n                    if(i == k || j == k) continue;\n\n                    double t = pts[k].real() * get<0>(L) + pts[k].imag() * get<1>(L) + get<2>(L);\n                    if(t == 0.0){\n                        left = -1;\n                        break;\n                    }\n                    if(t > 0.0) left++;\n                }\n                if(left == n - 2 || left == 0) ans++;\n            }\n        }\n        printf(\"%d\\n\", n - ans);\n    }\n    return 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint main(){\n  int n;\n  while(cin >>n,n){\n    vector<pair<double,double> > dot;\n    bool f[100]={false};\n    for(double i=0,a,b; i<n; i++){scanf(\"%lf,%lf\",&a,&b);dot.push_back(make_pair(a,b));}\n    sort(dot.begin(),dot.end());\n    int now=0,next;\n    for(;;){\n      for(int i=0; i<n; i++){\n\tif(i!=now && !f[i]){\n\t  next = i;\n\t  double ax=dot[i].first-dot[now].first;\n\t  double ay=dot[i].second-dot[now].second;\n\t  for(int j=0; j<n; j++){\n\t    if(!f[j]){\n\t      double bx=dot[j].first-dot[now].first;\n\t      double by=dot[j].second-dot[now].second;\n\t      if(ax*by-ay*bx<0){next = -1;break;}\n\t    }\n\t  }\n\t  if(next == i) break;\n\t}\n      }\n      f[next] = true;\n      now = next;\n      if(f[0]) break;\n    }\n    int ans = 0;\n    for(int i=0; i<n; i++) if(!f[i]) ans++;\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n\ndouble calcAngle(double a){\n\tif(a<=0){\n\t\treturn a+=atan(1.0)*8;\n\t}\n\telse{\n\t\treturn a;\n\t}\n}\n\nint main(){\n\n\t//P a=P(1,0);\n\t//P b=P(-1,1);\n\t//double tmp=asin((cross(a,b)/(abs(a)*abs(b))));\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tP ps[1001];\n\t\tbool fucked[1001];\n\t\tfill(fucked,fucked+1001,false);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdouble x,y;\n\t\t\tchar ch;\n\t\t\tcin>>x>>ch>>y;\n\t\t\tps[i]=P(x,y);\n\t\t}\n\t\tdouble minX=10000000;\n\t\tint initIdx;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t// kousin\n\t\t\tif(ps[i].real()<minX){\n\t\t\t\tminX=ps[i].real();\n\t\t\t\tinitIdx=i;\n\t\t\t}\n\t\t}\n\t\t// àÁÆàxÀWª¬³¢Æ±ë©çÔÉ©¯Ä¢­\n\t\tP bp=ps[initIdx];\n\t\tP pp=P(0,1);\n\t\twhile(1){\n\t\t\tint idx;\n\t\t\tdouble minD=100000;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t// pxðvZ\n\t\t\t\tdouble cc=(dot(ps[i]-bp,pp)/(abs(pp)*abs(ps[i]-bp)));\n\t\t\t\tif((cross(ps[i]-bp,pp)/(abs(pp)*abs(ps[i]-bp)))<0){\n\t\t\t\t\tcc=3.14-acos(cc);\n\t\t\t\t\tcc=3.14+cc;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcc=acos(cc);\n\t\t\t\t}\n\n\t\t\t\tif(minD>cc){\n\t\t\t\t\tminD=min(minD,cc);\n\t\t\t\t\tidx=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fucked[idx])\n\t\t\t\tbreak;\n\t\t\tfucked[idx]=true;\n\n\t\t\tpp=ps[idx]-bp;\n\t\t\tbp=ps[idx];\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!fucked[i])\n\t\t\t\tcnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\n\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tBOOL online(const P &p){\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]);\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\t\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool includeOnLine = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tREP(i, size()){\n\t\t\t\twhile(k>1 && (ccw(r[k-2], r[k-1], at(i)) < 1 || \n\t\t\t\t\t!includeOnLine && ccw(r[k-2], r[k-1], at(i)) == 2)) k--;\n\t\t\t\tr[k++] = at(i);\n\t\t\t}\n\t\t\tint t = k;\n\t\t\tRREP(i, size()){\n\t\t\t\twhile(k>t && (ccw(r[k-2], r[k-1], at(i)) < 1 || \n\t\t\t\t\t!includeOnLine && ccw(r[k-2], r[k-1], at(i)) == 2)) k--;\n\t\t\t\tr[k++] = at(i);\n\t\t\t}\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(scanf(\"%d\", &n), n){\n\t\tG g;\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tscanf(\"%lf,%lf\", &p.X, &p.Y);\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcout << g.size() - g.convex_hull(true).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <chrono>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n#include <limits>\n#include \"limits.h\"\n \n#define rep(i, a, b) for (long long (i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\nvoid debug_out(){std::cerr<<std::endl;}\n\ntemplate<typename Head,typename... Tail>\nvoid debug_out(Head h,Tail... t){\n  std::cerr<<\" \"<<h;\n  debug_out(t...);\n}\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if(b==0)return 1;\n  if ((a == 0)||(mod!=-1&&(a+mod)%mod==0)) {\n    return 0;\n  }\n  long long x = 1;\n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n\n// const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P=std::pair<long long,long long>;\n\nusing Point=std::complex<long double>;\n\nconst long double EPS=1e-10;\nconst long double PI=std::acos(-1.0l);\n\nbool EQ(long double a,long double b){return std::abs(a-b)<EPS;}\nbool EQP(Point a,Point b){return EQ(a.real(),b.real())&&EQ(a.imag(),b.imag());}\n\nPoint unitvec(Point a){return a/std::abs(a);}\n\n//dot a・b = |a||b|cosθ\nlong double dot(Point a,Point b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\n//cross a×b = |a||b|sinθ\nlong double cross(Point a,Point b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\n//直線a,b上に点cがあるか\nbool on_line(Point a,Point b,Point c){\n  return EQ(cross(c-a,b-a),0.0l);\n}\n\n// [a,b]上に点cがあるか\nbool on_segment(Point a,Point b,Point c){\n  return std::abs(c-a)+std::abs(b-c)<std::abs(b-a)+EPS;\n}\n\n//どの2点も異なる点集合の凸包を求める\nstd::vector<std::pair<Point,long long>> convex(std::vector<std::pair<Point,long long>> set){\n  using Pa=std::pair<Point,long long>;\n  if(set.size()==1)return {set[0]};\n  auto comp=[&](Pa a,Pa b){\n    return (EQ(a.first.real(),b.first.real()))?(a.first.imag()>b.first.imag()):(a.first.real()<b.first.real());\n  };\n\n  std::sort(set.begin(),set.end(),comp);\n\n  long long n=set.size();\n\n  std::vector<Pa> lower,upper;\n\n  lower.push_back(set[0]);\n  long long lowernow=0;\n  for(ll i=1;i<n;i++){\n    while(lowernow>0){\n      Point add=set[i].first-lower[lowernow].first;\n      Point last=lower[lowernow-1].first-lower[lowernow].first;\n      if(0<std::arg(last/add)&&std::arg(last/add)<PI-EPS){\n        break;\n      }else{\n        lower.pop_back();\n        lowernow--;\n      }\n    }\n    if(i!=n-1)lower.push_back(set[i]);\n    lowernow++;\n  }\n\n  upper.push_back(set[n-1]);\n  long long uppernow=0;\n  for(long long i=n-2;i>=0;i--){\n    while(uppernow>0){\n      Point add=set[i].first-upper[uppernow].first;\n      Point last=upper[uppernow-1].first-upper[uppernow].first;\n      if(0<std::arg(last/add)&&std::arg(last/add)<PI-EPS){\n        break;\n      }else{\n        upper.pop_back();\n        uppernow--;\n      }\n    }\n    if(i!=0)upper.push_back(set[i]);\n    uppernow++;\n  }\n\n  //for(auto low:lower)debug(low.first);\n  //for(auto up:upper)debug(up.first);\n\n  lower.reserve(lowernow+uppernow);\n  std::copy(upper.begin(),upper.end(),std::back_inserter(lower));\n  return lower;\n}\n\nint main() {\n  //std::cin.tie(nullptr);\n  //std::ios::sync_with_stdio(false);\n\n  int n;\n  while(std::cin>>n,n){\n    std::vector<std::pair<Point,long long>> s;\n    double x,y;\n    rep(i,0,n){\n      scanf(\"%lf,%lf\",&x,&y);\n      s.push_back({Point(x,y),i});\n    }\n    //for(auto e:convex(s))debug(e.first);\n    std::cout<<n-convex(s).size()<<\"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n// 点クラス\nstruct P {\n\tdouble x, y;\n\tP(double x_, double y_) { x = x_; y = y_; }\n\tP(){}\n\t// 加算, 減算, スカラー倍\n\tP operator+(const P& a) const {\n\t\treturn P(x + a.x, y + a.y);\n\t}\n\tP operator-(const P& a) const {\n\t\treturn P(x - a.x, y - a.y);\n\t}\n\tP operator*(const P& a) const {\n\t\treturn P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP operator*(double c) const {\n\t\treturn P(x * c, y * c);\n\t}\n\tP operator/(const P& a) const {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\treturn P(x_, y_);\n\t}\n\tP operator/(double c) const {\n\t\treturn P(x / c, y / c);\n\t}\n\tP& operator+=(const P& a) {\n\t\tx += a.x; y += a.y;\n\t}\n\tP& operator-=(const P& a) {\n\t\tx -= a.x; y -= a.y;\n\t}\n\tP& operator*=(const P& a) {\n\t\t*this = P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP& operator*=(double c) {\n\t\t*this = P(x * c, y * c);\n\t}\n\tP& operator/=(const P& a) {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\t*this = P(x_, y_);\n\t}\n\tP& operator/=(double c) {\n\t\t*this = P(x / c, y / c);\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"(%f,%f)\", x, y); }\n};\nP operator*(double c, P a){\n\treturn P(a.x * c, a.y * c);\n}\n// 比較演算子\nbool operator==(const P& a, const P& b) {\n\treturn equal(a.x, b.x) && equal(a.y, b.y);\n}\nbool operator!=(const P& a, const P& b) {\n\treturn !(a == b);\n}\nbool operator<(const P& a, const P& b) {\n\treturn (a.x != b.x)? a.x < b.x : a.y < b.y;\n}\n\nconst P INF_P = P(INF, INF);\n\n// 原点からの距離(絶対値)\ndouble abs(P a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n// 2点間の距離\ndouble dist(P a, P b) {\n\treturn abs(a - b);\n}\n// ノルム\ndouble norm(const P& z){\n\treturn z.x * z.x + z.y * z.y;\n}\n// 偏角\ndouble arg(const P& z) {\n\treturn atan2(z.y, z.x);\n}\n// ベクトル a の単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n// ベクトル a の法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0, +1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb -= a, c -= a;\n\tif( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n\tif( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n\tif( dot(b, c)  < -EPS ) return +2;  // c--a--b on line\n\tif( dot(b, b)  + EPS < dot(c, c) ) return -2; // a--b--c on line \n\treturn ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\treturn P(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n// 点 a を軸に点 b を角度 angle (ラジアン)だけ回転させた点を返す\nP rot(P a, P b, double angle){\n\treturn rot(b - a, angle) + a;\n}\n\n// 点 c を点 a, b を通る直線の線対称に移動させる\nP symmetry(P a, P b, P c) {\n\tP res;\n\tif( b.x == a.x ) {\n\t\tres.x = -c.x; res.y = c.y;\n\t}else{\n\t\tdouble m = (b.y - a.y) / (b.x - a.x);\n\t\tdouble z = b.y - m * b.x;\n\t\tres.x = (2 * m * c.y - c.x * (m * m - 1) - 2 * m * z) / (m * m + 1);\n\t\tres.y = (2 * m * c.x + c.y * (m * m - 1) + 2 * z) / (m * m + 1);\n\t}\n\treturn res;\n}\n\n// 直線クラス\nstruct Line : public vector<P> {\n\tLine(){}\n\tLine(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(const vector<P>& vp){\n\t\t(*this) = vp;\n\t}\n\t// デバッグ出力 (線分を出力)\n\tvoid print_s() const {\n\t\tprintf(\"line(%f,%f,%f,%f); \\n\", (*this)[0].x, (*this)[0].y, (*this)[1].x, (*this)[1].y);\n\t}\n\t// デバッグ出力 (直線を出力, 途中で直線が途切れているときは適当にlenの値を大きくする)\n\tvoid print_l() const {\n\t\tconst double len = 100;\n\t\tP p1 = (*this)[0], p2 = (*this)[1];\n\t\tdouble dx = p1.x - p2.x, dy = p1.y - p2.y;\n\t\tp1.print();\n\t\tp2.print();\n\t\tp1.x += len * dx;\n\t\tp1.y += len * dy;\n\t\tp2.x -= len * dx;\n\t\tp2.y -= len * dy;\n\t\tLine l( p1 , p2 );\n\t\tl.print_s();\n\t}\n};\n\n// 2つの直線の直交判定\nbool is_orthogonal(const Line& a, const Line& b) {\n\treturn equal( dot( a[0] - a[1] , b[0] - b[1] ) , 0.0 );\n}\n// 2つの直線の平行判定\nbool is_parallel(const Line& a, const Line& b) {\n\treturn equal( cross( a[0] - a[1] , b[0] - b[1] ), 0.0 );\n}\n\n// 直線 a と直線 b の交差判定\nbool intersectLL(const Line& a, const Line& b) {\n\treturn abs(cross(a[1] - a[0], b[1] - b[0])) > EPS || abs(cross(a[1] - a[0], b[0] - a[0])) < EPS;\n}\n// 直線 l と 線分 s の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n\treturn cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n// 直線 l 上に点 p があるかどうか\nbool intersectLP(const Line& l, const P& p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n// 線分 s と 線分 t の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t   ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分 s 上に点 p があるかどうか\nbool intersectSP(const Line& s, const P& p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nP projection(const Line& l, const P& p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[0] - l[1]) * t;\n}\nP reflection(const Line& l, const P& p) {\n\treturn p + 2 * (projection(l, p) - p);\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const P& p) {\n\treturn abs(p - projection(l, p));\n}\n// 直線と直線の距離\ndouble distanceLL(const Line& l, const Line& m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const P& p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n// 線分と線分の距離\ndouble distanceSS(const Line& s, const Line& t) {\n\tif (intersectSS(s, t)) return 0;\n\tdouble a = min(distanceSP(s, t[0]), distanceSP(s, t[1]));\n\tdouble b = min(distanceSP(t, s[0]), distanceSP(t, s[1]));\n\treturn min(a, b);\n}\n// 交点計算\nP crosspoint(const Line& l, const Line& m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\t// if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n// 円クラス\nstruct Circle{\n\tP p;\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) const {\n\t\treturn dist(p, a) <= r;\n\t}\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) const {\n\t\treturn equal( dist(p, a) , r );\n\t}// 等しいかどうか\n\tbool operator==(const Circle& c) const {\n\t\treturn p == c.p && r == c.r;\n\t}// デバッグ出力\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.x, p.y, r ); }\n};\n\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n\tdouble law_of_cos(double a, double b, double c) {\n\t\treturn acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n\t}\n\t// 点 a , b を端点とする線分に点 c が含まれているかどうか\n\tbool contain(P a, P b, P c) {\n\t\treturn abs(a - c) + abs(b - c) - abs(b - a) < EPS;\n\t}\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n\t// 3 つの辺の長さ\n\tdouble edgeA, edgeB, edgeC;\n\t// 3 つの角の角度 (ラジアン)\n\tdouble angleA,angleB,angleC;\n\t// コンストラクタで初期化\n\tTriangle(P p1, P p2, P p3) {\n\t\ta = p1; b = p2; c = p3;\n\t\tedgeB = abs(c-a);\n\t\tedgeA = abs(b-c);\n\t\tedgeC = abs(a-b);\n\t\tangleA = law_of_cos( edgeA, edgeB, edgeC );\n\t\tangleB = law_of_cos( edgeB, edgeC, edgeA );\n\t\tangleC = law_of_cos( edgeC, edgeA, edgeB );\n\t}\n\t// 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\treturn contain(a, b, p) || contain(b, c, p) || contain(c, a, p);\n\t}\n\t// 三角形の重心を返す\n\tP gravity() {\n\t\treturn P( (a.x + b.x + c.x) / 3.0 , (a.y + b.y + c.y) / 3.0 );\n\t}\n\t// 三角形の外接円を返す (AOJ 0010 で検証済み)\n\tCircle circumscribed_circle() {\n\t\tdouble r = ( edgeA / sin(angleA) / 2.0 );\n\t\tdouble A = sin( 2.0 * angleA );\n\t\tdouble B = sin( 2.0 * angleB );\n\t\tdouble C = sin( 2.0 * angleC );\n\t\tdouble cx = ( (a.x * A + b.x * B + c.x * C) / (A + B + C) );\n\t\tdouble cy = ( (a.y * A + b.y * B + c.y * C) / (A + B + C) );\n\t\treturn Circle( P(cx,cy) , r );\n\t}\n\t// 三角形の内接円を返す\n\tCircle inscribed_circle() {\n\t\t// 三角形の外周の長さ\n\t\tdouble ABC = edgeA + edgeB + edgeC;\n\t\t\n\t\tdouble cx = (a.x * edgeA + b.x * edgeB + c.x * edgeC) / ABC;\n\t\tdouble cy = (a.y * edgeA + b.y * edgeB + c.y * edgeC) / ABC;\n\t\tdouble r  = (2.0 * get_area()) / ABC ;\n\t\treturn Circle( P(cx,cy) , r );\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n\t// デバッグ出力\n\tvoid print() {\n\t\tLine AB(a,b), BC(b,c), CA(c,a);\n\t\tAB.print_s();\n\t\tBC.print_s();\n\t\tCA.print_s();\n\t}\n};\n\ntypedef vector<P> Polygon;\n\n// 点 p が単純多角形の内部・外部・境界のどこにあるか判定する.\nenum { OUT, IN };\nint contains(const Polygon& g, const P& p) {\n\tint n = g.size();\n\tbool in = false;\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\tP a = g[i] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif( a.y > b.y ){\n\t\t\tswap(a, b);\n\t\t}\n\t\tif( a.y <= 0 && 0 < b.y ){\n\t\t\tif( cross(a, b) < 0 ){\n\t\t\t\tin = !in;\n\t\t\t}\n\t\t}\n\t\tif( cross(a, b) == 0 && dot(a, b) <= 0 ){\n\t\t\treturn ON;\n\t\t}\n  }\n  return in? IN : OUT;\n}\n// (凸とは限らない) 多角形の面積を返す.\ndouble get_area(const Polygon& g) {\n\tint n = g.size();\n\tdouble s = 0;\n\tfor(int i = 0 ; i < n ; i++ )\n\t\ts += cross(g[i], g[(i+1) % n]);\n\treturn fabs(s);\n}\n\n// 凸多角形かどうか\nbool is_convex(const Polygon& g) {\n\tint n = g.size();\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\tif( ccw(g[(i+n-1) % n], g[i % n], g[(i+1) % n]) > 0 )\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n// 凸包を求める. (ps.size() >= 3 と仮定する)\nvector<P> convex_hull(vector<P> ps) {\n\t/*int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<P> ch(2*n);\n\tfor(int i = 0 ; i < n ; ch[k++] = ps[i++] ){ // lower-hull\n\t\twhile( k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0 ) --k;\n\t}\n\tfor(int i = n-2, t = k+1 ; i >= 0 ; ch[k++] = ps[i--] ){ // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\t\tch.resize(k-1);\n\t}\n\treturn ch;\n}*/\n  int n = ps.size();\n    sort( ps.begin() , ps.end() );\n     \n    // 上部を求める\n    vector<P> ch_u( n );\n    int n_u = 0;\n    for(int i = n-1 ; i >= 0 ; i-- ) {\n        ch_u[n_u++] = ps[i];\n        while( n_u >= 3 && ccw( ch_u[n_u-3] , ch_u[n_u-2] , ch_u[n_u-1] ) != CCW ) {\n            ch_u[n_u-2] = ch_u[n_u-1];\n            n_u--;\n        }\n    }\n  \n    vector<P> ch_l( n );\n    int n_l = 0;\n    for(int i = 0 ; i < n ; i++ ) {\n        ch_l[n_l++] = ps[i];\n        while( n_l >= 3 && ccw( ch_l[n_l-3] , ch_l[n_l-2] , ch_l[n_l-1]) != CCW ) {\n            ch_l[n_l-2] = ch_l[n_l-1];\n            n_l--;\n        }\n    }\n  \n    Polygon ch;\n    for(int i=0 ; i<n_u-1 ; i++ ) ch.push_back(ch_u[i]);\n    for(int i=0 ; i<n_l-1 ; i++ ) ch.push_back(ch_l[i]);\n    return ch;\n}\n\n// 凸多角形をある直線で切断し，その左側だけ残す．\nPolygon convex_cut(const Polygon& g, const Line& l) {\n\tPolygon Q;\n\tint n = g.size();\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\tP A = g[i], B = g[(i+1) % n];\n\t\tif( ccw(l[0], l[1], A) != -1 ){\n\t\t\tQ.push_back(A);\n\t\t}\n\t\tif( ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0 ){\n\t\t\tQ.push_back(crosspoint(Line(A, B), l));\n\t\t}\n\t}\n\treturn Q;\n}\n// 凸多角形の重心を返す\nP gravity(const Polygon& g) {\n\tP sg(0,0);\n\tdouble s = 0.0;\n\tfor(int i=2 ; i < g.size() ; i++ ) {\n\t\tTriangle t( g[0] , g[i-1] , g[i] );\n\t\ts += t.get_area();\n\t\tsg += t.get_area() * t.gravity();\n\t};\n\treturn sg / s;\n}\n\n// 点 p が凸多角形の内部・外部・境界のどれにあるか判定する.\nint convex_contains(const Polygon& g, const P& p) {\n\tconst int n = g.size();\n\tP pp = (g[0] + g[n/3] + g[2*n/3]) / 3.0;\n\tint a = 0, b = n;\n\twhile( a + 1 < b ){\n\t\tint c = (a + b) / 2;\n\t\tif( cross(g[a] - pp, g[c] - pp) > 0 ){\n\t\t\tif( cross(g[a] - pp, p - pp) > 0 && cross(g[c] - pp, p - pp) < 0 ){\n\t\t\t\tb = c;\n\t\t\t}else{\n\t\t\t\ta = c;\n\t\t\t}\n\t\t}else{\n\t\t\tif( cross(g[a] - pp, p - pp) < 0 && cross(g[c] - pp, p - pp) > 0 ){\n\t\t\t\ta = c;\n\t\t\t}else{\n\t\t\t\tb = c;\n\t\t\t}\n\t\t}\n\t}\n\tb %= n;\n\tif( cross(g[a] - p, g[b] - p) < 0 ) return OUT;\n\tif( cross(g[a] - p, g[b] - p) > 0 ) return IN;\n\treturn ON;\n}\n\n// 2つの凸多角形の共通部分の凸多角形を返す\nbool intersect_1pt(const P& a, const P& b, const P& c, const P& d, P &r) {\n\tdouble D =  cross(b - a, d - c);\n\tif( equal(D,0) ) return false;\n\tdouble t =  cross(c - a, d - c) / D;\n\tdouble s = -cross(a - c, b - a) / D;\n\tr = a + t * (b - a);\n\treturn ( t >= 0 && t <= 1 && s >= 0 && s <= 1 );\n}\nPolygon convex_intersect(Polygon p, Polygon q) {\n\tconst int n = p.size();\n\tconst int m = q.size();\n\tint a = 0, b = 0, aa = 0, ba = 0;\n\tenum { Pin, Qin, Unknown } in = Unknown;\n\tPolygon R;\n\tdo {\n\t\tint a1 = (a+n-1) % n;\n\t\tint b1 = (b+m-1) % m;\n\t\tdouble C = cross( p[a] - p[a1] , q[b] - q[b1] );\n\t\tdouble A = cross( p[a1] - q[b], p[a] - q[b] );\n\t\tdouble B = cross( q[b1] - p[a], q[b] - p[a] );\n\t\tP r;\n\t\tif( intersect_1pt( p[a1], p[a], q[b1], q[b], r ) ) {\n\t\t\tif( in == Unknown ) aa = ba = 0;\n\t\t\tR.push_back( r );\n\t\t\tin = (B > 0) ? Pin : (A > 0)? Qin : in ;\n\t\t}\n\t\tif( C == 0 && B == 0 && A == 0 ) {\n\t\t\tif( in == Pin ) {\n\t\t\t\tb = (b + 1) % m;\n\t\t\t\t++ba;\n\t\t\t}else {\n\t\t\t\ta = (a + 1) % m;\n\t\t\t\t++aa;\n\t\t\t}\n\t\t}else if( C >= 0 ) {\n\t\t\tif( A > 0 ) {\n\t\t\t\tif( in == Pin ) R.push_back( p[a] );\n\t\t\t\ta = (a+1) % n;\n\t\t\t\t++aa;\n\t\t\t}else {\n\t\t\t\tif( in == Qin ) R.push_back( q[b] );\n\t\t\t\tb = (b+1) % m;\n\t\t\t\t++ba;\n\t\t\t}\n\t\t}else {\n\t\t\tif( B > 0 ) { \n\t\t\t\tif( in == Qin ) R.push_back( q[b] );\n\t\t\t\tb = (b+1) % m;\n\t\t\t\t++ba;\n\t\t\t}else {\n\t\t\t\tif( in == Pin ) R.push_back( p[a] );\n\t\t\t\ta = (a+1) % n;\n\t\t\t\t++aa;\n\t\t\t}\n\t\t}\n\t}while( (aa < n || ba < m) && aa < 2*n && ba < 2*m );\n\tif( in == Unknown ) {\n\t\tif( convex_contains(q, p[0]) ) return p;\n\t\tif( convex_contains(p, q[0]) ) return q;\n\t}\n\treturn R;\n}\n\n// 凸多角形の直径を求める. (最遠頂点対は pp に入る)\nP diff(const Polygon& g, int i){\n\treturn g[(i+1) % g.size()] - g[i];\n}\ndouble convex_diameter(const Polygon& pt, pair<P,P>& pp) {\n\tconst int n = pt.size();\n\tint is = 0, js = 0;\n\tfor(int i = 1 ; i < n ; i++ ){\n\t\tif( pt[i].y > pt[is].y ) is = i;\n\t\tif( pt[i].y < pt[js].y ) js = i;\n\t}\n\tdouble maxd = norm(pt[is] - pt[js]);\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo{\n\t\tif( cross(diff(pt,i), diff(pt,j)) >= 0){\n\t\t\tj = (j+1) % n;\n\t\t}else{\n\t\t\ti = (i+1) % n;\n\t\t}\n\t\t\n\t\tif( norm(pt[i] - pt[j]) > maxd ){\n\t\t\tmaxd = norm(pt[i] - pt[j]);\n\t\t\tmaxi = i;\n\t\t\tmaxj = j;\n\t\t}\n\t}while( i != is || j != js );\n\tpp = pair<P,P>(pt[maxi], pt[maxj]);\n\treturn maxd;\n}\n\n// 直線 l の方向( l[0] から l[1] へのベクトル ) と 最も遠い点を返す\ndouble d(int k, const Polygon& g, const Line& l) {\n\treturn dot(g[k], l[1] - l[0]);\n}\nP convex_extreme(const Polygon& g, const Line& l) {\n\tint a = 0, b = g.size(), n = g.size();\n\tif( d(0,g,l) >= d(n-1,g,l) && d(0,g,l) >= d(1,g,l) ){\n\t\treturn g[0];\n\t}\n\twhile( a < b ) {\n\t\tint c = (a + b) / 2;\n\t\tif( d(c,g,l) >= d(c-1,g,l) && d(c,g,l) >= d(c+1,g,l) ){\n\t\t\treturn g[c];\n\t\t}\n\t\tif( d(a+1,g,l) > d(a,g,l) ){\n\t\t\tif( d(c+1,g,l) <= d(c,g,l) || d(a,g,l) > d(c,g,l) ){\n\t\t\t\tb = c;\n\t\t\t}else{\n\t\t\t\ta = c;\n\t\t\t}\n\t\t}else{\n\t\t\tif( d(c+1,g,l) > d(c,g,l) || d(a,g,l) >= d(c,g,l) ){\n\t\t\t\ta = c;\n\t\t\t}else{\n\t\t\t\tb = c;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tvector<P> v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back( P(x,y) );\n\t\t}\n\t\tcout << (n - convex_hull(v).size()) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <complex>\nusing namespace std;\n\ntypedef long double D;\nconst D EPS = 1e-8,INF = 1e12;\n\ntemplate<typename T> int sig(T a,T b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\ntemplate<typename T> bool eq(T a,T b){ return sig(abs(a-b))==0;}\ntemplate<typename T> D norm(T a){ return a*a;}\n\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n#define ISEQ(c) (c).begin(), (c).end()\ntypedef long long ll;\n\ntypedef vector<P> Poly,ConvexPoly;\n#define prev(as, i) as[(i-1+as.size())%as.size()]\n#define curr(as, i)  as[i]\n#define next(as, i) as[(i+1)%as.size()]\n\n\n// a×b\nD cross(const P& a,const P& b){\n  return imag(conj(a)*b);\n}\n// a・b\nD dot(const P& a,const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(const P& a,P b,P c){\n  b -= a; c -= a;\n  if (cross(b,c) > 0)   return +1;       // counter clockwise\n  if (cross(b,c) < 0)   return -1;       // clockwise\n  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//浮動小数点modで非負の値のみかえす．\nD pfmod(D v,D M=2*M_PI){\n  return fmod(fmod(v,M)+M,M);\n}\n\n//[0,PI)\nD AbsArg(D a){\n  D ret=pfmod(max(a,-a),2);\n  return min(ret,2*M_PI-ret);\n}\n\nnamespace std{\n  bool operator < (const P& a,const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n  bool operator == (const P& a,const P& b){\n    return eq(a,b);\n  }\n};\n\n//\nP O=P(0,0);\nP s,g;\n\n\n// verified by \n// 事前にs-g\n// O-s → O-gの回転方向に関してソート．\n// (同角度の場合、距離が遠い方が前)\nbool CompArg(const P& p1,const P&p2){\n  if(abs(ccw(O,p1,p2))!=1)return abs(p1)>abs(p2);//sameline\n  return ccw(O,p1,p2)==ccw(O,s,g);\n}\n\n//!!\n//角度ソート\nP dir;//基準方向\nbool Comp(const P& p1,const P&p2){\n  if(sig(pfmod(arg(p1)-arg(dir)),pfmod(arg(p2)-arg(dir)))==0)return abs(p1)>abs(p2);\n  return sig(pfmod(arg(p1)-arg(dir)),pfmod(arg(p2)-arg(dir)));\n}\n\n\nenum { OUT, ON, IN };\nint contains(const Poly& ps, const P& p) {\n  bool in = false;\n  REP(i,ps.size()){\n    P a = curr(ps,i) - p, b = next(ps,i) - p;\n    if (a.Y > b.Y) swap(a, b);\n    if (a.Y <= 0 && 0 < b.Y)\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nD area2(const Poly& ps){\n  D S=0;\n  REP(i,ps.size())S+=cross(curr(ps,i),next(ps,i));\n  return S;\n}\n\n//凸包\n//O(n logn)\nConvexPoly convex_hull(Poly ps) {\n  int n = ps.size(), k = 0;\n  sort(ALL(ps));\n  Poly ch(2*n);\n  REP(i,n){ // lower-hull\n    while (k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n    ch[k++]=ps[i];\n  }\n  for(int i=n-2,t=k+1;i>=0;i--){// upper-hull\n    while (k >= t && ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n    ch[k++]=ps[i];\n  }\n  ch.resize(k-1);\n  return ch;\n}\n\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    Poly p;\n    for (int i = 0; i < n; i++) {\n      double x, y;\n      scanf(\"%lf,%lf\", &x, &y);\n      p.push_back(P(x,y));\n    }\n    sort(ISEQ(p));\n    ConvexPoly cp = convex_hull(p);\n    \n    cout << n - cp.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 )\n\t{\n\t\treturn;\n\t}\n\n\tPoint( double x, double y ) : x( x ), y( y )\n\t{\n\t\treturn;\n\t}\n\n\tPoint operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x - a.x, y - a.y );\n\t}\n\n\tPoint operator * ( const double &a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint operator / ( const double &a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n};\n\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\nvector< Point > getConvex( vector< Point > ps )\n{\n\tconst int N = ps.size();\n\n\tsort( ALL( ps ) );\n\n\tint k = 0;\n\tvector< Point > convex( N * 2 );\n\n\tfor ( int i = 0; i < N; i++ )\n\t{\n\t\twhile ( 2 <= k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tfor ( int i = N - 2, t = k; 0 <= i; i-- )\n\t{\n\t\twhile ( t < k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.resize( k - 1 );\n\n\treturn convex;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< Point > ps( n );\n\n\t\tEACH( p, ps )\n\t\t{\n\t\t\tchar d;\n\n\t\t\tcin >> p.x >> d >> p.y;\n\t\t}\n\n\t\tvector< Point > convex = getConvex( ps );\n\n\t\tcout << n - convex.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nusing G = V<P>;\nR area(const G& g) {\n  if (g.size() < 3) return 0;\n  R res = 0;\n  P a = g.back();\n  for (P b : g) {\n    res += crs(a, b) / 2;\n    a = b;\n  }\n  return res;\n}\n// -1: in, 0: on, 1: out\nint contains(const G& g, P p) {\n  assert(g.size() >= 3);\n  int c = 0;\n  P q = p + P(pi, 1), a = g.back();\n  for (P b : g) {\n    if (!ccw(a, b, p)) return 0;\n    if (!sgn(distLS({p, q}, {a, b}))) {\n      c += ccw(p, q, intxn({p, q}, {a, b})) >= 0;\n    }\n    a = b;\n  }\n  return c & 1 ? -1 : 1;\n}\nG half_convex_hull(const V<P>& ps, bool strict) {\n  G g;\n  for (P p : ps) {\n    while (g.size() >= 2) {\n      int c = ccw(g[g.size() - 2], g.back(), p);\n      if (c == 1 or !strict and c == 2) break;\n      g.pop_back();\n    }\n    g.push_back(p);\n  }\n  g.pop_back();\n  return g;\n}\nG convex_hull(V<P> ps, bool strict = true) {\n  sort(begin(ps), end(ps), cmp);\n  ps.erase(unique(begin(ps), end(ps), eql), end(ps));\n  if (ps.size() < 3) return ps;\n  G g = half_convex_hull(ps, strict);\n  reverse(begin(ps), end(ps));\n  G h = half_convex_hull(ps, strict);\n  g.insert(end(g), begin(h), end(h));\n  return g;\n}\nR diameter(const G& g) {\n  auto e = minmax_element(begin(g), end(g), cmp);\n  int n = g.size(), i = e.first - begin(g), j = e.second - begin(g);\n  R res = 0;\n  for (int _ = 0; _ < n; ++_) { // n: 半周, 2n: 一周\n    res = max(res, distPP(g[i], g[j]));\n    int ni = (i + 1) % n, nj = (j + 1) % n;\n    if (sgn(crs(g[ni] - g[i], g[nj] - g[j])) < 0) i = ni;\n    else j = nj;\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<P> ps(n);\n    char dmy;\n    for (auto&& p : ps) {\n      R x, y; cin >> x >> dmy >> y;\n      p = P(x, y);\n    }\n    int res = n - convex_hull(ps).size();\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\n#define EPS 1e-10\n\ndouble add(double a,double b){\n  if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct P{\n  double x,y;\n  P(){}\n  P(double x,double y): x(x),y(y) {}\n\n  P operator + (P p){\n    return P(add(x,p.x),add(y,p.y));\n  }\n  P operator - (P p){\n    return P(add(x,-p.x),add(y,-p.y));\n  }\n\n  P operator * (double d){\n    return P(x*d,y*d);\n  }\n\n  double dot(P p){\n    return add(x*p.x,y*p.y);\n  }\n  double det(P p){\n    return add(x*p.y,-y*p.x);\n  }\n};\nbool cmp_x(const P& p,const P& q){\n  if(p.x != q.x )return p.x < q.x;\n  return p.y < q.y;\n}\n\nvector<P> convex_hull(vector<P> ps , int N)\n{\n  sort(ps.begin(),ps.end(),cmp_x);\n  /*for(int i = 0 ; i < N ; i++ ){\n    cout << ps[i].x << ' ' << ps[i].y << endl;\n    }*/\n  vector<P> qs(N*2);\n  int k = 0;\n  for(int i = 0 ; i < (int)ps.size() ; i++ ){\n    while(k > 1 && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1]) <= 0 )k--;\n    qs[k++] = ps[i];\n  }\n\n  for(int i=N-2,t = k ; i >= 0 ; i-- ){\n    while(k > t && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1]) <= 0 )k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  int n;\n\n  while(cin >> n,n){\n    vector<P> ps(n);\n    char c;\n    for(int i = 0 ; i < n ; i++ ){\n      cin >> ps[i].x >>c>> ps[i].y;\n    }\n    vector<P> qs = convex_hull(ps, n);\n    cout << ps.size()-qs.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#define EPS 1e-10\nusing namespace std;\nint n;\n\ndouble add(double a ,double b){\n  if(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nclass P{\npublic:\n  double x,y;\n\n  P(){}\n  P(double x,double y):x(x),y(y){}\n\n  P operator + (P p){\n    return P(add(x,p.x),add(y,p.y));\n  }\n  P operator - (P p){\n    return P(add(x,-p.x),add(y,-p.y));\n  }\n  P operator * (double d){\n    return P(x*d,y*d);\n  }\n  double dot(P p){\n    return add(x*p.x,y*p.y);\n  }\n  double det(P p){\n    return add(x*p.y,-y*p.x);\n  }\n};\n  bool cmp_x(const P& p,const P& q){\n    if(p.x != q.x)return p.x < q.x;\n    return p.y < q.y;\n  }\n\nvector<P> convex_hull(vector<P> ps,int n){\n\n  sort(ps.begin(),ps.end(),cmp_x);\n  int k = 0;\n  vector<P> qs(2*n);\n  for(int i = 0 ; i < n ; i++ ){\n    while( k > 1 && (qs[k-2]-qs[k-1]).det(qs[k-1]-ps[i])<= 0)k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = n-2 ,t = k ; i >= 0 ; i--  ){\n    while(k > t && (qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1]) <= 0)k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  while( cin >> n , n){\n    vector<P>p;\n    p.clear();\n    for(int i = 0 ; i < n ; i++ )\n      {\n\tdouble a,b;\n\tchar c; \n\tcin >> a >> c >> b;\n\tp.push_back(P(a,b));\n      }\n\n    vector<P> q = convex_hull(p,n);\n    cout <<  p.size() - q.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n \nusing namespace std;\n \ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef multimap<double,int> MDI;\ntypedef MDI::iterator MDII;\n \n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n \n \nint main(){\n \n    int n;\n    int max;\n    int ans;\n    int cnt;\n    double x,y;\n    double hx,hy,ix,iy,jx,jy;\n    char gav;\n    VPBB pin;\n    MDI point;\n \n    while(1){\n \n        /*入力*/\n        cin>>n;\n \n        /*終了*/\n        if(n==0) break;\n \n        /*準備*/\n        for(int i=0;i<n;i++){\n            cin>>x>>gav>>y;\n            pin.PUSH(PBB(x,y));\n        }\n        ans=0;\n \n        /*端の点を決める*/\n        max=0;\n        for(int i=1;i<n;i++){\n            if(pin[max].second<pin[i].second) max=i;\n            else if(pin[max].second==pin[i].second&&pin[max].first<pin[i].first) max=i;\n        }\n \n        /*基準点との角度から順番を付ける*/\n        for(int i=0;i<n;i++){\n            if(i!=max){\n\t\t\t\tif(pin[i].second!=pin[max].second) point.insert(MDIVT(atan2(pin[i].second-pin[max].second,pin[i].first-pin[max].first),i));\n\t\t\t\telse point.insert(MDIVT(-1*INF+10000-pin[i].first,i));\n            }\n        }\n        point.insert(MDIVT(-1*INF,max));\n \n        /*3点の角度から凸包を求めていく*/\n        MDII iH=point.begin(),iI=point.begin(),iJ=point.begin();\n        iI++,iJ++,iJ++;\n        cnt=0;\n        while(iJ!=point.end()){\n            hx=pin[(*iH).second].first,hy=pin[(*iH).second].second;\n            ix=pin[(*iI).second].first,iy=pin[(*iI).second].second;\n            jx=pin[(*iJ).second].first,jy=pin[(*iJ).second].second;\n \n            cout<<(*iH).second<<\" \"<<(*iI).second<<\" \"<<(*iJ).second<<\" \"<<(jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)<<endl; ///debug\n \n            if((jx-ix)*(hy-iy)-(jy-iy)*(hx-ix)>0){\n                iH++,iI++,iJ++;\n                while(cnt--) iH++;\n                cnt=0;\n            }\n            else{\n                iI++;\n                iJ++;\n                cnt++;\n                ans++;\n            }\n        }\n \n        /*出力*/\n        cout<<ans<<endl;\n \n        /*初期化*/\n        pin.clear();\n        point.clear();\n    }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=1){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - at(0))) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p){\n\t\t\tif(!sig(abs(p - at(0))) || !sig(abs(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-at(0),  dir()) < EPS) return abs(p - at(0));\n\t\t\tif(inp(p-at(1), -dir()) < EPS) return abs(p - at(1));\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\t\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t};\n\tinline BOOL cc_intersect(const C &a, const C &b){\n\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t}\n\tinline int cl_intersect(const C &c, const L &l){\n\t\treturn less(l.distance(c), c.r);\n\t}\n\tinline int cs_intersect(const C &c, const S &s){\n\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]) == 1 ? 0 : -1;\n\t\treturn less(s.distance(c), c.r);\n\t}\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\t\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i), 0) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-2;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i), 0) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n};\n#undef SELF\n#undef at\n}\n\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const geom::P &a, const geom::P &b) {\n\t    if (!geom::sig(a.X-b.X)) return (a.Y < b.Y);\n\t    return (a.X < b.X);\n\t}\n}\n\nint n;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(scanf(\"%d\", &n), n){\n\t\tG g;\n\t\tREP(i, n){\n\t\t\tP p;\n\t\t\tscanf(\"%lf,%lf\", &p.X, &p.Y);\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcout << g.size() - g.convex_hull(true).size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#include <iostream>\n#include <set>\n#include <map>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define mp make_pair\n\n#define th (*this)\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> C;\nstruct P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\n\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool eq(T a, T b) {return abs(a - b) < EPS;}\n\nstruct P {\n  complex<D> comp;\n  P() : comp(0) {}\n  \n  P(D x , D y) : comp(x,y) {}\n  P(C c) : comp(c) {}\n  P(L l) { th = l.second - l.first; }\n\n  D & x(){ return comp.real(); }\n  D & y(){ return comp.imag(); }\n\n  P operator+(P r) { return P(r.comp + th.comp); }\n  P operator-(P r) { return P(r.comp - th.comp); }\n  D operator*(P r) {\n    D x = comp.real();\n    D y = comp.imag();\n    D rx = r.comp.real();\n    D ry = r.comp.imag();\n    return x*rx - y*ry;\n  }\n  \n  D operator/(P r) {\n    D x = comp.real();\n    D y = comp.imag();\n    D rx = r.comp.real();\n    D ry = r.comp.imag();\n    return x*ry - y*rx;\n  }\n    \n  P & operator+=(P r) { return th = P(r.comp + th.comp); }\n  P & operator-=(P r) { return th = P(r.comp - th.comp); }\n  P & operator*=(D r) { return th = P(th.comp * r); }\n  P & operator/=(D r) { return th = P(th.comp / r); }\n\n  P operator+() { return th; }\n  P operator-() { return P(-comp); }\n  D operator!() { return abs(comp); }\n  D operator~() { return norm(comp); }\n};\n\nbool lessX(P & r, P & l) { return r.x() < l.x(); }\nbool lessY(P & r, P & l) { return r.y() < l.y(); }\nbool lessN(P & r, P & l) { return !r < !l; }\n\nP operator*(P p , D k){ p.x() *= k; p.y() *= k; return p; }\nP operator*(D k , P p){ p.x() *= k; p.y() *= k; return p; }\nP operator/(P p , D k){ p.x() /= k; p.y() /= k; return p; }\n\n//点と線分の位置関係\nenum CCW { BACK , ON , FRONT };\nint ccw(L l , P p){\n  P a = l.first;\n  P b = l.second;\n  return (a*p > 0) + (b*p > 0);\n}\n\n//円と円の位置関係\nenum { CROSS , TOUCH , INA , INB , OUT };\nint iCC(D ra , D rb , D dis){\n  if(ra + rb < dis) return OUT;\n  else if(dis + ra < rb && ra < rb) return INA;\n  else if(dis + rb < ra && ra > rb) return INB;\n  else return CROSS;\n}\n\n//3点が作る三角形の面積\nD area(P p , P q , P r){\n  P a = q - p;\n  P b = r - p;\n  return abs(a/b)/2;\n}\n\n//多角形の面積\nD areaPol(Pol p){\n  D rtn = 0;\n  P base = p[0];\n  rep(i , 1 , p.size()){\n    rtn += p[i]/p[(i+1)%p.size()];\n  }\n  return rtn/2;\n}\n\n//ヘロンの公式で面積\nD heron(D a , D b , D c){\n  //以下のif文は真が保証される場合省ける\n  if(b - a > EPS) swap(a , b);\n  if(c - a > EPS) swap(a , c);\n  if(c - b > EPS) swap(b , c);\n  if(b + c - a <= -EPS) return -1;\n  D s = (a + b + c)/2;\n  return sqrtl(s*(s-a)*(s-b)*(s-c));\n}\n\n//2点が原点を挟んでなす角を0~2Piで返す\nD anglePP(P a , P b){\n  return acosl(a*b/!a/!b) + (a/b < 0) * PI;\n}\n\n// 点の直線への射影\nP projLP(L l, P p){\n  P w = p - l.first;\n  P v = P(l);\n  if(~v < EPS) return l.first;\n  return v*w*v/~v - l.first;\n}\n\n// 直線2の直線1への射影\nL projLL(L l1, L l2){\n  P a = projLP(l1 , l2.first);\n  P b = projLP(l1 , l2.second);\n  return mp(a,b);\n}\n\n//2直線がなす角を返す\nD argL(L l , L m){\n  P a(l);\n  P b(m);\n  //[0,2Pi)で返す\n  return - abs(acosl(a*b/!a/!b)) + 2*PI;\n  //[-Pi,Pi)返す\n  //D r = - abs(acosl(a*b/!a/!b)) + 2*PI;\n  //return r - (r <= PI)*2*PI;\n}\n\n//角P1 B P2のなす角を求める\nD argP(P b , P p1 , P p2){\n  return 0;\n}\n\n//重心\nP GC(P a , P b , P c){\n  return (a + b + c)/3;\n}\n\n//内心\nP IC(P a, P b, P c){\n  D sa = !(b-c);\n  D sb = !(c-a);\n  D sc = !(a-b);\n  return (a*sa + b*sb + c*sb)/(sa + sb + sc);\n}\n\n//外心\nP CC(P a , P b , P c){\n  D ta = ~(b-c);\n  D tb = ~(c-a);\n  D tc = ~(a-b);\n    \n  D sa = ta*(-ta + tb + tc);\n  D sb = tb*( ta - tb + tc);\n  D sc = tc*( ta + tb - tc);\n\n  return (a*sa + b*sb + c*sc)/(sa + sb + sc);\n}\n\n//垂心\nP HC(P a , P b , P c){\n  D ta = ~(b-c);\n  D tb = ~(c-a);\n  D tc = ~(a-b);\n\n  D sa = -ta + tb + tc;\n  D sb =  ta - tb + tc;\n  D sc =  ta + tb - tc;\n\n  return (a*sa + b*sb + c*sc)/(sa + sb + sc);\n}\n\n//距離\nD dPP(P p , P q){ return !(p-q); }\nD dLP(L l , P p){ return !(projLP(l,p),p); }\n\n//放物線の長さ\nD lPar(D l , D r , D a , D b){\n  return abs( pow(2*a*r + b + 1,2/3) - pow(2*a*l + b + 1,2/3) );\n}\n\n//凸包\nbool comp_x(const P & p , const P & q){\n  D px = p.comp.real();\n  D py = p.comp.imag();\n  D qx = q.comp.real();\n  D qy = q.comp.imag();\n  if(px != qx) return px < qx;\n  return py < qy;\n}\n\nPol convex(Pol ps){\n  sort(ps.begin() , ps.end() , comp_x);\n  int k = 0;\n  int n = ps.size();\n  Pol qs(n*2);\n  rep(i,0,n){\n    while(1 < k && (qs[k-1] - qs[k-2])/(ps[i] - qs[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i=n-2, t=k; 0 <= i; i--){\n    while (t < k && (qs[k-1] - qs[k-2])/(ps[i] - qs[k-1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k - 1);\n  return qs;\n}\n\nint main(){\n  int n;\n  P a(1,0), b(1,0.5);\n  while(cin >> n, n){\n    Pol pol(n);\n    rep(i,0,n){\n      D x, y;\n      char c;\n      cin >> x >> c >> y;\n      pol.push_back(P(x,y));\n    }\n    Pol co = convex(pol);\n    cout << n - co.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P cent;double r;}; //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b){ return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b){ return a.x*b.y-a.y*b.x; }\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//?????????????????? verified\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble distance_l_p(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//????????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_point(P center, double r, L line){\n    if( distance_l_p(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nbool isPointInsidePolygon(vector<L> side,P p){\n    int c=0, sideSum=side.size();\n    \n    rep(i,sideSum){\n        if( cross(side[i].p2-side[i].p1,p-side[i].p1)>0 ) c++;\n    }\n    return !(c%sideSum);\n}\n//?????? verified AOJ0068\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n    int n = ps.size();\n    sort(all(ps), cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????????????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        vector<P> ps(n);\n        rep(i,n){\n            char ch;\n            cin>>ps[i].x>>ch>>ps[i].y;\n        }\n        vector<P> res = convex_hull(ps);\n        cout<<n-res.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef vector <int> vi;\ntypedef pair<double,double> pd;\ntypedef vector <pd > vp;\nvp D;\nvi A;\n\nint side(pd p1, pd p2){\n\tdouble dy=p2.first-p1.first,dx=p2.second-p1.second;\n\tfor(int i=0;i<(int)D.size();i++){\n\t\tpd p3=D[i];\n\t\tif (p1==p3||p2==p3)continue;\n\t\tif ((p3.second-p1.second)*dy-dx*(p3.first-p1.first)<0) return 0;\n\t}\n    return 1;\n}\n\nint main(){\n\twhile (1){\n\t\tint n,i,s;\n\t\tpd p,p1,p2;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif (n==0) break;\n\t\tfor (i=0;i<n;i++){\n\t\t\tcin>>p.first>>c>>p.second;\n\t\t\tD.push_back(p);\n\t\t\tA.push_back(0);\n\t\t}\n\t\tsort(D.begin(),D.end());\n\t\tp=D[0];\n\t\tp1=p;\n\t\ts=0;\n\t\twhile (1){\n\t\t\tfor (i=0;i<n;i++){\n\t\t\t\tp2=D[i];\n\t\t\t\tif (A[i]==0 && p1!=p2 && side(p1,p2)) break;\n\t\t\t}\n\t\t\tp1=p2;\n\t\t\tA[i]=1;\n\t\t\ts++;\n\t\t\tif (p2==p) break;\n\t\t}\n\t\tcout<<D.size()-s<<\"\\n\";\n\t\tD.clear();\n\t\tA.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<stack>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return a.X==b.X ? a.Y<b.Y : a.X<b.X;}\n}\n\ndouble cross(P a,P b){return a.X*b.Y-a.Y*b.X;}\nbool ccw(P a,P b,P c){return cross(b-a,c-a)>=0;}\nvector<P> convex_VP(vector<P> ps) {\n    int n = ps.size(), k = 0;\n     \n    if (n <= 1) return ps;\n     \n    sort(ps.begin(),ps.end());\n    vector<P> qs(n * 2);\n    for (int i = 0; i < n; qs[k++] = ps[i++]) {\n        while (k > 1 && ccw(qs[k-2],qs[k-1],ps[i])) k--;\n    }\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--]) {\n        while (k > t && ccw(qs[k-2],qs[k-1],ps[i])) k--;\n    }\n     \n    vector<P> res(qs.begin(), qs.begin() + k - 1);\n    return res;\n}\nint main(){\n\t\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\tvector<P> p;\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tp.push_back(P(a,b));\n\t\t}\n\t\t\n\t\tvector<P> convex = convex_VP(p);\n\t\trep(i,convex.size()){\n\t\t\tprintf(\"%lf %lf\\n\",convex[i].X,convex[i].Y);\n\t\t}\n\t\tcout<<(int)p.size()-(int)convex.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<double, double>P;\n\nP p[100];\ndouble det(P a, P b) {\n\treturn a.first*b.second - a.second*b.first;\n}\nP operator-(P a, P b) { return P(a.first - b.first, a.second - b.second); }\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n)scanf(\"%lf,%lf\", &p[i].first, &p[i].second);\n\t\tsort(p, p + n);\n\t\tvector<P>a(n * 2);\n\t\tint k = 0;\n\t\trep(i, n) {\n\t\t\twhile (k > 1 && det(a[k - 1] - a[k - 2], p[i] - a[k - 2]) < 0)k--;\n\t\t\ta[k++] = p[i];\n\t\t}\n\t\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\t\twhile (k > t && det(a[k - 1] - a[k - 2], p[i] - a[k - 2]) < 0)k--;\n\t\t\ta[k++] = p[i];\n\t\t}\n\t\tprintf(\"%d\\n\", n - k + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nmain(){\n\tint n,i,start,M;\n\tdouble x,y,dX,dY,dx,dy,dot,n1,n2,co,m;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<pair<pair<double,double>,int> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf,%lf\",&x,&y),v.push_back(make_pair(make_pair(x,y),i));\n\t\tpair<pair<double,double>,int>p=*min_element(v.begin(),v.end());\n\t\tdX=0,dY=-1;\n\t\tstart=p.second;\n\t\tvector<int>V;\n\t\tfor(;;){\n\t\t\tm=-1,M=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(i==p.second)continue;\n\t\t\t\tdx=v[i].first.first-p.first.first,dy=v[i].first.second-p.first.second;\n\t\t\t\tdot=dX*dx+dY*dy;\n\t\t\t\tn1=hypot(dX,dY),n2=hypot(dx,dy);\n\t\t\t\tco=dot/n1/n2;\n\t\t\t\t//printf(\"%f\\n\",co);\n\t\t\t\tif(m<co)m=co,M=i;\n\t\t\t}\n\t\t\tif(M==start)break;\n\t\t\tV.push_back(M);\n\t\t\t//printf(\"---%d %d\\n\",M,start);\n\t\t\tdX=v[M].first.first-p.first.first,dY=v[M].first.second-p.first.second;\n\t\t\tp=v[M];\n\t\t}\n\t\tprintf(\"%d\\n\",n-V.size()-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tbool done;\n\tbool operator<(const Point &p) const{\n\t\tif( x < p.x ) return true;\n\t\telse return false;\n\t}\n};\nclass Vector{\npublic:\n\tdouble x,y,z;\n\tVector():x(0.0),y(0.0),z(0.0){}\n\tVector(Point po,Point pt){\n\t\tx = pt.x - po.x;\n\t\ty = pt.y - po.y;\n\t\tz = 0.0;\n\t}\n};\n\nVector Cross(Vector va, Vector vb){\n\tVector vret;\n\tvret.x = va.y * vb.z - vb.y * va.z;\n\tvret.y = va.z * vb.x - vb.z * va.x;\n\tvret.z = va.x * vb.y - vb.x * va.y;\n\treturn vret;\n}\n\nint main(void){\n\twhile( true ){\n\t\tint cnt = 0;\n\t\tint nowPoint = 0;\n\t\tint n;\n\t\tvector<Point> vPoints;\n\n\t\tscanf(\"%d\", &n);\n\t\tif( n == 0 ) break;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tPoint p;\n\t\t\tscanf(\"%lf,%lf\", &p.x, &p.y);\n\t\t\tp.done = false;\n\t\t\tvPoints.push_back( p );\n\t\t}\n\t\tsort(vPoints.begin(), vPoints.end());\n\n\t\tvPoints[nowPoint].done = true;\n\t\tdo{\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif( !vPoints[i].done ){\n\t\t\t\t\tVector vo(vPoints[nowPoint],vPoints[i]);\n\t\t\t\t\tbool isPerimeter = true;\n\t\t\t\n\t\t\t\t\tvPoints[i].done = true;\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tif( !vPoints[j].done ){\n\t\t\t\t\t\t\tVector vt(vPoints[nowPoint],vPoints[j]);\n\t\t\t\t\t\t\tVector cr = Cross(vo, vt);\n\t\t\t\t\t\n\t\t\t\t\t\t\tif( cr.z > 0 ){\n\t\t\t\t\t\t\t\tisPerimeter = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( !isPerimeter ) vPoints[i].done = false;\n\t\t\t\t\telse{\n\t\t\t\t\t\tnowPoint = i;\n\t\t\t\t\t\tvPoints[0].done = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}while( nowPoint != 0 );\n\n\t\tvPoints[0].done = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif( !vPoints[i].done ) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cstdio>\nusing namespace std;\n\n//???????????¨\nbool lt(const complex<double>& a,const complex<double>& b){\n  return a.real()<b.real() || (a.real()==b.real() && a.imag()<b.imag());\n}\n\n//??????????¬????????????¢??????????????????????±??????????\ndouble cp(complex<double> a, complex<double> b){\n  return (conj(a)*b).imag();\n}\n\nint main(){\n  int n;\n  while(cin >> n && n>0){\n\n    //????????????\n    vector<complex<double> > v;\n    for(int i=0;i<n;i++){\n      double x, y;\n      scanf(\"%lf,%lf\",&x,&y);\n      v.push_back(complex<double>(x,y));\n    }\n\n    //C???R^2??¨???????????????????????§???????????????\n    sort(v.begin(),v.end(),lt);\n\n    //??????????????´????????´??????\n    vector<complex<double> > u,b;\n\n    //????????????????????§???v.front()??¨v.back()??????????????????????????§?????????\n    u.push_back(v[0]);\n    int i;\n    for(i=0;i<n;i++){\n      if(v[i].real()!=v[0].real()) break;\n    }\n    b.push_back(v[0]);\n    b.push_back(v[i]);\n\n    i=i+1;\n    while(b.back()!=v.back()){\n      b.push_back(v[i]);\n      i++;\n\n      int l=b.size();\n      if(l<3) continue;\n      if(cp(b[l-1]-b[l-2],b[l-3]-b[l-2])>0) continue;\n      else{\n\tb.pop_back();\n\tb.pop_back();\n\ti--;\n      }\n    }\n\n    i=1;\n    while(u.back()!=v.back()){\n      u.push_back(v[i]);\n      i++;\n\n      int l=u.size();\n      if(l<3) continue;\n      if(cp(u[l-1]-u[l-2],u[l-3]-u[l-2])<0) continue;\n      else{\n\tu.pop_back();\n\tu.pop_back();\n\ti--;\n      }\n    }\n\n    //u.front()==b.front()==v.front(), u.back()==b.back()==v.back()\n    //??§???????????????2????????????u,v??§??????????????????\n    cout << n-(b.size()+u.size()-2) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N_MAX 100\n#define sz stack.size()\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\nvector<P> v;\ndouble x,y;\nint n,ans;\nP a;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n \ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // テ」ツδ凖」ツつッテ」ツδ暗」ツδォ(b-a)テ」ツ?ョテ・ツキツヲテ・ツ?エテ」ツ?ォテ」ツδ凖」ツつッテ」ツδ暗」ツδォ(c-a)テ」ツ?古・ツュツ佚・ツ慊ィテ」ツ?凖」ツつ凝」ツ??\n  if(cross(b,c) < -EPS) return -1; // テ」ツδ凖」ツつッテ」ツδ暗」ツδォ(b-a)テ」ツ?ョテ・ツ渉ウテ・ツ?エテ」ツ?ォテ」ツδ凖」ツつッテ」ツδ暗」ツδォ(c-a)テ」ツ?古・ツュツ佚・ツ慊ィテ」ツ?凖」ツつ凝」ツ??\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nvector<P> convex_hull2(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      scanf(\"%lf,%lf\",&x,&y);\n      a.real()=x;\n      a.imag()=y;\n      v.push_back(a);\n    }\n    ans=0;\n    vector<P> r=convex_hull2(v);\n    for(int i=0;i<n;i++){\n      int f=0;\n      for(int j=0;j<r.size();j++)\n\tif(isIntersectSP(L(r[j],r[(j+1)%r.size()]),v[i]))f=1;\n      if(!f)ans++;\n    }\n    cout<<ans<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<string.h>\n#include<math.h>\n#include<functional>\n\nusing namespace std;\n\n\n\nint main(){\n    \n    \n    int count = 0;\n    pair<double, double> xy[100];\n    while(cin>>count){\n        \n        if(count==0)break;\n        for(int i=0; i<count; i++)scanf(\"%lf,%lf\",&xy[i].first,&xy[i].second);\n        sort(xy,xy+count);\n        int now = 0;\n        int end = count;\n        while(now<end-1){\n            double max = INTMAX_MIN;\n            int max_n = now;\n            for(int i=now+1; i<end; i++){\n                double temp;\n                double x = xy[i].first-xy[now].first;\n                double y = xy[i].second-xy[now].second;\n                if(x==0){\n                    if(y>0)temp=INTMAX_MAX;\n                    else temp= INTMAX_MIN+1;\n                }else{\n                    temp = y/x;\n                }\n                if(temp>max){\n                    max = temp;\n                    max_n = i;\n                }\n            }\n            now = max_n;\n            count--;\n        }\n        now = 0;\n        while(now<end-1){\n            double min = INTMAX_MAX;\n            int min_n = now;\n            for(int i=now+1; i<end; i++){\n                double temp;\n                double x = xy[i].first-xy[now].first;\n                double y = xy[i].second-xy[now].second;\n                if(x==0){\n                    if(y>0)temp=INTMAX_MAX-1;\n                    else temp= INTMAX_MIN;\n                }else{\n                    temp = y/x;\n                }\n                if(temp<min){\n                    min = temp;\n                    min_n = i;\n                }\n            }\n            now = min_n;\n            count--;\n        }\n        cout<<count<<endl;\n        \n        \n    }\n    \n    \n    \n\n        \n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <iterator>\n#include <stdlib.h>\n#include <map>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <set>\n#include <list>\n\nusing namespace std;\n\n// vector cout\ntemplate<typename _Ty>\nostream& operator << (ostream& os, const vector<_Ty>& v) {\n\tos << \"{\";\n\tfor (size_t i = 0; i < v.size(); i++)\n\t{\n\t\tif (i != 0) os << \", \";\n\t\tos << v[i];\n\t}\n\tos << \"}\";\n\n\treturn os;\n}\n\n//point\nclass Point {\npublic:\n\tdouble x;\n\tdouble y;\n\n\tPoint() {\n\t\tx = 0; y = 0;\n\t}\n\tPoint(int x, int y) {\n\t\tthis->x = x; this->y = y;\n\t}\n\n\tbool operator<(const Point& a) const {\n\t\tif (x == a.x)\n\t\t\treturn y < a.y;\n\t\telse\n\t\t\treturn x < a.x;\n\t}\n};\n\n//point cout\nostream& operator << (ostream& os, const Point& p) {\n\treturn os << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\n\nvoid rec(list<Point*>& Hull, list<Point*>& Points, Point* p1, Point* p2, int sgn) {\n\n\tdouble MaxDistance = 0;\n\tPoint* pMaxDistance = NULL;\n\tlist<Point*>::iterator it; //iterator\n\n\t//sgn?????????????????¨?????????\n\tlist<Point*> sgnPoints;\n\n\t//sgn ????????????????????§??´??? p1-p2 ??????????????¢?????§??????????±???????\n\tfor (it = Points.begin(); it != Points.end(); it++)  // list???????°??????§\n\t{\n\t\tPoint* p = *it;\n\t\tdouble d = (p2->x - p1->x)*(p->y - p1->y) - (p2->y - p1->y)*(p->x - p1->x);\n\n\t\t//0 ????????´???????????£?????? sgn ??????????????¨\n\t\tdouble reg = sgn * d;\n\n\t\t//??´????????§????????°??????\n\t\tif (abs(reg) < 1e-8) {\n\t\t\tPoints.erase(it);\n\t\t\tcontinue;\n\t\t}\n\n\t\t//??£?????????????????????????????¢?????????\n\t\tif (reg > 0) {\n\t\t\tsgnPoints.push_back(*it);\n\n\t\t\tif (abs(d) > MaxDistance) {\n\t\t\t\tMaxDistance = abs(d);\n\t\t\t\tpMaxDistance = p;\n\t\t\t}\n\t\t}\n\t}\n\n\t//?????¨??????????????°??????\n\tif (pMaxDistance == NULL) return;\n\n\t//p0 ??????????????????\n\tPoint* p0 = pMaxDistance;\n\tHull.push_back(p0);\n\tPoints.remove(p0);\n\tsgnPoints.remove(p0);\n\n\t//????§???¢ p0, p1, p2 ?????¨????????¨??????????????????\n\tfor (it = sgnPoints.begin(); it != sgnPoints.end(); it++) {\n\t\tPoint* pl = *it;\n\n\t\tPoint* p[3] = { p0, p1, p2 };\n\t\t//cross product\n\t\tdouble cp[3];\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcp[i] = (p[(i + 1) % 3]->x - p[i]->x)*(pl->y - p[i]->y) - (p[(i + 1) % 3]->y - p[i]->y)*(pl->x - p[i]->x);\n\t\t}\n\t\t//?????¨???????????????\n\t\tif ((cp[0] < 0 && cp[1] < 0 && cp[2] < 0) || (cp[0] > 0 && cp[1] > 0 && cp[2] > 0)) {\n\t\t\t//??????\n\t\t\tPoints.remove(*it);\n\t\t}\n\t}\n\n\t//??´??? (p0, p1) ???????????? p2 ????¬????\n\tdouble sp2 = (p1->x - p0->x)*(p2->y - p0->y) - (p1->y - p0->y)*(p2->x - p0->x);\n\tif (sp2 < 0) rec(Hull, Points, p0, p1, 1);\n\telse rec(Hull, Points, p0, p1, -1);\n\n\t//??´??? (p0, p2) ???????????? p1 ????¬????\n\tdouble sp1 = (p2->x - p0->x)*(p1->y - p0->y) - (p2->y - p0->y)*(p1->x - p0->x);\n\tif (sp1 < 0) rec(Hull, Points, p0, p2, 1);\n\telse rec(Hull, Points, p0, p2, -1);\n\n\treturn;\n}\n\nint convexhull(vector<Point>& vPoints)\n{\n\t//sort\n\tsort(vPoints.begin(), vPoints.end());\n\n\t//list ??? vPoints ??????????´???????????????????????´?\n\tlist<Point*> lPoints;\n\tfor (int i = 0; i < vPoints.size(); i++)\n\t{\n\t\tlPoints.push_back(&vPoints[i]);\n\t}\n\n\t//??????????§?????????????????????????\n\tlist<Point*> Hull;\n\n\t//x??§?¨?????°????????????§?????????????????????\n\tHull.push_back(lPoints.front());\n\tHull.push_back(lPoints.back());\n\n\t//p1, p2\n\tPoint* p1 = lPoints.front();\n\tPoint* p2 = lPoints.back();\n\n\t//??????\n\tlPoints.pop_front();\n\tlPoints.pop_back();\n\n\t//?¬??????£???????????¢?´¢\n\trec(Hull, lPoints, p1, p2, 1);\n\t//?¬??????????????????¢?´¢\n\trec(Hull, lPoints, p1, p2, -1);\n\n\treturn vPoints.size() - Hull.size();\n}\n\nint main() {\n\n\twhile (1) {\n\n\t\tint n;\n\t\tvector<Point> Points;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tPoint p;\n\t\t\tstring input;\n\t\t\tcin >> input;\n\n\t\t\tstringstream ss(input);\n\n\t\t\tss >> p.x;\n\t\t\tss.ignore();\n\t\t\tss >> p.y;\n\n\t\t\tPoints.push_back(p);\n\t\t}\n\t\tcout << convexhull(Points) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <complex>\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble stod (string str )\n{\n\tstringstream ss (str );\n\tdouble res;\n\n\tss >> res;\n\n\treturn res;\n}\n\nbool cmp (P a, P b )\n{\n\tif (a.real() != b.real() )\n\t\treturn a.real() < b.real();\n\n\treturn a.imag() > b.imag();\n}\n\n// OÏ (cross product) : a~b = |a||b|sinÆ\ndouble cross(P a, P b )\n{\n\tdouble res = a.real() * b.imag() - a.imag() * b.real();\n\n  return res;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.rubber\", \"r\", stdin );\n\tint n;\n\twhile (cin >> n, n ){\n\n\t\tif (n == 3 ){\n\t\t\tcout << n << endl;\n\t\t\treturn 0;\n\t\t} // end if\n\n\t\tvector <P> pos (n);\n\t\tfor (int i = 0; i < n; i++ ){\n\t\t\tstring str = \"\";\n\t\t\tcin >> str;\n\t\t\tdouble x = stod (str.substr (0, str.find (',') ) );\n\t\t\tdouble y = stod (str.substr (str.find (',') + 1) );\n\t\t\tP p; p.real() = x; p.imag() = y;\n\t\t\tpos[i] = p;\n\t\t} // end for\n\n\t\t// Åà¶[Ì_AxÀWª¯¶ÈçyÀWªå«¢_ÉÈéæ¤É\\[g\n\t\tsort (pos.begin(), pos.end(), cmp );\n\t\t\n\t\tvector <P> u, d;\n\t\tu.push_back (pos[0] );\n\t\tfor (int i = 1; i < pos.size(); i++ ){\n\t\t\tif (pos[i].imag() >= pos[0].imag() ){\n\t\t\t\tu.push_back (pos[i] );\n\t\t\t}else{\n\t\t\t\td.push_back (pos[i] );\n\t\t\t} // end if\n\t\t} //end for\n\n\t\t// ã¼ªÌTõ\n\t\tvector <P> U;\n\t\tU.push_back (u[0] );\n\t\tif (u.size() >= 2 ){\n\t\t\tU.push_back (u[1] );\n\t\t}// end if\n\t\tif (u.size() > 2 ){\n\t\t\tfor (int i = 2; i < u.size(); i++ ){\n\t\t\t\tU.push_back (u[i] );\n\t\t\t\tif (U.size() >= 3 ){\n\t\t\t\t\tint last  = U.size() - 1;\n\t\t\t\t\tint mid   = U.size() - 2;\n\t\t\t\t\tint first = U.size() - 3;\n\t\t\t\t\t// ÅãÌ_ªEñèÈç½àµÈ¢\n\t\t\t\t\tif (cross (U[mid] - U[first], U[last] - U[first] ) < 0. ){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// ÅãÌ_ª¼üãÉÚÁÄ¢éÜ½Í¶ñèÉ é\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvector <P>::iterator it = U.begin();\n\t\t\t\t\t\tfor (; it != U.end(); ++it ){\n\t\t\t\t\t\t\tif ((*it) == U[mid] ){\n\t\t\t\t\t\t\t\tU.erase (it );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} // end if\n\t\t\t\t\t\t} // end for\n\t\t\t\t\t} // end if\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end if\n\n\t\t// º¼ªÌTõ\n\t\tvector <P> D;\n\t\tif (!d.empty() ) {\n\t\t\tif (d.size() == 1 ){\n\t\t\tD.push_back (d[0] );\n\t\t\t}else\n\t\t\tif (d.size() >= 2 ){\n\t\t\t\tint m = d.size();\n\t\t\t\tD.push_back (d[m-1] ); D.push_back (d[m-2] );\n\t\t\t\tif (m >= 3 ){\n\t\t\t\t\tfor (int i = m - 3; i >= 0 ; i-- ){\n\t\t\t\t\t\tD.push_back (d[i] );\n\t\t\t\t\t\tif (D.size() >= 3 ){\n\t\t\t\t\t\t\tint last  = D.size() - 1;\n\t\t\t\t\t\t\tint mid   = D.size() - 2;\n\t\t\t\t\t\t\tint first = D.size() - 3;\n\t\t\t\t\t\t\t// ÅãÌ_ªEñèÈç½àµÈ¢\n\t\t\t\t\t\t\tif (cross (D[mid] - D[first], D[last] - D[first] ) < 0. ){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t// ÅãÌ_ª¼üãÉÚÁÄ¢éÜ½Í¶ñèÉ é\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tvector <P>::iterator jt = D.begin();\n\t\t\t\t\t\t\t\tfor (; jt != D.end(); ++jt ){\n\t\t\t\t\t\t\t\t\tif ((*jt) == D[mid] ){\n\t\t\t\t\t\t\t\t\t\tD.erase (jt );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} // end if\n\t\t\t\t\t\t\t\t} // end for\n\t\t\t\t\t\t\t} // end if\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t} // end for\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // end if\n\n\t\t// ã¼ªÆº¼ªð}[W\n\t\tvector <P> R;\n\t\tif (!U.empty() )\n\t\t\tfor (int i = 0; i < U.size(); i++ )\n\t\t\t\tR.push_back (U[i] );\n\n\t\tif (!D.empty() ){\n\t\t\tfor (int i = 0; i < D.size(); i++ ){\n\t\t\t\tbool found = false;\n\t\t\t\tfor (int j = 0; j < R.size(); j++ ){\n\t\t\t\t\tif (EQ (R[j], D[i] ) ){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end for\n\t\t\t\tif (found ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tR.push_back (D[i] );\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end if\n\n//\t\tfor (int i = 0; i < R.size(); ++i ){\n//\t\t\tcout << '(' << R[i].real() << ',' << R[i].imag() << ')' << endl;\n//\t\t} // end for\n\n\t\tcout << ( pos.size() - R.size()) << endl;\n\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nstruct P{ double x, y; };\nbool operator == (P x, P y)\n{   return x.x == y.x && x.y == y.y;    }\nbool operator != (P x, P y)\n{   return !(x == y);  }\nbool operator < (P x, P y)\n{ return x.x < y.x || (x.x == y.x && x.y < y.x); }\n\nint main()\n{    \n    int n;\n    while(cin >> n && n)\n    {\n        vector<P> points(n); char k;\n        rep(i, n)\n            cin >> points[i].x >> k >> points[i].y;\n        \n        sort(ALL(points));\n        \n        int res = 0;\n        P s = points[0];\n        P begin = s;\n        \n        double mrad = PI * 3 / 2;\n        do\n        {\n            res++;\n            vector<P>::iterator deleted;\n            \n            double irad = 0;\n            for(vector<P>::iterator it = points.begin() + (res == 1); it != points.end(); it++)\n            {\n                double rad = atan2((*it).y - begin.y, (*it).x - begin.x);\n                rad = rad < 0 ? 2 * PI + rad : rad;\n                \n                rad = rad < mrad ? 2 * PI - mrad + rad : rad - mrad;\n                if(it == points.begin() + (res == 1) || irad < rad)\n                {\n                    deleted = it;\n                    irad = rad;\n                }\n            }\n            mrad += irad;\n            if(2 * PI <= mrad) mrad -= 2 * PI;\n            \n            begin = *deleted;\n            points.erase(deleted);\n        }\n        while(begin != s);\n        \n        cout << n - res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\nbool cmp(complex<double> a,complex<double> b){\n  if(a.real()!=b.real()) return a.real()<b.real();\n  return a.imag()<b.imag();\n}\nint main(){\n  int n;\n  complex<double> R9(0.0,1.0);\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0) return 0;\n    complex<double> p[n];\n    for(int i=0;i<n;++i){\n      scanf(\"%lf,%lf\",&p[i].real(),&p[i].imag());\n    }\n    sort(p,p+n,cmp);\n    int k=0;\n    complex<double> q[n*2];\n    for(int i=0;i<n;i++){\n      while(k>1&&arg(q[k-1]-q[k-2])>arg(p[i]-q[k-1])) k--;\n      q[k++]=p[i];\n    }\n    for(int i=n-2,t=k;i>=0;i--){\n      while(k>t&&arg((q[k-1]-q[k-2])*R9)>arg((p[i]-q[k-1])*R9)) k--;\n      q[k++]=p[i];\n    }\n    printf(\"%d\\n\",n-k+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\nstruct Point : public complex<double>\n{\npublic:\n  Point() { this->real(0);  this->imag(0); }\n  Point(const double& x, const double& y) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // 内積\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // 外積\n};\n\nnamespace std\n{\n  bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nint ccw(Point a, Point b, Point c)\n{\n  b -= a;\n  c -= a;\n  if(b.det(c) > 0.0)    return  1;\n  if(b.det(c) < 0.0)    return -1;\n  if(b.dot(c) < 0.0)    return  2;\n  if(norm(b) < norm(c)) return -2;\n  return 0.0;\n}\n\ntypedef vector<Point> Polygon;\n\n// O(nlogn)\nvector<Point> AndrewMonotoneChain(vector<Point> ps)\n{\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<Point> ch(2*n);\n  for(int i=0; i<n; ch[k++]=ps[i++]) // lower-hull\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i=n-2, t=k+1; i>= 0; ch[k++]=ps[i--]) // upper-hull\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint n;\ndouble x, y;\n\nint main()\n{\n  while((cin >> n) && n){\n    Polygon ply;\n    rep(i, n){\n      scanf(\"%lf,%lf\", &x, &y);\n      ply.pb(Point(x, y));\n    }\n    cout << ply.size() - AndrewMonotoneChain(ply).size() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n#define R(i,a,n) for(int i=a;i<n;i++)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\nstruct Circle{\n  Point c;\n  double r;\n};\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶???????????????absolute  ?????????????????¶?????????\ndouble abs(Point p){return sqrt(norm(p));}\n//?????????????????????????????????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? ????????????????????????\ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ??????????????´???????????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°??????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   ???????????????\ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)???????????????\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢??????????????????\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????????????????????????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//????????????????????????????????????????????§?\\????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢?????????????????????????????§??¨???????????????\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//??????????????????????????????(?´????????`)\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//???????£????????????¢??????????????¢??????????????????????????\\????????????????????§???????????£???????????????????????????????????§?????????????????????\nint intersectCC(Circle a,Circle b){\n  double dist=abs(a.c-b.c);\n  if(dist>a.r+b.r+EPS)return 4;\n  if(dist>a.r+b.r-EPS)return 3;\n  if(dist>abs(a.r-b.r)+EPS)return 2;\n  if(dist>abs(a.r-b.r)-EPS)return 1;\n  return 0;\n}\n//?????¨??´???????????????2?????? (LINE)\nseg getCrossPoint(Circle c,seg l){\n  //assert(intersect(cc,l));\n  Point pr=project(l,c.c);\n  Point e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base =sqrt(c.r*c.r-norm(pr-c.c));\n  seg pp;pp.p1=(pr+e*base);pp.p2=(pr-e*base);\n  return pp;\n}\n//?????¨??´??????Line??????????????°\nint getCircleLine(Circle c,seg l){\n  seg a=getCrossPoint(c,l);\n  if(isnan(a.p1.x)&&isnan(a.p2.y))return 0;\n  else if(a.p1.x==a.p2.x&&a.p1.y==a.p2.y)return 1;\n  else return 2;\n}\n//??????\nPoint gaishin(Point a, Point b, Point c){\n  double a1,a2,b1,b2,c1,c2;\n  a1=2*(b.x-a.x);b1=2*(b.y-a.y);c1=a.x*a.x-b.x*b.x+a.y*a.y-b.y*b.y;\n  a2=2*(c.x-a.x);b2=2*(c.y-a.y);c2=a.x*a.x-c.x*c.x+a.y*a.y-c.y*c.y;\n  Point p;p.x=(b1*c2-b2*c1)/(a1*b2-a2*b1);p.y=(c1*a2-c2*a1)/(a1*b2-a2*b1);\n  return p;\n}\n//2??????????????????\ndouble arg(Point p){return atan2(p.y,p.x);}\nPoint polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\nseg getCrossPoints(Circle c1,Circle c2){\n  //assert(intersect(c1,c2));\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  seg s;s.p2=c1.c+polar(c1.r,t+a);s.p1=c1.c+polar(c1.r,t-a);\n  return s;\n}\n//???????????? ????????????->2 ??????->1  ????????\\???->0\ntypedef vector<Point> Polygon;\nint contains(Polygon g, Point p) {\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++) {\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n  }\n  return x ? 2 : 0;\n}\n//?????¢?????¢???\ndouble Area(Polygon p) {\n  double a=0;\n  for(int i=0;i<p.size();i++)a+=cross(p[i],p[(i+1)%p.size()]);\n  return a/2;\n}\nbool isConvex(Polygon p){\n  for(int i=0;i<p.size();i++){\n    if(CCW(p[(i+1)%p.size()],p[i%p.size()],p[(i+2)%p.size()])==1)return false;\n  }\n  return true;\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon l, u;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<s.size();i++){\n    for(int n=u.size();n>=2&&CCW(u[n-2],u[n-1],s[i])!=-1&&CCW(u[n-2],u[n-1],s[i])!=ONLINE_FRONT;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&CCW(l[n-2],l[n-1],s[i])!=-1&&CCW(l[n-2],l[n-1],s[i])!=ONLINE_FRONT;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for( int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  return l;\n}\nint main(){\n  \n  int n;char t;\n  while(cin>>n,n){\nPolygon p,pp;\n  Point s;\n  r(i,n){\n    cin>>s.x>>t>>s.y;\n    p.push_back(s);\n  }pp=andrewScan(p);\n  cout<<n-pp.size()<<endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\ntypedef pair<double,double> pd;\n\npd D[100];\nint A[100];\nint n;\n\nint side(pd p1, pd p2){\n\tdouble dy=p2.first-p1.first,dx=p2.second-p1.second;\n\tfor(int i=0;i<n;i++){\n\t\tpd p3=D[i];\n\t\tif (p1==p3||p2==p3)continue;\n\t\tif ((p3.second-p1.second)*dy-dx*(p3.first-p1.first)<0) return 0;\n\t}\n    return 1;\n}\n\nint main(){\n\twhile (1){\n\t\tint i,s;\n\t\tpd p,p1,p2;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif (n==0) break;\n\t\tfor (i=0;i<n;i++){\n\t\t\tcin>>D[i].first>>c>>D[i].second;\n\t\t\tA[i]=0;\n\t\t}\n\t\tsort(D,D+n);\n\t\tp=D[0];\n\t\tp1=p;\n\t\ts=0;\n\t\twhile (1){\n\t\t\tfor (i=0;i<n;i++){\n\t\t\t\tp2=D[i];\n\t\t\t\tif (A[i]==0 && p1!=p2 && side(p1,p2)) break;\n\t\t\t}\n\t\t\tp1=p2;\n\t\t\tA[i]=1;\n\t\t\ts++;\n\t\t\tif (p2==p) break;\n\t\t}\n\t\tstd::cout<<n-s<<\"\\n\";\n\t\tfor (i=0;i<n;i++){\n\t\t\tD[i]=make_pair(0,0);\n\t\t\tA[i]=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ALL( c ) (c).begin(), (c).end()\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 )\n\t{\n\t\treturn;\n\t}\n\n\tPoint( double x, double y ) : x( x ), y( y )\n\t{\n\t\treturn;\n\t}\n\n\tPoint operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x - a.x, y - a.y );\n\t}\n\n\tPoint operator * ( const double &a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint operator / ( const double &a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n};\n\n// ??????\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// Graham Scan\nvector< Point > getConvex( vector< Point > ps )\n{\n\tconst int N = ps.size();\n\n\tsort( ALL( ps ) );\n\n\tint k = 0;\n\tvector< Point > convex( N * 2 );\n\n\tfor ( int i = 0; i < N; i++ )\n\t{\n\t\twhile ( 2 <= k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tfor ( int i = N - 2, t = k; 0 <= i; i-- )\n\t{\n\t\twhile ( t < k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.resize( k - 1 );\n\n\treturn convex;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< Point > ps( n );\n\n\t\tEACH( p, ps )\n\t\t{\n\t\t\tchar d;\n\n\t\t\tcin >> p.x >> d >> p.y;\n\t\t}\n\n\t\tvector< Point > convex = getConvex( ps );\n\n\t\tcout << n - convex.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n\ntypedef long double ld;\nconst ld PI = 3.141592653589793238462643383279;\n\nstruct po{\n\tld x;\n\tld y;\n\tpo(ld a){ x = a; y = 0; }\n\tpo(ld a,ld b){ x = a; y = b; }\n\tpo(){}\n\tinline ld operator()(const po& rhs) const {\n\t\treturn x*rhs.x+y*rhs.y;\n\t}\n\tinline ld norm() {\n\t\treturn sqrt((*this)(*this));\n\t}\n\tinline po& operator+=(const po& rhs){\n\t\tx += rhs.x;\n\t\ty += rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator-=(const po& rhs){\n\t\tx -= rhs.x;\n\t\ty -= rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator*=(const po& rhs){\n\t\tld x_ = x*rhs.x-y*rhs.y;\n\t\ty = x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\treturn *this;\n\t}\n\tinline po& operator/=(const po& rhs){\n\t\tld x_ = x*rhs.x+y*rhs.y;\n\t\ty = -x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\tld nor = rhs(rhs);\n\t\tx /= nor;\n\t\ty /= nor;\n\t\treturn *this;\n\t}\n\tinline void in(){\n\t\tscanf(\"%Lf%Lf\",&x,&y);\n\t}\n};\ninline po operator+(const po& a, const po& b){ return po(a) += b; }\ninline po operator-(const po& a, const po& b){ return po(a) -= b; }\ninline po operator*(const po& a, const po& b){ return po(a) *= b; }\ninline po operator/(const po& a, const po& b){ return po(a) /= b; }\n\ninline po similar(const po& a,const po& b,const po& c,const po& p,const po& q){\n\treturn p+(q-p)*(c-a)/(b-a);\n}\n\ntypedef pair<po,po> se;\n#define fr first\n#define sc second\n\nstruct li{\n\tld a;\n\tld b;\n\tld c;\n\tli(po p,po q){\n\t\ta = q.y-p.y;\n\t\tb = p.x-q.x;\n\t\tc = p.y*q.x-p.x*q.y;\n\t}\n\t/*explicit li(se s){\n\t\ta = s.sc.y-s.fr.y;\n\t\tb = s.fr.x-s.sc.x;\n\t\tc = s.fr.y*s.sc.x-s.fr.x*s.sc.y;\n\t\tli(s.fr,s.sc);\n\t}*/\n\tli(){}\n\tinline ld operator()(const po& p) const {\n\t\treturn a*p.x+b*p.y+c;\n\t}\n};\n\nvoid intersect(const li &l,const li &m,po* &ret){\n\tif(abs(l.a*m.b-m.a*l.b) <= 1e-18){\n\t\tret = nullptr;\n\t\treturn;\n\t}\n\tret = new po;\n\tret->x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret->y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n}\ninline bool on(const po &p,const se &s){\n\treturn (s.fr-p)(s.sc-p) <= 1e-9;\n}\nvoid intersect(const se &s,const se &t,po* &ret){\n\tli l = li(s.fr,s.sc);\n\tli m = li(t.fr,t.sc);\n\tpo *p;\n\tintersect(l,m,p);\n\tif(p == nullptr || (on(*p,s)&&on(*p,t)))ret = p;\n\telse{\n\t\tdelete p;\n\t\tret = nullptr;\n\t}\n}\ninline ld dist(const po &p,const po &q){\n\treturn sqrt((p-q)(p-q));\n}\ninline li perpen(const po &p,const li &l){\n\tli ret;\n\tret.a = l.b;\n\tret.b = -l.a;\n\tret.c = l.a*p.y-l.b*p.x;\n\treturn ret;\n}\ninline po perpen_leg(const po &p,const li &l){\n\tpo ret;\n\tli m = perpen(p,l);\n\tret.x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret.y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n\treturn ret;\n}\ninline ld dist(const po &p,const se &s){\n\tpo h = perpen_leg(p,li(s.fr,s.sc));\n\tif(on(h,s))return dist(p,h);\n\telse return min( dist(p,s.fr) , dist(p,s.sc) );\n}\ninline ld dist(const se &s,const se &t){\n\tpo *p;\n\tintersect(s,t,p);\n\tif(p != nullptr){\n\t\tdelete p;\n\t\treturn 0.0;\n\t}\n\tld ret = min( dist(s.fr,t) , dist(s.sc,t) );\n\tret = min( ret , min( dist(t.fr,s) , dist(t.sc,s) ) );\n\treturn ret;\n}\ninline ld dist(const po &p, const li &l){\n\treturn abs(l(p))/sqrt(l.a*l.a+l.b*l.b);\n}\n\nstruct ci{\n\tpo c;\n\tld r;\n\tinline bool internal(const po &p){\n\t\treturn dist(p,c) <= r+1e-9;\n\t}\n};\n\nci circum(const po &p,const po &q,const po &r){\n\tci ret;\n\tli l = perpen((p+q)/2.0,li(p,q));\n\tli m = perpen((q+r)/2.0,li(q,r));\n\tpo* _c;\n\tintersect(l,m,_c);\n\tif(_c == nullptr){\n\t\tret.c = po(0.0,0.0);\n\t\tret.r = -1.0;\n\t\treturn ret;\n\t}\n\telse {\n\t\tret.c = *_c;\n\t\tret.r = dist(ret.c,p);\n\t\tdelete _c;\n\t\treturn ret;\n\t}\n}\n\n\nvoid intersect(const li &l, const ci &c, po* &ret1, po* &ret2){\n\tld d = dist(c.c,l);\n\tif(d > c.r+1e-9){\n\t\tret1 = nullptr;\n\t\tret2 = nullptr;\n\t\treturn;\n\t}\n\tpo h = perpen_leg(c.c,l);\n\tif(abs(d-c.r) <= 1e-9){\n\t\tret1 = new po;\n\t\t*ret1 = h;\n\t\tret2 = nullptr;\n\t\treturn;\n\t}\n\tpo v = po(l.b,-l.a);\n\tv /= sqrt(v(v));\n\tv *= sqrt(c.r*c.r-d*d);\n\tret1 = new po;\n\t*ret1 = h+v;\n\tret2 = new po;\n\t*ret2 = h-v;\n\treturn;\n}\nvoid intersect(const ci &c, const ci &d, po* &ret1, po* &ret2){\n\tli l;\n\tl.a = 2*(c.c.x-d.c.x);\n\tl.b = 2*(c.c.y-d.c.y);\n\tl.c = d.c(d.c)-d.r*d.r-(c.c(c.c)-c.r*c.r);\n\tintersect(l,c,ret1,ret2);\n}\nvoid tangent(const po &p, const ci &c,li* &ret1,li* &ret2){\n\tci d;\n\td.c = (p+c.c)/2.0;\n\td.r = dist(p,c.c)/2.0;\n\tpo *q,*r;\n\tintersect(c,d,q,r);\n\tret1 = ret2 = nullptr;\n\tif(q == nullptr)return;\n\tret1 = new li;\n\t*ret1 = li(p,*q);\n\tdelete q;\n\tif(r == nullptr)return;\n\tret2 = new li;\n\t*ret2 = li(p,*r);\n\tdelete r;\n}\nvoid cotan_in(const ci &c, const ci &d, li* &ret1, li* &ret2){\n\tpo p = similar(-c.r,d.r,0.0,c.c,d.c);\n\ttangent(p,c,ret1,ret2);\n}\nvoid cotan_out(const ci &c, const ci &d, li* &ret1, li* &ret2){\n\tif(abs(c.r-d.r) < 1e-9){\n\t\tret1 = new li;\n\t\tret2 = new li;\n\t\t*ret1 = *ret2 = li(c.c,d.c);\n\t\tret1->c += c.r*sqrt(ret1->a*ret1->a+ret1->b*ret1->b);\n\t\tret2->c -= c.r*sqrt(ret1->a*ret1->a+ret1->b*ret1->b);\n\t\treturn;\n\t}\n\tpo p = similar(c.r,d.r,0.0,c.c,d.c);\n\ttangent(p,c,ret1,ret2);\n}\n\nld cross_product(const po& p, const po& q){\n\treturn p.x*q.y-p.y*q.x;\n}\n\n#include <vector>\n#include <algorithm>\n\nbool cmp(const po& p, const po& q){\n\tif(abs(p.x-q.x) > 1e-12)return p.x < q.x;\n\treturn p.y < q.y;\n}\nvector<po> convex(vector<po> points){\n\tsort(points.begin(),points.end(),cmp);\n\tvector<po> ret;\n\tfor(int i = 0 ; i < points.size() ; i ++){\n\t\twhile(ret.size() > 1 && cross_product(ret[ret.size()-1]-ret[ret.size()-2],points[i]-ret[ret.size()-2]) <= 0)ret.pop_back();\n\t\tret.push_back(points[i]);\n\t}\n\tint t = ret.size();\n\tfor(int i = points.size()-2 ; i >= 0 ; i --){\n\t\twhile(ret.size() > t && cross_product(ret[ret.size()-1]-ret[ret.size()-2],points[i]-ret[ret.size()-2]) <= 0)ret.pop_back();\n\t\tret.push_back(points[i]);\n\t}\n\tret.pop_back();\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tld x[102],y[102];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tscanf(\"%Lf,%Lf\",&x[i],&y[i]);\n\t\t}\n\t\tvector<po> vec;\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tvec.push_back(po(x[i],y[i]));\n\t\t}\n\t\tvec = convex(vec);\n\t\tprintf(\"%d\\n\",n-vec.size());\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <array>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define eq(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-8;\nconst double EPS_GIG = 1e-3;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\n\n// 扇型、中心と半径、二つの端点\n// 現在中心角が180未満の前提\nstruct sector {\n\tpoint o;\n\tpoint a, b;\n\tdouble r;\n\tsector(){}\n\tsector(point O, point A, point B, double _r) :o(O), a(A), b(B), r(_r) {}\n};\n\nstruct segment : public array<point, 2> {\n\tsegment(const point &a, const point &b) {\n\t\tat(0) = a;\n\t\tat(1) = b;\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > 2 * PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS)   return +1;       // counter clockwise\n\tif (cross(b, c) + EPS < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\tauto a = s[0] - p;\n\tauto b = s[1] - p;\n\treturn (abs(cross(a, b)) < EPS && dot(a, b) <= EPS); // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n//端点の交差hは考えない\nbool strictIntersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) == -1 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) == -1;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n/*多角形内包判定\nhalf-line crossing method\nOUT:0\nON:1\nIN:2\n*/\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) < EPS && EPS < imag(b) && cross(a, b) > EPS)in = !in;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n/*\nOUT:0\nON:1\nIN:2\n*/\nint contain_sector(const sector &sec, point &p){\n\tif(eq(abs(p - sec.o), sec.r))return 1;\n\tif(intersectSP(segment(sec.o, sec.a), p))return 1;\n\tif(intersectSP(segment(sec.o, sec.b), p))return 1;\n\tif(abs(p - sec.o) + EPS > sec.r)return 0;\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(angle(vec, vecA) + EPS < angle(vecA, vecB) && angle(vec, vecB) + EPS < angle(vecA, vecB))return 2;\n\treturn 0;\n}\n\n//交点\npoint crosspointSS(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<point> crosspointCL(const circle &c, const segment &l) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto pro_p = projection(l, c.p);\n\tauto dist = distanceLP(l, c.p);\n\tif(abs(dist - c.r) < EPS){\n\t\tret[0] = pro_p;\n\t\treturn ret;\n\t}\n\tif(c.r < dist){\n\t\treturn ret;\n\t}\n\tpoint vec = (l[1] - l[0]) * sqrt(c.r * c.r - dist * dist) / abs(l[1] - l[0]);\n\tret[0] = pro_p + vec;\n\tret[1] = pro_p - vec;\n\treturn ret;\n}\n\nvector<point> crosspointCC(const circle c1, const circle c2) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto dist = abs(c2.p - c1.p);\n\tif(eq(dist, c1.r + c2.r) || eq(dist, abs(c2.r - c1.r))){\n\t\tauto tmp = c2.p - c1.p;\n\t\tret[0] = c1.p + tmp * (c1.r / dist);\n\t\treturn ret;\n\t}\n\tif(c1.r + c2.r < dist || dist < abs(c1.r - c2.r)){\n\t\treturn ret;\n\t}\n\tauto alpha = acos((c1.r * c1.r + dist * dist - c2.r * c2.r) / (2 * c1.r * dist));\n\tauto theta = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n\tret[0] = c1.p + point(cos(theta + alpha) * c1.r, sin(theta + alpha) * c1.r);\n\tret[1] = c1.p + point(cos(theta - alpha) * c1.r, sin(theta - alpha) * c1.r);\n\treturn ret;\n}\n\nbool isOnSector(const sector sec, const point p) {\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(eq(angle(vec, vecA) + angle(vec, vecB), angle(vecA, vecB)))return true;\n\treturn false;\n}\n\nvector<point> crosspointSecS(const sector sec, const segment s) {\n\tcircle c = circle(sec.o, sec.r);\n\tauto ret = crosspointCL(c, s);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(eq(ret[i], inf))continue;\n\t\tif(!isOnSector(sec, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!intersectSP(s, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\nvector<point> crosspointSecSec(const sector sec1, const sector sec2) {\n\tcircle c1 = circle(sec1.o, sec1.r);\n\tcircle c2 = circle(sec2.o, sec2.r);\n\tauto ret = crosspointCC(c1, c2);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(!isOnSector(sec1, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isOnSector(sec2, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a + b) * 0.5;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= EPS) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tif(ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]) == -1)return false;\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointSS(segment(A, B), l));\n  }\n  return Q;\n}\n\npoint max_circle_size_in_polygon_check(double mid, vector<point> &v){\n\tll n = v.size();\n\tvector<point> now(v);\n\tREP(i, n){\n\t\tauto a = v[i];\n\t\tauto b = v[(i+1)%n];\n\t\tauto vec = b - a;\n\t\tvec /= abs(vec);\n\t\tvec *= mid;\n\t\tvec = vec * point(0, 1);\n\t\tsegment seg = segment(a + vec, b + vec);\n\t\tnow = convex_cut(now, seg);\n\t}\n\treturn (now.empty() ? point(INF, INF): now[0]);\n}\n\n// 凸多角形に入る最大の円\ncircle max_circle_size_in_polygon(vector<point> &v){\n\tdouble l = 0;\n\tdouble r = convex_diameter(v);\n\tpoint ret;\n\tREP(_, 1000){\n\t\tif(abs(l - r) < EPS)break;\n\t\tdouble mid = (l + r) / 2;\n\t\tret = max_circle_size_in_polygon_check(mid, v);\n\t\tif(ret != point(INF, INF))l = mid;\n\t\telse r = mid;\n\t}\n\treturn circle(ret, l);\n}\n\n//　三角形の外接円\ncircle circumscribed_circle(vector<point> p) {\n\tsegment seg_a = segment((p[1] + p[0]) * 0.5,\n\t(p[1] + p[0]) * 0.5 + (p[1] - p[0]) * point(0, 1));\n\tsegment seg_b = segment((p[2] + p[1]) * 0.5,\n\t(p[2] + p[1]) * 0.5 + (p[2] - p[1]) * point(0, 1));\n\tcircle ret;\n\tret.p = crosspointSS(seg_a, seg_b);\n\tret.r = distancePP(p[0], ret.p);\n\treturn ret;\n}\n\nint main(){\n\n\tll n;\n\twhile(cin >> n, n){\n\t\tvector<point> p;\n\t\tREP(i, n){\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tp.EB(x, y);\n\t\t}\n\t\tcout << n - convex_hull(p).size() << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nstruct point{\n\tdouble x;\n\tdouble y;\n\n\tbool operator != ( point& p )\n\t{\n\t\treturn ( x != p.x || y != p.y );\n\t}\n\tbool operator == ( point& p )\n\t{\n\t\treturn ( x == p.x && y == p.y );\n\t}\n};\n\npoint getLeftPoint( int n , point *points );\ndouble getCrossProduct( const point& a , const point& b , const point& o );\npoint operator - ( const point& a , const point& b );\nistream& operator >> ( istream& s , point& p );\n\nint main(void)\n{\n\tpoint points[100];\n\tint n;\n\tint ans;\n\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif( n == 0 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> points[i];\n\t\t}\n\n\t\tpoint leftPoint = getLeftPoint( n , points );\n\t\tpoint stdPoint = leftPoint;\n\t\tpoint outsideLeftPoint;\n\t\tint vertexCounter = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t\t{\n\t\t\t\tint flag = 0;\n\t\t\t\tif( points[i] != stdPoint )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < n ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( points[j] != stdPoint )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( getCrossProduct( points[i] , points[j] , stdPoint ) > 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( flag == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\toutsideLeftPoint = points[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstdPoint = outsideLeftPoint;\n\t\t\tvertexCounter++;\n\t\t\tif( outsideLeftPoint == leftPoint )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans = n - vertexCounter;\n\t\tstd::cout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\npoint getLeftPoint( int n , point *points )\n{\n\tpoint leftPoint = points[0];\n\tfor( int i = 1 ; i < n ; i++ )\n\t{\n\t\tif( points[i].x < leftPoint.x )\n\t\t{\n\t\t\tleftPoint = points[i];\n\t\t}\n\t}\n\treturn leftPoint;\n}\n\ndouble getCrossProduct( const point& a , const point& b , const point& o )\n{\n\tpoint ao = a - o;\n\tpoint bo = b - o;\n\treturn (ao.x * bo.y) - (ao.y * bo.x);\n}\n\npoint operator - ( const point& a , const point& b )\n{\n\tpoint p;\n\tp.x = a.x - b.x;\n\tp.y = a.y - b.y;\n\treturn p;\n}\n\nistream& operator >> ( istream& s , point& p )\n{\n\tchar c;\n\treturn s >> p.x >> c >> p.y;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 10000000;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem0068 : Enclose Pins with a Rubber Band **/\n// Implementation of Andrew's monotone chain 2D convex hull algorithm.\n// Asymptotic complexity: O(n log n).\n// Practical performance: 0.5-1.0 seconds for n=1000000 on a 1GHz machine.\ntypedef double coord_t;         // coordinate type\ntypedef double coord2_t;  // must be big enough to hold 2*max(|coordinate|)^2\n\nstruct Point {\n\tcoord_t x, y;\n\t\n\tbool operator <(const Point &p) const {\n\t\treturn x < p.x || (x == p.x && y < p.y);\n\t}\n};\n\n// 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.\n// Returns a positive value, if OAB makes a counter-clockwise turn,\n// negative for clockwise turn, and zero if the points are collinear.\ncoord2_t cross(const Point &O, const Point &A, const Point &B)\n{\n\treturn (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\n// Returns a list of points on the convex hull in counter-clockwise order.\n// Note: the last point in the returned list is the same as the first one.\nvector<Point> convex_hull(vector<Point> P)\n{\n\tint n = (int)P.size(), k = 0;\n\tvector<Point> H(2*n);\n\t\n\t// Sort points lexicographically\n\tsort(P.begin(), P.end());\n\t\n\t// Build lower hull\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0) k--;\n\t\tH[k++] = P[i];\n\t}\n\t\n\t// Build upper hull\n\tfor (int i = n-2, t = k+1; i >= 0; i--) {\n\t\twhile (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0) k--;\n\t\tH[k++] = P[i];\n\t}\n\t\n\tH.resize(k);\n\treturn H;\n}\n\nint main()\n{\n\tint N;\n\t\n\twhile (cin>>N, N) {\n\t\tvector<Point> points;\n\t\tvector<Point> ch;\n\t\tchar c;\n\n\t\trep(k, N) {\n\t\t\tPoint p;\n\t\t\tcin >> p.x >> c >> p.y;\n\t\t\tpoints.push_back(p);\n\t\t}\n\t\t\n\t\tch = convex_hull(points);\n\t\tcout << (int)points.size()-((int)ch.size()-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n#define size_of(a) (int)a.size()\n\ntypedef double Double;\n\nconst Double EPS = 1e-9;\n\ntypedef struct Point {\n\tDouble x, y;\n\tPoint(Double _x, Double _y) : x(_x), y(_y) {}\n} Vector;\n\nPoint operator - (const Point& a, const Point& b) { return Point(a.x - b.x, a.y - b.y); }\nbool operator < (const Point& a, const Point& b) {\n\treturn a.x != b.x ? a.x < b.x : a.y < b.y;\n}\nbool operator > (const Point& a, const Point& b) {\n\treturn a.x != b.x ? a.x > b.x : a.y > b.y;\n}\nbool operator == (const Point& a, const Point& b) {\n\treturn fabs(a.x - b.x) < EPS && fabs(a.y - b.y) < EPS;\n}\n\nDouble norm(const Point& a) { return a.x * a.x + a.y + a.y; }\nDouble abs(const Point& a) { return sqrt(norm(a)); }\nDouble dot(const Vector& a, const Vector& b) { return a.x * b.x * a.y * b.y; }\nDouble cross(const Vector& a, const Vector& b) { return a.x * b.y - a.y * b.x; }\n\nint ccw(const Point& a, const Point& b, const Point& c) {\n\tVector ba = b - a, ca = c - a;\n\tif (cross(ba, ca) > EPS) return +1;\n\tif (cross(ba, ca) < -EPS) return -1;\n\tif (dot(ba, ca) < -EPS) return +2;\n\tif (abs(ba) + EPS < abs(ca)) return -2;\n\treturn 0;\n}\n\nint convex_hull(vector< Point >& vp) {\n\tint n = size_of(vp), k = 0;\n\t\n\tsort(allof(vp));\n\tvector< Point > ch(2 * n, Point(0, 0));\n\t\n\tfor (int i = 0; i < n; ch[k++] = vp[i++]) {\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], vp[i]) <= 0) --k;\n\t}\n\t\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = vp[i--]) {\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], vp[i]) <= 0) --k;\n\t}\n\t\n\treturn k - 1;\n}\n\nint main() {\n\tint n;\n\t\n\twhile (cin >> n, n) {\n\t\tvector< Point > vp;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tchar c;\n\t\t\tDouble x, y; cin >> x >> c >> y;\n\t\t\tvp.push_back(Point(x, y));\n\t\t}\n\t\t\n\t\tcout << n - convex_hull(vp) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<vector>\n#include<list>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\n#define EACH(v,c) for(auto&v:c)\ndouble EPS=1e-10;\n\nstruct P {\n    double x,y;\n    P() : x(0),y(0) {\n        return; \n    }\n    P(double x,double y) : x(x),y(y) {\n        return; \n    }\n\n    P operator + (const P &a) {\n        return P(x+a.x,y+a.y);\n    }\n    P operator - (const P &a) {\n        return P(x-a.x,y-a.y);\n    }\n    P operator * (const double a) {\n        return P(x*a,y*a);\n    }\n    P operator / (const double a) {\n        return P(x/a,y/a);\n    }\n\n    bool operator < (const P &a) {\n        return x==a.x?y<a.y:x<a.x;\n    }\n};\n\ndouble cross(const P &a, const P &b) {\n   return a.x*b.y-a.y*b.y;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n    const int n=ps.size();\n    sort(ps.begin(),ps.end());\n    int k=0;\n\n    vector<P> qs(n*2);\n    for (int i=0;i<n;++i) {\n        while (k>1 && cross(qs[k-1]-qs[k-2], ps[i]-qs[k-1])<=0) k--;\n        qs[k++]=ps[i];\n    }\n\n    for (int i=n-2,t=k;i>=0;--i) {\n        while (k>t && cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    for (;;) {\n        int n;\n        scanf(\"%d\",&n);\n        if (n==0) break;\n        vector< P > ps(n);\n        EACH(p,ps) {\n            char d;\n            cin >> p.x >> d >> p.y;\n        }\n\n        vector< P > qs=convex_hull(ps);\n        printf(\"%d\\n\",n-qs.size());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst double PI = 3.14159;\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tvector<double> x; x.reserve(100);\n\t\tvector<double> y; y.reserve(100);\n\t\tdouble tmp_x, tmp_y;\n\t\tchar dummy;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tcin >> tmp_x >> dummy >> tmp_y;\n\t\t\tx.push_back(tmp_x); y.push_back(tmp_y);\n\t\t}\n\t\t\n\t\tdouble min_y = y[0];\n\t\tint min_y_index = 0;\n\t\tfor (int i=1; i<n; i++) {\n\t\t\tif (min_y > y[i]) { min_y = y[i]; min_y_index = i; }\n\t\t}\n\t\t\n\t\tint curr_index = min_y_index;\n\t\tint circumference_points = 0;\n\t\tdouble curr_deg = 0.0;\n\t\tdo {\n\t\t\tdouble min_deg = PI;\n\t\t\tdouble min_deg_index;\n\t\t\tdouble tmp_deg;\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tif (i == curr_index) continue;\n\t\t\t\ttmp_deg = atan2( y[i] - y[curr_index], x[i] - x[curr_index] );\n\t\t\t\ttmp_deg -= curr_deg;cout << min_deg_index << \" \" <<\n\t\t\t\ttmp_deg += (tmp_deg < 0) ? 2*PI : 0;\n\t\t\t\tif ( min_deg > tmp_deg ) {\n\t\t\t\t\tmin_deg = tmp_deg; min_deg_index = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr_deg += min_deg;\n\t\t\tcurr_index = min_deg_index;\n\t\t\tcircumference_points++;\n\t\t\t// cout << min_deg_index << \" \" << curr_deg * 180 / PI << endl;\n\t\t} while (curr_index != min_y_index);\n\t\t\n\t\tcout << n - circumference_points << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator==(const Point &p)const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\t//Vector????????¢\n\tPoint rotate(double rad) { return Point(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nusing Vector = Point;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point(1, 1)) :p1(p1), p2(p2) {}\n\tVector vec() { return p2 - p1; }\n};\nusing Line = Segment;\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance_LP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance_SP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance_LP(s, p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance_SP(s1, s2.p1), get_distance_SP(s1, s2.p2)),\n\t\tmin(get_distance_SP(s2, s1.p1), get_distance_SP(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance_LP(l, c.c) <= c.r; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point getCrossPointLL(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//Graham scan\n//https://en.wikipedia.org/wiki/Graham_scan\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) > 0)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) < 0)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);//???????¨??????????\n\treturn down;\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tPolygon P(n);\n\t\tchar c;\n\t\trep(i, 0, n) cin >> P[i].x >> c >> P[i].y;\n\t\tPolygon CH = convex_hull(P);\n\t\tdumpc(CH);\n\t\tcout << (n - CH.size()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<list>\n\n#include<algorithm>\n#include<utility>\n#include<complex>\n\nusing namespace std;\n\n#define reE(i,a,b) for(auto (i)=(a);(i)<=(b);(i)++)\n#define rE(i,b) reE(i,0,b)\n#define reT(i,a,b) for(auto (i)=(a);(i)<(b);(i)++)\n#define rT(i,b) reT(i,0,b)\n#define rep(i,a,b) reE(i,a,b);\n\n#define rev(i,a,b) for(auto (i)=(b)-1;(i)>=(a);(i)--)\n#define itr(i,b) for(auto (i)=(b).begin();(i)!=(b).end();++(i))\n#define LL long long\n#define all(b) (b).begin(),(b).end()\n\n\n#define inpur_line(str,is) getline(cin, str);is.str(str);is.clear(istringstream::goodbit)\n#define input_token(ss,is,token,num) ss.str(\"\"); ss.clear(stringstream::goodbit); getline(is, token, ','); ss << token; ss >> num\n\ntypedef complex<double> P;\ntypedef vector<P> Poly;\n\nconst LL INF = 1 << 30;\nconst double eps = 1e-8;\n\n\ninline double dot(const P a, const  P b){//A dot B\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\n\ninline double cross(const P a, const P b){//A cross B\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\n\nbool less_P(const P& l, const P& r){\n\tif (l.real() == r.real())\n\t\treturn l.imag() < r.imag();\n\telse return l.real() < r.real();\n}\n\ninline void convex_hull(Poly p, Poly& res){\n\tint k = 0, t;\n\tres.resize(2 * p.size());\n\tsort(all(p),less_P);\n\treT(i, 0, (int)p.size()){\n\t\twhile (k > 1 && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1])<eps))k--;\n\t\tres[k++] = p[i];\n\t}\n\tt = k;\n\trev(i, 0, (int)p.size() - 1){\n\t\twhile (k > t && (cross(res[k - 1] - res[k - 2], p[i] - res[k - 1])<eps))k--;\n\t\tres[k++] = p[i];\n\t}\n\tres.resize(k-1);\n}\n\n\n\n\n\nint main(void){\n\tint n;\n\tdouble x, y;\n\tPoly p, q;\n\tstringstream ss;string str, token;istringstream is;\n\twhile (true){\n\t\tinpur_line(str, is);\n\t\tinput_token(ss, is, token, n);\n\t\tif (n == 0)break;\n\t\tp.resize(n);\n\t\trT(i, n){\n\t\t\tinpur_line(str, is);\n\t\t\tinput_token(ss, is, token, x);\n\t\t\tinput_token(ss, is, token, y);\n\t\t\tp[i].real(x);\n\t\t\tp[i].imag(y);\n\t\t}\n\t\tconvex_hull(p, q);\n\t\tcout << n - q.size() << endl;\n\t}\n\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\ndouble EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n};\ndouble dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\nistream& operator>>(istream& is, Point& p) { char c; return is >> p.x >> c >> p.y; }\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n    if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\n/* 与えら れた点集合の凸包をかえす.\n * psは3つ以上の要素を持たねばならない. */\nbool operator<(const Point& a, const Point& b) { return a.x < b.x; }\nvoid convexHull(vector<Point> ps, vector<Point>& ans) {\n    sort(ps.begin(), ps.end());\n    int N = ps.size();\n    int k = 0;\n    ans.resize(N * 2);\n    for (int i = 0; i < N; ans[k++] = ps[i++])\n        while (k >= 2 && ccw(ans[k - 2], ans[k - 1], ps[i]) <= 0) k--;\n    for (int i = N - 2, t = k + 1; i >= 0; ans[k++] = ps[i--])\n        while (k >= t && ccw(ans[k - 2], ans[k - 1], ps[i]) <= 0) k--;\n    /* 返上の点も頂点としたい場合は上4行を\n     *     for (int i = 0; i < N; ans[k++] = ps[i++])\n     *         while (k >= 2 && ccw(ans[k - 2], ans[k - 1], ps[i]) == -1) k--;\n     *     for (int i = N - 2, t = k + 1; i >= 0; ans[k++] = ps[i--])\n     *         while (k >= t && ccw(ans[k - 2], ans[k - 1], ps[i]) == -1) k--;\n     * にする. */\n    ans.resize(k - 1);\n}\n\nint main() {\n    while (true) {\n        int N; cin >> N;\n        if (N == 0) break;\n        vector<Point> ps(N);\n        for (int i = 0; i < N; i++) {\n            cin >> ps[i];\n        }\n        vector<Point> hull;\n        convexHull(ps, hull);\n        cout << N - hull.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * \nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分の交差判定\n\tbool is_intersection(const Segment& s) {\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) &&\n\t\t\t   ( cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) < EPS );\n\t}\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tif( this->is_intersection( s ) ) { // 交差するとき\t\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) || this->contain(s.b) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}else if( s.contain( a ) || s.contain( b ) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\t\tdouble A = this->distance(s.a);\n\t\tdouble B = this->distance(s.b);\n\t\tdouble C = s.distance( (*this).a );\n\t\tdouble D = s.distance( (*this).b );\n\t\treturn min( min(A,B) , min(C,D) );\n\t}\n\t// 点 p を軸に 線分 を 角度 angle だけ回転移動 (角度はラジアン)\n\tSegment rot(P p, double angle) {\n\t\tP a_ = rot2( p , a , angle );\n\t\tP b_ = rot2( p , b , angle );\n\t\treturn Segment( a_ , b_ );\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n// Segment の順序を定義 (x座標の小さい端点で比較)\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の直交判定\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 点 p が直線上に乗っているか\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// 直線と点 p の距離\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 角度を返す [-π,π]\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\treturn atan2( p.Y , p.X );\n\t}\n\t// 双対変換\n\tP dual(const Line &l) {\n\t\tconst P p = l[0], q = l[1];\n\t\treturn P( imag(p - q) / real(p - q), cross(p, q) / real(q - p) );\n\t}\n\t// 点を線対称に移動させる\n\tP symmetry(P a) {\n\t\tdouble x,y;\n\t\tdouble x1 = (*this)[0].X;\n\t\tdouble x2 = (*this)[1].X;\n\t\tdouble y1 = (*this)[0].Y;\n\t\tdouble y2 = (*this)[1].Y;\n\t\tdouble xq = a.X;\n\t\tdouble yq = a.Y;\n\t\tif( x2 == x1 ) {\n\t\t\tx = -xq;\n\t\t\ty = yq;\n\t\t}else{\n\t\t\tdouble m = (y2 - y1) / (x2 - x1);\n\t\t\tdouble c = y2 - m * x2;\n\t\t\tx = (2 * m * yq - xq * (m * m - 1) - 2 * m * c) / (m * m + 1);\n\t\t    y = (2 * m * xq + yq * (m * m - 1) + 2 * c) / (m * m + 1);\n\t\t}\n\t\treturn P(x,y);\n\t}\n\t// 点 p を軸に 直線 を 角度 angle だけ回転移動 (角度はラジアン)\n\tLine rot(P p, double angle) {\n\t\tP a = rot2( p , (*this)[0] , angle );\n\t\tP b = rot2( p , (*this)[1] , angle );\n\t\treturn Line( a , b );\n\t}\n\t// デバッグ出力\n\tvoid print() {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\tdouble dx = p1.X - p2.X;\n\t\tdouble dy = p1.Y - p2.Y;\n\t\t::print( p1 );\n\t\t::print( p2 );\n\t\tp1.X += 100 * dx;\n\t\tp1.Y += 100 * dy;\n\t\tp2.X -= 100 * dx;\n\t\tp2.Y -= 100 * dy;\n\t\tSegment s( p1 , p2 );\n\t\ts.print();\n\t}\n};\n\n\n// 三角形の表現\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n    // 3 つの辺の長さ\n    double edgeA, edgeB, edgeC;\n    // 3 つの角の角度 (ラジアン)\n    double angleA,angleB,angleC;\n    \n    // コンストラクタで初期化\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n    // 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n\t// 三角形の重心を返す\n\tP gravity() {\n\t\treturn P( (a.X + b.X + c.X) / 3.0 , (a.Y + b.Y + c.Y) / 3.0 );\n\t}\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\tSegment AB(a,b), BC(b,c), CA(c,a);\n\t\treturn (AB.contain( p ) || BC.contain( p ) || CA.contain( p ) );\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\t// 点 p が三角形の辺上 or 頂点上 にあるときは誤差で正しい結果が返ってこないので注意!!!\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n\t// 点 p を軸に 三角形 を 角度 angle だけ回転移動 (角度はラジアン)\n\tTriangle rot(P p, double angle) {\n\t\tP a_ = rot2( p , a , angle );\n\t\tP b_ = rot2( p , b , angle );\n\t\tP c_ = rot2( p , c , angle );\n\t\treturn Triangle( a_ , b_ , c_ );\n\t}\n\t// デバッグ出力\n\tvoid print() {\n\t\tSegment AB(a,b);\n\t\tSegment BC(b,c);\n\t\tSegment CA(c,a);\n\t\tAB.print();\n\t\tBC.print();\n\t\tCA.print();\n\t}\n};\n\n\n// 凸多角形かどうか (三角形に分割してすべての三角形が反時計回りか調べる)\nbool is_convex(vector<P> g) {\n\tfor(int i=2 ; i < g.size() ; i++ ){\n\t\tif( ccw( g[0] , g[i-1] , g[i] ) != CCW ) return false;\n\t}\n\treturn true;\n}\n\n// 多角形の表現 (凸多角形と仮定する)\nstruct Polygon{\n\t// 頂点の集まり\n\tvector<P> g;\n\t// コンストラクタで初期化\n\tPolygon(vector<P> g_){ g = g_; }\n\tPolygon(){}\n\t// 点 p が凸多角形の内部にあるかどうか\n\tbool is_inside(P p) {\n\t\tfor(int i=2 ; i < g.size() ; i++ ) {\n\t\t\tTriangle t( g[0] , g[i-1] , g[i] );\n\t\t\tif( t.is_inside( p ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t// 点 p が凸多角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\tfor(int i=0 ; i < g.size() ; i++ ) {\n\t\t\tSegment s( g[i] , g[(i+1) % g.size()] );\n\t\t\tif( s.contain( p ) ) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t// 凸多角形の面積を返す\n\tdouble get_area() {\n\t\tdouble s = 0.0;\n\t\tfor(int i=2 ; i < g.size() ; i++ ) {\n\t\t\ts += cross( g[i-1] - g[0] , g[i] - g[0] );\n\t\t}\n\t\treturn s/2.0;\n\t}\n\t// 凸多角形の重心を返す\n\tP gravity() {\n\t\tP sg(0,0);\n\t\tdouble s = 0.0;\n\t\tfor(int i=2 ; i < g.size() ; i++ ) {\n\t\t\tTriangle t( g[0] , g[i-1] , g[i] );\n\t\t\ts += t.get_area();\n\t\t\tsg += t.get_area() * t.gravity();\n\t\t};\n\t\treturn sg / s;\n\t}\n\t// 凸多角形の直径を返す (最遠点対は引数のpair<P,P> pに代入)\n\tdouble convex_diameter(pair<P,P>& p) {\n    \tdouble result = 0.0;\n    \tfor(int i=0 ; i < g.size() ; i++ ){\n    \t\tfor(int j = i+1 ; j < g.size() ; j++ ){\n    \t\t\t if( result < dist( g[i] , g[j] ) ){\n    \t\t\t \tresult = dist( g[i] , g[j] );\n    \t\t\t \tp = pair<P,P>( g[i] , g[j] );\n    \t\t\t }\n    \t\t}\n    \t}\n    \treturn result;\n\t}\n\t// 凸多角形を 点 seg.a と 点 seg.b を通る直線で切断し、直線の左側の多角形を返す\n\tPolygon convex_cut(const Segment& s) {\n  \t\tvector<P> Q;\n  \t\tfor(int i = 0; i < g.size() ; i++ ) {\n    \t\tP A = g[i];\n    \t\tP B = g[(i+1) % g.size()];\n    \t\tif( ccw( s.a , s.b , A ) != CW ) {\n    \t\t\tQ.push_back( A );\n    \t\t}\n    \t\tif( ccw( s.a , s.b , A ) * ccw( s.a , s.b , B ) < 0 ) {\n    \t\t\tSegment AB( A , B );\n    \t\t\tP p;\n    \t\t\tAB.intersection( s , p );\n     \t\t\tQ.push_back( p );\n     \t\t}\n  \t\t}\n \t\treturn Polygon( Q );\n\t}\n\t// 直線 s の方向( s.a から s.b へのベクトル ) と 最も遠い点を返す\n\tdouble d(int k, const Segment& s) { return dot( g[k] , s.b - s.a ) ;}\n\tP convex_extreme(const Segment& s) {\n\t\tint a = 0;\n\t\tint b = g.size();\n\t\tint n = g.size();\n\t\tif( d(0,s) >= d(n-1,s) && d(0,s) >= d(1,s) )\n\t\t\treturn g[0];\n\t\twhile( a < b ) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif( d(c,s) >= d(c-1,s) && d(c,s) >= d(c+1,s) )\n\t\t\t\treturn g[c];\n\t\t\tif( d(a+1,s) > d(a,s) ){\n\t\t\t\tif( d(c+1,s) <= d(c,s) || d(a,s) > d(c,s) )\n\t\t\t\t\tb = c;\n\t\t\t\telse\n\t\t\t\t\ta = c;\n\t\t\t}else{\n\t      \t\tif( d(c+1,s) > d(c,s) || d(a,s) >= d(c,s) )\n\t      \t\t\ta = c;\n\t      \t\telse\n\t      \t\t\tb = c;\n\t      \t}\n\t\t}\n\t}\n\t// デバッグ用出力\n\tvoid print() {\n\t\tfor(int i=0 ; i < g.size() ; i++ ) {\n\t\t\tSegment s( g[i] , g[(i+1) % g.size()] );\n\t\t\ts.print();\n\t\t}\n\t}\n};\n\n// n 個の点の集まりから凸包を求める\nPolygon convex_full(vector<P> ps) {\n\tint n = ps.size();\n\tsort( ps.begin() , ps.end() );\n\t\n\t// 上部を求める\n    vector<P> ch_u( n );\n    int n_u = 0;\n    for(int i = n-1 ; i >= 0 ; i-- ) {\n        ch_u[n_u++] = ps[i];\n        while( n_u >= 3 && ccw( ch_u[n_u-3] , ch_u[n_u-2] , ch_u[n_u-1] ) != CCW ) {\n            ch_u[n_u-2] = ch_u[n_u-1];\n            n_u--;\n        }\n    }\n \n    vector<P> ch_l( n );\n    int n_l = 0;\n    for(int i = 0 ; i < n ; i++ ) {\n        ch_l[n_l++] = ps[i];\n        while( n_l >= 3 && ccw( ch_l[n_l-3] , ch_l[n_l-2] , ch_l[n_l-1]) != CCW ) {\n            ch_l[n_l-2] = ch_l[n_l-1];\n            n_l--;\n        }\n    }\n \n    Polygon ch;\n    for(int i=0 ; i<n_u-1 ; i++ ) ch.g.push_back(ch_u[i]);\n    for(int i=0 ; i<n_l-1 ; i++ ) ch.g.push_back(ch_l[i]);\n    return ch;\n}\n\nint main(){\n\tint n;\n\twhile( scanf(\"%d\", &n) ){\n\t\tif( n == 0 ) break;\n\t\tvector<P> v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back( P(x,y) );\n\t\t}\n\t\tPolygon pol = convex_full( v );\n\t\tint ans = n - (int)pol.g.size();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define FORALL(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FOREACH(i,c) for(auto (i) : (c))\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef valarray<int> Array;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cout<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\n\nclass P\n{\nprivate:\n  double add(double a,double b){if(abs(a+b)<1e-10*(abs(a)+abs(b)))return 0;else return a+b;}\npublic:\n  double x,y;\n  P(){};P(double x,double y):x(x),y(y){};\n  P operator+(const P&q){return P(add(x,q.x),add(y,q.y));}\n  P operator+=(const P&q){x+=q.x;y+=q.y;return *this;}\n  P operator-(const P&q){return P(add(x,-q.x),add(y,-q.y));}\n  P operator-=(const P&q){x-=q.x;y-=q.y;return *this;}\n  template<typename T> P operator*(T d){return P(x*d,y*d);}\n  template<typename T> P operator*=(T d){x*=d;y*=d;return *this;}\n  bool operator<(const P&q){return (x!=q.x)?(x<q.x):(y<q.y);}\n  bool operator>(const P&q){return (x!=q.x)?(x>q.x):(y>q.y);}\n  bool operator<=(const P&q){return (x!=q.x)?(x<=q.x):(y<=q.y);}\n  bool operator>=(const P&q){return (x!=q.x)?(x>=q.x):(y>=q.y);}\n  static bool comp(const P&p,const P&q){return (p.x!=q.x)?(p.x<q.x):(p.y<q.y);}\n  double dot(const P&q){return x*q.x+y*q.y;}\n  double det(const P&q){return x*q.y-y*q.x;}\n  bool on_seg(P p1,P p2,P q){return (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;}\n  P intersection(P p1,P p2,P q1,P q2){return p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));}\n};\n\nvector<P> convex_hull(vector<P> ps)\n{\n  sort(ps.begin(),ps.end(),P::comp);\n  int k = 0, n = ps.size();\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++)\n  {\n    while(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--)\n  {\n    while(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n, n)\n  {\n    vector<P> ps,qs;\n    REP(i,n){P t;scanf(\"%lf,%lf\\n\",&t.x,&t.y);ps.push_back(t);}\n    qs = convex_hull(ps);\n    cout << n-qs.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int size = 101;\nint n;\ndouble X[size];\ndouble Y[size];\ndouble D[size];\nbool used[size];\n\ndouble getCross( double x1, double y1, double x2, double y2 ) {\n    return x1 * y2 - y1 * x2;\n}\n\ndouble getDistance( double x1, double y1, double x2, double y2 ) {\n    double X = x2 - x1;\n    double Y = y2 - y1;\n    return X * X + Y * Y;\n}\n\ndouble getDistance( double x, double y ) {\n    return getDistance( 0, 0, x, y );\n}\n\nvoid init() {\n    for ( int i = 0; i < size; i++ ) {\n        used[i] = false;\n    }\n}\n\nint solve() {\n    init();\n\n    bool first = true;\n    int pivot;\n    double mind;\n    for ( int i = 0; i < n; i++ ) {\n        if ( first || D[i] < mind ) {\n            pivot = i;\n            mind = D[i];\n            first = false;\n        }\n    }\n\n    int cnt = 1;\n    used[pivot] = true;\n\n    for ( int k = 0; k < n-1; k++ ) {\n        for ( int i = 0; i < n; i++ ) {\n            if ( used[i] ) continue;\n            bool flag = true;\n            for ( int j = 0; j < n; j++ ) {\n                if ( i == j ) continue;\n                double c = getCross( X[i] - X[pivot], Y[i] - Y[pivot], X[j] - X[pivot], Y[j] - Y[pivot] );\n                if ( c < 0.0 ) {\n                    flag = false;\n                    break;\n                }\n            }\n            if ( flag ) {\n                cnt++;\n                used[i] = true;\n                pivot = i;\n                break;\n            }\n        }\n    }\n    \n    return n - cnt;\n}\n\nint main() {\n    while ( cin >> n && n ) {\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            cin >> line;\n            replace( line.begin(), line.end(), ',', ' ' );\n            istringstream is( line );\n            is >> X[i] >> Y[i];\n            X[i] += 2000.0;\n            Y[i] += 2000.0;\n            D[i] = getDistance( X[i], Y[i] );\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// geometry\ntypedef long double Real;\n#define EPS 1e-12\ntypedef complex<Real> P;\nbool P_less(const P &a,const P &b){\n  if(a.real()!=b.real())return a.real()<b.real();\n  return a.imag()<b.imag();\n}\nReal dot(const P &a,const P &b){return real(conj(a)*b);}\nReal cross(const P &a,const P &b){return imag(conj(a)*b);}\nint ccw(const P &a,const P &b,const P &c){\n  Real x = cross(b-a,c-a);\n  if(abs(x)<EPS)return 0;\n  else if(x<0)return -1;\n  else return 1;\n}\n\nstruct ccw_less{\n  P x;\n  bool operator()(const P &a,const P &b) const{\n    int c = ccw(x,a,b);\n    if(c==0) return norm(a-x)<norm(b-x);\n    return c==1;\n  }\n};\nvector<P> createConvexHull(vector<P> p){\n  // Graham's scan\n  vector<P> ret(p.size());\n  // ?????????????????????\n  int id = 0;\n  REPR(i,p.size()) if(P_less(p[i],p[id])) id = i;\n  swap(p[0],p[id]);\n  // ????§??????????\n  ccw_less cw;\n  cw.x = p[0];\n  sort(p.begin()+1,p.end(),cw);\n  // ??°?????????????????£???\n  int iter = 0;\n  ret[iter++] = p[0];\n  REPR(i,p.size()){\n    while(iter>=2 && ccw(ret[iter-2],ret[iter-1],p[i])<=0)--iter;\n    ret[iter++] = p[i];\n  }\n  ret.resize(iter);\n  return ret;\n}\n\nint main(){\n  // verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0068\n  while(true){\n    int n;\n    scanf(\"%d\",&n);\n    if(!n)break;\n    vector<P> p(n);\n    REP(i,n){\n      Real x,y;\n      scanf(\"%Lf,%Lf\",&x,&y);\n      p[i] = P(x,y);\n    }\n    vector<P> conv = createConvexHull(p);\n    cout<< (n-conv.size()) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\n#define EPS (1e-15)\ntypedef complex<double> Po;\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){return abs(cross(b-a,c-a)/2);}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) + EPS)return false;\n  else return true;\n}\n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int ans;\n  bool use[100];\n  Po p[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&p[i].real(),&p[i].imag());\n      use[i] = false;\n    }\n\n    ans = 0;\n    for(i=0;i<n-3;i++){\n      for(j=i+1;j<n-2;j++){\n\tfor(k=j+1;k<n-1;k++){\n\t  for(l=k+1;l<n;l++){\n\t    if(!use[l]){\n\t      if(inter(p[i],p[j],p[k],p[l])){\n\t\tans++;\n\t\tuse[l] = true;\n\t      }\n\t    }\n\t    if(!use[k]){\n\t      if(inter(p[i],p[j],p[l],p[k])){\n\t\tans++;\n\t\tuse[k] = true;\n\t      }\n\t    }\n\t    if(!use[j]){\n\t      if(inter(p[i],p[l],p[k],p[j])){\n\t\tans++;\n\t\tuse[j] = true;\n\t      }\n\t    }\n\t    if(!use[i]){\n\t      if(inter(p[l],p[j],p[k],p[i])){\n\t\tans++;\n\t\tuse[i] = true;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nmain(){\n\tint n,i,start,M;\n\tdouble x,y,dX,dY,dx,dy,dot,n1,n2,co,m;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<pair<pair<double,double>,int> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf,%lf\",&x,&y),v.push_back(make_pair(make_pair(x,y),i));\n\t\tpair<pair<double,double>,int>p=*min_element(v.begin(),v.end());\n\t\tdX=0,dY=-1;\n\t\tstart=p.second;\n\t\tvector<int>V;\n\t\tfor(M=-1;M!=start;){\n\t\t\tm=-1,n1=hypot(dX,dY)\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(i==p.second)continue;\n\t\t\t\tdx=v[i].first.first-p.first.first,dy=v[i].first.second-p.first.second;\n\t\t\t\tdot=dX*dx+dY*dy;\n\t\t\t\tn2=hypot(dx,dy),co=dot/n1/n2;\n\t\t\t\tif(m<co)m=co,M=i;\n\t\t\t}\n\t\t\tV.push_back(M);\n\t\t\tdX=v[M].first.first-p.first.first,dY=v[M].first.second-p.first.second;\n\t\t\tp=v[M];\n\t\t}\n\t\tprintf(\"%d\\n\",n-V.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define EPS 1e-9\n\n//typedef complex<double> P;\n\nstruct P {\n\tdouble x, y;\n};\n\ntypedef vector<P> polygon;\n\nbool operator <(const P& p1, const P& p2) {\n\treturn p1.x < p2.x;\n}\nP operator -(const P& p1, const P& p2) {\n\treturn (P){p1.x - p2.x, p1.y - p2.y};\n}\n\nint F(double v) {\n\tif ( abs(v) < EPS ) return 0;\n\treturn v < 0 ? -1 : v > 0 ? 1 : 0;\n}\n\ndouble cross(P p1, P p2) {\n\treturn p1.x * p2.y - p1.y * p2.x;\n}\n\nint ccw(P& p1, P& p2, P& p3) {\n\treturn F(cross(p2 - p1, p3 - p1));\n}\n\nbool check(polygon& t, int comp) {\n\tint n = t.size();\n\tif (n < 3) return true;\n\treturn ccw(t[n-3], t[n-2], t[n-1]) != comp;\n}\n\nint main() {\n\tint n;\n\twhile ( cin >> n, n ) {\n\t\tvector<P> v;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back( (P){x, y} );\n\t\t}\n\t\tsort( v.begin(), v.end() );\n\n\t\tint ans = n+2;\n\n\t\tpolygon t;\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tt.push_back(v[i]);\n\t\t\twhile ( !check(t, 1) ) t.erase( t.end()-2, t.end()-1 );\n\t\t}\n\t\tans -= t.size();\n\n\t\tt.clear();\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tt.push_back(v[i]);\n\t\t\twhile ( !check(t, -1) ) t.erase( t.end()-2, t.end()-1 );\n\t\t}\n\t\tans -= t.size();\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<string.h>\n#include <stdio.h>\n#include<math.h>\n#include<functional>\n\n#define INTMAX_MAX 10000\n#define INTMAX_MIN -10000\n\nusing namespace std;\n\n\n\nint main(){\n    \n    \n    int count = 0;\n    pair<double, double> xy[100];\n    while(cin>>count){\n        \n        if(count==0)break;\n        for(int i=0; i<count; i++)scanf(\"%lf,%lf\",&xy[i].first,&xy[i].second);\n        sort(xy,xy+count);\n        int now = 0;\n        int end = count;\n        while(now<end-1){\n            double max = INTMAX_MIN;\n            int max_n = now;\n            for(int i=now+1; i<end; i++){\n                double temp;\n                double x = xy[i].first-xy[now].first;\n                double y = xy[i].second-xy[now].second;\n                if(x==0){\n                    if(y>0)temp=INTMAX_MAX;\n                    else temp= INTMAX_MIN+1;\n                }else{\n                    temp = y/x;\n                }\n                if(temp>max){\n                    max = temp;\n                    max_n = i;\n                }\n            }\n            now = max_n;\n            count--;\n        }\n        now = 0;\n        while(now<end-1){\n            double min = INTMAX_MAX;\n            int min_n = now;\n            for(int i=now+1; i<end; i++){\n                double temp;\n                double x = xy[i].first-xy[now].first;\n                double y = xy[i].second-xy[now].second;\n                if(x==0){\n                    if(y>0)temp=INTMAX_MAX-1;\n                    else temp= INTMAX_MIN;\n                }else{\n                    temp = y/x;\n                }\n                if(temp<min){\n                    min = temp;\n                    min_n = i;\n                }\n            }\n            now = min_n;\n            count--;\n        }\n        cout<<count<<endl;\n        \n        \n    }\n    \n    \n    \n\n        \n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ndouble EPS=1e-10;\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\nstruct P{\n\tdouble x, y;\n\tP() {}\n\tP (double x, double y) : x(x), y(y) {}\n\tP operator + (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t} \n\tP operator - (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x * d, y * d);\n\t}\n\tdouble dot(P p){  //??????\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\tdouble det(P p){  //??????\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n\tif(p.x != q.x) return p.x < q.x;\n\treturn p.y < q.y;\n}\n//??????????±???????\nvector<P> convex_hull(P* ps, int n){\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;  //?????????????????°\n\tvector<P> qs(n * 2);  //?§????????????????\n\t//?????´???????????????\n\tfor(int i = 0; i < n; i++){\n\t\twhile(k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\t//?????´???????????????\n\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\twhile(k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nint n;\nP ps[100];\n\nsigned main() {\n\twhile(cin >> n && n){\n\t\trep(i, 0, n){\n\t\t\tdouble x, y;\n\t\t\tchar c;\n\t\t\tcin >> x >> c >> y;\n\t\t\tps[i] = P(x, y);\n\t\t}\n\t\tvector<P> qs = convex_hull(ps, n);\n\t\tcout<< n - qs.size() <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define PI (acos(-1.0))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define POSARG(a) (arg(a) > 0.0? arg(a) : 2.0*PI + arg(a))\n\nint n;\n\nvector<P>::iterator convex_hull(vector<P>& vc)\n{\n\tint undermost = 0;\n\t\n\tfor(int i = 1; i < (int)vc.size(); i++)\n\t{\n\t\tif( vc[i].imag() < vc[undermost].imag() \n\t\t\t||( EQ(vc[undermost].imag(), vc[i].imag()) && vc[undermost].real() < vc[i].real() ) )\n\t\t{\n\t\t\tundermost = i;\n\t\t}\n\t}\n\t\n\tswap(vc[0], vc[undermost]);\n\n\tdouble nowarg = 0.0;\n\tint j;\n\t\n\tfor( j = 0; j < (int)vc.size()-1; j++)\n\t{\n\t\tdouble minarg = 2.0*PI;\n\t\tdouble maxdst = 0.0;\n\t\tint candidx = 0;\n\t\t\n\t\tfor(int i = j+1; i < (int)vc.size(); i++)\n\t\t{\n\t\t\tdouble newarg = POSARG(vc[i] - vc[j]);\n\t\t\tdouble newdst = abs(vc[i] - vc[j]);\n\t\t\t\n\t\t\tif( newarg > nowarg || EQ(newarg, nowarg))\n\t\t\t\tif( newarg < minarg || ( EQ(newarg, minarg) && newdst > maxdst) )\n\t\t\t\t{\n\t\t\t\t\tminarg = newarg;\n\t\t\t\t\tmaxdst = newdst;\n\t\t\t\t\tcandidx = i;\n\t\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif(candidx == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswap(vc[j+1], vc[candidx]);\n\t\t\tnowarg = minarg;\n\t\t}\n\t}\n\t\n\treturn vc.begin()+j+1;\n}\n\nint solve(vector<P> vc)\n{\n\tvector<P>::iterator r = convex_hull(vc);\n\treturn vc.end() - r;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> vc;\n\t\tvc.clear();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tchar c;\n\t\t\tdouble a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> c;\n\t\t\tcin >> b;\n\t\t\tvc.push_back(P(a, b));\n\t\t}\n\t\t\n\t\tcout << solve(vc) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<utility>\n#include<vector>\n#include<map>\n   \nusing namespace std;\n   \ntypedef pair<double,double> PBB;\ntypedef vector<PBB > VPBB;\ntypedef multimap<double,int> MDI;\ntypedef MDI::iterator MDII;\n   \n#define PUSH push_back\n#define MDIVT MDI::value_type\n#define PI 3.14159265359\n#define INF 10000000000\n#define NMAX 100\n   \n   \nint main(){\n   \n    int n;\n    int main,st;\n    int num;\n    double x,y;\n\tdouble sita;\n    char gav;\n\tdouble bef;\n    VPBB pin;\n    MDI point;\n    MDII ite;\n \n    while(1){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x>>gav>>y;\n\t\t\tpin.PUSH(PBB(x,y));\n\t\t}\n \n\t\tmain=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(pin[main].second<pin[i].second) main=i;\n\t\t\telse if(pin[main].second==pin[i].second&&pin[main].first<pin[i].first) main=i;\n\t\t}\n\t\tst=main;\n\t\tnum=0;\n\t\tbef=-1*PI;\n\t\twhile(1){\n\t\t\t///cout<<num<<\"\\\\\\\\\"<<main<<endl;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(pin[i].second!=pin[main].second) sita=atan2(pin[i].second-pin[main].second,pin[i].first-pin[main].first);\n\t\t\t\telse sita=-1*PI;\n\t\t\t\tif(i!=main&&sita>bef){\n\t\t\t\t\t///cout<<sita<<\"---\"<<i<<endl;\n\t\t\t\t\tpoint.insert(MDIVT(sita,i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tite=point.begin();\n\t\t\tbef=(*ite).first;\n\t\t\tmain=(*ite).second;\n\t\t\tpoint.clear();\n\t\t\tnum++;\n\t\t\tif(main==st) break;\n\t\t}\n\t\tcout<<n-num<<endl;\n\t\tpin.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <functional>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <typeinfo>\n#define PI 3.14159265359\n#define INF 99999999\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(n) rep(i, n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\nusing namespace std;\n//typedef pair<int, int> P;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b)\n{\n\tif (fabs(a + b) < EPS * (fabs(a) + fabs(b))) return 0;\n\treturn a + b;\n}\n\nstruct P\n{\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {\n\t}\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d) {\n\t\treturn P(x * d, y * d);\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\tdouble det(P p) {\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\nbool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x) return p.x < q.x;\n\treturn p.y < q.y;\n}\n\nvector<P> convex_hull(P* ps, int n) {\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;\n\tvector<P> qs(n * 2);\n\tfor (int i=0; i<n; i++) {\n\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i=n-2, t=k; i>=0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nint n;\ndouble x, y;\nchar comma;\nP ps[100];\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\trep(i, n) cin >> ps[i].x >> comma >> ps[i].y;\n\t\tvector<P> qs = convex_hull(ps, n);\n\t\tcout << n - qs.size() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double, double> P;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(void){\n  int n;\n  while(cin>>n){\n    if(n==0) break;\n    double x,y;\n    vector<P> point;\n    REP(i,n){\n      scanf(\"%lf,%lf\",&x,&y);\n      point.push_back(P(y,x));\n    }\n    sort(point.begin(),point.end());\n    reverse(point.begin(),point.end());\n    REP(i,point.size()){\n      swap(point[i].first,point[i].second);\n    }\n    P f,n;\n    double arg;\n    f = point[0];\n    REP(i,point.size()){\n      if(point[i].second==f.second&&point[i].first<f.first) f = point[i];\n    }\n    vector<pair<double,P> > tmp;\n    REP(i,point.size())if(point[i]!=f){\n      arg = atan2(point[i].second-f.second,point[i].first-f.first);\n      tmp.push_back(pair<double,P>(arg,point[i]));\n    }\n    sort(tmp.begin(),tmp.end());\n    n = tmp[0].second;\n    int ans = 2;\n    arg = tmp[0].first;\n//printf(\"%lf %lf\\n\",f.first,f.second);\n//printf(\"%lf %lf\\n\",(n).first,(n).second);\n    while(n!=f){\n      double arg2;\n      vector<pair<double,P> > argvec;\n      REP(i,point.size()){\n        if(n==point[i]) continue;\n        int nx = point[i].first; int ny = point[i].second;\n        arg2 = atan2(ny-n.second, nx-n.first);\n        argvec.push_back(pair<double,P>(arg2,point[i]));\n      }\n      vector<pair<double,P> >::iterator it;\n      sort(argvec.begin(),argvec.end());\n      it = upper_bound(argvec.begin(),argvec.end(),pair<double,P>(arg,n));\n//printf(\"%lf %lf\\n\",(*it).second.first,(*it).second.second);\n      if(it==argvec.end()) it = argvec.begin();\n      if(f==(*it).second){\n        cout<<point.size()-ans<<endl;\n        break;\n      }else{\n        arg = (*it).first;\n        n = (*it).second;\n        ans++;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nusing D = double;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_num(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define RALL(qpqpq)           (qpqpq).rbegin(),(qpqpq).rend()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define RFOR(i,tptpt,ypypy)  for(LL i=(tptpt);i>=(ypypy);i--)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n\ndouble EPS = 1e-10;\n\n//誤差を考慮して足し算を行う\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\n\n//二次元ベクトル構造体\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) :x(x), y(y) {\n\t}\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d) {\n\t\treturn P(x*d, y*d);\n\t}\n\t//内積\n\tdouble dot(P p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\t//外積\n\tdouble det(P p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n};\n\n//距離の二乗\ndouble dist(P p, P q) {\n\treturn (p - q).dot(p - q);\n}\n\n//辞書順で比較\nbool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x)return  p.x < q.x;\n\treturn p.y < q.y;\n}\n\n//凸包を求める\nvector<P> convex_hull(P* ps, int n) {\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;//凸法の頂点数\n\tvector<P> qs(n * 2);//構築中の凸包\n\n\t\t\t\t\t\t//下限凸包の作成\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\n\t//上限凸包の作成\n\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) <= 0)k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\n\nP ps[101010];\n\nint main() {\n\tint n;\n\twhile (cin >> n&&n) {\n\t\tREP(i, 101010) {\n\t\t\tps[i].x = ps[i].y = 0.0;\n\t\t}\n\t\tREP(i, n) {\n\t\t\tdouble x, y;\n\t\t\tchar c;\n\t\t\tcin >> x >> c >> y;\n\t\t\tps[i].x = x, ps[i].y = y;\n\t\t}\n\t\tvector<P> qa = convex_hull(ps, n);\n\t\tcout << n - qa.size() << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nclass Point{\npublic:\n  double x,y;\n  Point (double x = 0,double y = 0): x(x),y(y){}\n  Point operator + (Point &p){ return Point(x+p.x,y+p.y);}\n  Point operator - (Point &p){ return Point(x-p.x,y-p.y);}\n  Point operator * (double k){ return Point(x*k,y*k);}\n  bool operator < (const Point &p)const {\n    if(x == p.x) return y < p.y;\n    else return x < p.x;\n  }\n\n};\ntypedef Point Vector;\n\ndouble cross(Vector a, Vector b){ return a.x * b.y - a.y * b.x;}\n\nint Convex_Hull(vector<Point> v){\n  vector<Point> c; //convex\n  sort(v.begin(),v.end());\n  c.assign(v.begin(),v.begin()+2);\n\n  for(int i=2;i<v.size();i++){\n    Vector a = c[c.size()-1] - c[c.size()-2];\n    Vector b = v[i] - c[c.size()-2];\n\n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < 2) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n\n    c.push_back(v[i]);\n  }\n\n  int n = c.size();\n  c.push_back(v[v.size()-2]);\n\n  for(int i=v.size()-3;i>=0;i--){\n    Vector a = c[c.size()-1] - c[c.size()-2];\n    Vector b = v[i] - c[c.size()-2];\n\n    while(cross(a,b) > EPS){\n      c.pop_back();\n      if(c.size() < n + 1) break;\n      a = c[c.size()-1] - c[c.size()-2];\n      b = v[i] - c[c.size()-2];\n    }\n\n    c.push_back(v[i]);\n  }\n  c.pop_back();\n\n  return c.size();\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<Point> v(n);\n    for(int i=0;i<n;i++) scanf(\"%lf,%lf\",&v[i].x,&v[i].y);\n    cout << n - Convex_Hull(v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define EPS (1e-5)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) && n){\n\t\tPolygon in;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdouble p1, p2;\n\t\t\tscanf(\"%lf,%lf\", &p1, &p2);\n\t\t\tin.push_back(Point(p1, p2));\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", in.size() - conhel(in).size());\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\n\nnamespace std {\n  bool operator<(const P& p, const P& q)\n  {\n    return abs(p.real() - q.real()) < EPS ? p.imag() < q.imag() : p.real() < q.real();\n  }\n};\n\ndouble dot(const P& p, const P& q)\n{\n  return p.real()*q.real() + p.imag()*q.imag();\n}\n\ndouble cross(const P& a, const P& b)\n{\n  return imag(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0) {\n    return 1; // counter clockwise\n  } else if (cross(b, c) < 0) {\n    return -1;  // clockwise\n  } else if (dot(b, c) < 0) {\n    return 2; // c-a-b on line\n  } else if (abs(b) < abs(c)) {\n    return -2;  // a-b-c on line\n  }\n  return 0;\n}\n\nvector<P> convex(vector<P> ps)\n{\n  sort(ps.begin(), ps.end());\n  const int N = ps.size();\n  vector<P> ch(2*N);\n  int k = 0;\n  // upper\n  for (int i = 0; i < N; i++) {\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) {\n      k--;\n    }\n    ch[k] = ps[i];\n    k++;\n  }\n  // lower\n  for (int i = N-2, t = k+1; i >= 0; i--) {\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) {\n      k--;\n    }\n    ch[k] = ps[i];\n    k++;\n  }\n  ch.resize(k-1);\n  return ch;\n}\n\nint main()\n{\n  int n;\n  while (cin >> n && n != 0) {\n    vector<P> ps(n);\n    for (int i = 0; i < n; i++) {\n      char d;\n      cin >> ps[i].real() >> d >> ps[i].imag();\n    }\n    vector<P> c = convex(ps);\n    cout << n - c.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tstring html_str(){\n\t\tchar ns[50];\n\t\tstring res=\"\";\n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,3,0,360);\\n\",x,y);\n\t\tres+=\"ctx.beginPath();\\n\" + string(ns) + \"ctx.fill();\\n\";\n\t\treturn res;\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\n\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tstring html_str(){\n\t\tstring res=\"\";\n\t\tres+=p.html_str();\n\t\tres+=q.html_str();\n\t\tchar ns[50];\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\\n\",p.x,p.y);\n\t\tres+=\"ctx.beginPath();\\n\"+string(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\\n\",q.x,q.y);\n\t\tres+=string(ns)+\"ctx.stroke();\\n\";\n\t\treturn res;\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\tdouble d1=a.vec.cross(a.p.tov(p));\n\t\tdouble d2=a.vec.cross(a.p.tov(q));\n\t\t//d1???ap-aq-bp?????¢???\n\t\t//d2???ap-aq-bq?????¢???\n\t\t//??¢??????????????´???b????????????????????????????????°?????????????????????????????????\n\t\tbool isna=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(isna)sc = d1/(d1+d2); //???????????§??????????????????\n\t\telse{\n\t\t\t//if(d1>d2)sc = d1/(d1-d2);\n\t\t\t//else sc=-d1/(d2-d1);\n\t\t\tsc=d1/(d1-d2);\n\t\t}\n\t\treturn (p+vec.scalar(sc));\t\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n};\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid input(int n){\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tps.push_back(pos(x,y));\n\t\t}\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p);\n\t\t\tif(d1*d2<1e-6)res.ps.push_back(a.crosspos(ne));\n\t\t}\n\t\treturn res;\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\npos randpos(){\n\treturn pos(rand()%100,rand()%100);\n}\nline randline(){\n\treturn line(randpos(),randpos());\n}\n\n\nvoid makehtml(char* name,string s){\n\tchar fname[100];\n\tsprintf(fname,\"%s.html\",name);\n\tfreopen(fname,\"w\",stdout);\n\tprintf(\"<html>\\n<head>\\n<title>\");\n\tprintf(\"%s\",name);\n\tprintf(\"</title>\\n</head>\\n<body>\\n\");\n\t\n\tprintf(\"<p>name: %s</p>\",name);\n\t\n\tprintf(\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",500,500);\n\t\n\tprintf(\"<script>\\n\");\n\t\n\tprintf(\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\n\tprintf(\"%s\",s.c_str());\n\t\n\t//ctx.fillStyle = \\\"rgb(0,0,0)\\\";\n\t\n\n\t\n\tprintf(\"</script>\\n\");\n\t\n\tprintf(\"</body>\\n</html>\\n\");\n}\n\n\nint main(void){\n\t/*\n\tint n;\n\tscanf(\"%d\",&n);\n\tpolygon pol;\n\trep(i,n){\n\t\tdouble x,y;\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpol.ps.push_back(pos(x,y));\n\t}\n\tint q;\n\tscanf(\"%d\",&q);\n\trep(i,q){\n\t\tdouble x,y;\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpos p1(x,y);\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpos p2(x,y);\n\t\tline nl(p2,p1);\n\t\tpolygon tp=pol.cut(nl);\n\t\tprintf(\"%lf\\n\",tp.area());\n\t}\n\t*/\n\tint n;\n\tfor(;;){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tpolygon pol;\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf,%lf\",&x,&y);\n\t\t\tpol.ps.push_back(pos(x,y));\n\t\t}\n\t\tpolygon tp=pol.convex_full();\n\t\tint ans=0;\n\t\trep(i,pol.ps.size()){\n\t\t\tpos np=pol.ps[i];\n\t\t\tif(tp.isin(np)==2)ans++;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t/*\n\trep(i,10){\n\t\tline l1=randline();\n\t\tline l2=randline();\n\t\tpos xp=l1.crosspos(l2);\n\t\t//printf(\"%s\\n\",l1.str().c_str());\n\t\t//printf(\"%s\\n\",l2.str().c_str());\n\t\t//printf(\"%s\\n\",xp.str().c_str());\n\t\tprintf(\"%lf\\n\",l1.p.tov(xp).cross(l1.vec));\n\t\tprintf(\"%lf\\n\",l2.p.tov(xp).cross(l2.vec));\n\t\n\t}\n\treturn 0;\n\t*/\n\t\n\t/*\n\tstring h=\"\";\n\th+=l1.html_str();\n\th+=l2.html_str();\n\th+=xp.html_str();\n\t\n\t\n\t\n\tmakehtml(\"tess\",h);\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos(-1);\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator > (P a, P b) {\n        return (b < a);\n    }\n}\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (a > b) swap(a, b);\n    if (c < a) return 2;\n    if (b < c) return -2;\n    return 0;\n}\n\ntypedef vector<P> Pol;\n\nPol convex(Pol p) {\n    sort(p.begin(), p.end());\n    if (p.size() <= 2) return p;\n    Pol up;\n    for (P d: p) {\n        //if (up.size() > 1) printf(\"ccw%d\\n\",  ccw(up[up.size()-2], up[up.size()-1], d) );\n        while (up.size() > 1 && ccw(up[up.size()-2], up[up.size()-1], d) > 0) {\n        //    printf(\"pop\\n\");\n            up.pop_back();\n        }\n        //printf(\"push\\n\");\n        up.push_back(d);\n    }\n    reverse(up.begin(), up.end());\n    Pol down;\n    for (P d: p) {\n        while (down.size() > 1 && ccw(down[down.size()-2], down[down.size()-1], d) < 0) down.pop_back();\n        down.push_back(d);\n    }\n    //printf(\"%ld %ld\\n\", up.size(), down.size());\n    down.insert(down.begin(), up.begin()+1, up.end()-1);\n    return down;\n}\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (!n) break;\n        Pol p;\n        for (int i = 0; i < n; i++) {\n            R x, y;\n            scanf(\"%Lf,%Lf\", &x, &y);\n            p.push_back(P(x, y));\n        }\n        cout << n-convex(p).size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <map>\nusing namespace std;\n\ntypedef pair<double, double> P;\nbool isIn(P a, P b, P c, P p)\n{\n\tP s1(b.first - a.first, b.second - a.second);\n\tP s2(c.first - b.first, c.second - b.second);\n\tP s3(a.first - c.first, a.second - c.second);\n\tP p1(p.first - a.first, p.second - a.second);\n\tP p2(p.first - b.first, p.second - b.second);\n\tP p3(p.first - c.first, p.second - c.second);\n\tdouble x = (s1.first * p1.second) - (s1.second * p1.first);\n\tdouble y = (s2.first * p2.second) - (s2.second * p2.first);\n\tdouble z = (s3.first * p3.second) - (s3.second * p3.first);\n\n\tif (x >= 0 && y >= 0 && z >= 0) return true;\n\tif (x <= 0 && y <= 0 && z <= 0) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tint count = 0;\n\tP pos[100];\n\n\twhile (true)\n\t{\n\t\tcount = 0;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lf,%lf\", &(pos[i].first), &(pos[i].second));\n\t\t}\n\t\tfor (int p = 0; p < n; p++)\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tfor (int a = 0; a < n; a++)\n\t\t\t{\n\t\t\t\tif (a == p) continue;\n\t\t\t\tfor (int b = 0; b < n; b++)\n\t\t\t\t{\n\t\t\t\t\tif (b == a || b == p) continue;\n\t\t\t\t\tfor (int c = 0; c < n; c++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (c == a || c == b || c == p) continue;\n\t\t\t\t\t\tif (isIn(pos[a], pos[b], pos[c], pos[p]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag) break;\n\t\t\t\t}\n\t\t\t\tif (flag) break;\n\t\t\t}\n\t}\n\n\t\tprintf(\"%d\\n\", count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nbool operator<(const P &a, const P &b){\n    return real(a) != real(b) ? real(a) < real (b) : imag(a) < imag(b);\n}\n\nbool predication(const P &a, const P &b){\n    return real(a) != real(b) ? real(a) < real (b) : imag(a) < imag(b);\n}\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;                               // b==c || a--c--b on line\n}\n\nvector<P> convex_hull(vector<P> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end(), predication);\n    vector<P> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        vector<P> vec;\n        vector<P> ch;\n        double real,imag;\n        for(int i=0;i<n;i++){\n            cin >> real;\n            cin.ignore();\n            cin >> imag;\n            vec.push_back(complex<double>(real,imag));\n        }\n        ch = convex_hull(vec);\n        cout << n - ch.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define LOOP(i) while(i--)\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\ntemplate<typename T>\nclass Point2D{\n\tusing Same = const Point2D&;\npublic:\n\tT x,y;\n\tbool operator==(Same rhs){\n\t\treturn abs(x-rhs.x)<1e-8 && abs(y-rhs.y)<1e-8;\n\t}\n\tT operator^(Same rhs){\n\t\treturn x*rhs.y-rhs.x*y;\n\t}\n\tPoint2D operator-(Same rhs){\n\t\tPoint2D res(*this);\n\t\tres.x-=rhs.x,res.y-=rhs.y;\n\t\treturn res;\n\t}\n\tdouble GetNorm(){return hypot(x,y);}\n};\nusing Point2DD = Point2D<double>;\n\nvector<Point2DD> CalcConvexFullVertex(vector<Point2DD>& P){\n\tint N=P.size();\n\tPoint2DD A=P[0];\n\tvector<Point2DD> L;\n\tdo{\n\t\tL.push_back(A);\n\t\tPoint2DD B=P[0];\n\t\tfor(int i=1;i<N;i++){\n\t\t\tPoint2DD C=P[i];\n\t\t\tif(B==A){\n\t\t\t\tB = C;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tPoint2DD AB(B-A),AC(C-A);\n\t\t\t\tdouble outer = AB^AC;\n\t\t\t\tif(outer>0 || (abs(outer)<=1e-8 && AC.GetNorm()>AB.GetNorm())){\n\t\t\t\t\tB = C;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tA = B;\n\t}while(!(A==L[0]));\n\treturn L;\n}\n\nint main(){\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\n\twhile(true){\n\t\tint N=in();\n\t\tif(!N) break;\n\t\tvector<Point2DD> P(N);\n\t\tREP(i,N){\n\t\t\tscanf(\"%lf,%lf\",&P[i].x,&P[i].y);\n\t\t}\n\t\tsort(ALL(P),[](Point2DD& l,Point2DD& r){return l.x==r.x ? l.y<r.y : l.x<r.x;});\n\t\tauto L = CalcConvexFullVertex(P);\n\t\tout(N-L.size());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <string>\nclass Point;\nclass Sentinel;\nclass Point {\n\tlong double x, y;\npublic:\n\tPoint(const double &a = { 0 }, const double &b = { 0 }) :x(a), y(b) {};\n\tbool operator<(const Point &other) const {\n\t\treturn (x < other.x) || ((x == other.x) && (y < other.y));\n\t}\n\tbool operator>(const Point &other) const {\n\t\treturn other < *this;\n\t}\n\tlong double operator*(const Point &other) const {\n\t\treturn x * other.y - y * other.x;\n\t}\n\tvoid inspect() const {\n\t\tstd::cout << x << \"-\" << y << std::endl;\n\t}\n\tPoint operator-(const Point &other) const {\n\t\treturn Point(x - other.x, y - other.y);\n\t}\n};\nclass Sentinel : public Point {\npublic:\n\tSentinel() :Point(10000,10000) {};\n};\nstd::list<Point> sort(std::vector<Point> &vec, const int &left, const int &right) {\n\tif (left == right) {\n\t\treturn std::list<Point>{vec.at(left), Sentinel()};\n\t}\n\telse {\n\t\tstd::list<Point> l = sort(vec, left, left + (right - left) / 2);\n\t\tstd::list<Point> r = sort(vec, left + 1 + (right - left) / 2, right);\n\t\tstd::list<Point> res;\n\t\tfor (const auto &a : l) {\n\t\t\twhile (r.front() < a) {\n\t\t\t\tres.push_back(r.front());\n\t\t\t\tr.pop_front();\n\t\t\t}\n\t\t\tres.push_back(a);\n\t\t}\n\t\treturn res;\n\t}\n}\ndouble sub(const Point &a, const Point &b, const Point &c) {\n\treturn (a - b) * (b - c);\n}\nint main() {\n\tint n;\n\tstd::cin >> n;\n\twhile (n != 0) {\n\t\tstd::vector<Point> vec(n);\n\t\tfor (auto &v : vec) {\n\t\t\tdouble x, y;\n\t\t\tstd::scanf(\"%lf,%lf\", &x, &y);\n\t\t\tv = Point(x, y);\n\t\t}\n\t\tauto list = sort(vec, 0, n - 1);\n\t\tlist.pop_back();\n\t\tstd::vector<Point> a(n + 2), b(n + 2);\n\t\ta.at(0) = list.front(), a.at(1) = list.front(), b.at(0) = list.front(), b.at(1) = list.front();\n\t\tauto i = 1, j = 1;\n\t\tfor (const auto &p : list) {\n\t\t\twhile (sub(a.at(i - 1), a.at(i), p) > 0) {\n\t\t\t\t--i;\n\t\t\t\t//std::cout << i << \"-\";\n\t\t\t}\n\t\t\ta.at(++i) = p;\n\t\t\t//std::cout << i << std::endl;\n\t\t\twhile (sub(b.at(j - 1), b.at(j), p) < 0) {\n\t\t\t\t--j;\n\t\t\t\t//std::cout << j << \"=\";\n\t\t\t}\n\t\t\tb.at(++j) = p;\n\t\t\t//std::cout << j <<  std::endl;\n\t\t}\n\t\tstd::cout << n - i - j + 4 << std::endl;\n\t\tstd::cin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Point {\npublic:\n  double x;\n  double y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  bool operator <(const Point &p) const {\n    if(x != p.x) return x < p.x;\n    if(y != p.y) return y < p.y;\n    return false;\n  }\n};\n\ntypedef Point Vector;\n\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y - a.y*b.x;\n}\n\nint main() {\n  while(1) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n\n    vector<Point> P;\n    for(int i = 0; i < n; i++) {\n      double x, y;\n      scanf(\"%lf,%lf\", &x, &y);\n      P.push_back(Point(x, y));\n    }\n\n    int ans;\n    if(P.size() == 3) {\n      ans = 0;\n    } else {\n      sort(P.begin(), P.end());\n      vector<Vector> convex;\n\n      convex.push_back(P[0]);\n      convex.push_back(P[1]);\n      for(int i = 2; i < P.size(); i++) {\n\tif(convex.size() != 1 &&\n\t   cross(Vector(convex.rbegin()->x-(convex.rbegin()-1)->x,\n\t\t\tconvex.rbegin()->y-(convex.rbegin()-1)->y ),\n\t\t Vector(P[i].x-P[i-1].x, P[i].y-P[i-1].y)) > 0) {\n\t  convex.pop_back();\n\t  i--;\n\t  continue;\n\t}\n\tconvex.push_back(P[i]);\n      }\n\n      int num = convex.size();\n      convex.push_back(P[n-2]);\n      for(int i = n-3; i >= 0; i--) {\n\tif(convex.size() != num &&\n\t   cross(Vector(convex.rbegin()->x-(convex.rbegin()-1)->x,\n\t                convex.rbegin()->y-(convex.rbegin()-1)->y ),\n\t\t Vector(P[i-1].x-P[i].x, P[i-1].y-P[i].y)) > 0) {\n\t  convex.pop_back();\n\t  i++;\n\t  continue;\n\t}\n\tif(i != 0) convex.push_back(P[i]);\n      }\n\n      ans = n - (int)convex.size();\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<double, double> P;\n\nvoid solve()\n{\n\tint n;\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> pin(n);\n\t\tchar c;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tcin >> pin[i].first >> c >> pin[i].second;\n\t\t}\n\t\tsort(pin.begin(), pin.end());\n\t\tif(pin[0].first == pin[1].first && pin[0].second > pin[1].second)\n\t\t{\n\t\t\tP p = pin[0];\n\t\t\tpin[0] = pin[1];\n\t\t\tpin[1] = p;\n\t\t}\n\t\tbool isUsed[101] = {false};\n\t\tisUsed[0] = true;\n\t\tP current = pin[0];\n\t\tbool update = true;\n\t\twhile(update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tdouble max_slope = -99999999;\n\t\t\tint max_pin = 0;\n\t\t\tfor(int i = 1; i < n; ++i)\n\t\t\t{\n\t\t\t\tif(current.first < pin[i].first)\n\t\t\t\t{\n\t\t\t\t\tif(max_slope < (pin[i].second - current.second) / (pin[i].first - current.first))\n\t\t\t\t\t{\n\t\t\t\t\t\tmax_slope = (pin[i].second - current.second) / (pin[i].first - current.first);\n\t\t\t\t\t\tmax_pin = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(update)\n\t\t\t{\n\t\t\t\tisUsed[max_pin] = true;\n\t\t\t\tcurrent = pin[max_pin];\n\t\t\t}\n\t\t}\n\t\tcurrent = pin[0];\n\t\tupdate = true;\n\t\twhile(update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tdouble min_slope = 99999999;\n\t\t\tint min_pin = 0;\n\t\t\tfor(int i = 1; i < n; ++i)\n\t\t\t{\n\t\t\t\tif(current.first < pin[i].first)\n\t\t\t\t{\n\t\t\t\t\tif(min_slope > (pin[i].second - current.second) / (pin[i].first - current.first))\n\t\t\t\t\t{\n\t\t\t\t\t\tmin_slope = (pin[i].second - current.second) / (pin[i].first - current.first);\n\t\t\t\t\t\tmin_pin = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(update)\n\t\t\t{\n\t\t\t\tisUsed[min_pin] = true;\n\t\t\t\tcurrent = pin[min_pin];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif(isUsed[i] == false)\n\t\t\t{\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\ntypedef long long ll;\nusing namespace std;\nstruct point_t { double x, y; };\nbool operator < (point_t const & a, point_t const & b) { return make_pair(a.x,a.y) < make_pair(b.x,b.y); }\npoint_t operator + (point_t const & a, point_t const & b) { return { a.x + b.x, a.y + b.y }; }\npoint_t operator - (point_t const & a, point_t const & b) { return { a.x - b.x, a.y - b.y }; }\ndouble cross(point_t const & a, point_t const & b) { return a.x * b.y - a.y * b.x; }\ndouble ccw(point_t const & a, point_t const & b, point_t const & c) { return cross(b - a, c - a); }\nvector<point_t> convex_hull(vector<point_t> ps) {\n    int n = ps.size();\n    sort(ps.begin(), ps.end());\n    vector<point_t> qs;\n    int d = 1;\n    for (int i = 0; i >= 0; i += d) { // lower hull\n        if (i == n-1) d = -1;\n        int k = qs.size();\n        while (k >= 2 and ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            qs.pop_back();\n            k = qs.size();\n        }\n        qs.push_back(ps[i]);\n    }\n    qs.pop_back();\n    return qs;\n}\nint solve(vector<point_t> const & ps) {\n    vector<point_t> qs = convex_hull(ps);\n    return ps.size() - qs.size();\n}\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<point_t> ps(n);\n        char dummy;\n        for (auto && p : ps) cin >> p.x >> dummy >> p.y;\n        cout << solve(ps) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Point {\npublic:\n  double x;\n  double y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  bool operator <(const Point &p) const {\n    if(x != p.x) return x < p.x;\n    if(y != p.y) return y < p.y;\n    return false;\n  }\n};\n\ntypedef Point Vector;\n\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y - a.y*b.x;\n}\n\nint main() {\n  while(1) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n\n    vector<Point> P;\n    for(int i = 0; i < n; i++) {\n      double x, y;\n      scanf(\"%lf,%lf\", &x, &y);\n      P.push_back(Point(x, y));\n    }\n\n    int ans;\n    if(P.size() == 3) {\n      ans = 0;\n    } else {\n      sort(P.begin(), P.end());\n\n      vector<Point> upper;\n      upper.push_back(P[0]);\n      upper.push_back(P[1]);\n      for(int i = 2; i < n; i++) {\n\twhile(upper.size() != 1 &&\n\t      cross(Vector(upper.rbegin()->x - (upper.rbegin()+1)->x,\n\t\t\t   upper.rbegin()->y - (upper.rbegin()+1)->y ),\n\t\t    Vector(P[i].x-upper.rbegin()->x,\n\t\t\t   P[i].y-upper.rbegin()->y)                   ) > 0) {\n\t  upper.pop_back();\n\t}\n\tupper.push_back(P[i]);\n      }\n\n      vector<Point> lower;\n      lower.push_back(P[n-1]);\n      lower.push_back(P[n-2]);\n      for(int i = n-3; i >= 0; i--) {\n\twhile(lower.size() != 1 &&\n\t      cross(Vector(lower.rbegin()->x - (lower.rbegin()+1)->x,\n\t\t\t   lower.rbegin()->y - (lower.rbegin()+1)->y ),\n\t\t    Vector(P[i].x-lower.rbegin()->x,\n\t\t\t   P[i].y-lower.rbegin()->y)                   ) > 0) {\n\t  lower.pop_back();\n\t}\n\tlower.push_back(P[i]);\n      }\n      ans = n - (int)(upper.size() + lower.size() - 2);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define int long long\npair<double,double> operator+(const pair<double,double> &v1, const pair<double,double> &v2){\n\treturn pair<double, double>(v1.first+v2.first,v1.second+v2.second);\n}\npair<double,double> operator-(const pair<double,double> &v1, const pair<double,double> &v2){\n\treturn pair<double, double>(v1.first-v2.first,v1.second-v2.second);\n}\ndouble inner_product(pair<double, double> v1, pair<double, double> v2){\n\treturn v1.first*v2.first+v1.second*v2.second;\n}\ndouble outer_product(pair<double, double> v1, pair<double, double> v2){\n\treturn v1.first*v2.second-v1.second*v2.first;\n}\ndouble angle(pair<double, double> p1,\n\t\tpair<double,double> p2,\n\t\tpair<double,double> p3){\n\tauto v1 = p1-p2;\n\tauto v2 = p3-p2;\n\tauto ip = inner_product(v1,v2);\n\tauto op = (outer_product(v1,v2)>0)?1:-1;\n\tauto l1 = hypot(v1.first,v1.second);\n\tauto l2 = hypot(v2.first,v2.second);\n\treturn acos(ip/l1/l2)*op;\n}\nsigned main(){\n\tint a;\n\twhile( scanf(\"%lld\", &a) != EOF ){\n\t\tif(a==0) break;\n\t\tvector<pair<double,double>> vertex;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf,%lf\",&x,&y);\n\t\t\tvertex.push_back(pair<int,int>(x,y));\n\t\t}\n\t\tsort(vertex.begin(),vertex.end());\n\t\tdouble tx=0,ty=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\ttx += vertex[i].first;\n\t\t\tty += vertex[i].second;\n\t\t}\n\t\ttx /= a;\n\t\tty /= a;\n\t\tvector<int> visited(vertex.size(),0);\n\t\tvector<pair<int,int>> edges;\n\t\tauto prev = -1;\n\t\tauto now = 0;\n\t\tauto counter = 0;\n\t\twhile(true){\n\t\t\tif(visited[now]==1) break;\n\t\t\tcounter += 1;\n\t\t\tvisited[now] = 1;\n\t\t\tauto maxe = -100.0;\n\t\t\tauto next = -1;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(i==now||i==prev) continue;\n\t\t\t\tauto pv = (prev==0)?pair<double,double>(tx,ty):vertex[prev];\n\t\t\t\tauto ta = angle(pv, vertex[now], vertex[i]);\n\t\t\t\tif(maxe<ta){\n\t\t\t\t\tmaxe = ta;\n\t\t\t\t\tnext = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = now;\n\t\t\tnow = next;\n\t\t}\n\t\tcout << a-counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<30;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-8;\n\ntypedef complex<double> P;\ntypedef complex<double> Vec;\n\ndouble cross(Vec a, Vec b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool comp(P a, P b) {\n\tif (a.real() != b.real()) return a.real() < b.real();\n\treturn a.imag() < b.imag();\n}\n\nvector<P> convex_full(vector<P> p) {\n\tsort(ALL(p), comp);\n\t\n\tvector<P> res(2 * p.size());\n\tint k = 0;\n\t\n\t// ?????´??????\n\tREP(i, p.size()) {\n\t\twhile (k > 1 && cross(res[k - 1] - res[k - 2], p[i] - res[k - 2]) <= 0) k--;\n\t\tres[k++] = p[i];\n\t}\n\t\n\t// ?????´??????\n\tfor (int i = (int)p.size() - 2, c1 = k; i >= 0; i--) {\n\t\twhile (k > c1 && cross(res[k - 1] - res[k - 2], p[i] - res[k - 2]) <= 0) k--;\n\t\tres[k++] = p[i];\n\t}\n\t\n\tres.resize(k - 1);\n\treturn res;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<P> p(n);\n\t\tREP(i, n) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tp[i] = P(x, y);\n\t\t}\n\t\t\n\t\tvector<P> cf = convex_full(p);\n\t\t\n\t\tcout << p.size() - cf.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef long long int lli;\nconst double EPS = 1e-10;\ntemplate<class T>\nbool eq(const T& a, const T& b) {return abs(a - b) < EPS;}\n\nusing point = complex<double>;\n// sort/unique用、setではうまく動かないので使うべからず\nnamespace std {\n\tbool operator==(const point &a, const point &b){\n\t\treturn eq(a, b);\n\t}\n\tbool operator<(const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;  // counter clockwise\n\tif (cross(b, c) < 0)   return -1;  // clockwise\n\tif (dot(b, c) < 0)     return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;  // a--c--b on line or a----bc\n}\n\n\n//点集合 ps に対してその凸包を求める．\n//O(n log n)\nvector<point> convex_hull(vector<point> ps) {\n  int n=ps.size(), k=0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i=0; i < n; ch[k++]=ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i=n-2, t=k+1; i >= 0; ch[k++]=ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main()\n{\n  int n;\n  for(;cin>>n,n;)\n    {\n      vector<point> a;\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y;\n\t  char aa;\n\t  cin>>x>>aa>>y;\n\t  a.push_back(point(x,y));\n\t}\n      cout<<n-convex_hull(a).size()<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tint n, ans;\n\tint next, last, now, start;\n\tdouble lx0, lx1, ly0, ly1, sx, sy, vx0, vx1, vy0, vy1;\n\tdouble arg, tmp;\n\tdouble px[101], py[101];\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tans = n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf,%lf\", &px[i], &py[i]);\n\t\t}\n\t\tpx[100] = -999999;\n\t\tpy[100] = -999999;\n\t\t// select 2 top point\n\t\tlast = now = next = 100;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (py[i] > py[last]) {\n\t\t\t\tlast = i;\n\t\t\t}else if (py[i] > py[now]) {\n\t\t\t\tnow = i;\n\t\t\t}\n\t\t}\n\t\t//cout << last << endl;\n\t\t//cout << now << endl;\n\t\t//cout << \"---\" << endl;\n\t\tans -= 2;\n\t\tstart = last;\n\t\twhile (start != now) {\n\t\t\t// determine next point\n\t\t\targ = 1.0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif(i == now || i == last){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvx0 = px[i] - px[now];\n\t\t\t\tvy0 = py[i] - py[now];\n\t\t\t\tvx1 = px[last] - px[now];\n\t\t\t\tvy1 = px[last] - py[now];\n\n\t\t\t\ttmp = (vx0*vx1 + vy0*vy1) / (sqrt(vx0*vx0 + vy0*vy0) * sqrt(vx1*vx1 + vy1*vy1));\n\t\t\t\tif (arg > tmp) {\n\t\t\t\t\targ = tmp;\n\t\t\t\t\tnext = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << next << endl;\n\t\t\tlast = now;\n\t\t\tnow = next;\n\t\t\tans--;\n\t\t}\n\t\tans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct P{\n\tdouble x;\n\tdouble y;\n};\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return a.x != b.x ? a.x < b.x : a.y < b.y;\n  }\n}\n\nint ccw(P p0, P p1, P p2)\n{\n\tdouble dx1 = p1.x-p0.x;\n\tdouble dy1 = p1.y-p0.y;\n\tdouble dx2 = p2.x-p0.x;\n\tdouble dy2 = p2.y-p0.y;\n\t\n\tif(dx1*dy2 > dy1*dx2){\n\t\treturn 1;\n\t} \n\tif(dx1*dy2 < dy1*dx2){\n\t\treturn -1;\n\t}\n\tif((dx1*dx2 < 0) || (dy1*dy2 < 0)){\n\t\treturn -1;\n\t}\n\tif((dx1*dx1+dy1*dy1)<(dx2*dx2+dy2*dy2)){\n\t\treturn 1;\n\t}\n\t\n\treturn 0;\n}\n\nint convh(vector<P> vec)\n{\n\tint n = vec.size(), k = 0;\n\tsort(vec.begin(), vec.end());\n\tvector<P> ch(2*n);\n\t\n\tfor(int i = 0; i < n; ch[k++] = vec[i++]){\n\t\twhile(k >= 2 && ccw(ch[k-2], ch[k-1], vec[i]) <= 0){\n\t\t\tk--;\n\t\t}\n\t}\n\t\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++] = vec[i--]){\n\t\twhile(k >= t && ccw(ch[k-2], ch[k-1], vec[i]) <= 0){\n\t\t\tk--;\n\t\t}\n\t}\n\t\n\tch.resize(k-1);\n\t\n\treturn ch.size();\n}\n\nint main()\n{\n\tint n;\n\tP t;\n\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<P> vec;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\", &t.x, &t.y);\n\t\t\tvec.push_back(t);\n\t\t}\n\t\t\n\t\tcout << (n-convh(vec)) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-11;\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) { return a < b - EPS ? -1 : (a > b + EPS ? 1 : 0); }\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める (時計回りだと負になる)\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn res/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n/** Problem0068 : Enclose Pins with a Rubber Band **/\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tvector<P> ps;\n\t\trep(i, N) {\n\t\t\tchar c;\n\t\t\tP p; cin>>p.X>>c>>p.Y;\n\t\t\tps.push_back(p);\n\t\t}\n\t\tcout << ps.size() - convex_hull(ps).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<stack>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return a.X==b.X ? a.Y<b.Y : a.X<b.X;}\n}\n\ndouble cross(P a,P b){return a.X*b.Y-a.Y*b.X;}\nbool ccw(P a,P b,P c){return cross(b-a,c-a)>=0;}\n\nvector<P> convex_VP(vector<P> p){\n\t\n\tsort(p.begin(),p.end());\n\tvector<P> ret(p.size()*2);\n\t\n\tint k=0;\n\tfor(int i=0;i<p.size();i++){\n\t\twhile(k>1 && !ccw(ret[k-2],ret[k-1],p[i]))k--;\n\t\tret[k]=p[i];k++;\n\t}\n\t\n\tint t=k;\n\tfor(int i=p.size()-2;i>=0;i--){\n\t\twhile(k>t && !ccw(ret[k-2],ret[k-1],p[i]))k--;\n\t\tret[k]=p[i];k++;\n\t}\n\t\n\treturn vector<P>(ret.begin(), ret.begin()+k-1);\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\t\n\t\tvector<P> p;\n\t\trep(i,n){\n\t\t\tdouble a,b;\n\t\t\tscanf(\"%lf,%lf\",&a,&b);\n\t\t\tp.push_back(P(a,b));\n\t\t}\n\t\t\n\t\tvector<P> convex = convex_VP(p);\n\t\trep(i,convex.size()){\n\t\t\tprintf(\"%lf %lf\\n\",convex[i].X,convex[i].Y);\n\t\t}\n\t\tcout<<(int)p.size()-(int)convex.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <set>\n#include <complex>\n\n#define P_P    const P& a, const P& b\n\nusing namespace std;\n\ntypedef long long int lint;\ntypedef complex<double> P;\n\nnamespace std {\nbool operator < (P_P){\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n}\n}\ndouble cross(P_P){ return imag(conj(a) * b); }\ndouble dot(P_P){ return real(conj(a) * b); }\nint ccw(P a, P b, P c){\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;\n    if (cross(b, c) < 0)   return -1;\n    if (dot(b, c) < 0)     return +2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\ntypedef vector<P> G;\n\nG convex_hull(G ps){\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    G ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\ntemplate<typename T> inline bool in(T& x){ return cin >> x; }\ntemplate<typename T> inline T in(){T x; cin >> x; return x; }\n\nint main()\n{\n    int n;\n\n    while (scanf(\"%d\", &n), n){\n        G g;\n        for (int i = 0; i < n; i++){\n            double x, y;\n            scanf(\"%lf,%lf\", &x, &y);\n            g.push_back(P(x, y));\n        }\n        printf(\"%zu\\n\", g.size() - convex_hull(g).size());\n    }\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cfloat>\n#include<cassert>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define EPS (1e-5)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) && n){\n\t\tPolygon in;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdouble p1, p2;\n\t\t\tscanf(\"%lf,%lf\", &p1, &p2);\n\t\t\tin.push_back(Point(p1, p2));\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", in.size() - conhel(in).size());\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\n\ntypedef complex<double> P;\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(const P& a, const P& b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if(cross(b, c) > 0) return +1;\n    if(cross(b, c) < 0) return -1;\n    if(dot(b, c) < 0) return +2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<P> ch(n * 2);\n    for(int i = 0; i < n; ch[k++] = ps[i++])\n      while(k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n      while(k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N && N) {\n        double x_, y_; char gomi;\n        vector<P> ps(N);\n        rep(i, N) {\n            cin >> x_ >> gomi >> y_;\n            ps[i] = P(x_, y_);\n        }\n\n        cout << N - convex_hull(ps).size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define PAIR pair<double, double>\n\nint main() {\n\tint n, k;\n\tdouble s, x, y, x1, y1, tmp, d, h;\n\tchar t;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\n\t\tvector<PAIR> list;\n\t\tvector<int> res;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x >> t >> y;\n\t\t\tlist.push_back(make_pair(x, y));\n\t\t}\n\t\tsort(list.begin(), list.end());\n\n\t\tdouble dx = list[0].first;\n\t\tdouble dy = list[0].second;\n\n\t\tk = 1;\n\t\ts = (list[1].second - dy) / (list[1].first - dx);\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tx = list[i].first;\n\t\t\ty = list[i].second;\n\n\t\t\ttmp = (y - dy) / (x - dx);\n\t\t\tif (s < tmp) {\n\t\t\t\ts = tmp;\n\t\t\t\tk = i;\n\t\t\t}\n\t\t}\n\n\t\tres.push_back(0);\n\t\tres.push_back(k);\n\t\twhile (true) {\n\t\t\th = 0;\n\t\t\tk = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx = list[i].first;\n\t\t\t\ty = list[i].second;\n\n\t\t\t\tx1 = list[res[res.size() - 1]].first;\n\t\t\t\ty1 = list[res[res.size() - 1]].second;\n\n\t\t\t\tdx = list[res[res.size() - 2]].first;\n\t\t\t\tdy = list[res[res.size() - 2]].second;\n\n\t\t\t\tdx -= x1;\n\t\t\t\tdy -= y1;\n\n\t\t\t\tx -= x1;\n\t\t\t\ty -= y1;\n\n\t\t\t\td = (dx * x + dy * y) / (hypot(dx, dy) * hypot(x, y));\n\t\t\t\td = acos(d);\n\t\t\t\tif (h < d) {\n\t\t\t\t\tk = i;\n\t\t\t\t\th = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k == 0) break;\n\t\t\tres.push_back(k);\n\t\t}\n\t\tcout << n - res.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ALL( c ) (c).begin(), (c).end()\n\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() : x( 0 ), y( 0 )\n\t{\n\t\treturn;\n\t}\n\n\tPoint( double x, double y ) : x( x ), y( y )\n\t{\n\t\treturn;\n\t}\n\n\tPoint operator + ( const Point &a ) const\n\t{\n\t\treturn Point( x + a.x, y + a.y );\n\t}\n\n\tPoint operator - ( const Point &a ) const\n\t{\n\t\treturn Point( x - a.x, y - a.y );\n\t}\n\n\tPoint operator * ( const double &a ) const\n\t{\n\t\treturn Point( x * a, y * a );\n\t}\n\n\tPoint operator / ( const double &a ) const\n\t{\n\t\treturn Point( x / a, y / a );\n\t}\n\n\tbool operator < ( const Point &a ) const\n\t{\n\t\treturn x == a.x ? y < a.y : x < a.x;\n\t}\n};\n\n// ??????\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// Graham Scan\nvector< Point > getConvex( vector< Point > ps )\n{\n\tconst int N = ps.size();\n\n\tsort( ALL( ps ) );\n\n\tint k = 0;\n\tvector< Point > convex( N * 2 );\n\n\tfor ( int i = 0; i < N; i++ )\n\t{\n\t\twhile ( 2 <= k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tfor ( int i = N - 2, t = k; 0 <= i; i-- )\n\t{\n\t\twhile ( t < k && cross( convex[ k - 1 ] - convex[ k - 2 ], ps[i] - convex[ k - 1 ] ) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.resize( k - 1 );\n\n\treturn convex;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< Point > ps( n );\n\n\t\tEACH( p, ps )\n\t\t{\n\t\t\tchar d;\n\n\t\t\tcin >> p.x >> d >> p.y;\n\t\t}\n\n\t\tvector< Point > convex = getConvex( ps );\n\n\t\tcout << n - convex.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <functional>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <typeinfo>\n#define PI 3.14159265359\n#define INF 99999999\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(n) rep(i, n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\nusing namespace std;\n//typedef pair<int, int> P;\n\nstruct point\n{\n\tdouble x, y;\n};\n\ninline void swap(point a[], int i, int j)\n{\n\tpoint t = a[i]; a[i] = a[j]; a[j] = t;\n}\n\ndouble theta(point p1, point p2)\n{\n\tint dx, dy, ax, ay;\n\tdouble t;\n\tdx = p2.x - p1.x; ax = abs(dx);\n\tdy = p2.y - p1.y; ay = abs(dy);\n\tt = (ax + ay == 0) ? 0 : (double) dy / (ax + ay);\n\tif (dx < 0) t = 2 - t; else if (dy < 0) t = 4 + t;\n\treturn t * 90.0;\n}\n\nint wrap(point p[], int N)\n{\n\tint i, min, M;\n\tdouble th, v;\n\tfor (min=0, i=1; i<N; i++)\n\t{\n\t\tif (p[i].y <p[min].y) min = i;\n\t}\n\tp[N] = p[min]; th = 0.0;\n\tfor (M=0; M<N; M++)\n\t{\n\t\tswap(p, M, min);\n\t\tmin = N; v = th; th = 360.0;\n\t\tfor (i=M+1; i<=N; i++)\n\t\t{\n\t\t\tif (theta(p[M], p[i]) > v)\n\t\t\t{\n\t\t\t\tif (theta(p[M], p[i]) < th)\n\t\t\t\t{\n\t\t\t\t\tmin = i; th = theta(p[M], p[min]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (min == N) return M;\n\t}\n}\n\nint n;\npoint P[100];\nchar comma;\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\trep(i, n)\n\t\t{\n\t\t\tcin >> P[i].x >> comma >> P[i].y;\n\t\t}\n\t\tif (n - wrap(P, n) > 0) cout << n - wrap(P, n) - 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <complex>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos(-1);\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return imag(conj(a)*b); }\nR dot(P a, P b) { return real(conj(a)*b); }\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nnamespace std {\n    bool operator < (P a, P b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nint ccw(P a, P b, P c) {\n    double cr = cross(b-a, c-a);\n    if (cr > EPS) return 1;\n    if (cr < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (dot(a-b, c-b) < -EPS) return -2;\n    return 0;\n}\n\ntypedef vector<P> Pol;\n\nPol convex(Pol p) {\n    sort(p.begin(), p.end());\n    if (p.size() <= 2) return p;\n    Pol up;\n    for (P d: p) {\n        //if (up.size() > 1) printf(\"ccw%d\\n\",  ccw(up[up.size()-2], up[up.size()-1], d) );\n        while (up.size() > 1 && ccw(up[up.size()-2], up[up.size()-1], d) > 0) {\n        //    printf(\"pop\\n\");\n            up.pop_back();\n        }\n        //printf(\"push\\n\");\n        up.push_back(d);\n    }\n    reverse(up.begin(), up.end());\n    Pol down;\n    for (P d: p) {\n        while (down.size() > 1 && ccw(down[down.size()-2], down[down.size()-1], d) < 0) down.pop_back();\n        down.push_back(d);\n    }\n    //printf(\"%ld %ld\\n\", up.size(), down.size());\n    down.insert(down.begin(), up.begin()+1, up.end()-1);\n    return down;\n}\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (!n) break;\n        Pol p;\n        for (int i = 0; i < n; i++) {\n            R x, y;\n            scanf(\"%Lf,%Lf\", &x, &y);\n            p.push_back(P(x, y));\n        }\n        cout << n-convex(p).size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<climits>\n#include<complex>\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n\nG convex_hull(G &ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  int N;\n  while(cin >>N && N){\n    G ps(N);\n    REP(i, N){\n      double x, y;\n      scanf(\"%lf,%lf\", &x, &y);\n      ps[i] = P(x, y);\n    }\n    G res = convex_hull(ps);\n    cout <<N - (int)(res.size()) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require sqrt ceil floor\n#include <climits>\t// require INT_MAX etc\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <stdint.h>\t// require uint64_t\n#include <fstream>\t// require freopen\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int MAX_LEN = 4000.0;\nconst int MAX_ARG = M_PI;\n\n// àÏ (dot product) : a&#8901;b = |a||b|cosÆ\ndouble dot(P a, P b)\n{\n\tdouble res = a.real() * b.real() + a.imag() * b.imag();\n\n\treturn res;\n}\n// OÏ (cross product) : a~b = |a||b|sinÆ\n\ndouble cross(P a, P b)\n{\n\tdouble res = a.real() * b.imag() - a.imag() * b.real();\n\n  return res;\n}\n\ndouble stod (string str )\n{\n\tstringstream ss (str );\n\tdouble res;\n\n\tss >> res;\n\n\treturn res;\n}\n\nbool cmp (P a, P b )\n{\n\tif (a.imag() != b.imag() )\n\t\treturn a.imag() < b.imag();\n\n\treturn a.real() < b.real();\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.epl\", \"r\", stdin );\n\tint n;\n\n\twhile (cin >> n && n ){\n\n\t\tvector <P> pos (n);\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\tstring str = \"\";\n\t\t\tcin >> str;\n\t\t\tdouble x = stod (str.substr (0, str.find (',') ) );\n\t\t\tdouble y = stod (str.substr (str.find (',')+1) );\n\t\t\tP p;\n\t\t\tp.real() = x;\n\t\t\tp.imag() = y;\n\t\t\tpos[i] = p;\n\t\t} // end for\n\t\tsort (pos.begin(), pos.end(), cmp );\n\n\t\tvector <int> used (n, 0 );\n//\t\tused[0] = 1;\n\t\tP start = pos[0];\n\t\tP curr = pos[0];\n\t\tP base;\n\t\tbase.real() = 1.0;\n\t\tbase.imag() = 0.0;\n\n\t\tP next, prev;\n\n\t\tdouble len = MAX_LEN;\n\t\tdouble min_arg = M_PI;\n\t\tint nd = -1;\n\n\t\tfor (int i = 1; i < n; ++i ){\n//\t\t\tif (used[i] )\n//\t\t\t\tcontinue;\n\t\t\tP b = base;\n\t\t\tP c = pos[i] - curr;\n\t\t\tdouble d = dot (b, c );\n\t\t\tdouble a = 0.0;\n\t\t\tif (d < 0.0 ){\t\n\t\t\t\t\ta = M_PI/2.;\n\t\t\t\t} // end if\n\t\t\ta += acos (fabs(d )/abs(b )/abs (c ) );\n\t\t\tif (min_arg >= a ){\n\t\t\t\tif (min_arg == a && len > abs (c ) )  {\n\t\t\t\t\tnext = pos[i];\n\t\t\t\t\tnd = i;\n\t\t\t\t\tlen = MAX_LEN;\n\t\t\t\t}else{\n\t\t\t\t\tmin_arg = a;\n\t\t\t\t\tnext = pos[i];\n\t\t\t\t\tnd = i;\n\t\t\t\t\tlen = min (len, abs (c ) );\n\t\t\t\t} // en dif\n\t\t\t} // end if\n\t\t} // end for\n\t\tif (nd != - 1 ) \n\t\t\tused[nd] = 1;\n\n\t\tprev = next;\n\t\tbase = curr;\n\t\tdo{\n\t\t\tlen = MAX_LEN;\n\t\t\tmin_arg = M_PI;\n\t\t\tnd = -1;\n\t\t\tfor (int i = 0; i < n; ++i ){\n\n\t\t\t\tif (used[i] )\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tP b = prev - base;\n\t\t\t\tP c = pos[i] - base;\n\t\t\t\tdouble d = dot (b, c );\n\t\t\t\tdouble a = 0.0;\n\t\t\t\tif (d < 0.0 ){\n\t\t\t\t\ta = M_PI/2.;\n\t\t\t\t} // end if\n\t\t\t\n\t\t\t\ta += acos (fabs(d)/ abs (b) / abs (c ) );\n\n\t\t\t\tif (min_arg >= a ) {\n\t\t\t\t\tif (min_arg == a && len > abs (c ) ) {\n\t\t\t\t\t\tlen = abs (c );\n\t\t\t\t\t\tnext = pos[i];\n\t\t\t\t\t\tnd = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmin_arg = a;\n\t\t\t\t\t\tnext = pos[i];\n\t\t\t\t\t\tnd = i;\n\t\t\t\t\t\tlen = min (len, abs (c ) );\n\t\t\t\t\t} // en dif\n\t\t\t\t} // end if\n\t\t\t} // end for\n\n\t\t\tif (nd != -1 ) \n\t\t\t\tused[nd] = 1;\n\t\t\tbase = prev;\n\t\t\tprev = next;\n\n//\t\t}while (next != start && (int)count (used.begin(), used.end(),1 ) != n );\n\t\t}while (prev != start );\n\n\t\tint res = (int)count (used.begin(), used.end(), 0 );\t\n\n\t\tcout << res << endl;\t\n\n\t} // end loop\n\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef long long int lli;\nconst double EPS = 1e-10;\ntemplate<class T>\nbool eq(const T& a, const T& b) {return abs(a - b) < EPS;}\n\ntypedef  complex<double> point;\n// sort/unique用、setではうまく動かないので使うべからず\nnamespace std {\n\tbool operator==(const point &a, const point &b){\n\t\treturn eq(a, b);\n\t}\n\tbool operator<(const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;  // counter clockwise\n\tif (cross(b, c) < 0)   return -1;  // clockwise\n\tif (dot(b, c) < 0)     return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;  // a--c--b on line or a----bc\n}\n\n\ntypedef vector<point> polygon;\n\n//凸包\n//点集合 ps に対してその凸包を求める．\n//O(n log n)\npolygon  convex_hull(polygon ps) {\n  int n=ps.size(), k=0;\n  sort(ps.begin(), ps.end());\n  polygon ch(2*n);\n  for (int i=0; i < n; ch[k++]=ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i=n-2, t=k+1; i >= 0; ch[k++]=ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main()\n{\n  int n;\n  for(;cin>>n,n;)\n    {\n      polygon a;\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y;\n\t  char aa;\n\t  cin>>x>>aa>>y;\n\t  a.push_back(point(x,y));\n\t}\n      cout<<n-convex_hull(a).size()<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,c??????????¨???¨?????????????????¶\n//-1: a,b,c???????¨???¨?????????????????¶\n// 2: c,a,b???????????´???????????¶\n//-2: a,b,c???????????´???????????¶\n// 0: a,c,b???????????´???????????¶\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//???????±??????????????????????\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n/*  0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), all(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n//???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\trep(i, n) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tedge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nvoid add_edge(graph &g, const int from, const int to, const Weight& weight) {\n\tg[from].push_back(edge{ from, to, weight });\n}\n\ngraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\ngraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll2(s[i], s[j])[0]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\nsort(crss.begin(), crss.end());\ncrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\treturn segment_arrangement(s, crss);\n}\n\ngraph Circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t}\n\treturn g;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tPolygon poly(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tstring stx = st.substr(0, st.find(','));\n\t\t\tstring sty = st.substr(st.find(',' ) + 1);\n\t\t\tld x = stod(stx);\n\t\t\tld y = stod(sty);\n\t\t\tpoly[i] = Point(x, y);\n\t\t}\n\t\tPolygon ch(convex_hull(poly));\n\t\tint num = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tbool ok = false;\n\t\t\tPoint p(poly[i]);\n\t\t\tfor (int j = 0; j < ch.size(); ++j) {\n\t\t\t\tLine l(ch[j],ch[(j + 1) % ch.size()]);\n\t\t\t\tif (isis_lp(l, p))ok = true;\n\t\t\t}\n\t\t\tif (ok)num++;\n\t\t}\n\t\tcout << N - num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void){\n\tint n;\n\tdouble v[101][2];\n\tdouble s[2];\n\tint ans;\n\n\ts[0] = 100000;\n\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tans = n;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%lf,%lf\", &v[i][0], &v[i][1]);\n\t\t\tif(s[0] > v[i][0]){\n\t\t\t\ts[0] = v[i][0];\n\t\t\t\ts[1] = v[i][1];\n\t\t\t}\n\t\t}\n\n\t\tdouble t[2];\n\t\tt[0] = s[0];\n\t\tt[1] = s[1];\n\t\tdouble next[2];\n\t\tdouble bias = -M_PI/2.0;\n\t\tdouble min;\n\t\tdo{\n\t\t\tmin = 2*M_PI;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdouble theta = atan((t[1] - v[i][1]) / (t[0] - v[i][0]));\n\t\t\t\tif(t[0] > v[i][0]) theta += M_PI;\n\t\t\t\tif(bias <= theta && min > theta){\n\t\t\t\t\tmin = theta;\n\t\t\t\t\tnext[0] = v[i][0];\n\t\t\t\t\tnext[1] = v[i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans--;\n\t\t\tt[0] = next[0];\n\t\t\tt[1] = next[1];\n\t\t\tbias = min;\n\t\t}while(t[0] != s[0] || t[1] != s[1]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 計算幾何に関するコード\n * 2012/05/28 sasaki tasuku\n */\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// 頻繁に使うものには\n// * ほげほげ\n// と書いてあります. (ほげほげ は 任意の文字列)\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * \nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分の交差判定\n\tbool is_intersection(const Segment& s) {\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) &&\n\t\t\t   ( cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) < EPS );\n\t}\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tif( this->is_intersection( s ) ) { // 交差するとき\t\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) || this->contain(s.b) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}else if( s.contain( a ) || s.contain( b ) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\t\tdouble A = this->distance(s.a);\n\t\tdouble B = this->distance(s.b);\n\t\tdouble C = s.distance( (*this).a );\n\t\tdouble D = s.distance( (*this).b );\n\t\treturn min( min(A,B) , min(C,D) );\n\t}\n\t// 点 p を軸に 線分 を 角度 angle だけ回転移動 (角度はラジアン)\n\tSegment rot(P p, double angle) {\n\t\tP a_ = rot2( p , a , angle );\n\t\tP b_ = rot2( p , b , angle );\n\t\treturn Segment( a_ , b_ );\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n// Segment の順序を定義 (x座標の小さい端点で比較)\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の直交判定\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 点 p が直線上に乗っているか\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// 直線と点 p の距離\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 角度を返す [-π,π]\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\treturn atan2( p.Y , p.X );\n\t}\n\t// 双対変換\n\tP dual(const Line &l) {\n\t\tconst P p = l[0], q = l[1];\n\t\treturn P( imag(p - q) / real(p - q), cross(p, q) / real(q - p) );\n\t}\n\t// 点を線対称に移動させる\n\tP symmetry(P a) {\n\t\tdouble x,y;\n\t\tdouble x1 = (*this)[0].X;\n\t\tdouble x2 = (*this)[1].X;\n\t\tdouble y1 = (*this)[0].Y;\n\t\tdouble y2 = (*this)[1].Y;\n\t\tdouble xq = a.X;\n\t\tdouble yq = a.Y;\n\t\tif( x2 == x1 ) {\n\t\t\tx = -xq;\n\t\t\ty = yq;\n\t\t}else{\n\t\t\tdouble m = (y2 - y1) / (x2 - x1);\n\t\t\tdouble c = y2 - m * x2;\n\t\t\tx = (2 * m * yq - xq * (m * m - 1) - 2 * m * c) / (m * m + 1);\n\t\t    y = (2 * m * xq + yq * (m * m - 1) + 2 * c) / (m * m + 1);\n\t\t}\n\t\treturn P(x,y);\n\t}\n\t// 点 p を軸に 直線 を 角度 angle だけ回転移動 (角度はラジアン)\n\tLine rot(P p, double angle) {\n\t\tP a = rot2( p , (*this)[0] , angle );\n\t\tP b = rot2( p , (*this)[1] , angle );\n\t\treturn Line( a , b );\n\t}\n\t// デバッグ出力\n\tvoid print() {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\tdouble dx = p1.X - p2.X;\n\t\tdouble dy = p1.Y - p2.Y;\n\t\t::print( p1 );\n\t\t::print( p2 );\n\t\tp1.X += 100 * dx;\n\t\tp1.Y += 100 * dy;\n\t\tp2.X -= 100 * dx;\n\t\tp2.Y -= 100 * dy;\n\t\tSegment s( p1 , p2 );\n\t\ts.print();\n\t}\n};\n\n\n// 三角形の表現\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n    // 3 つの辺の長さ\n    double edgeA, edgeB, edgeC;\n    // 3 つの角の角度 (ラジアン)\n    double angleA,angleB,angleC;\n    \n    // コンストラクタで初期化\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n    // 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n\t// 三角形の重心を返す\n\tP gravity() {\n\t\treturn P( (a.X + b.X + c.X) / 3.0 , (a.Y + b.Y + c.Y) / 3.0 );\n\t}\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\tSegment AB(a,b), BC(b,c), CA(c,a);\n\t\treturn (AB.contain( p ) || BC.contain( p ) || CA.contain( p ) );\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\t// 点 p が三角形の辺上 or 頂点上 にあるときは誤差で正しい結果が返ってこないので注意!!!\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n\t// 点 p を軸に 三角形 を 角度 angle だけ回転移動 (角度はラジアン)\n\tTriangle rot(P p, double angle) {\n\t\tP a_ = rot2( p , a , angle );\n\t\tP b_ = rot2( p , b , angle );\n\t\tP c_ = rot2( p , c , angle );\n\t\treturn Triangle( a_ , b_ , c_ );\n\t}\n\t// デバッグ出力\n\tvoid print() {\n\t\tSegment AB(a,b);\n\t\tSegment BC(b,c);\n\t\tSegment CA(c,a);\n\t\tAB.print();\n\t\tBC.print();\n\t\tCA.print();\n\t}\n};\n\n\n// 凸多角形かどうか (三角形に分割してすべての三角形が反時計回りか調べる)\nbool is_convex(vector<P> g) {\n\tfor(int i=2 ; i < g.size() ; i++ ){\n\t\tif( ccw( g[0] , g[i-1] , g[i] ) != CCW ) return false;\n\t}\n\treturn true;\n}\n\n// 多角形の表現 (凸多角形と仮定する)\nstruct Polygon{\n\t// 頂点の集まり\n\tvector<P> g;\n\t// コンストラクタで初期化\n\tPolygon(vector<P> g_){ g = g_; }\n\tPolygon(){}\n\t// 点 p が凸多角形の内部にあるかどうか\n\tbool is_inside(P p) {\n\t\tfor(int i=2 ; i < g.size() ; i++ ) {\n\t\t\tTriangle t( g[0] , g[i-1] , g[i] );\n\t\t\tif( t.is_inside( p ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t// 点 p が凸多角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\tfor(int i=0 ; i < g.size() ; i++ ) {\n\t\t\tSegment s( g[i] , g[(i+1) % g.size()] );\n\t\t\tif( s.contain( p ) ) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t// 凸多角形の面積を返す\n\tdouble get_area() {\n\t\tdouble s = 0.0;\n\t\tfor(int i=2 ; i < g.size() ; i++ ) {\n\t\t\ts += cross( g[i-1] - g[0] , g[i] - g[0] );\n\t\t}\n\t\treturn s/2.0;\n\t}\n\t// 凸多角形の重心を返す\n\tP gravity() {\n\t\tP sg(0,0);\n\t\tdouble s = 0.0;\n\t\tfor(int i=2 ; i < g.size() ; i++ ) {\n\t\t\tTriangle t( g[0] , g[i-1] , g[i] );\n\t\t\ts += t.get_area();\n\t\t\tsg += t.get_area() * t.gravity();\n\t\t};\n\t\treturn sg / s;\n\t}\n\t// 凸多角形の直径を返す (最遠点対は引数のpair<P,P> pに代入)\n\tdouble convex_diameter(pair<P,P>& p) {\n    \tdouble result = 0.0;\n    \tfor(int i=0 ; i < g.size() ; i++ ){\n    \t\tfor(int j = i+1 ; j < g.size() ; j++ ){\n    \t\t\t if( result < dist( g[i] , g[j] ) ){\n    \t\t\t \tresult = dist( g[i] , g[j] );\n    \t\t\t \tp = pair<P,P>( g[i] , g[j] );\n    \t\t\t }\n    \t\t}\n    \t}\n    \treturn result;\n\t}\n\t// 凸多角形を 点 seg.a と 点 seg.b を通る直線で切断し、直線の左側の多角形を返す\n\tPolygon convex_cut(const Segment& s) {\n  \t\tvector<P> Q;\n  \t\tfor(int i = 0; i < g.size() ; i++ ) {\n    \t\tP A = g[i];\n    \t\tP B = g[(i+1) % g.size()];\n    \t\tif( ccw( s.a , s.b , A ) != CW ) {\n    \t\t\tQ.push_back( A );\n    \t\t}\n    \t\tif( ccw( s.a , s.b , A ) * ccw( s.a , s.b , B ) < 0 ) {\n    \t\t\tSegment AB( A , B );\n    \t\t\tP p;\n    \t\t\tAB.intersection( s , p );\n     \t\t\tQ.push_back( p );\n     \t\t}\n  \t\t}\n \t\treturn Polygon( Q );\n\t}\n\t// 直線 s の方向( s.a から s.b へのベクトル ) と 最も遠い点を返す\n\tdouble d(int k, const Segment& s) { return dot( g[k] , s.b - s.a ) ;}\n\tP convex_extreme(const Segment& s) {\n\t\tint a = 0;\n\t\tint b = g.size();\n\t\tint n = g.size();\n\t\tif( d(0,s) >= d(n-1,s) && d(0,s) >= d(1,s) )\n\t\t\treturn g[0];\n\t\twhile( a < b ) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif( d(c,s) >= d(c-1,s) && d(c,s) >= d(c+1,s) )\n\t\t\t\treturn g[c];\n\t\t\tif( d(a+1,s) > d(a,s) ){\n\t\t\t\tif( d(c+1,s) <= d(c,s) || d(a,s) > d(c,s) )\n\t\t\t\t\tb = c;\n\t\t\t\telse\n\t\t\t\t\ta = c;\n\t\t\t}else{\n\t      \t\tif( d(c+1,s) > d(c,s) || d(a,s) >= d(c,s) )\n\t      \t\t\ta = c;\n\t      \t\telse\n\t      \t\t\tb = c;\n\t      \t}\n\t\t}\n\t}\n\t// デバッグ用出力\n\tvoid print() {\n\t\tfor(int i=0 ; i < g.size() ; i++ ) {\n\t\t\tSegment s( g[i] , g[(i+1) % g.size()] );\n\t\t\ts.print();\n\t\t}\n\t}\n};\n\n// n 個の点の集まりから凸包を求める\nPolygon convex_full(vector<P> ps) {\n\tint n = ps.size();\n\tsort( ps.begin() , ps.end() );\n\t\n\t// 上部を求める\n    vector<P> ch_u( n );\n    int n_u = 0;\n    for(int i = n-1 ; i >= 0 ; i-- ) {\n        ch_u[n_u++] = ps[i];\n        while( n_u >= 3 && ccw( ch_u[n_u-3] , ch_u[n_u-2] , ch_u[n_u-1] ) != CCW ) {\n            ch_u[n_u-2] = ch_u[n_u-1];\n            n_u--;\n        }\n    }\n \n    vector<P> ch_l( n );\n    int n_l = 0;\n    for(int i = 0 ; i < n ; i++ ) {\n        ch_l[n_l++] = ps[i];\n        while( n_l >= 3 && ccw( ch_l[n_l-3] , ch_l[n_l-2] , ch_l[n_l-1]) != CCW ) {\n            ch_l[n_l-2] = ch_l[n_l-1];\n            n_l--;\n        }\n    }\n \n    Polygon ch;\n    for(int i=0 ; i<n_u-1 ; i++ ) ch.g.push_back(ch_u[i]);\n    for(int i=0 ; i<n_l-1 ; i++ ) ch.g.push_back(ch_l[i]);\n    return ch;\n}\n\nint main(){\n\tint n;\n\twhile( scanf(\"%d\", &n) ){\n\t\tif( n == 0 ) break;\n\t\tvector<P> v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tv.push_back( P(x,y) );\n\t\t}\n\t\tPolygon pol = convex_full( v );\n\t\tint ans = n - (int)pol.g.size();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<complex>\n#include<cmath>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(v) v.begin(),v.end()\nusing namespace std;\ntypedef complex<double> Point;\n\ndouble cross(Point a,Point b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tPoint dt[n],alt;\n\t\tvector<Point> p;\n\t\trep(i,n)scanf(\"%lf,%lf\",&dt[i].real(),&dt[i].imag());\n\t\tfor(int i=n-1;i>0;i--){\n\t\t\tif(dt[i-1].real()>dt[i].real()){\n\t\t\t\talt=dt[i];\n\t\t\t\tdt[i]=dt[i-1];\n\t\t\t\tdt[i-1]=alt;\n\t\t\t}\n\t\t}\n\t\tp.pb(dt[0]);\n\t\twhile(1){\n\t\t\talt=p[p.size()-1];\n\t\t\tbool yon=true;\n\t\t\trep(i,n){\n\t\t\t\tif(dt[i]==alt)continue;\n\t\t\t\tbool check=true;\n\t\t\t\trep(j,n){\n\t\t\t\t\tPoint a=dt[i]-alt,b=dt[j]-dt[i];\n\t\t\t\t\tif(i==j || dt[j]==alt)continue;\n\t\t\t\t\tif(cross(dt[i]-alt,dt[j]-dt[i])>0){\n\t\t\t\t\t\tcheck=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check){\n\t\t\t\t\tp.pb(dt[i]);\n\t\t\t\t\tyon=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(yon)break;\n\t\t\tif(p[p.size()-1]==p[0]){\n\t\t\t\tp.erase(p.end()-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<n-p.size()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS )\n\n// Point, Vector class\nclass Point {\npublic:\n  double x, y;\n\n  Point( double x = 0, double y = 0 ): x(x), y(y){}\n\n  Point operator + ( Point p ){ return Point( x + p.x, y + p.y ); }\n  Point operator - ( Point p ){ return Point( x - p.x, y - p.y ); }\n  Point operator * ( double k ){ return Point( x * k, y * k ); }\n\n  double abs() { return sqrt( norm() ); }\n  double norm() { return x * x + y * y; }\n\n  bool operator < ( const Point& p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == ( const Point& p ) const {\n    return fabs( x - p.x ) < EPS && fabs( y - p.y ) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// Segment\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\n\ndouble norm( Point p ) {\n  return p.x * p.x + p.y * p.y;\n}\n\ndouble abs( Point p ) {\n  return sqrt( norm( p ) );\n}\n\ndouble dot( Vector a, Vector b ) {\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble cross( Vector a, Vector b ) {\n  return a.x * b.y - a.y * b.x;\n}\n\nbool isOrthogonal( Vector a, Vector b ) {\n  return equals( dot(a, b), 0.0 );\n}\n\nbool isOrthogonal( Point a1, Point a2, Point b1, Point b2 ) {\n  return isOrthogonal( a1 - a2, b1 - b2 );\n}\n\nbool isOrthogonal( Segment s1, Segment s2 ) {\n  return equals( dot( s1.p2 - s1.p1, s2.p2 - s2.p1 ), 0.0 );\n}\n\nbool isParallel( Vector a, Vector b ) {\n  return equals( cross( a, b ), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2 ) {\n  return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ) {\n  return equals( cross( s1.p2-s1.p1, s2.p2 - s2.p1 ), 0.0 );\n}\n\nPoint project( Segment s, Point p ) {\n  Vector base = s.p2 - s.p1;\n  double t = dot( p - s.p1, base ) / base.norm();\n  return s.p1 + base * t;\n}\n\nPoint reflect( Segment s, Point p ) {\n  return p + ( project( s, p ) - p ) * 2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if ( cross( a, b ) > EPS ) return COUNTER_CLOCKWISE;\n  if ( cross( a, b ) < -EPS ) return CLOCKWISE;\n  if ( dot( a, b ) < -EPS ) return ONLINE_BACK;\n  if ( a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect( Point p1, Point p2, Point p3, Point p4 ) {\n  return ( ccw( p1, p2, p3 ) * ccw( p1, p2, p4 ) <= 0 &&\n\t   ccw( p3, p4, p1 ) * ccw( p3, p4, p2 ) <= 0 );\n}\n\nbool isIntersect( Segment s1, Segment s2 ) {\n  return isIntersect( s1.p1, s1.p2, s2.p1, s2.p2 );\n}\n\nPoint getCrossPoint( Segment s1, Segment s2 ) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs( cross( base, s1.p1 - s2.p1 ) );\n  double d2 = abs( cross( base, s1.p2 - s2.p1 ) );\n  double t = d1 / ( d1 + d2 );\n  return s1.p1 + ( s1.p2 - s1.p1 ) * t;\n}\n\ndouble getDistance( Point a, Point b ) {\n  Point c = a - b;\n  return c.abs();\n}\n\ndouble getDistanceLP( Line s, Point p ) {\n  return abs( cross( s.p2 - s.p1, p - s.p1 ) / abs( s.p2 - s.p1 ) );\n}\n\ndouble getDistanceSP( Segment s, Point p ) {\n  Point c1 = p - s.p1;\n  Point c2 = p - s.p2;\n  if ( dot( s.p2 - s.p1, p - s.p1 ) < 0.0 ) return c1.abs();\n  if ( dot( s.p1 - s.p2, p - s.p2 ) < 0.0 ) return c2.abs();\n  return getDistanceLP( s, p );\n}\n\ndouble getDistance( Segment s1, Segment s2 ) {\n  if ( isIntersect( s1, s2 ) ) return 0.0;\n  return min( min( getDistanceSP( s1, s2.p1 ), getDistanceSP( s1, s2.p2 ) ),\n\t      min( getDistanceSP( s2, s1.p1 ), getDistanceSP( s2, s1.p2 ) ));\n}\n\nint main() {\n    string line;\n    while ( getline( cin, line ) ) {\n        istringstream isn( line );\n        int n;\n        isn >> n;\n        if ( n == 0 ) break;\n        Point P[101];\n        double L[101];\n        for ( int i = 0; i < n; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            istringstream is( line );\n            double x, y;\n            is >> x >> y;\n            P[i].x = x + 1000.0;\n            P[i].y = y + 1000.0;\n            L[i] = P[i].abs();\n        }\n        for ( int i = 0; i+1 < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( L[i] > L[j] ) {\n                    swap( P[i], P[j] );\n                    swap( L[i], L[j] );\n                }\n            }\n        }\n\n        int s = 0, t = n-1;\n        int answer = 0;\n        bool used[101];\n        for ( int i = 0; i < n; i++ ) used[i] = false;\n        used[s] = used[t] = true;\n\n        for ( int i = 0; i < n; i++ ) {\n            if ( used[i] ) continue;\n            for ( int j = 0; j < n; j++ ) {\n                if ( used[j] ) continue;\n                Vector a( P[s] - P[j] );\n                Vector b( P[i] - P[j] );\n                Vector c( P[t] - P[j] );\n                if ( ( cross( a, b ) > 0 && cross( b, c ) > 0 && cross( c, a ) > 0 ) ||\n                     ( cross( a, b ) < 0 && cross( b, c ) < 0 && cross( c, a ) < 0 ) ) {\n                    answer++;\n                    used[j] = true;\n                }\n            }\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define PI (acos(-1.0))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define POSARG(a) (arg(a) > 0.0? arg(a) : 2.0*PI + arg(a))\n\nint n;\n\nvector<P>::iterator convex_hull(vector<P>& vc)\n{\n\tint undermost = 0;\n\t\n\tfor(int i = 1; i < (int)vc.size(); i++)\n\t{\n\t\tif( vc[i].imag() < vc[undermost].imag() \n\t\t\t||( EQ(vc[undermost].imag(), vc[i].imag()) && vc[undermost].real() < vc[i].real() ) )\n\t\t{\n\t\t\tundermost = i;\n\t\t}\n\t}\n\t\n\tswap(vc[0], vc[undermost]);\n\n\tdouble nowarg = 0.0;\n\tint j;\n\t\n\tfor( j = 0; j < (int)vc.size()-1; j++)\n\t{\n\t\tdouble minarg = 2.0*PI;\n\t\tdouble maxdst = 0.0;\n\t\tint candidx = 0;\n\t\t\n\t\tfor(int i = j+1; i < (int)vc.size(); i++)\n\t\t{\n\t\t\tdouble newarg = POSARG(vc[i] - vc[j]);\n\t\t\tdouble newdst = abs(vc[i] - vc[j]);\n\t\t\t\n\t\t\tif( newarg > nowarg)\n\t\t\t\tif( newarg < minarg || ( EQ(newarg, minarg) && newdst > maxdst) )\n\t\t\t\t{\n\t\t\t\t\tminarg = newarg;\n\t\t\t\t\tmaxdst = newdst;\n\t\t\t\t\tcandidx = i;\n\t\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif(candidx == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswap(vc[j+1], vc[candidx]);\n\t\t\tnowarg = minarg;\n\t\t}\n\t}\n\t\n\treturn vc.begin()+j+1;\n}\n\nint solve(vector<P> vc)\n{\n\tvector<P>::iterator r = convex_hull(vc);\n\treturn vc.end() - r;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tvector<P> vc;\n\t\tvc.clear();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tchar c;\n\t\t\tdouble a, b;\n\t\t\tcin >> a;\n\t\t\tcin >> c;\n\t\t\tcin >> b;\n\t\t\tvc.push_back(P(a, b));\n\t\t}\n\t\t\n\t\tcout << solve(vc) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nconstexpr double PI = 3.14159265358979323846264338327950288;\nconstexpr double EPS = 1e-10;\n\n\n//COUNTER CLOCKWISE\nconstexpr int CCW_COUNTER_CLOCKWISE = 1;\nconstexpr int CCW_CLOCKWISE = -1;\nconstexpr int CCW_ONLINE_BACK = 2;\nconstexpr int CCW_ONLINE_FRONT = -2;\nconstexpr int CCW_ON_SEGMENT = 0;\n\n\n//CIRCLE INTERSECTION\nconstexpr int ICC_SEPARATE = 4;\nconstexpr int ICC_CIRCUMSCRIBE = 3;\nconstexpr int ICC_INTERSECT = 2;\nconstexpr int ICC_INSCRIBE = 1;\nconstexpr int ICC_CONTAIN = 0;\n\n\ninline bool eq(const double a, const double b){ return fabs(a-b) < EPS; }\n\n\n//Point\nstruct Point {\n    double x, y;\n    Point() = default;\n    Point(double x, double y) : x(x), y(y){}\n    friend ostream& operator<<(ostream& os, const Point& p){ return os << '(' << p.x << \", \" << p.y << ')'; }\n    friend istream& operator>>(istream& is, Point& p){ return is >> p.x >> p.y; }\n};\nusing Vector = Point;\ninline Vector operator+(const Vector& p, const Vector& q){ return Vector(p.x+q.x, p.y+q.y); }\ninline Vector operator-(const Vector& p, const Vector& q){ return Vector(p.x-q.x, p.y-q.y); }\ninline Vector operator*(const Vector& p, double a){ return Vector(p.x*a, p.y*a); }\ninline Vector operator*(double a, const Vector& p){ return Vector(a*p.x, a*p.y); }\ninline Vector operator/(const Vector& p, double a){ return Vector(p.x/a, p.y/a); }\ninline Vector conj(const Vector& p){ return Vector(p.x, -p.y); }\ninline Vector rot(const Vector& p, double ang){ return Vector(cos(ang)*p.x-sin(ang)*p.y, sin(ang)*p.x+cos(ang)*p.y); }\ninline Vector rot90(const Vector& p){ return Vector(-p.y, p.x); }\ninline double dot(const Vector& p, const Vector& q){ return p.x*q.x+p.y*q.y; }\ninline double det(const Vector& p, const Vector& q){ return p.x*q.y-p.y*q.x; }\ninline double norm(const Vector& p){ return p.x*p.x+p.y*p.y; }\ninline double abs(const Vector& p){ return sqrtl(norm(p)); }\ninline double amp(const Vector& p){ double res = atan2(p.y, p.x); if(res < 0) res+=PI*2; return res; }\ninline bool eq(const Vector& p, const Vector& q){ return abs(p-q) < EPS; }\ninline bool operator<(const Vector& p, const Vector& q){ return (!eq(p.x, q.x) ? p.x < q.x : p.y < q.y); }\ninline bool operator>(const Vector &p, const Vector &q){ return (!eq(p.x, q.x) ? p.x > q.x : p.y > q.y); }\n\n\nusing Polygon = vector<Point>;\nistream& operator>>(istream& is, Polygon& p){ for(int i = 0;i < (int)p.size();++i) is >> p[i]; return is; }\n\n\n// Segment\nstruct Segment{\n    Point p1, p2;\n    Segment() = default;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2){}\n    Segment(double x1, double y1, double x2, double y2) : p1(x1, y1), p2(x2, y2){}\n    const Point& operator[](bool i) const { return i ? p2 : p1; }\n    Point& operator[](bool i){ return i ? p2 : p1; }\n    friend ostream& operator<<(ostream& os, const Segment& l){ return os << '{' << l[0] << \", \" << l[1] << '}'; }\n    friend istream& operator>>(istream& is, Segment& l){ return is >> l.p1 >> l.p2; }\n};\nusing Line = Segment;\n\n\n//Circle\nstruct Circle {\n    Point c;\n    double r;\n    Circle() = default;\n    Circle(Point c, double r) : c(c), r(r){}\n    friend istream& operator>>(istream& is, Circle& c){ return is >> c.c >> c.r; }\n};\n\n\nbool isOrthogonal(const Vector& a, const Vector& b){\n    return eq(dot(a, b), 0.0);\n}\n\n\nbool isOrthogonal(const Segment& s1, const Segment& s2){\n    return eq(dot(s1[1]-s1[0], s2[1]-s2[0]), 0.0);\n}\n\n\nbool isParallel(const Vector& a, const Vector& b){\n    return eq(det(a, b), 0.0);\n}\n\n\nbool isParalell(const Segment& s1, const Segment& s2){\n    return eq(det(s1[1]-s1[0], s2[1]-s2[0]), 0.0);\n}\n\n\nPoint project(const Line& l, const Point& p){\n    return (l[1]-l[0])*dot(l[1]-l[0], p-l[0])/norm(l[1]-l[0]);\n}\n\n\nPoint reflect(const Line& l, const Point& p){\n    return p+(project(l, p)-p)*2;\n}\n\n\nVector polar(double r, double ang){\n    return Point(r*cos(ang), r*sin(ang));\n}\n\n\nint ccw(const Point& a, const Point& b, const Point& c);\nbool intersectSS(const Segment& s1, const Segment& s2);\nbool intersectPS(const Polygon& p, const Segment& s);\nint intersectCC(const Circle& c1, const Circle& c2);\nbool intersectSC(const Segment& s, const Circle& c);\ndouble getDistanceLP(const Line& l, const Point& p);\ndouble getDistanceSP(const Segment& s, const Point& p);\nPoint getCrossPointSS(const Segment& s1, const Segment& s2);\nPoint getCrossPointLL(const Line& l1, const Line& l2);\nPolygon getCrossPointCL(const Circle& c, const Line& l);\nPolygon getCrossPointCC(const Circle& c1, const Circle& c2);\nPolygon convexHull(Polygon ps);\nCircle circumcircle(const Point& a, const Point& b, const Point& c);\n\n\nint ccw(const Point& a, const Point& b, const Point& c){\n    if(det(b-a, c-a) > EPS) return CCW_COUNTER_CLOCKWISE;\n    if(det(b-a, c-a) < -EPS) return CCW_CLOCKWISE;\n    if(dot(b-a, c-a) < -EPS) return CCW_ONLINE_BACK;\n    if(norm(b-a) < norm(c-a)) return CCW_ONLINE_FRONT;\n    return CCW_ON_SEGMENT;\n}\n\n\nbool intersectSS(const Segment& s1, const Segment& s2){\n    return (ccw(s1[0], s1[1], s2[0])*ccw(s1[0], s1[1], s2[1]) <= 0 and ccw(s2[0], s2[1], s1[0])*ccw(s2[0], s2[1], s1[1]) <= 0);\n}\n\n\ndouble getDistanceLP(const Line& l, const Point& p){\n    return abs(det(l[1]-l[0], p-l[0])/abs(l[1]-l[0]));\n}\n\n\ndouble getDistanceSP(const Segment& s, const Point& p){\n    if(dot(s[1]-s[0], p-s[0]) < 0.0) return abs(p-s[0]);\n    if(dot(s[0]-s[1], p-s[1]) < 0.0) return abs(p-s[1]);\n    return getDistanceLP(s, p);\n}\n\n\nPoint getCrossPointSS(const Segment& s1, const Segment& s2){\n    for(int i = 0;i < 2;++i){\n        if(getDistanceSP(s1, s2[i]) < EPS) return s1[i];\n        if(getDistanceSP(s2, s1[i]) < EPS) return s2[i];\n    }\n    double d1 = abs(det(s2[1]-s2[0], s1[0]-s2[0]));\n    double d2 = abs(det(s2[1]-s2[0], s1[1]-s2[0]));\n    return s1[0]+(s1[1]-s1[0])*d1/(d1+d2);\n}\n\n\nPoint getCrossPointLL(const Line& l1, const Line& l2){\n    double a = det(l1[1]-l1[0], l2[1]-l2[0]);\n    double b = det(l1[1]-l1[0], l1[1]-l2[0]);\n    if(abs(a) < EPS and abs(b) < EPS) return l2[0];\n    return l2[0]+(l2[1]-l2[0])*b/a;\n}\n\n\nPolygon convexHull(Polygon ps){\n    int n = ps.size();\n    sort(begin(ps), end(ps));\n    int k = 0;\n    Polygon qs(2*n);\n    for(int i = 0;i < n;++i){\n        while(k > 1 and det(qs[k-1]-qs[k-2], ps[i]-qs[k-2]) < 0) --k;\n        qs[k++] = ps[i];\n    }\n    for(int i = n-2, t = k;i >= 0;--i){\n        while(k > t and det(qs[k-1]-qs[k-2], ps[i]-qs[k-2]) < 0) --k;\n        qs[k++] = ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\n\nbool compArg(const Point& a, const Point& b){\n    auto getA = [&](Point p){\n        if(p.x >= 0 and p.y >= 0) return 0;\n        if(p.y >= 0) return 1;\n        if(p.x <= 0) return -2;\n        return -1;\n    };\n    if(getA(a) != getA(b)) return getA(a) < getA(b);\n    if(a.x == 0 and a.y == 0) return !(b.x == 0 and b.y == 0);\n    if(b.x == 0 and b.y == 0) return false;\n    return det(a, b) > 0;\n}\n\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        Polygon ps(n);\n        string s;\n        stringstream ss;\n        for(int i = 0;i < n;++i){\n            cin >> s;\n            replace(begin(s), end(s), ',', ' ');\n            ss << s;\n            ss >> ps[i];\n            ss.clear();\n        }\n        cout << n-convexHull(ps).size() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void){\n\tint n;\n\tdouble v[101][2];\n\tdouble s[2];\n\tint ans;\n\n\twhile(1){\n\t\ts[0] = 100000;\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tans = n;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%lf,%lf\", &v[i][0], &v[i][1]);\n\t\t\tif(s[0] > v[i][0]){\n\t\t\t\ts[0] = v[i][0];\n\t\t\t\ts[1] = v[i][1];\n\t\t\t}else if(s[0] == v[i][0] && s[1] < v[i][1]){\n\t\t\t\ts[1] = v[i][1];\n\t\t\t}\n\t\t}\n\n\t\tdouble t[2];\n\t\tt[0] = s[0];\n\t\tt[1] = s[1];\n\t\tdouble next[2];\n\t\tdouble bias = -M_PI/2.0;\n\t\tdouble min;\n\t\tdouble theta;\n\t\tdo{\n\t\t\tmin = 2*M_PI;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(v[i][0] == -10000 || v[i][1] == -10000) continue;\n\t\t\t\tif(v[i][0] == t[0] && v[i][1] == t[1]) continue;\n\t\t\t\tif(t[0] == v[i][0]){\n\t\t\t\t\tif(t[1] < v[i][1]) theta = M_PI/2;\n\t\t\t\t\telse if(t[1] > v[i][1]) theta = -M_PI/2;\n\t\t\t\t}else{\n\t\t\t\t\ttheta = atan((t[1] - v[i][1]) / (t[0] - v[i][0]));\n\t\t\t\t}\n\t\t\t\tif(t[0] > v[i][0]) theta += M_PI;\n\t\t\t\tif(bias <= theta && min > theta){\n\t\t\t\t\tmin = theta;\n\t\t\t\t\tnext[0] = v[i][0];\n\t\t\t\t\tnext[1] = v[i][1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans--;\n\t\t\tt[0] = next[0];\n\t\t\tt[1] = next[1];\n\t\t\tbias = min;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(v[i][0] == t[0] && v[i][1] == t[1]){\n\t\t\t\t\tv[i][0] = -10000;\n\t\t\t\t\tv[i][1] = -10000;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(t[0] != s[0] || t[1] != s[1]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n};\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\nint main() {\n\tvector<Point>vec; Point p; char c;\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tvec.clear();\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p.px >> c >> p.py;\n\t\t\tvec.push_back(p);\n\t\t}\n\t\tcout << n - convex_hull(vec).size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vP;\n\ndouble dot(P a, P b) {\n\treturn (a.real()*b.real() + a.imag()*b.imag());\n}\n\ndouble cross(P a, P b) {\n\treturn (a.real()*b.imag() - a.imag()*b.real());\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0) return +1;\n\tif(cross(b, c) < 0) return -1;\n\tif(dot(b, c) < 0)   return +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n}\n\nvP convex_hull(vP ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ALL(ps));\n\tvP ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++]) {\n\t\twhile(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) {\n\t\t\t--k;\n\t\t}\n\t}\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) {\n\t\twhile(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) {\n\t\t\t--k;\n\t\t}\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvP points;\n\t\tdouble x, y;\n\t\tchar c;\n\t\tREP(_, n) {\n\t\t\tcin >> x >> c >> y;\n\t\t\tpoints.push_back(P(x, y));\n\t\t}\n\n\t\tcout << n-convex_hull(points).size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<iomanip>\n#include<bitset>\n#include<utility>\n#include<list>\n#include<map>\n#include<set>\n#include<cstring>\n#include<sstream>\n#include<cctype>\nusing namespace std;\nconst double EPS=1e-8;\nconst double INF=1e9;\ntypedef complex<double>P;\nnamespace std{\n    bool operator<(const P& a,const P& b){\n        return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n    }\n}\n#define EQ(a,b) (fabs((a)-(b))<EPS)\n#define EQV(a,b) (EQ(real(a),real(b))&&EQ(imag(a),imag(b)))\ndouble cross(const P &a,const P &b){\n    return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n    return real(conj(a)*b);\n}\n\nstruct L:public vector<P>{\n    L(const P &a,const P &b){\n        push_back(a);push_back(b);\n    }\n    L(){}\n};\n\ntypedef vector<P>G;\n\nstruct C{\n    P p;double r;\n    C(const P &p_,double r_):p(p_),r(r_){}\n    C(){}\n};\n\nint ccw(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>0)return 1;///counter clockwise\n    if(cross(b,c)<0)return -1;///clockwise\n    if(dot(b,c)<0)return 2;///c--a--b on line\n    if(norm(b)<norm(c))return -2;///a--b--c on line\n    return 0;\n}\nbool orthogonal(P &p,P &q){\n    return EQ(dot(p,q),0.0);\n}\nbool intersectLL(const L &l,const L &m){\n    return abs(cross(l[1]-l[0],m[1]-m[0]))>EPS||///non-parallel\n        abs(cross(l[1]-l[0],m[0]-l[0]))<EPS;///same line\n}\nbool intersectLS(const L &l,const L &s){\n    return cross(l[1]-l[0],s[0]-l[0])*///s[0] is left of l\n        cross(l[1]-l[0],s[1]-l[0])<EPS;///s[1] is right of l\n}\nbool intersectLP(const L &l,const P &p){\n    return abs(cross(l[1]-p,l[0]-p))<EPS;\n}\nbool intersectSS(const L &s,const L &t){\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\nbool intersectSP(const L &s,const P &p){\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<EPS;\n    ///triangle inequality\n}\nP projection(const L &l,const P &p){\n    double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n    return l[0]+t*(l[0]-l[1]);\n}\nP reflection(const L &l,const P &p){\n    return p+(projection(l,p)-p)*2.0;\n}\ndouble distanceLP(const L &l,const P &p){\n    return abs(p-projection(l,p));\n}\ndouble distanceLL(const L &l,const L &m){\n    return intersectLL(l,m)?0:distanceLP(l,m[1]);\n}\ndouble distanceLS(const L &l,const L &s){\n    if(intersectLS(l,s))return 0;\n    return min(distanceLP(l,s[0]),distanceLP(l,s[1]));\n}\ndouble distanceSP(const L &s,const P &p){\n    const P r=projection(s,p);\n    if(intersectSP(s,r))return abs(r-p);\n    return min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L &s,const L &t){\n    if(intersectSS(s,t))return 0;\n    return min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n            min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\nP crossPoint(const L &l,const L &m){\n    double A=cross(l[1]-l[0],m[1]-m[0]);\n    double B=cross(l[1]-l[0],l[1]-m[0]);\n    if(abs(A)<EPS&&abs(B)<EPS)return m[0];///same line\n    ///if(abs(A)<EPS)assert(false);\n    return m[0]+B/A*(m[1]-m[0]);\n\n}\n\nP extreme(const G &g,const L &l){\n    int k=0;\n    for(int i=1;i<g.size();i++){\n        if(dot(g[i],l[1]-l[0])>dot(g[k],l[1]-l[0]))k=i;\n    }\n    return g[k];\n}\n\nG andrewScan(G s){\n    G u,l;\n    if(s.size()<3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n\n    for(int i=2;i<s.size();i++){\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=-1;n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for(int i=s.size()-3;i>=0;i--){\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=-1;n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n    return l;\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        G g;\n        for(int i=0;i<n;i++){\n            double x,y;\n            scanf(\"%lf,%lf\",&x,&y);\n            g.push_back(P(x,y));\n        }\n        g=andrewScan(g);\n        printf(\"%d\\n\",n-g.size());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <sstream>\n#include <istream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define vci vector<int>\n#define vcs vector<string>\n#define pb push_back\n#define sz size()\n#define mapii map<int, int>\n#define mapci map<char, int>\n#define mapsi map<string, int>\n#define all(x) x.begin(), x.end()\n#define minit(a, i) memset(a, i, sizeof(a));\n\n#define for_(i, a, b) for (int i=(int)a; i<(int)b; i++)\n#define for_d(i, a, b) for (int i=(int)a-1; i>=b; i--)\n#define for_r(i, a, b, c) for (int i=(int)a; i<(int)b; i += c)\n#define for_dr(i, a, b, c) for (int i=(int)a-1; i>=b; i -= c)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef long long ll;\ntypedef double D;\n\nconst int iINF = 2147483647;\nconst ll lINF = 9223372036854775807;\n\ntemplate <class T> inline void dbg(T t) { cout << t << endl; }\n\n\n\n// define eps\ndouble EPS = 1e-10;\n\nstruct Point2D { \n\tdouble x, y;\n\tPoint2D (double a=0, double b=0) : x(a), y(b) {}\n};\ntypedef Point2D Vector2D;\n\n// Point2D's and Vector2D's operator\nPoint2D operator + (Point2D a, Point2D b) { return Point2D(a.x + b.x, a.y + b.y); }\nPoint2D operator - (Point2D a, Point2D b) { return Point2D(a.x - b.x, a.y - b.y); }\nPoint2D operator * (Point2D a, double d) { return Point2D(a.x * d, a.y * d); }\nPoint2D operator / (Point2D a, double d) { return Point2D(a.x / d, a.y / d); }\n\nbool operator < (const Point2D& a, const Point2D& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool operator > (const Point2D& a, const Point2D& b) { return b.x != a.x ? b.x < a.x : b.y < a.y; }\nbool operator == (const Point2D& a, const Point2D& b) { return fabs(a.x-b.x)<EPS && fabs(a.y-b.y)<EPS; }\n\ndouble norm(Point2D a) { return a.x*a.x + a.y*a.y; }\ndouble dot2D(const Vector2D& a, const Vector2D& b) { return a.x * b.x + a.y * b.y; }\ndouble cross2D(const Vector2D& a, const Vector2D& b) { return a.x*b.y - a.y*b.x; }\n\n// 点の進行方向\ta -> b -> c\nint ccw(Point2D a, Point2D b, Point2D c) {\n\tb = b - a; c = c - a;\n\tif (cross2D(b, c) > 0) return +1;\t// counter clockwise\n\tif (cross2D(b, c) < 0) return -1;\t// clockwise\n\tif (dot2D(b, c) < 0) return +2;\t\t// c--a--b on line\n\tif (norm(b) < norm(c)) return -2;\t// a--b--c on line\n\treturn 0;\t// \n}\n\nvector<Point2D> convexHull(vector<Point2D> ps) {\n\tint n = (int)ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<Point2D> ch(2*n);\t\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\t// upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\tch.resize(k-1);\n\treturn ch;\n}\n\n\nint main() {\n\tint n;\n\t\n\twhile (cin>>n) {\n\t\tvector<Point2D> ps(n);\n\t\n\t\tfor_(i, 0, n) {\n\t\t\tD x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tps[i].x = x; ps[i].y = y;\n\t\t}\n\t\n\t\tvector<Point2D> ch = convexHull(ps);\n\t\tint k = (int)ch.sz;\n\t\n\t\tcout << n - k << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define SAFE_DELETE( x ) { if ( x ){ delete x; x = NULL; } }\n\nclass Vector2{\npublic:\n\tVector2() : x( 0 ), y( 0 ), round( false ), check( false ), prev( NULL ), next( NULL ){}\n\tVector2( double aX, double aY ) : round( false ), check( false ), prev( NULL ), next( NULL ){\n\t\tx = aX;\n\t\ty = aY;\n\t}\n\tVector2( Vector2 a, Vector2 b ) : round( false ), check( false ), prev( NULL ), next( NULL ){\n\t\tx = b.x - a.x;\n\t\ty = b.y - a.y;\n\t}\n\n\tVector2 normal( Vector2& a ){\n\t\tVector2 ret;\n\t\tret.x = a.y - y;\n\t\tret.y = x - a.x;\n\t\treturn ret;\n\t}\n\tdouble dot( Vector2& a ){\n\t\treturn x * a.x + y * a.y;\n\t}\n\tdouble cross( Vector2& a ){\n\t\treturn x * a.y - y * a.x;\n\t}\n\n\tvoid operator=( Vector2& a ){\n\t\tx = a.x;\n\t\ty = a.y;\n\t}\n\n\tbool round, check;\n\tdouble x, y;\n\tVector2 *prev, *next;\n};\n\nclass VecList{\npublic:\n\tVecList() : mSize( 0 ), head( NULL ), tail( NULL ){\n\t\thead = new Vector2;\n\t\ttail = new Vector2;\n\t\thead->next = tail;\n\t\ttail->prev = head;\n\t}\n\t~VecList(){\n\t\tinit();\n\t\tSAFE_DELETE( tail );\n\t\tSAFE_DELETE( head );\n\t}\n\n\tvoid init(){\n\t\tfor ( int i = mSize; i > 0; --i ){\n\t\t\tVector2* a = tail->prev;\n\t\t\ta->prev->next = a->next;\n\t\t\ta->next->prev = a->prev;\n\t\t\tSAFE_DELETE( a );\n\t\t}\n\t\tmSize = 0;\n\t}\n\tvoid pushBack( Vector2 v ){\n\t\tVector2* a = new Vector2( v.x, v.y );\n\t\ta->prev = tail->prev;\n\t\ta->next = tail;\n\t\ta->prev->next = a;\n\t\ta->next->prev = a;\n\t\t++mSize;\n\t}\n\tint cntRound(){\n\t\tint cnt = 0;\n\t\tdouble top, right, bottom, left;\n\t\tVector2 *it, *topR, *topL, *rightU, *rightD, *bottomR, *bottomL, *leftU, *leftD;\n\t\ttop = bottom = head->next->y;\n\t\tright = left = head->next->x;\n\t\ttopR = topL = rightU = rightD = bottomR = bottomL = leftU = leftD = NULL;\n\t\tit = head;\n\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\tit = it->next;\n\t\t\tif ( it->y > top ) top = it->y;\n\t\t\tif ( it->y < bottom ) bottom = it->y;\n\t\t\tif ( it->x > right ) right = it->x;\n\t\t\tif ( it->x < left ) left = it->x;\n\t\t}\n\t\tit = head;\n\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\tit = it->next;\n\t\t\tif ( it->x == right ){\n\t\t\t\tif( !rightU ){\n\t\t\t\t\trightU = rightD = it;\n\t\t\t\t\trightU->round = true;\n\t\t\t\t}else{\n\t\t\t\t\trightD = it;\n\t\t\t\t\trightD->round = true;\n\t\t\t\t\tif ( rightU->y < rightD->y ) swap( rightU, rightD );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( it->x == left ){\n\t\t\t\tif( !leftU ){\n\t\t\t\t\tleftU = leftD = it;\n\t\t\t\t\tleftU->round = true;\n\t\t\t\t}else{\n\t\t\t\t\tleftD = it;\n\t\t\t\t\tleftD->round = true;\n\t\t\t\t\tif ( leftU->y < leftD->y ) swap( leftU, leftD );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( it->y == top ){\n\t\t\t\tif( !topR ){\n\t\t\t\t\ttopR = topL = it;\n\t\t\t\t\ttopR->round = true;\n\t\t\t\t}else{\n\t\t\t\t\ttopL = it;\n\t\t\t\t\ttopL->round = true;\n\t\t\t\t\tif ( topR->y < topL->y ) swap( topR, topL );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( it->y == bottom ){\n\t\t\t\tif( !bottomR ){\n\t\t\t\t\tbottomR = bottomL = it;\n\t\t\t\t\tbottomR->round = true;\n\t\t\t\t}else{\n\t\t\t\t\tbottomL = it;\n\t\t\t\t\tbottomL->round = true;\n\t\t\t\t\tif ( bottomR->y < bottomL->y ) swap( bottomR, bottomL );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( !( topL == leftU ) ) checkRound( topL, leftU );\n\t\tif ( !( leftD == bottomL ) ) checkRound( leftD, bottomL );\n\t\tif ( !( bottomR == rightD ) ) checkRound( bottomR, rightD );\n\t\tif ( !( rightU == topR ) ) checkRound( rightU, topR );\n\n\t\tit = head;\n\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\tit = it->next;\n\t\t\tif ( it->round ){\n\t\t\t\t++cnt;\n\t\t\t\tcout << \"p\" << i+1 << \" is true.\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"p\" << i+1 << \" is false.\" << endl;\n\t\t\t}\n\t\t}\n\n\t\treturn mSize - cnt;\n\t}\n\nprivate:\n\tvoid checkRound( Vector2* a, Vector2* b ){\n\t\tbool rep = false;\n\t\tdouble right = a->x, left = b->x, top = a->y, bottom = b->y;\n\t\tif ( right < left ) swap( right, left );\n\t\tif ( top < bottom ) swap( top, bottom );\n\t\tVector2* it = head;\n\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\tit = it->next;\n\t\t\tif( !it->round && it->x > left && it->x < right && it->y > bottom && it->y < top ){\n\t\t\t\tit->check = true;\n\t\t\t\trep = true;\n\t\t\t}\n\t\t}\n\t\tif ( rep ){\n\t\t\trep = false;\n\t\t\tVector2 ab( *a, *b );\n\t\t\tVector2 *p = a, *pp = NULL;\n\t\t\tit = head;\n\t\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\t\tit = it->next;\n\t\t\t\tif ( it->check ){\n\t\t\t\t\tVector2 ac( *p, *it );\n\t\t\t\t\tif ( ab.cross( ac ) < 0 ){\n\t\t\t\t\t\tp = it;\n\t\t\t\t\t\trep = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( rep ){\n\t\t\t\tp->round = true;\n\t\t\t\tp->check = false;\n\t\t\t\tit = head;\n\t\t\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\t\t\tit = it->next;\n\t\t\t\t\tif ( it->check ){\n\t\t\t\t\t\tit->check = false;\n\t\t\t\t\t\tVector2 ac( *p, *it );\n\t\t\t\t\t\tif ( !ab.cross( ac ) ){\n\t\t\t\t\t\t\tpp = it;\n\t\t\t\t\t\t\tpp->round = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( pp ){\n\t\t\t\t\tif ( p->x - a->x > pp->x - a->x ) swap( p, pp );\n\t\t\t\t\tcheckRound( a, p );\n\t\t\t\t\tcheckRound( pp, b );\n\t\t\t\t}else{\n\t\t\t\t\tcheckRound( a, p );\n\t\t\t\t\tcheckRound( p, b );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint mSize;\n\tVector2 *head, *tail;\n};\n\nint main(){\n\tint n;\n\tchar c;\n\tVecList list;\n\n\twhile ( cin >> n && n ){\n\t\tlist.init();\n\t\tVector2 a;\n\t\tfor ( int i = 0; i < n; ++i ){\n\t\t\tcin >> a.x >> c >>a.y;\n\t\t\tlist.pushBack( a );\n\t\t}\n\n\t\tcout << list.cntRound() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<string>\n#include<sstream>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nnamespace std {\n  bool operator <(const P &a, const P &b) {\n    if(a.real() != b.real()) return a.real() < b.real();\n    return a.imag() < b.imag();\n  }\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for(int i = 0; i < n; ch[k++] = ps[i++])\n    while(k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for(int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n    while(k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main() {\n  int n;\n  while(scanf(\"%d\", &n) != EOF && n) {\n    vector<P> g(n);\n    for(int i = 0; i < n; ++i) {\n      P &p = g[i];\n      scanf(\"%lf,%lf\", &p.real(), &p.imag());\n    }\n    printf(\"%d\\n\", g.size() - convex_hull(g).size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require sqrt ceil floor\n#include <climits>\t// require INT_MAX etc\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <stdint.h>\t// require uint64_t\n#include <fstream>\t// require freopen\n#include <complex>\n\n#define EPS (1e-9)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst int MAX_LEN = 4000.0;\nconst int MAX_ARG = M_PI;\n\n// àÏ (dot product) : a&#8901;b = |a||b|cosÆ\ndouble dot(P a, P b)\n{\n\tdouble res = a.real() * b.real() + a.imag() * b.imag();\n\n\treturn res;\n}\n// OÏ (cross product) : a~b = |a||b|sinÆ\n\ndouble cross(P a, P b)\n{\n\tdouble res = a.real() * b.imag() - a.imag() * b.real();\n\n  return res;\n}\n\ndouble stod (string str )\n{\n\tstringstream ss (str );\n\tdouble res;\n\n\tss >> res;\n\n\treturn res;\n}\n\nbool cmp (P a, P b )\n{\n\tif (a.imag() != b.imag() )\n\t\treturn a.imag() < b.imag();\n\n\treturn a.real() < b.real();\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.epl\", \"r\", stdin );\n\tint n;\n\n\twhile (cin >> n && n ){\n\n\t\tvector <P> pos (n);\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\tstring str = \"\";\n\t\t\tcin >> str;\n\t\t\tdouble x = stod (str.substr (0, str.find (',') ) );\n\t\t\tdouble y = stod (str.substr (str.find (',')+1) );\n\t\t\tP p;\n\t\t\tp.real() = x;\n\t\t\tp.imag() = y;\n\t\t\tpos[i] = p;\n\t\t} // end for\n\t\tsort (pos.begin(), pos.end(), cmp );\n\n\t\tvector <int> used (n, 0 );\n//\t\tused[0] = 1;\n\t\tP start = pos[0];\n\t\tP curr = pos[0];\n\t\tP base;\n\t\tbase.real() = 1.0;\n\t\tbase.imag() = 0.0;\n\n\t\tP next, prev;\n\n\t\tdouble len = MAX_LEN;\n\t\tdouble min_arg = M_PI;\n\t\tint nd = -1;\n\n\t\tfor (int i = 1; i < n; ++i ){\n//\t\t\tif (used[i] )\n//\t\t\t\tcontinue;\n\t\t\tP b = base;\n\t\t\tP c = pos[i] - curr;\n\t\t\tdouble d = dot (b, c );\n\t\t\tdouble a = 0.0;\n\t\t\tif (d < 0.0 ){\t\n\t\t\t\t\ta = M_PI/2.;\n\t\t\t\t} // end if\n\t\t\ta += acos (fabs(d )/abs(b )/abs (c ) );\n\t\t\tif (min_arg >= a ){\n\t\t\t\tif ( EQ (min_arg, a) && len > abs (c ) )  {\n\t\t\t\t\tnext = pos[i];\n\t\t\t\t\tnd = i;\n\t\t\t\t\tlen = MAX_LEN;\n\t\t\t\t}else{\n\t\t\t\t\tmin_arg = a;\n\t\t\t\t\tnext = pos[i];\n\t\t\t\t\tnd = i;\n\t\t\t\t\tlen = min (len, abs (c ) );\n\t\t\t\t} // en dif\n\t\t\t} // end if\n\t\t} // end for\n\t\tif (nd != - 1 ) \n\t\t\tused[nd] = 1;\n\n\t\tprev = next;\n\t\tbase = curr;\n\t\tdo{\n\t\t\tlen = MAX_LEN;\n\t\t\tmin_arg = M_PI;\n\t\t\tnd = -1;\n\t\t\tfor (int i = 0; i < n; ++i ){\n\n\t\t\t\tif (used[i] )\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tP b = prev - base;\n\t\t\t\tP c = pos[i] - base;\n\t\t\t\tdouble d = dot (b, c );\n\t\t\t\tdouble a = 0.0;\n\t\t\t\tif (d < 0.0 ){\n\t\t\t\t\ta = M_PI/2.;\n\t\t\t\t} // end if\n\t\t\t\n\t\t\t\ta += acos (fabs(d)/ abs (b) / abs (c ) );\n\n\t\t\t\tif (min_arg >= a ) {\n\t\t\t\t\tif (EQ (min_arg, a) && len > abs (c ) ) {\n\t\t\t\t\t\tlen = abs (c );\n\t\t\t\t\t\tnext = pos[i];\n\t\t\t\t\t\tnd = i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmin_arg = a;\n\t\t\t\t\t\tnext = pos[i];\n\t\t\t\t\t\tnd = i;\n\t\t\t\t\t\tlen = min (len, abs (c ) );\n\t\t\t\t\t} // en dif\n\t\t\t\t} // end if\n\t\t\t} // end for\n\n\t\t\tif (nd != -1 ) \n\t\t\t\tused[nd] = 1;\n\t\t\tbase = prev;\n\t\t\tprev = next;\n\n//\t\t}while (next != start && (int)count (used.begin(), used.end(),1 ) != n );\n\t\t}while (prev != start );\n\n\t\tint res = (int)count (used.begin(), used.end(), 0 );\t\n\n\t\tcout << res << endl;\t\n\n\t} // end loop\n\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef complex<double> P;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nint ccw(const P& a, P b, P c) {\n    b -= a, c -= a;\n    if (cross(b, c) > 0) return 1;\n    if (cross(b, c) < 0) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nvector<P> convex_hull(vector<P> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<P> v(2*n);\n    for (int i = 0; i < n; v[k++] = ps[i++]) {\n        while (k > 1 && ccw(v[k-2], v[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k; i >= 0; v[k++] = ps[i--]) {\n        while (k > t && ccw(v[k-2], v[k-1], ps[i]) <= 0) k--;\n    }\n    v.resize(k-1);\n    return v;\n}\n\nint main() {\n    for (;;) {\n        int n;\n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n        vector<P> ps;\n        rep (i, n) {\n            double x, y;\n            scanf(\"%lf,%lf\", &x, &y);\n            ps.push_back(P(x, y));\n        }\n        vector<P> qs = convex_hull(ps);\n        printf(\"%d\\n\", (int)(ps.size()-qs.size()));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\n\n#define X(a)\t\t( (a).real() )\n#define Y(a)\t\t( (a).imag() )\n#define EQ(a,b)\t\t( -EPS<(a)-(b) && (a)-(b)<EPS )\n#define EQV(a,b)\t( EQ(X(a),X(b)) && EQ(Y(a),Y(b)) )\n\n#define unit(a)\t\t( (a)/abs(a) )\n#define normal(a)\t( (a)*P(0,1) )\n#define dot(a,b)\t( X((a)*conj(b)) )\n#define cross(a,b)\t( Y(conj(a)*(b)) )\n\nnamespace std\n{\n\tbool operator < (const P& a, const P& b)\n\t{\n\t\treturn X(a)!=X(b) ? X(a)<X(b) : Y(a)<Y(b);\n\t}\n}\n\n// 3ツ点ツづ個暗環置ツ甘鳴係\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t// a--b--c on line\n\treturn 0;\n}\n\n\nG convexhull(G g)\n{\n\tG h(2*g.size());\n\tsort(g.begin(), g.end());\n\n\tint i,k,t,sz=g.size();\n\tfor(i=0,k=0; i<sz; h[k++]=g[i++])\n\t{\n\t\twhile( k>=2 && ccw(h[k-2],h[k-1],g[i])<=0 ) k--;\n\t}\n\tfor(i=sz-2,t=k+1; i>=0; h[k++]=g[i--])\n\t{\n\t\twhile( k>=t && ccw(h[k-2],h[k-1],g[i])<=0 ) k--;\n\t}\n\n\th.resize(k-1);\n\treturn h;\n}\n\n\nint main()\n{\n\tint n; double x,y; char c;\n\twhile(cin >> n, n)\n\t{\n\t\tG g,h;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> x >> c >> y;\n\t\t\tg.push_back(P(x,y));\n\t\t}\n\t\th=convexhull(g);\n\t\tcout << g.size()-h.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nP pin(){\n\tdouble x,y;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(P c,double r,const L &l){\n    return (distanceLP(l,c) < r+EPS &&\n            (r < abs(c-l[0]) + EPS || r < abs(c-l[1]) + EPS));\n}\nL circles_point(P c1,double r1,P c2,double r2){\n    double d = abs(c1-c2);\n    double s = (r1+r2+d) / 2;\n    double S = sqrt(s*(s-r1)*(s-r2)*(s-d));\n    double h = 2 * S / d;\n    P v = (c2-c1) / (abs(c2-c1)); \n    double m = sqrt(r1*r1 - h*h);\n    P a=c1 + m*v+h*v*P(0,1);\n\tP b=c1 + m*v-h*v*P(0,1);\n\tif(b<a)\n\t\tswap(a,b);\n\treturn L(a,b);\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint contain(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspoint(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG g(n);\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tchar d;\n\t\t\tcin>>x>>d>>y;\n\t\t\tg[i]=P(x,y);\n\t\t}\n\t\tG totu=convex_hull(g);\n\t\tcout<<n-totu.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\n\n\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; double r;\n    C(const P &p, double r) : p(p), r(r) { }\n};\n\nvector<P> convex_hull(vector<P> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<P> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        vector<P> v;\n        for(int i=0; i< n; i++){\n            double x, y;\n            scanf(\"%lf,%lf\", &x, &y);\n            P p;\n            p.real(x); p.imag(y);\n            v.push_back(p);\n        }\n        vector<P> q =  convex_hull(v);\n        cout << n-q.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\n#define SIZE 100000\n\nstruct Point{\n    typedef double Type;\n    \n    Type x,y;\n    \n    Point(Type X,Type Y){\n        x = X;\n        y = Y;\n    }\n    \n    bool operator< (const Point &B) const{\n        return x==B.x ? y < B.y : x < B.x;\n    }\n};\n\n/* ConvexHull(??????) */\n\nbool ccw(Point &base,Point &A,Point &B){\n    return (A.x-base.x)*(B.y-base.y) - (A.y-base.y)*(B.x-base.x) >= 0; //double?????? -EPS\n}\n\nvector<Point> ConvexHull(vector<Point> s){\n    vector<Point> upper,lower;\n    int n = (int)s.size();\n    \n    if(n<3) return s;\n    \n    sort(s.begin(),s.end());\n    \n    upper.push_back(s[0]);\n    upper.push_back(s[1]);\n    lower.push_back(s[n-1]);\n    lower.push_back(s[n-2]);\n    \n    for(int i=2;i<n;i++){\n        for(int m = (int)upper.size();m>=2 && ccw(upper[m-2],upper[m-1],s[i]); m--){\n            upper.pop_back();\n        }\n        upper.push_back(s[i]);\n    }\n    \n    for(int i=n-3;i>=0;i--){\n        for(int m = (int)lower.size();m>=2 && ccw(lower[m-2],lower[m-1],s[i]); m--){\n            lower.pop_back();\n        }\n        lower.push_back(s[i]);\n    }\n    \n    reverse(lower.begin(),lower.end());\n    for(int i=(int)upper.size()-2;i>=1;i--) lower.push_back(upper[i]);\n    \n    return lower;\n}\n\nint calc(int n){\n    double x,y;\n    \n    //scanf(\"%d\",&n);\n    \n    vector<Point> vec,ans;\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%lf,%lf\",&x,&y);\n        vec.push_back(Point(x,y));\n    }\n    \n    ans = ConvexHull(vec);\n    \n    printf(\"%d\\n\",n-(int)ans.size());\n    \n    return 0;\n}\n\nint main(){\n    int n;\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        calc(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n); (i)++)\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b); (i)++)\n#define PUSH(n,v) for(int i=0; i<(n); i++) {int j; cin >> j; v.push_back(j);}\n#define ALL(v) v.begin(), v.end()\n#define print(s) cout << (s) << endl\n\ntypedef pair<double,double> xy;\nconst double INF = 1e9;\n\ndouble getTilt(xy p, xy q) {\n    if (p.first == q.first && p.second == q.second) {\n        return -INF;\n    }else if (p.first == q.first) {\n        return INF;\n    }else {\n        return (q.second-p.second)/(q.first-p.first);\n    }\n}\n\nvoid solve68(int n) {\n    vector<xy> points;\n    double x,y;\n    REP(i,n) {\n        scanf(\"%lf,%lf\",&x,&y);\n        points.push_back(make_pair(x, y));\n    }\n    sort(ALL(points));\n    vector<xy> peri;\n    peri.push_back(points[0]);\n    double maxTilt;\n    double tmpMax;\n    int tmpMaxPoint;\n    double tilt;\n    maxTilt = 2*INF;\n    while(!(peri.size() >= 4 && peri.front() == peri.back())) {\n        tmpMax = -INF;\n        tmpMaxPoint = -1;\n        xy back = peri.back();\n        REP(i,points.size()) {\n            tilt = getTilt(back, points[i]);\n            if (tilt < maxTilt && tilt > tmpMax) {\n                tmpMax = tilt;\n                tmpMaxPoint = i;\n            }\n        }\n        if (tmpMaxPoint == -1) {\n            maxTilt = 2*INF;\n            tmpMax = INF;\n        }else {\n            maxTilt = tmpMax;\n            peri.push_back(points[tmpMaxPoint]);\n        }\n    }\n    cout << n - peri.size() + 1 << endl;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        solve68(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<30;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-8;\n\ntypedef complex<double> P;\ntypedef complex<double> Vec;\n\ndouble cross(Vec a, Vec b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool comp(P a, P b) {\n\tif (a.real() != b.real()) return a.real() < b.real();\n\treturn a.imag() < b.imag();\n}\n\nvector<P> convex_full(vector<P> p) {\n\tsort(ALL(p), comp);\n\t\n\tvector<P> res(2 * p.size());\n\tint k = 0;\n\t\n\t// ?????´??????\n\tREP(i, p.size()) {\n\t\twhile (k > 1 && cross(res[k - 1] - res[k - 2], p[i] - res[k - 1]) <= EPS) k--;\n\t\tres[k++] = p[i];\n\t}\n\t\n\t// ?????´??????\n\tfor (int i = (int)p.size() - 2, c1 = k; i >= 0; i--) {\n\t\twhile (k > c1 && cross(res[k - 1] - res[k - 2], p[i] - res[k - 1]) <= EPS) k--;\n\t\tres[k++] = p[i];\n\t}\n\t\n\tres.resize(k - 1);\n\treturn res;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<P> p(n);\n\t\tREP(i, n) {\n\t\t\tdouble x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tp[i] = P(x, y);\n\t\t}\n\t\t\n\t\tvector<P> cf = convex_full(p);\n\t\t\n\t\tprintf(\"%d %d\\n\", p.size(), cf.size());\n\t\t\n\t\tcout << p.size() - cf.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <string.h>\n#include <complex>\nusing namespace std;\n\ntypedef long double D;\nconst D EPS = 1e-8,INF = 1e12;\n\ntemplate<typename T> int sig(T a,T b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\ntemplate<typename T> bool eq(T a,T b){ return sig(abs(a-b))==0;}\ntemplate<typename T> D norm(T a){ return a*a;}\n\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n#define ISEQ(c) (c).begin(), (c).end()\ntypedef long long ll;\n\ntypedef vector<P> Poly,ConvexPoly;\n#define prev(as, i) as[(i-1+as.size())%as.size()]\n#define curr(as, i)  as[i]\n#define next(as, i) as[(i+1)%as.size()]\n\n\n// a×b\nD cross(const P& a,const P& b){\n  return imag(conj(a)*b);\n}\n// a・b\nD dot(const P& a,const P& b) {\n  return real(conj(a)*b);\n}\n\nint ccw(const P& a,P b,P c){\n  b -= a; c -= a;\n  if (cross(b,c) > 0)   return +1;       // counter clockwise\n  if (cross(b,c) < 0)   return -1;       // clockwise\n  if (dot(b,c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//浮動小数点modで非負の値のみかえす．\nD pfmod(D v,D M=2*M_PI){\n  return fmod(fmod(v,M)+M,M);\n}\n\n//[0,PI)\nD AbsArg(D a){\n  D ret=pfmod(max(a,-a),2);\n  return min(ret,2*M_PI-ret);\n}\n\nnamespace std{\n  bool operator < (const P& a,const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n  bool operator == (const P& a,const P& b){\n    return eq(a,b);\n  }\n};\n\n//\nP O=P(0,0);\nP s,g;\n\n\n// verified by \n// 事前にs-g\n// O-s → O-gの回転方向に関してソート．\n// (同角度の場合、距離が遠い方が前)\nbool CompArg(const P& p1,const P&p2){\n  if(abs(ccw(O,p1,p2))!=1)return abs(p1)>abs(p2);//sameline\n  return ccw(O,p1,p2)==ccw(O,s,g);\n}\n\n//!!\n//角度ソート\nP dir;//基準方向\nbool Comp(const P& p1,const P&p2){\n  if(sig(pfmod(arg(p1)-arg(dir)),pfmod(arg(p2)-arg(dir)))==0)return abs(p1)>abs(p2);\n  return sig(pfmod(arg(p1)-arg(dir)),pfmod(arg(p2)-arg(dir)));\n}\n\n\nenum { OUT, ON, IN };\nint contains(const Poly& ps, const P& p) {\n  bool in = false;\n  REP(i,ps.size()){\n    P a = curr(ps,i) - p, b = next(ps,i) - p;\n    if (a.Y > b.Y) swap(a, b);\n    if (a.Y <= 0 && 0 < b.Y)\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nD area2(const Poly& ps){\n  D S=0;\n  REP(i,ps.size())S+=cross(curr(ps,i),next(ps,i));\n  return S;\n}\n\n//凸包\n//O(n logn)\nConvexPoly convex_hull(Poly ps) {\n  int n = ps.size(), k = 0;\n  sort(ALL(ps));\n  Poly ch(2*n);\n  REP(i,n){ // lower-hull\n    while (k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n    ch[k++]=ps[i];\n  }\n  for(int i=n-2,t=k+1;i>=0;i--){// upper-hull\n    while (k >= t && ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n    ch[k++]=ps[i];\n  }\n  ch.resize(k-1);\n  return ch;\n}\n\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    Poly p;\n    for (int i = 0; i < n; i++) {\n      double x, y;\n      scanf(\"%lf,%lf\", &x, &y);\n      p.push_back(P(x,y));\n    }\n    sort(ISEQ(p));\n    ConvexPoly cp = convex_hull(p);\n    //    for (int i = 0; i < cp.size(); i++) {\n    //      printf(\"%f, %f\\n\", cp[i].X, cp[i].Y);\n    //    }\n    cout << n - cp.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-15;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<int,Pii> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    Point operator + (Point p){\n        return Point(x+p.x,y+p.y);\n    }\n  \n    Point operator - (Point p){\n        return Point(x-p.x,y-p.y);\n    }\n  \n    Point operator * (double k){\n        return Point(k*x,k*y);\n    }\n  \n    Point operator / (double k){\n        return Point(x/k,y/k);\n    }\n \n    bool operator<(const Point &p)const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n  \n};\ndouble dot(Point p, Point q){\n    return p.x*q.x+p.y*q.y;\n}\n  \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n  \ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y;\n}\n  \ndouble pabs(Point p){\n    return sqrt(norm(p));\n}\ntypedef vector<Point> Polygon;\nstruct Line : Polygon{\n    Line(){}\n    Line(Point p,Point q){\n        PB(p);\n        PB(q);  \n    }\n};\nstruct Circle{\n    Point p; //中心点\n    double r; //半径\n    Circle(){}\n    Circle(Point _p,double _r){\n        p = _p;\n        r = _r;\n    }\n};\nint ccw(Point a,Point b,Point c){\n    b = b-a;\n    c = c-a;\n    if(cross(b,c) > 0)return +1; //a→b で反時計に折れてc ccw\n    if(cross(b,c) < 0)return -1; //a→b で時計に折れてc ccw\n    if(dot(b,c) < 0)return +2; // c--a--b;\n    if(pabs(b)<pabs(c))return -2; //a--b--c\n    return 0; //a--c--b\n}\nbool intersectSS(Line l,Line m){\n    //lとmが交差してるかどうか\n    return (ccw(l[0],l[1],m[0])*ccw(l[0],l[1],m[1])<=0)&&\n            (ccw(m[0],m[1],l[0])*ccw(m[0],m[1],l[1])<=0);\n}\n\nbool intersectLL(Line l,Line m){\n\treturn fabs(cross(l[1]-l[0],m[1]-m[0])) > EPS || //平行でない\n\t\t\tfabs(cross(l[1]-l[0],m[0]-l[0])) < EPS; //同一の線\n}\n\n\ndouble TriangleArea(Point a,Point b,Point c){\n    b = b - a;\n    c = c - a;\n    return cross(b,c)*0.5; //負になることもあるので注意\n}\n \ndouble VertexArea(Polygon v){\n    double subArea = 0.0;\n    rep(i,v.size()-1){\n        subArea += TriangleArea(v[0],v[i],v[i+1]);\n    }\n    return subArea; //負になることもあるので注意\n}\n\nPoint crosspoint(Line l,Line m){\n    if(intersectSS(l,m) == false)return Point(INF,INF);\n    return m[0]+(m[1]-m[0])*cross(l[1]-l[0],l[1]-m[0])/cross(l[1]-l[0],m[1]-m[0]);\n}\n \nPolygon ConvexHull(Polygon v){\n\tint n = v.size();\n\tint k = 0;\n\tsort(v.begin(),v.end());\n\tPolygon e(2*n);\n\tfor(int i=0;i<n;e[k++]=v[i++])\n\t\twhile(k>=2&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\tfor(int i=n-2,t=k+1;i>=0;e[k++]=v[i--])\n\t\twhile(k>=t&&ccw(e[k-2],e[k-1],v[i])<=0)k--;\n\te.resize(k-1);\n\treturn e;\n}\n\nint main(){\n\tint N;\n\twhile(scanf(\"%d\",&N),N){\n\t\tPolygon v;\n\t\trep(i,N){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf,%lf\",&x,&y);\n\t\t\tv.PB(Point(x,y));\n\t\t}\n\t\tprintf(\"%d\\n\",N-ConvexHull(v).size());\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t\t1e-9\n#define\tpb(a)\tpush_back(a);\n\n#define\tID_CCW\t0\n#define\tID_CW\t1\n#define\tID_GO\t2\n#define\tID_BACK\t3\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy) : x(xx),y(yy){}\n};\n\nclass Polygon : public vector<Point>{};\n\nPoint &operator -=(Point &a,const Point &b)\n{\n\ta.x-=b.x;\n\ta.y-=b.y;\n\treturn a;\n}\n\nbool operator <(const Point &a,const Point &b)\n{\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\ndouble dot(const Point &a,const Point &b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint ccw(const Point &a,Point b,Point c)\n{\n\tb-=a;\n\tc-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn ID_CCW;\n\tif(rotdir<-EPS)\t\treturn ID_CW;\n\tif(dot(b,c)>EPS)\treturn ID_GO;\n\treturn ID_BACK;\n}\n\nPolygon ConvexHull(vector<Point> ps)\n{\n\tPolygon ch;\n\tint n=ps.size();\n\tsort(ps.begin(),ps.end());\n\n\tvector<Point> ch_u(n);\n\tint n_u=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tch_u[n_u++]=ps[i];\n\t\twhile(n_u>=3 && ccw(ch_u[n_u-3],ch_u[n_u-2],ch_u[n_u-1])!=ID_CCW){\n\t\t\tch_u[n_u-2]=ch_u[n_u-1];\n\t\t\tn_u--;\n\t\t}\n\t}\n\n\tvector<Point> ch_l(n);\n\tint n_l=0;\n\tfor(int i=0;i<n;i++){\n\t\tch_l[n_l++]=ps[i];\n\t\twhile(n_l>=3 && ccw(ch_l[n_l-3],ch_l[n_l-2],ch_l[n_l-1])!=ID_CCW){\n\t\t\tch_l[n_l-2]=ch_l[n_l-1];\n\t\t\tn_l--;\n\t\t}\n\t}\n\n\tfor(int i=0;i<n_u-1;i++)\tch.pb(ch_u[i]);\n\tfor(int i=0;i<n_l-1;i++)\tch.pb(ch_l[i]);\n\treturn ch;\n}\n\nint main()\n{\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tvector<Point> p(n);\n\t\tfor(int i=0;i<n;i++)\tscanf(\"%lf,%lf\",&p[i].x,&p[i].y);\n\t\tprintf(\"%d\\n\",n-ConvexHull(p).size());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nstruct P{\n\tdouble x, y;\n\tP(){}\n\tP(double x, double y) : x(x), y(y) {\n\t}\n\tP operator - (P p) {\n\t\treturn P(x-p.x,y-p.y);\n\t}\n\tdouble det(P p){\n\t\treturn x*p.y-y*p.x;\n\t}\n\tbool operator<(const P& r) const {\n\t\treturn x==r.x?y<r.y:x<r.x;\n\t}\n};\n\nint n;\nP p[100];\n\nvoid solve(){\n\tint k = 0;\n\tchar tra;\n\trep(i,n) scanf(\"%lf%c%lf\", &p[i].x, &tra, &p[i].y);\n\tsort(p,p+n);\n\tP qs[200];\n\trep(i,n){\n\t\twhile(k > 1 && (qs[k-1]-qs[k-2]).det(p[i]-qs[k-1]) <= 0) k--;\n\t\tqs[k++] = p[i];\n\t}\n\tfor(int i = n-2, t = k; i >= 0; i--){\n\t\twhile(k > t && (qs[k-1]-qs[k-2]).det(p[i]-qs[k-1]) <= 0) k--;\n\t\tqs[k++] = p[i];\n\t}\n\tprintf(\"%d\\n\",n-k+1); \n}\n\nint main(){\n\twhile(scanf(\"%d\",&n),n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace geometry\n{\t\n\ttypedef double D;\n\ttypedef complex<D> P;\n\ttypedef pair<P, P> S;\n\ttypedef S L;\n\ttypedef pair<P, D> C;\n\t\n\t#define EPS \t\t(1e-10)\n\t#define EQ(a, b) \t(abs((a) - (b)) < EPS)\n\t#define EQV(a, b) \t(EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\t\n\tstatic const int COUNTER_CLOCKWISE \t=  1;\n\tstatic const int CLOCKWISE\t\t\t= -1;\n\tstatic const int ONLINE_BACK\t\t=  2;\n\tstatic const int ONLINE_FRONT\t\t= -2;\n\tstatic const int ON_SEGMENT\t\t\t=  0;\n\t\n\tbool cmp(const P& a, const P& b){\n\t\tif (a.real() != b.real()) return a.real() < b.real();\n\t\treturn a.imag() < b.imag();\n\t}\n\t\n\tvoid debug(P p){\n\t\tprintf(\"x: %f, y: %f\\n\", p.real(), p.imag()); \n\t}\n\tvoid debug(C c){\n\t\tprintf(\"x: %f, y: %f, r: %f\\n\", c.first.real(), c.first.imag(), c.second);\n\t}\n\tvoid debug(S s){\n\t\tprintf(\"{\\n\");\n\t\tprintf(\"    \");\n\t\tdebug(s.first);\n\t\tprintf(\"    \");\n\t\tdebug(s.second);\n\t\tprintf(\"}\\n\");\n\t}\n\tvoid debug(vector<P> poly){\n\t\tprintf(\"{\\n\");\n\t\tfor (int i = 0; i < poly.size(); i++){\n\t\t\tprintf(\"    \");\n\t\t\tdebug(poly[i]);\n\t\t}\n\t\tprintf(\"}\\n\");\n\t}\n\t\n\tD norm(P a) { return a.real() * a.real() + a.imag() * a.imag(); }\n\t\n\tD dot(P a, P b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\tD cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\n\t\n\tbool isOrthogonal(P a1, P a2, P b1, P b2) { return EQ(dot(a1 - a2, b1 - b2), 0.0); }\n\tbool isOrthogonal(L a, L b) { return isOrthogonal(a.first, a.second, b.first, b.second); }\n\tbool isParallel(P a1, P a2, P b1, P b2) { return EQ(cross(a1 - a2, b1 - b2), 0.0); }\n\tbool isParallel(L a, L b) { return isParallel(a.first, a.second, b.first, b.second); }\n\t\n\tbool isPointOnLine(P a, P b, P c) { return EQ(cross(b - a, c - a), 0.0); }\n\tbool isPointOnLine(L a, P b) { return isPointOnLine(a.first, a.second, b); }\n\tbool isPointOnSegment(P a, P b, P c) {\n\t\treturn EQ(cross(b - a, c - a), 0.0) &&\n\t\t       (dot(b - a, c - a) > -EPS) &&\n\t\t\t   (dot(a - b, c - b) > -EPS);\n\t}\n\tbool isPointOnSegment(S a, P b) { return isPointOnLine(a.first, a.second, b); }\n\t\n\tint ccw(P p0, P p1, P p2){\n\t\tP a = p1 - p0;\n\t\tP b = p2 - p0;\n\t\tif (cross(a, b) > EPS) \treturn COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS)\treturn ONLINE_BACK;\n\t\tif (norm(a) < norm(b))\treturn ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\tbool intersect(P p1, P p2, P p3, P p4){\n\t\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t       ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n\t}\n\tbool intersect(S s1, S s2){\n\t\treturn intersect(s1.first, s1.second, s2.first, s2.second);\n\t}\n\t\n\tD distanceLP(P a, P b, P c) { return abs(cross(b - a, c - a)) / abs(b - a); }\n\tD distanceLP(L a, P b) { return distanceLP(a.first, a.second, b); }\n\tD distanceSP(P a, P b, P c) {\n\t\tif (dot(b - a, c - a) < EPS) return abs(c - a);\n\t\tif (dot(a - b, c - b) < EPS) return abs(c - b);\n\t\treturn abs(cross(b - a, c - a)) / abs(b - a);\n\t}\n\tD distanceSP(S a, P b) { return distanceSP(a.first, a.second, b); }\n\t\n\tbool intersectCL(C c, L l){\n\t\treturn c.second - distanceLP(l, c.first) > -EPS;\n\t}\n\tbool intersectCS(C c, S s){\n\t\tif (EQ(c.second - abs(c.first - s.first), 0.0) ||\n\t\t\tEQ(c.second - abs(c.first - s.second), 0.0)) return true;\n\t\tif (c.second - distanceSP(s, c.first) > -EPS){\n\t\t\treturn (c.second - abs(c.first - s.first) < EPS ||\n\t\t\t\t    c.second - abs(c.first - s.second) < EPS);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tP project(S s, P p){\n\t\tP base = s.second - s.first;\n\t\tD r = dot(p - s.first, base) / norm(base);\n\t\treturn s.first + base * r;\n\t}\n\tP reflect(S s, P p){\n\t\treturn p + (project(s, p) - p) * (D)2.0;\n\t}\n\t\n\tP crossPoint(S s1, S s2){\n\t\tP base = s2.second - s2.first;\n\t\tD d1 = abs(cross(base, s1.first - s2.first));\n\t\tD d2 = abs(cross(base, s1.second - s2.first));\n\t\tD t = d1 / (d1 + d2);\n\t\treturn s1.first + (s1.second - s1.first) * t;\n\t}\n\t\n\tD area(vector<P> poly){\n\t\tif (poly.size() < 3) return 0.0;\n\t\tD res = 0.0;\n\t\tfor (int i = 0; i < poly.size() - 2; i++){\n\t\t\tP v1 = poly[i + 1] - poly[i];\n\t\t\tP v2 = poly[i + 2] - poly[i];\n\t\t\tres += abs(cross(v1, v2)) / 2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<P> convexHull(vector<P> s){\n\t\tif (s.size() < 3) return s;\n\t\tvector<P> u, l;\n\t\tsort(s.begin(), s.end(), cmp);\n\t\t//debug(s);\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE/* && ccw(u[n - 2], u[n - 1], s[i]) != ONLINE_FRONT*/; n--){\n\t\t\t\tu.pop_back();\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE/* && ccw(l[n - 2], l[n - 1], s[i]) != ONLINE_FRONT*/; n--){\n\t\t\t\tl.pop_back();\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\treturn l;\n\t}\n}\n\nusing namespace geometry;\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tvector<P> p;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tD x, y;\n\t\t\tscanf(\"%lf,%lf\", &x, &y);\n\t\t\tp.push_back(P(x, y));\n\t\t}\n\t\tint r = p.size() - convexHull(p).size();\n\t\tprintf(\"%d\\n\", r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double ld;\n\nconst ld EPS = 1e-9;\nconst ld INF = 1e10;\nconst ld PI = M_PI;\n\nstruct Point{\n  ld x, y;\n  Point(ld x, ld y):x(x), y(y){}\n  Point(){}\n};\n\nPoint operator+(const Point &a, const Point &b){\n  return Point(a.x + b.x, a.y + b.y);\n}\nPoint operator-(const Point &a, const Point &b){\n  return Point(a.x - b.x, a.y - b.y);\n}\nPoint operator*(const Point &a, const ld b){\n  return Point(a.x * b, a.y * b);\n}\nPoint operator*(const Point &a, const Point &b){\n  return Point(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nPoint operator/(const Point &a, const ld b){\n  return Point(a.x / b, a.y / b);\n}\n\nbool eq(ld a, ld b){\n  return abs(a-b) < EPS;\n}\n\n// 外積\nld cross(const Point &a, const Point &b){\n  return a.x*b.y - a.y*b.x;\n}\n// 内積\nld dot(const Point &a, const Point &b){\n  return a.x*b.x + a.y*b.y;\n}\nld norm(const Point &a){\n  return dot(a, a);\n}\n\nbool operator<(const Point &a, const Point &b){\n  return make_pair(a.x, a.y) < make_pair(b.x, b.y);\n}\nbool operator==(const Point &a, const Point &b){\n  return a.x == b.x && a.y == b.y;\n}\n\n\ntypedef vector<Point> Polygon;\nPoint next(const Polygon &a, int x){\n  return a[(x+1)%a.size()];\n}\nPoint prev(const Polygon &a, int x){\n  return a[(x-1+a.size()) % a.size()];\n}\n\n// Counter Clock Wise 判定\nint ccw(Point a, Point b, Point c){\n  b = b - a;\n  c = c - a;\n  if(cross(b, c) > EPS) return +1; // 反時計周り\n  if(cross(b, c) < -EPS) return -1; // 時計周り\n  if(dot(b, c) < 0) return +2; // c -- a -- b がこの順番に一直線上\n  if(norm(b) < norm(c)) return -2; // a -- b -- c がこの順番に一直線上\n  return 0; // a -- c -- b が一直線上\n}\n\nbool compare(const Point &a, const Point &b){\n  if(eq(a.y, b.y)) return a.x < b.x;\n  return a.y < b.y;\n}\n\n\nPolygon convex_hull(Polygon ps){\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end(), compare);\n  Polygon ch(2*n);\n  for(int i = 0 ; i < n ; i++){\n    while(k > 1 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;    \n    ch[k++] = ps[i];\n  }\n  int t = k;\n  for(int i = n-2 ; i >= 0 ; i--){\n    while(k > t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    ch[k++] = ps[i];\n  }\n  ch.resize(k-1);\n  return ch;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    Polygon poly;\n    \n    double x, y;\n    for(int i = 0 ; i < n ; i++){\n      scanf(\"%lf,%lf\", &x, &y);\n      poly.push_back(Point(x, y));      \n    }\n    \n    Polygon con = convex_hull(poly);    \n    int ans = poly.size() - con.size();\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n \nstruct Point {\n    double x, y;\n \n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n \ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n \ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n \ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n \n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\ntypedef Point Vector;\n \nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n \ntypedef vector<Point> Polygon;\n \nbool sortY(Point p1, Point p2)\n{\n    if (p1.y != p2.y) {\n    return (p1.y - p2.y < -EPS);\n    } else { \n    return (p1.x - p2.x < -EPS);\n    }\n}\n \nPolygon convex_hull(Polygon &ps)\n{\n    int N = ps.size(), j = 0;\n    Polygon pg(N*2);\n    sort(ps.begin(), ps.end(), sortY);\n    for (int i = 0; i < N; i++, j++) {\n    while (j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) {\n        j--;\n    }\n    pg[j] = ps[i];\n    }\n    int k = j+1;\n    for (int i = N-2; i >= 0; i--, j++) {\n    while (j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) {\n        j--;\n    }\n    pg[j] = ps[i];\n    }\n    pg.resize(j-1);\n    return pg;\n}\n \nint main()\n{\n    int N;\n    char c;\n    while (cin >> N, N) {\n        Polygon pg(N);\n        for (int i = 0; i < N; i++) {\n            cin >> pg[i].x >> c >> pg[i].y;\n        }        \n        cout << N - convex_hull(pg).size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x real() \n#define y imag()\n#define px second\n#define py first\nusing namespace std;\ntypedef complex<double> point;\ntypedef pair <double,double> P;\nP G[100001];\nvector <P> stc;\nvector <point> pol;\n \nbool eq(double a,double b){return (abs(a-b)<=(1e-9));}\nbool on_segment(point a,point b,point c){return eq(abs(b-a),abs(a-c)+abs(b-c));}\ndouble get_r(point a,point b,point c){\n  b-=a,c-=a;\n  b*=conj(c);\n  return arg(b);\n}\nint solve(point a){\n  for(int i=0;i<(int)pol.size();i++)\n    if(on_segment(pol[i],pol[(i+1)%pol.size()],a)) return 1;\n  \n  double sum=0;\n  for(int i=0;i<(int)pol.size();i++)sum+=get_r(a,pol[i],pol[(i+1)%pol.size()]);\n  \n  if(eq(sum,0))return 0;\n  return 2;\n}\n//\n \nint ccw(point a,point b,point c) {\n  point ab=b-a, ac =c-a;\n  point d =ac*conj(ab); \n  if(d.y > 0) return true;\n  return false;\n}\n\nint mk(int i,int flg) {\n  point av = point(stc[stc.size()-2].px,stc[stc.size()-2].py);\n  point bv = point(stc[stc.size()-1].px,stc[stc.size()-1].py);\n  point cv = point(G[i].px,G[i].py);\n  if(ccw(av,bv,cv) && stc.size()!=1)stc.pop_back(),i+=flg;\n  else  stc.push_back(G[i]);\n  return i;\n}\n\nint main() {\n  int n;\n  while(cin >> n,n){\n    pol.clear();\n    stc.clear();\n    for(int i=0;i<n;i++)scanf(\"%lf,%lf\",&G[i].px,&G[i].py);\n    sort(G,G+n);\n   \n    stc.push_back(G[0]),stc.push_back(G[1]);\n    for(int i=2;i<n;i++) i=mk(i,-1);\n    for(int i=n-2;i>=0;i--) i=mk(i,1);\n\n    \n    int ans=0;\n    for(int i=0;i<(int)stc.size()-1;i++) pol.push_back(point(stc[i].px,stc[i].py));\n\n    for(int i=0;i<n;i++) ans+=(solve(point(G[i].px,G[i].py))==2);\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a)const{ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(a/x,a/y); }\n    point& operator/=(const double a)const{ x /= a; y /= a; return *this;}\n\t\n\t//比較用\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,const point<T> &b,const point<T> &c){\n    double rdir=cross(b-a,c-a);\n    if(rdir> EPS) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n \ntypedef point<double> P;\ntypedef segment<double> S;\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<P> pt(n);\n\t\tfor(int i =0 ; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\",&(pt[i].x),&(pt[i].y));\n\t\t}\n\t\tvector<P> ans = convex_hull(pt);\n\t\tcout << pt.size() - ans.size() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef complex<double> Point;\n\nnamespace std{\n\ttemplate<typename T>\n\t\tbool operator<(const complex<T>& lhs,const complex<T>& rhs)\n\t\t{\n\t\t\tif(real(lhs)==real(rhs))\n\t\t\t\treturn imag(lhs)<imag(rhs);\n\t\t\telse\n\t\t\t\treturn real(lhs)<real(rhs);\n\t\t}\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Point> p(n);\n\t\trep(i,n)\n\t\t\tscanf(\"%lf,%lf\",&real(p[i]),&imag(p[i]));\n\n\t\t//rep(i,n)\n\t\t//\tcout<<real(p[i])<<\" \"<<imag(p[i])<<endl;\n\n\t\tsort(allof(p));\n\n\t\tvector<Point> uv,lv;\n\t\trep(i,n){\n\t\t\tfor(;;){\n\t\t\t\tif(lv.size()<2){\n\t\t\t\t\tlv.push_back(p[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tPoint p0=lv[lv.size()-2];\n\t\t\t\t\tPoint p1=lv[lv.size()-1];\n\t\t\t\t\t//if(arg(p[i]-p1)>arg(p[i]-p0)){\n\t\t\t\t\tdouble cross=imag(conj(p1-p0)*(p[i]-p0));\n\t\t\t\t\tif(cross>0){\n\t\t\t\t\t\tlv.push_back(p[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlv.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=n;i--;){\n\t\t\tfor(;;){\n\t\t\t\tif(uv.size()<2){\n\t\t\t\t\tuv.push_back(p[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tPoint p0=uv[uv.size()-2];\n\t\t\t\t\tPoint p1=uv[uv.size()-1];\n\t\t\t\t\t//if(arg(p[i]-p1)>arg(p[i]-p0)){\n\t\t\t\t\tdouble cross=imag(conj(p1-p0)*(p[i]-p0));\n\t\t\t\t\tif(cross>0){\n\t\t\t\t\t\tuv.push_back(p[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tuv.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\t//puts(\"uv\");\n\t\t\t//rep(i,uv.size())\n\t\t\t//\tcout<<uv[i]<<endl;\n\t\t}\n\n\t\t//puts(\"uv\");\n\t\t//rep(i,uv.size())\n\t\t//\tcout<<uv[i]<<endl;\n\n\t\t//puts(\"lv\");\n\t\t//rep(i,lv.size())\n\t\t//\tcout<<lv[i]<<endl;\n\t\t\n\t\tint vn=uv.size()+lv.size()-2;\n\t\tcout<<p.size()-vn<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint cross(double x1, double y1, double x2, double y2) {\n    if (0 < x1 * y2 - y1 * x2) return 1;\n    return -1;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        char c;\n        vector<double> x(n), y(n);\n        for (int i=0; i<n; ++i) {\n            cin >> x[i] >> c >> y[i];\n        }\n        vector<bool> touch(n, false);\n        for (int i=0; i<n; ++i) {\n            for (int j=i+1; j<n; ++j) {\n                bool ok = true;\n                int d = 0;\n                for (int k=0; k<n; ++k) {\n                    if (k == i || k == j) continue;\n                    int dd = cross(x[j] - x[i], y[j] - y[i], x[k] - x[i], y[k] - y[i]);\n                    if (d == 0) {\n                        d = dd;\n                    } else if (d != dd) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) {\n                    touch[i] = touch[j] = true;\n                }\n            }\n        }\n        int cnt = n;\n        for (int i=0; i<n; ++i) cnt -= touch[i];\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a,double b){\n  if(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct P{\n  double x,y;\n  P() {}\n  P(double x,double y):x(x),y(y){\n  }\n  P operator + (P p){\n    return P(add(x,p.x),add(y,p.y));\n  }\n  P operator - (P p){\n    return P(add(x,-p.x),add(y,-p.y));\n  }\n  P operator * (double d){\n    return P(x*d,y*d);\n  }\n  double dot(P p){\n    return add(x*p.x,y*p.y);\n  }\n  double det(P p){\n    return add(x*p.y, -y*p.x);\n  }\n};\n\nbool cmp_x(const P& p, const P& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nvector<P>convex_hull(P* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<P>qs(n*2);\n\n  for(int i=0;i<n;i++){\n    while(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(void){\n  int n;\n  double x,y;\n  P p[100];\n\n  while(cin >> n,n){\n    for(int i=0;i<n;i++)\n      scanf(\"%lf,%lf\",&p[i].x,&p[i].y);\n \n    vector<P>d=convex_hull(p,n);\n\n    cout << n-d.size() << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\n#define EPS (1e-10)\ntypedef complex<double> Po;\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){return abs(cross(b-a,c-a)/2);}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) +EPS)return false;\n  else return true;\n}\n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int ans;\n  bool use[100];\n  Po p[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&p[i].real(),&p[i].imag());\n      use[i] = false;\n    }\n\n    ans = 0;\n    for(i=0;i<n-3;i++){\n      for(j=i+1;j<n-2;j++){\n\tfor(k=j+1;k<n-1;k++){\n\t  for(l=k+1;l<n;l++){\n\t    if(!use[l]){\n\t      if(inter(p[i],p[j],p[k],p[l])){\n\t\tans++;\n\t\tuse[l] = true;\n\t      }\n\t    }\n\t    if(!use[k]){\n\t      if(inter(p[i],p[j],p[l],p[k])){\n\t\tans++;\n\t\tuse[k] = true;\n\t      }\n\t    }\n\t    if(!use[j]){\n\t      if(inter(p[i],p[l],p[k],p[j])){\n\t\tans++;\n\t\tuse[j] = true;\n\t      }\n\t    }\n\t    if(!use[i]){\n\t      if(inter(p[l],p[j],p[k],p[i])){\n\t\tans++;\n\t\tuse[i] = true;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nmain(){\n\tint n,i,start,M;\n\tdouble x,y,dX,dY,dx,dy,dot,n1,n2,co,m;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tvector<pair<pair<double,double>,int> >v;\n\t\tfor(i=0;i<n;i++)scanf(\"%lf,%lf\",&x,&y),v.push_back(make_pair(make_pair(x,y),i));\n\t\tpair<pair<double,double>,int>p=*min_element(v.begin(),v.end());\n\t\tdX=0,dY=-1;\n\t\tstart=p.second;\n\t\tvector<int>V;\n\t\tfor(M=-1;M!=start;){\n\t\t\tm=-1,n1=hypot(dX,dY);\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(i==p.second)continue;\n\t\t\t\tdx=v[i].first.first-p.first.first,dy=v[i].first.second-p.first.second;\n\t\t\t\tdot=dX*dx+dY*dy;\n\t\t\t\tn2=hypot(dx,dy),co=dot/n1/n2;\n\t\t\t\tif(m<co)m=co,M=i;\n\t\t\t}\n\t\t\tV.push_back(M);\n\t\t\tdX=v[M].first.first-p.first.first,dY=v[M].first.second-p.first.second;\n\t\t\tp=v[M];\n\t\t}\n\t\tprintf(\"%d\\n\",n-V.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<stack>\n#include<cmath>\n \nusing namespace std;\n \n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n \n#define X real()\n#define Y imag()\ntypedef complex<double> P;\n \nnamespace std{\n    bool operator<(const P &a, const P &b){return a.X==b.X ? a.Y<b.Y : a.X<b.X;}\n}\n \ndouble cross(P a,P b){return a.X*b.Y-a.Y*b.X;}\nbool ccw(P a,P b,P c){return cross(b-a,c-a)>=0;}\n \nvector<P> convex_VP(vector<P> p){\n     \n    sort(p.begin(),p.end());\n    vector<P> ret(p.size()*2);\n     \n    int k=0;\n    for(int i=0;i<p.size();i++){\n        while(k>1 && !ccw(ret[k-2],ret[k-1],p[i]))k--;\n        ret[k]=p[i];k++;\n    }\n     \n    int t=k;\n    for(int i=p.size()-2;i>=0;i--){\n        while(k>t && !ccw(ret[k-2],ret[k-1],p[i]))k--;\n        ret[k]=p[i];k++;\n    }\n     \n    return vector<P>(ret.begin(), ret.begin()+k-1);\n}\n \nint main(){\n     \n    while(1){\n        int n;\n        cin>>n;\n        if(n==0)break;\n         \n        vector<P> p;\n        rep(i,n){\n            double a,b;\n            scanf(\"%lf,%lf\",&a,&b);\n            p.push_back(P(a,b));\n        }\n         \n        vector<P> convex = convex_VP(p);\n\t  /*\n        rep(i,convex.size()){\n            printf(\"%lf %lf\\n\",convex[i].X,convex[i].Y);\n        }*/\n        cout<<(int)p.size()-(int)convex.size()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\n\nbool used[100];\nchar c;\nint n;\ndouble x,y;\nP p[100];\n\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\tfill(used,used+100,0);\n\t\tint mx,my=INF,m;\n\t\trep(i,n){\n\t\t\tcin>>x>>c>>y;\n\t\t\tp[i]=P(x,y);\n\t\t\tif(y<my||y==my&&x<mx){my=y;mx=x;m=i;}\n\t\t}\n\t\tint ans=n,prv=-1;\n\t\tP v(1,0);\n\t\twhile(!used[m]){\n\t\t\tused[m]=1;\n\t\t\tans--;\n\t\t\tint nx;\n\t\t\tdouble M=-2;\n\t\t\trep(i,n)if(i!=m&&i!=prv&&dot(v,(p[i]-p[m])/abs(p[i]-p[m]))>M){M=dot(v,(p[i]-p[m])/abs(p[i]-p[m]));nx=i;}\n\t\t\tv=(p[nx]-p[m])/abs(p[nx]-p[m]);\n\t\t\t//cout<<p[nx]<<\" \"<<v<<\" \"<<M<<endl;\n\t\t\tprv=m;\n\t\t\tm=nx;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint a,s,d,j,i,k,lo,cc[10001],ss,sss,zz,xx;\ndouble f[1001][2],g,h,z,x,c,v,b,q,w;\nint main(void)\n{\n\twhile(1){\n\t\tg=-10000.0;c=0.0;v=0.0;\n\t\tscanf(\"%d\",&a);\n\t\tif(a==0) break;\n\t\td=a-1;\n\t\tfor(i=0;i<a;i++){\n\t\t\tscanf(\"%lf,%lf\",&f[i][0],&f[i][1]);\n\t\t\tcc[i]=0;\n\t\t\tif(g<f[i][0]){\n\t\t\t\tg=f[i][0]; h=f[i][1];\n\t\t\t\tz=g-1001.0; x=h;\n\t\t\t\ts=i;\n\t\t\t}\n\t\t}\n\t\tss=-1;\n\t\tcc[s]=1;\n\t\tq=g;\n\t\tw=h;\n\t\twhile(1){\n\t\t\tsss=s;\n\t\t\tfor(i=0;i<a;i++){\n\t\t\t\tif(sss!=i&&ss!=i){\n\t\t\t\t\tc=(((g-z)*(g-f[i][0])+(h-x)*(h-f[i][1]))/(sqrt((g-z)*(g-z)+(g-f[i][0])*(g-f[i][0]))*sqrt((h-x)*(h-x)+(h-f[i][1])*(h-f[i][1]))));\n\t\t\t\t\tc=acos(c);\n\t\t\t\t\tif(v<c){\n\t\t\t\t\t\tv=c;\n\t\t\t\t\t\ts=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(v==c){\n\t\t\t\t\t\tif(f[i][0]-g<0) zz=-1;\n\t\t\t\t\t\telse zz=1;\n\t\t\t\t\t\tif(f[s][0]-g<0) xx=-1;\n\t\t\t\t\t\telse xx=1;\n\t\t\t\t\t\tif((f[i][0]-g)*zz<(f[s][0]-g)*xx) s=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tss=sss;\n\t\t\tcc[s]=1;\n\t\t\tz=g; x=h;\n\t\t\tg=f[s][0]; h=f[s][1];\n\t\t\tlo=s;\n\t\t\td--;\n\t\t\tif(d==0) break;\n\t\t\tif(g==q&&h==w) break;\n\t\t\tv=0.0;\n\t\t\tc=0.0;\n\t\t}\n\t\tprintf(\"%d\\n\",d);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define Eps (1e-10)\n\nint N;\nbool flag[102];\ndouble x[102],y[102];\n\nint main() {\n  while (scanf(\"%d\",&N),N) {\n    rep(i,N) scanf(\"%lf,%lf\",x+i,y+i);\n    fill(flag, flag + N, false);\n    //rep(i,N) printf(\"%lf,%lf\\n\",x[i],y[i]);\n    for (int i = 0; i < N; ++i) {\n      for (int j = i+1; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n          for (int l = 0; l < N; ++l) {\n            if (i == l || j == l || k == l) continue;\n            if (flag[l]) continue;\n            double S, subS[3], subSum = 0;\n            S = fabs((x[i]*y[j] + x[j]*y[k] + x[k]*y[i] -\n                      y[i]*x[j] - y[j]*x[k] - y[k]*x[i]) / 2);\n            subS[0] = fabs((x[l]*y[j] + x[j]*y[k] + x[k]*y[l] -\n                            y[l]*x[j] - y[j]*x[k] - y[k]*x[l]) / 2);\n            subS[1] = fabs((x[i]*y[l] + x[l]*y[k] + x[k]*y[i] -\n                            y[i]*x[l] - y[l]*x[k] - y[k]*x[i]) / 2);\n            subS[2] = fabs((x[i]*y[j] + x[j]*y[l] + x[l]*y[i] -\n                            y[i]*x[j] - y[j]*x[l] - y[l]*x[i]) / 2);\n            rep(ii,3) subSum += subS[ii];\n            if (fabs(S-subSum) < Eps) {\n              //printf(\"(%d,%d,%d) : %d | %.3lf %.3lf\\n\", i,j,k,l,S,subSum);\n              flag[l] = true;\n            }\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\",count(flag, flag+N, true));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x, y;\n  int n;\n  bool operator < (const Point &s)const{\n    if(x==s.x) return y<s.y;\n    else return x<s.x;\n  }\n};\n\nmain(){\n  int n;\n  Point in[100];\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    for(int i=0;i<n;i++){\n      scanf(\"%lf,%lf\", &in[i].x, &in[i].y);\n    }\n    sort(in, in+n);\n    for(int i=0;i<n;i++) in[i].n=i;\n    vector<Point> data;\n    Point p, q, r;\n    data.push_back(in[0]);\n    data.push_back(in[1]);\n    for(int i=2;i<n;i++){\n      while(1){\n\tif(i>=n) break;\n\tp=data[data.size()-2];\n\tq=data[data.size()-1];\n\tr=in[i];\n\tif((q.x-p.x)*(r.y-q.y)-(q.y-p.y)*(r.x-q.x)<=0){\n\t  data.push_back(r);\n\t  break;\n\t}else{\n\t  data.pop_back();\n\t  if(data.size()<2){\n\t    data.push_back(r);\n\t    i++;\n\t  }\n\t}\n      }\n    }\n    bool use[100];\n    for(int i=0;i<n;i++) use[i]=false;\n    vector<Point>::iterator ite=data.begin();\n    for(;ite!=data.end();ite++){\n      use[(*ite).n]=true;\n    }\n    data.clear();\n    data.push_back(in[n-1]);\n    data.push_back(in[n-2]);\n    for(int i=n-3;i>=0;i--){\n      while(1){\n\tif(i<0) break;\n\tp=data[data.size()-2];\n\tq=data[data.size()-1];\n\tr=in[i];\n\tif((q.x-p.x)*(r.y-q.y)-(q.y-p.y)*(r.x-q.x)<=0){\n\t  data.push_back(r);\n\t  break;\n\t}else{\n\t  data.pop_back();\n\t  if(data.size()<2){\n\t    data.push_back(r);\n\t    i--;\n\t  }\n\t}\n      }\n    }\n    ite=data.begin();\n    for(;ite!=data.end();ite++) use[(*ite).n]=true;\n    int ans=0;\n    for(int i=0;i<n;i++){\n      if(!use[i]) ans++;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <sstream>\n#include <fstream>\n#include <tuple>\n#include <set>\n#include <functional> \n#include <string.h>\n\n#define X first\n#define Y second\n#define MP make_pair\n#define MT make_tuple\n#define FOR(i, n) for(int (i) = 0; (i) < (n); (i)++)\n#define REP(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\ntypedef long long ll;\ntypedef std::pair<int, int> pii;\ntypedef std::pair<ll, ll > pll;\nusing namespace std;\nconst int MAX = 101;\nconst double PI = 3.1415926535897932384;\n\ntemplate<class T, class U>\nvoid convert(T &t, U &u){\n\tstringstream ss;\n\tss << t;\n\tss >> u;\n}\n\ndouble cross(pair<double, double> &a, pair<double, double> &b, pair<double, double> &o){\n\treturn (a.first - o.first) * (b.second - o.second) - (b.first - o.first) * (a.second - o.second);\n}\n\nint main(){\n\tint n;\n\twhile (cin >> n && n != 0){\n\t\tvector<pair<double, double> > tb;\n\t\tFOR(i, n){\n\t\t\tchar c;\n\t\t\tdouble x, y; \n\t\t\tcin >> x >> c >> y;\n\t\t\ttb.push_back(MP(x, y));\n\t\t}\n\t\tsort(tb.begin(), tb.end());\n\n\t\tvector<pair<double, double> > ans(n * 2, MP(0, 0));\n\t\tint k = 0; //使ってる三点\n\t\t//常に2点目が使えるかどうかを判定してる\n\t\t//3点が凹になってる場合は、答えに入れた2点目を外して、次の3点を選択し直す\n\t\tfor (int i = 0; i < tb.size(); ans[k++] = tb[i++]){\n\t\t\twhile (k >= 2 && cross(ans[k - 2], ans[k - 1], tb[i]) <= 0){ k--; }\n\t\t}\n\n\t\tfor (int i = n - 2; i >= 0; ans[k++] = tb[i--]){\n\t\t\twhile (k >= 2 && cross(ans[k - 2], ans[k - 1], tb[i]) <= 0){ k--; }\n\t\t}\n\n\t\tans.resize(k - 1);\n\t\tcout << n - ans.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string.h>\n#define P pair<double,double>\nusing namespace std;\ndouble EPS=1e-10;\ndouble add(double a, double b)\n{\n\tif(abs(a+b)<EPS*(abs(a)+abs(b))) return 0;\n\treturn a+b;\n}\nbool cmp_x(const P& p, const P& q)\n{\n\tif(p.first !=q.first) return p.first<q.first;\n\treturn p.second>q.second;\n}\nP p[100];\nvector<P> v;\nvector<int> num;\nint n;\nbool used[100];\nvoid make_convex(int l,int r)\n{\n\tfor(int i=l ;(r>l ? i<r : i>=r);(r>l ? i++ : i--))\n\t{\n\t\tif(used[i]) continue;\n\t\tfor(bool loop=true;loop; )\n\t\t{\n\t\t\tloop=false;\n\t\t\tif(v.size()<2) {v.push_back(p[i]),num.push_back(i),used[i]=true; continue;}\n\t\t\tif(v.size()==2)\n\t\t\t{\n\t\t\t\tdouble vx[2],vy[2];\n\t\t\t\tvx[0]=v[1].first-v[0].first;\n\t\t\t\tvy[0]=v[1].second-v[0].second;\n\t\t\t\tvx[1]=p[i].first-v[1].first;\n\t\t\t\tvy[1]=p[i].second-v[1].second;\n\t\t\t\tif(add(vx[0]*vy[1],-vx[1]*vy[0])<=0) v.push_back(p[i]),num.push_back(i),used[i]=true;\n\t\t\t\telse used[num[1]]=false,num.pop_back(),v.pop_back(),loop=true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble vx[3],vy[3]; int len=v.size();\n\t\t\tvx[0]=v[len-2].first-v[len-3].first;\n\t\t\tvy[0]=v[len-2].second-v[len-3].second;\n\t\t\tvx[1]=v[len-1].first-v[len-2].first;\n\t\t\tvy[1]=v[len-1].second-v[len-2].second;\n\t\t\tvx[2]=p[i].first-v[len-1].first;\n\t\t\tvy[2]=p[i].second-v[len-1].second;\n\t\t\tif(add(vx[1]*vy[2],-vx[2]*vy[1])<=0) v.push_back(p[i]),num.push_back(i),used[i]=true;\n\t\t\telse used[num[len-1]]=false,num.pop_back(),v.pop_back(),loop=true;\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> n; if(!n) break;\n\t\tv.clear(); num.clear(); memset(used,false,sizeof(used));\n\t\tfor(int i=0;i<n;i++) scanf(\"%lf,%lf\",&p[i].first,&p[i].second);\n\t\tsort(p,p+n,cmp_x);\n\t\t//pはxの昇順、yの降順。時計回りで見ること\n\t\tmake_convex(0,n);\n\t\tint tmp=v.size(); v.clear(),num.clear(); memset(used,false,sizeof(used));\n\t\tmake_convex(n-1,0);\n\t\tcout << n-(tmp+v.size()-2) << '\\n' ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <list>\n#include <algorithm>\n#include <complex>\nusing namespace std;\ndouble PI = 3.141592653589793238462643383279502884L;\nconst double EPS = 1e-10;\ntypedef complex<double> P;\ninline bool eql(double a, double b) { return abs(b - a) < EPS; }\ninline bool eql(P a, P b) { return eql(a.real(), b.real()) && eql (a.imag(), b.imag());}\ninline P unit(P a) { return a/abs(a); }\ninline P o15n(P a) { return a * P(0, 1); }\ninline double dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\ninline bool orthogp(P a, P b) { return eql(dot(a, b), 0.0); }\ninline bool parap(P a, P b) { return eql(cross(a, b), 0.0); }\ninline bool onlinep(P start, P end, P p) { return parap(end - start, p - start); }\ninline bool onsegp(P start, P end, P p) { return abs(p-start)+abs(end-p) < abs(end-start)+EPS; }\ninline double distance(P start, P end, P p) { return abs(cross(end-start, p-start))/abs(end-start); }\ninline double distseg(P start, P end, P p) {\n  if (dot(end-start, p-start) < EPS) return abs(p-start);\n  else if (dot(start-end, p-end) < EPS) return abs(p-end);\n  else return distance(start, end, p);\n}\ninline bool leftp(P start, P end, P p) { return cross(end-start, p-start) < EPS; }\ninline bool rightp(P start, P end, P p) { return leftp(end, start, p); }\ninline bool intersectp(P as, P ae, P bs, P be) {\n  return (leftp(as, ae, bs) && rightp(as, ae, be))\n         || (leftp(as, ae, be) && rightp(as, ae, bs));\n}\ninline bool intersectporig(P as, P ae, P bs, P be) {\n  return (cross(ae-as, bs-as)*cross(ae-as, be-as) < EPS)\n         && (cross(be-bs, as-bs)*cross(be-bs, ae-bs) < EPS);\n}\ninline P intersection(P as, P ae, P bs, P be) {\n  double das = distance(bs, be, as);\n  double dae = distance(bs, be, ae);\n  return as + (ae-as)*dae/(das+dae);\n}\ntypedef vector<int> vi;\nconst int INF = 1e9+7;\n#define all(c) (c).begin(), (c).end()\n#define tr(c, i) for(auto i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for(auto i=0;i<(n);i++)\n#define pb push_back\n#define sz(c) int((c).size())\n\ntypedef vector<P> vp;\nvp v;\n\nint EnclosePins()\n{\n  int outside = 0;\n  for (int i = 0; i < sz(v); i++) {\n    for (int j = 0; j < sz(v); j++) {\n      if (i == j)\n        continue;\n      bool flag = true;\n      for (int k = 0; k < sz(v); k++) {\n        if (i == k || j == k)\n          continue;\n        flag = flag && leftp(v[i], v[j], v[k]);\n        if (!flag)\n          break;\n      }\n      if (flag) {\n        outside++;\n        break;\n      }\n    }\n  }\n  return sz(v) - outside;\n}\n\nint main(int argc, char **argv)\n{\n  int n;\n  double x, y;\n  char c;\n\n  for (;;) {\n    cin >> n;\n    if (!n)\n      break;\n    v.clear();\n    for (int i = 0; i < n; i++) {\n      cin >> x >> c >> y;\n      v.pb(P(x, y));\n    }\n    cout << EnclosePins() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nEnclose Pins with a Rubber Band(https://onlinejudge.u-aizu.ac.jp/problems/0068)\n前\n\n*/\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putln(x) cout << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef pair<double, double> dP;\ntypedef complex<double> comp;\ntypedef vector <int> vec;\ntypedef vector <ll> vecll;\ntypedef vector <double> vecd;\ntypedef vector <vec> mat;\ntypedef vector <vecll> matll;\ntypedef vector <vecd> matd;\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nconst int MAX = 200000;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst ll INFL = 1e18;\nconst int MOD = 1000000007;\n\nint dx4[4]={1,0,-1,0};\nint dy4[4]={0,1,0,-1};\nint dx8[8]={1,0,-1,1,-1,1,0,-1};\nint dy8[8]={1,1,1,0,0,-1,-1,-1};\n\n//********************************template END****************************************//\n\n//外積を計算する関数\ndouble gaiseki(comp a, comp b)\n{\n\treturn (conj(a)*b).imag();\n}\n\n//凸包\n\nvoid solve(void){\n\n\tint N; char c;\n\twhile (cin >> N && N) {\n\n\t\tvector <dP> pps(N);\n\n\t\trep(N, i)\n\t\t{\n\t\t\tcin >> pps[i].fst >> c >> pps[i].snd;\n\t\t}\n\n\t\tsort(all(pps));\n\n\t\tint k = 0;\n\n\t\tvector <comp> ps(N), qs(2*N);\n\n\t\trep(N, i)\n\t\t{\n\t\t\tps[i] = comp(pps[i].fst, pps[i].snd);\n\t\t}\n\n\t\t//上側\n\t\trep(N, i)\n\t\t{\n\t\t\twhile(k > 1 && gaiseki(qs[k-1] - qs[k-2], ps[i]-qs[k-1]) <= 0)\n\t\t\t{\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\n\t\tint t = k;\n\n\t\t//下側\n\t\trepr(N-1, i)\n\t\t{\n\t\t\twhile(k > t && gaiseki(qs[k-1] - qs[k-2], ps[i]-qs[k-1]) <= 0)\n\t\t\t{\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\n\t\tcout << N-k+1 << endl;\n\n\n\t}\n\n\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef long long int lli;\nconst double EPS = 1e-10;\ntemplate<class T>\nbool eq(const T& a, const T& b) {return abs(a - b) < EPS;}\n\ntypedef  complex<double> point;\n// sort/unique用、setではうまく動かないので使うべからず\nnamespace std {\n\tbool operator==(const point &a, const point &b){\n\t\treturn eq(a, b);\n\t}\n\tbool operator<(const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;  // counter clockwise\n\tif (cross(b, c) < 0)   return -1;  // clockwise\n\tif (dot(b, c) < 0)     return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;  // a--c--b on line or a----bc\n}\n\n\n//点集合 ps に対してその凸包を求める．\n//O(n log n)\nvector<point> convex_hull(vector<point> ps) {\n  int n=ps.size(), k=0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i=0; i < n; ch[k++]=ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i=n-2, t=k+1; i >= 0; ch[k++]=ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\nint main()\n{\n  int n;\n  for(;cin>>n,n;)\n    {\n      vector<point> a;\n      for(int i=0;i<n;i++)\n\t{\n\t  double x,y;\n\t  char aa;\n\t  cin>>x>>aa>>y;\n\t  a.push_back(point(x,y));\n\t}\n      cout<<n-convex_hull(a).size()<<endl;\n    }\n\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\n-- import qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Fixed\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\n--import Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\nimport Text.Printf\n-- import System.IO.Unsafe\n \n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ntjoin :: (Show a, Show b) => (a, b) -> String\ntjoin (x, y) = show x ++ (' ' : show y)\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\nibsearch :: (Int -> Bool) -> (Int,Int) -> Int\nibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))\nwhenM :: Monad m => m Bool -> m () -> m ()\nwhenM c a = c >>= flip when a\nunconsU :: [a] -> (a, [a])\nunconsU (x:xs) = (x, xs)\n-- templete\n\nf ps = firstP : sub firstP 0\n  where\n    sub p a = let np = nextP p a in if np==firstP then [] else np : sub np (angleFrom p np)\n    firstP = minimumBy (comparing snd <> flip (comparing fst)) ps\n    nextP p a = minimumBy (comparing (flip mod' (2*pi) . subtract a . angleFrom p)) (delete p ps)\n    angleFrom (x0,y0) (x,y) = atan2 (y-y0) (x-x0)\n\nmain = do\n    n <- getInt\n    unless (n==0) $ map (apply2 (,) . map readDouble . wordsBy (==',')) <$> replicateM n getLine >>= print . (n-) . length . f >> main\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . enclose_pins . map read') . splitBy ((==1).length) . lines\n where read' str = let [x,y] = map read (splitOn ',' str) in (x,y)\n\nenclose_pins pins = length pins - length sides\n where sides = [(p1,p2)| p1<-pins, p2<-pins, p1<p2, are_counterparts p1 p2 (pins\\\\[p1,p2])]\n\nare_counterparts (x1,y1) (x2,y2) xys =\n alleq $ filter (/= EQ) $ map (\\(x,y) -> compare y (x * slope (x1,y1) (x2,y2) + intercept_y)) xys\n  where\n   alleq xs = and $ zipWith (==) xs (tail xs)\n   intercept_y = snd $ intercept (x1,y1) (x2,y2)\n  \nslope (x1,y1) (x2,y2)\n | x2 == x1  = (y2-y1) / 1e-9\n | otherwise = (y2-y1) / (x2-x1)\n\nintercept (x1,y1) (x2,y2) = (axis_x, axis_y)\n where\n  axis_x = x1 - y1 / slope (x1,y1) (x2,y2)\n  axis_y = y1 - x1 * slope (x1,y1) (x2,y2)\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)\n\nsplitBy p xs\n | null xs = []\n | p (head xs) = splitBy p (tail xs)\n | otherwise = (takeWhile (not.p) xs : splitBy p (dropWhile (not.p) xs))"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.Monoid\nimport Data.List\nimport Data.List.Split\nimport Data.Ord\nimport Data.Fixed\n \n\napply2 f [x,y] = f x y\n\nf ps = firstP : sub firstP 0\n  where\n    sub p a = let np = nextP p a in if np==firstP then [] else np : sub np (angleFrom p np)\n    firstP = minimumBy (comparing snd <> flip (comparing fst)) ps\n    nextP p a = minimumBy (comparing (flip mod' (2*pi) . subtract a . angleFrom p)) (delete p ps)\n    angleFrom (x0,y0) (x,y) = atan2 (y-y0) (x-x0)\n\nmain = do\n    n <- readLn\n    unless (n==0) $ map (apply2 (,) . map read . wordsBy (==',')) <$> replicateM n getLine >>= print . (n-) . length . f >> main\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . enclose_pins . map read') . parse' . lines\n where\n  parse' = splitBy ((==1).length) . takeWhile (/= \"0\")\n  read' str = let [x,y] = map read (splitOn ',' str) in (x,y)\n\nenclose_pins pins = length pins - length sides\n where sides = [(p1,p2)| p1<-pins, p2<-pins, p1<p2, are_counterparts p1 p2 (pins\\\\[p1,p2])]\n\nare_counterparts (x1,y1) (x2,y2) xys =\n alleq $ filter (/= EQ) $ map (\\(x,y) -> compare y (x * slope (x1,y1) (x2,y2) + intercept_y)) xys\n  where\n   alleq xs = and $ zipWith (==) xs (tail xs)\n   intercept_y = snd $ intercept (x1,y1) (x2,y2)\n  \nslope (x1,y1) (x2,y2)\n | x2 == x1  = (y2-y1) / 1e-9\n | otherwise = (y2-y1) / (x2-x1)\n\nintercept (x1,y1) (x2,y2) = (axis_x, axis_y)\n where\n  axis_x = x1 - y1 / slope (x1,y1) (x2,y2)\n  axis_y = y1 - x1 * slope (x1,y1) (x2,y2)\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)\n\nsplitBy p xs\n | null xs = []\n | p (head xs) = splitBy p (tail xs)\n | otherwise = (takeWhile (not.p) xs : splitBy p (dropWhile (not.p) xs))"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . enclose_pins . map read') . parse' . lines\n where\n  parse' = splitBy (notElem ',') . takeWhile (/= \"0\")\n  read' str = let [x,y] = map read (splitOn ',' str) in (x,y)\n\nenclose_pins pins = length pins - length sides\n where sides = [(p1,p2)| p1<-pins, p2<-pins, p1<p2, are_counterparts p1 p2 (pins\\\\[p1,p2])]\n\nare_counterparts (x1,y1) (x2,y2) xys =\n alleq $ filter (/= EQ) $ map (\\(x,y) -> compare y (x * slope (x1,y1) (x2,y2) + intercept_y)) xys\n  where\n   alleq xs = and $ zipWith (==) xs (tail xs)\n   intercept_y = snd $ intercept (x1,y1) (x2,y2)\n  \nslope (x1,y1) (x2,y2)\n | x2 == x1  = (y2-y1) / 1e-9\n | otherwise = (y2-y1) / (x2-x1)\n\nintercept (x1,y1) (x2,y2) = (axis_x, axis_y)\n where\n  axis_x = x1 - y1 / slope (x1,y1) (x2,y2)\n  axis_y = y1 - x1 * slope (x1,y1) (x2,y2)\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)\n\nsplitBy p xs\n | null xs = []\n | p (head xs) = splitBy p (tail xs)\n | otherwise = (takeWhile (not.p) xs : splitBy p (dropWhile (not.p) xs))"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\n-- import qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Fixed\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\n--import Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\nimport Text.Printf\n-- import System.IO.Unsafe\n \n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ntjoin :: (Show a, Show b) => (a, b) -> String\ntjoin (x, y) = show x ++ (' ' : show y)\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\nibsearch :: (Int -> Bool) -> (Int,Int) -> Int\nibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))\nwhenM :: Monad m => m Bool -> m () -> m ()\nwhenM c a = c >>= flip when a\nunconsU :: [a] -> (a, [a])\nunconsU (x:xs) = (x, xs)\n-- templete\n\nf :: [(Double,Double)] -> [(Double,Double)]\nf ps = firstP : sub firstP 0\n  where\n    sub p a = let np = nextP p a in if np==firstP then [] else np : sub np (angle $ diff p np)\n    firstP = minimumBy (comparing snd <> flip (comparing fst)) ps\n    nextP p a = minimumBy (comparing (da a . angle . diff p)) (delete p ps)\n    diff (x1,y1) (x,y) = (x-x1,y-y1)\n    angle (x,y) = atan2 y x\n    da a na = mod' (na - a) (2*pi)\n\nmain = do\n    n <- getInt\n    unless (n==0) $ do\n        ps <- map (apply2 (,) . map readDouble . wordsBy (==',')) <$> replicateM n getLine\n        print $ n - length (f ps)\n        main\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>))\nimport Control.Monad\nimport Data.List\nimport Data.List.Split (splitOn)\n\nmain :: IO ()\nmain = do\n  n <- getl toInt\n  when (n /= 0) $ do\n    xs <- rgetl n $ (\\[x,y] -> Point x y) . map toDbl . splitOn \",\"\n    print $ solve xs\n    main\n\nsolve :: [Point] -> Int\nsolve ps = length ps - length ups - length lps + 2\n  where\n    sps = sort ps\n    ups = hch sps\n    lps = (hch . reverse) sps\n\nisConvex :: Point -> Point -> Point -> Bool\nisConvex p0 p1 p2 = cross v0 v1 < 0.0\n  where\n    v0 = toVect p0 p1\n    v1 = toVect p0 p2\n\nch :: [Point] -> [Point]\nch ps\n  | length ps < 3 = ps\n  | isConvex p0 p1 p2 = ps\n  | otherwise = ch (p2:p0:rs)\n  where\n    (p2:p1:p0:rs) = ps\n    \nhch :: [Point] -> [Point]\nhch ps = foldl f [] ps\n  where\n    f xs p = ch (p:xs)\n    \ntoInt :: String -> Int\ntoInt s = read s\n\ntoDbl :: String -> Double\ntoDbl s = read s\n\ngetl :: (String -> a) -> IO a\ngetl f = f <$> getLine\n\nrgetl :: Int -> (String -> a) -> IO [a]\nrgetl n f = map f <$> replicateM n getLine\n\neps :: Double\neps = 1e-9\n \ndata Point = Point {xop :: Double, yop :: Double} deriving Show\ndata Vect = Vect {xov :: Double, yov :: Double} deriving Show\n\ncross :: Vect -> Vect -> Double\ncross v1 v2 = xov v1 * yov v2 - yov v1 * xov v2\n \ntoVect :: Point -> Point -> Vect\ntoVect p1 p2 = Vect (xop p2 - xop p1) (yop p2 - yop p1)\n\ninstance Eq Point where\n  x == y = abs (xop x - xop y) < eps && abs (xop x - xop y) < eps\n\ninstance Ord Point where\n  compare x y \n    | abs (xop x - xop y) < eps && abs (yop x - yop y) < eps = EQ\n    | xop x < xop y = LT\n    | xop x > xop y = GT\n    | abs (xop x - xop y) < eps && yop x < yop y = LT\n    | abs (xop x - xop y) < eps && yop x > yop y = GT"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . enclose_pins . map read') . splitBy ((==1).length) . lines\n where read' str = let [x,y] = map read (splitOn ',' str) in (x,y)\n\nenclose_pins pins = length pins - length sides\n where sides = [(p1,p2)| p1<-pins, p2<-pins, p1<p2, are_counterparts p1 p2 (pins\\\\[p1,p2])]\n\nare_counterparts (x1,y1) (x2,y2) xys\n | x1 == x2  = alleq $ filter (/= EQ) $ map (\\(x,y) -> compare x x1) xys\n | otherwise = alleq $ filter (/= EQ) $ map (\\(x,y) -> compare y (x * slope (x1,y1) (x2,y2) + intercept_y)) xys\n    where\n     alleq xs = and $ zipWith (==) xs (tail xs)\n     intercept_y = snd $ intercept (x1,y1) (x2,y2)\n  \nslope (x1,y1) (x2,y2) = (y2-y1)/(x2-x1)\nintercept (x1,y1) (x2,y2) = (axis_x, axis_y)\n where\n  axis_x = x1 - y1 / slope (x1,y1) (x2,y2)\n  axis_y = y1 - x1 * slope (x1,y1) (x2,y2)\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)\n\nsplitBy p xs\n | null xs = []\n | p (head xs) = splitBy p (tail xs)\n | otherwise = (takeWhile (not.p) xs : splitBy p (dropWhile (not.p) xs))"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,key;}w;w p[101],bs;i,m,v[100],n,j;z(w*c,w*d){return c->key>d->key?-1:c->key<d->key;}double outer(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(){double k,t;for(;~scanf(\"%d\",&n),n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;bs=p[m];p[m]=*p;*p=bs;p[100].x=bs.x;p[100].y=bs.y+1;for(i=1;i<n;i++){k=outer(0,i,100);t=(p[i].x-bs.x)*(p[i].x-bs.x)+(p[i].y-bs.y)*(p[i].y-bs.y);k*=k/t;if(bs.x>p[i].x)k=-k;p[i].key=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;outer(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ndouble x[100],y[100];\n\ndouble len(int a,int b){\n  return  sqrt( (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]) );\n}\n\ndouble flon(int a,int b,int c){\n  double s;\n  double la,lb,lc;\n  la = len(b,c);\n  lb = len(a,c);\n  lc = len(a,b);\n  s = (la+lb+lc)/2.0;\n  return sqrt(s*(s-la)*(s-lb)*(s-lc));\n}\n  \nint inter(int x,int a,int b,int c){\n  if(flon(a,b,x)+flon(a,c,x)+flon(b,c,x) > flon(a,b,c))return 0;\n  else return 1;\n}\n\nint band(int i,int j,int k,int l){\n  if(inter(i,j,k,l))return 1;\n  return 0;\n}\n  \n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int tmp;\n  int unuse[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&x[i],&y[i]);\n      unuse[i] = 0;\n    }\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n-2;j++){\n\tif(j==i)continue;\n\tfor(k=j+1;k<n-1;k++){\n\t  if(k==i)continue;\n\t  for(l=k+1;l<n;l++){\n\t    if(l==i)continue;\n\t    if(band(i,j,k,l)){\n\t      unuse[i] = 1;\n\t      break;\n\t    }\n\t  }\n\t  if(unuse[i])break;\n\t}\n\tif(unuse[i])break;\n      }\n    }\n      \n    tmp = 0;\n    for(i=0;i<n;i++){\n      if(unuse[i])tmp++;\n    }\n      \n    printf(\"%d\\n\",tmp);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint cross(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){\n\tint r;\n\tr=((x1-x2)*(y3-y1)+(y1-y2)*(x1-x3))*((x1-x2)*(y4-y1)+(y1-y2)*(x1-x4))<0;\n\treturn r;\n}\nint InTri(double x1,double y1,double x2,double y2,double x3,double y3,double x,double y){\n\tint r;\n\tr=\n\t\t!cross(x1,y1,x2,y2,x,y,x3,y3) &&\n\t\t!cross(x2,y2,x3,y3,x,y,x1,y1) &&\n\t\t!cross(x3,y3,x1,y1,x,y,x2,y2);\n\treturn r;\n}\nint main(){\n\tint n,c,i,j,k,l;\n\tdouble x[100],y[100];\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%lf,%lf\",x+i,y+i);\n\t\tc=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\t\tfor(l=0;l<n;l++){\n\t\t\t\t\t\tif(l==i||l==j||l<=k)continue;\n\t\t\t\t\t\t//printf(\"triangle(%d,%d,%d) p(%d)\\n\",j,k,l,i);\n\t\t\t\t\t\tif(InTri(x[j],y[j],x[k],y[k],x[l],y[l],x[i],y[i])){\n\t\t\t\t\t\t\t//printf(\"%d in poly\\n\",i);\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\tgoto nextp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnextp:;\n\t\t}\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n\n#define INT(X) \\\n  ( *( (const int *)(X) ) )\n\nstatic int\ncompare (\n  const void  * a,\n  const void  * b\n  )\n{\n  return ( INT( b ) - INT( a ) );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  struct Point\n  {\n    double x;\n    double y;\n  }   d[ 128 ];\n  int i;\n\n  for ( ; ; )\n  {\n    double ul, ll;\n    int lc = 0;\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( !( n ) ) break ;\n\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \" %lf,%lf\", &d[ i ].x, &d[ i ].y );\n    }\n    qsort ( d, n, sizeof ( struct Point ), compare );\n\n    ul = ll\n       = d->y;\n    d->y = DBL_MAX; ++lc;\n    for ( i = 1; i < n - 1; ++i )\n    {\n      if ( d[ i ].y > ul )\n      {\n        ul = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n      if ( d[ i ].y > ll )\n      {\n        ll = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n    }\n\n    ul = ll\n       = d[n - 1 ].y;\n    d[ n - 1 ].y = DBL_MAX; ++lc;\n    for ( i = n - 1; i > 0; --i )\n    {\n      if ( d[ i ].y == DBL_MAX )  continue ;\n\n      if ( d[ i ].y > ul )\n      {\n        ul = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n      if ( d[ i ].y > ll )\n      {\n        ll = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n    }\n\n    printf ( \"%d\\n\", n - lc );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\ndouble point[100][3];\nint check(int i,int j,int k,int n) {\n\tdouble x1,x2,x3,y1,y2,y3,xp,yp,ax,ay,bx,by,cx,cy,a,b;\n\tint x,ans;\n\n\tx1=point[i][0];y1=point[i][1];\n\tx2=point[j][0];y2=point[j][1];\n\tx3=point[k][0];y3=point[k][1];\n\tax=x2-x1; ay=y2-y1;\n\tbx=x3-x1; by=y3-y1;\n\tans=0;\n\n\tfor(x=0;x<n;x++){\n\t\tif(point[x][2]<1 || x==i || x==j || x==k)continue;\n\t\txp=point[x][0];yp=point[x][1];\n\t\tcx=xp-x1; cy=yp-y1;\n\t\tif(by!=0){\n\t\t\ta=(cx*by-cy*bx)/(ax*by-ay*bx);\n\t\t\tb=(cy-a*ay)/by;\n\t\t}\n\t\telse{\n\t\t\ta=cy/ay;\n\t\t\tb=(cx-a*ax)/bx;\n\t\t}\n\t\tif(a>=0 && b>=0 && a+b<=1){ans++;point[x][2]=0;}\n\t}\n\n\treturn ans;\n}\nint main(void){\n\tint i,j,k,n,ans;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tif(n==0)break;\n\t\tans=0;\n\t\tfor(i=0;i<n;i++){scanf(\"%lf,%lf\",&point[i][0],&point[i][1]);point[i][2]=1;}\n\n\t\tfor(i=0;i<n-2;i++){if(point[i][2]<1)continue;\n\t\tfor(j=i+1;j<n-1;j++){if(point[j][2]<1)continue;\n\t\tfor(k=j+1;k<n;k++){if(point[k][2]<1)continue;\n\t\tans+=check(i,j,k,n);\n\t\t}\n\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint main(){\n  int n,i,mi,mj,c;\n  double max,m,ax,ay,by,bx,x[100],y[100];\n  while(scanf(\"%d\",&n),n){\n    int f[100]={0};\n    ay=1;\n    ax=max=0;\n    for(i=0;i<n;i++){\n      scanf(\"%lf,%lf\",&x[i],&y[i]);\n      if(max<x[i])max=x[mi=i];\n    }\n    for(c=0;f[mi]==0;c++){//printf(\"%d\\n\",mi);\n      f[mi]=1;\n      for(i=max=0;i<n;i++){\n\tif(mi==i)continue;\n\tbx=x[i]-x[mi];\n\tby=y[i]-y[mi];\n\tm=(ax*bx+ay*by)/(hypot(ay,ax)*hypot(bx,by));\n\tif(ax*by>ay*bx)m+=2;\n\telse m*=-1;\n\tif(max<m){\n\t  max=m;\n\t  mj=i;\n\t}\n      }\n      ax=x[mj]-x[mi];\n      ay=y[mj]-y[mi];\n      mi=mj;\n    }\n    printf(\"%d\\n\",n-c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[101],b;m,v[100],n,j,r;z(w*c,w*d){r=c->k>d->k?-1:1;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++)p[i].k=o(0,i,100)/hypot(p[i].x-b.x,p[i].y-b.y);qsort(p+1,n-1,24,z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;double k,t;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:1;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++)p[i].k=o(0,i,100)/hypot(p[i].x-b.x,p[i].y-b.y);qsort(p+1,n-1,24,z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x,y;\n} xy_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst xy_t* a=(const xy_t*)x;\n\tconst xy_t* b=(const xy_t*)y;\n\tif((a->x)>(b->x))return 1;\n\tif((a->x)<(b->x))return -1;\n\tif((a->y)>(b->y))return 1;\n\tif((a->y)<(b->y))return -1;\n\treturn 0;\n}\n\nint zahyou_num;\nxy_t zahyou[100];\n\nint th_up_n;\nint th_down_n;\nxy_t th_up[100];\nxy_t th_down[100];\n\nint main(void) {\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d\",&zahyou_num);\n\t\tif(zahyou_num==0)break;\n\t\tfor(i=0;i<zahyou_num;i++) {\n\t\t\tscanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y);\n\t\t}\n\t\tqsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp);\n\t\t//sita no totu-ho\n\t\tth_down_n=1;\n\t\tth_down[0].x=zahyou[0].x;\n\t\tth_down[0].y=zahyou[0].y;\n\t\tfor(i=1;i<zahyou_num;i++) {\n\t\t\t//if(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\twhile(th_down_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_down[th_down_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_down[th_down_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_down[th_down_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_down[th_down_n-1].x==th_down[th_down_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_down[th_down_n-1].y<th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_down[th_down_n-1].y-th_down[th_down_n-2].y)/\n\t\t\t\t\t\t   (th_down[th_down_n-1].x-th_down[th_down_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_down_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_down[th_down_n].x=zahyou[i].x;\n\t\t\tth_down[th_down_n].y=zahyou[i].y;\n\t\t\tth_down_n++;\n\t\t}\n\t\t//ue no totu-ho\n\t\tth_up_n=1;\n\t\tth_up[0].x=zahyou[zahyou_num-1].x;\n\t\tth_up[0].y=zahyou[zahyou_num-1].y;\n\t\tfor(i=zahyou_num-2;i>=0;i--) {\n\t\t\t//if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\twhile(th_up_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_up[th_up_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_up[th_up_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_up[th_up_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_up[th_up_n-1].x==th_up[th_up_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_up[th_up_n-1].y<th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/\n\t\t\t\t\t\t   (th_up[th_up_n-1].x-th_up[th_up_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_up_n--;\n\t\t\t\t}\n\t\t\t//}\n\t\t\tth_up[th_up_n].x=zahyou[i].x;\n\t\t\tth_up[th_up_n].y=zahyou[i].y;\n\t\t\tth_up_n++;\n\t\t}\n\t\tprintf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[100],b;m,v[100],n,j,r;z(w*c,w*d){r=c->k>d->k?-1:1;}double o(w q,w r,w s){return q.x*(r.y-s.y)+r.x*(s.y-q.y)+s.x*(q.y-r.y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;for(i=1;i<n;i++)p[i].k=(p[i].x-b.x)/hypot(p[i].x-b.x,p[i].y-b.y);qsort(p+1,n-1,24,z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(p[v[j-1]],p[v[j]],p[i])<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define GRADIENT_MIN (0)\n#define GRADIENT_MAX (1)\n\nint find(size_t n, double list[n][2], double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, m, g;\n\n\tm = copysign(INFINITY, max ? -1.0 : 1.0);\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(list[i][0]) || list[i][0] < p[0])\n\t\t\tcontinue;\n\n\t\tdx = p[0] - list[i][0];\n\t\tdy = p[1] - list[i][1];\n\t\tg = (dx != 0.0) ? (dy / dx) : copysign(INFINITY, -dy);\n\n\t\tif (max ? (m < g) : (m > g)) {\n\t\t\tm = g;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\tp[0] = list[midx][0];\n\tp[1] = list[midx][1];\n\treturn midx;\n}\n\nvoid input(size_t n, double list[n][2], double p0[2], double p1[2]) {\n\tint i, left;\n\n\tp0[0] = 1001.0;\n\tp1[0] = -1001.0;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", list[i], list[i]+1);\n\t\tif (p0[0] > list[i][0]) {\n\t\t\tp0[0] = list[i][0];\n\t\t\tp0[1] = list[i][1];\n\t\t\tleft = i;\n\t\t}\n\t\tif (p1[0] < list[i][0]) {\n\t\t\tp1[0] = list[i][0];\n\t\t\tp1[1] = list[i][1];\n\t\t}\n\t}\n\tlist[left][0] = list[left][1] = NAN;\n}\n\nvoid rm_vertex(size_t n, double list[n][2], double p0[2], double p1[2]) {\n\tint i;\n\tdouble p[2];\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MAX);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MIN);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n}\n\nint solve(size_t n) {\n\tdouble list[n][2], p0[2], p1[2];\n\tint i, count;\n\n\tinput(n, list, p0, p1);\n\trm_vertex(n, list, p0, p1);\n\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (!isnan(list[i][0]))\n\t\t\tcount++;\n\t}\n\treturn count - 1;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[99],b;double f;m,v[99],n,j,r;z(w*c,w*d){r=c->k>d->k?-1:1;}double o(w q,w r,w s){f=q.x*(r.y-s.y)+r.x*(s.y-q.y)+s.x*(q.y-r.y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;for(i=1;i<n;i++)p[i].k=(f=p[i].x-b.x)/hypot(f,p[i].y-b.y);qsort(p+1,n-1,24,z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(p[v[j-1]],p[v[j]],p[i])<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ndouble x[100],y[100];\n\ndouble len(int a,int b){\n  return  sqrt( (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]) );\n}\n\ndouble flon(int a,int b,int c){\n  double s;\n  double la,lb,lc;\n  la = len(b,c);\n  lb = len(a,c);\n  lc = len(a,b);\n  s = (la+lb+lc)/2.0;\n  return sqrt(s*(s-la)*(s-lb)*(s-lc));\n}\n  \nint inter(int x,int a,int b,int c){\n  if(flon(a,b,x)+flon(a,c,x)+flon(b,c,x)-flon(a,b,c)<1e-10)return 1;\n  else return 0;\n}\n\nint band(int i,int j,int k,int l){\n  if(inter(i,j,k,l))return i;\n  if(inter(j,i,k,l))return j;\n  if(inter(k,i,j,l))return k;\n  if(inter(l,i,j,k))return l;\n  return -1;\n}\n  \n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int tmp;\n  int unuse[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&x[i],&y[i]);\n      unuse[i] = 0;\n    }\n\n    for(i=0;i<n-3;i++){\n      for(j=i+1;j<n-2;j++){\n\tfor(k=j+1;k<n-1;k++){\n\t  for(l=k+1;l<n;l++){\n\t    tmp = band(i,j,k,l);\n\t    if(tmp>=0)unuse[tmp] = 1;\n\t  }\n\t}\n      }\n    }\n\n    tmp = 0;\n    for(i=0;i<n;i++){\n      if(unuse[i])tmp++;\n    }\n\n    printf(\"%d\\n\",tmp);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[101],bs;i,m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double outer(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(){double k,t;for(;~scanf(\"%d\",&n),n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;bs=p[m];p[m]=*p;*p=bs;p[100].x=bs.x;p[100].y=bs.y+1;for(i=1;i<n;i++){k=outer(0,i,100);t=(p[i].x-bs.x)*(p[i].x-bs.x)+(p[i].y-bs.y)*(p[i].y-bs.y);k*=k/t;if(bs.x>p[i].x)k=-k;p[i].k=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;outer(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n\n#define INT(X) \\\n  ( *( (const int *)(X) ) )\n\nstatic int\ncompare (\n  const void  * a,\n  const void  * b\n  )\n{\n  return ( INT( b ) - INT( a ) );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  struct Point\n  {\n    double x;\n    double y;\n  }   d[ 128 ];\n  int i;\n\n  for ( ; ; )\n  {\n    double ul, ll;\n    int lc = 0;\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( !( n ) ) break ;\n\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \" %lf,%lf\", &d[ i ].x, &d[ i ].y );\n    }\n    qsort ( d, n, sizeof ( struct Point ), compare );\n\n    ul = ll\n       = d->y;\n    d->y = DBL_MAX; ++lc;\n    for ( i = 1; i < n - 1; ++i )\n    {\n      if ( d[ i ].y >= ul )\n      {\n        ul = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n      else if ( d[ i ].y <= ll )\n      {\n        ll = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n    }\n\n    ul = ll\n       = d[n - 1 ].y;\n    d[ n - 1 ].y = DBL_MAX; ++lc;\n    for ( i = n - 1; i > 0; --i )\n    {\n      if ( d[ i ].y == DBL_MAX )  continue ;\n\n      if ( d[ i ].y >= ul )\n      {\n        ul = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n      else if ( d[ i ].y <= ll )\n      {\n        ll = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n    }\n\n    printf ( \"%d\\n\", n - lc );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define GRADIENT_MIN (0)\n#define GRADIENT_MAX (1)\n\nint find(int n, double list[100][2], double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, m, g;\n\n\tm = copysign(INFINITY, max ? -1.0 : 1.0);\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(list[i][0]) || list[i][0] < p[0])\n\t\t\tcontinue;\n\n\t\tdx = p[0] - list[i][0];\n\t\tdy = p[1] - list[i][1];\n\t\t// runtime error\n\t\tif (fabs(dx) <= 0.0)\n\t\t\tg = copysign(INFINITY, -dy);\n\t\telse\n\t\t\tg = dy / dx; \n\n\t\tif (max ? (m < g) : (m > g)) {\n\t\t\tm = g;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\tp[0] = list[midx][0];\n\tp[1] = list[midx][1];\n\treturn midx;\n}\n\nvoid input(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i, left;\n\n\tp0[0] = 1001.0;\n\tp1[0] = -1001.0;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", list[i], list[i]+1);\n\t\tif (p0[0] > list[i][0]) {\n\t\t\tp0[0] = list[i][0];\n\t\t\tp0[1] = list[i][1];\n\t\t\tleft = i;\n\t\t}\n\t\tif (p1[0] < list[i][0]) {\n\t\t\tp1[0] = list[i][0];\n\t\t\tp1[1] = list[i][1];\n\t\t}\n\t}\n\tlist[left][0] = list[left][1] = NAN;\n}\n\nvoid rm_vertex(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i;\n\tdouble p[2];\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MAX);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MIN);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n}\n\nint solve(int n) {\n\tdouble list[100][2], p0[2], p1[2];\n\tint i, count;\n\n\tinput(n, list, p0, p1);\n\trm_vertex(n, list, p0, p1);\n\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (!isnan(list[i][0]))\n\t\t\tcount++;\n\t}\n\treturn count - 1;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;double k,t;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++)p[i].k=o(0,i,100)/hypot(p[i].x-b.x,p[i].y-b.y);qsort(p+1,n-1,24,z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 100\n\nint isLeft( double xy[ 2 ][ N ], int a, int b, int x ){\n  double x1 = xy[ 0 ][ b ] - xy[ 0 ][ a ];\n  double y1 = xy[ 1 ][ b ] - xy[ 1 ][ a ];\n  double x2 = xy[ 0 ][ x ] - xy[ 0 ][ a ];\n  double y2 = xy[ 1 ][ x ] - xy[ 1 ][ a ];\n\n  return ( x1 * y2 - x2 * y1 > 0 ) ? 1 : 0;\n}\n\nint main( void ){\n  int i, j, k, n;\n  double xy[ 2 ][ N ]; // vertex\n  int mostLeftIndex;\n  int next[ N ]; // edge\n  int cur, count;\n  char hoge;\n\n  while( 1 ){\n    scanf( \"%d\", &n);\n    if( !n ) break;\n\n    for( i = 0; i < n; i++ ){\n      scanf( \"%lf%c%lf\", &xy[ 0 ][ i ], &hoge, &xy[ 1 ][ i ] );\n    }\n\n    for( i = 0; i < n; i++ ){\n      next[ i ] = -1; // null value\n    }\n\n    mostLeftIndex = 0;\n    for( i = 1; i < n; i++ ){\n      if( xy[ 0 ][ mostLeftIndex ] > xy[ 0 ][ i ] )\n        mostLeftIndex = i;\n    }\n\n    i = mostLeftIndex;\n    next[ i ] = (i+1)%n;\n    for( j = 0; j < n; j++ ){\n      if( j == i || j == next[ i ] ) continue;\n\n      if( isLeft( xy, i, next[ i ], j ) ){\n        next[ i ] = j;\n      }\n    }\n    count = 1;\n    i = next[ i ];\n\n    while( i != mostLeftIndex ){\n      next[ i ] = (i+1)%n;\n      for( j = 0; j < n; j++ ){\n        if( j == i || j == next[ i ] ) continue;\n\n        if( isLeft( xy, i, next[ i ], j ) ){\n          next[ i ] = j;\n        }\n      }\n      count++;\n      i = next[ i ];\n    }\n\n    printf( \"%d\\n\", n - count );\n  }\n\n  return( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nc,i,p,P,f;main(n){float x[100],y[100],d,t,T;for(;scanf(\"%d\",&n),n;printf(\"%d\\n\",c)){for(T=2000,i=n;i--;y[i]>T||(T=y[p=f=i]))scanf(\"%f,%f\",x+i,y+i);c=n;d=0;do{T=9;for(i=n;i--;)if(i-p)t=atan2f(y[i]-y[p],x[i]-x[p]),t>d||(t+=2*M_PI),t>T||(T=t,P=i);p=P,d=T,c--;}while(p-f);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint cross(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){\n\tint r;\n\tr=((x1-x2)*(y3-y1)+(y1-y2)*(x1-x3))*((x1-x2)*(y4-y1)+(y1-y2)*(x1-x4))<0;\n\treturn r;\n}\nint InTri(double x1,double y1,double x2,double y2,double x3,double y3,double x,double y){\n\tint r;\n\tr=\n\t\t!cross(x1,y1,x2,y2,x,y,x3,y3) &&\n\t\t!cross(x2,y2,x3,y3,x,y,x1,y1) &&\n\t\t!cross(x3,y3,x1,y1,x,y,x2,y2);\n\treturn r;\n}\nint main(){\n\tint n,c,i,j,k;\n\tdouble x[100],y[100];\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%lf,%lf\",x+i,y+i);\n\t\tc=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=1;j<n-2;j++){\n\t\t\t\tfor(k=j+1;k<n-1;k++){\n\t\t\t\t\tif(InTri(x[(i+j)%n],y[(i+j)%n],x[(i+k)%n],y[(i+k)%n],x[(i+k+1)%n],y[(i+k+1)%n],x[i],y[i])){\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tgoto nextp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnextp:;\n\t\t}\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){double k,t;for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++){k=o(0,i,100);t=(p[i].x-b.x)*(p[i].x-b.x)+(p[i].y-b.y)*(p[i].y-b.y);k*=k/t;if(b.x>p[i].x)k=-k;p[i].k=k;}qsort(p+1,n-1,sizeof(w),z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0068\nTitle Enclose Pins with a Rubber Band\n*/\n#include <stdio.h>\n#include <float.h>\n#include <math.h>\n#include <limits.h>\n#define MAXPOINT 100\n#define PI (3.141592653589793)\n//Global data section\nint n;\ndouble x[MAXPOINT],y[MAXPOINT];\nint flag[MAXPOINT];\n//\nint find_top_left()\n{\n  int i,ret;\n  double xx,yy;\n\n  yy=DBL_MAX;\n  for(i=0;i<n;i++)\n    {\n      if(yy > y[i])\n\t{\n\t  yy=y[i];\n\t  xx=x[i];\n\t  ret=i;\n\t}\n      if(yy == y[i])\n\t{\n\t  if(xx<x[i])\n\t    {\n\t      xx=x[i];\n\t      ret=i;\n\t    }\n\t}\n    }\n  return(ret);\n}\ndouble length(double xx1,double yy1,\n\t\t  double xx2,double yy2)\n{\n  return(sqrt((xx1-xx2)*(xx1-xx2)+(yy1-yy2)*(yy1-yy2)));\n}\ndouble inner_product(double xx1,double yy1,\n\t\t  double xx2,double yy2)\n{\n  return(xx1*xx2+yy1*yy2);\n}\ndouble calc_cos(double xx1,double yy1,\n\t\t  double xx2,double yy2,double xx3,double yy3)\n{\n  double in_p,len1,len2; // inner_product\n  in_p=inner_product(xx1-xx2,yy1-yy2,xx3-xx2,yy3-yy2);\n  len1=length(xx1,yy1,xx2,yy2);\n  len2=length(xx3,yy3,xx2,yy2);\n  return(in_p/len1/len2);\n}\nint find_next_point(mp1,mp2)\n{\n  double xx1,yy1,xx2,yy2,xx3,yy3,mincos,minp,cosx;\n  int i;\n\n  xx1=x[mp1];\n  yy1=y[mp1];\n  xx2=x[mp2];\n  yy2=y[mp2];\n  mincos=1;minp=-1;\n  for(i=0;i<n;i++)\n    {\n      if(flag[i])\n\tcontinue;\n      xx3=x[i];\n      yy3=y[i];\n      cosx=calc_cos(xx1,yy1,xx2,yy2,xx3, yy3);\n#ifdef DEBUG2\n      printf(\"N:%d,COS:%f\\n\",i,cosx);\n#endif\n      if(mincos > cosx)\n\t{\n\t  mincos=cosx;\n\t  minp=i;\n\t}\n    }\n  return(minp);\n}\nint find_2nd(int mp1)\n{\n  double xx1,yy1,xx2,yy2,xx3,yy3,mincos,minp,cosx;\n  int i;\n\n  xx2=x[mp1];\n  yy2=y[mp1];\n  xx1=xx2-1;\n  yy1=yy2;\n  mincos=1;minp=-1;\n  for(i=0;i<n;i++)\n    {\n      if(flag[i])\n\tcontinue;\n      xx3=x[i];\n      yy3=y[i];\n      cosx=calc_cos(xx1,yy1,xx2,yy2,xx3,yy3);\n#ifdef DEBUG2 \n      printf(\"N:%d,COS:%f\\n\",i,cosx);\n#endif\n      if(mincos > cosx)\n\t{\n\t  mincos=cosx;\n\t  minp=i;\n\t}\n    }\n  return(minp);\n}\nprint_point(int np)\n{\n  printf(\"P(%d):%lf,%lf\\n\",np,x[np],y[np]);\n}\nmain()\n{\n  int i,np,nps,np1,np2,np3,pc;\n\n  while(EOF!=scanf(\"%d\",&n) && n)\n    {\n      for(i=0;i<n;i++)\n\tscanf(\"%lf,%lf\",&x[i],&y[i]);\n      for(i=0;i<n;i++)\n\tflag[i]=0;\n\n      pc=2;\n      np1=nps=find_top_left();\n      //flag[np1]=-1;\n#if DEBUG\n      print_point(nps);\n#endif\n      np2=find_2nd(np1);\n      flag[np2]=-1;\n#if DEBUG\n      print_point(np2);\n#endif\n      while(1)\n\t{\n\t  np3=find_next_point(np1,np2);\n\t  flag[np3]=-1;\n\t  if(np3==nps)\n\t    break;\n#if DEBUG\n      print_point(np3);\n#endif\n\t  flag[np3]=-1;\n\t  np1=np2;\n\t  np2=np3;\n\t  pc++;\n\t}\n      printf(\"%d\\n\",n-pc);\n    }\n  \nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n#define sfd(type, fn)   type fn(P a\n#define isfd(type, fn)  inline sfd(type, fn)\n#define fd(type, fn)    type fn(P a, P b\n#define ifd(type, fn)   inline fd(type, fn)\n  \ntypedef double frac;\n  \ntypedef struct { frac x, y; } Point, P;\n  \nifd(frac, cross))   { return (a.x * b.y - a.y * b.x);  }\nifd(frac, dot))     { return (a.x * b.x + a.y * b.y);  }\nifd(P, plus))       { return (P){a.x + b.x, a.y + b.y};}\nifd(P, minus))      { return (P){a.x - b.x, a.y - b.y};}\nisfd(P, multi),int x){ return (P){a.x * x, a.y * x};   }\nisfd(P, sq))        { return (P){a.x * a.x, a.y * a.y};}\nisfd(frac, scalar)) { return (a.x + a.y);              }\nisfd(frac, norm))   { return hypot(a.x, a.y);  \t\t   }\n \nfd(int, ccw), P c){\n    b = minus(b, a), c = minus(c, a);\n    if (cross(b, c) > 0) return +1;          // ccw\n    if (cross(b, c) < 0) return -1;          // cw\n    if (dot(b, c) < 0)    return +2;         // c-a-b\n    if (norm(b) < norm(c)) return -2;  // a-b-c\n    return 0;\n}\nfd(int, in_tri), P c, P p){ return (ccw(a, b, p) == ccw(b, c, p) && ccw(b, c, p) == ccw(c, a, p)); }\n  \nint input_p(P *p) { return scanf(\"%lf,%lf\", &p->x, &p->y); }\nint cmp_p(P *a, P *b){ return (a->x == b->x ? a->y - b->y : a->x - b->x); }\nint graham_scan(P *vs, int n)\n{\n\tint k = 0, i, t;\n\tP ch[256];\n\tqsort(vs, n, sizeof(P), cmp_p);\n\tfor (i = 0; i < n; ch[k++] = vs[i++]){\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], vs[i]) <= 0) --k;\n\t}\n\tfor (i = n - 2, t = k + 1; i >= 0; ch[k++] = vs[i--]){\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], vs[i]) <= 0) --k;\n\t}\n\treturn (k - 1);\n}\n\nint main(void)\n{\n    P ps[128];\n    int n, i;\n \n    while (scanf(\"%d\", &n), n){\n\t    for (i = 0; i < n; i++){\n\t    \tinput_p(ps + i);\n\t    }\n\t    printf(\"%d\\n\", n - graham_scan(ps, n));\n\t}\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100\n\n/** テァツつケテ」ツ?ョテ・ツ?凝ヲツ閉ー */\nstatic int n;\n/** テァツつケテ」ツ?ョx テ・ツコツァテヲツィツ?*/\nstatic double x[ N ];\n/** テァツつケテ」ツ?ョy テ・ツコツァテヲツィツ?*/\nstatic double y[ N ];\n/** テ・ツ?クテ・ツ個?ゥツ?づァツつケテ」ツδ陛」ツδゥテ」ツつー */\nstatic double v[ N ];\n\n/** テヲツ鳴ケテ・ツ青妥、ツサツ佚」ツ?催ァツ崢エテァツキツ嗔1->p2 テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテァツつケp テ」ツ?古・ツキツヲテ・ツ?エテ」ツ?ォテ・ツュツ佚・ツ慊ィテ」ツ?凖」ツつ凝」ツ?凝」ツつ津・ツ按、テ・ツョツ堙」ツ?凖」ツつ?*/\nstatic int\nisLeft (\n  int p1,\n  int p2,\n  int p\n  )\n{\n  /** テヲツ鳴ケテ・ツ青妥、ツサツ佚」ツ?催ァツ崢エテァツキツ嗔1->p2 テ」ツ?ィテァツつケp テ」ツ?ョテ・ツ、ツ姪ァツゥツ?*/\n  const double op = ( x[ p2 ] - x[ p1 ] ) * ( y[ p ] - y[ p1 ] )\n                  - ( y[ p2 ] - y[ p1 ] ) * ( x[ p ] - x[ p1 ] );\n\n  /* テ・ツ、ツ姪ァツゥツ催」ツ?古ィツイツ?」ツ?ェテ」ツつ嘉・ツキツヲテ・ツ?エテ」ツ?ォテ・ツュツ佚・ツ慊ィ */\n  return ( !!( op < 0 ) );\n}\n\n/** テヲツ慊?・ツキツヲテァツつケテ」ツつ津ヲツ篠「テァツエツ「テ」ツ?療ッツシツ古」ツ?敕」ツ?ョテ」ツつ、テ」ツδウテ」ツδ?」ツδε」ツつッテ」ツつケテ」ツつ津ィツソツ氾」ツ??*/\nstatic int\nfindIndexOfLeftmost (\n  void\n  )\n{\n  int res = 0;\n  int i;\n\n  for ( i = 1; i < n; ++i )\n  {\n    if ( x[ i ] < x[ res ] )\n      res = i;\n  }\n\n  return ( res );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int res = 0;\n    int c;\n\n    scanf ( \" %d\", &n );\n    if ( n == 0 ) break ;\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \" %lf,%lf\", &x[ i ], &y[ i ] );\n      v[ i ] = 1;\n    }\n\n    /* テヲツ慊?・ツキツヲテァツつケテ」ツ?凝」ツつ嘉・ツ?クテ・ツ個?ゥツ?づァツつケテ」ツつ津・ツ渉ウテ・ツ崢榲」ツつ甘」ツ?ァテゥツ??」ツ?ォテァツ卍コティツヲツ凝」ツ?凖」ツつ?*/\n    c = findIndexOfLeftmost ( );\n    for ( ; ; )\n    {\n      int nc = !( c ); /*< ( c == 0 ? 1 : 0 ) */\n\n      v[ c ] = 0;\n\n      /* ティツ?ェティツコツォテ」ツ?凝」ツつ嘉ィツヲツ凝」ツ?ヲテヲツ慊?・ツキツヲテァツつケテ」ツつ津ヲツ篠「テァツエツ「テ」ツ?凖」ツつ?*/\n      for ( i = 0; i < n; ++i )\n      {\n        /* ティツ?ェテ・ツ按?ィツ?ェティツコツォテ」ツ?ッテヲツ篠「テァツエツ「テ・ツッツセティツアツ。テ」ツ?凝」ツつ嘉ゥツ卍、テ・ツ、ツ?*/\n        if ( i == c ) continue ;\n\n        if ( isLeft ( c, nc, i ) )\n          nc = i;\n      }\n      /* テ、ツクツ?・ツ堕ィテ」ツ?療」ツ?淌」ツつ嘉ァツオツづ、ツコツ?*/\n      if ( v[ nc ] == 0 ) break ;\n      c = nc;\n    }\n\n    for ( i = 0; i < n; ++i )\n      res += !!( v[ i ] );\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nconst double eps = 1e-5;\n\n#define sfd(type, fn)   type fn(P a\n#define isfd(type, fn)  inline sfd(type, fn)\n#define fd(type, fn)    type fn(P a, P b\n#define ifd(type, fn)   inline fd(type, fn)\n\n;\ntypedef double frac;\n  \ntypedef struct { frac x, y; } Point, P;\n  \nifd(frac, cross))   { return (a.x * b.y - a.y * b.x);  }\nifd(frac, dot))     { return (a.x * b.x + a.y * b.y);  }\nifd(P, plus))       { return (P){a.x + b.x, a.y + b.y};}\nifd(P, minus))      { return (P){a.x - b.x, a.y - b.y};}\nisfd(P, multi),int x){ return (P){a.x * x, a.y * x};   }\nisfd(P, sq))        { return (P){a.x * a.x, a.y * a.y};}\nisfd(frac, scalar)) { return (a.x + a.y);              }\nisfd(frac, norm))   { return (a.x * a.x + a.y * a.y);  }\nisfd(frac, pabs))\t{ return sqrt(norm(a)); \t\t   }\n\nfd(int, ccw), P c){\n    b = minus(b, a), c = minus(c, a);\n    if (cross(b, c) > eps) return +1;          // ccw\n    if (cross(b, c) < -eps) return -1;          // cw\n    if (dot(b, c) < -eps)    return +2;         // c-a-b\n    if (norm(b) < norm(c)) return -2;\t\t // a-b-c\n    return 0;\n}\nfd(int, in_tri), P c, P p){ return (ccw(a, b, p) == ccw(b, c, p) && ccw(b, c, p) == ccw(c, a, p)); }\n  \nint input_p(P *p) { return scanf(\"%lf,%lf\", &p->x, &p->y); }\nint cmp_p(P *a, P *b){ return (a->x == b->x ? a->y - b->y : a->x - b->x); }\nint graham_scan(P *vs, int n)\n{\n\tint k = 0, i, t;\n\tP ch[256];\n\tqsort(vs, n, sizeof(P), cmp_p);\n\tfor (i = 0; i < n; ch[k++] = vs[i++]){\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], vs[i]) <= 0) --k;\n\t}\n\tfor (i = n - 2, t = k + 1; i >= 0; ch[k++] = vs[i--]){\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], vs[i]) <= 0) --k;\n\t}\n\treturn (k - 1);\n}\n\nint main(void)\n{\n    P ps[128];\n    int n, i;\n \n    while (scanf(\"%d\", &n), n){\n\t    for (i = 0; i < n; i++){\n\t    \tinput_p(ps + i);\n\t    }\n\t    printf(\"%d\\n\", n - graham_scan(ps, n));\n\t}\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{doublex,y,key;}w;w p[101],bs;i,m,v[100],n;z(w*c,w*d){return c->key>d->key?-1:c->key<d->key;}doubleouter(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(){doublek,t;for(;~scanf(\"%d\",&n),n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;bs=p[m];p[m]=*p;*p=bs;p[100].x=bs.x;p[100].y=bs.y+1;for(i=1;i<n;i++){k=outer(0,i,100);t=(p[i].x-bs.x)*(p[i].x-bs.x)+(p[i].y-bs.y)*(p[i].y-bs.y);k*=k/t;if(bs.x>p[i].x)k=-k;p[i].key=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;outer(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define GRADIENT_MIN (0)\n#define GRADIENT_MAX (1)\n\nint find(int n, double list[100][2], double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, m, g;\n\n\tm = atan2(max ? -1.0 : 1.0, 0.0);\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(list[i][0]) || isless(list[i][0], p[0]))\n\t\t\tcontinue;\n\n\t\tdx = list[i][0] - p[0];\n\t\tdy = list[i][1] - p[1];\n\t\tg = atan2(dy, dx);\n\t\tif (max ? isgreater(g, m) : isgreater(m, g)) {\n\t\t\tm = g;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\tp[0] = list[midx][0];\n\tp[1] = list[midx][1];\n\treturn midx;\n}\n\nvoid input(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i, left;\n\n\tp0[0] = 1001.0;\n\tp1[0] = -1001.0;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", &list[i][0], &list[i][1]);\n\t\tif (isgreater(p0[0], list[i][0])) {\n\t\t\tp0[0] = list[i][0];\n\t\t\tp0[1] = list[i][1];\n\t\t\tleft = i;\n\t\t}\n\t\tif (isless(p1[0], list[i][0])) {\n\t\t\tp1[0] = list[i][0];\n\t\t\tp1[1] = list[i][1];\n\t\t}\n\t}\n\tlist[left][0] = list[left][1] = NAN;\n}\n\nvoid rm_vertex(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i;\n\tdouble p[2];\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MAX);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MIN);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n}\n\nint solve(int n) {\n\tdouble list[100][2], p0[2], p1[2];\n\tint i, count;\n\n\tinput(n, list, p0, p1);\n#if 0\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%lf,%lf\\n\", list[i][0], list[i][1]);\n\t}\n#endif\n\trm_vertex(n, list, p0, p1);\n\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (!isnan(list[i][0]))\n\t\t\tcount++;\n\t}\n\treturn count - 1;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* １個ずつ紐を張っていく感じ */\n\n#include <stdio.h>\n#include <math.h>\n#define N_MAX 100\n#define INF 100\n\n/* vector */\n\ntypedef struct vector { double x, y; } vector;\n\ndouble norm(vector a){ return hypot(a.x, a.y); }\nvector div(vector a, double b){ vector c={ .x = a.x/b, .y = a.y/b}; return c; }\nvector normalize(vector a) { return div(a, norm(a)); }\ndouble product(vector a, vector b){ return a.x * b.y - a.y * b.x; }\nvector sub(vector a, vector b){ vector x={ .x = a.x-b.x, .y = a.y-b.y }; return x; }\nvector zero={ .x = 0, .y = 0 };\n\n/**********/\n\ndouble cosV(vector a, vector b){ a=normalize(a), b=normalize(b); return a.x*b.x + a.y*b.y; }\ndouble sinV(vector a, vector b){ a=normalize(a), b=normalize(b); return a.x*b.y - a.y*b.x; }\n\nint main(void)\n{\n     int n; vector pin[N_MAX]; int used[N_MAX];\n     \n     while(scanf(\"%d\",&n), n!=0){\n\t  int i, k, maxN; double max, t; vector prev;\n\n\t  /* input */\n\t  max = 0, maxN = -1;\n\t  for(i=0; i<n; i++) used[i]=0;\n\t  for(i=0; i<n; i++){\n\t       scanf(\"%lf,%lf\",&(pin[i].x),&(pin[i].y));\n\t       if((t=norm(pin[i])) > max) max = t, maxN = i;\n\t  }\n\n\t  /* first \"k\" is the point that has the largest norm */\n\t  /* zero is zero-vector */\n\t  k = maxN, prev = zero;\n\t  while(!used[k]){\n\n\t       used[k] = 1;\n\t       \n\t       max = -INF, maxN = -1;\n\t       for(i=0; i<n; i++)\n\t\t    if(i!=k){\n\t\t\t if(sinV(sub(pin[k],prev), sub(pin[i],pin[k])) < 0) continue;\n\t\t\t \n\t\t\t t = cosV(sub(pin[k],prev), sub(pin[i],pin[k]));\n\t\t\t if(t > max) max = t, maxN = i;\n\t\t    }\n\n\t       prev = pin[k], k = maxN;\n\t  }\n\n\t  k = 0;\n\t  for(i=0; i<n; i++)\n\t       if(!used[i]) k++;\n\n\t  printf(\"%d\\n\",k);\n     }\n\n     return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ndouble g_vec[101][2];\n\nint compare(const void *a, const void *b) {\n\tif (*(double*)a > *(double*)b)\n\t\treturn 1;\n\tif (*(double*)a < *(double*)b)\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid input(int n, double p0[2], double p1[2]) {\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", &g_vec[i][0], &g_vec[i][1]);\n\t}\n\tqsort(g_vec, n, sizeof(double)*2, compare);\n\tp0[0] = g_vec[0][0];\n\tp0[1] = g_vec[0][1];\n\tp1[0] = g_vec[n-1][0];\n\tp1[1] = g_vec[n-1][1];\n\tg_vec[0][0] = g_vec[0][1] = NAN;\n}\n\nint find(int n, double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, rad, m;\n\n\tm = max ? -3.15 : 3.15;\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(g_vec[i][0]) || g_vec[i][0] < p[0]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdx = g_vec[i][0] - p[0];\n\t\tdy = g_vec[i][1] - p[1];\n\t\trad = atan2(dy, dx);\n\t\tif (max ? (rad > m) : (rad < m)) {\n\t\t\tm = rad;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\treturn midx;\n}\n\nint solve(int n) {\n\tint i, a = n;\n\tdouble p[2], p0[2], p1[2];\n\n\tinput(n, p0, p1);\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, p, 1);\n\t\tif (g_vec[i][0] == p1[0] && g_vec[i][1] == p1[1]) {\n\t\t\tbreak;\n\t\t}\n\t\tp[0] = g_vec[i][0];\n\t\tp[1] = g_vec[i][1];\n\t\tg_vec[i][0] = g_vec[i][1] = NAN;\n\t\ta--;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, p, 0);\n\t\tif (g_vec[i][0] == p1[0] && g_vec[i][1] == p1[1]) {\n\t\t\tbreak;\n\t\t}\n\t\tp[0] = g_vec[i][0];\n\t\tp[1] = g_vec[i][1];\n\t\tg_vec[i][0] = g_vec[i][1] = NAN;\n\t\ta--;\n\t}\n#if 0\n\tprintf(\"%lf,%lf\\n\", p0[0], p0[1]);\n\tprintf(\"%lf,%lf\\n\", p1[0], p1[1]);\n#endif\n\treturn a - 2;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[101],b;i,m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(){double k,t;for(;~scanf(\"%d\",&n),n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++){k=o(0,i,100);t=(p[i].x-b.x)*(p[i].x-b.x)+(p[i].y-b.y)*(p[i].y-b.y);k*=k/t;if(b.x>p[i].x)k=-k;p[i].k=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define GRADIENT_MIN (0)\n#define GRADIENT_MAX (1)\n\nint find(int n, double list[100][2], double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, m, g;\n\n\tm = copysign(INFINITY, max ? -1.0 : 1.0);\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(list[i][0]) || list[i][0] < p[0])\n\t\t\tcontinue;\n\n\t\tdx = p[0] - list[i][0];\n\t\tdy = p[1] - list[i][1];\n\t\t//g = (dx != 0.0) ? (dy / dx) : copysign(INFINITY, -dy);\n\t\tg = (dx != 0.0) ? (dy / dx) : INFINITY;\n\n\t\tif (max ? (m < g) : (m > g)) {\n\t\t\tm = g;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\tp[0] = list[midx][0];\n\tp[1] = list[midx][1];\n\treturn midx;\n}\n\nvoid input(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i, left;\n\n\tp0[0] = 1001.0;\n\tp1[0] = -1001.0;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", list[i], list[i]+1);\n\t\tif (p0[0] > list[i][0]) {\n\t\t\tp0[0] = list[i][0];\n\t\t\tp0[1] = list[i][1];\n\t\t\tleft = i;\n\t\t}\n\t\tif (p1[0] < list[i][0]) {\n\t\t\tp1[0] = list[i][0];\n\t\t\tp1[1] = list[i][1];\n\t\t}\n\t}\n\tlist[left][0] = list[left][1] = NAN;\n}\n\nvoid rm_vertex(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i;\n\tdouble p[2];\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MAX);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MIN);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n}\n\nint solve(int n) {\n\tdouble list[100][2], p0[2], p1[2];\n\tint i, count;\n\n\tinput(n, list, p0, p1);\n\trm_vertex(n, list, p0, p1);\n\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (!isnan(list[i][0]))\n\t\t\tcount++;\n\t}\n\treturn count - 1;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-0 0068: Enclose Pins with a Rubber Band\n// 2017.8.10\n\n#include <stdio.h>\n#include <math.h>\n\ntypedef double data;\n\n#define SIZE  105\n#define EPS   1e-8\n\nint size;\ndata x[SIZE], y[SIZE];\n\nint convexHull(int pn, data *x, data *y);\ndata distance(data x1, data y1, data x2, data y2);\ndouble theta(data x1, data y1, data x2, data y2);\n\nint main(void)\n{\n\tint i, vsize;\n\n\twhile (1) {\n\t\tscanf(\"%d\", &size); if (!size) break;\n\t\tfor (i = 0; i < size; i++) scanf(\"%lf,%lf\", x + i, y + i);\n\t\tvsize = convexHull(size, x, y);\n\t\tprintf(\"%d\\n\", size - vsize);\n\t}\n\treturn 0;\n}\n\nint convexHull(int pn, data *x, data *y)\n{\n\tint i, j;\n\tint min;\n\tdouble minang, nowang;\n\tdata dist;\n\n\tmin = 0;\n\tfor (i = 1; i < pn; i++) {\n\t\tif (y[i] < y[min]) min = i;\n\t\telse if (y[i] == y[min] && x[i] < x[min]) min = i;\n\t}\n\n\tminang = 0;\n\tx[pn] = x[min], y[pn] = y[min];\n\tfor (j = 0; j < pn; j++) {\n\t\tdata tx, ty;\n\t\tif (j != min) {\n\t\t\ttx = x[j], x[j] = x[min], x[min] = tx;\n\t\t\tty = y[j], y[j] = y[min], y[min] = ty;\n\t\t}\n\t\tdist = 0x7ffffff;\n\t\tmin = pn; nowang = minang; minang = 360;\n\t\tfor (i = j + 1; i <= pn; i++) {\n\t\t\tdata d = distance(x[j], y[j], x[i], y[i]);\n\t\t\tdouble rad = theta(x[j], y[j], x[i], y[i]);\n\t\t\tif (d == 0) continue;\n\t\t\tif (rad < nowang) continue;\n\t\t\tif (rad > nowang + EPS) {\n\t\t\t\tif (rad + EPS < minang) {\n\t\t\t\t\tdist = d;\n\t\t\t\t\tminang = rad;\n\t\t\t\t\tmin = i;\n\t\t\t\t}\n\t\t\t\telse if (fabs(rad - minang) < EPS && d > EPS && d > dist) {\n\t\t\t\t\tdist = d;\n\t\t\t\t\tminang = rad;\n\t\t\t\t\tmin = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (fabs(rad - nowang) < EPS && d > EPS &&\n\t\t\t\tfabs(rad - minang) > EPS || d > dist) {\n\t\t\t\tdist = d;\n\t\t\t\tminang = rad;\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t}\n\t\tif (min == pn) break;\n\t}\n\treturn j + 1;\n}\n\ndata distance(data x1, data y1, data x2, data y2)\n{\n\tdata dx = x1 - x2;\n\tdata dy = y1 - y2;\n\treturn dx*dx + dy*dy;\n}\n\ndouble theta(data x1, data y1, data x2, data y2)\n{\n\tdata dx, dy, ax, ay;\n\tdouble t;\n\n\tdx = x2 - x1, ax = dx < 0 ? -dx : dx;\n\tdy = y2 - y1, ay = dy < 0 ? -dy : dy;\n\tt = (ax + ay == 0) ? 0 : (double)dy / (double)(ax + ay);\n\tif (dx < 0) t = 2 - t;\n\telse if (dy < 0) t = 4 + t;\n\treturn t * 90.0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100\n\n/** テァツつケテ」ツ?ョテ・ツ?凝ヲツ閉ー */\nstatic int n;\n/** テァツつケテ」ツ?ョx テ・ツコツァテヲツィツ?*/\nstatic double x[ N ];\n/** テァツつケテ」ツ?ョy テ・ツコツァテヲツィツ?*/\nstatic double y[ N ];\n/** テ・ツ?クテ・ツ個?ゥツ?づァツつケテ」ツδ陛」ツδゥテ」ツつー */\nstatic double v[ N ];\n\n/** テヲツ鳴ケテ・ツ青妥、ツサツ佚」ツ?催ァツ崢エテァツキツ嗔1->p2 テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテァツつケp テ」ツ?古・ツキツヲテ・ツ?エテ」ツ?ォテ・ツュツ佚・ツ慊ィテ」ツ?凖」ツつ凝」ツ?凝」ツつ津・ツ按、テ・ツョツ堙」ツ?凖」ツつ?*/\nstatic int\nisLeft (\n  int p1,\n  int p2,\n  int p\n  )\n{\n  /** テヲツ鳴ケテ・ツ青妥、ツサツ佚」ツ?催ァツ崢エテァツキツ嗔1->p2 テ」ツ?ィテァツつケp テ」ツ?ョテ・ツ、ツ姪ァツゥツ?*/\n  const int op = ( x[ p2 ] - x[ p1 ] ) * ( y[ p ] - y[ p1 ] )\n               - ( y[ p2 ] - y[ p1 ] ) * ( x[ p ] - x[ p1 ] );\n\n  /* テ・ツ、ツ姪ァツゥツ催」ツ?古ィツイツ?」ツ?ェテ」ツつ嘉・ツキツヲテ・ツ?エテ」ツ?ォテ・ツュツ佚・ツ慊ィ */\n  return ( !!( op < 0 ) );\n}\n\n/** テヲツ慊?・ツキツヲテァツつケテ」ツつ津ヲツ篠「テァツエツ「テ」ツ?療ッツシツ古」ツ?敕」ツ?ョテ」ツつ、テ」ツδウテ」ツδ?」ツδε」ツつッテ」ツつケテ」ツつ津ィツソツ氾」ツ??*/\nstatic int\nfindIndexOfLeftmost (\n  void\n  )\n{\n  int res = 0;\n  int i;\n\n  for ( i = 1; i < n; ++i )\n  {\n    if ( x[ i ] < x[ res ] )\n      res = i;\n  }\n\n  return ( res );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int res = 0;\n    int c;\n\n    scanf ( \" %d\", &n );\n    if ( n == 0 ) break ;\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \" %lf,%lf\", &x[ i ], &y[ i ] );\n      v[ i ] = 1;\n    }\n\n    /* テヲツ慊?・ツキツヲテァツつケテ」ツ?凝」ツつ嘉・ツ?クテ・ツ個?ゥツ?づァツつケテ」ツつ津・ツ渉ウテ・ツ崢榲」ツつ甘」ツ?ァテゥツ??」ツ?ォテァツ卍コティツヲツ凝」ツ?凖」ツつ?*/\n    c = findIndexOfLeftmost ( );\n    for ( ; ; )\n    {\n      int nc = !( c ); /*< ( c == 0 ? 1 : 0 ) */\n\n      v[ c ] = 0;\n\n      /* ティツ?ェティツコツォテ」ツ?凝」ツつ嘉ィツヲツ凝」ツ?ヲテヲツ慊?・ツキツヲテァツつケテ」ツつ津ヲツ篠「テァツエツ「テ」ツ?凖」ツつ?*/\n      for ( i = 0; i < n; ++i )\n      {\n        /* ティツ?ェテ・ツ按?ィツ?ェティツコツォテ」ツ?ッテヲツ篠「テァツエツ「テ・ツッツセティツアツ。テ」ツ?凝」ツつ嘉ゥツ卍、テ・ツ、ツ?*/\n        if ( i == c ) continue ;\n\n        if ( isLeft ( c, nc, i ) )\n          nc = i;\n      }\n      /* テ、ツクツ?・ツ堕ィテ」ツ?療」ツ?淌」ツつ嘉ァツオツづ、ツコツ?*/\n      if ( v[ nc ] == 0 ) break ;\n      c = nc;\n    }\n\n    for ( i = 0; i < n; ++i )\n      res += !!( v[ i ] );\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){double k,t;for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++){k=o(0,i,100);t=(p[i].x-b.x)*(p[i].x-b.x)+(p[i].y-b.y)*(p[i].y-b.y);k*=k/t;if(b.x>p[i].x)k=-k;p[i].k=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define GRADIENT_MIN (0)\n#define GRADIENT_MAX (1)\n\nint find(int n, double list[100][2], double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, m, g;\n\n\tm = copysign(INFINITY, max ? -1.0 : 1.0);\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(list[i][0]) || list[i][0] < p[0])\n\t\t\tcontinue;\n\n\t\tdx = p[0] - list[i][0];\n\t\tdy = p[1] - list[i][1];\n\t\tif (dx == 0.0) {\n\t\t\tif (max ? (dy > 0.0) : (dy < 0.0)) {\n\t\t\t\tmidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tg = dy / dx;\n\t\t}\n\t\tif (max ? (m < g) : (m > g)) {\n\t\t\tm = g;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\tp[0] = list[midx][0];\n\tp[1] = list[midx][1];\n\treturn midx;\n}\n\nvoid input(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i, left;\n\n\tp0[0] = 1001.0;\n\tp1[0] = -1001.0;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", list[i], list[i]+1);\n\t\tif (p0[0] > list[i][0]) {\n\t\t\tp0[0] = list[i][0];\n\t\t\tp0[1] = list[i][1];\n\t\t\tleft = i;\n\t\t}\n\t\tif (p1[0] < list[i][0]) {\n\t\t\tp1[0] = list[i][0];\n\t\t\tp1[1] = list[i][1];\n\t\t}\n\t}\n\tlist[left][0] = list[left][1] = NAN;\n}\n\nvoid rm_vertex(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i;\n\tdouble p[2];\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MAX);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MIN);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n}\n\nint solve(int n) {\n\tdouble list[100][2], p0[2], p1[2];\n\tint i, count;\n\n\tinput(n, list, p0, p1);\n\trm_vertex(n, list, p0, p1);\n\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (!isnan(list[i][0]))\n\t\t\tcount++;\n\t}\n\treturn count - 1;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n\n#define INT(X) \\\n  ( *( (const int *)(X) ) )\n\nstatic int\ncompare (\n  const void  * a,\n  const void  * b\n  )\n{\n  return ( INT( b ) - INT( a ) );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  struct Point\n  {\n    double x;\n    double y;\n  }   d[ 128 ];\n  int i;\n\n  for ( ; ; )\n  {\n    double ul, ll;\n    int lc = 0;\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( !( n ) ) break ;\n\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \" %lf,%lf\", &d[ i ].x, &d[ i ].y );\n    }\n    qsort ( d, n, sizeof ( struct Point ), compare );\n\n    ul = ll\n       = d->y;\n    d->y = DBL_MAX; ++lc;\n    for ( i = 1; i < n - 1; ++i )\n    {\n      if ( d[ i ].y > ul )\n      {\n        ul = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n      else if ( d[ i ].y < ll )\n      {\n        ll = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n    }\n\n    ul = ll\n       = d[n - 1 ].y;\n    d[ n - 1 ].y = DBL_MAX; ++lc;\n    for ( i = n - 1; i > 0; --i )\n    {\n      if ( d[ i ].y == DBL_MAX )  continue ;\n\n      if ( d[ i ].y > ul )\n      {\n        ul = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n      else if ( d[ i ].y < ll )\n      {\n        ll = d[ i ].y;\n        d[ i ].y = DBL_MAX; ++lc;\n      }\n    }\n\n    printf ( \"%d\\n\", n - lc );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "c,i,p,P,f;main(n){float x[100],y[100],d,t,T;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",c)){for(T=2e3,c=i=n;d=i--;y[i]<T?T=y[p=f=i]:0)scanf(\"%f,%f\",x+i,y+i);do{T=9;for(i=n;i--;)i-p?t=atan2f(y[i]-y[p],x[i]-x[p]),t+=8*atan(t<d),t<T?T=t,P=i:0:0;p=P,d=T,c--;}while(p-f);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nconst double eps = 1e-5;\n\n#define sfd(type, fn)   type fn(P a\n#define isfd(type, fn)  inline sfd(type, fn)\n#define fd(type, fn)    type fn(P a, P b\n#define ifd(type, fn)   inline fd(type, fn)\n\n;\ntypedef double frac;\n  \ntypedef struct { frac x, y; } Point, P;\n  \nifd(frac, cross))   { return (a.x * b.y - a.y * b.x);  }\nifd(frac, dot))     { return (a.x * b.x + a.y * b.y);  }\nifd(P, plus))       { return (P){a.x + b.x, a.y + b.y};}\nifd(P, minus))      { return (P){a.x - b.x, a.y - b.y};}\nisfd(P, multi),int x){ return (P){a.x * x, a.y * x};   }\nisfd(P, sq))        { return (P){a.x * a.x, a.y * a.y};}\nisfd(frac, scalar)) { return (a.x + a.y);              }\nisfd(frac, norm))   { return (a.x * a.x + a.y * a.y);  }\nisfd(frac, pabs))\t{ return sqrt(norm(a)); \t\t   }\n\nfd(int, ccw), P c){\n    b = minus(b, a), c = minus(c, a);\n    if (cross(b, c) > eps) return +1;          // ccw\n    if (cross(b, c) < -eps) return -1;          // cw\n    if (dot(b, c) < -eps)    return +2;         // c-a-b\n    if (norm(b) < norm(c)) return -2;\t\t // a-b-c\n    return 0;\n}\nfd(int, in_tri), P c, P p){ return (ccw(a, b, p) == ccw(b, c, p) && ccw(b, c, p) == ccw(c, a, p)); }\n  \nint input_p(P *p) { return scanf(\"%lf,%lf\", &p->x, &p->y); }\nint cmp_p(P *a, P *b){ return (a->x == b->x ? a->y - b->y : a->x - b->x); }\nint graham_scan(P *vs, int n)\n{\n\tint k = 0, i, t;\n\tP ch[256];\n\tqsort(vs, n, sizeof(P), cmp_p);\n\tfor (i = 0; i < n; i++){\n\t\twhile (k > 1 && cross(minus(ch[k - 1], ch[k - 2]), minus(vs[i], ch[k - 1])) < -eps) --k;\n\t\tch[k++] = vs[i];\n\t}\n\tfor (i = n - 2, t = k; i >= 0; i--){\n\t\twhile (k > t && cross(minus(ch[k - 1], ch[k - 2]), minus(vs[i], ch[k - 1])) < -eps) --k;\n\t\tch[k++] = vs[i];\n\t}\n\treturn (k - 1);\n}\n\nint main(void)\n{\n    P ps[128];\n    int n, i;\n \n    while (scanf(\"%d\", &n), n){\n\t    for (i = 0; i < n; i++){\n\t    \tinput_p(ps + i);\n\t    }\n\t    printf(\"%d\\n\", n - graham_scan(ps, n));\n\t}\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x,y;\n} xy_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst xy_t* a=(const xy_t*)x;\n\tconst xy_t* b=(const xy_t*)y;\n\tif((a->x)>(b->x))return 1;\n\tif((a->x)<(b->x))return -1;\n\tif((a->y)>(b->y))return 1;\n\tif((a->y)<(b->y))return -1;\n\treturn 0;\n}\n\nint zahyou_num;\nxy_t zahyou[100];\n\nint th_up_n;\nint th_down_n;\nxy_t th_up[100];\nxy_t th_down[100];\n\nint main(void) {\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d\",&zahyou_num);\n\t\tif(zahyou_num==0)break;\n\t\tfor(i=0;i<zahyou_num;i++) {\n\t\t\tscanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y);\n\t\t}\n\t\tqsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp);\n\t\t//sita no totu-ho\n\t\tth_down_n=1;\n\t\tth_down[0].x=zahyou[0].x;\n\t\tth_down[0].y=zahyou[0].y;\n\t\tfor(i=1;i<zahyou_num;i++) {\n\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\twhile(th_down_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_down[th_down_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_down[th_down_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_down[th_down_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_down[th_down_n-1].x==th_down[th_down_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_down[th_down_n-1].y<th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_down[th_down_n-1].y-th_down[th_down_n-2].y)/\n\t\t\t\t\t\t   (th_down[th_down_n-1].x-th_down[th_down_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_down_n--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tth_down[th_down_n].x=zahyou[i].x;\n\t\t\tth_down[th_down_n].y=zahyou[i].y;\n\t\t\tth_down_n++;\n\t\t}\n\t\t//ue no totu-ho\n\t\tth_up_n=1;\n\t\tth_up[0].x=zahyou[zahyou_num-1].x;\n\t\tth_up[0].y=zahyou[zahyou_num-1].y;\n\t\tfor(i=zahyou_num-2;i>=0;i--) {\n\t\t\tif(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\twhile(th_up_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_up[th_up_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_up[th_up_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_up[th_up_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_up[th_up_n-1].x==th_up[th_up_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_up[th_up_n-1].y<th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/\n\t\t\t\t\t\t   (th_up[th_up_n-1].x-th_up[th_up_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_up_n--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tth_up[th_up_n].x=zahyou[i].x;\n\t\t\tth_up[th_up_n].y=zahyou[i].y;\n\t\t\tth_up_n++;\n\t\t}\n\t\tprintf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){double k,t;for(;~scanf(\"%d\",&n),j=n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++){k=o(0,i,100);t=(p[i].x-b.x)*(p[i].x-b.x)+(p[i].y-b.y)*(p[i].y-b.y);k*=k/t;if(b.x>p[i].x)k=-k;p[i].k=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}exit(0);}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,key;}w;w p[101],bs;i,m,v[100],n;z(w*c,w*d){return c->key>d->key?-1:c->key<d->key;}double outer(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(){double k,t;for(;~scanf(\"%d\",&n),n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;bs=p[m];p[m]=*p;*p=bs;p[100].x=bs.x;p[100].y=bs.y+1;for(i=1;i<n;i++){k=outer(0,i,100);t=(p[i].x-bs.x)*(p[i].x-bs.x)+(p[i].y-bs.y)*(p[i].y-bs.y);k*=k/t;if(bs.x>p[i].x)k=-k;p[i].key=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;outer(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc,char* argv[]){\n  int n,i;\n  double array_x[100];\n  double array_y[100];\n\n  for(;;){\n    double smallest_x = 9999.0,smallest_y = 9999.0;\n    double cur_rad = 0;\n    int cur = 0,smallest_cur = 0;\n    int count = 0;\n    \n    scanf(\"%d\",&n);\n    if(n == 0){\n      break;\n    }\n\n    for(i = 0; i < n; i++){\n      scanf(\"%lf,%lf\",&array_x[i],&array_y[i]);\n      if(smallest_y > array_y[i]){\n\tsmallest_y = array_y[i];\n\tsmallest_x = array_x[i];\n\tcur = i;\n      }else if(smallest_y == array_y[i]){\n\tif(smallest_x > array_x[i]){\n\t  smallest_x = array_x[i];\n\t  cur = i;\n\t}\n      }\n    }\n\n    smallest_cur = cur;\n\n    for(;;){\n      int next_cur;\n      double next_rad = 0;\n      double smallest_rad = 2*M_PI;\n      \n      printf(\"cur = %d\\n\",cur);\n\n      for(i = 0; i < n; i++){\n\tdouble tmp,tmp2;\n\tif(i == cur){continue;}\n\ttmp = atan2(array_y[i]-array_y[cur],array_x[i]-array_x[cur]);\n\tif(tmp <= 0){tmp += M_PI*2;}\n\t//printf(\"cur = %d, i = %d rad = %lf cur_rad = %lf smallest = %lf\\n\",cur,i,tmp,cur_rad,smallest_rad);\n\ttmp2 = tmp - cur_rad;\n\tif(tmp2 <= 0){\n\t  tmp2 += 2*M_PI;\n\t}\n\tif(smallest_rad > tmp2){\n\t  smallest_rad = tmp2;\n\t  next_rad = tmp;\n\t  next_cur = i;\n\t}\n      }\n\n      count++;\n\n      if(next_cur == smallest_cur){\n\tbreak;\n      }else{\n\tcur = next_cur;\n\tcur_rad = next_rad;\n      }\n    }\n\n    printf(\"%d\\n\",n-count);\n\n    \n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ndouble x[100],y[100];\n\ndouble len(int a,int b){\n  return  sqrt( (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]) );\n}\n\ndouble flon(int a,int b,int c){\n  double s;\n  double la,lb,lc;\n  la = len(b,c);\n  lb = len(a,c);\n  lc = len(a,b);\n  s = (la+lb+lc)/2.0;\n  return sqrt(s*(s-la)*(s-lb)*(s-lc));\n}\n  \nint inter(int x,int a,int b,int c){\n  if(flon(a,b,x)+flon(a,c,x)+flon(b,c,x)-flon(a,b,c)<1e-10)return 1;\n  else return 0;\n}\n\nint band(int i,int j,int k,int l){\n  if(inter(i,j,k,l))return i;\n  if(inter(j,i,k,l))return j;\n  if(inter(k,i,j,l))return k;\n  if(inter(l,i,j,k))return l;\n  return -1;\n}\n  \n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int tmp;\n  double minx,tmpd;\n  int unuse[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    minx = 9999.9;\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&x[i],&y[i]);\n      unuse[i] = 0;\n      if(minx>x[i])minx = x[i];\n    }\n\n    for(i=0;i<n;i++){\n      if(minx==x[i]){\n\ttmpd = x[i];\n\tx[i] = x[0];\n\tx[0] = tmpd;\n\ttmpd = y[i];\n\ty[i] = y[0];\n\ty[0] = tmpd;\n\tbreak;\n      }\n    }\n\n    for(i=0;i<n-3;i++){\n      for(j=i+1;j<n-2;j++){\n\tfor(k=j+1;k<n-1;k++){\n\t  for(l=k+1;l<n;l++){\n\t    tmp = band(i,j,k,l);\n\t    if(tmp>=0)unuse[tmp] = 1;\n\t  }\n\t}\n      }\n    }\n\n    tmp = 0;\n    for(i=0;i<n;i++){\n      if(unuse[i])tmp++;\n    }\n\n    printf(\"%d\\n\",tmp);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define GRADIENT_MIN (0)\n#define GRADIENT_MAX (1)\n\nint find(int n, double list[100][2], double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, m, g;\n\n\tm = copysign(INFINITY, max ? -1.0 : 1.0);\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(list[i][0]) || isless(list[i][0], p[0]))\n\t\t\tcontinue;\n\n\t\tdx = p[0] - list[i][0];\n\t\tdy = p[1] - list[i][1];\n\t\t// runtime error\n\t\tif (!islessgreater(dx, 0.0))\n\t\t\tg = copysign(INFINITY, -dy);\n\t\telse\n\t\t\tg = dy / dx; \n\n\t\tif (max ? isgreater(g, m) : isgreater(m, g)) {\n\t\t\tm = g;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\tp[0] = list[midx][0];\n\tp[1] = list[midx][1];\n\treturn midx;\n}\n\nvoid input(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i, left;\n\n\tp0[0] = 1001.0;\n\tp1[0] = -1001.0;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", list[i], list[i]+1);\n\t\tif (isgreater(p0[0], list[i][0])) {\n\t\t\tp0[0] = list[i][0];\n\t\t\tp0[1] = list[i][1];\n\t\t\tleft = i;\n\t\t}\n\t\tif (isless(p1[0], list[i][0])) {\n\t\t\tp1[0] = list[i][0];\n\t\t\tp1[1] = list[i][1];\n\t\t}\n\t}\n\tlist[left][0] = list[left][1] = NAN;\n}\n\nvoid rm_vertex(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i;\n\tdouble p[2];\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MAX);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MIN);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n}\n\nint solve(int n) {\n\tdouble list[100][2], p0[2], p1[2];\n\tint i, count;\n\n\tinput(n, list, p0, p1);\n\trm_vertex(n, list, p0, p1);\n\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (!isnan(list[i][0]))\n\t\t\tcount++;\n\t}\n\treturn count - 1;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // qsort()\n#include <math.h>           // fabs()\n#include <stdbool.h>\n\n#define MAX_N 100\nconst double EPS = 1e-10;\n\ntypedef struct\n{\n\tdouble x;\n\tdouble y;\n} P;\n\nP ps[MAX_N];\nP qs[MAX_N * 2];\nint n;\nint m;\n\ndouble\ndet(P *a, P *b)\n{\n\treturn a->x * b->y - a->y * b->x;\n}\n\nint\ncmp_func(const void *l_, const void *r_)\n{\n\tconst P *l = (const P*) l_;\n\tconst P *r = (const P*) r_;\n\n\tif (fabs(l->x - r->x) >= EPS)\n\t{\n\t\tif (l->x < r->x)\n\t\t\treturn -1;\n\n\t\tif (l->x > r->x)\n\t\t\treturn 1;\n\t}\n\n\tif (fabs(l->y - r->y) >= EPS)\n\t{\n\t\tif (l->y < r->y)\n\t\t\treturn -1;\n\n\t\tif (l->y > r->y)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid\nconvex_hull()\n{\n\tP p, q;\n\tint i, j;\n\n\tqsort(ps, n, sizeof(P), cmp_func);\n\tm = 0;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tif (m <= 1)\n\t\t\t\tbreak;\n\n\t\t\tp.x = qs[m - 1].x - qs[m - 2].x;\n\t\t\tp.y = qs[m - 1].y - qs[m - 2].y;\n\t\t\tq.x = ps[i].x - qs[m - 1].x;\n\t\t\tq.y = ps[i].y - qs[m - 1].y;\n\t\t\tif (det(&p, &q) > 0)\n\t\t\t\tbreak;\n\n\t\t\tm--;\n\t\t}\n\n\t\tqs[m++] = ps[i];\n\t}\n\n\tfor (i = n - 2, j = m; i >= 0; --i)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tif (m <= j)\n\t\t\t\tbreak;\n\n\t\t\tp.x = qs[m - 1].x - qs[m - 2].x;\n\t\t\tp.y = qs[m - 1].y - qs[m - 2].y;\n\t\t\tq.x = ps[i].x - qs[m - 1].x;\n\t\t\tq.y = ps[i].y - qs[m - 1].y;\n\t\t\tif (det(&p, &q) > 0)\n\t\t\t\tbreak;\n\n\t\t\tm--;\n\t\t}\n\n\t\tqs[m++] = ps[i];\n\t}\n\n\tm--;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tint i;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tscanf(\"%lf,%lf\", &ps[i].x, &ps[i].y);\n\n\t\tconvex_hull();\n\t\tprintf(\"%d\\n\", n - m);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint main(){\n  int n,i,mi,mj,c;\n  double max,m,ax,ay,by,bx,x[100],y[100];\n  while(scanf(\"%d\",&n),n){\n    int f[100]={0};\n    ay=1;\n    ax=max=0;\n    for(i=0;i<n;i++){\n      scanf(\"%lf,%lf\",&x[i],&y[i]);\n      if(max<x[i])max=x[mi=i];\n    }\n    for(c=0;f[mi]==0;c++){//printf(\"%d\\n\",mi);\n      f[mi]=1;\n      for(i=max=0;i<n;i++){\n\tif(mi==i)continue;\n\tbx=x[i]-x[mi];\n\tby=y[i]-y[mi];\n\tm=(ax*bx+ay*by)/(hypot(ay,ax)*hypot(bx,by));\n\tif(ax*by<ay*bx)m=1-m;\n\telse m+=3;\n\tif(max<m){\n\t  max=m;\n\t  mj=i;\n\t}\n      }\n      ax=x[mj]-x[mi];\n      ay=y[mj]-y[mi];\n      mi=mj;\n    }\n    printf(\"%d\\n\",n-c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct{\n\tdouble x,y,key;\n}point;\npoint pnt[101];\nint n;\nint cmp(const void*a,const void*b){\n\tconst point*c=a,*d=b;\n\treturn c->key>d->key?-1:c->key<d->key;\n}\ndouble outer(int q,int r,int s){\n\treturn pnt[q].x*(pnt[r].y-pnt[s].y)+pnt[r].x*(pnt[s].y-pnt[q].y)+pnt[s].x*(pnt[q].y-pnt[r].y);\n}\nint main(void){\n\tint i,m,tb[100],j;\n\tdouble k,t;\n\tpoint bs;\n\tfor(;~scanf(\"%d\",&n),n;){\n\t\tfor(m=i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\",&pnt[i].x,&pnt[i].y);\n\t\t\tif(pnt[m].y>pnt[i].y)m=i;\n\t\t}\n\t\tbs = pnt[m];\n\t\tpnt[m] = *pnt;\n\t\t*pnt = bs;\n\t\t\n\t\tpnt[100].x = bs.x;\n\t\tpnt[100].y = bs.y + 1.0;\n\t\t\n\t\tfor( i = 1; i < n; i++ ){\n\t\t\tk = outer( 0, i, 100 );\n\t\t\tt = (pnt[i].x-bs.x)*(pnt[i].x-bs.x) + (pnt[i].y-bs.y)*(pnt[i].y-bs.y);\n\t\t\tk *= k / t;\n\t\t\tif( bs.x>pnt[i].x ) k = -k;\n\t\t\tpnt[i].key = k;\n\t\t}\n\t\t\n\t\tqsort( pnt+1, n-1, sizeof(point), cmp );\n\t\t\n\t\ttb[0]=0;\n\t\ttb[1]=1;\n\t\ttb[2]=j=2;\n\t\tfor( i = 3; i < n; i++ ){\n\t\t\tfor(;outer(tb[j-1],tb[j],i)<0;j--);\n\t\t\ttb[++j] = i;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", n - j - 1 );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nstruct POINT{\n\tdouble x,y;\n};\n\ndouble area(double a,double b,double c){\n\tdouble s;\n\n\ts = (a+b+c)/2.0;\n\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nint main(){\n\tint h,i,j,k,l,n,cnt;\n\tint flag[100];\n\tdouble len[6],s[4];\n\tPOINT p[4];\n\tPOINT pin[100];\n\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%lf,%lf\",&pin[i].x,&pin[i].y);\n\t\t}\n\n\t\tmemset(flag,0,sizeof(flag));\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(flag[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp[0] = pin[i];\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j || flag[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp[1] = pin[j];\n\t\t\t\tfor(k = 0;k < n;k++){\n\t\t\t\t\tif(i == k || j == k || flag[k]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tp[2] = pin[k];\n\t\t\t\t\tfor(h = 0;h < 3;h++){\n\t\t\t\t\t\t\tlen[h] = sqrt(pow(p[(h+1)%3].x-p[h].x,2)+pow(p[(h+1)%3].y-p[h].y,2));\n\t\t\t\t\t}\n\t\t\t\t\ts[3] = area(len[0],len[1],len[2]);\n\t\t\t\t\tfor(l = 0;l < n;l++){\n\t\t\t\t\t\tif(i == l || j == l || k == l || flag[l]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp[3] = pin[l];\n\t\t\t\t\t\tfor(h = 0;h < 3;h++){\n\t\t\t\t\t\t\tlen[3+h] = sqrt(pow(p[3].x-p[h].x,2)+pow(p[3].y-p[h].y,2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(h = 0;h < 3;h++){\n\t\t\t\t\t\t\ts[h] = area(len[h],len[3+h],len[(h+1)%3+3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fabs(s[3]-s[0]-s[1]-s[2])/(s[0]+s[1]+s[2]) < 1e-5){\n\t\t\t\t\t\t\tflag[l] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(flag[i]){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[99],b;m,v[99],n,j,r;z(w*c,w*d){r=c->k>d->k?-1:1;}double o(w q,w r,w s){return q.x*(r.y-s.y)+r.x*(s.y-q.y)+s.x*(q.y-r.y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;for(i=1;i<n;i++)p[i].k=(p[i].x-b.x)/hypot(p[i].x-b.x,p[i].y-b.y);qsort(p+1,n-1,24,z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(p[v[j-1]],p[v[j]],p[i])<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define EPS 0.000000001\ntypedef struct p{\n\tdouble x,y;\n}P;\nint compP(const void *p,const void *q){\n\tP *a=(P *)p,*b=(P *)q;\n\tif(a->x == b->x)return a->y - b->y;\n\telse return a->x - b->x;\n}\nP mi(P a,P b){\n\treturn (P){a.x-b.x,a.y-b.y};\n}\ndouble det(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\nint convex(P v[],P nv[],int n){\n\tint i,k,t;\n\tqsort(v,n,sizeof(P),compP);\n\tfor(i=0,k=0;i<n;i++){\n\t\twhile(k>1 && det(mi(nv[k-1],nv[k-2]),mi(v[i],nv[k-1]))<EPS)k--;\n\t\tnv[k++]=v[i];\n\t}\n\tfor(i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t && det(mi(nv[k-1],nv[k-2]),mi(v[i],nv[k-1]))<EPS)k--;\n\t\tnv[k++]=v[i];\n\t}\n\t//nv[k]->x=10000.0;\n\treturn k-1;\n}\nint main(){\n\tint i,j,n;\n\tP q[105],sq[230];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%lf,%lf\",&q[i].x,&q[i].y);\n\t\tj=convex(q,sq,n);\n\t\t//for(i=0;i<j;i++)printf(\"%lf %lf\\n\",sq[i].x,sq[i].y);\n\t\tprintf(\"%d\\n\",n-j);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100\n\n/** 平面座標を表す */\nstruct Point\n{\n  /** x 座標 */\n  double x;\n  /** y 座標 */\n  double y;\n  /** グラフ表現用 */\n  struct Point *e;\n};\n\n/** ピン数 */\nstatic int n;\n/** ピン座標 */\nstatic struct Point p[ N ];\n\n/** 2 ベクトル(x1, y1), (x2, y2) の外積を求める． */\nstatic double\nouterProduct (\n  double x1,\n  double y1,\n  double x2,\n  double y2\n  )\n{\n  return ( x1 * y2 - y1 * x2 );\n}\n\n/** 頂点p[ idx ] より最も進行方向左側に存在する頂点を探索する． */\nstatic int\nfindOtherSideIndex (\n  int idx\n  )\n{\n  int otherSideIndex = !( idx ); /*< ( idx == 0 ? 1 : 0 ) */\n  int i;\n\n  for ( i = 1; i < n; ++i )\n  {\n    const double det\n      = outerProduct (\n          p[ otherSideIndex ].x - p[ idx ].x,\n          p[ otherSideIndex ].y - p[ idx ].y,\n          p[ i ].x - p[ idx ].x,\n          p[ i ].y - p[ idx ].y\n          );\n\n    /* 頂点p[ idx ] は探索対象から除く */\n    if ( i == idx ) continue ;\n\n    if ( det < 0. )\n    {\n      otherSideIndex = i;\n    }\n  }\n\n  return ( otherSideIndex );\n}\n\n/** 左端ピンのインデックスを探索する． */\nstatic int\nfindLeftmostIndex (\n  void\n  )\n{\n  int leftmostIndex = 0;\n  int i;\n\n  for ( i = 1; i < n; ++i )\n  {\n    if ( p[ i ].x < p[ leftmostIndex ].x )\n      leftmostIndex = i;\n  }\n\n  return ( leftmostIndex );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int vertexes = 0;\n\n    scanf ( \" %d\", &n );\n    if ( n == 0 ) break ;\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \" %lf,%lf\", &p[ i ].x, &p[ i ].y );\n      p[ i ].e = NULL;\n    }\n\n    /* 最左ピンより半時計回りに凸包頂点を一周結ぶ */\n    i = findLeftmostIndex ( );\n    while ( p[ i ].e == NULL )\n    {\n      const int nextIndex = findOtherSideIndex ( i );\n\n      printf ( \"==>%d\\n\", i );\n      p[ i ].e = &p[ nextIndex ];\n      i = nextIndex;\n    }\n\n    /* 凸包頂点の個数vertexes を数え上げる */\n    for ( i = 0; i < n; ++i )\n    {\n      vertexes += !!( p[ i ].e != NULL );\n    }\n\n    printf ( \"%d\\n\", n - vertexes );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct{\n  double x;\n  double y;\n}point;\n\nint main(){\n  int i,j,k,n,count;\n  point ps[100];\n  double a,c,now,prev,x;\n  do{\n    scanf(\"%d\",&n);\n    if(!n) break;\n    for(i=0;i<n;i++) scanf(\"%lf,%lf\",&(ps[i].x),&(ps[i].y));\n    for(count=0,i=0;i<n-1;i++){\n      for(j=0;j<n;j++){\n\tif(ps[i].x==ps[j].x){\n\t  x=ps[i].x;\n\t  for(k=1,prev=ps[0].x-x;k<n;k++){\n\t    now=ps[k].x-x;\n\t    if(prev*now<0) break;\n\t  }\n\t  if(k==n) goto find;\n\t}else{\n\t  a=(ps[i].y-ps[j].y)/(ps[i].x-ps[j].x);\n\t  c=ps[i].y-a*ps[i].x;\n\t  for(k=1,prev=a*ps[0].x+c-ps[k].y;k<n;k++){\n\t    now=a*ps[k].x+c-ps[k].y;\n\t    if(prev*now<0) break;\n\t  }\n\t  if(k==n) goto find;\n\t}\n      }\n      count++;\n    find:;\n    }\n    printf(\"%d\\n\",count);\n  }while(1);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100\n\n/** 平面座標を表す */\nstruct Point\n{\n  /** x 座標 */\n  double x;\n  /** y 座標 */\n  double y;\n  /** グラフ表現用 */\n  struct Point *e;\n};\n\n/** ピン数 */\nstatic int n;\n/** ピン座標 */\nstatic struct Point p[ N ];\n\n/** 2 ベクトル(x1, y1), (x2, y2) の外積を求める． */\nstatic double\nouterProduct (\n  double x1,\n  double y1,\n  double x2,\n  double y2\n  )\n{\n  return ( x1 * y2 - y1 * x2 );\n}\n\n/** 頂点p[ idx ] より最も進行方向左側に存在する頂点を探索する． */\nstatic int\nfindOtherSideIndex (\n  int idx\n  )\n{\n  int otherSideIndex = !( idx ); /*< ( idx == 0 ? 1 : 0 ) */\n  int i;\n\n  for ( i = 1; i < n; ++i )\n  {\n    const double det\n      = outerProduct (\n          p[ otherSideIndex ].x - p[ idx ].x,\n          p[ otherSideIndex ].y - p[ idx ].y,\n          p[ i ].x - p[ idx ].x,\n          p[ i ].y - p[ idx ].y\n          );\n\n    /* 頂点p[ idx ] は探索対象から除く */\n    if ( i == idx ) continue ;\n\n    if ( det < 0. )\n    {\n      otherSideIndex = i;\n    }\n  }\n\n  return ( otherSideIndex );\n}\n\n/** 左端ピンのインデックスを探索する． */\nstatic int\nfindLeftmostIndex (\n  void\n  )\n{\n  int leftmostIndex = 0;\n  int i;\n\n  for ( i = 1; i < n; ++i )\n  {\n    if ( p[ i ].x < p[ leftmostIndex ].x )\n      leftmostIndex = i;\n  }\n\n  return ( leftmostIndex );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int vertexes = 0;\n\n    scanf ( \" %d\", &n );\n    if ( n == 0 ) break ;\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \" %lf,%lf\", &p[ i ].x, &p[ i ].y );\n      p[ i ].e = NULL;\n    }\n\n    /* 最左ピンより半時計回りに凸包頂点を一周結ぶ */\n    i = findLeftmostIndex ( );\n    while ( p[ i ].e == NULL )\n    {\n      const int nextIndex = findOtherSideIndex ( i );\n\n      p[ i ].e = &p[ nextIndex ];\n      i = nextIndex;\n    }\n\n    /* 凸包頂点の個数vertexes を数え上げる */\n    for ( i = 0; i < n; ++i )\n    {\n      vertexes += !!( p[ i ].e != NULL );\n    }\n\n    printf ( \"%d\\n\", n - vertexes );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "c,i,p,P,f;main(n){float x[100],y[100],d,t,T;for(;scanf(\"%d\",&n)*n;printf(\"%d\\n\",c)){for(T=2e3,i=n;i--;y[i]>T||(T=y[p=f=i]))scanf(\"%f,%f\",x+i,y+i);c=n;d=0;do{T=9;for(i=n;i--;)i-p?t=atan2f(y[i]-y[p],x[i]-x[p]),t+=8*atan(t<d),t<T?T=t,P=i:0:0;p=P,d=T,c--;}while(p-f);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ndouble x[100],y[100];\n\ndouble len(int a,int b){\n  return  sqrt( (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]) );\n}\n\nint straight(int d, int a, int b, int c){\n  if(fabs( (y[a]-y[b]) / (x[a]-x[b]) ) - fabs( (y[b]-y[c])/(x[b]-x[c])) < 1e-10){\n    if(x[d]>x[a] && x[d]>x[b] && x[d]>x[c])return 1;\n    if(x[d]<x[a] && x[d]<x[b] && x[d]<x[c])return 1;\n  }\n  return 0;\n}\n\ndouble flon(int a,int b,int c){\n  double s;\n  double la,lb,lc;\n  la = len(b,c);\n  lb = len(a,c);\n  lc = len(a,b);\n  s = (la+lb+lc)/2.0;\n  return sqrt(s*(s-la)*(s-lb)*(s-lc));\n}\n  \nint inter(int x,int a,int b,int c){\n  if(flon(a,b,x)+flon(a,c,x)+flon(b,c,x) > flon(a,b,c) + 1e-10)return 0;\n  else return 1;\n}\n\nint band(int i,int j,int k,int l){\n  if(straight(i,j,k,l))return 0;\n  if(inter(i,j,k,l))return 1;\n  return 0;\n}\n  \n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int tmp;\n  int unuse[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&x[i],&y[i]);\n      unuse[i] = 0;\n    }\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<n-2;j++){\n\tif(j==i || unuse[j])continue;\n\tfor(k=j+1;k<n-1;k++){\n\t  if(k==i || unuse[k])continue;\n\t  for(l=k+1;l<n;l++){\n\t    if(l==i || unuse[l])continue;\n\t    if(band(i,j,k,l)){\n\t      unuse[i] = 1;\n\t      break;\n\t    }\n\t  }\n\t  if(unuse[i])break;\n\t}\n\tif(unuse[i])break;\n      }\n    }\n      \n    tmp = 0;\n    for(i=0;i<n;i++){\n      if(unuse[i])tmp++;\n    }\n      \n    printf(\"%d\\n\",tmp);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100\n\n/** 平面座標を表す */\nstruct Point\n{\n  /** x 座標 */\n  double x;\n  /** y 座標 */\n  double y;\n  /** グラフ表現用 */\n  struct Point *e;\n};\n\n/** ピン数 */\nstatic int n;\n/** ピン座標 */\nstatic struct Point p[ N ];\n\n/** 2 ベクトル(x1, y1), (x2, y2) の外積を求める． */\nstatic double\nouterProduct (\n  double x1,\n  double y1,\n  double x2,\n  double y2\n  )\n{\n  return ( x1 * y2 - y1 * x2 );\n}\n\n/** 頂点p[ idx ] より最も進行方向左側に存在する頂点を探索する． */\nstatic int\nfindOtherSideIndex (\n  int idx\n  )\n{\n  int otherSideIndex = !( idx ); /*< ( idx == 0 ? 1 : 0 ) */\n  int i;\n\n  for ( i = 1; i < n; ++i )\n  {\n    const double det\n      = outerProduct (\n          p[ otherSideIndex ].x - p[ idx ].x,\n          p[ otherSideIndex ].y - p[ idx ].y,\n          p[ i ].x - p[ idx ].x,\n          p[ i ].y - p[ idx ].y\n          );\n\n    /* 頂点p[ idx ] は探索対象から除く */\n    if ( i == idx ) continue ;\n\n    if ( det <= 0. )\n    {\n      otherSideIndex = i;\n    }\n  }\n\n  return ( otherSideIndex );\n}\n\n/** 左端ピンのインデックスを探索する． */\nstatic int\nfindLeftmostIndex (\n  void\n  )\n{\n  int leftmostIndex = 0;\n  int i;\n\n  for ( i = 1; i < n; ++i )\n  {\n    if ( p[ i ].x < p[ leftmostIndex ].x )\n      leftmostIndex = i;\n  }\n\n  return ( leftmostIndex );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int vertexes = 0;\n\n    scanf ( \" %d\", &n );\n    if ( n == 0 ) break ;\n    for ( i = 0; i < n; ++i )\n    {\n      scanf ( \" %lf,%lf\", &p[ i ].x, &p[ i ].y );\n      p[ i ].e = NULL;\n    }\n\n    /* 最左ピンより半時計回りに凸包頂点を一周結ぶ */\n    i = findLeftmostIndex ( );\n    while ( p[ i ].e == NULL )\n    {\n      const int nextIndex = findOtherSideIndex ( i );\n\n      printf ( \"==>%d\\n\", i );\n      p[ i ].e = &p[ nextIndex ];\n      i = nextIndex;\n    }\n\n    /* 凸包頂点の個数vertexes を数え上げる */\n    for ( i = 0; i < n; ++i )\n    {\n      vertexes += !!( p[ i ].e != NULL );\n    }\n\n    printf ( \"%d\\n\", n - vertexes );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define GRADIENT_MIN (0)\n#define GRADIENT_MAX (1)\n\nint find(int n, double list[100][2], double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, m, g;\n\n\tm = copysign(INFINITY, max ? -1.0 : 1.0);\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(list[i][0]) || list[i][0] < p[0])\n\t\t\tcontinue;\n\n\t\tdx = p[0] - list[i][0];\n\t\tdy = p[1] - list[i][1];\n\t\tif (dx == 0.0)\n\t\t\tg = copysign(INFINITY, -dy);\n\t\telse\n\t\t\tg = dy / dx; \n\n\t\tif (max ? (m < g) : (m > g)) {\n\t\t\tm = g;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\tp[0] = list[midx][0];\n\tp[1] = list[midx][1];\n\treturn midx;\n}\n\nvoid input(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i, left;\n\n\tp0[0] = 1001.0;\n\tp1[0] = -1001.0;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", list[i], list[i]+1);\n\t\tif (p0[0] > list[i][0]) {\n\t\t\tp0[0] = list[i][0];\n\t\t\tp0[1] = list[i][1];\n\t\t\tleft = i;\n\t\t}\n\t\tif (p1[0] < list[i][0]) {\n\t\t\tp1[0] = list[i][0];\n\t\t\tp1[1] = list[i][1];\n\t\t}\n\t}\n\tlist[left][0] = list[left][1] = NAN;\n}\n\nvoid rm_vertex(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i;\n\tdouble p[2];\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MAX);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MIN);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n}\n\nint solve(int n) {\n\tdouble list[100][2], p0[2], p1[2];\n\tint i, count;\n\n\tinput(n, list, p0, p1);\n\trm_vertex(n, list, p0, p1);\n\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (!isnan(list[i][0]))\n\t\t\tcount++;\n\t}\n\treturn count - 1;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){double k,t;for(;~scanf(\"%d\",&n),j=n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++){k=o(0,i,100);t=(p[i].x-b.x)*(p[i].x-b.x)+(p[i].y-b.y)*(p[i].y-b.y);k*=k/t;if(b.x>p[i].x)k=-k;p[i].k=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define GRADIENT_MIN (0)\n#define GRADIENT_MAX (1)\n\nint find(int n, double list[100][2], double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, m, g;\n\n\tm = copysign(INFINITY, max ? -1.0 : 1.0);\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(list[i][0]) || list[i][0] < p[0])\n\t\t\tcontinue;\n\n\t\tdx = p[0] - list[i][0];\n\t\tdy = p[1] - list[i][1];\n\t\tg = (dx != 0.0) ? (dy / dx) : copysign(INFINITY, -dy);\n\n\t\tif (max ? (m < g) : (m > g)) {\n\t\t\tm = g;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\tp[0] = list[midx][0];\n\tp[1] = list[midx][1];\n\treturn midx;\n}\n\nvoid input(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i, left;\n\n\tp0[0] = 1001.0;\n\tp1[0] = -1001.0;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", list[i], list[i]+1);\n\t\tif (p0[0] > list[i][0]) {\n\t\t\tp0[0] = list[i][0];\n\t\t\tp0[1] = list[i][1];\n\t\t\tleft = i;\n\t\t}\n\t\tif (p1[0] < list[i][0]) {\n\t\t\tp1[0] = list[i][0];\n\t\t\tp1[1] = list[i][1];\n\t\t}\n\t}\n\tlist[left][0] = list[left][1] = NAN;\n}\n\nvoid rm_vertex(int n, double list[100][2], double p0[2], double p1[2]) {\n\tint i;\n\tdouble p[2];\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MAX);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MIN);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n}\n\nint solve(int n) {\n\tdouble list[100][2], p0[2], p1[2];\n\tint i, count;\n\n\tinput(n, list, p0, p1);\n\trm_vertex(n, list, p0, p1);\n\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (!isnan(list[i][0]))\n\t\t\tcount++;\n\t}\n\treturn count - 1;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ Volume 0 Problem 0068\n\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint n, n_remain;\n\tdouble pin[100][2];\n\tint use[100];\n\tdouble max_x, min_x, max_y, min_y;\n\tdouble r, min_r;\n\tint start, now, next;\n\tint i;\n\tint phase;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tn_remain = n;\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%lf,%lf\", &pin[i][0], &pin[i][1]);\t\t\n\t\t\tuse[i] = 0;\n\t\t}\n\t\t\n\t\tmax_x = min_x = pin[0][0];\n\t\tmax_y = min_y = pin[0][1];\n\t\tstart = 0;\n\t\tfor (i = 1; i < n; i++){\n\t\t\tif (pin[i][0] < min_x){\n\t\t\t\tmin_x = pin[i][0];\n\t\t\t}\n\t\t\tif (pin[i][0] > max_x){\n\t\t\t\tmax_x = pin[i][0];\n\t\t\t}\n\t\t\tif (pin[i][1] < min_y){\n\t\t\t\tmin_y = pin[i][1];\n\t\t\t}\n\t\t\tif (pin[i][1] > max_y){\n\t\t\t\tmax_y = pin[i][1];\n\t\t\t}\n\t\t\tif (pin[i][1] < pin[start][1]){\n\t\t\t\tstart = i;\n\t\t\t}\n\t\t\tif (pin[i][1] == pin[start][1]){\n\t\t\t\tif (pin[i][0] < pin[start][0]){\n\t\t\t\t\tstart = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tprintf(\"<min_x=%lf max_x=%lf min_x=%lf max_y=%lf, start:%d>\\n\", min_x, max_x, min_y, max_y, start);\n\t\t\n\t\tnow = start;\n\t\tphase = 1;\n\t\twhile (1){\n\t\t\tmin_r = 9999999999;\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tif (use[i] == 0 && i != now){\n\t\t\t\t\tif (pin[now][0] == max_x){\n\t\t\t\t\t\tphase = 2;\n\t\t\t\t\t}\n\t\t\t\t\tif (pin[now][1] == max_y){\n\t\t\t\t\t\tphase = 3;\n\t\t\t\t\t}\n\t\t\t\t\tif (pin[now][0] == min_x){\n\t\t\t\t\t\tphase = 4;\n\t\t\t\t\t}\n\n//\t\t\t\t\tprintf(\"<Phase=%d>\", phase);\n\t\t\t\t\tif (pin[now][1] == min_y){\n\t\t\t\t\t\tif (i != start && pin[i][1] == pin[now][1] && pin[i][0] > pin[now][0]){\n//\t\tprintf(\"(min_y)\");\n\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pin[now][0] == max_x){\n\t\t\t\t\t\tif (pin[i][0] == pin[now][0] && pin[i][1] > pin[now][1]){\n//\t\tprintf(\"(max_x)\");\n\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pin[now][1] == max_y){\n\t\t\t\t\t\tif (pin[i][1] == pin[now][1] && pin[i][0] < pin[now][0]){\n//\t\tprintf(\"(max_y)\");\n\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pin[now][0] == min_x){\n\t\t\t\t\t\tif (pin[i][0] == pin[now][0] && pin[i][1] < pin[now][1]){\n//\t\tprintf(\"(min_x)\");\n\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t\tprintf(\"[A %d %d]\", i, now);\n\n\t\t\t\t\tif (phase == 1){\n\t\t\t\t\t\tif (pin[i][0] != pin[now][0] && pin[i][1] > pin[now][1]){\n\t\t\t\t\t\t\tr = ((pin[i][1] - pin[now][1]) / (pin[i][0] - pin[now][0]));\n\t\t\t\t\t\t\tif (r >= 0 && r < min_r){\n\t\t\t\t\t\t\t\tmin_r = r;\n\t\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (phase == 2){\n\t\t\t\t\t\tif (pin[i][0] != pin[now][0] && pin[i][0] < pin[now][0]){\n\t\t\t\t\t\t\tr = ((pin[i][1] - pin[now][1]) / (pin[i][0] - pin[now][0]));\n\t\t\t\t\t\t\tif (r <= 0 && r < min_r){\n\t\t\t\t\t\t\t\tmin_r = r;\n\t\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (phase == 3){\n\t\t\t\t\t\tif (pin[i][0] != pin[now][0] && pin[i][1] < pin[now][1]){\n\t\t\t\t\t\t\tr = ((pin[i][1] - pin[now][1]) / (pin[i][0] - pin[now][0]));\n\t\t\t\t\t\t\tif (r >= 0 && r < min_r){\n\t\t\t\t\t\t\t\tmin_r = r;\n\t\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (phase == 4){\n\t\t\t\t\t\tif (pin[i][0] != pin[now][0] && pin[i][0] > pin[now][0]){\n\t\t\t\t\t\t\tr = ((pin[i][1] - pin[now][1]) / (pin[i][0] - pin[now][0]));\n\t\t\t\t\t\t\tif (r <= 0 && r < min_r){\n\t\t\t\t\t\t\t\tmin_r = r;\n\t\t\t\t\t\t\t\tnext = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tuse[next] = 1;\n\t\t\tn_remain--;\n\n//\t\t\tprintf(\"[%d:%.2lf, %.2lf]\", next, pin[next][0], pin[next][1]);\n\t\t\tif (next == start){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnow = next;\n\t\t}\n\t\tprintf(\"%d\\n\", n_remain);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define jijou(X) ( (X)*(X) )\n\ntypedef struct _node {\n        double x;\n        double y;\n        double cosv;\n} node_t;\n\nint flag = 0;\n\nvoid swap( node_t * nd, int i, int j );\nvoid push( int * stack, int j, int i );\nvoid pop( int * stack, int i );\nvoid printstack( int * stack, int size );\nint grahamscan( node_t * nd, int minpos, int num );\n\nvoid swap( node_t * nd, int i, int j )\n{\n        node_t tmp;\n        tmp.x = nd[i].x;\n        tmp.y = nd[i].y;\n        tmp.cosv = nd[i].cosv;\n        nd[i].x = nd[j].x;\n        nd[i].y = nd[j].y;\n        nd[i].cosv = nd[j].cosv;\n        nd[j].x = tmp.x;\n        nd[j].y = tmp.y;\n        nd[j].cosv = tmp.cosv;\n}\n\n/* push( node * stack, int j, int i ) stackのi番目にjをpush */\nvoid push( int * stack, int j, int i )\n{\n        stack[i] = j;\n}\n\n/* pop( node_t * stack, int i ) stackのi番目の値をpop */\nvoid pop( int * stack, int i )\n{\n        stack[i] = stack[i+1];\n}\n\n//void printstack( int * stack, int i )\n//{\n//      printf( \"stack size %d\\n\", i );\n///     while ( i > -1 ) {\n//              printf( \"%2d : %2d\\n\", i, stack[i] );\n//              i--;\n//      }\n//}\n\nint grahamscan( node_t * nd, int minpos, int num )\n{\n        int stack[100];\n        node_t vecbase, tmp;\n        int i, j, tmppos;\n        double dist1, dist2;\n\n\n        /* 最下かつ最左の点を配列の先頭に移動する */\n        swap( nd, 0, minpos );\n\n\n        /* 最下かつ最左の点とのcosの値を求める */\n        vecbase.x = 1;\n        vecbase.y = 0;\n        for ( i = 1 ; i < num ; i++ ) {\n                tmp.x = nd[i].x - nd[0].x;\n                tmp.y = nd[i].y - nd[0].y;\n                nd[i].cosv = ( vecbase.x * tmp.x + vecbase.y * tmp.y ) /\n                        ( sqrt( jijou( vecbase.x ) + jijou( vecbase.y ) ) * sqrt( jijou( tmp.x ) + jijou( tmp.y ) ) ) ;\n        }\n\n\n        /* 最下かつ最左の点から反時計周りに点を整列 */\n        for ( i = 1 ; i < num ; i++ ) {\n                for ( j = num-1 ; j > i ; j-- ) {\n                        if ( nd[j].cosv > nd[i].cosv ) {\n                                swap( nd, j, i );\n                        } else if ( nd[j].cosv == nd[i].cosv ) {\n                                /* 角度が同じ場合，距離が遠いものを選択する */\n                                dist1 = sqrt( jijou( nd[j].x ) + jijou( nd[j].y ) );\n                                dist2 = sqrt( jijou( nd[i].x ) + jijou( nd[i].y ) );\n                                if ( dist1 > dist2  ) {\n                                        swap( nd, j, i );\n                                }\n                                tmppos = j;\n                                while ( tmppos+1 < num ) {\n                                        nd[tmppos].x = nd[tmppos+1].x;\n                                        nd[tmppos].y = nd[tmppos+1].y;\n                                        nd[tmppos].cosv = nd[tmppos+1].cosv;\n                                        tmppos++;\n                                }\n                                num--;\n                        }\n                }\n        }\n\n        /* push( stack, j, i ) stackのi番目にjをpush */\n        push( stack, 0, 0 );\n        push( stack, 1, 1 );\n        push( stack, 2, 2 );\n        i = 2; j = 3;   // iは現在のスタックの一番上を示す\n        while ( j < num ) {\n                i++;\n                push( stack, j, i );\n                j++;\n                //printf( \"%d : (%f,%f), %d : (%f,%f), %d : (%f,%f)\\n\", i-2, nd[stack[i-2]].x, nd[stack[i-2]].y, i-1, nd[stack[i-1]].x, nd[stack[i-1]].y, i, nd[stack[i]].x, nd[stack[i]].y );\n                while (   nd[stack[i-2]].x * nd[stack[i-1]].y + nd[stack[i-1]].x * nd[stack[i]].y + nd[stack[i]].x * nd[stack[i-2]].y\n                        < nd[stack[i-2]].y * nd[stack[i-1]].x + nd[stack[i-1]].y * nd[stack[i]].x + nd[stack[i]].y * nd[stack[i-2]].x )\n                {\n                        pop( stack, i-1 );\n                        //printstack( stack, i );\n                        i--;\n                }\n        }\n        return i+1;\n}\n\n\nint main()\n{\n        node_t nd[100];\n        int i, j, first, min;\n\n        while ( scanf( \"%d\", &i ) == 1 ) {\n                if ( i == 0 ) { break; }\n                first = 1;\n                for ( j = 0 ; j < i ; j++ ) {\n                        scanf( \"%lf,%lf\", &nd[j].x, &nd[j].y );\n                        if ( first == 1 ) {\n                                first = 0;\n                                min = 0;\n                        } else { /* 最下かつ最左の点を記録する */\n                                if ( nd[min].y > nd[j].y ) {\n                                        min = j;\n                                } else if ( nd[min].y == nd[j].y ) {\n                                        if ( nd[min].x > nd[j].x ) {\n                                                min = j;\n                                        }\n                                }\n                        }\n                }\n                flag = 0;\n                printf( \"%d\\n\", i-grahamscan( nd, min, i ) );\n                if ( flag == 1 ) { printf( \"same rage\\n\" ); }\n        }\n\n        return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nstruct POINT{\n\tdouble x,y;\n};\n\ndouble area(double a,double b,double c){\n\tdouble s;\n\n\ts = (a+b+c)/2.0;\n\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nint main(){\n\tint h,i,j,k,l,n,cnt;\n\tint flag[100];\n\tdouble len[6],s[4];\n\tstruct POINT p[4];\n\tstruct POINT pin[100];\n\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%lf,%lf\",&pin[i].x,&pin[i].y);\n\t\t}\n\n\t\tmemset(flag,0,sizeof(flag));\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(flag[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp[0] = pin[i];\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(i == j || flag[j]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp[1] = pin[j];\n\t\t\t\tfor(k = 0;k < n;k++){\n\t\t\t\t\tif(i == k || j == k || flag[k]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tp[2] = pin[k];\n\t\t\t\t\tfor(h = 0;h < 3;h++){\n\t\t\t\t\t\t\tlen[h] = sqrt(pow(p[(h+1)%3].x-p[h].x,2)+pow(p[(h+1)%3].y-p[h].y,2));\n\t\t\t\t\t}\n\t\t\t\t\ts[3] = area(len[0],len[1],len[2]);\n\t\t\t\t\tfor(l = 0;l < n;l++){\n\t\t\t\t\t\tif(i == l || j == l || k == l || flag[l]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp[3] = pin[l];\n\t\t\t\t\t\tfor(h = 0;h < 3;h++){\n\t\t\t\t\t\t\tlen[3+h] = sqrt(pow(p[3].x-p[h].x,2)+pow(p[3].y-p[h].y,2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(h = 0;h < 3;h++){\n\t\t\t\t\t\t\ts[h] = area(len[h],len[3+h],len[(h+1)%3+3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fabs(s[3]-s[0]-s[1]-s[2])/(s[0]+s[1]+s[2]) < 1e-5){\n\t\t\t\t\t\t\tflag[l] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(flag[i]){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define EPS 0.00001\ntypedef struct p{\n\tdouble x,y;\n}P;\nint compP(const void *p,const void *q){\n\tP *a=(P *)p,*b=(P *)q;\n\tif(a->x == b->x)return a->y - b->y;\n\telse return a->x - b->x;\n}\n//double add(double a,double b)\nP mi(P a,P b){\n\treturn (P){a.x-b.x,a.y-b.y};\n}\ndouble det(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\nint convex(P v[],P nv[],int n){\n\tint i,k,t;\n\tqsort(v,n,sizeof(P),compP);\n\tfor(i=0,k=0;i<n;i++){\n\t\twhile(k>1 && det(mi(nv[k-1],nv[k-2]),mi(v[i],nv[k-1]))<EPS)k--;\n\t\tnv[k++]=v[i];\n\t}\n\tfor(i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t && det(mi(nv[k-1],nv[k-2]),mi(v[i],nv[k-1]))<EPS)k--;\n\t\tnv[k++]=v[i];\n\t}\n\t//nv[k]->x=10000.0;\n\treturn k-1;\n}\nint main(){\n\tint i,j,n;\n\tP q[105],sq[230];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(i=0;i<n;i++)\n\t\t\tscanf(\"%lf,%lf\",&q[i].x,&q[i].y);\n\t\tj=convex(q,sq,n);\n\t\t//for(i=0;i<j;i++)printf(\"%lf %lf\\n\",sq[i].x,sq[i].y);\n\t\tprintf(\"%d\\n\",n-j);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nc,i,p,P,f;main(n){float x[100],y[100],d,t,T;while(scanf(\"%d\",&n),n){T=2000;for(i=0;i<n;i++){scanf(\"%f,%f\",x+i,y+i);if(y[i]<T){T=y[i];p=f=i;}}c=n;d=0;do{T=9;for(i=0;i<n;i++){if(i!=p){t=atan2f(y[i]-y[p],x[i]-x[p])-d;while(t<0)t+=2*M_PI;if(t<T){T=t;P=i;}}}p=P;d+=T;c--;}while(p!=f);printf(\"%d\\n\",c);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc,char* argv[]){\n  int n,i;\n  double array_x[100];\n  double array_y[100];\n\n  for(;;){\n    double smallest_x = 9999.0,smallest_y = 9999.0;\n    double cur_rad = 0;\n    int cur = 0,smallest_cur = 0;\n    int count = 0;\n    \n    scanf(\"%d\",&n);\n    if(n == 0){\n      break;\n    }\n\n    for(i = 0; i < n; i++){\n      scanf(\"%lf,%lf\",&array_x[i],&array_y[i]);\n      if(smallest_y > array_y[i]){\n\tsmallest_y = array_y[i];\n\tsmallest_x = array_x[i];\n\tcur = i;\n      }else if(smallest_y == array_y[i]){\n\tif(smallest_x > array_x[i]){\n\t  smallest_x = array_x[i];\n\t  cur = i;\n\t}\n      }\n    }\n\n    smallest_cur = cur;\n\n    for(;;){\n      int next_cur;\n      double next_rad = 0;\n      double smallest_rad = 2*M_PI;\n      \n      //printf(\"cur = %d\\n\",cur);\n\n      for(i = 0; i < n; i++){\n\tdouble tmp,tmp2;\n\tif(i == cur){continue;}\n\ttmp = atan2(array_y[i]-array_y[cur],array_x[i]-array_x[cur]);\n\tif(tmp <= 0){tmp += M_PI*2;}\n\t//printf(\"cur = %d, i = %d rad = %lf cur_rad = %lf smallest = %lf\\n\",cur,i,tmp,cur_rad,smallest_rad);\n\ttmp2 = tmp - cur_rad;\n\tif(tmp2 <= 0){\n\t  tmp2 += 2*M_PI;\n\t}\n\tif(smallest_rad > tmp2){\n\t  smallest_rad = tmp2;\n\t  next_rad = tmp;\n\t  next_cur = i;\n\t}\n      }\n\n      count++;\n\n      if(next_cur == smallest_cur){\n\tbreak;\n      }else{\n\tcur = next_cur;\n\tcur_rad = next_rad;\n      }\n    }\n\n    printf(\"%d\\n\",n-count);\n\n    \n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[100],b;m,v[100],n,j,r;z(w*c,w*d){r=c->k>d->k?-1:1;}double o(w q,w r,w s){return q.x*(r.y-s.y)+r.x*(s.y-q.y)+s.x*(q.y-r.y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;for(i=1;i<n;i++)p[i].k=(p[i].x-b.x)/hypot(p[i].x-b.x,p[i].y-b.y);qsort(p+1,n-1,24,z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(w[v[j-1]],w[v[j]],w[i])<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define SQ(x) ((x) * (x))\n\ntypedef struct {\n\tdouble x;\n\tdouble y;\n} POINT;\n\ndouble area(double x, double y, double z)\n{\n    double s;\n    s = (x + y + z) / 2.00;\n    return (sqrt(s * (s - x) * (s - y) * (s - z)));\n}\n\nint main(void)\n{\n\tPOINT array[100];\n    POINT a, b, c, p;\n    char flag[100], p_flag, m_flag;\n    int count;\n    int i, j, k, l;\n    int n;\n    double ab, bc, ca, ap, bp, cp;\n    \n    while (1){\n        scanf(\"%d\", &n);\n\t\t\n        if (n == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%lf,%lf\", &array[i].x, &array[i].y);\n        }\n        \n        memset(flag, 0, sizeof(flag));\n        \n        for (i = 0; i < n; i++){\n            if (flag[i] == 1){\n                continue;\n            }\n            a = array[i];\n            for (j = 0; j < n; j++){\n                if (i == j || flag[j] == 1){\n                    continue;\n                }\n                b = array[j];\n                for (k = 0; k < n; k++){\n                    if (i == k || j == k ||flag[k] == 1){\n                        continue;\n                    }\n                    c = array[k];\n                    ab = sqrt(SQ(a.x - b.x) + SQ(a.y - b.y));\n\t\t            bc = sqrt(SQ(b.x - c.x) + SQ(b.y - c.y));\n            \t\tca = sqrt(SQ(c.x - a.x) + SQ(c.y - a.y));\n                    for (l = 0; l < n; l++){\n                        if (l == i || l == j || l == k || flag[l] == 1){\n                            continue;\n                        }\n                        p = array[l];\n                        ap = sqrt(SQ(a.x - p.x) + SQ(a.y - p.y));\n\t\t                bp = sqrt(SQ(b.x - p.x) + SQ(b.y - p.y));\n\t\t                cp = sqrt(SQ(c.x - p.x) + SQ(c.y - p.y));\n\t\t                \n\t\t                if (fabs(area(ab ,bc ,ca) - area(ap, bp, ab) - area(ap, cp, ca) - area(bp, cp, bc)) < 1e-5){\n                            flag[l] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        count = 0;\n        \n        for (i = 0; i < n; i++){\n            if (flag[i] == 1){\n                count++;\n            }\n        }\n        \n\t\tprintf(\"%d\\n\", count);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ndouble x[100],y[100];\n\ndouble len(int a,int b){\n  return  sqrt( (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]) );\n}\n\ndouble flon(int a,int b,int c){\n  double s;\n  double la,lb,lc;\n  la = len(b,c);\n  lb = len(a,c);\n  lc = len(a,b);\n  s = (la+lb+lc)/2.0;\n  return sqrt(s*(s-la)*(s-lb)*(s-lc));\n}\n  \nint inter(int x,int a,int b,int c){\n  if(flon(a,b,x)+flon(a,c,x)+flon(b,c,x)-flon(a,b,c)<1e-10)return 1;\n  else return 0;\n}\n\nint band(int i,int j,int k,int l){\n  if(inter(i,j,k,l))return 1;\n  return 0;\n}\n  \n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int tmp;\n  int unuse[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&x[i],&y[i]);\n      unuse[i] = 0;\n    }\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n-2;j++){\n\tif(j==i)continue;\n\tfor(k=j+1;k<n-1;k++){\n\t  if(k==i)continue;\n\t  for(l=k+1;l<n;l++){\n\t    if(l==i)continue;\n\t    if(band(i,j,k,l)){\n\t      unuse[i] = 1;\n\t      break;\n\t    }\n\t  }\n\t  if(unuse[i])break;\n\t}\n\tif(unuse[i])break;\n      }\n    }\n      \n    tmp = 0;\n    for(i=0;i<n;i++){\n      if(unuse[i])tmp++;\n    }\n      \n    printf(\"%d\\n\",tmp);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;double k,t;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++)p[i].k=o(0,i,100)/hypot(p[i].x-b.x,p[i].y-b.y);qsort(p+1,n-1,sizeof(w),z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x,y;\n} xy_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst xy_t* a=(const xy_t*)x;\n\tconst xy_t* b=(const xy_t*)y;\n\tif((a->x)>(b->x))return 1;\n\tif((a->x)<(b->x))return -1;\n\tif((a->y)>(b->y))return 1;\n\tif((a->y)<(b->y))return -1;\n\treturn 0;\n}\n\nint zahyou_num;\nxy_t zahyou[100];\n\nint th_up_n;\nint th_down_n;\nxy_t th_up[100];\nxy_t th_down[100];\n\nint main(void) {\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d\",&zahyou_num);\n\t\tif(zahyou_num==0)break;\n\t\tfor(i=0;i<zahyou_num;i++) {\n\t\t\tscanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y);\n\t\t}\n\t\tqsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp);\n\t\t//sita no totu-ho\n\t\tth_down_n=1;\n\t\tth_down[0].x=zahyou[0].x;\n\t\tth_down[0].y=zahyou[0].y;\n\t\tfor(i=1;i<zahyou_num;i++) {\n\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\twhile(th_down_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_down[th_down_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_down[th_down_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_down[th_down_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_down[th_down_n-1].x==th_down[th_down_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_down[th_down_n-1].y<th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_down[th_down_n-1].y-th_down[th_down_n-2].y)/\n\t\t\t\t\t\t   (th_down[th_down_n-1].x-th_down[th_down_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_down_n--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tth_down[th_down_n].x=zahyou[i].x;\n\t\t\tth_down[th_down_n].y=zahyou[i].y;\n\t\t\tth_down_n++;\n\t\t}\n\t\t//ue no totu-ho\n\t\tth_up_n=1;\n\t\tth_up[0].x=zahyou[zahyou_num-1].x;\n\t\tth_up[0].y=zahyou[zahyou_num-1].y;\n\t\tfor(i=zahyou_num-2;i>=0;i--) {\n\t\t\tif(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\twhile(th_up_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_up[th_up_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_up[th_up_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_up[th_up_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_up[th_up_n-1].x==th_up[th_up_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_up[th_up_n-1].y<th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/\n\t\t\t\t\t\t   (th_up[th_up_n-1].x-th_up[th_up_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_up_n--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tth_up[th_up_n].x=zahyou[i].x;\n\t\t\tth_up[th_up_n].y=zahyou[i].y;\n\t\t\tth_up_n++;\n\t\t}\n\t\tprintf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define GRADIENT_MIN (0)\n#define GRADIENT_MAX (1)\n\nint find(size_t n, double list[100][2], double p[2], int max) {\n\tint i, midx;\n\tdouble dx, dy, m, g;\n\n\tm = copysign(INFINITY, max ? -1.0 : 1.0);\n\tfor (i = 0; i < n; i++) {\n\t\tif (isnan(list[i][0]) || list[i][0] < p[0])\n\t\t\tcontinue;\n\n\t\tdx = p[0] - list[i][0];\n\t\tdy = p[1] - list[i][1];\n\t\tg = (dx != 0.0) ? (dy / dx) : copysign(INFINITY, -dy);\n\n\t\tif (max ? (m < g) : (m > g)) {\n\t\t\tm = g;\n\t\t\tmidx = i;\n\t\t}\n\t}\n\tp[0] = list[midx][0];\n\tp[1] = list[midx][1];\n\treturn midx;\n}\n\nvoid input(size_t n, double list[100][2], double p0[2], double p1[2]) {\n\tint i, left;\n\n\tp0[0] = 1001.0;\n\tp1[0] = -1001.0;\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\" %lf,%lf \", list[i], list[i]+1);\n\t\tif (p0[0] > list[i][0]) {\n\t\t\tp0[0] = list[i][0];\n\t\t\tp0[1] = list[i][1];\n\t\t\tleft = i;\n\t\t}\n\t\tif (p1[0] < list[i][0]) {\n\t\t\tp1[0] = list[i][0];\n\t\t\tp1[1] = list[i][1];\n\t\t}\n\t}\n\tlist[left][0] = list[left][1] = NAN;\n}\n\nvoid rm_vertex(size_t n, double list[100][2], double p0[2], double p1[2]) {\n\tint i;\n\tdouble p[2];\n\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MAX);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n\tp[0] = p0[0];\n\tp[1] = p0[1];\n\twhile (1) {\n\t\ti = find(n, list, p, GRADIENT_MIN);\n\t\tif (p[0] == p1[0] && p[1] == p1[1])\n\t\t\tbreak;\n\t\tlist[i][0] = list[i][1] = NAN;\n\t}\n}\n\nint solve(size_t n) {\n\tdouble list[100][2], p0[2], p1[2];\n\tint i, count;\n\n\tinput(n, list, p0, p1);\n\trm_vertex(n, list, p0, p1);\n\n\tfor (i = count = 0; i < n; i++) {\n\t\tif (!isnan(list[i][0]))\n\t\t\tcount++;\n\t}\n\treturn count - 1;\n}\n\nint main(void) {\n\tint n;\n\n\twhile (1) {\n\t\tscanf(\" %d \", &n);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:1;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){for(;j=scanf(\"%d\",&n)+~n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++)p[i].k=o(0,i,100)/hypot(p[i].x-b.x,p[i].y-b.y);qsort(p+1,n-1,24,z);*v=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct{\n\tdouble x,y,key;\n}point;\npoint pnt[101];\nint n;\nint cmp(const void*a,const void*b){\n\tconst point*c=a,*d=b;\n\treturn c->key>d->key?-1:c->key<d->key;\n}\ndouble outer(int q,int r,int s){\n\treturn pnt[q].x*(pnt[r].y-pnt[s].y)+pnt[r].x*(pnt[s].y-pnt[q].y)+pnt[s].x*(pnt[q].y-pnt[r].y);\n}\nint main(void){\n\tint i,m,tb[100],j;\n\tdouble k,t;\n\tpoint bs;\n\tfor(;~scanf(\"%d\",&n),n;){\n\t\tfor(m=i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\",&pnt[i].x,&pnt[i].y);\n\t\t\tif(pnt[m].y>pnt[i].y)m=i;\n\t\t}\n\t\tbs = pnt[m];\n\t\tpnt[m] = *pnt;\n\t\t*pnt = bs;\n\t\t\n\t\tpnt[100].x = bs.x;\n\t\tpnt[100].y = bs.y + 1.0;\n\t\t\n\t\tfor( i = 1; i < n; i++ ){\n\t\t\tk = outer( 0, i, 100 );\n\t\t\tt = (pnt[i].x-bs.x)*(pnt[i].x-bs.x) + (pnt[i].y-bs.y)*(pnt[i].y-bs.y);\n\t\t\tk *= k / t;\n\t\t\tif( bs.x>pnt[i].x ) k = -k;\n\t\t\tpnt[i].key = k;\n\t\t}\n\t\t\n\t\tqsort( pnt+1, n-1, sizeof(point), cmp );\n\t\t\n\t\ttb[0]=0;\n\t\ttb[1]=1;\n\t\ttb[2]=j=2;\n\t\tfor( i = 3; i < n; i++ ){\n\t\t\tfor(;outer(tb[j-1],tb[j],i)<=0;j--);\n\t\t\ttb[++j] = i;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", n - j - 1 );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tdouble x,y;\n} xy_t;\n\nint qsort_comp(const void* x,const void* y) {\n\tconst xy_t* a=(const xy_t*)x;\n\tconst xy_t* b=(const xy_t*)y;\n\tif((a->x)>(b->x))return 1;\n\tif((a->x)<(b->x))return -1;\n\tif((a->y)>(b->y))return 1;\n\tif((a->y)<(b->y))return -1;\n\treturn 0;\n}\n\nint zahyou_num;\nxy_t zahyou[100];\n\nint th_up_n;\nint th_down_n;\nxy_t th_up[100];\nxy_t th_down[100];\n\nint main(void) {\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d\",&zahyou_num);\n\t\tif(zahyou_num==0)break;\n\t\tfor(i=0;i<zahyou_num;i++) {\n\t\t\tscanf(\"%lf,%lf\",&zahyou[i].x,&zahyou[i].y);\n\t\t}\n\t\tqsort(zahyou,zahyou_num,sizeof(xy_t),qsort_comp);\n\t\t//sita no totu-ho\n\t\tth_down_n=1;\n\t\tth_down[0].x=zahyou[0].x;\n\t\tth_down[0].y=zahyou[0].y;\n\t\tfor(i=1;i<zahyou_num;i++) {\n\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\twhile(th_down_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_down[th_down_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_down[th_down_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_down[th_down_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_down[th_down_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_down[th_down_n-1].x==th_down[th_down_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_down[th_down_n-1].y<th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else if(th_down[th_down_n-1].y>th_down[th_down_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_down[th_down_n-1].y-th_down[th_down_n-2].y)/\n\t\t\t\t\t\t   (th_down[th_down_n-1].x-th_down[th_down_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_down_n--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tth_down[th_down_n].x=zahyou[i].x;\n\t\t\tth_down[th_down_n].y=zahyou[i].y;\n\t\t\tth_down_n++;\n\t\t}\n\t\t//ue no totu-ho\n\t\tth_up_n=1;\n\t\tth_up[0].x=zahyou[zahyou_num-1].x;\n\t\tth_up[0].y=zahyou[zahyou_num-1].y;\n\t\tfor(i=zahyou_num-2;i>=0;i--) {\n\t\t\tif(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\twhile(th_up_n>1) {\n\t\t\t\t\tdouble k1,k2;\n\t\t\t\t\tif(zahyou[i].x==th_up[th_up_n-1].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(zahyou[i].y<th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=-1e+200;\n\t\t\t\t\t\t} else if(zahyou[i].y>th_up[th_up_n-1].y) {\n\t\t\t\t\t\t\tk1=1e+200;\n\t\t\t\t\t\t} else k1=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk1=(zahyou[i].y-th_up[th_up_n-1].y)/\n\t\t\t\t\t\t   (zahyou[i].x-th_up[th_up_n-1].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(th_up[th_up_n-1].x==th_up[th_up_n-2].x) {\n\t\t\t\t\t\t//INF\n\t\t\t\t\t\tif(th_up[th_up_n-1].y<th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=-1e+200;\n\t\t\t\t\t\t} else if(th_up[th_up_n-1].y>th_up[th_up_n-2].y) {\n\t\t\t\t\t\t\tk2=1e+200;\n\t\t\t\t\t\t} else k2=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk2=(th_up[th_up_n-1].y-th_up[th_up_n-2].y)/\n\t\t\t\t\t\t   (th_up[th_up_n-1].x-th_up[th_up_n-2].x);\n\t\t\t\t\t}\n\t\t\t\t\tif(k1>=k2)break;\n\t\t\t\t\tth_up_n--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tth_up[th_up_n].x=zahyou[i].x;\n\t\t\tth_up[th_up_n].y=zahyou[i].y;\n\t\t\tth_up_n++;\n\t\t}\n\t\tprintf(\"%d\\n\",zahyou_num-(th_down_n+th_up_n-2));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint main(){\n  int i;\n  int c,n,si,ei,ni;\n  double ca,ba,mina;\n  for(;;){\n    scanf(\"%d\",&n);\n    if(n==0)\n      break;\n    int f[n];\n    double x[n],y[n];\n    memset(f,0,sizeof(f));\n    si=0;\n    ei=0;\n    for(i=0;i<n;i++){\n      scanf(\"%lf,%lf\",&x[i],&y[i]);\n      if(y[i]>y[si]){\n\tsi=i;\n\tei=i;\n      }else if(y[i]==y[si]){\n\tif(x[i]<x[si])\n\t  si=i;\n\tif(x[i]>x[ei])\n\t  ei=i;\n      }\n    }\n    c=n;\n    ba=-M_PI;\n    for(;;){\n      mina=M_PI;\n      for(i=0;i<n;i++){\n\tif(i!=si&&f[i]==0){\n\t  ca=atan2(y[i]-y[si],x[i]-x[si]);\n\t  if(ba<ca&&mina>ca){\n\t    mina=ca;\n\t    ni=i;\n\t  }\n\t}\n      }\n      if(si!=ei){\n\tf[si]=1;\n\tc--;\n      }\n      ba=mina;\n      si=ni;\n      if(si==ei){\n\tc--;\n\tbreak;\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define SQ(x) ((x) * (x))\n\ntypedef struct {\n\tdouble x;\n\tdouble y;\n} POINT;\n\ndouble area(double x, double y, double z)\n{\n    double s;\n    s = (x + y + z) / 2.00;\n    return (sqrt(s * (s - x) * (s - y) * (s - z)));\n}\n\nint main(void)\n{\n\tPOINT array[100];\n    POINT a, b, c, p;\n    char flag[100], p_flag, m_flag;\n    int count;\n    int i, j, k, l;\n    int n;\n    double ab, bc, ca, ap, bp, cp;\n    \n    while (1){\n        scanf(\"%d\", &n);\n\t\t\n        if (n == 0){\n            break;\n        }\n        \n        for (i = 0; i < n; i++){\n            scanf(\"%lf,%lf\", &array[i].x, &array[i].y);\n        }\n        \n        memset(flag, 0, sizeof(flag));\n        \n        for (i = 0; i < n; i++){\n            a = array[i];\n            for (j = 0; j < n; j++){\n                if (i == j){\n                    continue;\n                }\n                b = array[j];\n                for (k = 0; k < n; k++){\n                    if (i == k || j == k){\n                        continue;\n                    }\n                    c = array[k];\n                    ab = sqrt(SQ(a.x - b.x) + SQ(a.y - b.y));\n\t\t            bc = sqrt(SQ(b.x - c.x) + SQ(b.y - c.y));\n            \t\tca = sqrt(SQ(c.x - a.x) + SQ(c.y - a.y));\n                    for (l = 0; l < n; l++){\n                        if (l == i || l == j || l == k){\n                            continue;\n                        }\n                        p = array[l];\n                        ap = sqrt(SQ(a.x - p.x) + SQ(a.y - p.y));\n\t\t                bp = sqrt(SQ(b.x - p.x) + SQ(b.y - p.y));\n\t\t                cp = sqrt(SQ(c.x - p.x) + SQ(c.y - p.y));\n\t\t                \n\t\t                if (fabs(area(ab ,bc ,ca) - area(ap, bp, ab) - area(ap, cp, ca) - area(bp, cp, bc)) < 1e-5){\n                            flag[l] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        count = 0;\n        \n        for (i = 0; i < n; i++){\n            if (flag[i] == 1){\n                count++;\n            }\n        }\n        \n\t\tprintf(\"%d\\n\", count);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ndouble x[100],y[100];\n\ndouble len(int a,int b){\n  return  sqrt( (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]) );\n}\n\ndouble flon(int a,int b,int c){\n  double s;\n  double la,lb,lc;\n  la = len(b,c);\n  lb = len(a,c);\n  lc = len(a,b);\n  s = (la+lb+lc)/2.0;\n  return sqrt(s*(s-la)*(s-lb)*(s-lc));\n}\n  \nint inter(int x,int a,int b,int c){\n  if(flon(a,b,x)+flon(a,c,x)+flon(b,c,x)-flon(a,b,c)<1e-10)return 1;\n  else return 0;\n}\n\nint band(int i,int j,int k,int l){\n  if(inter(i,j,k,l))return i;\n  if(inter(j,i,k,l))return j;\n  if(inter(k,i,j,l))return k;\n  if(inter(l,i,j,k))return l;\n  return -1;\n}\n  \n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int tmp;\n  int unuse[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&x[i],&y[i]);\n      unuse[i] = 0;\n    }\n\n    for(i=0;i<n-3;i++){\n      if(!unuse[i]){\n\tfor(j=i+1;j<n-2;j++){\n\t  if(!unuse[j]){\n\t    for(k=j+1;k<n-1;k++){\n\t      if(!unuse[k]){\n\t\tfor(l=k+1;l<n;l++){\n\t\t  if(!unuse[l]){\n\t\t    tmp = band(i,j,k,l);\n\t\t    if(tmp>=0)unuse[tmp] = 1;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n      \n    tmp = 0;\n    for(i=0;i<n;i++){\n      if(unuse[i])tmp++;\n    }\n      \n    printf(\"%d\\n\",tmp);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "typedef struct{double x,y,k;}w;w p[101],b;m,v[100],n,j;z(w*c,w*d){return c->k>d->k?-1:c->k<d->k;}double o(q,r,s){return p[q].x*(p[r].y-p[s].y)+p[r].x*(p[s].y-p[q].y)+p[s].x*(p[q].y-p[r].y);}main(i){double k,t;for(;~scanf(\"%d\",&n),j=n;){for(m=i=0;i<n;i++)scanf(\"%lf,%lf\",&p[i].x,&p[i].y),p[m].y>p[i].y?m=i:0;b=p[m];p[m]=*p;*p=b;p[100].x=b.x;p[100].y=b.y+1;for(i=1;i<n;i++){k=o(0,i,100);t=(p[i].x-b.x)*(p[i].x-b.x)+(p[i].y-b.y)*(p[i].y-b.y);k*=k/t;if(b.x>p[i].x)k=-k;p[i].k=k;}qsort(p+1,n-1,sizeof(w),z);v[0]=0;v[1]=1;v[2]=j=2;for(i=3;i<n;i++){for(;o(v[j-1],v[j],i)<=0;j--);v[++j]=i;}printf(\"%d\\n\",n+~j);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define PI 3.1415926353898\nint main(){\n\tint n,c,i;\n\tint p,pmin,pfirst,f;\n\tdouble x[100],y[100],ymin,dir,t,tmin;\n\twhile(scanf(\"%d\",&n),n){\n\t\tf=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%lf,%lf\",x+i,y+i);\n\t\t\tif(!f || y[i]<ymin) {\n\t\t\t\tymin=y[i];\n\t\t\t\tp=pfirst=i;\n\t\t\t\tf=1;\n\t\t\t}\n\t\t}\n\t\tc=n;\n\t\tdir=0;\n\t\t//printf(\"p(%d) dir=%g\\n\", p, dir);\n\t\tdo{\n\t\t\tf=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(i==p) continue;\n\t\t\t\tt=atan2(y[i]-y[p],x[i]-x[p])-dir;\n\t\t\t\twhile(t<0) t+=2*PI;\n\t\t\t\tif(!f || t<tmin) {\n\t\t\t\t\ttmin=t;\n\t\t\t\t\tpmin=i;\n\t\t\t\t\tf=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp=pmin;\n\t\t\tdir=tmin+dir;\n\t\t\t//printf(\"p(%d) dir=%g\\n\", p, dir);\n\t\t\tc--;\n\t\t} while(p!=pfirst);\n\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n \n#define sfd(type, fn)   type fn(P a\n#define isfd(type, fn)  inline sfd(type, fn)\n#define fd(type, fn)    type fn(P a, P b\n#define ifd(type, fn)   inline fd(type, fn)\n  \ntypedef double frac;\n  \ntypedef struct { frac x, y; } Point, P;\n  \nifd(frac, cross))   { return (a.x * b.y - a.y * b.x);  }\nifd(frac, dot))     { return (a.x * b.x + a.y * b.y);  }\nifd(P, plus))       { return (P){a.x + b.x, a.y + b.y};}\nifd(P, minus))      { return (P){a.x - b.x, a.y - b.y};}\nisfd(P, multi),int x){ return (P){a.x * x, a.y * x};   }\nisfd(P, sq))        { return (P){a.x * a.x, a.y * a.y};}\nisfd(frac, scalar)) { return (a.x + a.y);              }\nisfd(frac, norm))   { return (a.x * a.x + a.y * a.y);  }\n \nfd(int, ccw), P c){\n    b = minus(b, a), c = minus(c, a);\n    if (cross(b, c) > 0) return +1;          // ccw\n    if (cross(b, c) < 0) return -1;          // cw\n    if (dot(b, c) < 0)    return +2;         // c-a-b\n    if (norm(b) < norm(c)) return -2;  // a-b-c\n    return 0;\n}\nfd(int, in_tri), P c, P p){ return (ccw(a, b, p) == ccw(b, c, p) && ccw(b, c, p) == ccw(c, a, p)); }\n  \nint input_p(P *p) { return scanf(\"%lf,%lf\", &p->x, &p->y); }\nint cmp_p(P *a, P *b){ return (a->x == b->x ? a->y - b->y : a->x - b->x); }\nint graham_scan(P *vs, int n)\n{\n\tint k = 0, i, t;\n\tP ch[256];\n\tqsort(vs, n, sizeof(P), cmp_p);\n\tfor (i = 0; i < n; ch[k++] = vs[i++]){\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], vs[i]) <= 0) --k;\n\t}\n\tfor (i = n - 2, t = k + 1; i >= 0; ch[k++] = vs[i--]){\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], vs[i]) <= 0) --k;\n\t}\n\treturn (k - 1);\n}\n\nint main(void)\n{\n    P ps[128];\n    int n, i;\n \n    while (scanf(\"%d\", &n), n){\n\t    for (i = 0; i < n; i++){\n\t    \tinput_p(ps + i);\n\t    }\n\t    printf(\"%d\\n\", n - graham_scan(ps, n));\n\t}\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\ndouble x[100],y[100];\n\ndouble len(int a,int b){\n  return  sqrt( (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]) );\n}\n\ndouble flon(int a,int b,int c){\n  double s;\n  double la,lb,lc;\n  la = len(b,c);\n  lb = len(a,c);\n  lc = len(a,b);\n  s = (la+lb+lc)/2.0;\n  return sqrt(s*(s-la)*(s-lb)*(s-lc));\n}\n  \nint inter(int x,int a,int b,int c){\n  if(flon(a,b,x)+flon(a,c,x)+flon(b,c,x) > flon(a,b,c) + 1e-10)return 0;\n  else return 1;\n}\n\nint band(int i,int j,int k,int l){\n  if(inter(i,j,k,l))return 1;\n  return 0;\n}\n  \n\nint main(void){\n  int i,j,k,l;\n  int n;\n  int tmp;\n  int unuse[100];\n\n  while(1){\n    scanf(\" %d \",&n);\n    if(!n)break;\n\n    for(i=0;i<n;i++){\n      scanf(\" %lf,%lf \",&x[i],&y[i]);\n      unuse[i] = 0;\n    }\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n-2;j++){\n\tif(j==i || unuse[j])continue;\n\tfor(k=j+1;k<n-1;k++){\n\t  if(k==i || unuse[k])continue;\n\t  for(l=k+1;l<n;l++){\n\t    if(l==i || unuse[l])continue;\n\t    if(band(i,j,k,l)){\n\t      unuse[i] = 1;\n\t      break;\n\t    }\n\t  }\n\t  if(unuse[i])break;\n\t}\n\tif(unuse[i])break;\n      }\n    }\n      \n    tmp = 0;\n    for(i=0;i<n;i++){\n      if(unuse[i])tmp++;\n    }\n      \n    printf(\"%d\\n\",tmp);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(int argc,char* argv[]){\n  int n,i;\n  double array_x[100];\n  double array_y[100];\n\n  for(;;){\n    double smallest_x = 9999.0,smallest_y = 9999.0;\n    double cur_rad = 0;\n    int cur = 0,smallest_cur = 0;\n    int count = 0;\n    \n    scanf(\"%d\",&n);\n    if(n == 0){\n      break;\n    }\n\n    for(i = 0; i < n; i++){\n      scanf(\"%lf,%lf\",&array_x[i],&array_y[i]);\n      if(smallest_y > array_y[i]){\n\tsmallest_y = array_y[i];\n\tsmallest_x = array_x[i];\n\tcur = i;\n      }else if(smallest_y == array_y[i]){\n\tif(smallest_x > array_x[i]){\n\t  smallest_x = array_x[i];\n\t  cur = i;\n\t}\n      }\n    }\n\n    smallest_cur = cur;\n\n    for(;;){\n      int next_cur;\n      double smallest_rad = 2*M_PI;\n      \n      for(i = 0; i < n; i++){\n\tdouble tmp;\n\tif(i == cur){continue;}\n\ttmp = atan2(array_y[cur]-array_y[i],array_x[cur]-array_x[i]);\n\tif(tmp < 0){tmp += M_PI*2;}\n\ttmp -= cur_rad;\n\tif(smallest_rad > tmp){\n\t  smallest_rad = tmp;\n\t  next_cur = i;\n\t}\n      }\n\n      count++;\n\n      if(next_cur == smallest_cur){\n\tbreak;\n      }else{\n\tcur = next_cur;\n\tcur_rad = smallest_rad;\n      }\n    }\n\n    printf(\"%d\\n\",n-count);\n\n    \n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n//グラハムスキャン\n//幾何\n//凸包\nclass Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] ps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] str=sc.next().split(\",\");\n\t\t\t\tps[i]=new P(Double.parseDouble(str[0]),Double.parseDouble(str[1]));\n\t\t\t}\n\t\t\tArrays.sort(ps);\n\n\t\t\tint k=0;\n\t\t\tP[] qs =new P[2*n];\n\t\t\t//下側\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\twhile(k>1 && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;//凸包になるまで戻す\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\t//上側\n\t\t\tfor(int i=n-2,t=k;i>=0;i--){\n\t\t\t\twhile(k>t && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\tqs=Arrays.copyOf(qs,k-1);\n\n\t\t\tln(ps.length-qs.length);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}\n\nclass P implements Comparable<P>{\n\tdouble x;\n\tdouble y;\n\tP(double _x,double _y){\n\t\tx=_x;\n\t\ty=_y;\n\t}\n\t@Override\n\tpublic int compareTo(P o) {\n\t\tif(x>o.x){\n\t\t\treturn 1;\n\t\t}else if(x<o.x){\n\t\t\treturn -1;\n\t\t}\n\t\treturn y>o.y?1:y<o.y?-1:0;\n\t}\n\n\tpublic static double dot(P a,P b){\n\t\t\treturn a.x*b.x+a.y*b.y;\n\t}\n\tpublic static  double cross(P a,P b){\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n\tpublic static boolean isParallel(P a1,P a2,P b1,P b2){\n\t\treturn Math.abs(cross(a2.s(a1),b2.s(b1)))<Double.MIN_NORMAL;\n\t}\n\tpublic static boolean isVertical(P a1,P a2,P b1,P b2){\n\t\treturn Math.abs(dot(a2.s(a1),b2.s(b1)))<Double.MIN_NORMAL;\n\t}\n\n\tpublic P a(P a){\n\t\treturn new P(x+a.x,y+a.y);\n\t}\n\tpublic P s(P a){\n\t\treturn new P(x-a.x,y-a.y);\n\t}\n\n\tpublic double norm(){\n\t\treturn Math.sqrt(x*x+y*y);\n\t}\n\n\tpublic static int ccw(P a,P b,P c){\n\t\tif(P.cross(b.s(a),c.s(a))>Double.MIN_NORMAL){\n\t\t\treturn 1;\n\t\t}\n\t\tif(P.cross(b.s(a),c.s(a))<-Double.MIN_NORMAL){\n\t\t\treturn -1;\n\t\t}\n\t\tif(P.dot(b,c)<-Double.MIN_NORMAL)return 2;\n\t\tif(b.norm()<c.norm()-Double.MIN_NORMAL)return -2;\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof P){\n\t\t\tP p=(P)obj;\n\t\t\treturn x==p.x && y==p.y;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic String toString(){\n\t\treturn \"(\"+x+\",\"+y+\")\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tpublic double x,y;\n\t\t\n\t\tVector sub(Vector a){\n\t\t\treturn new Vector(x-a.x,y-a.y);\n\t\t}\n\t\tdouble op(Vector a){\n\t\t\treturn x*a.y-y*a.x;\n\t\t}\n\t\n\t\tdouble ip(Vector a){\n\t\t\treturn x*a.x+y*a.y;\n\t\t}\n\t\t\n\t\tdouble norm(){\n\t\t\treturn Math.sqrt(x*x+y*y);\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\tpublic Vector(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\tclass VectorComparator implements Comparator<Vector>{\n\t\t@Override\n\t\tpublic int compare(Vector o1, Vector o2) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tdouble sign=o1.y-o2.y;\n\t\t\tif(sign==0)sign=(o1.x-o2.x);\n\t\t\treturn (int)Math.signum(sign);\n\t\t}\n\t}\n\t\n\tint solve(LinkedList<Vector> coords){\n\t\tCollections.sort(coords,new VectorComparator());\n\t\tVector p0=coords.getFirst(),p=p0;\n\t\tVector v=new Vector(1,0);\n\n\t\tdo{\n\t\t\tdouble ipmax=Double.NEGATIVE_INFINITY;\n\t\t\tVector qmax=null;\n\t\t\tfor(Vector q:coords){\n\t\t\t\tdouble ip;\n\t\t\t\tVector u=q.sub(p);\n\t\t\t\tif(v.op(u)>=0&&(ip=v.ip(u)/(v.norm()*u.norm()))>ipmax){\n\t\t\t\t\tipmax=ip;\n\t\t\t\t\tqmax=q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv=qmax.sub(p);\n\t\t\tp=qmax;\n\t\t\tcoords.remove(p);\n\t\t}while(p!=p0);\n\t\treturn coords.size();\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");\n\t\tLinkedList<Vector> coords=new LinkedList<Vector>();\n\t\t\n\t\tint n;\n\t\twhile((n=ni())!=0){\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tcoords.add(new Vector(nd(),nd()));\n\t\t\t}\n\t\t\tSystem.out.println(solve(coords));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine() == true) {\n\t\t\tint lines = Integer.parseInt(sc.nextLine());\n\t\t\tif (lines == 0) break;\n\t\t\t\n\t\t\tdouble[][] points = new double[lines][2];\n\t\t\tfor (int i = 0; i < lines; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < nico.length; j++) {\n\t\t\t\t\tpoints[i][j] = Double.parseDouble(nico[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[] flag = new boolean[points.length];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\tfor (int j = (i + 1); j < points.length; j++) {\n\t\t\t\t\tif (flag[j] == true) {\n\t\t\t\t\t\tdouble dx = points[j][0] - points[i][0];\n\t\t\t\t\t\tdouble dy = points[j][1] - points[i][1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean judge = true;\n\t\t\t\t\t\tif (dx != 0.0) {\n\t\t\t\t\t\t\tdouble a = dy / dx;\n\t\t\t\t\t\t\tdouble b = points[i][1] - a * points[i][0];\n\n\t\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\t\tnside = points[k][1] - (a * points[k][0] + b);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((side != 0.0) && (side * nside < 0)) {\n\t\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\t\tnside = points[k][0] - points[i][0];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((side != 0.0) && (side * nside < 0)) {\n\t\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (judge == true) {\n\t\t\t\t\t\t\tflag[i] = false;\n\t\t\t\t\t\t\tflag[j] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tif (flag[i] == true) cnt++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine() == true) {\n\t\t\tint lines = Integer.parseInt(sc.nextLine());\n\t\t\tif (lines == 0) break;\n\t\t\t\n\t\t\tdouble[][] points = new double[lines][2];\n\t\t\tfor (int i = 0; i < lines; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < nico.length; j++) {\n\t\t\t\t\tpoints[i][j] = Double.parseDouble(nico[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[] flag = new boolean[points.length];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\tfor (int j = (i + 1); j < points.length; j++) {\n\t\t\t\t\tif (flag[j] == true) {\n\t\t\t\t\t\tdouble dx = points[j][0] - points[i][0];\n\t\t\t\t\t\tdouble dy = points[j][1] - points[i][1];\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean judge = true;\n\t\t\t\t\t\tif (dx != 0.0) {\n\t\t\t\t\t\t\tdouble a = dy / dx;\n\t\t\t\t\t\t\tdouble b = points[i][1] - a * points[i][0];\n\n\t\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\t\tnside = points[k][1] - (a * points[k][0] + b);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((side != 0.0) && (side * nside < 0)) {\n\t\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\t\tnside = points[k][0] - points[i][0];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((side != 0.0) && (side * nside < 0)) {\n\t\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (judge == true) {\n\t\t\t\t\t\t\tflag[j] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tif (flag[i] == true) cnt++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.awt.geom.Point2D;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tint n = Integer.parseInt(br.readLine());\n\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPoint2D input[] = new Point2D[n];\n\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString[] tmpArray = br.readLine().split(\",\");\n\n\t\t\t\tdouble x = Double.parseDouble(tmpArray[0]);\n\t\t\t\tdouble y = Double.parseDouble(tmpArray[1]);\n\n\t\t\t\tinput[i] = new Point2D.Double(x, y);\n\t\t\t}\n\n\t\t\tConvex convex = new Convex(input);\n\n\t\t\tSystem.out.println(n - convex.getSize());\n\t\t}\n\t}\n\n\tstatic void printPointAsInt(Point2D point){\n\t\tSystem.out.println((int)point.getX()+\" \"+(int)point.getY());\n\t}\n\n}\n\nclass Convex {\n\t//並び順は一番左から時計回り\n\tPoint2D points[];\n\n\tConvex(Point2D[] points){\n\n\t\t//x座標で整列\n\t\tArrays.sort(points, (p1, p2) ->(p1.getX() == p2.getX() ?\n\t\t\t\t(p1.getY() == p2.getY() ? 0 : (p1.getY() > p2.getY() ? 1 : -1)) :\n\t\t\t\t\t(p1.getX() > p2.getX() ? 1 : -1))\n\t\t\t\t);\n\n\t\tArrayList<Point2D> upper = new ArrayList<Point2D>();\n\t\tArrayList<Point2D> lower = new ArrayList<Point2D>();\n\n\t\t//この2点が上の凸包にあるとする\n\t\tupper.add(points[0]);\n\t\tupper.add(points[1]);\n\n\t\tfor(int i = 2; i < points.length; i++){\n\t\t\tupper.add(points[i]);\n\n\t\t\t//最後の3点が左回りなら最後から2番目の点を削除\n\t\t\twhile(upper.size() >= 3 && crossProduct(upper.get(upper.size() - 3), upper.get(upper.size() - 2), upper.get(upper.size() - 1)) > 0){\n\t\t\t\tupper.remove(upper.size() - 2);\n\t\t\t}\n\t\t}\n\n\t\t//この2点が下の凸包にあるとする\n\t\tlower.add(points[0]);\n\t\tlower.add(points[1]);\n\n\t\tfor(int i = 2; i < points.length; i++){\n\t\t\tlower.add(points[i]);\n\n\t\t\t//最後の3点が左回りなら最後から2番目の点を削除\n\t\t\twhile(lower.size() >= 3 && crossProduct(lower.get(lower.size() - 3), lower.get(lower.size() - 2), lower.get(lower.size() - 1)) < 0){\n\t\t\t\tlower.remove(lower.size() - 2);\n\t\t\t}\n\t\t}\n\n\t\tthis.points = new Point2D[upper.size() + lower.size() - 2];\n\n\t\t//upperとlowerを合成した配列を作る\n\t\tfor(int i = 0; i < upper.size(); i++){\n\t\t\tthis.points[i] = upper.get(i);\n\t\t}\n\n\t\tfor(int i = 0; i < lower.size() - 2; i++){\n\t\t\tthis.points[i + upper.size()] = lower.get(lower.size() - i - 2);\n\t\t}\n\n\t}\n\n\t//正なら左回り、負なら右回り、0なら共線\n\tprivate double crossProduct(Point2D p1, Point2D p2, Point2D p3){\n\t\treturn (p2.getX() - p1.getX())*(p3.getY() - p1.getY()) - (p2.getY() - p1.getY())*(p3.getX() - p1.getX());\n\t}\n\n\t//頂点数を返す\n\tint getSize(){\n\t\treturn points.length;\n\t}\n\n\t//一番下（y座標が同じなら左）にある頂点のインデックスを返す\n\t//AOJ CGL4A用\n\tint searchBottom(){\n\t\tint index = 0;\n\t\tdouble x = points[0].getX();\n\t\tdouble y = points[0].getY();\n\n\t\tfor(int i = 1; i < points.length; i++){\n\t\t\tif(points[i].getY() < y || (points[i].getY() == y && points[i].getX() < x)){\n\t\t\t\tindex = i;\n\t\t\t\tx = points[i].getX();\n\t\t\t\ty = points[i].getY();\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tdouble EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D[] p = new Point2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString [] input = sc.next().split(\",\");\n\t\t\t\tdouble x = Double.parseDouble(input[0]);\n\t\t\t\tdouble y = Double.parseDouble(input[1]);\n\t\t\t\tp[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tPoint2D [] res = convexHull(p);\n\t\t\tSystem.out.println(n - res.length);\n\t\t\t\n\t\t}\n\t}\n\t\n\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\tpublic int compare(Point2D o1, Point2D o2) {\n\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\telse return 0;\n\t\t}\n\t};\n\t\n\tprivate Point2D [] convexHull(Point2D [] p) {\n\t\tint n = p.length;\n\t\tArrays.sort(p, com);\n\t\tArrayList<Point2D> q = new ArrayList<Point2D>();\n\t\tq.add(p[0]);\n\t\tq.add(p[1]);\n\t\t\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tboolean correct_turn;\n\t\t\tdo{\n\t\t\t\tPoint2D q1 = q.get(q.size() - 2);\n\t\t\t\tPoint2D q2 = q.get(q.size() - 1);\n\t\t\t\tcorrect_turn = Line2D.relativeCCW(q1.getX(), q1.getY(), q2.getX(), q2.getY(), p[i].getX(), p[i].getY()) == -1;\n\t\t\t\tif(! correct_turn)q.remove(q.size() - 1);\n\t\t\t}while(! correct_turn && q.size() >= 2);\n\t\t\tq.add(p[i]);\n\t\t}\n\t\tint t = q.size();\n\t\tfor(int i = n - 2; i >= 0; i--){\n\t\t\tboolean correct_turn;\n\t\t\tdo{\n\t\t\t\tPoint2D q1 = q.get(q.size() - 2);\n\t\t\t\tPoint2D q2 = q.get(q.size() - 1);\n\t\t\t\tcorrect_turn = Line2D.relativeCCW(q1.getX(), q1.getY(), q2.getX(), q2.getY(), p[i].getX(), p[i].getY()) == -1;\n\t\t\t\tif(! correct_turn)q.remove(q.size() - 1);\n\t\t\t}while(! correct_turn && q.size() >= t);\n\t\t\tq.add(p[i]);\n\t\t}\n\t\tq.remove(q.size() - 1);\n\t\tPoint2D [] res = q.toArray(new Point2D[q.size()]);\n\t\treturn res;\n\t}\n\t\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  static int infi = 10001;\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int n, i, j, m, l, r;\n    char[] c;\n    String s;\n    double[] x, y;\n\n    for(;;){\n      n = sc.nextInt();\n      if(n == 0)break;\n      x = new double[n]; y = new double[n];\n      for(i = 0;i < n;i++){\n        s = sc.next(); c = new char[s.length()];\n        for(j = 0;j < s.length();j++)c[j] = s.charAt(j);\n        l = 0;\n        for(j = 0;j < s.length();j++)if(c[j] == ','){\n          r = j; x[i] = readdouble(c, l, r); l = ++r; break;\n        }\n        y[i] = readdouble(c, l, s.length());\n      }\n\n      m = getconvex(x, y, n);\n      out.println(n - m);\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n  private static double readdouble(char[] ch, int l, int r){\n    int i;\n    double res, d, s;\n    s = 1;\n    if(ch[l] == '-'){\n      s = -1; l++;\n    }\n    d = 1.0; res = 0.0;\n    for(i = l;i < r;i++){\n      if(ch[i] == '.')break;\n      d *= 10;\n    }\n    d /= 10;\n    for(i = l;i < r;i++)if(ch[i] != '.'){\n      res += d * (double)(ch[i] - '0');\n      d /= 10;\n    }\n    return res * s;\n  }\n  private static int getconvex(double[] x, double[] y, int n){\n    int i, numr, numl;\n    double[] resx, resy, anslx, ansly;\n    mergesort(x, y, 0, n);\n    resx = new double[n]; resy = new double[n];\n    numr = rcovering(x, y, n, resx, resy);\n    if(n == numr)return numr;\n    else{\n      anslx = new double[n]; ansly = new double[n];\n      reverse(x, y, n);\n      numl = rcovering(x, y, n, anslx, ansly);\n      for(i = 0;i < numl;i++){\n        resx[numr + i] = anslx[i]; resy[numr + i] = ansly[i];\n      }\n    }\n    return (numr + numl);\n  }\n  private static int rcovering(double[] x, double[] y, int n,\n                                double[] ansx, double[] ansy){\n    int i, num;\n    ansx[0] = x[0]; ansy[0] = y[0];\n    ansx[1] = x[1]; ansy[1] = y[1];\n    num = 2;\n    for(i = 2;i < n;i++){\n      ansx[num] = x[i]; ansy[num] = y[i];\n      num = gscan(ansx, ansy, num);\n    }\n    if(ansx[num - 1] == x[n - 1] && ansy[num - 1] == y[n - 1])num--;\n    return num;\n  }\n  private static void reverse(double[] x, double[] y, int n){\n    double tmp;\n    int i;\n    for(i = 0;i < n / 2;i++){\n      tmp = x[i]; x[i] = x[n - 1 - i]; x[n - 1 - i] = tmp;\n      tmp = y[i]; y[i] = y[n - 1 - i]; y[n - 1 - i] = tmp;\n    }\n    return;\n  }\n  private static int gscan(double[] ansx, double[] ansy, int num){\n    double s1x, s1y, s2x, s2y;\n    for(;num > 0;){\n      if(num == 1)return ++num;\n      s1x = ansx[num - 1] - ansx[num]; s1y = ansy[num - 1] - ansy[num];\n      s2x = ansx[num - 2] - ansx[num]; s2y = ansy[num - 2] - ansy[num];\n      if(s1x * s2y - s2x * s1y > 0){\n        ansx[num - 1] = ansx[num]; ansy[num - 1] = ansy[num]; num--;\n      }else return ++num;\n    }\n    return num;\n  }\n  private static void mergesort(double[] x, double[] y, int l, int r){\n    int m, c;\n    if(l + 1 >= r)return;\n    else{\n      m = (l + r) / 2;\n      mergesort(x, y, l, m); mergesort(x, y, m, r); merge(x, y, l, m, r);\n      return;\n    }\n  }\n  private static void merge(double[] x, double[] y, int l, int m, int r){\n    int nl, nr;\n    int i, j, k;\n    double[] xl, xr, yl, yr;\n    nl = m - l; nr = r - m;\n    xl = new double[nl + 1]; xr = new double[nr + 1];\n    yl = new double[nl + 1]; yr = new double[nr + 1];\n    for(i = 0;i < nl;i++){ xl[i] = x[l + i]; yl[i] = y[l + i]; }\n    for(i = 0;i < nr;i++){ xr[i] = x[m + i]; yr[i] = y[m + i]; }\n    xl[nl] = infi; xr[nr] = infi; yl[nl] = infi; yr[nr] = infi;\n    i = 0; j = 0;\n    for(k = l;k < r;k++){\n      if(alow(xl[i], yl[i], xr[j], yr[j])){ x[k] = xl[i]; y[k] = yl[i++]; }\n      else{ x[k] = xr[j]; y[k] = yr[j++]; }\n    }\n    return;\n  }\n  private static boolean alow(double ax, double ay, double bx, double by){\n    if(ay < by || (ay == by && ax <= bx))return true;\n    else return false;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tP[] ps = new P[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString[] sp = sc.next().split(\",\");\n\t\t\t\tps[i] = new P(Double.parseDouble(sp[0]), Double.parseDouble(sp[1]));\n\t\t\t}\n\t\t\t\n\t\t\tP[] poly = poly(ps);\n\t\t\tSystem.out.println( n - poly.length );\n\t\t}\n\t}\n\t\n\tP[] poly(P[] ps) {\n\t\tint n = ps.length, k=0;\n\t\tif(n <= 1) return ps;\n\t\tsort(ps, new Comp());\n\t\tP[] qs = new P[n*2];\n\t\t\n\t\tfor(int i=0;i<n;qs[k++] = ps[i++]) {\n\t\t\twhile(k > 1 && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) < EPS) k--;\n\t\t}\n\t\tfor(int i=n-2,t=k;i>=0;qs[k++] = ps[i--]) {\n\t\t\twhile(k > t && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) < EPS) k--;\n\t\t}\n\t\tP[] res = new P[k-1];\n\t\tSystem.arraycopy(qs, 0, res, 0, k-1);\n\t\treturn res;\n\t}\n\t\n\tboolean contains(P[] ps, P p) {\n\t\tint n = ps.length;\n\t\tint res = -1;\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tP a = ps[j].sub(p);\n\t\t\tP b = ps[(j+1)%n].sub(p);\n\t\t\tif(a.y > b.y) {\n\t\t\t\tP t = new P(a.x, a.y); a = b; b = t; \n\t\t\t}\n\t\t\tif(a.y < EPS &&  b.y > EPS && a.det(b) > EPS) {\n\t\t\t\tres = -res;\n\t\t\t}\n\t\t\tif(abs(a.det(b)) < EPS && a.dot(b) < EPS) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn res == -1? false: true;\n\t}\n\tclass Comp implements Comparator<P> {\n\n\t\tpublic int compare(P o1, P o2) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\tif(o1.x != o2.x) return (int)(o1.x - o2.x);\n\t\t\treturn (int)(o1.y - o2.y);\n\t\t}\n\t\t\n\t}\n\tclass P {\n\t\tdouble EPS = 1e-10;\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble add(double a, double b) {\t//誤差を考慮\n\t\t\tif( Math.abs(a+b) < EPS * ( Math.abs(a) + Math.abs(b) ) ) return 0;\n\t\t\treturn a + b;\n\t\t}\n\n\t\tP add(P p) {\t//和\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p) {\t//差\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\t\t\n\t\tP mlt(double k) {\n\t\t\treturn new P(x*k, y*k);\n\t\t}\n\n\t\tdouble dot(P p) {\t//内積\n\t\t\t\treturn add(x*p.x, y*p.y);\n\t\t}\n\n\t\tdouble det(P p) {\t//外積\n\t\t\treturn add(x*p.y, -y*p.x);\n\t\t}\n\n\t\t//距離系\n\t\tdouble abs() {\n\t\t\tdouble ret = sqrt( add(x*x, y*y) );\n\t\t\tif ( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble abs(P p) {\n\t\t\tdouble dx = add( x, -p.x );\n\t\t\tdouble dy = add( y, -p.y );\n\t\t\tdouble ret = sqrt( add(dx*dx, dy*dy) );\n\t\t\tif( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\t//点と線分の距離\n\t\tdouble disSP(P p1, P p2, P q) {\n\t\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).abs();\n\t\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).abs();\n\t\t\treturn disLP(p1, p2, q);\n\t\t}\n\n\t\t//点と直線の距離\n\t\tdouble disLP(P p1, P p2, P q) {\n\t\t\treturn Math.abs(p2.sub(p1).det(q.sub(p1))) / p2.sub(p1).abs();\n\t\t}\n\n\t\t//線分交差判定\n\t\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t\t}\n\n\t\t//時計回りなのか．反時計回りなのか，直線状なのか，とにかく位置関係をみる\n\t\tint ccw (P a, P b, P c) {\n\t\t\tP s = b.sub(a);\n\t\t\tP t = c.sub(a);\n\t\t\tif( s.det(t) > EPS ) return 1;\n\t\t\tif( s.det(t) < -EPS ) return -1;\n\t\t\tif( s.dot(t) < -EPS ) return 2;\n\t\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tP[] ps = new P[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString[] sp = sc.next().split(\",\");\n\t\t\t\tps[i] = new P(Double.parseDouble(sp[0]), Double.parseDouble(sp[1]));\n\t\t\t}\n\t\t\t\n\t\t\tP[] poly = poly(ps);\n\t\t\tSystem.out.println( n - poly.length );\n\t\t}\n\t}\n\t\n\tP[] poly(P[] ps) {\n\t\tint n = ps.length, k=0;\n\t\tif(n <= 1) return ps;\n\t\tsort(ps, new Comp(ps[0]));\n\t\tP[] qs = new P[n*2];\n\t\t\n\t\tfor(int i=0;i<n;qs[k++] = ps[i++]) {\n\t\t\twhile(k > 1 && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) < EPS) k--;\n\t\t}\n\t\tfor(int i=n-2,t=k;i>=0;qs[k++] = ps[i--]) {\n\t\t\twhile(k > t && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) < EPS) k--;\n\t\t}\n\t\tP[] res = new P[k-1];\n\t\tSystem.arraycopy(qs, 0, res, 0, k-1);\n\t\treturn res;\n\t}\n\t\n\tboolean contains(P[] ps, P p) {\n\t\tint n = ps.length;\n\t\tint res = -1;\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tP a = ps[j].sub(p);\n\t\t\tP b = ps[(j+1)%n].sub(p);\n\t\t\tif(a.y > b.y) {\n\t\t\t\tP t = new P(a.x, a.y); a = b; b = t; \n\t\t\t}\n\t\t\tif(a.y < EPS &&  b.y > EPS && a.det(b) > EPS) {\n\t\t\t\tres = -res;\n\t\t\t}\n\t\t\tif(abs(a.det(b)) < EPS && a.dot(b) < EPS) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn res == -1? false: true;\n\t}\n\tclass Comp implements Comparator<P> {\n\t\tP p;\n\t\tComp(P p) {\n\t\t\tthis.p = new P(p.x, p.y);\n\t\t}\n\n\t\tpublic int compare(P o1, P o2) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn (p.det(p.sub(o1)) > p.det(p.sub(o2))? 1: -1);\n\t\t}\n\t\t\n\t}\n\tclass P {\n\t\tdouble EPS = 1e-8;\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble add(double a, double b) {\t//誤差を考慮\n\t\t\tif( Math.abs(a+b) < EPS * ( Math.abs(a) + Math.abs(b) ) ) return 0;\n\t\t\treturn a + b;\n\t\t}\n\n\t\tP add(P p) {\t//和\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p) {\t//差\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\t\t\n\t\tP mlt(double k) {\n\t\t\treturn new P(x*k, y*k);\n\t\t}\n\n\t\tdouble dot(P p) {\t//内積\n\t\t\t\treturn add(x*p.x, y*p.y);\n\t\t}\n\n\t\tdouble det(P p) {\t//外積\n\t\t\treturn add(x*p.y, -y*p.x);\n\t\t}\n\n\t\t//距離系\n\t\tdouble abs() {\n\t\t\tdouble ret = sqrt( add(x*x, y*y) );\n\t\t\tif ( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble abs(P p) {\n\t\t\tdouble dx = add( x, -p.x );\n\t\t\tdouble dy = add( y, -p.y );\n\t\t\tdouble ret = sqrt( add(dx*dx, dy*dy) );\n\t\t\tif( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\t//点と線分の距離\n\t\tdouble disSP(P p1, P p2, P q) {\n\t\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).abs();\n\t\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).abs();\n\t\t\treturn disLP(p1, p2, q);\n\t\t}\n\n\t\t//点と直線の距離\n\t\tdouble disLP(P p1, P p2, P q) {\n\t\t\treturn Math.abs(p2.sub(p1).det(q.sub(p1))) / p2.sub(p1).abs();\n\t\t}\n\n\t\t//線分交差判定\n\t\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t\t}\n\n\t\t//時計回りなのか．反時計回りなのか，直線状なのか，とにかく位置関係をみる\n\t\tint ccw (P a, P b, P c) {\n\t\t\tP s = b.sub(a);\n\t\t\tP t = c.sub(a);\n\t\t\tif( s.det(t) > EPS ) return 1;\n\t\t\tif( s.det(t) < -EPS ) return -1;\n\t\t\tif( s.dot(t) < -EPS ) return 2;\n\t\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D[] p = new Point2D[n];\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tp[i] = new Point2D.Double(Double.parseDouble(s[0]), Double.parseDouble(s[1]));\n\t\t\t}\n\n\t\t\tSystem.out.println(p.length - convexHull(p).length);\n\t\t}\n\t}\n\n\tpublic static Point2D[] convexHull(Point2D[] ps) {        \n\t\tArrays.sort(ps , new Comparator< Point2D >() {\n\t\t\t\tpublic int compare(Point2D o1, Point2D o2) {\n\t\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\t\telse return 0;        \n\t\t\t\t}\n\t\t\t});\n\t\tint n = ps.length, k = 0;\n\t\tPoint2D[] ch = new Point2D[2 * n];\n\n\t\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\t\twhile (k >= 2\n\t\t\t\t\t\t && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ps[i].getY()) <= 0)\n\t\t\t\tk--;\n\n\t\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\t\twhile (k >= t\n\t\t\t\t\t\t && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ps[i].getY()) <= 0)\n\t\t\t\tk--;\n\t\treturn Arrays.copyOf(ch, k - 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine() == true) {\n\t\t\tint lines = Integer.parseInt(sc.nextLine());\n\t\t\tif (lines == 0) break;\n\t\t\t\n\t\t\tdouble[][] points = new double[lines][2];\n\t\t\tfor (int i = 0; i < lines; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < nico.length; j++) {\n\t\t\t\t\tpoints[i][j] = Double.parseDouble(nico[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[] flag = new boolean[points.length];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\tfor (int j = (i + 1); j < points.length; j++) {\n\t\t\t\t\tdouble dx = points[j][0] - points[i][0];\n\t\t\t\t\tdouble dy = points[j][1] - points[i][1];\n\t\t\t\t\t\n\t\t\t\t\tboolean judge = true;\n\t\t\t\t\tif (dx != 0.0) {\n\t\t\t\t\t\tdouble a = dy / dx;\n\t\t\t\t\t\tdouble b = points[i][1] - a * points[i][0];\n\n\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\tnside = points[k][1] - (a * points[k][0] + b);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((side != 0.0) && ((side * nside < 0.0) || (nside == 0.0))) {\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\tnside = points[k][0] - points[i][0];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((side != 0.0) && ((side * nside < 0.0) || (nside == 0.0))) {\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (judge == true) {\n\t\t\t\t\t\tflag[i] = false;\n\t\t\t\t\t\tflag[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tif (flag[i] == true) cnt++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n \nclass Main{\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nArrayList<Point2D> array;\nwhile((line=br.readLine()!=null){\nint n=Integer.parseInt(line);\nPoint2D[] points=new Point2D[n];\nfor(int i=0;i<n;i++){\nline=br.readLine();\nString[] values=line.split(\",\");\npoints[i]=new Point2D.Double(Double.parseDouble(values[0]),Double.parseDouble(values[1]));\n}\nArrays.sort(points,new Comparator<Point2D>(){\npublic int compare(Point2D p1,Point2D p2){\nreturn (p1.getY()>p2.getY())?1:(p1.getY()<p2.getY())?-1:(p1.getX()>p2.getX())?1:(p1.getX()<p2.getX())?-1:0;\n}\n});\narray=new ArrayList<Point2D>();\nPoint2D start=points[0];\narray.add(now);\ndouble px=start.getX();\ndouble py=start.getY();\nPoint2D prev=start;\nwhile(true){\nPoint2D min=null;\ndouble minx=0;\ndouble miny=0;\ndouble maxcos=-1;\nfor(Point2D p : points){\nif(p==prev){\ncontinue;\n}\ndouble nx=p.getX()-prev.getX();\ndouble ny=p.getY()-prev.getY();\ndouble cos=(px*nx+py*ny)/(Math.hypot(px,py)*Math.hypot(nx,ny));\nif(cos>maxcos){\nmaxcos=cos;\nminx=nx;\nminy=ny;\nmin=p;\n}\n}\nif(min==start){\nbreak;\n}\npx=minx;\npy=miny;\nprev=min;\narray.add(min);\n}\nSystem.out.println(points.length()-array.size());\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n//グラハムスキャン\n//幾何\n//凸包\nclass Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] ps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] str=sc.next().split(\",\");\n\t\t\t\tps[i]=new P(Double.parseDouble(str[0]),Double.parseDouble(str[1]));\n\t\t\t}\n\t\t\tArrays.sort(ps);\n\n\t\t\tint k=0;\n\t\t\tP[] qs =new P[2*n];\n\t\t\t//下側\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\twhile(k>1 && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;//凸包になるまで戻す\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\t//上側\n\t\t\tfor(int i=n-2,t=k;i>=0;i--){\n\t\t\t\twhile(k>t && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\tqs=Arrays.copyOf(qs,k-1);\n\n\t\t\tln(ps.length-qs.length);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}\n\nclass P implements Comparable<P>{\n\tdouble x;\n\tdouble y;\n\tP(double _x,double _y){\n\t\tx=_x;\n\t\ty=_y;\n\t}\n\t@Override\n\tpublic int compareTo(P o) {\n\t\tif(this.x!=o.x){\n\t\t\treturn (int)(this.x-o.x);\n\t\t}\n\t\treturn (int)(this.y-o.y);\n\t}\n\n\tpublic static double dot(P a,P b){\n\t\t\treturn a.x*b.x+a.y*b.y;\n\t}\n\tpublic static  double cross(P a,P b){\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n\tpublic static boolean isParallel(P a1,P a2,P b1,P b2){\n\t\treturn Math.abs(cross(a2.s(a1),b2.s(b1)))<Double.MIN_NORMAL;\n\t}\n\tpublic static boolean isVertical(P a1,P a2,P b1,P b2){\n\t\treturn Math.abs(dot(a2.s(a1),b2.s(b1)))<Double.MIN_NORMAL;\n\t}\n\n\tpublic P a(P a){\n\t\treturn new P(x+a.x,y+a.y);\n\t}\n\tpublic P s(P a){\n\t\treturn new P(x-a.x,y-a.y);\n\t}\n\n\tpublic double norm(){\n\t\treturn Math.sqrt(x*x+y*y);\n\t}\n\n\tpublic static int ccw(P a,P b,P c){\n\t\tif(P.cross(b.s(a),c.s(a))>Double.MIN_NORMAL){\n\t\t\treturn 1;\n\t\t}\n\t\tif(P.cross(b.s(a),c.s(a))<-Double.MIN_NORMAL){\n\t\t\treturn -1;\n\t\t}\n\t\tif(P.dot(b,c)<-Double.MIN_NORMAL)return 2;\n\t\tif(b.norm()<c.norm()-Double.MIN_NORMAL)return -2;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tdouble[][] xy = new double[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\txy[i][0] = Double.valueOf(s[0]);\n\t\t\t\txy[i][1] = Double.valueOf(s[1]);\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(xy, new Comparator<double[]>(){\n\t\t\t\tpublic int compare(double[] o1, double[] o2) {\n\t\t\t\t\tif(o1[0]==o2[0]){\n\t\t\t\t\t\tif(o1[1]-o2[1]>0) return 1;\n\t\t\t\t\t\telse return -1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(o1[0]-o2[0]>0) return 1;\n\t\t\t\t\t\telse return -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tint z = 0;\n\t\t\tint zz = 0;\n\t\t\tint cnt = 0;\n\t\t\t\n\t\t\tdouble a = Double.MAX_VALUE;\n\t\t\tdouble b, c;\n\t\t\tboolean flag;\n\t\t\twhile(true){\n\t\t\t\tflag = false;\n\t\t\t\tb = -Double.MAX_VALUE;\n\t\t\t\tfor(int i=z+1;i<n;i++){\n\t\t\t\t\tif(xy[z][0]==xy[i][0]) c = Double.MAX_VALUE;\n\t\t\t\t\telse c = (xy[z][1]-xy[i][1])/(xy[z][0]-xy[i][0]);\n\t\t\t\t\t\n\t\t\t\t\tif(b<c && c<=a){\n\t\t\t\t\t\tb = c;\n\t\t\t\t\t\tzz = i;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta = b;\n\t\t\t\tz = zz;\n\t\t\t\tcnt++;\n\t\t\t\tif(flag==false) break;\n\t\t\t}\n\t\t\t\n\t\t\ta = Double.MAX_VALUE;\n\t\t\twhile(true){\n\t\t\t\tflag = false;\n\t\t\t\tb = -Double.MAX_VALUE;\n\t\t\t\tfor(int i=z-1;i>=0;i--){\n\t\t\t\t\tif(xy[z][0]==xy[i][0]) c = Double.MAX_VALUE;\n\t\t\t\t\telse c = (xy[z][1]-xy[i][1])/(xy[z][0]-xy[i][0]);\n\t\t\t\t\t\n\t\t\t\t\tif(b<c && c<=a){\n\t\t\t\t\t\tb = c;\n\t\t\t\t\t\tzz = i;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta = b;\n\t\t\t\tz = zz;\n\t\t\t\tcnt++;\n\t\t\t\tif(flag == false) break;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(n-cnt+2);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic final double EPS = 0.00000000001;\n\tstatic final int COUNTER_CLOCKWISE = 1;\n\tstatic final int CLOCKWISE = -1;\n\tstatic final int ONLINE_BACK = 2;\n\tstatic final int ONLINE_FRONT = -2;\n\tstatic final int ON_SEGMENT = 0;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tList<Point> s = new ArrayList<Point>();\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tString[] t = sc.next().split(\",\");\n\t\t\t\tdouble x = Double.parseDouble(t[0]);\n\t\t\t\tdouble y = Double.parseDouble(t[1]);\n\t\t\t\ts.add(new Point(x, y));\n\t\t\t}\n\t\t\tList<Point> l = andrewScan(s);\n\t\t\tSystem.out.println(n - l.size());\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic List<Point> andrewScan(List<Point> s){\n\t\tList<Point> u = new ArrayList<Point>();\n\t\tList<Point> l = new ArrayList<Point>();\n\t\tif(s.size() < 3) return s;\n\t\tCollections.sort(s, new MyComp(1));\n//\t\tfor(int i = 0; i < s.size(); i++) {\n//\t\t\tSystem.out.printf(\"%d %d %d\\n\", i, s.get(i).x, s.get(i).y);\n//\t\t}\n\t\t// x が小さいものから2つ u に追加\n\t\tu.add(s.get(0));\n\t\tu.add(s.get(1));\n\t\t// x が大きいものから2つ l に追加\n\t\tl.add(s.get(s.size() - 1));\n\t\tl.add(s.get(s.size() - 2));\n\n\t\t// 凸包の上部を生成\n\t\tfor(int i = 2; i < s.size(); i++) {\n\t\t\tfor(int n = u.size(); n >= 2 && ccw(u.get(n - 2), u.get(n - 1), s.get(i)) != CLOCKWISE; n--) {\n\t\t\t\tu.remove(u.size() - 1);\n\t\t\t}\n\t\t\tu.add(s.get(i));\n\t\t}\n\n\t\t// 凸包の下部を生成\n\t\tfor(int i = s.size() - 3; i >= 0; i--) {\n\t\t\tfor(int n = l.size(); n >= 2 && ccw(l.get(n - 2), l.get(n - 1) , s.get(i)) != CLOCKWISE; n--) {\n\t\t\t\tl.remove(l.size() - 1);\n\t\t\t}\n\t\t\tl.add(s.get(i));\n\t\t}\n\n\t\t// 時計回りになるように凸包の点を列に生成\n\t\tCollections.reverse(l);\n\t\tfor(int i = u.size() - 2; i >= 1; i--) {\n\t\t\tl.add(u.get(i));\n\t\t}\n\t\treturn l;\n\t}\n\tstatic class Point{\n\t\tdouble x, y;\n\t\tPoint(double x, double y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\tstatic class MyComp implements Comparator<Point>{\n\t\tint sign;\n\t\tMyComp(int sign) {\n\t\t\tthis.sign = sign;\n\t\t}\n\t\tpublic int compare(Point p1, Point p2) {\n\t\t\tif(p1.y < p2.y) {\n\t\t\t\treturn -1 * sign;\n\t\t\t}else if(p1.y == p2.y) {\n\t\t\t\tif(p1.x < p2.x) {\n\t\t\t\t\treturn -1 * sign;\n\t\t\t\t}else if(p1.x == p2.x) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}else {\n\t\t\t\t\treturn 1 * sign;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\treturn 1 * sign;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int ccw(Point p0, Point p1, Point p2) {\n\t\tPoint a = vec(p0, p1);\n\t\tPoint b = vec(p0, p2);\n\t\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif(cross(a, b) < EPS) return CLOCKWISE;\n\t\tif(dot(a, b) < EPS) return ONLINE_BACK;\n\t\tif(norm(a) < norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\tstatic double norm(Point p) {\n\t\treturn p.x * p.x + p.y * p.y;\n\t}\n\tstatic Point vec(Point p1, Point p2) {\n\t\treturn new Point(p2.x - p1.x, p2.y - p1.y);\n\t}\n\tstatic double dot(Point u, Point v) {\n\t\treturn u.x * v.x + u.y * v.y;\n\t}\n\tstatic double cross(Point u, Point v) {\n\t\treturn u.x * v.y - u.y * v.x;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n \nclass Main{\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nArrayList<Point2D> array;\nwhile((line=br.readLine())!=null){\nint n=Integer.parseInt(line);\nPoint2D[] points=new Point2D[n];\nfor(int i=0;i<n;i++){\nline=br.readLine();\nString[] values=line.split(\",\");\npoints[i]=new Point2D.Double(Double.parseDouble(values[0]),Double.parseDouble(values[1]));\n}\nArrays.sort(points,new Comparator<Point2D>(){\npublic int compare(Point2D p1,Point2D p2){\nreturn (p1.getY()>p2.getY())?1:(p1.getY()<p2.getY())?-1:(p1.getX()>p2.getX())?1:(p1.getX()<p2.getX())?-1:0;\n}\n});\narray=new ArrayList<Point2D>();\nPoint2D start=points[0];\narray.add(now);\ndouble px=start.getX();\ndouble py=start.getY();\nPoint2D prev=start;\nwhile(true){\nPoint2D min=null;\ndouble minx=0;\ndouble miny=0;\ndouble maxcos=-1;\nfor(Point2D p : points){\nif(p==prev){\ncontinue;\n}\ndouble nx=p.getX()-prev.getX();\ndouble ny=p.getY()-prev.getY();\ndouble cos=(px*nx+py*ny)/(Math.hypot(px,py)*Math.hypot(nx,ny));\nif(cos>maxcos){\nmaxcos=cos;\nminx=nx;\nminy=ny;\nmin=p;\n}\n}\nif(min==start){\nbreak;\n}\npx=minx;\npy=miny;\nprev=min;\narray.add(min);\n}\nSystem.out.println(points.length()-array.size());\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n while(true){\n  int n=ir.nextInt();\n  if(n==0) return;\n  P[] ps=new P[n];\n  for(int i=0;i<n;i++){\n   ps[i]=new P(ir.nextDouble(),ir.nextDouble());\n  }\n  P[] c=convexHull(ps);\n  out.println(ps.length-c.length);\n  System.gc();\n }\n}\n\npublic static P[] convexHull(P[] ps){\n int n=ps.length;\n Arrays.sort(ps,new Comparator<P>(){\n  public int compare(P a,P b){\n   if(a.getX()!=b.getY()) return Double.compare(a.getX(),b.getX());\n   return Double.compare(a.getY(),b.getY());\n  }\n });\n int p=0;\n P[] qs=new P[2*n];\n for(int i=0;i<n;i++){\n  while(p>1&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n for(int i=n-2,t=p;i>=0;i--){\n  while(p>t&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n return Arrays.copyOf(qs,p-1);\n}\n\nstatic final double EPS=1e-10;\n\npublic static double accurateTotal(double a,double b){\n if(Math.abs(a+b)<EPS*(Math.abs(a)+Math.abs(b))) return 0.0;\n return a+b;\n}\n\nstatic class P{\n\n public double x,y;\n\n public P(double x,double y){\n  this.x=x; this.y=y;\n }\n\n public double getX(){\n  return this.x;\n }\n\n public double getY(){\n  return this.y;\n }\n\n public P add(P v){\n  return new P(accurateTotal(this.x,v.x),accurateTotal(this.y,v.y));\n }\n\n public P sub(P v){\n  return new P(accurateTotal(this.x,-v.x),accurateTotal(this.y,-v.y));\n }\n\n public P mul(double k){\n  return new P(this.x*k,this.y*k);\n }\n\n public double dot(P v){\n  return accurateTotal(this.x*v.x,this.y*v.y);\n }\n\n public double det(P v){\n  return accurateTotal(this.x*v.y,-this.y*v.x);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126)||(c==',');}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tpublic double x,y;\n\t\t\n\t\tVector sub(Vector a){\n\t\t\treturn new Vector(x-a.x,y-a.y);\n\t\t}\n\t\tdouble op(Vector a){\n\t\t\treturn x*a.y-y*a.x;\n\t\t}\n\t\n\t\tdouble ip(Vector a){\n\t\t\treturn x*a.x+y*a.y;\n\t\t}\n\t\t\n\t\tdouble norm(){\n\t\t\treturn Math.sqrt(x*x+y*y);\n\t\t}\n\t\t\n\t\tpublic Vector(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\tclass VectorComparator implements Comparator<Vector>{\n\t\t@Override\n\t\tpublic int compare(Vector o1, Vector o2) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tdouble sign=o1.y-o2.y;\n\t\t\tif(sign==0)sign=(o1.x-o2.x);\n\t\t\treturn (int)Math.signum(sign);\n\t\t}\n\t}\n\t\n\tint solve(LinkedList<Vector> coords){\n\t\tCollections.sort(coords,new VectorComparator());\n\t\tVector p0=coords.getFirst(),p=p0;\n\t\tVector v=new Vector(1,0);\n\n\t\tdo{\n\t\t\tdouble cosmax=-1;\n\t\t\tVector qmax=null;\n\t\t\tfor(Vector q:coords){\n\t\t\t\tdouble cos;\n\t\t\t\tVector u=q.sub(p);\n\t\t\t\tcos=v.ip(u)/(v.norm()*u.norm());\n\t\t\t\tif(v.op(u)>=0&&cos>cosmax){\n\t\t\t\t\tcosmax=cos;\n\t\t\t\t\tqmax=q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv=qmax.sub(p);\n\t\t\tp=qmax;\n\t\t\tcoords.remove(p);\n\t\t}while(p!=p0);\n\t\treturn coords.size();\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");\n\t\tLinkedList<Vector> coords=new LinkedList<Vector>();\n\t\t\n\t\tint n;\n\t\twhile((n=ni())!=0){\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tcoords.add(new Vector(nd(),nd()));\n\t\t\t}\n\t\t\tSystem.out.println(solve(coords));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\n\nclass Point {\n\tdouble x,y;\n\tPoint(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tboolean NotEqual(Point p) {\n\t\tif (this.x==p.x&&this.y==p.y) return false;\n\t\telse return true;\n\t}\n}\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile ((buf = br.readLine())!=null) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tPoint p[] = new Point[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tbuf = br.readLine();\n\t\t\t\t\tStringTokenizer st = new StringTokenizer(buf,\",\");\n\t\t\t\t\tp[i] = new Point(Double.parseDouble(st.nextToken()),Double.parseDouble(st.nextToken()));\n\t\t\t\t}\n\t\t\t\tquicksort(0,n-1,p);\n\t\t\t\tsorty(n,p);\n\t\t\t\tPoint ans[] = construct(n,p);\n\t\t\t\tSystem.out.println(n-ans.length);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Point[] construct(int n,Point p[]) {\n\t\treturn construct_left(n,p);\n\t}\n\n\tpublic static Point[] construct_left(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[1];\n\t\t\tc[1] = p[0];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[2],p[1],p[0])<0) {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[0];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[0];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nl[] = new Point[n];\n\t\tlc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmax = c2[0].x;\n\t\tfor (int i=1;i<c2.length;i++) {\n\t\t\tif (xmax<c2[i].x) {\n\t\t\t\txmax = c2[i].x;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tnl[lc] = c2[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\t\t\t\n\t\t}\n\t\tnl[lc++] = cnt1[1];\n\t\tpt = 0;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tnl[lc++] = cnt1[0];\n\t\tpt = (pt+1)%c1.length;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\tnl[lc] = c1[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tnl[lc++] = cnt2[0];\n\t\tpt = 0;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\t\tif (cnt2[1].NotEqual(c2[mem])) {\n\t\t\tnl[lc++] = cnt2[1];\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(c2[mem])) {\n\t\t\tnl[lc] = c2[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\n\t\tPoint c[] = new Point[lc];\n\t\tfor (int i=0;i<lc;i++) c[i] = nl[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static Point[] construct_right(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[0];\n\t\t\tc[1] = p[1];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[0],p[1],p[2])>0) {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[2];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[2];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nr[] = new Point[n];\n\t\trc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmin = c1[0].x;\n\t\tfor (int i=1;i<c1.length;i++) {\n\t\t\tif (xmin>c1[i].x) {\n\t\t\t\txmin = c1[i].x;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tnr[rc] = c1[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\n\t\tnr[rc++] = cnt1[0];\n\t\tpt = 0;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tnr[rc++] = cnt1[1];\n\t\tpt = (pt+1)%c2.length;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\tnr[rc] = c2[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tnr[rc++] = cnt2[1];\n\t\tpt = 0;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\t\tif (cnt2[0].NotEqual(c1[mem])) {\n\t\t\tnr[rc++] = cnt2[0];\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(c1[mem])) {\n\t\t\tnr[rc] = c1[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\t\n\n\t\tPoint c[] = new Point[rc];\n\t\tfor (int i=0;i<rc;i++) c[i] = nr[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static void quicksort(int low,int high,Point p[]) {\n\t\tif (high>low) {\n\t\t\tint mid = (low+high)/2;\n\t\t\tdouble x = p[mid].x;\n\t\t\tint i = low;\n\t\t\tint j = high;\n\t\t\twhile (p[i].x<x) i++;\n\t\t\twhile (p[j].x>x) j--;\n\t\t\tif (i<=j) {\n\t\t\t\tPoint t =p[i];\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\ti++;j--;\n\t\t\t}\n\t\t\tquicksort(low,j,p);\n\t\t\tquicksort(i,high,p);\n\t\t}\n\t}\n\n\tpublic static void sorty(int n,Point p[]) {\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tint j = i-1;\n\t\t\twhile (p[j].x==p[j+1].x&&p[j].y>p[j+1].y) {\n\t\t\t\tPoint t = p[j+1];\n\t\t\t\tp[j+1] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\tj--;\n\t\t\t\tif (j<0) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double S(Point p0,Point p1,Point p2) {\n\t\treturn (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Stack;\n\nclass Main {\n\n    public static void main(String[] args) throws IOException {\n        doit(args, System.in, System.out);\n    }\n\n    static void doit(String[] args, InputStream in, PrintStream out)\n            throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            if (line.isEmpty()) {\n                continue;\n            }\n            int n = Integer.parseInt(line);\n            if (n == 0) {\n                break;\n            }\n            double[][] points = new double[n][4];\n            int bottomRightIndex = 0;\n            for (int i = 0; i < n; i++) {\n                String[] values = reader.readLine().split(\",\");\n                points[i][0] = Double.parseDouble(values[0]);\n                points[i][1] = Double.parseDouble(values[1]);\n                if (points[i][1] < points[bottomRightIndex][1]\n                        || (points[i][1] == points[bottomRightIndex][1] && points[i][0] > points[bottomRightIndex][0])) {\n                    bottomRightIndex = i;\n                }\n            }\n            if (bottomRightIndex != 0) {\n                double[] tmp = points[0];\n                points[0] = points[bottomRightIndex];\n                points[bottomRightIndex] = tmp;\n            }\n            points[0][3] = 1.0;\n            for (int i = 1; i < n; i++) {\n                double dx = points[i][0] - points[0][0];\n                double dy = points[i][1] - points[0][1];\n                points[i][2] = Math.hypot(dx, dy);\n                points[i][3] = dx / points[i][2];\n            }\n            Arrays.sort(points, new Comparator<double[]>() {\n\n                @Override\n                public int compare(double[] point1, double[] point2) {\n                    double d = point2[3] - point1[3];\n                    if (d == 0.0) {\n                        d = point1[2] - point2[2];\n                    }\n                    return (int) Math.signum(d);\n                }\n            });\n            int result = 0;\n            Stack<double[]> pointStack = new Stack<double[]>();\n            pointStack.push(points[0]);\n            pointStack.push(points[1]);\n            for (int i = 2; i < n; i++) {\n                double[] point3 = points[i];\n                double[] point2 = pointStack.pop();\n                double[] point1 = pointStack.pop();\n                while (true) {\n                    if (ccw(point1[0], point1[1], point2[0], point2[1],\n                            point3[0], point3[1]) > 0.0) {\n                        break;\n                    }\n                    result++;\n                    point2 = point1;\n                    point1 = pointStack.pop();\n                }\n                pointStack.push(point1);\n                pointStack.push(point2);\n                pointStack.push(point3);\n            }\n            out.println(result);\n        }\n    }\n\n    private static double ccw(double x1, double y1, double x2, double y2,\n            double x3, double y3) {\n        return (x2 - x1) * (y3 - y2) - (x3 - x2) * (y2 - y1);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main extends EuclideanSpace {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\n\tstatic int[] requireConvexHull(final Point[] ps) {\n\t\tint n = ps.length;\n\t\tif (n < 3) return null;\n\t\tInteger[] idx = new Integer[n];\n\t\tfor (int i=0; i<n; i++) idx[i] = i;\n\t\tArrays.sort(idx,new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\treturn ps[a].compareTo(ps[b]);\n\t\t\t}\n\t\t});\n\n\t\tint[] res = new int[n*2];\n\t\tint ptr = 0;\n\t\t//lower hull\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (ptr > 0\n\t\t\t\t&& epsEquals(ps[res[ptr-1]].getX(), ps[idx[i]].getX())\n\t\t\t\t&& epsEquals(ps[res[ptr-1]].getY(), ps[idx[i]].getY())) continue;\n\t\t\twhile (ptr > 1\n\t\t\t\t&& -Line2D.relativeCCW(ps[res[ptr-2]].getX(), ps[res[ptr-2]].getY(),\n\t\t\t\t\tps[idx[i]].getX(), ps[idx[i]].getY(),\n\t\t\t\t\tps[res[ptr-1]].getX(), ps[res[ptr-1]].getY()) > 0) ptr--;\n\t\t\tres[ptr++] = idx[i];\n\t\t}\n\n\t\tint end = ptr;\n\t\t//upper hull\n\t\tfor (int i=n-2; i>=0; i--) {\n\t\t\tif (epsEquals(ps[res[ptr-1]].getX(), ps[idx[i]].getX())\n\t\t\t\t&& epsEquals(ps[res[ptr-1]].getY(), ps[idx[i]].getY())) continue;\n\t\t\twhile (ptr > end\n\t\t\t\t&& -Line2D.relativeCCW(ps[res[ptr-2]].getX(), ps[res[ptr-2]].getY(),\n\t\t\t\t\tps[idx[i]].getX(), ps[idx[i]].getY(),\n\t\t\t\t\tps[res[ptr-1]].getX(), ps[res[ptr-1]].getY()) > 0) ptr--;\n\t\t\tres[ptr++] = idx[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(res,ptr-1);\n\t}\n\n\tstatic boolean solve() {\n\t\tint n = in.nextInt();\n\t\tif (n == 0) return false;\n\n\t\tPoint[] ps = new Point[n];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tString[] s = in.next().split(\",\");\n\t\t\tps[i] = new Point(Double.parseDouble(s[0]), Double.parseDouble(s[1]));\n\t\t}\n\n\t\tint[] res = requireConvexHull(ps);\n\t\tout.println(n-res.length);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\t//trace(end-start + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass EuclideanSpace{\n\tpublic static final double EPS = 1E-10;\n\tpublic static boolean epsEquals(double a, double b) { return Math.abs(a-b) < EPS; };\n}\n\n\nclass Point extends EuclideanSpace implements Comparable, Cloneable {\n\n\tprivate double x, y;\n\tpublic Point(double x, double y) {\n\t\tthis.x = x; this.y = y;\n\t}\n\n\tpublic double getX() {\n\t\treturn this.x;\n\t}\n\tpublic double getY() {\n\t\treturn this.y;\n\t}\n\n\tpublic void set(double x, double y) {\n\t\tthis.x = x; this.y = y;\n\t}\n\n\tpublic int compareTo(Object another) {\n\t\tPoint p = (Point)another;\n\t\tif (!epsEquals(this.x,p.x)) return this.x < p.x ? -1 : 1;\n\t\tif (!epsEquals(this.y,p.y)) return this.y < p.y ? -1 : 1;\n\t\treturn 0;\n\t}\n\n\tpublic boolean equals(Point p) {\n\t\treturn epsEquals(this.x,p.x) && epsEquals(this.y,p.y);\n\t}\n\n\tpublic Point clone() {\n\t\treturn new Point(this.x, this.y);\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\"+x+\",\"+y+\")\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\n\tclass Point extends Point2D.Double implements Comparable<Point2D.Double>{\n\t\tPoint(double x, double y){\n\t\t\tsuper(x,y);\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Point2D.Double o) {\n\t\t\tif(super.x < o.x) return -1;\n\t\t\tif(super.x > o.x) return 1;\n\t\t\tif(super.y < o.y) return -1;\n\t\t\tif(super.y > o.y) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint []  plist = new Point[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString [] a = sc.next().split(\",\");\n\t\t\t\tdouble x = Double.parseDouble(a[0]);\n\t\t\t\tdouble y = Double.parseDouble(a[1]);\n\t\t\t\tplist[i] = new Point(x, y);\n\t\t\t}\n\t\t\tArrays.sort(plist);\n\t\t\t\n\t\t\tArrayList<Point2D> res = convexHull(plist);\n\t\t\tSystem.out.println(n - res.size());\n\t\t}\n\t}\n\n\tprivate ArrayList<Point2D> convexHull(Point2D [] plist) {\n\t\tint n = plist.length;\n\t\tint k = 0;\n\t\tPoint2D [] qs = new Point2D[n * 2];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\twhile(k > 1 && cross(sub(qs[k-1], qs[k-2]), (sub(plist[i],qs[k-1]))) <= 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tqs[k++] = plist[i];\n\t\t}\n\t\t\n\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\twhile(k > t && cross(sub(qs[k-1],qs[k-2]), (sub(plist[i],qs[k-1]))) <= 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tqs[k++] = plist[i];\n\t\t}\n\t\tArrayList<Point2D> res = new ArrayList<Point2D>();\n\t\tfor(int i = 0; i < k - 1;i++){\n\t\t\tres.add(qs[i]);\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tprivate double cross(Point2D p1, Point2D p2) {\n\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\treturn res;\n\t}\n\n\tprivate Point2D sub(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D[] p = new Point2D[n];\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tp[i] = new Point2D.Double(Double.parseDouble(s[0]), Double.parseDouble(s[1]));\n\t\t\t}\n\n\t\t\tSystem.out.println(p.length - convexHull(p).length);\n\t\t}\n\t}\n\n\tpublic static Point2D[] convexHull(Point2D[] ps) {        \n\t\tArrays.sort(ps , new Comparator< Point2D >() {\n\t\t\t\tpublic int compare(Point2D o1, Point2D o2) {\n\t\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\t\telse return 0;        \n\t\t\t\t}\n\t\t\t});\n\t\tint n = ps.length, k = 0;\n\t\tPoint2D[] ch = new Point2D[2 * n];\n\n\t\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\t\twhile (k >= 2\n\t\t\t\t\t\t && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ps[i].getY()) <= 0)\n\t\t\t\tk--;\n\n\t\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\t\twhile (k >= t\n\t\t\t\t\t\t && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ps[i].getY()) <= 0)\n\t\t\t\tk--;\n\t\treturn Arrays.copyOf(ch, k - 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tdouble EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D[] p = new Point2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString [] input = sc.next().split(\",\");\n\t\t\t\tdouble x = Double.parseDouble(input[0]);\n\t\t\t\tdouble y = Double.parseDouble(input[1]);\n\t\t\t\tp[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tPoint2D [] res = convexHull(p);\n\t\t\tSystem.out.println(n - res.length);\n\t\t\t\n\t\t}\n\t}\n\t\n\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\tpublic int compare(Point2D o1, Point2D o2) {\n\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\telse return 0;\n\t\t}\n\t};\n\t\n\tprivate Point2D [] convexHull(Point2D [] p) {\n\t\tint n = p.length;\n\t\tArrays.sort(p, com);\n\t\tArrayList<Point2D> q = new ArrayList<Point2D>();\n\t\tq.add(p[0]);\n\t\tq.add(p[1]);\n\t\t\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tboolean correct_turn;\n\t\t\tdo{\n\t\t\t\tPoint2D q1 = q.get(q.size() - 2);\n\t\t\t\tPoint2D q2 = q.get(q.size() - 1);\n\t\t\t\tcorrect_turn = Line2D.relativeCCW(q1.getX(), q1.getY(), q2.getX(), q2.getY(), p[i].getX(), p[i].getY()) == -1;\n\t\t\t\tif(! correct_turn)q.remove(q.size() - 1);\n\t\t\t}while(! correct_turn && q.size() >= 2);\n\t\t\tq.add(p[i]);\n\t\t}\n\t\tfor(int i = n - 2; i >= 0; i--){\n\t\t\tboolean correct_turn;\n\t\t\tdo{\n\t\t\t\tPoint2D q1 = q.get(q.size() - 2);\n\t\t\t\tPoint2D q2 = q.get(q.size() - 1);\n\t\t\t\tcorrect_turn = Line2D.relativeCCW(q1.getX(), q1.getY(), q2.getX(), q2.getY(), p[i].getX(), p[i].getY()) == -1;\n\t\t\t\tif(! correct_turn)q.remove(q.size() - 1);\n\t\t\t}while(! correct_turn);\n\t\t\tq.add(p[i]);\n\t\t}\n\t\tq.remove(q.size() - 1);\n\t\tPoint2D [] res = q.toArray(new Point2D[q.size()]);\n\t\treturn res;\n\t}\n\t\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tP[] ps;\n\n\tvoid run(){\n\t\tsc.useDelimiter(\",|\\r\\n\");\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps=new P[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tps[i]=new P(x, y);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tArrays.sort(ps, new Comparator<P>(){\n\t\t\t@Override\n\t\t\tpublic int compare(P p1, P p2){\n\t\t\t\treturn (int)((p1.x-p2.x)*10000);\n\t\t\t}\n\t\t});\n\t\tint i=0;\n\t\tboolean[] used=new boolean[n];\n\t\tint ans=n-1;\n\t\tfor(int k=0; k<n-1; k++){\n\t\t\t// debug(i, ps[i].x, ps[i].y);\n\t\t\tused[i]=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(!used[j]&&check(i, j)){\n\t\t\t\t\ti=j;\n\t\t\t\t\tans--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"\"+ans);\n\t}\n\n\tboolean check(int i, int j){\n\t\tdouble a=(ps[j].y-ps[i].y)/(ps[j].x-ps[i].x);\n\t\tdouble b=-a*ps[i].x+ps[i].y;\n\t\tTreeSet<Integer> set=new TreeSet<Integer>();\n\t\tfor(int k=0; k<n; k++){\n\t\t\tif(k!=i&&k!=j){\n\t\t\t\tint sign=0;\n\t\t\t\tif(Math.abs(ps[j].x-ps[i].x)<EPS)\n\t\t\t\t\tsign=(int)Math.signum(ps[k].x-ps[i].x);\n\t\t\t\telse\n\t\t\t\t\tsign=(int)Math.signum(ps[k].y-(a*ps[k].x+b));\n\t\t\t\tset.add(sign);\n\t\t\t}\n\t\t}\n\t\treturn set.size()==1;\n\t}\n\n\tclass P{\n\t\tdouble x, y;\n\n\t\tP(){\n\t\t\tthis(0, 0);\n\t\t}\n\n\t\tP(double x, double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n  private static class Task {\n    void solve(FastScanner in, PrintWriter out) {\n      while (true) {\n        int N = in.nextInt();\n        if (N == 0) break;\n        double[][] xy = new double[N][2];\n        for (int i = 0; i < N; i++) {\n          String s = in.next();\n          String[] sxy = s.split(\",\");\n          xy[i][0] = Double.parseDouble(sxy[0]);\n          xy[i][1] = Double.parseDouble(sxy[1]);\n        }\n        long[][] cxy = new long[N][2];\n        for (int i = 0; i < N; i++) {\n          cxy[i][0] = (long) (xy[i][0] * 1000000.0);\n          cxy[i][1] = (long) (xy[i][1] * 1000000.0);\n        }\n        long[][] hoge = convexHull(cxy);\n        out.println(N - hoge.length);\n\n      }\n    }\n\n    long[][] convexHull(long[][] xy) {\n      int N = xy.length;\n      if (N <= 1) return xy;\n      Arrays.sort(xy, new Comparator<long[]>() {\n        @Override\n        public int compare(long[] a, long[] b) {\n          if (a[0] != b[0]) return Long.compare(a[0], b[0]);\n          return Long.compare(a[1], b[1]);\n        }\n      });\n\n      int[] qs = new int[N + 1];//?§????????????????\n      int k = 0;//?????????????????°\n      for (int i = 0; i < N; i++) {\n        if (k >= 1 && xy[qs[k - 1]][0] == xy[i][0] && xy[qs[k - 1]][1] == xy[i][1]) continue;\n        while (k > 1 && ccw(xy[qs[k - 2]], xy[qs[k - 1]], xy[i]) >= 0) k--;\n        qs[k++] = i;\n      }\n\n      int inf = k + 1;\n      for (int i = N - 2; i >= 0; i--) {\n        if (xy[qs[k - 1]][0] == xy[i][0] && xy[qs[k - 1]][1] == xy[i][1]) continue;\n        while (k >= inf && ccw(xy[qs[k - 2]], xy[qs[k - 1]], xy[i]) >= 0) k--;\n        qs[k++] = i;\n      }\n\n      long[][] ret = new long[k - 1][];\n      for (int i = 0; i < k - 1; i++) ret[i] = xy[qs[i]];\n      return ret;\n    }\n\n    int ccw(long[] a, long[] b, long[] t) {\n      return Long.signum((t[0] - a[0]) * (b[1] - a[1]) - (b[0] - a[0]) * (t[1] - a[1]));\n    }\n\n  }\n\n  // Template\n  public static void main(String[] args) {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.Stack;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\t\n\t\tint n, index, count;\n\t\tdouble point[][];\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tn = Integer.valueOf(string);\n\t\t\tif(n == 3){ continue; }\n\t\t\t\n\t\t\tpoint = new double[n][2];\n\t\t\t\n\t\t\tstring = reader.readLine();\n\t\t\tindex = 0;\n\t\t\tpoint[0][0] = Double.valueOf(string.split(\",\")[0]);\n\t\t\tpoint[0][1] = Double.valueOf(string.split(\",\")[1]);\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\tpoint[i][0] = Double.valueOf(string.split(\",\")[0]);\n\t\t\t\tpoint[i][1] = Double.valueOf(string.split(\",\")[1]);\n\t\t\t\t\n\t\t\t\tif(point[i][1] < point[index][1]){\n\t\t\t\t\tindex = i;\n\t\t\t\t}else if(point[i][1] == point[index][1] &&\n\t\t\t\t\t\t point[i][0] < point[index][0]){\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Party> que = new PriorityQueue<Party>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(i != index){\n\t\t\t\t\tdouble radians = Math.atan2((point[i][1] - point[index][1]),\n\t\t\t\t\t\t\t\t\t\t\t\t point[i][0] - point[index][0]);\n\t\t\t\t\n\t\t\t\t\tParty pair = new Party(radians, point[i]);\n\t\t\t\t\tque.add(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tStack<Pair> stack = new Stack<Pair>();\n\t\t\tstack.push(new Pair(que.peek().x, que.poll().y));\n\t\t\tstack.push(new Pair(que.peek().x, que.poll().y));\n\t\t\tcount = 0;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tPair p1 = stack.pop();\n\t\t\t\tPair p2 = stack.pop();\n\t\t\t\t\n\t\t\t\tdouble radians = Math.atan2(p1.y - p2.y, p1.x - p2.x);\n\t\t\t\tif(radians < 0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstack.push(p1);\n\t\t\t\tstack.push(p2);\n\t\t\t\tstack.push(new Pair(que.peek().x, que.poll().y));\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\treader.close();\n\t}\n}\n\nclass Party implements Comparable<Party>{\n\tdouble radians;\n\tdouble x;\n\tdouble y;\n\t\n\tParty(double radians, double point[]){\n\t\tthis.radians = radians;\n\t\tthis.x = point[0];\n\t\tthis.y = point[1];\n\t}\n\n\t@Override\n\tpublic int compareTo(Party o){\n\t\treturn radians - o.radians < 0 ? -1 : 1;\n\t}\n}\n\nclass Pair{\n\tdouble x;\n\tdouble y;\n\t\n\tPair(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tPoint2D.Double p[];\n\t\tint start;\n\t\tint count;\n\n\t\tn = sc.nextInt();\n\t\twhile (n != 0) {\n\t\t\tp = new Point2D.Double[n];\n\t\t\tstart = 0;\n\t\t\tcount = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s[] = sc.next().split(\",\");\n\t\t\t\tp[i] = new Point2D.Double(Double.valueOf(s[0]), Double.valueOf(s[1]));\n\t\t\t\tif (p[i].x < p[start].x) {\n\t\t\t\t\tstart = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint pre = start;\n\t\t\twhile (true) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (i != pre) {\n\t\t\t\t\t\tboolean flag = true;\n\t\t\t\t\t\tfor (int j = 0; j < n && flag; j++) {\n\t\t\t\t\t\t\tif (j != i && j != pre) {\n\t\t\t\t\t\t\t\tflag = isLeft(p[pre], p[i], p[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tpre = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pre == start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(n - count);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static boolean isLeft(Point2D.Double p, Point2D.Double q, Point2D.Double x) {\n\t\tdouble dx1 = q.x - p.x;\n\t\tdouble dy1 = q.y - p.y;\n\t\tdouble dx2 = x.x - p.x;\n\t\tdouble dy2 = x.y - p.y;\n\t\tif (0 < dx1 * dy2 - dx2 * dy1) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\n\nclass Main {\n\n    public static void main(String[] args) throws IOException {\n        doit(args, System.in, System.out);\n    }\n\n    static void doit(String[] args, InputStream in, PrintStream out)\n            throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            if (line.isEmpty()) {\n                continue;\n            }\n            int n = Integer.parseInt(line);\n            if (n == 0) {\n                break;\n            }\n            double[][] points = new double[n][2];\n            for (int i = 0; i < n; i++) {\n                String[] values = reader.readLine().split(\",\");\n                points[i][0] = Double.parseDouble(values[0]);\n                points[i][1] = Double.parseDouble(values[1]);\n            }\n            Arrays.sort(points, new Comparator<double[]>() {\n                @Override\n                public int compare(double[] o1, double[] o2) {\n                    return (int) (o1[0] - o2[0]);\n                }\n            });\n            if (opz(points, 0, 1, 2) < 0.0) {\n                swap(points, 1, 2);\n            }\n            LinkedList<Integer> vertexes = new LinkedList<Integer>();\n            vertexes.add(0);\n            vertexes.add(1);\n            vertexes.add(2);\n            int result = 0;\n            for (int i = 3; i < n; i++) {\n                int a = vertexes.getLast();\n                boolean outer = false;\n                ListIterator<Integer> it = vertexes.listIterator();\n                while (it.hasNext()) {\n                    int b = it.next();\n                    if (opz(points, a, b, i) < 0) {\n                        it.previous();\n                        it.add(i);\n                        outer = true;\n                        break;\n                    }\n                    a = b;\n                }\n                if (!outer) {\n                    result++;\n                }\n            }\n            ListIterator<Integer> it = vertexes.listIterator();\n            int a = it.next();\n            int b = it.next();\n            while (it.hasNext()) {\n                int c = it.next();\n                if (opz(points, a, b, c) < 0) {\n                    it.previous();\n                    it.previous();\n                    it.remove();\n                    result++;\n                    b = it.next();\n                    continue;\n                }\n                a = b;\n                b = c;\n            }\n            if (opz(points, vertexes.get(vertexes.size() - 2), vertexes\n                    .getLast(), vertexes.getFirst()) < 0) {\n                result++;\n            }\n            out.println(result);\n        }\n    }\n\n    private static void swap(double[][] points, int a, int b) {\n        if (a == b) {\n            return;\n        }\n        double[] tmp = points[a];\n        points[a] = points[b];\n        points[b] = tmp;\n    }\n\n    private static double opz(double[][] points, int a, int b, int c) {\n        double x1 = points[b][0] - points[a][0];\n        double y1 = points[b][1] - points[a][1];\n        double x2 = points[c][0] - points[b][0];\n        double y2 = points[c][1] - points[b][1];\n        return x1 * y2 - x2 * y1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static int ccw(double x1, double y1, double x2, double y2, double x3, double y3) {\n\t\tx2 -= x1;x3 -= x1;y2 -= y1;y3 -= y1;\n\t\tdouble c = x2 * y3 - x3 * y2;\n\t\tif (c > 0)return +1;\n\t\tif (c < 0)return -1;\n\t\tif (x2 * x3 + y2 * y3 < 0)return +2;\n\t\tif (x3 * x3 + y3 * y3 - x2 * x2 - y2 * y2 > 0)return -2;\n\t\treturn 0;\n\t}\n\tpublic static double[][] convexHull(double[][] ps) {\n\t\tint n = ps.length, k = 0;\n\t\tArrays.sort(ps, new Comparator<double[]>() {\n\t\t\tpublic int compare(double[] a, double[] b) {\n\t\t\t\tdouble x = a[0] - b[0];\n\t\t\t\tdouble y = a[1] - b[1];\n\t\t\t\tif (x != 0)return x > 0 ? 1 : -1;\n\t\t\t\tif (y != 0)return y > 0 ? 1 : -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\t\tdouble[][] ch = new double[2*n][];\n\t\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\t\twhile (k >= 2 && ccw(ch[k - 2][0], ch[k - 2][1], ch[k - 1][0], ch[k - 1][1], ps[i][0], ps[i][1]) <= 0)\n\t\t\t\t--k;\n\t\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\t\twhile (k >= t && ccw(ch[k - 2][0], ch[k - 2][1], ch[k - 1][0], ch[k - 1][1], ps[i][0], ps[i][1]) <= 0)\n\t\t\t\t--k;\n\t\treturn Arrays.copyOf(ch, k - 1);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[^0-9\\\\-\\\\.]+\");\n\t\twhile(true){\n\t\t\tint n = Integer.parseInt(sc.next());\n\t\t\tif(n==0)break;\n\t\t\tdouble[][] ps = new double[n][2];\n\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\tps[i][0] = Double.parseDouble(sc.next());\n\t\t\t\tps[i][1] = Double.parseDouble(sc.next());\n\t\t\t}\n\t\t\tdouble[][] ch = convexHull(ps);\n\t\t\tSystem.out.println(n-ch.length);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n \nclass Main{\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nArrayList<Point2D> array;\nwhile(!(line=br.readLine()).equals(\"0\")){\nint n=Integer.parseInt(line);\nPoint2D[] points=new Point2D[n];\nfor(int i=0;i<n;i++){\nline=br.readLine();\nString[] values=line.split(\",\");\npoints[i]=new Point2D.Double(Double.parseDouble(values[0]),Double.parseDouble(values[1]));\n}\nArrays.sort(points,new Comparator<Point2D>(){\npublic int compare(Point2D p1,Point2D p2){\nreturn (p1.getY()>p2.getY())?1:(p1.getY()<p2.getY())?-1:(p1.getX()>p2.getX())?1:(p1.getX()<p2.getX())?-1:0;\n}\n});\narray=new ArrayList<Point2D>();\nPoint2D start=points[0];\narray.add(start);\ndouble px=start.getX();\ndouble py=start.getY();\nPoint2D prev=start;\nwhile(true){\nPoint2D min=null;\ndouble minx=0;\ndouble miny=0;\ndouble maxcos=-1;\nfor(Point2D p : points){\nif(p==prev){\ncontinue;\n}\ndouble nx=p.getX()-prev.getX();\ndouble ny=p.getY()-prev.getY();\ndouble cos=(px*nx+py*ny)/(Math.hypot(px,py)*Math.hypot(nx,ny));\nif(cos>maxcos){\nmaxcos=cos;\nminx=nx;\nminy=ny;\nmin=p;\n}\n}\nif(min==start){\nbreak;\n}\npx=minx;\npy=miny;\nprev=min;\narray.add(min);\n}\nSystem.out.println(points.length-array.size());\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tP[] ps;\n\n\tvoid run(){\n\t\tsc.useDelimiter(\",|\\n\");\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps=new P[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tdouble x=sc.nextDouble();\n\t\t\t\tdouble y=sc.nextDouble();\n\t\t\t\tps[i]=new P(x, y);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tArrays.sort(ps, new Comparator<P>(){\n\t\t\t@Override\n\t\t\tpublic int compare(P p1, P p2){\n\t\t\t\treturn (int)((p1.x-p2.x)*10000);\n\t\t\t}\n\t\t});\n\t\tint i=0;\n\t\tboolean[] used=new boolean[n];\n\t\tint ans=n-1;\n\t\tfor(int k=0; k<n-1; k++){\n\t\t\t// debug(i, ps[i].x, ps[i].y);\n\t\t\tused[i]=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(!used[j]&&check(i, j)){\n\t\t\t\t\ti=j;\n\t\t\t\t\tans--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"\"+ans);\n\t}\n\n\tboolean check(int i, int j){\n\t\tdouble a=(ps[j].y-ps[i].y)/(ps[j].x-ps[i].x);\n\t\tdouble b=-a*ps[i].x+ps[i].y;\n\t\tTreeSet<Integer> set=new TreeSet<Integer>();\n\t\tfor(int k=0; k<n; k++){\n\t\t\tif(k!=i&&k!=j){\n\t\t\t\tint sign=0;\n\t\t\t\tif(Math.abs(ps[j].x-ps[i].x)<EPS)\n\t\t\t\t\tsign=(int)Math.signum(ps[k].x-ps[i].x);\n\t\t\t\telse\n\t\t\t\t\tsign=(int)Math.signum(ps[k].y-(a*ps[k].x+b));\n\t\t\t\tset.add(sign);\n\t\t\t}\n\t\t}\n\t\treturn set.size()==1;\n\t}\n\n\tclass P{\n\t\tdouble x, y;\n\n\t\tP(){\n\t\t\tthis(0, 0);\n\t\t}\n\n\t\tP(double x, double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\t static List<Point> points = new ArrayList<Point>();\n\t static List<Point> hull;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint n = (int)sc.nextLong();\n\t\t\tpoints.clear();\n\t\t\tif(n == 0) break;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tString[] tmp = sc.next().split(\",\");\n\t\t\t\tdouble x = Double.parseDouble(tmp[0]);\n\t\t\t\tdouble y = Double.parseDouble(tmp[1]);\n\t\t\t\t\n\t\t\t\tPoint p = new Point(x,y);\n\t\t\t\tpoints.add(p);\n\t\t\t\t\n\t\t\t}\n\t\t\tcreateConvexHull();\n\t\t\tout.println((points.size() - hull.size() + 2));\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t   \n    static double getSignedArea(Point p1, Point p2, Point p3){\n        return (p2.x - p1.x) * (p3.y - p1.y) \n                - (p3.x - p1.x) * (p2.y - p1.y);\n    }\n    static void createConvexHull(){\n        //X??§?¨???§????????????\n        Collections.sort(points, new Comparator<Point>() {\n            public int compare(Point o1, Point o2) {\n            \tif(o1.x < o2.x) return -1;\n            \telse if(o1.x > o2.x) return 1;\n            \treturn 0;\n            }\n        });\n        \n        //??????????±???????\n        hull = new ArrayList<Point>();\n        List<Point> proc = hull;\n        for(int k = 0; k < 2; ++k){\n            //1????????§?????´???2????????§?????´??????????????????\n            proc.add(points.get(0));\n            proc.add(points.get(1));\n            for(int i = 2; i < points.size(); ++i){\n                Point p = points.get(i);\n                for(;;){\n                    Point q1 = proc.get(proc.size() - 2);\n                    Point q2 = proc.get(proc.size() - 1);\n                    double s = getSignedArea(q1, q2, p);\n                    if(k == 0){\n                        if(s < 0) break;\n                    }else{\n                        if(s > 0) break;\n                    }\n                    proc.remove(proc.size() - 1);\n                    if(proc.size() < 2) break;\n                }\n                proc.add(p);\n            }\n            if(k == 0) proc = new ArrayList<Point>();\n        }\n\n        //????????????\n        for(int i = 0; i < proc.size(); ++i){\n            hull.add(proc.get(proc.size() - i - 1));\n        }\n    }\n\t\n\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n\n}\n\nclass Point {\n\tDouble x;\n\tDouble y;\n\tPoint(double a, double b) {\n\t\tx = a;\n\t\ty = b;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n while(true){\n  int n=ir.nextInt();\n  if(n==0) return;\n  P[] ps=new P[n];\n  for(int i=0;i<n;i++){\n   ps[i]=new P(ir.nextDouble(),ir.nextDouble());\n  }\n  P[] c=convexHull(ps);\n  out.println(ps.length-c.length);\n  System.gc();\n }\n}\n\npublic static P[] convexHull(P[] ps){\n int n=ps.length;\n Arrays.sort(ps,new Comparator<P>(){\n  public int compare(P a,P b){\n   if(a.getX()!=b.getY()) return Double.compare(a.getX(),b.getX());\n   return Double.compare(a.getY(),b.getY());\n  }\n });\n int p=0;\n P[] qs=new P[2*n];\n for(int i=0;i<n;i++){\n  while(p>1&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n for(int i=n-2,t=p;i>=0;i--){\n  while(p>t&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n return Arrays.copyOf(qs,p-1);\n}\n\nstatic final double EPS=1e-10;\n\npublic static accurateTotal(double a,double b){\n if(Math.abs(a+b)<EPS*(Math.abs(a)+Math.abs(b))) return 0.0;\n return a+b;\n}\n\nstatic class P{\n\n public double x,y;\n\n public P(double x,double y){\n  this.x=x; this.y=y;\n }\n\n public double getX(){\n  return this.x;\n }\n\n public double getY(){\n  return this.y;\n }\n\n public P add(P v){\n  return new P(accurateTotal(this.x,v.x),accurateTotal(this.y,v.y));\n }\n\n public P sub(P v){\n  return new P(accurateTotal(this.x,-v.x),accurateTotal(this.y,-v.y));\n }\n\n public P mul(double k){\n  return new P(this.x*k,this.y*k);\n }\n\n public double dot(P v){\n  return accurateTotal(this.x*v.x,this.y*v.y);\n }\n\n public double det(P v){\n  return accurateTotal(this.x*v.y,-this.y*v.x);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126)||(c==',');}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.Stack;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\t\n\t\tint n, index, count;\n\t\tdouble point[][];\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tn = Integer.valueOf(string);\n\t\t\tif(n == 3){ continue; }\n\t\t\t\n\t\t\tpoint = new double[n][2];\n\t\t\t\n\t\t\tstring = reader.readLine();\n\t\t\tindex = 0;\n\t\t\tpoint[0][0] = Double.valueOf(string.split(\",\")[0]);\n\t\t\tpoint[0][1] = Double.valueOf(string.split(\",\")[1]);\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\tpoint[i][0] = Double.valueOf(string.split(\",\")[0]);\n\t\t\t\tpoint[i][1] = Double.valueOf(string.split(\",\")[1]);\n\t\t\t\t\n\t\t\t\tif(point[i][0] < point[index][0]){\n\t\t\t\t\tindex = i;\n\t\t\t\t}else if(point[i][0] == point[index][0] &&\n\t\t\t\t\t\t point[i][1] < point[index][1]){\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Party> que = new PriorityQueue<Party>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(i != index){\n\t\t\t\t\tdouble radians = Math.atan2((point[i][1] - point[index][1]),\n\t\t\t\t\t\t\t\t\t\t\t\t point[i][0] - point[index][0]);\n\t\t\t\t\n\t\t\t\t\tParty party = new Party(radians, point[i]);\n\t\t\t\t\tque.add(party);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tStack<Pair> stack = new Stack<Pair>();\n\t\t\tstack.push(new Pair(que.peek().x, que.poll().y));\n\t\t\tstack.push(new Pair(que.peek().x, que.poll().y));\n\t\t\tstack.push(new Pair(que.peek().x, que.poll().y));\n\t\t\tcount = 0;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tPair p1 = stack.pop();\n\t\t\t\tPair p2 = stack.pop();\n\t\t\t\tPair p3 = stack.pop();\n\t\t\t\t\n\t\t\t\tPair vec1 = new Pair(p2.x - p1.x, p2.y - p1.y);\n\t\t\t\tPair vec2 = new Pair(p3.x - p1.x, p3.y - p1.y);\n\t\t\t\t\n\t\t\t\tif(0 >= vec1.x * vec2.y - vec1.y * vec2.x){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstack.push(p1);\n\t\t\t\tstack.push(p2);\n\t\t\t\tstack.push(p3);\n\t\t\t\tstack.push(new Pair(que.peek().x, que.poll().y));\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\treader.close();\n\t}\n}\n\nclass Party implements Comparable<Party>{\n\tdouble radians;\n\tdouble x;\n\tdouble y;\n\t\n\tParty(double radians, double point[]){\n\t\tthis.radians = radians;\n\t\tthis.x = point[0];\n\t\tthis.y = point[1];\n\t}\n\n\t@Override\n\tpublic int compareTo(Party o){\n\t\treturn radians - o.radians < 0 ? -1 : 1;\n\t}\n}\n\nclass Pair{\n\tdouble x;\n\tdouble y;\n\t\n\tPair(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tPoint p[]=new Point[n];\n\t\t\tPoint q[]=new Point[n*2];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tString st[]=in.next().split(\",\");\n\t\t\t\tp[i]=new Point(Double.valueOf(st[0]), Double.valueOf(st[1]));\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(p,new PointComparator());\n\t\t\t\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\twhile(k>1 && cross(q[k-1].x-q[k-2].x, q[k-1].y-q[k-2].y , p[i].x-q[k-1].x, p[i].y-q[k-1].y)<=0)\n\t\t\t\t\t\tk--;\n\t\t\t\tq[k++]=p[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=n-2,t=k;i>=0;i--)\n\t\t\t{\n\t\t\t\twhile(k>t && cross(q[k-1].x-q[k-2].x, q[k-1].y-q[k-2].y , p[i].x-q[k-1].x, p[i].y-q[k-1].y)<=0)\n\t\t\t\t\t\tk--;\n\t\t\t\tq[k++]=p[i];\n\t\t\t}\n\t\t\tSystem.out.println(n-k+1);\n\t\t}\n\t}\n\t\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n\t\n\tstatic double cross(double x1,double y1, double x2,double y2)\n\t{\n\t\treturn x1*y2-y1*x2;\n\t}\n}\n\nclass Point\n{\n\tdouble x;\n\tdouble y;\n\tPoint(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}\n\nclass PointComparator implements Comparator<Point>\n{\n\tpublic int compare(Point p1,Point p2)\n\t{\n\t\tdouble cmp=p1.x-p2.x;\n\t\tif(cmp==0)\n\t\t\tcmp=p1.y-p2.y;\n\t\tif(cmp<0)\n\t\t\tcmp=-1;\n\t\telse\n\t\t\tcmp=1;\n\t\treturn (int) cmp;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n \nclass Main{\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nArrayList<Point2D> array;\nwhile((line=br.readLine())!=null){\nint n=Integer.parseInt(line);\nPoint2D[] points=new Point2D[n];\nfor(int i=0;i<n;i++){\nline=br.readLine();\nString[] values=line.split(\",\");\npoints[i]=new Point2D.Double(Double.parseDouble(values[0]),Double.parseDouble(values[1]));\n}\nArrays.sort(points,new Comparator<Point2D>(){\npublic int compare(Point2D p1,Point2D p2){\nreturn (p1.getY()>p2.getY())?1:(p1.getY()<p2.getY())?-1:(p1.getX()>p2.getX())?1:(p1.getX()<p2.getX())?-1:0;\n}\n});\narray=new ArrayList<Point2D>();\nPoint2D start=points[0];\narray.add(start);\ndouble px=start.getX();\ndouble py=start.getY();\nPoint2D prev=start;\nwhile(true){\nPoint2D min=null;\ndouble minx=0;\ndouble miny=0;\ndouble maxcos=-1;\nfor(Point2D p : points){\nif(p==prev){\ncontinue;\n}\ndouble nx=p.getX()-prev.getX();\ndouble ny=p.getY()-prev.getY();\ndouble cos=(px*nx+py*ny)/(Math.hypot(px,py)*Math.hypot(nx,ny));\nif(cos>maxcos){\nmaxcos=cos;\nminx=nx;\nminy=ny;\nmin=p;\n}\n}\nif(min==start){\nbreak;\n}\npx=minx;\npy=miny;\nprev=min;\narray.add(min);\n}\nSystem.out.println(points.length-array.size());\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n/**\n * AOj id=0068\n * Enclose Pins with a Rubber Band\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s\");\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\t\n\t\t\tArrayList<double[]> l = new ArrayList<double[]>(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tl.add(new double[]{sc.nextDouble(), sc.nextDouble()});\n\t\t\t}\n\t\t\tsolve(n, l);\t\n\t\t}\n\t}\n\n\tpublic void solve(int n, ArrayList<double[]> l) {\n\t\tCollections.sort(l, new DoubleArrayComparator());\n\t\t\n\t\tLinkedList<double[]> resu = new LinkedList<double[]>();\n\t\tresu.add(l.get(0));\n\t\tresu.add(l.get(1));\n\t\t\n\t\tfor(int i=2;i<l.size();i++){\n\t\t\tresu.add(l.get(i));\n\t\t\twhile(resu.size()>=3){\n\t\t\t\tint len = resu.size();\n\t\t\t\tdouble[] p1 = resu.get(len-3);\n\t\t\t\tdouble[] p2 = resu.get(len-2);\n\t\t\t\tdouble[] p3 = resu.get(len-1);\n\t\t\t\t\n\t\t\t\tdouble vx1 = p2[0]-p1[0];\n\t\t\t\tdouble vy1 = p2[1]-p1[1];\n\t\t\t\tdouble vx2 = p3[0]-p1[0];\n\t\t\t\tdouble vy2 = p3[1]-p1[1];\n\t\t\t\t\n\t\t\t\tif(vx1*vy2-vx2*vy1 < 0 )\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tresu.remove(len-2);\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tLinkedList<double[]> resd = new LinkedList<double[]>();\n\t\tresd.add(l.get(l.size()-1));\n\t\tresd.add(l.get(l.size()-2));\n\t\tfor(int i=l.size()-2;i>=0;i--){\n\t\t\tresd.add(l.get(i));\n\t\t\twhile(resd.size()>=3){\n\t\t\t\tint len = resd.size();\n\t\t\t\tdouble[] p1 = resd.get(len-3);\n\t\t\t\tdouble[] p2 = resd.get(len-2);\n\t\t\t\tdouble[] p3 = resd.get(len-1);\n\t\t\t\t\n\t\t\t\tdouble vx1 = p2[0]-p1[0];\n\t\t\t\tdouble vy1 = p2[1]-p1[1];\n\t\t\t\tdouble vx2 = p3[0]-p1[0];\n\t\t\t\tdouble vy2 = p3[1]-p1[1];\n\t\t\t\t\n\t\t\t\tif(vx1*vy2-vx2*vy1 < 0 )\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tresd.remove(len-2);\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(n-resu.size()-resd.size()+2);\n\t\t\n\t\t\n\t}\n\n\tpublic class DoubleArrayComparator implements Comparator<double[]>{\n\t\t@Override\n\t\tpublic int compare(double[] o1, double[] o2) {\n\t\t\tif(o1[0]==o2[0])\n\t\t\t\treturn Double.compare(o1[1], o2[1]);\n\t\t\telse\n\t\t\t\treturn Double.compare(o1[0], o2[0]);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\n\nclass Point {\n\tdouble x,y;\n\tPoint(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tboolean NotEqual(Point p) {\n\t\tif (this.x==p.x&&this.y==p.y) return false;\n\t\telse return true;\n\t}\n}\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile ((buf = br.readLine())!=null) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tPoint p[] = new Point[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tbuf = br.readLine();\n\t\t\t\t\tStringTokenizer st = new StringTokenizer(buf,\",\");\n\t\t\t\t\tp[i] = new Point(Double.parseDouble(st.nextToken()),Double.parseDouble(st.nextToken()));\n\t\t\t\t}\n\t\t\t\tquicksort(0,n-1,p);\n\t\t\t\tPoint ans[] = construct(n,p);\n\t\t\t\tSystem.out.println(n-ans.length);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Point[] construct(int n,Point p[]) {\n\t\treturn construct_left(n,p);\n\t}\n\n\tpublic static Point[] construct_left(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[1];\n\t\t\tc[1] = p[0];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[2],p[1],p[0])<0) {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[0];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[0];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nl[] = new Point[n];\n\t\tlc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmax = c2[0].x;\n\t\tfor (int i=1;i<c2.length;i++) {\n\t\t\tif (xmax<c2[i].x) {\n\t\t\t\txmax = c2[i].x;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tnl[lc] = c2[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\t\t\t\n\t\t}\n\t\tnl[lc++] = cnt1[1];\n\t\tpt = 0;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tnl[lc++] = cnt1[0];\n\t\tpt = (pt+1)%c1.length;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\tnl[lc] = c1[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tnl[lc++] = cnt2[0];\n\t\tpt = 0;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\t\tif (cnt2[1].NotEqual(c2[mem])) {\n\t\t\tnl[lc++] = cnt2[1];\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(c2[mem])) {\n\t\t\tnl[lc] = c2[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\n\t\tPoint c[] = new Point[lc];\n\t\tfor (int i=0;i<lc;i++) c[i] = nl[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static Point[] construct_right(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[0];\n\t\t\tc[1] = p[1];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[0],p[1],p[2])>0) {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[2];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[2];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nr[] = new Point[n];\n\t\trc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmin = c1[0].x;\n\t\tfor (int i=1;i<c1.length;i++) {\n\t\t\tif (xmin>c1[i].x) {\n\t\t\t\txmin = c1[i].x;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tnr[rc] = c1[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\n\t\tnr[rc++] = cnt1[0];\n\t\tpt = 0;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tnr[rc++] = cnt1[1];\n\t\tpt = (pt+1)%c2.length;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\tnr[rc] = c2[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tnr[rc++] = cnt2[1];\n\t\tpt = 0;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\t\tif (cnt2[0].NotEqual(c1[mem])) {\n\t\t\tnr[rc++] = cnt2[0];\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(c1[mem])) {\n\t\t\tnr[rc] = c1[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\t\n\n\t\tPoint c[] = new Point[rc];\n\t\tfor (int i=0;i<rc;i++) c[i] = nr[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static void quicksort(int low,int high,Point p[]) {\n\t\tif (high>low) {\n\t\t\tint mid = (low+high)/2;\n\t\t\tdouble x = p[mid].x;\n\t\t\tint i = low;\n\t\t\tint j = high;\n\t\t\twhile (p[i].x<x) i++;\n\t\t\twhile (p[j].x>x) j--;\n\t\t\tif (i<=j) {\n\t\t\t\tPoint t =p[i];\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\ti++;j--;\n\t\t\t}\n\t\t\tquicksort(low,j,p);\n\t\t\tquicksort(i,high,p);\n\t\t}\n\t}\n\n\tpublic static double S(Point p0,Point p1,Point p2) {\n\t\treturn (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Point{\n\t\tpublic double x,y;\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\tpublic Point(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tdouble getTheta(Point p,Point p0){\n\t\tdouble theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y));\n\t\tif(p.y<p0.y)theta=Math.PI*2-theta;\n\t\treturn theta;\n\t}\n\t\n\tint solve(Point[] points){\n\t\tPoint start=points[0];\n\t\tfor(Point v:points){\n\t\t\tif(v.y<start.y)start=v;\n\t\t}\n\t\tPoint p0=start;\n\t\tint n=0;\n\t\tdouble prev=0;\n\t\tdo{\n\t\t\tdouble min=Math.PI*3;\n\t\t\tPoint next=p0;\n\t\t\tfor(Point p: points){\n\t\t\t\tdouble theta=getTheta(p,p0);\n\t\t\t\tif(theta>=prev&&theta<min){\n\t\t\t\t\tmin=theta;\n\t\t\t\t\tnext=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp0=next;\n\t\t\tprev=min;\n\t\t\t++n;\n\t\t}while(p0!=start);\n\t\treturn points.length-n;\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\"+System.getProperty(\"line.separator\"));\n\t\t\n\t\tint n;\n\t\tPoint[] points;\n\t\twhile((n=ni())!=0){\n\t\t\tpoints=new Point[n];\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tpoints[i]=new Point(nd(),nd());\n\t\t\t}\n\t\t\tSystem.out.println(solve(points));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main(){\n\t\tnew AOJ0068().doIt();\n\t}\n\t\n\t\n\tclass AOJ0068{\n\t\tint n;\n\t\tPoint2D p[];\n\t\t\n\t\tvoid solve(){\n\t\t\tPoint2D[] a = convexHull(p);\n//\t\t\tSystem.out.println(Arrays.toString(a));\n\t\t\tSystem.out.println(p.length-a.length);\n\t\t}\n\t\t\n\t\tvoid doIt(){\n\t\t\twhile(in.hasNext()){\n\t\t\t\tn = in.nextInt();\n\t\t\t\tif(n==0)break;\n\t\t\t\tp = new Point2D[n];\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tString[] a = in.next().split(\",\");\n\t\t\t\t\tp[i] = new Point2D.Double(Double.parseDouble(a[0]),Double.parseDouble(a[1]));\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(Arrays.toString(p));\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t//凸包 返上は含めない\n\t\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\t\tpublic int compare(Point2D p1,Point2D p2) {\n\t\t\t\tif(p1.getX() < p2.getX()) return -1;\n\t\t\t\telse if(p1.getX() > p2.getX()) return 1; \n\t\t\t\telse if(p1.getY() < p2.getY()) return -1;\n\t\t\t\telse if(p1.getY() > p2.getY()) return 1; \n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\tPoint2D[] convexHull(Point2D []plist) { \n\t\t\tint n = plist.length; Arrays.sort(plist, com);\n\t\t\tint k = 0;\n\t\t\tPoint2D [] qs = new Point2D[n * 2]; \n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\t\twhile(k > t && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\t\treturn res; \n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine() == true) {\n\t\t\tint lines = Integer.parseInt(sc.nextLine());\n\t\t\tif (lines == 0) break;\n\t\t\t\n\t\t\tBigDecimal[][] points = new BigDecimal[lines][2];\n\t\t\tfor (int i = 0; i < lines; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < nico.length; j++) {\n\t\t\t\t\tpoints[i][j] = new BigDecimal(nico[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[] flag = new boolean[points.length];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\tfor (int j = (i + 1); j < points.length; j++) {\n\t\t\t\t\tBigDecimal dx = points[j][0].subtract(points[i][0]);\n\t\t\t\t\tBigDecimal dy = points[j][1].subtract(points[i][1]);\n\t\t\t\t\t\n\t\t\t\t\tboolean judge = true;\n\t\t\t\t\tif (dx.compareTo(BigDecimal.valueOf(0.0)) != 0) {\n\t\t\t\t\t\tBigDecimal a = dy.divide(dx, BigDecimal.ROUND_HALF_UP);\n\t\t\t\t\t\tBigDecimal b = points[i][1].subtract(a.multiply(points[i][0]));\n\n\t\t\t\t\t\tBigDecimal side = BigDecimal.valueOf(0.0);\n\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\tBigDecimal nside = BigDecimal.valueOf(0.0);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\tnside = points[k][1].subtract(a.multiply(points[k][0]).add(b));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((side.compareTo(BigDecimal.valueOf(0.0)) != 0) && (side.multiply(nside).compareTo(BigDecimal.valueOf(0.0)) < 0)) {\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tBigDecimal side = BigDecimal.valueOf(0.0);\n\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\tBigDecimal nside = BigDecimal.valueOf(0.0);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\tnside = points[k][0].subtract(points[i][0]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ((side.compareTo(BigDecimal.valueOf(0.0)) != 0) && (side.multiply(nside).compareTo(BigDecimal.valueOf(0.0)) < 0)) {\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (judge == true) {\n\t\t\t\t\t\tflag[i] = false;\n\t\t\t\t\t\tflag[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tif (flag[i] == true) cnt++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tPoint ps[] = new Point[n];\n\t\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tps[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tPoint[] qs = convexHull(ps);\n\t\t\tSystem.out.println(n - qs.length);\n\t\t}\n\t}\n\n\tstatic double cross(Point a, Point b) {\n\t\treturn a.y * b.x - a.x * b.y;\n\t}\n\n\tstatic double dot(Point a, Point b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\n\tstatic Point[] convexHull(Point[] V) {\n\t\tint n = V.length;\n\t\tArrays.sort(V); // x, yのプライオリティで昇順ソート\n\t\tint k = 0; // resのindex\n\t\tPoint[] res = new Point[2 * n];\n\t\t/* lower-hull */\n\t\tfor (int i = 0; i < n; res[k++] = V[i++])\n\t\t\twhile (k >= 2 && ccw(res[k - 2], res[k - 1], V[i]) <= 0)\n\t\t\t\t--k;\n\t\t/* upper-hull */\n\t\t// t=|lower-hull|+1\n\t\tfor (int i = n - 2, t = k + 1; i >= 0; res[k++] = V[i--])\n\t\t\twhile (k >= t && ccw(res[k - 2], res[k - 1], V[i]) <= 0)\n\t\t\t\t--k;\n\n\t\treturn Arrays.copyOf(res, k - 1); // 最後の点res[k-1]はlower-hullの始点なのでいらない\n\t}\n\n\tstatic int ccw(Point a, Point b, Point c) {\n\t\tPoint tempb = b.sub(a);\n\t\tPoint tempc = c.sub(a);\n\t\tif (cross(tempb, tempc) > 0)\n\t\t\treturn +1; // counter clockwise\n\t\tif (cross(tempb, tempc) < 0)\n\t\t\treturn -1; // clockwise\n\t\tif (dot(tempb, tempc) < 0)\n\t\t\treturn +2; // (c--a--b or b--a--c) on line\n\t\tif (tempb.normsq() < tempc.normsq())\n\t\t\treturn -2; // (a--b--c or c--b--a) on line (a=b≠c)\n\t\treturn 0; // (a--c--b or b--c--a) on line (c=b, a=c, a=b=cも含む)\n\t}\n}\n\nclass Point extends Point2D.Double implements Comparable<Point> {\n\tstatic final double EPS = 1e-10;\n\n\tstatic boolean EQ(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tprivate static final long serialVersionUID = -1781994971111328877L;\n\n\t// constructor\n\tpublic Point() {\n\t\tsuper();\n\t}\n\n\tpublic Point(double x, double y) {\n\t\tsuper(x, y);\n\t}\n\n\tpublic Point(Point p) {\n\t\tsuper(p.x, p.y);\n\t}\n\n\t// setter\n\tpublic void set(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic void set(Point p) {\n\t\tthis.x = p.x;\n\t\tthis.y = p.y;\n\t}\n\n\t// norm\n\tpublic double norm() {\n\t\treturn Math.sqrt(normsq());\n\t}\n\n\tpublic double normsq() {\n\t\treturn x * x + y * y;\n\t}\n\n\t// addition, subtraction, multiplication, division\n\tpublic Point add(Point p) {\n\t\treturn new Point(x + p.x, y + p.y);\n\t}\n\n\tpublic Point sub(Point p) {\n\t\treturn new Point(x - p.x, y - p.y);\n\t}\n\n\tpublic Point mul(double k) {\n\t\treturn new Point(k * x, k * y);\n\t}\n\n\tpublic Point div(double k) {\n\t\treturn new Point(x / k, y / k);\n\t}\n\n\t// 単位法線ベクトル(の一つ)\n\tpublic Point normalVector() {\n\t\tdouble d = this.norm();\n\t\treturn new Point(-y / d, x / d);\n\t}\n\n\t// compareTo x座標優先比較\n\tpublic int compareTo(Point o) {\n\t\treturn (this.x != o.x) ? ((this.x < o.x) ? -1 : 1)\n\t\t\t\t: ((this.y < o.y) ? -1 : (this.y > o.y) ? 1 : 0);\n\t}\n\t// ........................................\n} // class Point"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.ArrayList;\n\nclass Point {\n\tdouble x,y;\n\n\tPoint(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile (!(buf = br.readLine()).equals(\"0\")) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tPoint p[] = new Point[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tbuf = br.readLine();\n\t\t\t\t\tStringTokenizer st = new StringTokenizer(buf,\",\");\n\t\t\t\t\tp[i] = new Point(Double.parseDouble(st.nextToken()),Double.parseDouble(st.nextToken()));\n\t\t\t\t}\n\t\t\t\tquicksort(0,n-1,p);\n\t\t\t\tsorty(n,p);\n\t\t\t\tint c = convexhull(n,p);\n\t\t\t\tSystem.out.println(n-c);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static int convexhull(int n,Point p[]) { //逐次追加法\n\t\tArrayList<Point> ans = new ArrayList<Point>();\n\t\tif (S(p[2],p[1],p[0])>=0) { //CCWまたは一直線\n\t\t\tans.add(p[2]);\n\t\t\tans.add(p[1]);\n\t\t\tans.add(p[0]);\n\t\t} else { //CW\n\t\t\tans.add(p[2]);\n\t\t\tans.add(p[0]);\n\t\t\tans.add(p[1]);\n\t\t}\n\n\t\tfor (int i=3;i<n;i++) {\n\t\t\tint s = ans.size();\n\t\t\tPoint cnt_up,cnt_down;\n\t\t\tint j = 0;\n\t\t\tint k = 1;\n\t\t\twhile (S(p[i],ans.get(j),ans.get(k))<0) { //CW\n\t\t\t\tj = (j+1)%s;\n\t\t\t\tk = (k+1)%s;\n\t\t\t}\n\t\t\tcnt_up = ans.get(j);\n\t\t\tj = 0;\n\t\t\tk = s-1;\n\t\t\twhile (S(p[i],ans.get(j),ans.get(k))>0) { //CCW\n\t\t\t\tj = (j+s-1)%s;\n\t\t\t\tk = (k+s-1)%s;\n\t\t\t}\n\t\t\tcnt_down = ans.get(j);\n\n\t\t\tArrayList<Point> construct = new ArrayList<Point>();\n\t\t\tconstruct.add(p[i]);\n\t\t\tfor (int l=ans.indexOf(cnt_up);l!=ans.indexOf(cnt_down);l=(l+1)%s) {\n\t\t\t\tconstruct.add(ans.get(l));\n\t\t\t}\n\t\t\tconstruct.add(cnt_down);\n\n\t\t\tans.clear();\n\t\t\tfor (int l=0;l<construct.size();l++) {\n\t\t\t\tans.add(construct.get(l));\n\t\t\t}\n\t\t}\n\t\treturn ans.size();\n\t}\n\n\tpublic static void quicksort(int low,int high,Point p[]) {\n\t\tif (high>low) {\n\t\t\tint mid = (low+high)/2;\n\t\t\tdouble x = p[mid].x;\n\t\t\tint i = low;\n\t\t\tint j = high;\n\t\t\twhile (p[i].x<x) i++;\n\t\t\twhile (p[j].x>x) j--;\n\t\t\tif (i<=j) {\n\t\t\t\tPoint t =p[i];\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\ti++;j--;\n\t\t\t}\n\t\t\tquicksort(low,j,p);\n\t\t\tquicksort(i,high,p);\n\t\t}\n\t}\n\n\tpublic static void sorty(int n,Point p[]) {\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tint j = i-1;\n\t\t\twhile (p[j].x==p[j+1].x&&p[j].y>p[j+1].y) {\n\t\t\t\tPoint t = p[j+1];\n\t\t\t\tp[j+1] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\tj--;\n\t\t\t\tif (j<0) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double S(Point p0,Point p1,Point p2) {\n\t\treturn (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid solve() {\n\t\tint n = sc.nextInt();\n\t\tif (n == 0) return;\n\t\tP[] ps = new P[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString[] ss = sc.next().split(\",\");\n\t\t\tps[i] = new P(Double.parseDouble(ss[0]), Double.parseDouble(ss[1]));\n\t\t}\n\t\tP[] con = convexHull(ps);\n\t\tSystem.out.println(ps.length - con.length);\n\t}\n\n\tfinal double EPS = 1e-10;\n\n\tstatic class P implements Comparable<P> {\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn x != o.x ? Double.compare(x, o.x) : Double.compare(y, o.y);\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t\tpublic double abs() {return sqrt(x * x + y * y); }\n\t\tpublic double abs2() {return (x * x + y * y); }\n\t\tpublic double arg() { return atan2(y, x); } // (-pi 〜 pi)\n\t\tpublic double dist(P o) {return this.sub(o).abs(); }\n\t\tpublic P mul(double k) {return new P(x * k, y * k);}\n\t\tpublic P div(double k) {return new P(x / k, y / k);}\n\t\tpublic P add(P o) {return new P(x + o.x, y + o.y);}\n\t\tpublic P sub(P o) {return new P(x - o.x, y - o.y);}\n\t\tpublic P mul(P o) {return new P(x * o.x - y * o.y,  x * o.y + y * o.x); }\n\t\tpublic P div(P o) {return new P(x * o.x + y * o.y, -x * o.y + y * o.x).div(o.abs2()); }\n\t\tpublic double dot(P o) {return x * o.x + y * o.y;} // a b sin(t)\n\t\tpublic double det(P o) {return x * o.y - y * o.x;} // a b cos(t)\n\t\tpublic P normal() { return this.div(this.abs()); }\n\t\tpublic P rot90() { return new P(-y, x); }\n\t\tpublic static P polar(double d, double rad) {return new P(d * Math.cos(rad), d * Math.sin(rad));}\n\t}\n\tP[] convexHull(P[] ps) {\n\t\tint n = ps.length;\n\t\tif (n <= 1) return ps;\n\t\tsort(ps);\n\t\tint k = 0;\n\t\tP[] qs = new P[n * 2];\n\t\tfor (int i = 0; i < n; qs[k++] = ps[i++]) {\n\t\t\twhile (k > 1 && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) < EPS) k--;\n\t\t}\n\t\tfor (int i = n-2, t = k; i >= 0; qs[k++] = ps[i--]) {\n\t\t\twhile (k > t && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) < EPS) k--;\n\t\t}\n\t\treturn copyOf(qs, k-1);\n\t}\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\n\nclass Point {\n\tdouble x,y;\n\tPoint(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tboolean NotEqual(Point p) {\n\t\tif (this.x==p.x&&this.y==p.y) return false;\n\t\telse return true;\n\t}\n}\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile ((buf = br.readLine())!=null) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tPoint p[] = new Point[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tbuf = br.readLine();\n\t\t\t\t\tStringTokenizer st = new StringTokenizer(buf,\",\");\n\t\t\t\t\tp[i] = new Point(Double.parseDouble(st.nextToken()),Double.parseDouble(st.nextToken()));\n\t\t\t\t}\n\t\t\t\tquicksort(0,n-1,p);\n\t\t\t\tsorty(n,p);\n\t\t\t\tPoint ans[] = construct(n,p);\n\t\t\t\tSystem.out.println(n-ans.length);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Point[] construct(int n,Point p[]) {\n\t\treturn construct_left(n,p);\n\t}\n\n\tpublic static Point[] construct_left(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[1];\n\t\t\tc[1] = p[0];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[2],p[1],p[0])<0) {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[0];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[0];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nl[] = new Point[n];\n\t\tlc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmax = c2[0].x;\n\t\tfor (int i=1;i<c2.length;i++) {\n\t\t\tif (xmax<c2[i].x) {\n\t\t\t\txmax = c2[i].x;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tnl[lc] = c2[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\t\t\t\n\t\t}\n\t\tnl[lc++] = cnt1[1];\n\t\tpt = 0;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tnl[lc++] = cnt1[0];\n\t\tpt = (pt+1)%c1.length;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\tnl[lc] = c1[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tnl[lc++] = cnt2[0];\n\t\tpt = 0;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\t\tif (cnt2[1].NotEqual(c2[mem])) {\n\t\t\tnl[lc++] = cnt2[1];\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(c2[mem])) {\n\t\t\tnl[lc] = c2[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\n\t\tPoint c[] = new Point[lc];\n\t\tfor (int i=0;i<lc;i++) c[i] = nl[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static Point[] construct_right(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[0];\n\t\t\tc[1] = p[1];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[0],p[1],p[2])>0) {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[2];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[2];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nr[] = new Point[n];\n\t\trc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmin = c1[0].x;\n\t\tfor (int i=1;i<c1.length;i++) {\n\t\t\tif (xmin>c1[i].x) {\n\t\t\t\txmin = c1[i].x;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tnr[rc] = c1[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\n\t\tnr[rc++] = cnt1[0];\n\t\tpt = 0;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tnr[rc++] = cnt1[1];\n\t\tpt = (pt+1)%c2.length;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\tnr[rc] = c2[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tnr[rc++] = cnt2[1];\n\t\tpt = 0;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t}\n\t\tif (cnt2[0].NotEqual(c1[mem])) {\n\t\t\tnr[rc++] = cnt2[0];\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(c1[mem])) {\n\t\t\tnr[rc] = c1[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\t\n\n\t\tPoint c[] = new Point[rc];\n\t\tfor (int i=0;i<rc;i++) c[i] = nr[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static void quicksort(int low,int high,Point p[]) {\n\t\tif (high>low) {\n\t\t\tint mid = (low+high)/2;\n\t\t\tdouble x = p[mid].x;\n\t\t\tint i = low;\n\t\t\tint j = high;\n\t\t\twhile (p[i].x<x) i++;\n\t\t\twhile (p[j].x>x) j--;\n\t\t\tif (i<=j) {\n\t\t\t\tPoint t =p[i];\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\ti++;j--;\n\t\t\t}\n\t\t\tquicksort(low,j,p);\n\t\t\tquicksort(i,high,p);\n\t\t}\n\t}\n\n\tpublic static void sorty(int n,Point p[]) {\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tint j = i-1;\n\t\t\twhile (p[i].x==p[j].x&&p[j].y>p[i].y) {\n\t\t\t\tPoint t = p[j];\n\t\t\t\tp[j] = p[i];\n\t\t\t\tp[i] = t;\n\t\t\t\tj--;\n\t\t\t\tif (j<0) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double S(Point p0,Point p1,Point p2) {\n\t\treturn (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n  private static class Task {\n    void solve(FastScanner in, PrintWriter out) {\n      while (true) {\n        int N = in.nextInt();\n        if (N == 0) break;\n        Double[][] xy = new Double[N][2];\n        for (int i = 0; i < N; i++) {\n          String s = in.next();\n          String[] sxy = s.split(\",\");\n          xy[i][0] = Double.parseDouble(sxy[0]);\n          xy[i][1] = Double.parseDouble(sxy[1]);\n        }\n        ConvexHull<Double> c = new ConvexHull<Double>();\n        out.println(N - c.convexHull(xy).size());\n\n      }\n    }\n\n  }\n\n  static class ConvexHull<T extends Number> {\n    ArrayList<T[]> convexHull(T[][] xy) {\n      int N = xy.length;\n      if (N <= 1) {\n        ArrayList<T[]> list = new ArrayList<>();\n        Collections.addAll(list, xy);\n        return list;\n      }\n      Arrays.sort(xy, new Comparator<T[]>() {\n        @Override\n        public int compare(T[] a, T[] b) {\n          if (!a[0].equals(b[0])) return Double.compare(a[0].doubleValue(), b[0].doubleValue());\n          return Double.compare(a[1].doubleValue(), b[1].doubleValue());\n        }\n      });\n\n      int[] qs = new int[N + 1];//?§????????????????\n      int k = 0;//?????????????????°\n      for (int i = 0; i < N; i++) {\n        if (k >= 1 && xy[qs[k - 1]][0].equals(xy[i][0]) && xy[qs[k - 1]][1].equals(xy[i][1])) continue;\n        while (k > 1 && ccw(xy[qs[k - 2]], xy[qs[k - 1]], xy[i]) >= 0) k--;\n        qs[k++] = i;\n      }\n\n      int inf = k + 1;\n      for (int i = N - 2; i >= 0; i--) {\n        if (xy[qs[k - 1]][0] == xy[i][0] && xy[qs[k - 1]][1] == xy[i][1]) continue;\n        while (k >= inf && ccw(xy[qs[k - 2]], xy[qs[k - 1]], xy[i]) >= 0) k--;\n        qs[k++] = i;\n      }\n\n      ArrayList<T[]> ret = new ArrayList<>(k - 1);\n      for (int i = 0; i < k - 1; i++) ret.add(xy[qs[i]]);\n      return ret;\n    }\n\n    double ccw(T[] a, T[] b, T[] t) {\n      return (t[0].doubleValue() - a[0].doubleValue()) * (b[1].doubleValue() - a[1].doubleValue()) - (b[0].doubleValue() - a[0].doubleValue()) * (t[1].doubleValue() - a[1].doubleValue());\n    }\n  }\n\n  // Template\n  public static void main(String[] args) {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Point{\n\t\tpublic double x,y;\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t\t\n\t\tpublic Point(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tdouble getTheta(Point p,Point p0){\n\t\tdouble theta=Math.acos((p.x-p0.x)/Math.hypot(p.x-p0.x,p.y-p0.y));\n\t\tif(p.y<p0.y)theta=Math.PI*2-theta;\n\t\treturn theta;\n\t}\n\t\n\tint solve(Point[] points){\n\t\tPoint start=points[0];\n\t\tfor(Point v:points){\n\t\t\tif(v.y<start.y)start=v;\n\t\t}\n\t\tPoint p0=start;\n\t\tint n=0;\n\t\tdouble prev=0;\n\t\tdo{\n\t\t\tdouble min=Math.PI*3;\n\t\t\tPoint next=p0;\n\t\t\tfor(Point p: points){\n\t\t\t\tdouble theta=getTheta(p,p0);\n\t\t\t\tif(theta>=prev&&theta<min){\n\t\t\t\t\tmin=theta;\n\t\t\t\t\tnext=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp0=next;\n\t\t\tprev=min;\n\t\t\t++n;\n\t\t}while(p0!=start);\n\t\treturn points.length-n;\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");\n\t\t\n\t\tint n;\n\t\tPoint[] points;\n\t\twhile((n=ni())!=0){\n\t\t\tpoints=new Point[n];\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tpoints[i]=new Point(nd(),nd());\n\t\t\t}\n\t\t\tSystem.out.println(solve(points));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t\n\tvoid io(){\n\t\t\n\t\twhile(true){\n\t\t\tint n = ni();\n\t\t\tif(n==0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t// 一番左の点から\n\t\t\tint left=0;\n\t\t\tdouble[][] map = new double[n][2];\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tmap[i] = ndl();\n\t\t\t\tif(map[i][0] < map[left][0]){\n\t\t\t\t\tleft = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinal int last = left;\n\t\t\tint now = left;\n\t\t\tint count = n;\n\t\t\t// 一番左なので、真上を指すベクトルから\n\t\t\tdouble[] v = new double[]{0., 1.};\n\t\t\tdo{\n\t\t\t\t--count;\n\t\t\t\tdouble min = 360.1;\n\t\t\t\tint i_best = 0;\n\t\t\t\tdouble[] v_best = v;\n\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\t// 自身以外の全探索\n\t\t\t\t\tif(i!=now){\n\t\t\t\t\t\t// 進行方向ベクトル, vに対する角度を求める\n\t\t\t\t\t\t\n\t\t\t\t\t\t// 内積から0~180度の角度を得る\n\t\t\t\t\t\tdouble[] v_ = new double[]{map[i][0]-map[now][0], map[i][1]-map[now][1]};\n\t\t\t\t\t\tdouble ab = v[0]*v_[0] + v[1]*v_[1];\n\t\t\t\t\t\tdouble a_ = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n\t\t\t\t\t\tdouble b_ = Math.sqrt(v_[0]*v_[0] + v_[1]*v_[1]);\n\t\t\t\t\t\tdouble cos_ = ab/(a_*b_);\n\t\t\t\t\t\tdouble ang_ = Math.toDegrees(Math.acos(cos_));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// 外積で左向いていたら180度げたはかせる\n\t\t\t\t\t\tdouble axb = v[0]*v_[1] - v[1]*v_[0];\n\t\t\t\t\t\tif(axb > 0){\n\t\t\t\t\t\t\tang_ = 360. - ang_;  //(180. - ang_) + 180.\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//debug(map[now], map[i], ang_);\n\t\t\t\t\t\t// 方向ベクトルに対する一番時計回りに近い点を得る\n\t\t\t\t\t\tif(ang_ < min){\n\t\t\t\t\t\t\tmin = ang_;\n\t\t\t\t\t\t\ti_best = i;\n\t\t\t\t\t\t\tv_best = v_;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 点の移動\n\t\t\t\tnow = i_best;\n\t\t\t\tv = v_best;\n\t\t\t}while(now!=last);\n\t\t\t\n\t\t\t// 残りのn(count)が中に入っている点の数\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tdouble[] ndl(){\n\t\tString[] str = sc.next().split(\",\");\n\t\tdouble args[] = new double[2];\n\t\tfor(int i=0; i<2; ++i){\n\t\t\targs[i] = Double.parseDouble(str[i]);\n\t\t}\n\t\treturn args;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().io();\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string, str[];\n\t\t\n\t\tint n, t;\n\t\tdouble x, y, x1, y1, maxslope, tmp, d, h;\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tn = Integer.valueOf(string);\n\t\t\t\n\t\t\tArrayList<Pair> list = new ArrayList<Pair>();\n\t\t\tArrayList<Integer> res = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstr = reader.readLine().split(\",\");\n\t\t\t\t\n\t\t\t\tx = Double.parseDouble(str[0]);\n\t\t\t\ty = Double.parseDouble(str[1]);\n\t\t\t\tlist.add(new Pair(x, y));\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tdouble dx = list.get(0).x;\n\t\t\tdouble dy = list.get(0).y;\n\t\t\t\n\t\t\tt = 1;\n\t\t\tmaxslope = (list.get(1).y - dy) / (list.get(1).x - dx);\n\t\t\tfor(int i = 2; i < n; i++){\n\t\t\t\tx = list.get(i).x;\n\t\t\t\ty = list.get(i).y;\n\t\t\t\t\n\t\t\t\ttmp = (y - dy) / (x - dx);\n\t\t\t\tif(maxslope < tmp){\n\t\t\t\t\tmaxslope = tmp;\n\t\t\t\t\tt = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tres.add(0);\n\t\t\tres.add(t);\n\t\t\twhile(true){\n\t\t\t\th = 0;\n\t\t\t\tt = 0;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tx = list.get(i).x;\n\t\t\t\t\ty = list.get(i).y;\n\t\t\t\t\t\n\t\t\t\t\tx1 = list.get(res.get(res.size() - 1)).x;\n\t\t\t\t\ty1 = list.get(res.get(res.size() - 1)).y;\n\t\t\t\t\t\n\t\t\t\t\tdx = list.get(res.get(res.size() - 2)).x;\n\t\t\t\t\tdy = list.get(res.get(res.size() - 2)).y;\n\t\t\t\t\t\n\t\t\t\t\tdx = dx - x1;\n\t\t\t\t\tdy = dy - y1;\n\t\t\t\t\t\n\t\t\t\t\tx = x - x1;\n\t\t\t\t\ty = y - y1;\n\t\t\t\t\t\n\t\t\t\t\td = ((dx * x) + (dy * y)) / (Math.hypot(dx, dy) * Math.hypot(x, y));\n\t\t\t\t\td = Math.acos(d);\n\t\t\t\t\tif(h < d){\n\t\t\t\t\t\tt = i;\n\t\t\t\t\t\th = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(t == 0) break;\n\t\t\t\tres.add(t);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(n - res.size());\n\t\t}\n\t\treader.close();\n\t}\n}\n\nclass Pair implements Comparable<Pair>{\n\tdouble x;\n\tdouble y;\n\t\n\tPair(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pair o) {\n\t\treturn x > o.x ? 1 : -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n while(true){\n  int n=ir.nextInt();\n  if(n==0) return;\n  P[] ps=new P[n];\n  for(int i=0;i<n;i++){\n   ps[i]=new P(ir.nextDouble(),ir.nextDouble());\n  }\n  P[] c=convexHull(ps);\n  out.println(ps.length-c.length);\n  System.gc();\n }\n}\n\npublic static P[] convexHull(P[] ps){\n int n=ps.length;\n Arrays.sort(ps,new Comparator<P>(){\n  public int compare(P a,P b){\n   if(a.getX()!=b.getX()) return Double.compare(a.getX(),b.getX());\n   return Double.compare(a.getY(),b.getY());\n  }\n });\n int p=0;\n P[] qs=new P[2*n];\n for(int i=0;i<n;i++){\n  while(p>1&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n for(int i=n-2,t=p;i>=0;i--){\n  while(p>t&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n return Arrays.copyOf(qs,p-1);\n}\n\nstatic final double EPS=1e-10;\n\npublic static double accurateTotal(double a,double b){\n if(Math.abs(a+b)<EPS*(Math.abs(a)+Math.abs(b))) return 0.0;\n return a+b;\n}\n\nstatic class P{\n\n public double x,y;\n\n public P(double x,double y){\n  this.x=x; this.y=y;\n }\n\n public double getX(){\n  return this.x;\n }\n\n public double getY(){\n  return this.y;\n }\n\n public P add(P v){\n  return new P(accurateTotal(this.x,v.x),accurateTotal(this.y,v.y));\n }\n\n public P sub(P v){\n  return new P(accurateTotal(this.x,-v.x),accurateTotal(this.y,-v.y));\n }\n\n public P mul(double k){\n  return new P(this.x*k,this.y*k);\n }\n\n public double dot(P v){\n  return accurateTotal(this.x*v.x,this.y*v.y);\n }\n\n public double det(P v){\n  return accurateTotal(this.x*v.y,-this.y*v.x);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126)||(c==',');}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] ps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] str=sc.next().split(\",\");\n\t\t\t\tps[i]=new P(Double.parseDouble(str[0]),Double.parseDouble(str[1]));\n\t\t\t}\n\t\t\tArrays.sort(ps);\n\t\t\tint k=0;\n\t\t\tP[] qs =new P[2*n];\n\t\t\t//下側\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\twhile(k>1 && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;//凸包になるまで戻す\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\t//上側\n\t\t\tfor(int i=n-2,t=k;i>=0;i--){\n\t\t\t\twhile(k>t && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\tqs=Arrays.copyOf(qs,k-1);\n\n\t\t\tln(ps.length-qs.length);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}\n\nclass P implements Comparable<P>{\n\tdouble x,y;\n\tP(double _x,double _y){\n\t\tx=_x;\n\t\ty=_y;\n\t}\n\t@Override\n\tpublic int compareTo(P o) {\n\t\tif(x>o.x){\n\t\t\treturn 1;\n\t\t}else if(x<o.x){\n\t\t\treturn -1;\n\t\t}\n\t\treturn y>o.y?1:y<o.y?-1:0;\n\t}\n\tpublic static  double cross(P a,P b){\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n\tpublic P s(P a){\n\t\treturn new P(x-a.x,y-a.y);\n\t}\n\tpublic String toString(){\n\t\treturn \"(\"+x+\",\"+y+\")\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner in = new Scanner(System.in);\n\n\tclass P{\n\n\t\tdouble x;\n\n\t\tdouble y;\n\n\t\tint i;\n\n\t\tP(double x,double y,int i){\n\n\t\t\tthis.x = x;\n\n\t\t\tthis.y = y;\n\n\t\t\tthis.i = i;\n\n\t\t}\n\n\t\tP dir;\n\n\t}\n\n\tvoid run(){\n\n\t\tfor(;;){\n\n\t\t\tScanner sc = new Scanner(in.nextLine().replace(',', ' '));\n\n\t\t\tint n= sc.nextInt();\n\n\t\t\tif(n==0) break;\n\n\t\t\tif(n==1){\n\n\t\t\t\tSystem.out.println(\"0\");\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tP[] p = new P[n];\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tdouble minx = Double.MAX_VALUE;\n\n\t\t\tint first = 0;\n\n\t\t\tfor(int i=0; i< n; i++){\n\n\t\t\t\tsc = new Scanner(in.nextLine().replace(',', ' '));\n\n\t\t\t\tp[i] = new P(sc.nextDouble(),sc.nextDouble(),i);\n\n\t\t\t\tif(minx > p[i].x){\n\n\t\t\t\t\tfirst = i;\n\n\t\t\t\t\tminx = p[i].x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tp[first].dir = new P(0,1,-1);\n\n\t\t\tP now = p[first];\n\n\t\t\tused[now.i] = true;\n\n\t\t\tfor(;;){\n\n//\t\t\t\tSystem.out.println(\" \"+now.i);\n\n\t\t\t\tdouble min = Double.MAX_VALUE;\n\n\t\t\t\tint next = 0;\n\n\t\t\t\tfor(int i = 0; i < n;i++){\n\n\t\t\t\t\tif(i == now.i) continue;\n\n\t\t\t\t\tdouble y = Math.atan2((p[i].y-now.y)*now.dir.x - (p[i].x-now.x)*now.dir.y,-(p[i].y-now.y)*now.dir.y - (p[i].x-now.x)*now.dir.x);\n\n\t\t\t\t\tif(min > y){\n\n\t\t\t\t\t\tmin = y;\n\n\t\t\t\t\t\tnext = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n//\t\t\t\tSystem.out.println(\"  \"+min/Math.PI*180);\n\n\t\t\t\tif(used[next]){\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tused[next] = true;\n\n\t\t\t\tP dir = new P(p[next].x-now.x,p[next].y-now.y,next);\n\n\t\t\t\tnow = p[next];\n\n\t\t\t\tp[next].dir = dir;\n\n\t\t\t}\n\n\t\t\tint sum = 0;\n\n\t\t\tfor(int i=0; i< n; i++){\n\n\t\t\t\tif(!used[i]) sum++;\n\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args){\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\n\nclass Point {\n\tdouble x,y;\n\tPoint(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tboolean NotEqual(Point p) {\n\t\tif (this.x==p.x&&this.y==p.y) return false;\n\t\telse return true;\n\t}\n}\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile ((buf = br.readLine())!=null) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tPoint p[] = new Point[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tbuf = br.readLine();\n\t\t\t\t\tStringTokenizer st = new StringTokenizer(buf,\",\");\n\t\t\t\t\tp[i] = new Point(Double.parseDouble(st.nextToken()),Double.parseDouble(st.nextToken()));\n\t\t\t\t}\n\t\t\t\tquicksort(0,n-1,p);\n\t\t\t\tsorty(n,p);\n\t\t\t\tPoint ans[] = construct(n,p);\n\t\t\t\tSystem.out.println(n-ans.length);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Point[] construct(int n,Point p[]) {\n\t\treturn construct_left(n,p);\n\t}\n\n\tpublic static Point[] construct_left(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[1];\n\t\t\tc[1] = p[0];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[2],p[1],p[0])<0) {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[0];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[0];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nl[] = new Point[n];\n\t\tlc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmax = c2[0].x;\n\t\tdouble ymax = c2[0].y;\n\t\tfor (int i=1;i<c2.length;i++) {\n\t\t\tif (xmax<c2[i].x) {\n\t\t\t\txmax = c2[i].x;\n\t\t\t\tymax = c2[i].y;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t} else if (xmax==c2[i].x&&ymax<c2[i].y) {\n\t\t\t\tymax = c2[i].y;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tnl[lc] = c2[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\t\t\t\n\t\t}\n\t\tnl[lc++] = cnt1[1];\n\t\tpt = 0;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tnl[lc++] = cnt1[0];\n\t\tpt = (pt+1)%c1.length;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\tnl[lc] = c1[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tif (cnt1[0].NotEqual(cnt2[0])) {\n\t\t\tnl[lc++] = cnt2[0];\n\t\t\tpt = 0;\n\t\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t\tif (cnt2[1].NotEqual(c2[mem])) {\n\t\t\t\tnl[lc++] = cnt2[1];\n\t\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t\twhile (pt<c2.length&&c2[pt].NotEqual(c2[mem])) {\n\t\t\t\tnl[lc] = c2[pt];\n\t\t\t\tlc++;\n\t\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint c[] = new Point[lc];\n\t\tfor (int i=0;i<lc;i++) c[i] = nl[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static Point[] construct_right(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[0];\n\t\t\tc[1] = p[1];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[0],p[1],p[2])>0) {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[2];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[2];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nr[] = new Point[n];\n\t\trc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmin = c1[0].x;\n\t\tdouble ymin = c1[0].y;\n\t\tfor (int i=1;i<c1.length;i++) {\n\t\t\tif (xmin>c1[i].x) {\n\t\t\t\txmin = c1[i].x;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t} else if (xmin==c1[i].x&&ymin>c1[i].y) {\n\t\t\t\tymin = c1[i].y;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tnr[rc] = c1[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\n\t\tnr[rc++] = cnt1[0];\n\t\tpt = 0;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tnr[rc++] = cnt1[1];\n\t\tpt = (pt+1)%c2.length;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\tnr[rc] = c2[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tif (cnt1[0].NotEqual(cnt2[0])) {\n\t\t\tnr[rc++] = cnt2[1];\n\t\t\tpt = 0;\n\t\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t\tif (cnt2[0].NotEqual(c1[mem])) {\n\t\t\t\tnr[rc++] = cnt2[0];\n\t\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (pt<c1.length&&c1[pt].NotEqual(c1[mem])) {\n\t\t\t\tnr[rc] = c1[pt];\n\t\t\t\trc++;\n\t\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t\t}\t\n\t\t}\n\t\tPoint c[] = new Point[rc];\n\t\tfor (int i=0;i<rc;i++) c[i] = nr[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static void quicksort(int low,int high,Point p[]) {\n\t\tif (high>low) {\n\t\t\tint mid = (low+high)/2;\n\t\t\tdouble x = p[mid].x;\n\t\t\tint i = low;\n\t\t\tint j = high;\n\t\t\twhile (p[i].x<x) i++;\n\t\t\twhile (p[j].x>x) j--;\n\t\t\tif (i<=j) {\n\t\t\t\tPoint t =p[i];\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\ti++;j--;\n\t\t\t}\n\t\t\tquicksort(low,j,p);\n\t\t\tquicksort(i,high,p);\n\t\t}\n\t}\n\n\tpublic static void sorty(int n,Point p[]) {\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tint j = i-1;\n\t\t\twhile (p[j].x==p[j+1].x&&p[j].y>p[j+1].y) {\n\t\t\t\tPoint t = p[j+1];\n\t\t\t\tp[j+1] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\tj--;\n\t\t\t\tif (j<0) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double S(Point p0,Point p1,Point p2) {\n\t\treturn (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n//グラハムスキャン\n//幾何\n//凸包\nclass Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] ps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] str=sc.next().split(\",\");\n\t\t\t\tps[i]=new P(Double.parseDouble(str[0]),Double.parseDouble(str[1]));\n\t\t\t}\n\t\t\tArrays.sort(ps);\n\n\t\t\tint k=0;\n\t\t\tP[] qs =new P[2*n];\n\t\t\t//下側\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\twhile(k>1 && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;//凸包になるまで戻す\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\t//上側\n\t\t\tfor(int i=n-2,t=k;i>=0;i--){\n\t\t\t\twhile(k>t && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\tqs=Arrays.copyOf(qs,k-1);\n\n\t\t\tln(ps.length-qs.length);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}\n\nclass P implements Comparable<P>{\n\tdouble x;\n\tdouble y;\n\tP(double _x,double _y){\n\t\tx=_x;\n\t\ty=_y;\n\t}\n\t@Override\n\tpublic int compareTo(P o) {\n\t\tif(this.x!=o.x){\n\t\t\treturn (int)(this.x-o.x);\n\t\t}\n\t\treturn (int)(this.y-o.y);\n\t}\n\n\tpublic static double dot(P a,P b){\n\t\t\treturn a.x*b.x+a.y*b.y;\n\t}\n\tpublic static  double cross(P a,P b){\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n\tpublic static boolean isParallel(P a1,P a2,P b1,P b2){\n\t\treturn Math.abs(cross(a2.s(a1),b2.s(b1)))<Double.MIN_NORMAL;\n\t}\n\tpublic static boolean isVertical(P a1,P a2,P b1,P b2){\n\t\treturn Math.abs(dot(a2.s(a1),b2.s(b1)))<Double.MIN_NORMAL;\n\t}\n\n\tpublic P a(P a){\n\t\treturn new P(x+a.x,y+a.y);\n\t}\n\tpublic P s(P a){\n\t\treturn new P(x-a.x,y-a.y);\n\t}\n\n\tpublic double norm(){\n\t\treturn Math.sqrt(x*x+y*y);\n\t}\n\n\tpublic static int ccw(P a,P b,P c){\n\t\tif(P.cross(b.s(a),c.s(a))>Double.MIN_NORMAL){\n\t\t\treturn 1;\n\t\t}\n\t\tif(P.cross(b.s(a),c.s(a))<-Double.MIN_NORMAL){\n\t\t\treturn -1;\n\t\t}\n\t\tif(P.dot(b,c)<-Double.MIN_NORMAL)return 2;\n\t\tif(b.norm()<c.norm()-Double.MIN_NORMAL)return -2;\n\t\treturn 0;\n\t}\n\tpublic String toString(){\n\t\treturn \"(\"+x+\",\"+y+\")\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.awt.geom.Point2D;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Comparator;\n\nclass Main{\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nArrayList<Point2D> array;\nwhile((line=br.readLine()!=null){\nint n=Integer.parseInt(line);\nPoint2D[] points=new Point2D[n];\nfor(int i=0;i<n;i++){\nline=br.readLine();\nString[] values=line.split(\",\");\npoints[i]=new Point2D.Double(Double.parseDouble(values[0]),Double.parseDouble(values[1]));\n}\nArrays.sort(points,new Comparator<Point2D>(){\npublic int compare(Point2D p1,Point2D p2){\nreturn (p1.getY()>p2.getY())?1:(p1.getY()<p2.getY())?-1:(p1.getX()>p2.getX())?1:(p1.getX()<p2.getX())?-1:0;\n}\n});\narray=new ArrayList<Point2D>();\nPoint2D start=points[0];\narray.add(now);\ndouble px=start.getX();\ndouble py=start.getY();\nPoint2D prev=start;\nwhile(true){\nPoint2D min=null;\ndouble minx=0;\ndouble miny=0;\ndouble maxcos=-1;\nfor(Point2D p : points){\nif(p==prev){\ncontinue;\n}\ndouble nx=p.getX()-prev.getX();\ndouble ny=p.getY()-prev.getY();\ndouble cos=(px*nx+py*ny)/(Math.hypot(px,py)*Math.hypot(nx,ny));\nif(cos>maxcos){\nmaxcos=cos;\nminx=nx;\nminy=ny;\nmin=p;\n}\n}\nif(min==start){\nbreak;\n}\npx=minx;\npy=miny;\nprev=min;\narray.add(min);\n}\nSystem.out.println(points.length()-array.size());\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Point2D;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D[] ps = new Point2D[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tps[i] = new Point2D.Double(Double.parseDouble(s[0]),Double.parseDouble(s[1]));\n\t\t\t}\n\t\t\tSystem.out.println(n-makeConvexHull(ps));\n\t\t}\n\t}\n\n\tstatic int num;\n\tprivate static int makeConvexHull(Point2D[] ps){\n\t\tnum = ps.length;\n\t\tint minIndex = 0;\n\t\tdouble minY = ps[0].getY();\n\t\tdouble maxX = ps[0].getX();\n\t\tfor(int i=1;i<num;i++){\n\t\t\tif(minY > ps[i].getY()\n\t\t\t\t || (minY == ps[i].getY() && maxX < ps[i].getX())){\n\t\t\t\tmaxX = ps[i].getX();\n\t\t\t\tminY = ps[i].getY();\n\t\t\t\tminIndex = i;\n\t\t\t}\n\t\t}\n\n\t\tdouble rad,find,now=0.0,dist=0.0;\n\t\tint j;\n\t\tfor(j=0;j<num;j++){\n\t\t\tPoint2D tmp = ps[j];\n\t\t\tps[j] = ps[minIndex];\n\t\t\tps[minIndex] = tmp;\n\t\t\tfind = 360;\n\t\t\tfor(int i=j+1;i<num;i++){\n\t\t\t\trad = getTheta(ps[j],ps[i]);\n\t\t\t\tif(!ps[j].equals(ps[i]) && find >= rad && rad >= now){\n\t\t\t\t\tif(find != rad || find == rad\n\t\t\t\t\t\t && dist < ps[j].distance(ps[i])){\n\t\t\t\t\t\tdist = ps[j].distance(ps[i]);\n\t\t\t\t\t\tfind = rad;\n\t\t\t\t\t\tminIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(find == 360 || minIndex == num){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnow = find;\n\t\t}\n\t\tj++;\n\t\twhile(ps[0].equals(ps[j-1])){\n\t\t\tj--;\n\t\t}\n\t\tnum = j;\n\t\treturn num;\n\t}\n\n\tprivate static double getTheta(Point2D p1, Point2D p2){\n\t\tdouble dx,dy,ax,ay;\n\t\tdouble t;\n\t\tdx = p2.getX() - p1.getX();\n\t\tax = dx >= 0 ? dx : -dx;\n\t\tdy = p2.getY() - p1.getY();\n\t\tay = dy >= 0 ? dy : -dy;\n\n\t\tt = (ax + ay == 0) ? 0 : dy / (ax + ay);\n\t\tif(dx < 0){\n\t\t\tt = 2 - t;\n\t\t}\n\t\telse if(dy < 0){\n\t\t\tt += 4;\n\t\t}\n\t\treturn t * 90.0;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n while(true){\n  int n=ir.nextInt();\n  if(n==0) return;\n  P[] ps=new P[n];\n  for(int i=0;i<n;i++){\n   ps[i]=new P(ir.nextDouble(),ir.nextDouble());\n  }\n  P[] c=convexHull(ps);\n  out.println(ps.length-c.length);\n  System.gc();\n }\n}\n\npublic static P[] convexHull(P[] ps){\n int n=ps.length;\n Arrays.sort(ps,new Comparator<P>(){\n  public int compare(P a,P b){\n   if(a.getX()!=b.getY()) return Double.compare(a.getX(),b.getX());\n   return Double.compare(a.getY(),b.getY());\n  }\n });\n int p=0;\n P[] qs=new P[2*n];\n for(int i=0;i<n;i++){\n  while(p>1&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n for(int i=n-2,t=p;i>=0;i--){\n  while(p>t&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n return Arrays.copyOf(qs,p-1);\n}\n\nstatic final double EPS=1e-10;\n\npublic static double accurateTotal(double a,double b){\n if(Math.abs(a+b)<EPS*(Math.abs(a)+Math.abs(b))) return 0.0;\n return a+b;\n}\n\nstatic class P{\n\n public double x,y;\n\n public P(double x,double y){\n  this.x=x; this.y=y;\n }\n\n public double getX(){\n  return this.x;\n }\n\n public double getY(){\n  return this.Y;\n }\n\n public P add(P v){\n  return new P(accurateTotal(this.x,v.x),accurateTotal(this.y,v.y));\n }\n\n public P sub(P v){\n  return new P(accurateTotal(this.x,-v.x),accurateTotal(this.y,-v.y));\n }\n\n public P mul(double k){\n  return new P(this.x*k,this.y*k);\n }\n\n public double dot(P v){\n  return accurateTotal(this.x*v.x,this.y*v.y);\n }\n\n public double det(P v){\n  return accurateTotal(this.x*v.y,-this.y*v.x);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126)||(c==',');}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n while(true){\n  int n=ir.nextInt();\n  if(n==0) return;\n  P[] ps=new P[n];\n  for(int i=0;i<n;i++){\n   ps[i]=new P(ir.nextDouble(),ir.nextDouble());\n  }\n  P[] c=convexHull(ps);\n  out.println(ps.length-c.length);\n  System.gc();\n }\n}\n\npublic static P[] convexHull(P[] ps){\n int n=ps.length;\n Arrays.sort(ps,new Comparator<P>(){\n  public int compare(P a,P b){\n   if(a.getX()!=b.getY()) return Double.compare(a.getX(),b.getX());\n   return Double.compare(a.getY(),b.getY());\n  }\n });\n int p=0;\n P[] qs=new P[2*n];\n for(int i=0;i<n;i++){\n  while(p>1&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n for(int i=n-2,t=p;i>=0;i--){\n  while(p>t&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n return Arrays.copyOf(qs,p-1);\n}\n\nstatic final double EPS=1e-10;\n\npublic static accurateTotal(double a,double b){\n if(Math.abs(a+b)<EPS*(Math.abs(a)+Math.abs(b))) return 0.0;\n return a+b;\n}\n\nstatic class P{\n\n public double x,y;\n\n public P(double x,double y){\n  this.x=x; this.y=y;\n }\n\n public double getX(){\n  return this.x;\n }\n\n public double getY(){\n  return this.Y;\n }\n\n public P add(P v){\n  return new P(accurateTotal(this.x,v.x),accurateTotal(this.y,v.y));\n }\n\n public P sub(P v){\n  return new P(accurateTotal(this.x,-v.x),accurateTotal(this.y,-v.y));\n }\n\n public P mul(double k){\n  return new P(this.x*k,this.y*k);\n }\n\n public double dot(P v){\n  return accurateTotal(this.x*v.x,this.y*v.y);\n }\n\n public double det(P v){\n  return accurateTotal(this.x*v.y,-this.y*v.x);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126)||(c==',');}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public BigInteger nextBigInteger(){return new BigInteger(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n    \n     \n    public static void main(String[] args) {\n    \tMain app = new Main();\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()){\n            int n = sc.nextInt(),left = 0,ans = 0,end,sta; \n            if(n == 0)break;\n            double[][] p = new double[n][2];\n            \n            for(int i=0;i<n;i++){\n                String[] s = sc.next().split(\",\");\n                p[i][0] = Double.parseDouble(s[0]);\n                p[i][1] = Double.parseDouble(s[1]);\n            }\n            \n            \n            \n            \n            boolean[] judge1 = new boolean[n];\n            for(int i=1;i<n;i++){\n            \tif(p[i][0]<p[left][0])left=i;\n            }\n            judge1[left]=true;\n            end = left;\n            sta = left;\n            \n            \n            \n            \n            \n            while(true){\n                for(int i = 0;i < n;i++){\n                    if(sta == i)continue;\n                    boolean judge2 = true;\n                    for(int j  =0;j  < n;j++){\n                        if(j == sta||j == i)continue;\n                        if(app.doing(p[sta][0], p[sta][1], p[i][0], p[i][1], p[j][0], p[j][1]) <= 0){\n                            judge2 = false;\n                            break;\n                        }\n                    }\n                    if(judge2){\n                        judge1[i] = true;\n                        sta = i;\n                        break;\n                    }\n                }\n                if(sta == end)break;\n            }\n            for(int i = 0;i < n;i++){\n            \tif(!judge1[i])ans++;\n            }\n            System.out.println(ans);\n        }\n    }\n\n    double doing(double x1, double y1, double x2, double y2, double x3, double y3){\n        double dx1 = x2-x1,\n        \t   dy1 = y2-y1,\n        \t   dx2 = x3-x1,\n        \t   dy2 = y3-y1;\n        return (dx1*dy2)-(dx2*dy1);\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tpublic double x,y;\n\t\t\n\t\tdouble norm(){\n\t\t\treturn Math.hypot(x,y);\n\t\t}\n\t\tpublic Vector(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tVector sub(Vector a,Vector b){\n\t\treturn new Vector(a.x-b.x,a.y-b.y);\n\t}\n\t\n\tdouble op(Vector a,Vector b){\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n\tdouble ip(Vector a,Vector b){\n\t\treturn a.x*b.x+a.y*b.y;\n\t}\n\t\n\tclass VectorComparator implements Comparator<Vector>{\n\t\t@Override\n\t\tpublic int compare(Vector o1, Vector o2) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tdouble sign=o1.y-o2.y;\n\t\t\tif(sign==0)sign=(o1.x-o2.x);\n\t\t\treturn (int)Math.signum(sign);\n\t\t}\n\t}\n\t\n\tint solve(LinkedList<Vector> coords){\n\t\tCollections.sort(coords,new VectorComparator());\n\n\t\tVector p0=coords.getFirst(),p=p0;\n\t\tVector v=new Vector(1,0);\n\n\t\tdo{\n\t\t\tdouble cosmax=-2;\n\t\t\tVector qmax=null;\n\t\t\tfor(Vector q:coords){\n\t\t\t\tVector u=sub(q,p);\n\t\t\t\tdouble cos=ip(v,u)/(v.norm()*u.norm());\n\t\t\t\tif(op(v,u)>=0&&cos>cosmax){\n\t\t\t\t\tcosmax=cos;\n\t\t\t\t\tqmax=q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv=sub(qmax,p);\n\t\t\tp=qmax;\n\t\t\tcoords.remove(p);\n\t\t}while(p!=p0);\n\t\treturn coords.size();\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");\n\t\tLinkedList<Vector> coords=new LinkedList<Vector>();\n\t\t\n\t\tint n;\n\t\twhile((n=ni())!=0){\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tcoords.add(new Vector(nd(),nd()));\n\t\t\t}\n\t\t\tSystem.out.println(solve(coords));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\n\nclass Point {\n\tdouble x,y;\n\tPoint(double x,double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tboolean NotEqual(Point p) {\n\t\tif (this.x==p.x&&this.y==p.y) return false;\n\t\telse return true;\n\t}\n}\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\n\t\ttry {\n\t\t\twhile (!(buf = br.readLine()).equals(\"0\")) {\n\t\t\t\tint n = Integer.parseInt(buf);\n\t\t\t\tPoint p[] = new Point[n];\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tbuf = br.readLine();\n\t\t\t\t\tStringTokenizer st = new StringTokenizer(buf,\",\");\n\t\t\t\t\tp[i] = new Point(Double.parseDouble(st.nextToken()),Double.parseDouble(st.nextToken()));\n\t\t\t\t}\n\t\t\t\tquicksort(0,n-1,p);\n\t\t\t\tsorty(n,p);\n\t\t\t\tPoint ans[] = construct(n,p);\n\t\t\t\tSystem.out.println(n-ans.length);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static Point[] construct(int n,Point p[]) {\n\t\treturn construct_left(n,p);\n\t}\n\n\tpublic static Point[] construct_left(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[1];\n\t\t\tc[1] = p[0];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[2],p[1],p[0])<0) {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[0];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[2];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[0];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nl[] = new Point[n];\n\t\tlc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmax = c2[0].x;\n\t\tdouble ymax = c2[0].y;\n\t\tfor (int i=1;i<c2.length;i++) {\n\t\t\tif (xmax<c2[i].x) {\n\t\t\t\txmax = c2[i].x;\n\t\t\t\tymax = c2[i].y;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t} else if (xmax==c2[i].x&&ymax<c2[i].y) {\n\t\t\t\tymax = c2[i].y;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tnl[lc] = c2[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+(c2.length-1))%c2.length;\t\t\t\n\t\t}\n\t\tnl[lc++] = cnt1[1];\n\t\tpt = 0;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tnl[lc++] = cnt1[0];\n\t\tpt = (pt+1)%c1.length;\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\tnl[lc] = c1[pt];\n\t\t\tlc++;\n\t\t\tpt = (pt+1)%c1.length;\n\t\t}\n\t\tif (cnt1[0].NotEqual(cnt2[0])) {\n\t\t\tnl[lc++] = cnt2[0];\n\t\t\tpt = 0;\n\t\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t\tif (cnt2[1].NotEqual(c2[mem])) {\n\t\t\t\tnl[lc++] = cnt2[1];\n\t\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t\twhile (pt<c2.length&&c2[pt].NotEqual(c2[mem])) {\n\t\t\t\tnl[lc] = c2[pt];\n\t\t\t\tlc++;\n\t\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint c[] = new Point[lc];\n\t\tfor (int i=0;i<lc;i++) c[i] = nl[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static Point[] construct_right(int n,Point p[]) {\n\t\tif (n==2) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tc[0] = p[0];\n\t\t\tc[1] = p[1];\n\t\t\treturn c;\n\t\t} else if (n==3) {\n\t\t\tPoint c[] = new Point[n];\n\t\t\tif (S(p[0],p[1],p[2])>0) {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[2];\n\t\t\t\tc[2] = p[1];\n\t\t\t} else {\n\t\t\t\tc[0] = p[0];\n\t\t\t\tc[1] = p[1];\n\t\t\t\tc[2] = p[2];\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\n\t\tPoint pl[] = new Point[n/2];\n\t\tPoint pr[] = new Point[n/2+1];\n\n\t\tfor (int i=0;i<n/2;i++) {\n\t\t\tpl[i] = p[i];\n\t\t\tpr[i] = p[n/2+i];\n\t\t}\n\t\tint mid = n/2;\n\t\tif (n%2==1) {\n\t\t\tpr[n/2] = p[n-1];\n\t\t\tmid = n/2+1;\n\t\t}\n\n\t\tPoint c1[] = construct_left(n/2,pl);\n\t\tPoint c2[] = construct_right(mid,pr);\n\n\t\tPoint cnt1[] = new Point[2]; //cnt1 : 上部接線\n\t\tcnt1[0] = c1[0];\n\t\tcnt1[1] = c2[0];\n\t\tint lc,rc;\n\t\tlc = rc = 1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt1[0],cnt1[1],c2[rc])>0) {\n\t\t\t\tcnt1[1] = c2[rc];\n\t\t\t\trc = (rc+1)%c2.length;\n\t\t\t}\n\t\t\twhile (S(cnt1[1],cnt1[0],c1[lc])<0) {\n\t\t\t\tcnt1[0] = c1[lc];\n\t\t\t\tlc = (lc+1)%c1.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint cnt2[] = new Point[2]; //cnt2 : 下部接線\n\t\tcnt2[0] = c1[0];\n\t\tcnt2[1] = c2[0];\n\t\tlc = c1.length-1;\n\t\trc = c2.length-1;\n\t\tfor (int i=0;i<2;i++) {\n\t\t\twhile (S(cnt2[1],cnt2[0],c1[lc])>0) {\n\t\t\t\tcnt2[0] = c1[lc];\n\t\t\t\tlc = (lc+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (S(cnt2[0],cnt2[1],c2[rc])<0) {\n\t\t\t\tcnt2[1] = c2[rc];\n\t\t\t\trc = (rc+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t}\n\n\t\tPoint nr[] = new Point[n];\n\t\trc = 0;\n\t\tint pt = 0;\n\t\tint mem = 0;\n\t\tdouble xmin = c1[0].x;\n\t\tdouble ymin = c1[0].y;\n\t\tfor (int i=1;i<c1.length;i++) {\n\t\t\tif (xmin>c1[i].x) {\n\t\t\t\txmin = c1[i].x;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t} else if (xmin==c1[i].x&&ymin>c1[i].y) {\n\t\t\t\tymin = c1[i].y;\n\t\t\t\tpt = i;\n\t\t\t\tmem = i;\n\t\t\t}\n\t\t}\n\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt1[0])) {\n\t\t\tnr[rc] = c1[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t}\n\t\tnr[rc++] = cnt1[0];\n\t\tpt = 0;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt1[1])) {\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tnr[rc++] = cnt1[1];\n\t\tpt = (pt+1)%c2.length;\n\t\twhile (pt<c2.length&&c2[pt].NotEqual(cnt2[1])) {\n\t\t\tnr[rc] = c2[pt];\n\t\t\trc++;\n\t\t\tpt = (pt+1)%c2.length;\n\t\t}\n\t\tif (cnt1[0].NotEqual(cnt2[0])) {\n\t\t\tnr[rc++] = cnt2[1];\n\t\t\tpt = 0;\n\t\t\twhile (pt<c1.length&&c1[pt].NotEqual(cnt2[0])) {\n\t\t\t\tpt = (pt+(c2.length-1))%c2.length;\n\t\t\t}\n\t\t\tif (cnt2[0].NotEqual(c1[mem])) {\n\t\t\t\tnr[rc++] = cnt2[0];\n\t\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t\t}\n\t\t\twhile (pt<c1.length&&c1[pt].NotEqual(c1[mem])) {\n\t\t\t\tnr[rc] = c1[pt];\n\t\t\t\trc++;\n\t\t\t\tpt = (pt+(c1.length-1))%c1.length;\n\t\t\t}\t\n\t\t}\n\t\tPoint c[] = new Point[rc];\n\t\tfor (int i=0;i<rc;i++) c[i] = nr[i];\n\n\t\treturn c;\n\t}\n\n\tpublic static void quicksort(int low,int high,Point p[]) {\n\t\tif (high>low) {\n\t\t\tint mid = (low+high)/2;\n\t\t\tdouble x = p[mid].x;\n\t\t\tint i = low;\n\t\t\tint j = high;\n\t\t\twhile (p[i].x<x) i++;\n\t\t\twhile (p[j].x>x) j--;\n\t\t\tif (i<=j) {\n\t\t\t\tPoint t =p[i];\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\ti++;j--;\n\t\t\t}\n\t\t\tquicksort(low,j,p);\n\t\t\tquicksort(i,high,p);\n\t\t}\n\t}\n\n\tpublic static void sorty(int n,Point p[]) {\n\t\tfor (int i=1;i<n;i++) {\n\t\t\tint j = i-1;\n\t\t\twhile (p[j].x==p[j+1].x&&p[j].y>p[j+1].y) {\n\t\t\t\tPoint t = p[j+1];\n\t\t\t\tp[j+1] = p[j];\n\t\t\t\tp[j] = t;\n\t\t\t\tj--;\n\t\t\t\tif (j<0) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double S(Point p0,Point p1,Point p2) {\n\t\treturn (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\t static List<Point> points = new ArrayList<Point>();\n\t static List<Point> hull;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint n = (int)sc.nextLong();\n\t\t\tpoints.clear();\n\t\t\tif(n == 0) break;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tString[] tmp = sc.next().split(\",\");\n\t\t\t\tdouble x = Double.parseDouble(tmp[0]);\n\t\t\t\tdouble y = Double.parseDouble(tmp[1]);\n\t\t\t\t\n\t\t\t\tPoint p = new Point(x,y);\n\t\t\t\tpoints.add(p);\n\t\t\t\t\n\t\t\t}\n\t\t\tcreateConvexHull();\n\t\t\tout.println((points.size() - hull.size() + 2));\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t   \n    static double getSignedArea(Point p1, Point p2, Point p3){\n        return (p2.x - p1.x) * (p3.y - p1.y) \n                - (p3.x - p1.x) * (p2.y - p1.y);\n    }\n    static void createConvexHull(){\n        //X??§?¨???§????????????\n        Collections.sort(points, new Comparator<Point>() {\n            public int compare(Point o1, Point o2) {\n                return (int)((o1).x - (o2).x);\n            }\n        });\n        \n        //??????????±???????\n        hull = new ArrayList<Point>();\n        List<Point> proc = hull;\n        for(int k = 0; k < 2; ++k){\n            //1????????§?????´???2????????§?????´??????????????????\n            proc.add(points.get(0));\n            proc.add(points.get(1));\n            for(int i = 2; i < points.size(); ++i){\n                Point p = points.get(i);\n                for(;;){\n                    Point q1 = proc.get(proc.size() - 2);\n                    Point q2 = proc.get(proc.size() - 1);\n                    double s = getSignedArea(q1, q2, p);\n                    if(k == 0){\n                        if(s < 0) break;\n                    }else{\n                        if(s > 0) break;\n                    }\n                    proc.remove(proc.size() - 1);\n                    if(proc.size() < 2) break;\n                }\n                proc.add(p);\n            }\n            if(k == 0) proc = new ArrayList<Point>();\n        }\n\n        //????????????\n        for(int i = 0; i < proc.size(); ++i){\n            hull.add(proc.get(proc.size() - i - 1));\n        }\n    }\n\t\n\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n\n}\n\nclass Point {\n\tDouble x;\n\tDouble y;\n\tPoint(double a, double b) {\n\t\tx = a;\n\t\ty = b;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Enclose Pins with a Rubber Band\npublic class Main{\n\n\tstatic double ex(double x1, double y1, double x2, double y2, double x3, double y3){\n\t\tdouble dx1 = x2-x1;\n\t\tdouble dy1 = y2-y1;\n\t\tdouble dx2 = x3-x1;\n\t\tdouble dy2 = y3-y1;\n\t\treturn dx1*dy2-dx2*dy1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tdouble[][] p = new double[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tp[i][0] = Double.parseDouble(s[0]);\n\t\t\t\tp[i][1] = Double.parseDouble(s[1]);\n\t\t\t}\n\t\t\tboolean[] used = new boolean[n];\n\t\t\tint left = 0;\n\t\t\tfor(int i=1;i<n;i++)if(p[i][0]<p[left][0])left=i;\n\t\t\tused[left]=true;\n\t\t\tint end = left;\n\t\t\tint pre = left;\n\t\t\twhile(true){\n\t\t\t\tint k;\n\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\tif(pre==k)continue;\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(j==pre||j==k)continue;\n\t\t\t\t\t\tif(ex(p[pre][0], p[pre][1], p[k][0], p[k][1], p[j][0], p[j][1]) <= 0){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tused[k] = true;\n\t\t\t\t\t\tpre = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pre==end)break;\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<n;i++)if(!used[i])c++;\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tP[] ps = new P[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString[] sp = sc.next().split(\",\");\n\t\t\t\tps[i] = new P(Double.parseDouble(sp[0]), Double.parseDouble(sp[1]));\n\t\t\t}\n\t\t\t\n\t\t\tP[] poly = poly(ps);\n\t\t\tSystem.out.println( n - poly.length );\n\t\t}\n\t}\n\t\n\tP[] poly(P[] ps) {\n\t\tint n = ps.length, k=0;\n\t\tif(n <= 1) return ps;\n\t\tsort(ps, new Comp());\n\t\tP[] qs = new P[n*2];\n\t\t\n\t\tfor(int i=0;i<n;qs[k++] = ps[i++]) {\n\t\t\twhile(k > 1 && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) < EPS) k--;\n\t\t}\n\t\tfor(int i=n-2,t=k;i>=0;qs[k++] = ps[i--]) {\n\t\t\twhile(k > t && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) < EPS) k--;\n\t\t}\n\t\tP[] res = new P[k-1];\n\t\tSystem.arraycopy(qs, 0, res, 0, k-1);\n\t\treturn res;\n\t}\n\t\n\tboolean contains(P[] ps, P p) {\n\t\tint n = ps.length;\n\t\tint res = -1;\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tP a = ps[j].sub(p);\n\t\t\tP b = ps[(j+1)%n].sub(p);\n\t\t\tif(a.y > b.y) {\n\t\t\t\tP t = new P(a.x, a.y); a = b; b = t; \n\t\t\t}\n\t\t\tif(a.y < EPS &&  b.y > EPS && a.det(b) > EPS) {\n\t\t\t\tres = -res;\n\t\t\t}\n\t\t\tif(abs(a.det(b)) < EPS && a.dot(b) < EPS) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn res == -1? false: true;\n\t}\n\tclass Comp implements Comparator<P> {\n\n\t\tpublic int compare(P o1, P o2) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\tif(o1.x != o2.x) return o1.x>o2.x? 1: -1;\n\t\t\treturn o1.y>o2.y? 1: -1;\n\t\t}\n\t\t\n\t}\n\tclass P {\n\t\tdouble EPS = 1e-8;\n\t\tdouble x, y;\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble add(double a, double b) {\t//誤差を考慮\n\t\t\tif( Math.abs(a+b) < EPS * ( Math.abs(a) + Math.abs(b) ) ) return 0;\n\t\t\treturn a + b;\n\t\t}\n\n\t\tP add(P p) {\t//和\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p) {\t//差\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\t\t\n\t\tP mlt(double k) {\n\t\t\treturn new P(x*k, y*k);\n\t\t}\n\n\t\tdouble dot(P p) {\t//内積\n\t\t\t\treturn add(x*p.x, y*p.y);\n\t\t}\n\n\t\tdouble det(P p) {\t//外積\n\t\t\treturn add(x*p.y, -y*p.x);\n\t\t}\n\n\t\t//距離系\n\t\tdouble abs() {\n\t\t\tdouble ret = sqrt( add(x*x, y*y) );\n\t\t\tif ( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tdouble abs(P p) {\n\t\t\tdouble dx = add( x, -p.x );\n\t\t\tdouble dy = add( y, -p.y );\n\t\t\tdouble ret = sqrt( add(dx*dx, dy*dy) );\n\t\t\tif( Math.abs(ret) < EPS ) return 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\t//点と線分の距離\n\t\tdouble disSP(P p1, P p2, P q) {\n\t\t\tif( p2.sub(p1).dot(q.sub(p1)) < EPS ) return q.sub(p1).abs();\n\t\t\tif( p1.sub(p2).dot(q.sub(p2)) < EPS ) return q.sub(p2).abs();\n\t\t\treturn disLP(p1, p2, q);\n\t\t}\n\n\t\t//点と直線の距離\n\t\tdouble disLP(P p1, P p2, P q) {\n\t\t\treturn Math.abs(p2.sub(p1).det(q.sub(p1))) / p2.sub(p1).abs();\n\t\t}\n\n\t\t//線分交差判定\n\t\tboolean cross(P p1, P p2, P q1, P q2) {\n\t\t\treturn ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 &&\n\t\t\t\tccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0;\n\t\t}\n\n\t\t//時計回りなのか．反時計回りなのか，直線状なのか，とにかく位置関係をみる\n\t\tint ccw (P a, P b, P c) {\n\t\t\tP s = b.sub(a);\n\t\t\tP t = c.sub(a);\n\t\t\tif( s.det(t) > EPS ) return 1;\n\t\t\tif( s.det(t) < -EPS ) return -1;\n\t\t\tif( s.dot(t) < -EPS ) return 2;\n\t\t\tif( s.dot(s) + EPS < t.dot(t) ) return -2;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine() == true) {\n\t\t\tint lines = Integer.parseInt(sc.nextLine());\n\t\t\tif (lines == 0) break;\n\t\t\t\n\t\t\tdouble[][] points = new double[lines][2];\n\t\t\tfor (int i = 0; i < lines; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < nico.length; j++) {\n\t\t\t\t\tpoints[i][j] = Double.parseDouble(nico[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[] flag = new boolean[points.length];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\tfor (int j = (i + 1); j < points.length; j++) {\n\t\t\t\t\tdouble dx = points[j][0] - points[i][0];\n\t\t\t\t\tdouble dy = points[j][1] - points[i][1];\n\t\t\t\t\t\n\t\t\t\t\tboolean judge = true;\n\t\t\t\t\tif (dx != 0.0) {\n\t\t\t\t\t\tdouble a = dy / dx;\n\t\t\t\t\t\tdouble b = points[i][1] - a * points[i][0];\n\n\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\tnside = points[k][1] - (a * points[k][0] + b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((side != 0.0) && (side * nside < 0)) {\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\tnside = points[k][0] - points[i][0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((side != 0.0) && (side * nside < 0)) {\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (judge == true) {\n\t\t\t\t\t\tflag[i] = false;\n\t\t\t\t\t\tflag[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tif (flag[i] == true) cnt++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader\tbr = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tnum = 0;\n\t\tMyPolygon\tpolygon = new MyPolygon();\n\t\twhile ((num = parseNum()) != 0) {\n\t\t\tpolygon.clear();\n\n\t\t\tfor (int n = 0; n < num; n++) {\n\t\t\t\tpolygon.AddEx(parsePoint());\n\t\t\t\tpolygon.removeUselessPos();\n\t\t\t}\n\n\t\t\tSystem.out.println(num - polygon.size());\n\t\t}\n\t}\n\n\tprivate static int parseNum() {\n\t\tString\tline = null;\n\t\tint\t\tnum  = 0;\n\n\t\tif ((line = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(line);\n\t\t}\n\n\t\treturn num;\n\t}\n\n\tprivate static double[] parsePoint() {\n\t\tString\t\tline  = null;\n\t\tString[]\tsplit = null;\n\t\tdouble[]\tpoint = null;\n\n\t\tif ((line = parseStdin()) != null) {\n\t\t\tsplit    = line.split(\",\");\n\t\t\tpoint    = new double[4];\n\t\t\tpoint[0] = Double.parseDouble(split[0]);\n\t\t\tpoint[1] = Double.parseDouble(split[1]);\n\t\t}\n\n\t\treturn point;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstdin = null;\n\n\t\ttry {\n\t\t\tstdin = br.readLine();\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn stdin;\n\t}\n}\n\nclass MyPolygon extends ArrayList<double[]> {\n\tprivate\tstatic\tdouble[]\toPos = null;\n\n\tpublic void AddEx(double[] element) {\n\t\tint\tlen = size();\n\n\t\tif (len == 0) {\n\t\t\toPos = element;\n\t\t}\n\t\telse {\n\t\t\tif (element[1] < oPos[1] || (element[1] == oPos[1] && element[0] < oPos[0])) {\n\t\t\t\toPos = element;\n\t\t\t}\n\t\t}\n\n\t\tadd(element);\n\t\tCollections.sort(this, new MyComparator());\n\t}\n\n\tpublic void removeEx(double[] element) {\n\t\tint\tlen = size();\n\n\t\tif (oPos[0] == element[0] && oPos[1] == element[1]) {\n\t\t\toPos = null;\n\t\t}\n\n\t\tremove(element);\n\t\tlen = size();\n\n\t\tif (oPos == null && len > 0) {\n\t\t\tdouble[]\ttPos = get(0);\n\t\t\toPos = tPos;\n\n\t\t\tfor (int n = 1; n < len; n++) {\n\t\t\t\ttPos = get(n);\n\t\t\t\tif (tPos[1] < oPos[1] || (tPos[1] == oPos[1] && tPos[0] < oPos[0])) {\n\t\t\t\t\toPos = tPos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(this, new MyComparator());\n\t}\n\n\tpublic void removeUselessPos() {\n\t\t// 同じ直線状に点があれば削除する（点が3個登録されている場合）\n\t\tremoveSameLinePos();\n\t\n\t\t// 図形の内側に点があれば削除する（点が4個以上登録されている場合）\n\t\tremoveInnerPos();\n\t}\n\n\tprivate void removeSameLinePos() {\n\t\tint\tlen = size();\n\t\tif (len == 3) {\n\t\t\tfor (int n = 1; n >= 0; n--) {\n\t\t\t\tdouble[]\tpos1 = get(n);\n\t\t\t\tdouble[]\tpos2 = get(n+1);\n\t\t\t\tif (pos1[3] == pos2[3]) {\n\t\t\t\t\tremove(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void removeInnerPos() {\n\t\tint\tlen = size();\n\t\tif (len > 3) {\n\t\t\tfor (int i = size() - 1; i >= 0; i--) {\n\t\t\t\tdouble[]\tpos  = get(i);\n\t\t\t\tint\t\t\tsign = 1;\n\n\t\t\t\t// 図形を構成する点を取り出す\n\t\t\t\tremoveEx(pos);\n\t\t\t\tlen = size();\n\t\t\t\tfor (int j = 0; j < len && sign != -1; j++) {\n\t\t\t\t\tsign = getCrossSign(get(j), get((j + 1) % len), pos);\n\t\t\t\t}\n\n\t\t\t\tif (sign == -1) {\n\t\t\t\t\t// 残りの点で構成される図形の外側に点があれば戻す\n\t\t\t\t\tAddEx(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static int getCrossSign(double[] da, double[] db, double[] dp) {\n\t\tdouble[]\tdab = { db[0] - da[0], db[1] - da[1] };\n\t\tdouble[]\tdap = { dp[0] - da[0], dp[1] - da[1] };\n\t\treturn ( getCross(dab, dap) >= 0.0 ) ? 1 : -1;\n\t}\n\n\tprivate static double getCross(double[] d1, double[] d2) {\n\t\treturn d1[0] * d2[1] - d1[1] * d2[0];\t// x1*x2 + y1*y2\n\t}\n\n\tclass MyComparator implements Comparator<double[]> {\n\t\tpublic int compare(double[] pos1,double[] pos2){\n\t\t\tpos1[2] = Math.sqrt(Math.pow(pos1[1] - oPos[1], 2.0) + Math.pow(pos1[0] - oPos[0], 2.0));\n\t\t\tpos1[3] = Math.atan2(pos1[1] - oPos[1], pos1[0] - oPos[0]);\n\t\t\tpos2[2] = Math.sqrt(Math.pow(pos2[1] - oPos[1], 2.0) + Math.pow(pos2[0] - oPos[0], 2.0));\n\t\t\tpos2[3] = Math.atan2(pos2[1] - oPos[1], pos2[0] - oPos[0]);\n\n\t\t\treturn (pos1[3] == pos2[3]) ? (pos1[2] == pos2[2]) ? 0 : (pos1[2] < pos2[2]) ? -1 : 1 : (pos1[3] < pos2[3]) ? -1 : 1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader\tbr = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tnum = 0;\n\t\tMyPolygon\tpolygon = new MyPolygon();\n\t\twhile ((num = parseNum()) != 0) {\n\t\t\tpolygon.clear();\n\n\t\t\tfor (int n = 0; n < num; n++) {\n\t\t\t\tpolygon.AddEx(parsePoint());\n\t\t\t\tpolygon.removeUselessPos();\n\t\t\t}\n\n\t\t\tSystem.out.println(num - polygon.size());\n\t\t}\n\t}\n\n\tprivate static int parseNum() {\n\t\tString\tline = null;\n\t\tint\t\tnum  = 0;\n\n\t\tif ((line = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(line);\n\t\t}\n\n\t\treturn num;\n\t}\n\n\tprivate static double[] parsePoint() {\n\t\tString\t\tline  = null;\n\t\tString[]\tsplit = null;\n\t\tdouble[]\tpoint = null;\n\n\t\tif ((line = parseStdin()) != null) {\n\t\t\tsplit    = line.split(\",\");\n\t\t\tpoint    = new double[4];\n\t\t\tpoint[0] = Double.parseDouble(split[0]);\n\t\t\tpoint[1] = Double.parseDouble(split[1]);\n\t\t}\n\n\t\treturn point;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstdin = null;\n\n\t\ttry {\n\t\t\tstdin = br.readLine();\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn stdin;\n\t}\n}\n\nclass MyPolygon extends ArrayList<double[]> {\n\tprivate\tstatic\tdouble[]\toPos = null;\n\n\tpublic void AddEx(double[] element) {\n\t\tint\tlen = size();\n\n\t\tif (len == 0) {\n\t\t\toPos = element;\n\t\t}\n\t\telse {\n\t\t\tif (element[1] < oPos[1] || (element[1] == oPos[1] && element[0] < oPos[0])) {\n\t\t\t\toPos = element;\n\t\t\t}\n\t\t}\n\n\t\tadd(element);\n\t\tCollections.sort(this, new MyComparator());\n\t}\n\n\tpublic void removeEx(double[] element) {\n\t\tint\tlen = size();\n\n\t\tif (oPos[0] == element[0] && oPos[1] == element[1]) {\n\t\t\toPos = null;\n\t\t}\n\n\t\tremove(element);\n\t\tlen = size();\n\n\t\tif (oPos == null && len > 0) {\n\t\t\tdouble[]\ttPos = get(0);\n\t\t\toPos = tPos;\n\n\t\t\tfor (int n = 1; n < len; n++) {\n\t\t\t\ttPos = get(n);\n\t\t\t\tif (tPos[1] < oPos[1] || (tPos[1] == oPos[1] && tPos[0] < oPos[0])) {\n\t\t\t\t\toPos = tPos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(this, new MyComparator());\n\t}\n\n\tpublic void removeUselessPos() {\n\t\t// 同じ直線状に点があれば削除する（点が3個登録されている場合）\n\t\tremoveSameLinePos();\n\t\n\t\t// 図形の内側に点があれば削除する（点が4個以上登録されている場合）\n\t\tremoveInnerPos();\n\t}\n\n\tprivate void removeSameLinePos() {\n\t\tint\tlen = size();\n\t\tif (len == 3) {\n\t\t\tfor (int n = 1; n >= 0; n--) {\n\t\t\t\tdouble[]\tpos1 = get(n);\n\t\t\t\tdouble[]\tpos2 = get(n+1);\n\t\t\t\tif (pos1[3] == pos2[3]) {\n\t\t\t\t\tremove(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void removeInnerPos() {\n\t\tint\tlen = size();\n\t\tif (len > 3) {\n\t\t\tfor (int i = size() - 1; i >= 0 && size() > 3; i--) {\n\t\t\t\tdouble[]\tpos  = get(i);\n\t\t\t\tint\t\t\tsign = 1;\n\n\t\t\t\t// 図形を構成する点を取り出す\n\t\t\t\tremoveEx(pos);\n\t\t\t\tlen = size();\n\t\t\t\tfor (int j = 0; j < len && sign != -1; j++) {\n\t\t\t\t\tsign = getCrossSign(get(j), get((j + 1) % len), pos);\n\t\t\t\t}\n\n\t\t\t\tif (sign == -1) {\n\t\t\t\t\t// 残りの点で構成される図形の外側に点があれば戻す\n\t\t\t\t\tAddEx(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static int getCrossSign(double[] da, double[] db, double[] dp) {\n\t\tdouble[]\tdab = { db[0] - da[0], db[1] - da[1] };\n\t\tdouble[]\tdap = { dp[0] - da[0], dp[1] - da[1] };\n\t\treturn ( getCross(dab, dap) >= 0.0 ) ? 1 : -1;\n\t}\n\n\tprivate static double getCross(double[] d1, double[] d2) {\n\t\treturn d1[0] * d2[1] - d1[1] * d2[0];\t// x1*x2 + y1*y2\n\t}\n\n\tclass MyComparator implements Comparator<double[]> {\n\t\tpublic int compare(double[] pos1,double[] pos2){\n\t\t\tpos1[2] = Math.sqrt(Math.pow(pos1[1] - oPos[1], 2.0) + Math.pow(pos1[0] - oPos[0], 2.0));\n\t\t\tpos1[3] = Math.atan2(pos1[1] - oPos[1], pos1[0] - oPos[0]);\n\t\t\tpos2[2] = Math.sqrt(Math.pow(pos2[1] - oPos[1], 2.0) + Math.pow(pos2[0] - oPos[0], 2.0));\n\t\t\tpos2[3] = Math.atan2(pos2[1] - oPos[1], pos2[0] - oPos[0]);\n\n\t\t\treturn (pos1[3] == pos2[3]) ? (pos1[2] == pos2[2]) ? 0 : (pos1[2] < pos2[2]) ? -1 : 1 : (pos1[3] < pos2[3]) ? -1 : 1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\t static List<Point> points;\n\t static List<Point> hull;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint n = (int)sc.nextLong();\n\t\t\tpoints = new ArrayList<Point>();\n\t\t\tif(n == 0) break;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tString[] tmp = sc.next().split(\",\");\n\t\t\t\tdouble x = Double.parseDouble(tmp[0]);\n\t\t\t\tdouble y = Double.parseDouble(tmp[1]);\n\t\t\t\t\n\t\t\t\tPoint p = new Point(x,y);\n\t\t\t\tpoints.add(p);\n\t\t\t\t\n\t\t\t}\n\t\t\tcreateConvexHull();\n\t\t\tout.println((points.size() - hull.size() + 2));\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\t   \n    static double getSignedArea(Point p1, Point p2, Point p3){\n        return (p2.x - p1.x) * (p3.y - p1.y) \n                - (p3.x - p1.x) * (p2.y - p1.y);\n    }\n    static void createConvexHull(){\n        //X??§?¨???§????????????\n        Collections.sort(points, new Comparator<Point>() {\n            public int compare(Point o1, Point o2) {\n            \tif(o1.x < o2.x) return -1;\n            \telse if(o1.x > o2.x) return 1;\n            \treturn 0;\n            }\n        });\n        \n        //??????????±???????\n        hull = new ArrayList<Point>();\n        List<Point> proc = hull;\n        for(int k = 0; k < 2; ++k){\n            //1????????§?????´???2????????§?????´??????????????????\n            proc.add(points.get(0));\n            proc.add(points.get(1));\n            for(int i = 2; i < points.size(); ++i){\n                Point p = points.get(i);\n                for(;;){\n                    Point q1 = proc.get(proc.size() - 2);\n                    Point q2 = proc.get(proc.size() - 1);\n                    double s = getSignedArea(q1, q2, p);\n                    if(k == 0){\n                        if(s < 0) break;\n                    }else{\n                        if(s > 0) break;\n                    }\n                    proc.remove(proc.size() - 1);\n                    if(proc.size() < 2) break;\n                }\n                proc.add(p);\n            }\n            if(k == 0) proc = new ArrayList<Point>();\n        }\n\n        //????????????\n        for(int i = 0; i < proc.size(); ++i){\n            hull.add(proc.get(proc.size() - i - 1));\n        }\n    }\n\t\n\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n\n}\n\nclass Point {\n\tDouble x;\n\tDouble y;\n\tPoint(double a, double b) {\n\t\tx = a;\n\t\ty = b;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n//グラハムスキャン\n//幾何\n//凸包\nclass Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] ps=new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] str=sc.next().split(\",\");\n\t\t\t\tps[i]=new P(Double.parseDouble(str[0]),Double.parseDouble(str[1]));\n\t\t\t}\n\t\t\tArrays.sort(ps);\n\n\t\t\tint k=0;\n\t\t\tP[] qs =new P[2*n];\n\t\t\t//下側\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\twhile(k>1 && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;//凸包になるまで戻す\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\t//上側\n\t\t\tfor(int i=n-2,t=k;i>=0;i--){\n\t\t\t\twhile(k>t && P.cross(qs[k-1].s(qs[k-2]),ps[i].s(qs[k-1]))<=0)k--;\n\t\t\t\tqs[k++]=ps[i];\n\t\t\t}\n\t\t\tqs=Arrays.copyOf(qs,k-1);\n\n\t\t\tln(ps.length-qs.length);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}\n\nclass P implements Comparable<P>{\n\tdouble x;\n\tdouble y;\n\tP(double _x,double _y){\n\t\tx=_x;\n\t\ty=_y;\n\t}\n\t@Override\n\tpublic int compareTo(P o) {\n\t\tif(x!=o.x){\n\t\t\treturn (int)(x-o.x);\n\t\t}\n\t\treturn (int)(y-o.y);\n\t}\n\n\tpublic static double dot(P a,P b){\n\t\t\treturn a.x*b.x+a.y*b.y;\n\t}\n\tpublic static  double cross(P a,P b){\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n\tpublic static boolean isParallel(P a1,P a2,P b1,P b2){\n\t\treturn Math.abs(cross(a2.s(a1),b2.s(b1)))<Double.MIN_NORMAL;\n\t}\n\tpublic static boolean isVertical(P a1,P a2,P b1,P b2){\n\t\treturn Math.abs(dot(a2.s(a1),b2.s(b1)))<Double.MIN_NORMAL;\n\t}\n\n\tpublic P a(P a){\n\t\treturn new P(x+a.x,y+a.y);\n\t}\n\tpublic P s(P a){\n\t\treturn new P(x-a.x,y-a.y);\n\t}\n\n\tpublic double norm(){\n\t\treturn Math.sqrt(x*x+y*y);\n\t}\n\n\tpublic static int ccw(P a,P b,P c){\n\t\tif(P.cross(b.s(a),c.s(a))>Double.MIN_NORMAL){\n\t\t\treturn 1;\n\t\t}\n\t\tif(P.cross(b.s(a),c.s(a))<-Double.MIN_NORMAL){\n\t\t\treturn -1;\n\t\t}\n\t\tif(P.dot(b,c)<-Double.MIN_NORMAL)return 2;\n\t\tif(b.norm()<c.norm()-Double.MIN_NORMAL)return -2;\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof P){\n\t\t\tP p=(P)obj;\n\t\t\treturn x==p.x && y==p.y;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic String toString(){\n\t\treturn \"(\"+x+\",\"+y+\")\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Vertex {\n\t\tdouble x, y;\n\n\t\tpublic Vertex(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"{\" + this.x + \" \" + this.y + \"}\";\n\t\t}\n\n\t\tpublic boolean isLeft(Vertex p, Vertex q) {\n\t\t\tif (0 < (q.x - p.x) * (this.y - p.y) - (this.x - p.x) * (q.y - p.y)) {\n\t\t\t\treturn true;\n\t\t\t}else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tVertex v[];\n\t\tVertex hull[];\n\n\t\tn = sc.nextInt();\n\t\twhile (n != 0) {\n\t\t\tv = new Vertex[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s[] = sc.next().split(\",\");\n\t\t\t\tv[i] = new Vertex(Double.valueOf(s[0]), Double.valueOf(s[1]));\n\t\t\t}\n\n\t\t\tsort(v, 0, n - 1);\n\t\t\thull = makeHull(v, 0, n - 1);\n\n\t\t\tSystem.out.println(v.length - hull.length);\n\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static void sort(Vertex v[], int low, int high) {\n\t\tif (high <= low) {\n\t\t\treturn ;\n\t\t}\n\t\tint i = low;\n\t\tint j = high;\n\t\tdouble x = v[(low + high) / 2].x;\n\t\twhile (i <= j) {\n\t\t\twhile (v[i].x < x) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (x < v[j].x) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (i <= j) {\n\t\t\t\tVertex swap = new Vertex(v[i].x, v[i].y);\n\t\t\t\tv[i] = v[j];\n\t\t\t\tv[j] = swap;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tsort(v, low, j);\n\t\tsort(v, i, high);\n\t}\n\n\tpublic static Vertex[] makeHull(Vertex v[], int low, int high) {\n\t\tif (high - low == 0) {\n\t\t\tVertex v1[] = new Vertex[1];\n\t\t\tv1[0] = v[low];\n\t\t\treturn v1;\n\t\t} else if (high - low == 1) {\n\t\t\tVertex v1[] = new Vertex[2];\n\t\t\tv1[0] = v[low];\n\t\t\tv1[1] = v[high];\n\t\t\treturn v1;\n\t\t} else {\n\t\t\tVertex left[];\n\t\t\tVertex right[];\n\t\t\tVertex v1[];\n\t\t\tleft = makeHull(v, low, (low + high) / 2);\n\t\t\tright = makeHull(v, (low + high) / 2 + 1, high);\n\t\t\tv1 = combineHull(left, right);\n\t\t\treturn v1;\n\t\t}\n\t}\n\n\tpublic static Vertex[] combineHull(Vertex left[], Vertex right[]) {\n\t\tVertex hull[];\n\t\tint topIndex[];\n\t\tint bottomIndex[];\n\n\t\ttopIndex = seachTopIndex(left, right);\n\t\tbottomIndex = seachBottomIndex(left, right);\n\n\t\tint k_left = (bottomIndex[0] - topIndex[0] + left.length) % left.length + 1;\n\t\tint k_right = (topIndex[1] - bottomIndex[1] + right.length) % right.length + 1;\n\t\thull = new Vertex[k_left + k_right];\n\t\tint index = 0;\n\t\twhile (true) {\n\t\t\tif (0 <= index && index < k_left) {\n\t\t\t\thull[index] = left[(topIndex[0] + index) % left.length];\n\t\t\t\tindex++;\n\t\t\t} else if (k_left <= index && index < k_left + k_right) {\n\t\t\t\thull[index] = right[(bottomIndex[1] + index - k_left) % right.length];\n\t\t\t\tindex++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn hull;\n\t}\n\n\tpublic static int[] seachTopIndex(Vertex left[], Vertex right[]) {\n\t\tint i = seachMostRightIndex(left);\n\t\tint j = seachMostLeftIndex(right);\n\n\t\twhile (true) {\n\t\t\tint i1 = (i + 1) % left.length;\n\t\t\tint j1 = (j - 1 + right.length) % right.length;\n\t\t\tif (left[i1].isLeft(left[i], right[j])) {\n\t\t\t\ti = i1;\n\t\t\t} else if (right[j1].isLeft(left[i], right[j])) {\n\t\t\t\tj = j1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint index[] = {i, j};\n\t\treturn index;\n\t}\n\n\tpublic static int[] seachBottomIndex(Vertex left[], Vertex right[]) {\n\t\tint i = seachMostRightIndex(left);\n\t\tint j = seachMostLeftIndex(right);\n\n\t\twhile (true) {\n\t\t\tint i1 = (i - 1 + left.length) % left.length;\n\t\t\tint j1 = (j + 1) % right.length;\n\t\t\tif (left[i1].isLeft(right[j], left[i])) {\n\t\t\t\ti = i1;\n\t\t\t} else if (right[j1].isLeft(right[j], left[i])) {\n\t\t\t\tj = j1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint index[] = {i, j};\n\t\treturn index;\n\t}\n\n\tpublic static int seachMostRightIndex(Vertex v[]) {\n\t\tint max = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\tif (v[max].x < v[i].x) {\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tpublic static int seachMostLeftIndex(Vertex v[]) {\n\t\tint min = 0;\n\t\tfor (int i = 0; i < v.length; i++) {\n\t\t\tif (v[i].x < v[min].x) {\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int n=ir.nextInt();\n  if(n==0) return;\n  P[] ps=new P[n];\n  for(int i=0;i<n;i++) ps[i]=new P(ir.nextDouble(),ir.nextDouble());\n  out.println(n-convexHull(ps).length);\n }\n}\n\npublic static P[] convexHull(P[] ps){\n int n=ps.length;\n Arrays.sort(ps,new Comparator<P>(){\n  public int compare(P a,P b){\n   if(a.getX()!=b.getX()) return Double.compare(a.getX(),b.getX());\n   return Double.compare(a.getY(),b.getY());\n  }\n });\n int p=0;\n P[] qs=new P[2*n];\n for(int i=0;i<n;i++){\n  while(p>1&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n for(int i=n-2,t=p;i>=0;i--){\n  while(p>t&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n return Arrays.copyOf(qs,p-1);\n}\n\nstatic final double EPS=1e-10;\n\npublic static double accurateTotal(double a,double b){\n if(Math.abs(a+b)<EPS*(Math.abs(a)+Math.abs(b))) return 0.0;\n return a+b;\n}\n\nstatic class P{\n\n public double x,y;\n\n public P(double x,double y){\n  this.x=x; this.y=y;\n }\n\n public double getX(){\n  return this.x;\n }\n\n public double getY(){\n  return this.y;\n }\n\n public P add(P v){\n  return new P(accurateTotal(this.x,v.x),accurateTotal(this.y,v.y));\n }\n\n public P sub(P v){\n  return new P(accurateTotal(this.x,-v.x),accurateTotal(this.y,-v.y));\n }\n\n public P mul(double k){\n  return new P(this.x*k,this.y*k);\n }\n\n public double dot(P v){\n  return accurateTotal(this.x*v.x,this.y*v.y);\n }\n\n public double det(P v){\n  return accurateTotal(this.x*v.y,-this.y*v.x);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)&&b!=','){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D []  plist = new Point2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString [] a = sc.next().split(\",\");\n\t\t\t\tdouble x = Double.parseDouble(a[0]);\n\t\t\t\tdouble y = Double.parseDouble(a[1]);\n\t\t\t\tplist[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\t\n\n\t\t\tPoint2D [] res = convexHull(plist);\n\t\t\tSystem.out.println(n - res.length);\n\t\t}\n\t}\n\n\tprivate Point2D [] convexHull(Point2D [] plist) {\n\t\tint n = plist.length;\n\t\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\t\tpublic int compare(Point2D o1, Point2D o2) {\n\t\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\tArrays.sort(plist, com);\n\t\tint k = 0;\n\t\tPoint2D [] qs = new Point2D[n * 2];\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tqs[k++] = plist[i];\n\t\t}\n\t\t\n\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\twhile(k > t && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\tk--;\n\t\t\t}\n\t\t\tqs[k++] = plist[i];\n\t\t}\n\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tpublic double x,y;\n\t\t\n\t\tdouble norm(){\n\t\t\treturn Math.hypot(x,y);\n\t\t}\n\t\tpublic Vector(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tVector sub(Vector a,Vector b){\n\t\treturn new Vector(a.x-b.x,a.y-b.y);\n\t}\n\t\n\tdouble op(Vector a,Vector b){\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n\tdouble ip(Vector a,Vector b){\n\t\treturn a.x*b.x+a.y*b.y;\n\t}\n\t\n\tclass VectorComparator implements Comparator<Vector>{\n\t\t@Override\n\t\tpublic int compare(Vector o1, Vector o2) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tdouble sign=o1.y-o2.y;\n\t\t\tif(sign==0)sign=(o1.x-o2.x);\n\t\t\treturn (int)Math.signum(sign);\n\t\t}\n\t}\n\t\n\tint solve(LinkedList<Vector> coords){\n\t\tCollections.sort(coords,new VectorComparator());\n\n\t\tVector p0=coords.getFirst(),p=p0;\n\t\tVector v=new Vector(1,0);\n\n\t\tdo{\n\t\t\tdouble min=Math.PI*2;\n\t\t\tVector qmin=null;\n\t\t\tfor(Vector q:coords){\n\t\t\t\tVector u=sub(q,p);\n\t\t\t\tdouble angle=Math.acos(ip(v,u)/(v.norm()*u.norm()));\n\t\t\t\tif(op(v,u)<0)angle=Math.PI*2-angle;\n\t\t\t\tif(angle<min){\n\t\t\t\t\tmin=angle;\n\t\t\t\t\tqmin=q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv=sub(qmin,p);\n\t\t\tp=qmin;\n\t\t\tcoords.remove(p);\n\t\t}while(p!=p0);\n\t\treturn coords.size();\n\t}\n\t\n\tdouble nd(){\n\t\treturn sc.nextDouble();\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\",|\\r\\n|\\n\");\n\t\tLinkedList<Vector> coords=new LinkedList<Vector>();\n\t\t\n\t\tint n;\n\t\twhile((n=ni())!=0){\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tcoords.add(new Vector(nd(),nd()));\n\t\t\t}\n\t\t\tSystem.out.println(solve(coords));\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\t\n\tint[][] map;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine() == true) {\n\t\t\tint lines = Integer.parseInt(sc.nextLine());\n\t\t\tif (lines == 0) break;\n\t\t\t\n\t\t\tdouble[][] points = new double[lines][2];\n\t\t\tfor (int i = 0; i < lines; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < nico.length; j++) {\n\t\t\t\t\tpoints[i][j] = Double.parseDouble(nico[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[] flag = new boolean[points.length];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < points.length; i++) {\n\t\t\t\tfor (int j = (i + 1); j < points.length; j++) {\n\t\t\t\t\tdouble dx = points[j][0] - points[i][0];\n\t\t\t\t\tdouble dy = points[j][1] - points[i][1];\n\t\t\t\t\t\n\t\t\t\t\tboolean judge = true;\n\t\t\t\t\tif (dx != 0.0) {\n\t\t\t\t\t\tdouble a = dy / dx;\n\t\t\t\t\t\tdouble b = points[i][1] - a * points[i][0];\n\n\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\tnside = points[k][1] - (a * points[k][0] + b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (((side != 0.0) && (side * nside < 0.0)) || (nside == 0.0)) {\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdouble side = 0.0;\n\t\t\t\t\t\tfor (int k = 0; k < points.length; k++) {\n\t\t\t\t\t\t\tdouble nside = 0.0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((k != i) && (k != j)) {\n\t\t\t\t\t\t\t\tnside = points[k][0] - points[i][0];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (((side != 0.0) && (side * nside < 0.0)) || (nside == 0.0)) {\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tside = nside;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (judge == true) {\n\t\t\t\t\t\tflag[i] = false;\n\t\t\t\t\t\tflag[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tif (flag[i] == true) cnt++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int n=ir.nextInt();\n  if(n==0) return;\n  P[] ps=new P[n];\n  for(int i=0;i<n;i++) ps[i]=new P(ir.nextDouble(),ir.nextDouble());\n  out.println(n-convexHull(ps).length);\n }\n}\n\npublic static P[] convexHull(P[] ps){\n int n=ps.length;\n Arrays.sort(ps,new Comparator<P>(){\n  public int compare(P a,P b){\n   if(a.getX()!=b.getX()) return Double.compare(a.getX(),b.getX());\n   return Double.compare(a.getY(),b.getY());\n  }\n });\n int p=0;\n P[] qs=new P[2*n];\n for(int i=0;i<n;i++){\n  while(p>1&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n for(int i=n-2,t=p;i>=0;i--){\n  while(p>t&&(qs[p-1].sub(qs[p-2])).det(ps[i].sub(qs[p-1]))<=0) p--;\n  qs[p++]=ps[i];\n }\n return Arrays.copyOf(qs,p-1);\n}\n\nstatic final double EPS=1e-10;\n\npublic static double accurateTotal(double a,double b){\n if(Math.abs(a+b)<EPS*(Math.abs(a)+Math.abs(b))) return 0.0;\n return a+b;\n}\n\nstatic class P{\n\n public double x,y;\n\n public P(double x,double y){\n  this.x=x; this.y=y;\n }\n\n public double getX(){\n  return this.x;\n }\n\n public double getY(){\n  return this.y;\n }\n\n public P add(P v){\n  return new P(accurateTotal(this.x,v.x),accurateTotal(this.y,v.y));\n }\n\n public P sub(P v){\n  return new P(accurateTotal(this.x,-v.x),accurateTotal(this.y,-v.y));\n }\n\n public P mul(double k){\n  return new P(this.x*k,this.y*k);\n }\n\n public double dot(P v){\n  return accurateTotal(this.x*v.x,this.y*v.y);\n }\n\n public double det(P v){\n  return accurateTotal(this.x*v.y,-this.y*v.x);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n  private static class Task {\n    void solve(FastScanner in, PrintWriter out) {\n      while (true) {\n        int N = in.nextInt();\n        if (N == 0) break;\n        Double[][] xy = new Double[N][2];\n        for (int i = 0; i < N; i++) {\n          String s = in.next();\n          String[] sxy = s.split(\",\");\n          xy[i][0] = Double.parseDouble(sxy[0]);\n          xy[i][1] = Double.parseDouble(sxy[1]);\n        }\n        out.println(N - ConvexHull.convexHull(xy).size());\n\n      }\n    }\n\n  }\n\n  static class ConvexHull {\n    static <T extends Number> ArrayList<T[]> convexHull(T[][] xy) {\n      int N = xy.length;\n      if (N <= 1) {\n        ArrayList<T[]> list = new ArrayList<>();\n        Collections.addAll(list, xy);\n        return list;\n      }\n      Arrays.sort(xy, new Comparator<T[]>() {\n        @Override\n        public int compare(T[] a, T[] b) {\n          if (!a[0].equals(b[0])) return Double.compare(a[0].doubleValue(), b[0].doubleValue());\n          return Double.compare(a[1].doubleValue(), b[1].doubleValue());\n        }\n      });\n\n      int[] qs = new int[N + 1];//?§????????????????\n      int k = 0;//?????????????????°\n      for (int i = 0; i < N; i++) {\n        if (k >= 1 && xy[qs[k - 1]][0].equals(xy[i][0]) && xy[qs[k - 1]][1].equals(xy[i][1])) continue;\n        while (k > 1 && ccw(xy[qs[k - 2]], xy[qs[k - 1]], xy[i]) >= 0) k--;\n        qs[k++] = i;\n      }\n\n      int inf = k + 1;\n      for (int i = N - 2; i >= 0; i--) {\n        if (xy[qs[k - 1]][0] == xy[i][0] && xy[qs[k - 1]][1] == xy[i][1]) continue;\n        while (k >= inf && ccw(xy[qs[k - 2]], xy[qs[k - 1]], xy[i]) >= 0) k--;\n        qs[k++] = i;\n      }\n\n      ArrayList<T[]> ret = new ArrayList<>(k - 1);\n      for (int i = 0; i < k - 1; i++) ret.add(xy[qs[i]]);\n      return ret;\n    }\n\n    static <T extends Number> double ccw(T[] a, T[] b, T[] t) {\n      return (t[0].doubleValue() - a[0].doubleValue()) * (b[1].doubleValue() - a[1].doubleValue()) - (b[0].doubleValue() - a[0].doubleValue()) * (t[1].doubleValue() - a[1].doubleValue());\n    }\n  }\n\n  // Template\n  public static void main(String[] args) {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n=cin.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tP[] p = new P[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s=cin.next().split(\",\");\n\t\t\t\tp[i]=new P(Double.parseDouble(s[0]),Double.parseDouble(s[1]));\n\t\t\t}\n\t\t\tP[] con=Main.convexHull(p);\n\t\t\tSystem.out.println(p.length-con.length);\n\t\t}\n\n\t}\n\tpublic static final double EPS = 1e-8;\n\n\tpublic static class P implements Comparable<P>{\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t//座標が左下にあるほどソート列において前に来る\n\t\tpublic int compareTo(P o) {\n\t\t\tif(equals(o))return 0;\n\t\t\tif(Math.abs(x-o.x)<EPS){\n\t\t\t\treturn y-o.y<0?-1:y-o.y>0?1:0;\n\t\t\t}\n\t\t\treturn x-o.x<0?-1:x-o.x>0?1:0;\n\t\t}\n\t\tpublic boolean equals(P o){\n\t\t\treturn Math.abs(x-o.x)<EPS && Math.abs(y-o.y)<EPS;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t}\n\n\t/**\n\t * s->tベクトル\n\t */\n\tpublic static class Vec{\n\t\tpublic P s;\n\t\tpublic P t;\n\t\tpublic double dx;\n\t\tpublic double dy;\n\t\tpublic Vec(P t){\n\t\t\tthis.s = new P(0, 0);\n\t\t\tthis.t = t;\n\t\t\tdx = t.x-s.x;\n\t\t\tdy = t.y-s.y;\n\t\t}\n\t\tpublic Vec(P s, P t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tdx = t.x-s.x;\n\t\t\tdy = t.y-s.y;\n\t\t}\n\t\tpublic Vec reverse(){\n\t\t\treturn new Vec(t, s);\n\t\t}\n\t\t/**\n\t\t * ベクトルの大きさ\n\t\t */\n\t\tpublic double norm(){\n\t\t\treturn Math.sqrt(dx*dx+dy*dy);\n\t\t}\n\t\t/**\n\t\t * 内積\n\t\t */\n\t\tpublic double dotProduct(Vec o){\n\t\t\treturn dx*o.dx + dy*o.dy;\n\t\t}\n\t\t/**\n\t\t * 外積\n\t\t */\n\t\tpublic double crossProduct(Vec o){\n\t\t\treturn dx*o.dy - dy*o.dx;\n\t\t}\n\t\t/**\n\t\t * ベクトル o と直交しているか\n\t\t * 交点を持っている必要はない\n\t\t * Verify: AOJ0058\n\t\t */\n\t\tpublic boolean isOrthogonal(Vec o){\n\t\t\treturn dotProduct(o)==0;\n\t\t}\n\t\t/**\n\t\t * ベクトル o と平行か\n\t\t */\n\t\tpublic boolean isParallel(Vec o){\n\t\t\treturn crossProduct(o)==0;\n\t\t}\n\t\t/**\n\t\t * CCW\n\t\t */\n\t\tpublic int ccw_(P p){\n\t\t\treturn ccw(s, t, p);\n\t\t}\n\t\t/**\n\t\t * ベクトル o と交わるか\n\t\t */\n\t\tpublic boolean isCross(Vec o){\n\t\t\treturn ccw_(o.s)*ccw_(o.t) < EPS && o.ccw_(s)*o.ccw_(t) < EPS ||\n\t\t\tccw_(o.s)*ccw_(o.t) < EPS && o.ccw_(s)*o.ccw_(t) < EPS;\n\t\t}\n\t\t/**\n\t\t * 点p からベクトル延長線上へ垂線を引いたときの長さ\n\t\t */\n\t\tpublic double distanceFromPoint(P p){\n\t\t\tVec o = new Vec(s, p);\n\t\t\treturn Math.abs(crossProduct(o))/norm();\n\t\t}\n\t\t/**\n\t\t * 点pをこのベクトルに対して線対象の位置に移す\n\t\t * 方程式ガン解きだが、誤差は少ないらしい\n\t\t * Verify: AOJ0081\n\t\t */\n\t\tpublic P symmetricPoint(P p){\n\t\t\tif(s.x==t.x){\n\t\t\t\treturn new P(p.x+(s.x-p.x)*2, p.y);\n\t\t\t}\n\t\t\telse if(s.y==t.y){\n\t\t\t\treturn new P(p.x, p.y+(s.y-p.y)*2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdouble alpha = (s.y-t.y)/(s.x-t.x);\n\t\t\t\tdouble beta = s.y-s.x*alpha;\n\t\t\t\tdouble x = (2*p.y*alpha-2*alpha*beta+p.x-alpha*alpha*p.x)/(alpha*alpha+1);\n\t\t\t\tdouble y = (p.x-x)/alpha+p.y;\n\t\t\t\treturn new P(x, y);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn s+\"->\"+t;\n\t\t}\n\t}\n\n\t/**\n\t * CCW: counter clock wise\n\t * 1 : clock wise\n\t * -1: counter clock wise\n\t * 2 : c--a--b on line\n\t * -2: a--b--c on line\n\t * 0 : a--c--b or a--c=b on line\n\t */\n\tpublic static int ccw(P p1, P p2, P p3){\n\t\tVec a = new Vec(p1, p2);\n\t\tVec b = new Vec(p1, p3);\n\t\tif(a.crossProduct(b)<EPS)return 1;\n\t\tif(a.crossProduct(b)>EPS)return -1;\n\t\t//if program run here, three points on line because AxB = 0 shows parallel\n\t\tif(a.dotProduct(b)<EPS)return 2;\n\t\tif(a.norm() < b.norm())return -2;\n\t\treturn 0;\n\t}\n\n\t/**\n\t * 頂点列を与えてその多角形の面積を求める\n\t * 頂点列はどっちまわりでもいい\n\t * Vecの外積を使うとうまくいかないので別途外積を書き下している\n\t * 誤差が気になるなら2で割らないといいっぽいよ\n\t */\n\tpublic static double area(P[] p){\n\t\tint n = p.length;\n\t\tif(n<3)return 0;\n\t\tdouble a = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta += p[i].x*p[(i+1)%n].y-p[i].y*p[(i+1)%n].x;\n\t\t}\n\t\treturn Math.abs(a/2);\n\t}\n\n\t/**\n\t * 反時計回りに凸包を求める O(n log n)\n\t * Graham's scan algorithm\n\t * Verify: UVa109\n\t */\n\tpublic static P[] convexHull(P[] p){\n\t\tint n = p.length;\n\t\tif(n<3)return p;\n\t\tArrays.sort(p);\n\t\tLinkedList<P> lower = new LinkedList<P>();\n\t\tlower.add(p[0]);\n\t\tlower.add(p[1]);\n\t\tfor(int i=2;i<n;i++){\n\t\t\tlower.add(p[i]);\n\t\t\twhile(lower.size()>=3){\n\t\t\t\tint k = lower.size()-1;\n\t\t\t\tif(ccw(lower.get(k-2), lower.get(k-1), lower.get(k))==-1 && ccw(lower.get(k-1), lower.get(k), lower.get(k-2))==-1)break;\n\t\t\t\tlower.remove(k-1);\n\t\t\t}\n\t\t}\n\t\tLinkedList<P> upper = new LinkedList<P>();\n\t\tupper.add(p[n-1]);\n\t\tupper.add(p[n-2]);\n\t\tfor(int i=n-3;i>=0;i--){\n\t\t\tupper.add(p[i]);\n\t\t\twhile(upper.size()>=3){\n\t\t\t\tint k = upper.size()-1;\n\t\t\t\tif(ccw(upper.get(k-2), upper.get(k-1), upper.get(k))==-1 && ccw(upper.get(k-1), upper.get(k), upper.get(k-2))==-1)break;\n\t\t\t\tupper.remove(k-1);\n\t\t\t}\n\t\t}\n\t\tupper.remove(0);\n\t\tupper.remove(upper.size()-1);\n\t\tint N = lower.size()+upper.size();\n\t\tP[] res = new P[N];\n\t\tint x = 0;\n\t\tfor(P q:upper)res[x++] = q;\n\t\tfor(P q:lower)res[x++] = q;\n//\t\tif(area(res)<=EPS)return p;\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tdouble EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D[] p = new Point2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString [] input = sc.next().split(\",\");\n\t\t\t\tdouble x = Double.parseDouble(input[0]);\n\t\t\t\tdouble y = Double.parseDouble(input[1]);\n\t\t\t\tp[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tPoint2D [] res = convexHull(p);\n\t\t\tSystem.out.println(n - res.length);\n\t\t\t\n\t\t}\n\t}\n\t\n\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\tpublic int compare(Point2D o1, Point2D o2) {\n\t\t\tif(o1.getX() < o2.getX()) return -1;\n\t\t\telse if(o1.getX() > o2.getX()) return 1;\n\t\t\telse if(o1.getY() < o2.getY()) return -1;\n\t\t\telse if(o1.getY() > o2.getY()) return 1;\n\t\t\telse return 0;\n\t\t}\n\t};\n\t\n\tprivate Point2D [] convexHull(Point2D [] p) {\n\t\tint n = p.length;\n\t\tArrays.sort(p, com);\n\t\tArrayList<Point2D> q = new ArrayList<Point2D>();\n\t\tq.add(p[0]);\n\t\tq.add(p[1]);\n\t\t\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tboolean correct_turn;\n\t\t\tdo{\n\t\t\t\tPoint2D q1 = q.get(q.size() - 2);\n\t\t\t\tPoint2D q2 = q.get(q.size() - 1);\n\t\t\t\tcorrect_turn = Line2D.relativeCCW(q1.getX(), q1.getY(), q2.getX(), q2.getY(), p[i].getX(), p[i].getY()) == -1;\n\t\t\t\tif(! correct_turn)q.remove(q.size() - 1);\n\t\t\t}while(! correct_turn && q.size() >= 2);\n\t\t\tq.add(p[i]);\n\t\t}\n\t\tint t = q.size();\n\t\tfor(int i = n - 2; i >= 0; i--){\n\t\t\tboolean correct_turn;\n\t\t\tdo{\n\t\t\t\tPoint2D q1 = q.get(q.size() - 2);\n\t\t\t\tPoint2D q2 = q.get(q.size() - 1);\n\t\t\t\tcorrect_turn = Line2D.relativeCCW(q1.getX(), q1.getY(), q2.getX(), q2.getY(), p[i].getX(), p[i].getY()) == -1;\n\t\t\t\tif(! correct_turn)q.remove(q.size() - 1);\n\t\t\t}while(! correct_turn && q.size() > t);\n\t\t\tq.add(p[i]);\n\t\t}\n\t\tq.remove(q.size() - 1);\n\t\tPoint2D [] res = q.toArray(new Point2D[q.size()]);\n\t\treturn res;\n\t}\n\t\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nnamespace aoj {\n\tstruct Point {\n\t\tprivate double _x, _y;\n\t\tpublic Point(double x, double y) {\n\t\t\t_x = x;\n\t\t\t_y = y;\n\t\t}\n\t\tpublic double x { get { return _x; } set { _x = value; } }\n\t\tpublic double y { get { return _y; } set { _y = value; } }\n\t\tpublic static Point operator+(Point r, Point l) { return new Point(r.x + l.x, r.y + l.y); }\n\t\tpublic static Point operator-(Point r, Point l) { return new Point(r.x - l.x, r.y - l.y); }\n\t\tpublic static double Cross(Point p1, Point p2) { return p1.x * p2.y - p1.y * p2.x; }\n\t}\n\tclass _0068 {\n\t\tstatic bool Turn2Right(Point p0, Point p1, Point p2) { return Point.Cross(p2 - p0, p1 - p0) > 0; }\n\t\tstatic int GrahamScan(Point[] ps) {\n\t\t\tArray.Sort(ps, (a, b) => (a.x < b.x) ? -1 : (a.x > b.x) ? 1 : 0);\n\t\t\tvar p0 = ps[0];\n\n\t\t\tvar args = new List<KeyValuePair<Point,double>>();\n\t\t\tfor (int i = 1; i < ps.Length; i++) {\n\t\t\t\tvar tp = ps[i] - p0;\n\t\t\t\targs.Add(new KeyValuePair<Point, double>(ps[i], Math.Atan2(tp.y, tp.x)));\n\t\t\t}\n\t\t\targs.Sort((a, b) => (a.Value < b.Value) ? -1 : (a.Value > b.Value) ? 1 : 0);\n\t\t\tfor (int i = 1; i < ps.Length; i++)\n\t\t\t\tps[i] = args[i - 1].Key;\n\n\t\t\tvar s = new Stack<Point>();\n\t\t\ts.Push(ps[0]); s.Push(ps[1]); s.Push(ps[2]);\n\t\t\tfor(int i = 3; i < ps.Length; i++) {\n\t\t\t\tvar top = s.Pop();\n\t\t\t\tvar n2t = s.Pop();\n\t\t\t\twhile (Turn2Right(n2t, top, ps[i])) {\n\t\t\t\t\ttop = n2t;\n\t\t\t\t\tn2t = s.Pop();\n\t\t\t\t}\n\t\t\t\ts.Push(n2t); s.Push(top); s.Push(ps[i]);\n\t\t\t}\n\t\t\treturn ps.Length - s.Count;\n\t\t}\n\t\tpublic static void Main() {\n\t\t\tstring str;\n\t\t\twhile ((str = Console.ReadLine()) != \"0\") {\n\t\t\t\tvar n = int.Parse(str);\n\t\t\t\tvar points = new Point[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tvar pos = Console.ReadLine().Split(',').Take(2).Select(double.Parse).ToArray();\n\t\t\t\t\tpoints[i].x = pos[0];\tpoints[i].y = pos[1];\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine(GrahamScan(points));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint n=sc.I,p;\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile(n!=0){\n\t\t\tp=0;\n\t\t\tvar a=new double[n][];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i]=Array.ConvertAll(Console.ReadLine().Split(','),double.Parse);\n\t\t\t\tif(a[i][1]<a[p][1]){p=i;}\n\t\t\t\telse if(a[i][1]==a[p][1]&&a[i][0]<a[p][0]){p=i;}\n\t\t\t}\n\t\t\tGs gs=new Gs(a,p,true);\n\t\t\tsb.Append((n-gs.li.Count)+\"\\n\");\n\t\t\tn=sc.I;\n\t\t}\n\t\tConsole.Write(sb);\n\t}\n}\npublic class Gs{\n\tpublic class Dt{\n\t\tpublic int n;\n\t\tpublic double x,y;\n\t\tpublic double d;\n\t\tpublic Dt(double d,int n,double x,double y){this.d=d;this.n=n;this.x=x;this.y=y;}\n\t}\n\tprivate Dt[] arr;\n\tprivate double cd,cx;\n\tpublic List<Dt> li=new List<Dt>();\n\tpublic Gs(double[][] a,int p,bool b){\n\t\tint n=a.Length,q=2;\n\t\tarr=new Dt[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i!=p){arr[i]=new Dt(Atan2(a[i][1]-a[p][1],a[i][0]-a[p][0])*180/PI,i,a[i][0],a[i][1]);cd=Max(cd,arr[i].d);}\n\t\t}\n\t\tarr[p]=new Dt(-512,p,a[p][0],a[p][1]);\n\t\tif(b){\n\t\t\tArray.Sort(arr,Ca1);\n\t\t\tli.Add(arr[0]);li.Add(arr[1]);\n\t\t\twhile(q!=n){\n\t\t\t\tli.Add(arr[q]);\n\t\t\t\tq++;\n\t\t\t\twhile(li.Count>2&&(li[li.Count-1].x-li[li.Count-2].x)*(li[li.Count-3].y-li[li.Count-2].y)-(li[li.Count-1].y-li[li.Count-2].y)*(li[li.Count-3].x-li[li.Count-2].x)<=0){li.RemoveAt(li.Count-2);}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcx=a[p][0];\n\t\t\tArray.Sort(arr,Ca2);\n\t\t\tli.Add(arr[0]);li.Add(arr[1]);\n\t\t\twhile(q!=n){\n\t\t\t\tli.Add(arr[q]);\n\t\t\t\tq++;\n\t\t\t\twhile(li.Count>2&&(li[li.Count-1].x-li[li.Count-2].x)*(li[li.Count-3].y-li[li.Count-2].y)-(li[li.Count-1].y-li[li.Count-2].y)*(li[li.Count-3].x-li[li.Count-2].x)<0){li.RemoveAt(li.Count-2);}\n\t\t\t}\n\t\t}\n\t}\n\tprivate int Ca1(Dt a,Dt b){\n\t\tif(a.d>b.d){return 1;}\n\t\telse if(a.d<b.d){return -1;}\n\t\telse if(a.y>b.y){return 1;}\n\t\telse if(a.y<b.y){return -1;}\n\t\telse if(a.x<b.x){return 1;}\n\t\telse if(a.x>b.x){return -1;}\n\t\treturn 0;\n\t}\n\tprivate int Ca2(Dt a,Dt b){\n\t\tif(a.d>b.d){return 1;}\n\t\telse if(a.d<b.d){return -1;}\n\t\telse if(a.d==cd){\n\t\t\tif(cx==a.x){if(a.y<b.y){return 1;}else if(a.y>b.y){return -1;}}\n\t\t\telse if(cx>a.x){if(a.x>b.x){return 1;}else if(a.x<b.x){return -1;}}\n\t\t\telse{if(a.x<b.x){return 1;}else if(a.x>b.x){return -1;}}\n\t\t}\n\t\telse{\n\t\t\tif(cx==a.x){if(a.y>b.y){return 1;}else if(a.y<b.y){return -1;}}\n\t\t\telse if(cx<a.x){if(a.x>b.x){return 1;}else if(a.x<b.x){return -1;}}\n\t\t\telse{if(a.x<b.x){return 1;}else if(a.x>b.x){return -1;}}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic double Diameter(){//直径\n\t\tdouble q=(li[0].x-li[li.Count-1].x),p=(li[0].y-li[li.Count-1].y),d=Math.Sqrt(q*q+p*p);\n\t\tfor(int i=1;i<li.Count;i++){\n\t\t\tq=(li[i].x-li[i-1].x);\n\t\t\tp=(li[i].y-li[i-1].y);\n\t\t\td+=Sqrt(q*q+p*p);\n\t\t}\n\t\treturn d;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nnamespace aoj {\n\tpublic struct Point {\n\t\tprivate double _x, _y;\n\t\tpublic Point(double x, double y) {\n\t\t\t_x = x;\n\t\t\t_y = y;\n\t\t}\n\t\tpublic double x { get { return _x; } set { _x = value; } }\n\t\tpublic double y { get { return _y; } set { _y = value; } }\n\t\tpublic static Point operator+(Point r, Point l) { return new Point(r.x + l.x, r.y + l.y); }\n\t\tpublic static Point operator-(Point r, Point l) { return new Point(r.x - l.x, r.y - l.y); }\n\t\tpublic static double Cross(Point p1, Point p2) { return p1.x * p2.y - p1.y * p2.x; }\n\t}\n\tpublic class Program {\n\t\tpublic static bool Turn2Right(Point p0, Point p1, Point p2) { return Point.Cross(p2 - p0, p1 - p0) > 0; }\n\t\tpublic static int GrahamScan(Point[] ps) {\n\t\t\tArray.Sort(ps, (a, b) => (int)(a.y - b.y));\n\t\t\tvar p0 = ps[0];\n\n\t\t\tvar args = new SortedList<double, Point>();\n\t\t\tfor (int i = 1; i < ps.Length; i++) {\n\t\t\t\tvar tp = ps[i] - p0;\n\t\t\t\targs.Add(Math.Atan2(tp.y, tp.x), ps[i]);\n\t\t\t}\n\t\t\targs.Values.CopyTo(ps, 1);\n\n\t\t\tvar s = new Stack<Point>();\n\t\t\ts.Push(ps[0]); s.Push(ps[1]); s.Push(ps[2]);\n\t\t\tfor(int i = 3; i < ps.Length; i++) {\n\t\t\t\tvar top = s.Pop();\n\t\t\t\tvar n2t = s.Pop();\n\t\t\t\twhile (Turn2Right(n2t, top, ps[i])) {\n\t\t\t\t\ttop = n2t;\n\t\t\t\t\tn2t = s.Pop();\n\t\t\t\t}\n\t\t\t\ts.Push(n2t); s.Push(top); s.Push(ps[i]);\n\t\t\t}\n\t\t\treturn ps.Length - s.Count;\n\t\t}\n\t\tpublic static void Main() {\n\t\t\tstring str;\n\t\t\twhile ((str = Console.ReadLine()) != \"0\") {\n\t\t\t\tvar n = int.Parse(str);\n\t\t\t\tvar points = new Point[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tvar pos = Console.ReadLine().Split(',').Take(2).Select(double.Parse).ToArray();\n\t\t\t\t\tpoints[i].x = pos[0];\tpoints[i].y = pos[1];\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine(GrahamScan(points));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ0068\n{\n    class Program\n    {\n        public bool[] inside;\n        public void Proc()\n        {\n            while (true)\n            {\n                string input = Console.ReadLine();\n                if (string.IsNullOrEmpty(input)) continue;\n                int N = int.Parse(input);\n                if (N == 0) break;\n                List<Point> table = new List<Point>();\n                int count = 0;\n\n                for (int i = 0; i < N; i++)\n                {\n                    input = Console.ReadLine();\n                    string[] num = input.Split(',');\n                    table.Add(new Point(num[0], num[1]));\n                }\n\n                if (N == 3)\n                {\n                    Console.WriteLine(count);\n                    continue;\n                }\n\n                decimal[,] dist = new decimal[N, N];\n                this.inside = new bool[N];\n\n                for (int i = 0; i < N; i++)\n                {\n                    for (int j = 0; j < N; j++)\n                    {\n                        dist[i, j] = getDistance(table[i], table[j]);\n                    }\n                }\n\n                for (int i = 0; i < N; i++)\n                {\n                    decimal[,] NP = new decimal[3, 2];\n                    NP[0, 1] = 4000000M; NP[1, 1] = 4000000M; NP[2, 1] = 4000000M;\n                    for (int j = 0; j < N; j++)\n                    {\n                        if (dist[i, j].Equals(0)) continue;\n                        if (this.inside[j]) continue;\n                        if (dist[i,j] < NP[0,1])\n                        {\n                            NP[2, 0] = NP[1, 0];\n                            NP[2, 1] = NP[1, 1];\n                            NP[1, 0] = NP[0, 0];\n                            NP[1, 1] = NP[0, 1];\n                            NP[0, 0] = j;\n                            NP[0, 1] = dist[i, j];\n                        } else if (dist[i,j] < NP[1,1])\n                        {\n                            NP[2, 0] = NP[1, 0];\n                            NP[2, 1] = NP[1, 1];\n                            NP[1, 0] = j;\n                            NP[1, 1] = dist[i, j];\n                        } else if (dist[i, j] < NP[2, 1])\n                        {\n                            NP[2, 0] = j;\n                            NP[2, 1] = dist[i, j];\n                        }\n                    }\n                    Rectangle parts = new Rectangle(table[(int)NP[0,0]], table[(int)NP[1, 0]],table[(int)NP[2, 0]]);\n\n                    if (parts.InterSection(table[i]))\n                    {\n                        this.inside[i] = true;\n                        count++;\n                    }\n                }\n                Console.WriteLine(count);\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            Program prg = new Program();\n            prg.Proc();\n        }\n\n        public decimal getDistance(Point p, Point q)\n        {\n            return (p.X - q.X) * (p.X - q.X) + (p.Y - q.Y) * (p.Y - q.Y);\n        }\n\n        public struct Point\n        {\n            decimal x;\n            decimal y;\n\n            public Point(string x, string y)\n            {\n                this.x = decimal.Parse(x);\n                this.y = decimal.Parse(y);\n            }\n\n            public decimal X\n            {\n                get { return this.x; }\n                set { this.x = X; }\n            }\n\n            public decimal Y\n            {\n                get { return this.y; }\n                set { this.y = Y; }\n            }\n        }\n\n        public struct Vector\n        {\n            decimal vx;\n            decimal vy;\n\n            public Vector(Point a, Point b)\n            {\n                this.vx = b.X - a.X;\n                this.vy = b.Y - a.Y;\n            }\n\n            public decimal VX\n            {\n                get { return this.vx; }\n                set { this.vx = VX; }\n            }\n\n            public decimal VY\n            {\n                get { return this.vy; }\n                set { this.vy = VY; }\n            }\n        }\n\n        public struct Rectangle\n        {\n            Point a;\n            Point b;\n            Point c;\n\n            public Rectangle(Point x, Point y, Point z)\n            {\n                this.a = x;\n                this.b = y;\n                this.c = z;\n            }\n\n            public bool InterSection(Point p)\n            {\n                Vector AB = new Vector(this.a, this.b);\n                Vector BP = new Vector(this.b, p);\n\n                Vector BC = new Vector(this.b, this.c);\n                Vector CP = new Vector(this.c, p);\n\n                Vector CA = new Vector(this.c, this.a);\n                Vector AP = new Vector(this.a, p);\n\n                decimal C1 = AB.VX * BP.VY - AB.VY * BP.VX;\n                decimal C2 = BC.VX * CP.VY - BC.VY * CP.VX;\n                decimal C3 = CA.VX * AP.VY - CA.VY * AP.VX;\n\n                if ((C1 > 0 && C2 > 0 && C3 > 0) || (C1 < 0 && C2 < 0 && C3 < 0))\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing CompProgLib;\n\nnamespace _0068\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int n = RInt();\n                if (n == 0) break;\n\n                List<Vector> ps = new List<Vector>(n);\n\n                for (int i = 0 ; i < n ; i++)\n                {\n                    double[] items = RDoubleAr(',');\n                    ps.Add(new Vector(items[0], items[1]));\n                }\n\n                var convex = getConvex(ps);\n                Console.WriteLine(n - convex.Count());\n            }\n        }\n\n        /// <summary>\n        /// 凸包となる点を取得する（グラハムスキャン）\n        /// </summary>\n        /// <param name=\"ps\">点集合（原点からのベクトル集合）</param>\n        /// <returns>凸包となる点集合</returns>\n        public static Vector[] getConvex(List<Vector> ps)\n        {\n            int n = ps.Count;\n            ps = ps.OrderBy(x => x.X).ThenBy(x => x.Y).ToList();\n\n            int k = 0;\n            Vector[] convex = new Vector[n * 2];\n\n            for (int i = 0 ; i < n ; i++)\n            {\n                while (k > 1 && Vector.CrossProduct(convex[k - 1] - convex[k - 2], ps[i] - convex[k - 1]) <= 0) k--;\n                convex[k++] = ps[i];\n            }\n\n            for (int i = n - 2, t = k ; i >= 0 ; i--)\n            {\n                while (t < k && Vector.CrossProduct(convex[k - 1] - convex[k - 2], ps[i] - convex[k - 1]) <= 0) k--;\n                convex[k++] = ps[i];\n            }\n\n            Array.Resize(ref convex, k - 1);\n            return convex;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly double EPS = 1E-10;\n\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                int n = int.Parse(Console.ReadLine());\n\n                if (n == 0) break;\n\n                List<Point> s = new List<Point>();\n\n                for (int i = 0; i < n; i++)\n                {\n                    double[] input = Array.ConvertAll(Console.ReadLine().Split(','), double.Parse);\n                    s.Add(new Point(input[0], input[1]));\n                }\n\n                List<Point> selected = AndrewScan(s);\n\n                int ans = n - selected.Count;\n\n                sb.AppendLine(ans.ToString());\n            }\n            Console.Write(sb);\n        }\n\n        static List<Point> AndrewScan(List<Point> s)\n        {\n            int n = s.Count;\n\n            if (n < 3) return s;\n\n            s.Sort();\n\n            List<Point> u = new List<Point>();\n            u.Add(s[0]);\n            u.Add(s[1]);\n\n            List<Point> l = new List<Point>();\n            l.Add(s[n - 1]);\n            l.Add(s[n - 2]);\n\n            for (int i = 2; i < n; i++)\n            {\n                for (int j = u.Count; j >= 2 && (u[j - 1] - u[j - 2]).Cross(s[i] - u[j - 2]) > EPS; j--)\n                {\n                    u.RemoveAt(u.Count - 1);\n                }\n                u.Add(s[i]);\n            }\n\n            for (int i = s.Count - 3; i >= 0; i--)\n            {\n                for (int j = l.Count; j >= 2 && (l[j - 1] - l[j - 2]).Cross(s[i] - l[j - 2]) > EPS; j--)\n                {\n                    l.RemoveAt(l.Count - 1);\n                }\n                l.Add(s[i]);\n            }\n\n            l.Reverse();\n            for (int i = u.Count - 2; i >= 1; i--) l.Add(u[i]);\n\n            return l;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point() { }\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0068\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int n = RInt();\n                if (n == 0) break;\n\n                List<Vector> ps = new List<Vector>(n);\n\n                for (int i = 0 ; i < n ; i++)\n                {\n                    double[] items = RDoubleAr(',');\n                    ps.Add(new Vector(items[0], items[1]));\n                }\n\n                var convex = getConvex(ps);\n                Console.WriteLine(n - convex.Count());\n            }\n        }\n\n        /// <summary>\n        /// 凸包となる点を取得する（グラハムスキャン）\n        /// </summary>\n        /// <param name=\"ps\">点集合（原点からのベクトル集合）</param>\n        /// <returns>凸包となる点集合</returns>\n        public static Vector[] getConvex(List<Vector> ps)\n        {\n            int n = ps.Count;\n            ps = ps.OrderBy(x => x.X).ThenBy(x => x.Y).ToList();\n\n            int k = 0;\n            Vector[] convex = new Vector[n * 2];\n\n            for (int i = 0 ; i < n ; i++)\n            {\n                while (k > 1 && Vector.CrossProduct(convex[k - 1] - convex[k - 2], ps[i] - convex[k - 1]) <= 0) k--;\n                convex[k++] = ps[i];\n            }\n\n            for (int i = n - 2, t = k ; i >= 0 ; i--)\n            {\n                while (t < k && Vector.CrossProduct(convex[k - 1] - convex[k - 2], ps[i] - convex[k - 1]) <= 0) k--;\n                convex[k++] = ps[i];\n            }\n\n            Array.Resize(ref convex, k - 1);\n            return convex;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        struct Point\n        {\n            public double x;\n            public double y;\n        }\n\n        static void Main()\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                int n = int.Parse(Console.ReadLine());\n\n                if (n == 0) break;\n\n                List<Point> pointList = new List<Point>();\n\n                for (int i = 0; i < n; i++)\n                {\n                    double[] input = Array.ConvertAll(Console.ReadLine().Split(','), double.Parse);\n\n                    Point inputP;\n                    inputP.x = input[0];\n                    inputP.y = input[1];\n                    pointList.Add(inputP);\n                }\n\n                pointList = pointList.OrderBy(p => p.x).ThenBy(p => p.y).ToList();\n\n                List<Point> selectList = new List<Point>();\n\n                Point startP;\n                startP.x = pointList[0].x;\n                startP.y = pointList[0].y;\n\n                Point nextP = new Point();\n\n                double minRd = 1.0;\n\n                for (int i = 1; i < pointList.Count; i++)\n                {\n                    double r = Math.Atan2((pointList[i].y - startP.y), (pointList[i].x - startP.x));\n\n                    if (r < minRd)\n                    {\n                        nextP.x = pointList[i].x;\n                        nextP.y = pointList[i].y;\n                        minRd = r;\n                    }\n                }\n\n                selectList.Add(nextP);\n\n                Point target = new Point();\n\n                do\n                {\n                    double maxRd = 0.0;\n\n                    for (int i = 0; i < pointList.Count; i++)\n                    {\n                        if (pointList[i].x != startP.x || pointList[i].y != startP.y ||\n                            pointList[i].x != nextP.x || pointList[i].y != nextP.y)\n                        {\n                            double rd = CalcAngle(startP, nextP, pointList[i]);\n\n                            if (rd > maxRd)\n                            {\n                                maxRd = rd;\n\n                                target.x = pointList[i].x;\n                                target.y = pointList[i].y;\n                            }\n                        }\n                    }\n\n                    startP.x = nextP.x;\n                    startP.y = nextP.y;\n                    nextP.x = target.x;\n                    nextP.y = target.y;\n\n                    selectList.Add(target);\n\n                } while (target.x != pointList[0].x || target.y != pointList[0].y);\n\n                int ans = pointList.Count - selectList.Count;\n\n                sb.AppendLine(ans.ToString());\n            }\n            Console.Write(sb);\n        }\n\n        static double CalcAngle(Point a, Point b, Point c)\n        {\n            double baX = a.x - b.x;\n            double baY = a.y - b.y;\n            double bcX = c.x - b.x;\n            double bcY = c.y - b.y;\n\n            double babc = baX * bcX + baY * bcY;\n            double ban = baX * baX + baY * baY;\n            double bcn = bcX * bcX + bcY * bcY;\n\n            double rd = Math.Acos(babc / Math.Sqrt(ban * bcn));\n\n            return rd;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nnamespace aoj {\n\tstruct Point {\n\t\tprivate double _x, _y;\n\t\tpublic Point(double x, double y) {\n\t\t\t_x = x;\n\t\t\t_y = y;\n\t\t}\n\t\tpublic double x { get { return _x; } set { _x = value; } }\n\t\tpublic double y { get { return _y; } set { _y = value; } }\n\t\tpublic static Point operator+(Point r, Point l) { return new Point(r.x + l.x, r.y + l.y); }\n\t\tpublic static Point operator-(Point r, Point l) { return new Point(r.x - l.x, r.y - l.y); }\n\t\tpublic static double Cross(Point p1, Point p2) { return p1.x * p2.y - p1.y * p2.x; }\n\t}\n\tpublic class Program {\n\t\tpublic static bool Turn2Right(Point p0, Point p1, Point p2) { return Point.Cross(p2 - p0, p1 - p0) > 0; }\n\t\tpublic static int GrahamScan(Point[] ps) {\n\t\t\tArray.Sort(ps, (a, b) => (int)(a.y - b.y));\n\t\t\tvar p0 = ps[0];\n\n\t\t\tvar args = new SortedList<double, Point>();\n\t\t\tfor (int i = 1; i < ps.Length; i++) {\n\t\t\t\tvar tp = ps[i] - p0;\n\t\t\t\targs.Add(Math.Atan2(tp.y, tp.x), ps[i]);\n\t\t\t}\n\t\t\targs.Values.CopyTo(ps, 1);\n\n\t\t\tvar s = new Stack<Point>();\n\t\t\ts.Push(ps[0]); s.Push(ps[1]); s.Push(ps[2]);\n\t\t\tfor(int i = 3; i < ps.Length; i++) {\n\t\t\t\tvar top = s.Pop();\n\t\t\t\tvar n2t = s.Pop();\n\t\t\t\twhile (Turn2Right(n2t, top, ps[i])) {\n\t\t\t\t\ttop = n2t;\n\t\t\t\t\tn2t = s.Pop();\n\t\t\t\t}\n\t\t\t\ts.Push(n2t); s.Push(top); s.Push(ps[i]);\n\t\t\t}\n\t\t\treturn ps.Length - s.Count;\n\t\t}\n\t\tpublic static void Main() {\n\t\t\tstring str;\n\t\t\twhile ((str = Console.ReadLine()) != \"0\") {\n\t\t\t\tvar n = int.Parse(str);\n\t\t\t\tvar points = new Point[n];\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tvar pos = Console.ReadLine().Split(',').Take(2).Select(double.Parse).ToArray();\n\t\t\t\t\tpoints[i].x = pos[0];\tpoints[i].y = pos[1];\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine(GrahamScan(points));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing static System.Math;\n\nnamespace CSharpSpiral {\n\tclass Program {\n\t\tstatic void Main(string[] args) {\n\t\t\tvar sw = new StreamWriter(Console.OpenStandardOutput()) {\n\t\t\t\tAutoFlush =\n#if DEBUG\n\t\t\ttrue\n#else\n\t\t\tfalse\n#endif\n\t\t\t};\n\t\t\tConsole.SetOut(sw);\n\t\t\tnew Program().Solve(new ConsoleInput(\n#if DEBUG\n\t\t\tnew StreamReader(\"../../../inputData.txt\")\n#else\n\t\t\tConsole.In\n#endif\n\t\t\t, ','));\n\t\t\tConsole.Out.Flush();\n\t\t}\n\t\tpublic void Solve(ConsoleInput cin) {\n\t\t\twhile(true) {\n\t\t\t\tvar n = cin.ReadInt;\n\t\t\t\tif(n == 0) break;\n\t\t\t\tvar Points = new Point[n];\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\tvar datum = cin.ReadStrArray(2).Select(decimal.Parse).ToArray();\n\t\t\t\t\tPoints[i] = new Point(datum[0], datum[1]);\n\t\t\t\t}\n\t\t\t\tvar res = n - GrahamScan(Points).Count();\n\t\t\t\tConsole.WriteLine(res);\n\t\t\t}\n\t\t}\n\t\tpublic struct Point: IComparable<Point> {\n\t\t\tpublic decimal x { get; set; }\n\t\t\tpublic decimal y { get; set; }\n\t\t\tpublic Point(decimal xx, decimal yy) { x = xx; y = yy; }\n\t\t\tpublic int CompareTo(Point q)\n\t\t\t\t=> x == q.x ? y.CompareTo(q.y) : x.CompareTo(q.x);\n\t\t\tpublic static Point operator -(Point p, Point q) => new Point(q.x - p.x, q.y - p.y);\n\t\t\tpublic static decimal outer(Point p, Point q) => p.x * q.y - p.y * q.x;\n\t\t\tpublic override string ToString() => $\"({x}, {y})\";\n\t\t\t//outer((0,1),(1,0))==-1\n\t\t}\n\t\tpublic class PointComparer: IComparer<Point> {\n\t\t\tpublic int Compare(Point p, Point q) => p.CompareTo(q);\n\t\t}\n\t\tpublic List<Point> GrahamScan(Point[] X) {\n\t\t\tvar CO = new PointComparer();\n\t\t\tMergeSort(X, CO);\n\t\t\tvar Down = new Stack<Point>();\n\t\t\tDown.Push(X[0]);\n\t\t\tDown.Push(X[1]);\n\t\t\tforeach(var p in X.Skip(2)) {\n\t\t\t\twhile(true) {\n\t\t\t\t\tvar v1 = Down.Pop();\n\t\t\t\t\tif(!Down.Any()) {\n\t\t\t\t\t\tDown.Push(v1);\n\t\t\t\t\t\tDown.Push(p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvar v0 = Down.Peek();\n\t\t\t\t\tif(Point.outer(v0 - v1, p - v1) > 0) continue;\n\t\t\t\t\telse {\n\t\t\t\t\t\tDown.Push(v1);\n\t\t\t\t\t\tDown.Push(p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar Upper = new Stack<Point>();\n\t\t\tUpper.Push(X[X.Length - 1]);\n\t\t\tUpper.Push(X[X.Length - 2]);\n\t\t\tforeach(var p in X.Reverse().Skip(2)) {\n\t\t\t\twhile(true) {\n\t\t\t\t\tvar v1 = Upper.Pop();\n\t\t\t\t\tif(!Upper.Any()) {\n\t\t\t\t\t\tUpper.Push(v1);\n\t\t\t\t\t\tUpper.Push(p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvar v0 = Upper.Peek();\n\t\t\t\t\tif(Point.outer(v0 - v1, p - v1) > 0) continue;\n\t\t\t\t\telse {\n\t\t\t\t\t\tUpper.Push(v1);\n\t\t\t\t\t\tUpper.Push(p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar Hull = Upper.Concat(Down.Skip(1).Take(Down.Count() - 2));\n\t\t\treturn Hull.ToList();\n\t\t}\n\t\tpublic static void MergeSort<T>(T[] A, IComparer<T> comparer) where T : IComparable<T> {\n\t\t\tMergeSort1(0, A.Length, A, comparer);\n\t\t}\n\t\tprivate static void Merge<T>(int left, int mid, int right, T[] A, IComparer<T> comparer)\n\t\t\twhere T : IComparable<T> {\n\t\t\tvar nl = mid - left;\n\t\t\tvar nr = right - mid;\n\t\t\tvar L = new T[nl];\n\t\t\tvar R = new T[nr];\n\t\t\tfor(int i = 0; i < nl; i++)\n\t\t\t\tL[i] = A[i + left];\n\t\t\tfor(int i = 0; i < nr; i++)\n\t\t\t\tR[i] = A[i + mid];\n\t\t\tint il = 0, ir = 0;\n\t\t\tfor(int k = left; k < right; k++) {\n\t\t\t\tif(comparer.Compare(L[il], R[ir]) <= 0) {\n\t\t\t\t\tA[k] = L[il++];\n\t\t\t\t\tif(il == nl) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tfor(; ir < nr;)\n\t\t\t\t\t\t\tA[k++] = R[ir++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tA[k] = R[ir++];\n\t\t\t\t\tif(ir == nr) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tfor(; il < nl;)\n\t\t\t\t\t\t\tA[k++] = L[il++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate static void MergeSort1<T>(int left, int right, T[] A, IComparer<T> comparer)\n\t\twhere T : IComparable<T> {\n\t\t\tif(left + 1 < right) {\n\t\t\t\tvar mid = (left + right) / 2;\n\t\t\t\tMergeSort1(left, mid, A, comparer);\n\t\t\t\tMergeSort1(mid, right, A, comparer);\n\t\t\t\tMerge(left, mid, right, A, comparer);\n\t\t\t}\n\t\t}\n\t}\n\tstatic class ExtendClass {\n\t\tpublic static string Join<T>(this IEnumerable<T> X, string separator = \" \") => string.Join(separator, X);\n\t\t\n\t}\n\tclass ConsoleInput {\n\t\tprivate readonly TextReader _stream;\n\t\tprivate readonly char _separator = ' ';\n\t\tprivate readonly Queue<string> inputStream;\n\t\tpublic ConsoleInput(TextReader stream, char separator = ' ') {\n\t\t\tthis._separator = separator;\n\t\t\tthis._stream = stream;\n\t\t\tinputStream = new Queue<string>();\n\t\t}\n\t\tpublic string Read {\n\t\t\tget {\n\t\t\t\tif(inputStream.Count != 0) return inputStream.Dequeue();\n\t\t\t\tstring[] tmp = _stream.ReadLine().Split(_separator);\n\t\t\t\tfor(int i = 0; i < tmp.Length; ++i)\n\t\t\t\t\tinputStream.Enqueue(tmp[i]);\n\t\t\t\treturn inputStream.Dequeue();\n\t\t\t}\n\t\t}\n\t\tpublic string ReadLine { get { return _stream.ReadLine(); } }\n\t\tpublic int ReadInt { get { return int.Parse(Read); } }\n\t\tpublic long ReadLong { get { return long.Parse(Read); } }\n\t\tpublic double ReadDouble { get { return double.Parse(Read); } }\n\t\tpublic string[] ReadStrArray(long N) {\n\t\t\tvar ret = new string[N];\n\t\t\tfor(long i = 0; i < N; ++i)\n\t\t\t\tret[i] = Read;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i < N; ++i) ret[i] = ReadInt; return ret; }\n\t\tpublic long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i < N; ++i) ret[i] = ReadLong; return ret; }\n\t\tpublic double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i < N; ++i) ret[i] = ReadDouble; return ret; }\n\t\tpublic bool isEOF {\n\t\t\tget { return _stream.Peek() == -1; }\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly double EPS = 1E-10;\n\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                int n = int.Parse(Console.ReadLine());\n\n                if (n == 0) break;\n\n                Point[] ps = new Point[n];\n\n                for (int i = 0; i < n; i++)\n                {\n                    double[] input = Array.ConvertAll(Console.ReadLine().Split(','), double.Parse);\n                    ps[i] = new Point(input[0], input[1]);\n                }\n\n                int ans = n - ConvexHull(ps);\n\n                sb.AppendLine(ans.ToString());\n            }\n            Console.Write(sb);\n        }\n\n        static int ConvexHull(Point[] ps)\n        {\n            int n = ps.Length, k = 0;\n\n            Array.Sort(ps);\n\n            int[] ch = new int[n * 2];\n\n            for (int i = 0; i < n; ch[k++] = i++)\n            {\n                while (k >= 2 && (ps[ch[k - 1]] - ps[ch[k - 2]]).Cross(ps[i] - ps[ch[k - 2]]) > EPS) k--;\n            }\n\n            for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = i--)\n            {\n                while (k >= t && (ps[ch[k - 1]] - ps[ch[k - 2]]).Cross(ps[i] - ps[ch[k - 2]]) > EPS) k--;\n            }\n\n            return k - 1;\n        }\n    }\n\n    class Point : IComparable<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point() { }\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Point other)\n        {\n            return x != other.x ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing CompProgLib;\n\nnamespace _0068\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int n = RInt();\n                if (n == 0) break;\n\n                List<Vector> ps = new List<Vector>(n);\n\n                for (int i = 0 ; i < n ; i++)\n                {\n                    double[] items = RDoubleAr(',');\n                    ps.Add(new Vector(items[0], items[1]));\n                }\n\n                var convex = getConvex(ps);\n                Console.WriteLine(n - convex.Count());\n            }\n        }\n\n        /// <summary>\n        /// 凸包となる点を取得する（グラハムスキャン）\n        /// </summary>\n        /// <param name=\"ps\">点集合（原点からのベクトル集合）</param>\n        /// <returns>凸包となる点集合</returns>\n        public static Vector[] getConvex(List<Vector> ps)\n        {\n            int n = ps.Count;\n            ps = ps.OrderBy(x => x.X).ThenBy(x => x.Y).ToList();\n\n            int k = 0;\n            Vector[] convex = new Vector[n * 2];\n\n            for (int i = 0 ; i < n ; i++)\n            {\n                while (k > 1 && Vector.CrossProduct(convex[k - 1] - convex[k - 2], ps[i] - convex[k - 1]) <= 0) k--;\n                convex[k++] = ps[i];\n            }\n\n            for (int i = n - 2, t = k ; i >= 0 ; i--)\n            {\n                while (t < k && Vector.CrossProduct(convex[k - 1] - convex[k - 2], ps[i] - convex[k - 1]) <= 0) k--;\n                convex[k++] = ps[i];\n            }\n\n            Array.Resize(ref convex, k - 1);\n            return convex;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n\n    }\n}\n\nnamespace CompProgLib\n{\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[]line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ\n{\n    class Program\n    {\n        class Point\n        {\n            public double x, y;\n            public readonly int i;\n\n            public Point(double x, double y, int i)\n            {\n                this.x = x;\n                this.y = y;\n                this.i = i;\n            }\n\n            public override string ToString()\n            {\n                return i.ToString();\n            }\n        }\n        static void Main(string[] args)\n        {\n            string line;\n            while((line = Console.ReadLine()) != null)\n            {\n                if (line == \"0\") break;\n                var n = int.Parse(line);\n                var l = new List<Point>(n);\n                for(int i = 0; i < n; i++)\n                {\n                    var s = Console.ReadLine().Split(',').Select(double.Parse).ToArray();\n                    l.Add(new Point(s[0], s[1], i));\n                }\n                Point min = l.First(), @from = new Point(-10000, 0, -1), next;\n                foreach(var point in l)\n                {\n                    if (point.y < min.y)\n                        min = point;\n                }\n                next = min;\n                var res = new HashSet<int>();\n                do\n                {\n                    double min_angle = double.MaxValue;\n                    Point min_point = @from;\n                    foreach(var point in l)\n                    {\n                        if (@from == point || next == point) continue;\n                        var x1 = next.x - @from.x;\n                        var y1 = next.y - @from.y;\n                        var x2 = point.x - next.x;\n                        var y2 = point.y - next.y;\n                        var a = Math.Atan2(x1 * y2 - x2 * y1, x1 * x2 + y1 * y2);\n                        if (a < min_angle)\n                        {\n                            min_point = point;\n                            min_angle = a;\n                        }\n                    }\n                    @from = next;\n                    next = min_point;\n                    res.Add(@from.i);\n                } while(min != next);\n                Console.WriteLine(l.Count - res.Count);\n            }\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "// const\nvar COUNTER_CLOCKWISE = 1;\nvar CLOCKWISE = - 1;\nvar ONLINE_BACK = 2;\nvar ONLINE_FRONT =  -2;\nvar ON_SEGMENT = 0;\n\n// Vector2d\nvar Vector2D = class Vector2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nVector2D.prototype.Init = function(x,y){\n\tthis.x = x;\n\tthis.y = y;\n}\n\n/*\n * v: Vector2D\n */\nfunction rotateVector90(v){\n\tvar r = new Vector2D();\n\tr.x = -v.y;\n\tr.y = v.x;\n\treturn r;\n}\n\n/*\n * get degree to radian return radian\n */\nfunction getDegreeToRadian(degree){\n\tvar pi = 3.14159265358979323846;\n\treturn degree * pi / 180;\n}\n\n/*\n * vec:Vector2D return Vector2D\n */\nfunction getRotateVector(vec,degree){\n\tvar radian = getDegreeToRadian(degree);\n\n\tvar sin = Math.sin(radian);\n\tvar cos = Math.cos(radian);\n\n\tvar r = new Vector2D();\n\tr.x = vec.x * cos - vec.y * sin;\n\tr.y = vec.x * sin + vec.y * cos;\n\n\treturn r;\n}\n\nfunction isEqualVectors(a,b){\n\treturn equalFloats(a.x - b.x,0) && equalFloats(a.y - b.y,0);\n}\n\n/**\n * vec:Vector2D\n * \n * return unitVector\n */\nfunction getUnitVector(vec){\n\tvar length = getVectorLength2D(vec);\n\tif(length > 0){\n\t\treturn getDivideVector(vec,length);\n\t}\n\treturn vec;\n}\n\n/**\n * return vector length\n * \n * vec:Vector2D\n */\nfunction getVectorLength2D(vec){\n\treturn Math.sqrt((vec.x * vec.x) + (vec.y * vec.y));\n}\n\nfunction getDivideVector(vec2D,length){\n\tvec2D.x = vec2D.x / length;\n\tvec2D.y = vec2D.y / length;\n\treturn vec2D;\n}\n\nfunction equalFloats(a,b){\n\tvar threshold = 1 / 8192;\n\treturn Math.abs(a - b) < threshold;\n}\n\nfunction isParallelVector(vectorA,vectorB){\n\tvar na = rotateVector90(vectorA);\n\treturn equalFloats(0,dotProduct2D(na,vectorB));\n}\n\nfunction isVerticalVector(vectorA,vectorB){\n\treturn equalFloats(0,dotProduct2D(vectorA,vectorB));\n}\n\nfunction subtractVector(vecA,vecB){\n\tvar vec = new Vector2D();\n\tvec.x = vecA.x - vecB.x;\n\tvec.y = vecA.y - vecB.y;\n\treturn vec;\n}\n\nfunction dotProduct2D(vecA,vecB){\n    var dot = vecA.x * vecB.x + vecA.y * vecB.y;\n    //console.log(dot);\n\treturn vecA.x * vecB.x + vecA.y * vecB.y;\n}\n\n/**\n * 外積\n * \n * @param vecA\n * @param vecB\n * @returns\n */\nfunction getCross(vecA,vecB){\n\treturn vecA.x * vecB.y - vecA.y * vecB.x;\n}\n\n/**\n * line segment\n * \n * point1:Vector2D point2:Vector2D\n */\nvar LineSegment2D = class LineSegment2D {\n\tconstructor(point1,point2){\n\t\tthis.point1 = point1;\n\t\tthis.point2 = point2;\n\t}\n}\n\nLineSegment2D.prototype.Init = function(point1,point2){\n\tthis.point1 = point1;\n\tthis.point2 = point2;\n}\n\nfunction onOneSide(axis,segment){\n\tvar d1 = new Vector2D();\n\td1 = subtractVector(segment.point1,axis.base);\n\n\tvar d2 = new Vector2D();\n\td2 = subtractVector(segment.point2,axis.base);\n\n\tvar n = new Vector2D();\n\tn = rotateVector90(axis.direction);\n\n\t// 同じ方向だということを返す\n\treturn dotProduct2D(n,d1) * dotProduct2D(n,d2) > 0;\n}\n\nfunction overLapping(minA,maxA,minB,maxB){\n\treturn minB <= maxA && minA <= maxB;\n}\n\nfunction isSegmentsCollide(segment1,segment2){\n\t// 線分の方向をチェックするためのベクトル\n\tvar axisA = new Line();\n\tvar axisB = new Line();\n\n\t// 線分1のベクトルに対して、線分2が片側にあるかチェック\n\taxisA.base = segment1.point1;\n\taxisA.direction = subtractVector(segment1.point2,segment1.point1);\n\n\tif(onOneSide(axisA,segment2)){\n\t\treturn false;\n\t}\n\n\t// 同じく\n\taxisB.base = segment2.point1;\n\taxisB.direction = subtractVector(segment2.point2,segment2.point1);\n\n\tif(onOneSide(axisB,segment1)){\n\t\treturn false;\n\t}\n\n\t// 同じベクトルをもつケース\n\tif(isParallelVector(axisA.direction,axisB.direction)){\n\t\tvar rangeA = getProjectSegment(segment1,axisA.direction);\n\t\tvar rangeB = getProjectSegment(segment2,axisA.direction);\n\n\t\t// 重なっているか\n\t\treturn isOverLappingRanges(rangeA,rangeB);\n\t}\n\telse{\n\t\treturn true;\n\t}\n}\n\n/*\n * Line Object\n */\nfunction Line(){\n\t// vector2D\n\tthis.base;\n\t// vector2D\n\tthis.direction\n}\n\nLine.prototype.Init = function(base,direction,color){\n\tthis.base = base;\n\tthis.direction = direction;\n}\n\n/**\n * Range\n */\nvar Range = class Range {\n\tconstructor(min,max){\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t}\n}\n\nfunction getMaxMinRange(range1,range2){\n\tvar range = new Range();\n\trange.min = range1.min < range2.min ? range1.min : range2.min;\n\trange.max = range1.max < range2.max ? range2.max : range1.max;\n\treturn range;\n}\n\nfunction getSortRange(range){\n\tvar sorted = new Range(range.min,range.max);\n\tif(range.min > range.max){\n\t\tsorted.min = range.max;\n\t\tsorted.max = range.min;\n\t}\n\treturn sorted;\n}\n\nfunction getNegateVector(vector){\n\tvector.x = -vector.x;\n\tvector.y = -vector.y;\n\treturn vector;\n}\n\nfunction getAddVector(vecA,vecB){\n\treturn new Vector2D(vecA.x + vecB.x,vecA.y + vecB.y);\n}\n\n/**\n * segment:segment onto:Vector2D\n * \n * return Range\n */\nfunction getProjectSegment(segment,onto){\n\tvar ontoUnitVec = getUnitVector(onto);\n\n\tvar range = new Range();\n\trange.min = dotProduct2D(ontoUnitVec,segment.point1);\n\trange.max = dotProduct2D(ontoUnitVec,segment.point2);\n\n\trange = getSortRange(range);\n\treturn range;\n}\n\nfunction isOverLappingRanges(range1,range2){\n\treturn overLapping(range1.min,range1.max,range2.min,range2.max);\n}\n\nfunction projectVector(project,onto){\n\tvar d = dotProduct2D(onto,onto);\n\tif(0 < d){\n\t    var dp = dotProduct2D(project,onto);\n\t    return multiplyVector(onto,dp / d);\n\t}\n\treturn onto;\n}\n\nfunction getNorm(vec){\n\treturn vec.x * vec.x + vec.y * vec.y;\n}\n\nfunction getVec2DLength(vec){\n\treturn Math.sqrt(getNorm(vec));\n}\n\n\n/**\n * point class\n */\nvar Point2D = class Point2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n}\n\nfunction addPoint(point1,point2){\n\treturn new Point2D(point1.x + point2.x,point1.y + point2.y);\n}\n\nfunction subtractPoint(point1,point2){\n\treturn new Point2D(point1.x - point2.x,point1.y - point2.y);\n}\n\nfunction multiplyPoint(point,scalar){\n\treturn new Point2D(point.x * scalar,point.y * scalar);\n}\n\n/**\n * segment : LineSegment2D\n * point : Point\n */\nfunction getProjectPoint(segment,point){\n\tvar vec1 = new Vector2D(segment.point2.x - segment.point1.x,segment.point2.y - segment.point1.y);\n\tvar vec2 = new Vector2D(point.x - segment.point1.x,point.y - segment.point1.y);\n\tvar rate = dotProduct2D(vec2,vec1) / getNorm(vec1);\n\tvar vec3 = multiplyVector(vec1,rate);\n\tvar project = new Point2D(segment.point1.x + vec3.x,segment.point1.y + vec3.y);\n\treturn project; \n}\n\nfunction getReflectionPoint(segment,point){\n\tvar projection = getProjectPoint(segment,point);\n\t// pから射影点までのベクトル\n\tvar vec = subtractPoint(projection,point);\n\t// 2倍したものが射影点になる\n\tvar refrectionPoint = multiplyPoint(vec,2);\n\t// 始点を足す\n\treturn addPoint(refrectionPoint,point);\n}\n\n/**\n * \n * @param segment1\n * @param segment2\n * @returns point\n */\nfunction getCrossPoint(segment1,segment2){\n\t// 基準となる線を決める\n\tvar baseVector = new Vector2D(segment2.point2.x - segment2.point1.x,segment2.point2.y - segment2.point1.y);\n\tvar d1Vec = new Vector2D(segment1.point1.x - segment2.point1.x,segment1.point1.y - segment2.point1.y);\n\tvar d2Vec = new Vector2D(segment1.point2.x - segment2.point1.x,segment1.point2.y - segment2.point1.y);\n\tvar d1 = Math.abs(getCross(baseVector,d1Vec));\n\tvar d2 = Math.abs(getCross(baseVector,d2Vec));\n\tvar t = d1 / (d1 + d2);\n\tvar x = segment1.point1.x + (segment1.point2.x - segment1.point1.x) * t;\n\tvar y = segment1.point1.y + (segment1.point2.y - segment1.point1.y) * t;\n\treturn new Point2D(x,y);\n}\n\nfunction multiplyVector(vec,scalar){\n\tvar temp = new Vector2D();\n\ttemp.x = vec.x * scalar;\n\ttemp.y = vec.y * scalar;\n\treturn temp;\n}\n\nfunction clampOnRange(x,min,max){\n\tif(x < min){\n\t\treturn min;\n\t}else if(x > max){\n\t\treturn max;\n\t}else{\n\t\treturn x;\n\t}\n}\n\n/**\n * 直線と点との距離\n */\nfunction getDistanceLinePoint(line,point){\n\tvar vec1 = new Vector2D(line.point2.x - line.point1.x,line.point2.y - line.point1.y);\n\tvar vec2 = new Vector2D(point.x - line.point1.x,point.y - line.point1.y);\n\treturn Math.abs(getCross(vec1,vec2) / getVec2DLength(vec1)); \n}\n\n/**\n * 線分と点との距離を求める\n */\nfunction getDistanceSegmentPoint(segment,point){    \n\t// ベクトルp2 - p1とベクトルp - p1がなす角θが90どより大きい場合(-90より小さい場合)\n\t// dは点pと点p1の距離になる\n\tif(dotProduct2D(subtractPoint(segment.point2,segment.point1),subtractPoint(point,segment.point1)) < 0){\n\t\treturn getVec2DLength(subtractPoint(point,segment.point1));\n\t}\n\t// ベクトルp1 - p2とベクトルp - p2がなす角θが90どより大きい場合(-90より小さい場合)\n\t// dは点pと点p2の距離になる\n\tif(dotProduct2D(subtractPoint(segment.point1,segment.point2),subtractPoint(point,segment.point2)) < 0){\n\t\treturn getVec2DLength(subtractPoint(point,segment.point2));\n\t}\n\t// それ以外はdは点pと直線p1p2の距離になる\n\treturn getDistanceLinePoint(segment,point);\n}\n\n/**\n * 線分と線分との距離を求める\n */\nfunction getSegmentDistance(segment1,segment2){\n\t// 交差していた場合距離は0になる\n\tif(isSegmentsCollide(segment1,segment2)){\n\t\treturn 0;\n\t}\n\treturn Math.min(Math.min(getDistanceSegmentPoint(segment1,segment2.point1),getDistanceSegmentPoint(segment1,segment2.point2)),\n\t\t\tMath.min(getDistanceSegmentPoint(segment2,segment1.point1),getDistanceSegmentPoint(segment2,segment1.point2)));\n}\n\nfunction ccw(point1,point2,point3){\n    var vec1 = new Vector2D(point2.x - point1.x,point2.y - point1.y);\n    var vec2 = new Vector2D(point3.x - point1.x,point3.y - point1.y);\n    var cross = getCross(vec1,vec2);\n\n    if(cross > Number.EPSILON){\n        return COUNTER_CLOCKWISE;\n    }\n    if(cross < -Number.EPSILON){\n        return CLOCKWISE;\n    }\n    if(dotProduct2D(vec1,vec2) < -Number.EPSILON){\n        return ONLINE_BACK;\n    }\n    if(getVectorLength2D(vec1) < getVectorLength2D(vec2)){\n        return ONLINE_FRONT;\n    }\n    return ON_SEGMENT;\n}\n\n/**\n * アンドリューでconvex hollを返す \n*/\nfunction getConvexHoll(points){\n    if(points.length < 3){\n        points.reverse();\n        return points;\n    }\n    \n    // xを基準に昇順にソート、数値が同じものはyが小さいもの基準にソート \n    points.sort((a, b) => (a.x > b.x) ? 1 : (a.x == b.x) ? ((a.y > b.y) ? 1 : -1) : -1);\n    // xを小さいほうから2つ\n    var u = [];\n    u.push(points[0]);\n    u.push(points[1]);\n    // xを大きい方から2つ\n    var l = [];\n    l.push(points[points.length - 1]);\n    l.push(points[points.length - 2]);\n    \n    // 上部の生成\n    for(var i = 2;i < points.length;++i){\n    \t// 対象が半時計なら削除する\n        for(var j = u.length;j >= 2 && ccw(u[j - 2],u[j - 1],points[i]) == COUNTER_CLOCKWISE;--j){\n            u.pop();\n        }\n        u.push(points[i]);\n    }\n    // 下部の生成\n    for(var i = points.length - 3;i >= 0;--i){\n    \t// 対象が半時計なら削除する\n        for(var j = l.length;j >= 2 && ccw(l[j - 2],l[j - 1],points[i]) == COUNTER_CLOCKWISE;--j){\n            l.pop();\n        }\n        l.push(points[i]);\n    }\n    // 時計回りに凸包の点の列を生成\n    l.reverse();\n    for(var i = u.length - 2;i >= 1;--i){\n        l.push(u[i]);\n    }\n    return l;\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\n//var input = require('fs').readFileSync('input.txt', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\t\n\nwhile(1){\n    //console.log(Arr);\n    var n = Arr[0];\n    if(n == 0){\n        break;\n    }\n    var points = [];\n    // 消す\n    Arr.shift();\n    // 多角形の点を記録する\n    for(var i = 0;i < n;++i){\n        var nums = Arr[0].split(\",\").map(Number);\n        points[i] = new Point2D(nums[0],nums[1]);\n        Arr.shift();\n    }\n    points = getConvexHoll(points);\n    console.log(n - points.length)\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  include Comparable\n  attr_accessor :x, :y\n  def initialize(x=0.0, y=0.0)\n    @x, @y = x, y\n  end\n  def <=>(p)\n    @y != p.y ? @y <=> p.y : @x <=> p.x\n  end\n  def +(p)\n    Point.new(@x+p.x, @y+p.y)\n  end\n  def -(p)\n    Point.new(@x-p.x, @y-p.y)\n  end\n  def -@\n    Point.new(-@x, -@y)\n  end\n  def angle\n    a = Math::atan2(@y, @x)\n  end\nend\n\nwhile (n = gets.to_i) != 0 do\n  point = Array.new\n  n.times do\n    point.push(Point.new(*(gets.split(\",\").map(&:to_f))))\n  end\n  point.sort!\n\n  convexHull = Array.new\n  convexHull.push(point.first)\n  convexHull.push(point.drop(1).min_by{|p| (p-point.first).angle})\n  while true do\n    origin = convexHull.last\n    base = (convexHull[-1] - convexHull[-2]).angle\n    add = nil\n    min = 2.0 * Math::PI\n    point.each do |p|\n      next if origin == p\n      angle = (p-origin).angle - base\n      angle += 2.0 * Math::PI if angle < 0.0\n      next if min <= angle\n      min = angle\n      add = p\n    end\n    break if convexHull.first == add\n    convexHull.push(add)\n  end\n  p n - convexHull.size\nend"
  },
  {
    "language": "Ruby",
    "code": "include Math\n\nuntil (n = $<.gets.to_i).zero?\n  points = Array.new(n) { Complex(*$<.gets.split(\",\").map(&:to_f))  }\n  ym = points.map(&:imaginary).max\n  start_po = po0 = points.find {|po| po.imaginary == ym}\n  prev_arg = PI\n  \n  result = loop do\n    points = (points - [start_po] + [po0]).uniq\n    selected = points.map.with_index {|po, i| [po - start_po, po]}\n      .reject {|pos| pos.first == 0}\n      .sort_by {|pos| a = pos.first.angle + PI - prev_arg; a >= 0 ? a : a + 2 * PI}\n      .first.last\n    points.select! {|po| po != start_po}\n    if selected == po0\n      break points.size - 1\n    else\n      prev_arg = (selected - start_po).angle + PI\n      start_po = selected\n    end\n  end\n  \n  puts result\nend\n"
  },
  {
    "language": "Ruby",
    "code": "while n = gets.to_i\n  break if n == 0\n  arr = []\n  n.times{|i|\n    arr << gets.split(\",\").map(&:to_f)\n  }\n  arr.sort!\n  max = []\n  min = []\n  n.times{|i|\n    (i+1).upto(n-1){|j|\n      del = (arr[j][1] - arr[i][1]) / (arr[j][0] - arr[i][0])\n      max[i] ||= [del, j]\n      min[i] ||= [del, j]\n      max[i] = [del, j] if max[i][0] < del\n      min[i] = [del, j] if min[i][0] > del\n    }\n  }\n  used = [0]\n  i = 0\n  loop do\n    i = max[i][1]\n    used << i\n    break if i == n - 1\n  end\n  i = 0\n  loop do\n    i = min[i][1]\n    break if i == n - 1\n    used << i\n  end\n  p n - used.size\nend"
  },
  {
    "language": "Ruby",
    "code": "pi2 = Math::PI * 2\n\nwhile true\n  n = gets.chomp.to_i\n  break if n == 0\n\n  pts = []\n  n.times do\n    pts.push gets.chomp.split(\",\").map{|s| s.to_f}\n  end\n  pts.sort!{|a, b| b[0] <=> a[0] || b[1] <=> a[1]}\n  #p pts\n\n  used = pts.map{false}\n\n  id0 = 0\n  id1 = 0\n  pt0 = [pts[id0][0], pts[id0][1] - 1]\n  pt1 = pts[id1]\n  used[id1] = true\n  #p [id1, pts[id1]]\n\n  while true\n    v0x = pt1[0] - pt0[0]\n    v0y = pt1[1] - pt0[1]\n    th0 = Math.atan2(v0y, v0x)\n    #p [v0x, v0y, th0]\n\n    npt = (0...pts.length).select{|i| i != id1}.map{|i|\n      vx = pts[i][0] - pt1[0]\n      vy = pts[i][1] - pt1[1]\n      th = Math.atan2(vy, vx) - th0\n\n      while th < 0\n        th += pi2\n      end\n      while th > pi2\n        th -= pi2\n      end\n\n      #p [i, vx, vy, th]\n      [i, th]\n    }.min{|a, b| a[1] <=> b[1]}\n\n    break if npt[0] == 0\n\n    pt0 = pt1\n    id0 = id1\n\n    id1 = npt[0]\n    pt1 = pts[id1]\n    used[id1] = true\n\n    #p [id1, pt1]\n  end\n  #p used\n\n  puts used.select{|t| ! t}.length\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  n = gets.to_i\n  break if n.zero?\n  ps = n.times.map { x, y = gets.split(?,).map(&:to_f); x + y * 1i }\n  p0 = ps.min_by(&:imag)\n  p, u, c = p0, 1, 1\n  loop do\n    q = ps.reject {|q| p == q }.min_by {|q|\n      v = q - p\n      (v / u).arg\n    }\n    break if q == p0\n    c += 1\n    u = q - p\n    u /= u.abs\n    p = q\n  end\n  p ps.size - c\nend"
  },
  {
    "language": "Ruby",
    "code": "include Math\n\nuntil (n = $<.gets.to_i).zero?\n  points = Array.new(n) { Complex(*$<.gets.split(\",\").map(&:to_f))  }\n  ym = points.map(&:imaginary).max\n  start_po = po0 = points.find {|po| po.imaginary == ym}\n  prev_arg = PI\n  result = loop do\n    points = (points - [start_po] + [po0]).uniq\n    idx = points.map.with_index {|po, i| [po - start_po, i]}\n      .reject {|pos| pos.first == 0}\n      .sort_by {|pos| a = pos.first.angle + PI - prev_arg; a >= 0 ? a : a + 2 * PI}\n      .first.last\n    selected = points[idx]\n    points.select! {|po| po != start_po}\n    if selected == po0\n      break points.size - 1\n    else\n      prev_arg = (selected - start_po).angle + PI\n      start_po = selected\n    end\n  end\n  puts result\nend\n"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  n = gets.to_i\n  break if n==0\n  a,b,c,*dots = n.times.map{|i| gets.split(\",\").map(&:to_f)}\n  d = [a,b,c]\n  cnt = 0\n  dots.each do |v|\n    d << v\n    d.permutation(4) do |w1,w2,w3,w4|\n      v0 = [w2[0]-w1[0], w2[1]-w1[0]]\n      v1 = [w3[0]-w1[0], w3[1]-w1[0]]\n      v2 = [w4[0]-w1[0], w4[1]-w1[0]]\n      t = (v0[0]*v2[1]-v2[0]*v0[1])/(v1[0]*v2[1]-v2[0]*v1[1])\n      u = (v0[0]*v1[1]-v1[0]*v0[1])/(v2[0]*v1[1]-v1[0]*v2[1])\n      if t>0 && u>0 && t+u<=1\n        d.delete(w2)\n        cnt += 1\n        break\n      end\n    end\n  end\n  puts cnt\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  n = gets.to_i\n  break if n==0\n  a,b,c,*dots = n.times.map{|i| gets.split(\",\").map(&:to_f)}\n  d = [a,b,c]\n  cnt = 0\n  dots.each do |v|\n    d << v\n    d.permutation(4) do |w1,w2,w3,w4|\n      v0 = [w2[0]-w1[0], w2[1]-w1[1]]\n      v1 = [w3[0]-w1[0], w3[1]-w1[1]]\n      v2 = [w4[0]-w1[0], w4[1]-w1[1]]\n      t = (v0[0]*v2[1]-v2[0]*v0[1])/(v1[0]*v2[1]-v2[0]*v1[1])\n      u = (v0[0]*v1[1]-v1[0]*v0[1])/(v2[0]*v1[1]-v1[0]*v2[1])\n      if t>0 && u>0 && t+u<=1\n        d.delete(w2)\n        cnt += 1\n        break\n      end\n    end\n  end\n  puts cnt\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\n# -*- coding:utf-8 -*-\n\nmodule Geometry\n  EPS = 1e-6\n  class Point\n    attr_accessor :x, :y\n    \n    def initialize(x = 0.0, y = 0.0)\n      @x = x\n      @y = y\n    end\n  \n    def abs()\n      return Math.sqrt(x*x + y*y)\n    end\n    \n    def dot(p)\n      return x * p.x + y * p.y\n    end\n    \n    def cross(p)\n      return x * p.y - y * p.x\n    end\n  \n    def norm()\n      return x*x + y*y\n    end\n    \n    def -(p)\n      return Point.new(x-p.x,y-p.y)\n    end \n  end\n  \n  def ccw(a,b,c)\n    b-=a\n    c-=a\n    return +1 if b.cross(c) > EPS\n    return -1 if b.cross(c) < -EPS\n    return +2 if b.dot(c) < -EPS\n    return -2 if b.norm() < c.norm()\n    return 0\n  end\n\n  def convex_hull(ps)\n    n, k = ps.length(), 0\n    ps.sort!{|a,b| \n              if a.x != b.x\n                a.y <=> b.y\n              else\n                a.x <=> b.x\n              end\n            }\n    ch = Array.new(n * 2)\n    i = 0\n    while i < n\n      k -= 1 while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)\n      ch[k] = ps[i]\n      k, i = k + 1, i + 1\n    end\n    i,t = n - 2,k + 1\n    while i >= 0\n      k -= 1 while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)\n      ch[k] = ps [i]\n      k, i = k + 1, i - 1\n    end\n    ch = ch[0...(k-1)]\n    return ch\n  end\nend\n\ninclude Geometry\n\nn = 0\nwhile (n = gets.to_i) > 0\n  pts = []\n  n.times do \n    x ,y = gets.split(',').map(&:to_f)\n    pts.push(Point.new(x,y))\n  end\n  puts n - convex_hull(pts).size\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  n = gets.to_i\n  break if n.zero?\n  ps = n.times.map { x, y = gets.split(?,).map(&:to_f); x + y * 1i }\n  p0 = ps.min_by(&:imag)\n  p, u, c = p0, 1, 1\n  loop do\n    q = ps.reject {|q| p == q }.min_by {|q|\n      v = q - p\n      (v * u).arg\n    }\n    break if q == p0\n    c += 1\n    u = q - p\n    u /= u.abs\n    u = 1 / u\n    p = q\n  end\n  p ps.size - c\nend"
  },
  {
    "language": "Ruby",
    "code": "def getCross point, prepre, pre, current\n  (point[pre][0] - point[prepre][0]) * (point[current][1] - point[prepre][1]) - (point[pre][1] - point[prepre][1]) * (point[current][0] - point[prepre][0])\nend\n\n#３点の作る折れ線の回転方向を判定する\ndef areLeft point, upper\n  cross = getCross(point, upper[upper.size - 3], upper[upper.size - 2], upper[upper.size - 1])\n  (cross >= 0)? true : false \nend\n\n#凸包生成\ndef convexHull point\n  return point if point.size == 3\n\n  #上側は左端から\n  upper = [0, 1]\n  2.upto(point.size - 1) do |i|\n    upper << i\n    while upper.size >= 3 && areLeft(point, upper)\n      upper.delete_at(upper.size - 2)\n    end\n  end\n\n  #下側は右端から\n  lower = [point.size - 1, point.size - 2]\n  (point.size - 3).downto(0) do |i|\n    lower << i\n    while lower.size >= 3 && areLeft(point, lower)\n      lower.delete_at(lower.size - 2)\n    end\n  end\n\n  #左端と右端の重複を排除\n  upper.pop\n  lower.pop\n\n  hull = upper + lower\nend\n\nuntil (n = $stdin.gets.to_i) == 0\n  point = Array.new\n  n.times do\n    point << $stdin.gets.chomp.split(\",\").map(&:to_f)\n  end\n  #事前準備としてx軸について座標をソート。x同軸についてはy軸ソート\n  point.sort!{|a,b| \n    if a[0] == b[0]\n      a[1] <=> b[1]\n    else\n      a[0] <=> b[0]\n  end}\n\n  p point.size - convexHull(point).size\nend"
  },
  {
    "language": "Ruby",
    "code": "def a(x1,y1,x2,y2,xp,yp)\n    (x2-x1)*(yp-y1) - (y2-y1)*(xp-x1)\nend\ndef in?(x1,y1,x2,y2,x3,y3,xp,yp)\n    res = true\n    res &= a(x1,y1,x2,y2,xp,yp) * a(x1,y1,x2,y2,x3,y3) > 0\n    res &= a(x1,y1,x3,y3,xp,yp) * a(x1,y1,x3,y3,x2,y2) > 0\n    res &= a(x3,y3,x2,y2,xp,yp) * a(x3,y3,x2,y2,x1,y1) > 0\n    res\nend\n\nuntil (n = gets.chomp.to_i) == 0\n    p = []\n    n.times do\n        p << gets.chomp.split(',').map(&:to_f)\n    end\n\n    minmax = p.minmax{|a,b| a[0] <=> b[0]}\n    min = p.select{|x|x[0] == minmax[0][0]}\n    max = p.select{|x|x[0] == minmax[1][0]}\n    array = p\n    min.each do |x| array -= x end\n    max.each do |x| array -= x end\n    min.each do |mn|\n        max.each do |mx|\n            array.size.times do |i|\n                array.size.times do |j|\n                    next if i==j\n                    next if array[i]==nil || array[j]==nil\n                    array[j] = nil if in?(mn[0],mn[1],mx[0],mx[1],array[i][0],array[i][1],array[j][0],array[j][1])\n                end\n            end\n        end\n    end\n    puts array.select{|x| x==nil}.size\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\n# -*- coding:utf-8 -*-\n\nmodule Geometry\n  EPS = 1e-6\n  class Point\n    attr_accessor :x, :y\n    \n    def initialize(x = 0.0, y = 0.0)\n      @x = x\n      @y = y\n    end\n  \n    def abs()\n      return Math.sqrt(x*x + y*y)\n    end\n    \n    def dot(p)\n      return x * p.x + y * p.y\n    end\n    \n    def cross(p)\n      return x * p.y - y * p.x\n    end\n  \n    def norm()\n      return x*x + y*y\n    end\n    \n    def -(p)\n      return Point.new(x-p.x,y-p.y)\n    end \n  end\n  \n  def ccw(a,b,c)\n    b-=a\n    c-=a\n    return +1 if b.cross(c) > EPS\n    return -1 if b.cross(c) < -EPS\n    return +2 if b.dot(c) < 0 \n    return -2 if b.norm() < c.norm()\n    return 0\n  end\n\n  def convex_hull(ps)\n    n, k = ps.length(), 0\n    ps.sort!{|a,b| \n              if a.x == b.x\n                a.y <=> b.y\n              else\n                a.x <=> b.x\n              end\n            }\n    ch = Array.new(n * 2)\n    i = 0\n    while i < n\n      k -= 1 while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)\n      ch[k] = ps[i]\n      k, i = k + 1, i + 1\n    end\n    i,t = n - 2,k + 1\n    while i >= 0\n      k -= 1 while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0)\n      ch[k] = ps [i]\n      k, i = k + 1, i - 1\n    end\n    ch = ch[0...(k-1)]\n    return ch\n  end\nend\n\ninclude Geometry\n\nn = 0\nwhile (n = gets.to_i) > 0\n  pts = []\n  n.times do \n    x ,y = gets.split(',').map(&:to_f)\n    pts.push(Point.new(x,y))\n  end\n  puts n - convex_hull(pts).size\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  n = gets.to_i\n  break if n.zero?\n  ps = n.times.map { x, y = gets.split(?,).map(&:to_f); x + y * 1i }\n  p0 = ps.min_by(&:imag)\n  p, u, c = p0, 1, 1\n  loop do\n    q = ps.reject {|q| p == q }.min_by {|q|\n      v = q - p\n      a = (v / u).arg\n      a < 0 ? 2 * Math::PI + a : a\n    }\n    break if q == p0\n    c += 1\n    u = q - p\n    u /= u.abs\n    p = q\n  end\n  p ps.size - c\nend"
  },
  {
    "language": "Ruby",
    "code": "def a(x1,y1,x2,y2,xp,yp)\n    (x2-x1)*(yp-y1) - (y2-y1)*(xp-x1)\nend\ndef in?(x1,y1,x2,y2,x3,y3,xp,yp)\n    res = true\n    res &= a(x1,y1,x2,y2,xp,yp) * a(x1,y1,x2,y2,x3,y3) > 0\n    res &= a(x1,y1,x3,y3,xp,yp) * a(x1,y1,x3,y3,x2,y2) > 0\n    res &= a(x3,y3,x2,y2,xp,yp) * a(x3,y3,x2,y2,x1,y1) > 0\n    res\nend\n\nuntil (n = gets.chomp.to_i) == 0\n    p = []\n    n.times do\n        p << gets.chomp.split(',').map(&:to_f)\n    end\n\n    min,max =  p.minmax{|a,b| a[0] <=> b[0]}\n    array = (p - min - max)\n    array.size.times do |i|\n        array.size.times do |j|\n            next if i==j\n            next if array[i]==nil || array[j]==nil\n            array[j] = nil if in?(min[0],min[1],max[0],max[1],array[i][0],array[i][1],array[j][0],array[j][1])\n        end\n    end\n    puts array.select{|x| x==nil}.size\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  n = gets.to_i\n  break if n==0\n  a,b,c,*dots = n.times.map{|i| gets.split(\",\").map(&:to_f)}\n  d = [a,b,c]\n  cnt = 0\n  dots.each do |v|\n    d << v\n    d.permutation(4).any? do |w1,w2,w3,w4|\n      v0 = [w2[0]-w1[0], w2[1]-w1[0]]\n      v1 = [w3[0]-w1[0], w3[1]-w1[0]]\n      v2 = [w4[0]-w1[0], w4[1]-w1[0]]\n      t = (v0[0]*v2[1]-v2[0]*v0[1])/(v1[0]*v2[1]-v2[0]*v1[1])\n      u = (v0[0]*v1[1]-v1[0]*v0[1])/(v2[0]*v1[1]-v1[0]*v2[1])\n      if t>0 && u>0 && t+u<1\n        d.delete(w2)\n        cnt += 1\n        break\n      end\n    end\n  end\n  puts cnt\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  n = gets.to_i\n  break if n==0\n  a,b,c,*dots = n.times.map{|i| gets.split(\",\").map(&:to_f)}\n  d = [a,b,c]\n  cnt = 0\n  dots.each do |v|\n    d << v\n    d.permutation(4) do |w1,w2,w3,w4|\n      v0 = [w2[0]-w1[0], w2[1]-w1[0]]\n      v1 = [w3[0]-w1[0], w3[1]-w1[0]]\n      v2 = [w4[0]-w1[0], w4[1]-w1[0]]\n      t = (v0[0]*v2[1]-v2[0]*v0[1])/(v1[0]*v2[1]-v2[0]*v1[1])\n      u = (v0[0]*v1[1]-v1[0]*v0[1])/(v2[0]*v1[1]-v1[0]*v2[1])\n      if t>0 && u>0 && t+u<1\n        d.delete(w2)\n        cnt += 1\n        break\n      end\n    end\n  end\n  puts cnt\nend"
  },
  {
    "language": "Ruby",
    "code": "include Math\n\nuntil (n = $<.gets.to_i).zero?\n  points = Array.new(n) { Complex(*$<.gets.split(\",\").map(&:to_f))  }\n  ym = points.map(&:imaginary).max\n  start_po = po0 = points.find {|po| po.imaginary == ym}\n  prev_arg = PI\n  \n  result = loop do\n    points = (points - [start_po] + [po0]).uniq\n    selected = points.map {|po| [po - start_po, po]}\n      .reject {|pos| pos.first == 0}\n      .sort_by {|pos| a = pos.first.angle + PI - prev_arg; a >= 0 ? a : a + 2 * PI}\n      .first.last\n    points.select! {|po| po != start_po}\n    if selected == po0\n      break points.size - 1\n    else\n      prev_arg = (selected - start_po).angle + PI\n      start_po = selected\n    end\n  end\n  \n  puts result\nend\n"
  },
  {
    "language": "Ruby",
    "code": "# GrahamScan\nmodule GrahamScan\n  def self.calc(data)\n    points = data.map do |data|\n      Point.new(data)\n    end\n\n    # sort by lower y-cordinate\n    points.sort! do |a, b|\n      if a.y == b.y\n        a.x <=> b.x\n      else\n        a.y <=> b.y\n      end\n    end\n\n    # sort by polar angle with respect to base of points[0]\n    points[1...points.size] = points[1...points.size].sort! do |a, b|\n      -ccw(points[0], a, b)\n    end\n\n    hull = []\n    hull << points[0]\n    hull << points[1]\n    hull << points[2]\n\n    for i in 3...points.size\n      top = hull.pop\n\n      while ccw(hull.last, top, points[i]) != 1\n        top = hull.pop\n      end\n      hull << top\n      hull << points[i]\n    end\n\n    hull\n  end\n\n  def self.ccw(p1, p2, p3)\n    dx1 = p2.x - p1.x\n    dy1 = p2.y - p1.y\n    dx2 = p3.x - p1.x\n    dy2 = p3.y - p1.y\n\n    cross_product = dx1 * dy2 - dy1 * dx2\n\n    if cross_product < 0\n      return -1\n    elsif cross_product > 0\n      return 1\n    else\n      return 0\n    end\n  end\n\n  # Point\n  class Point\n    attr_reader :x, :y\n\n    def initialize(data)\n      @x, @y = data\n    end\n  end\nend\n\nwhile line = gets\n  n = line.chomp.to_i\n  break if n == 0\n\n  data = []\n  n.times do\n    data << gets.chomp.split(',').map(&:to_f)\n  end\n\n  hull = GrahamScan.calc(data)\n  puts n - hull.size\nend"
  },
  {
    "language": "OCaml",
    "code": "module Vector =\n  struct\n    type t = { x: float; y: float }\n    let eps = 1e-10\n    let init x y = {x = x; y = y}\n    let add v1 v2 = {x = v1.x +. v2.x; y = v1.y +. v2.y}\n    let sub v1 v2 = {x = v1.x -. v2.x; y = v1.y -. v2.y}\n    let mul v a = {x = v.x *. a; y = v.y *. a}\n    let div v a = {x = v.x /. a; y = v.y /. a}\n    let norm v = v.x *. v.x +. v.y *. v.y\n    let abs v = sqrt (norm v)\n    let dot v1 v2 = v1.x *. v2.x +. v1.y *. v2.y\n    let cross v1 v2 = v1.x *. v2.y -. v1.y *. v2.x\n    type ccw_t = Ccw | Cw | Ob | Of | Os\n    let ccw p0 p1 p2 =\n      let v0 = sub p1 p0\n      and v1 = sub p2 p0 in\n      if cross v0 v1 > eps then Ccw\n      else if cross v0 v1 < (-1.0) *. eps then Cw\n      else if dot v0 v1 < (-1.0) *. eps then Ob\n      else if (norm v0) < (norm v1) then Of\n      else Os\n  end\n\nlet id x = x\n\nlet rec read n = if n <= 0 then [] else let z = Scanf.scanf \"%f,%f\\n\" (fun x y -> Vector.init x y) in z :: read (n - 1)\n\nlet rec convex clst rlst = \n  match (clst, rlst) with\n  | ([], _) -> rlst\n  | (c :: crest, []) -> convex crest [c]\n  | (c :: crest, [r]) -> convex crest [c;r]\n  | (c :: crest, r1 :: r2 :: rrest) -> if Vector.ccw r2 r1 c = Vector.Cw then convex crest (c :: rlst)\n                                       else convex clst (r2 :: rrest)\n\nlet solve lst =\n  let slst = List.sort compare lst in\n  let rslst = List.rev slst in\n  let ul = convex slst [] in\n  let ll = convex rslst [] in\n  (List.length lst) - (List.length ul) - (List.length ll) + 2\n\nlet _ = \n  let rec loop () = \n    let n = Scanf.scanf \"%d\\n\" id in\n    if n = 0 then ()\n    else\n      begin\n        let xy = read n in\n        Printf.printf \"%d\\n\" @@ solve xy;\n        loop ()\n      end\n  in loop ()"
  },
  {
    "language": "D",
    "code": "\nimport std.stdio;\nimport std.typecons;\nimport std.algorithm;\nimport std.conv;\nimport std.math;\nimport std.string;\nimport std.array;\n\n// 最大抱合を求める問題\n// グラハムスキャンを用いて解く\n// アルゴリズム: http://en.wikipedia.org/wiki/Graham_scan\n\nstruct Point {\n  double x, y;\n  double dot(Point a) {return x * a.x + y * a.y;}\n  double cross(Point a) {return x * a.y - y * a.x;}\n  Point opBinary(string s)(Point p) if (s == \"+\") {p.x += x; p.y += y; return p;}\n  Point opBinary(string s)(Point p) if (s == \"-\") {\n    p.x = x - p.x;\n    p.y = y - p.y;\n    return p;\n  }\n}\n\n// CCW, 3 点の外積を求める\n// X1 x X2 == 0  ... X1, X2 は並行\n// X1 x X2 > 0   ... X1, X2 は反時計周り\n// X1 x X2 < 0   ... X1, X2 は時計周り\n// (-1) * (BA x BC) = (-1) * (X1 - X2) x (X3 - X2)\n\n// ccw > 0 ... 時計周り, ccw < 0 反時計周り\ndouble ccw(Point p1, Point p2, Point p3) {\n  return - (p1.x - p2.x) * (p3.y - p1.y) + (p1.y - p2.y) * (p3.x - p1.x);\n}\n\n// 最大抱合を求める\nPoint[] max_convex_full(Point[] points) {\n  Point[] res = new Point[](points.length);\n  sort!((a, b) {\n      if (a.x != b.x) return a.x < b.x;\n      return a.y < b.y;\n    })(points);\n  uint k = 0;\n  // 下側凸部を作る\n  for(int i = 0; i < points.length; i++) {\n    while(k > 1 && ccw(points[k - 1], points[k - 2], points[i]) <= 0) k--;\n    res[k++] = points[i];\n  }\n  // 上側凸部を作る\n  for(int i = cast(int)points.length - 2, t = k; i >= 0; i--) {\n    while(k > t && ccw(points[k - 1], points[k - 2], points[i]) <= 0) k--;\n    res[k++] = points[i];\n  }\n  res.length = k;\n  return res;\n}\n\nvoid main() {\n  while(true) {\n    int n = readln.chomp.to!(int);\n    if (n == 0) break;\n    Point[] points;\n    foreach(t; 0..n) {\n      auto line = readln.chomp.split(\",\").map!(to!(double)).array;\n      points ~= Point(line[0], line[1]);\n    }\n    (points.length - points.max_convex_full.length).writeln;\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.array, std.algorithm, std.range;\n\nalias real F;\nF cross(F[2] a, F[2] b){ return a[0]*b[1]-b[0]*a[1]; }\nF[2] sub(F[] a, F[] b){ return [a[0]-b[0],a[1]-b[1]]; }\n\nint solve(immutable int n)\n{\n    auto ps = iota(n).map!(_=>readln().chomp().split(\",\").map!(to!F).array()).array();\n    if(ps.length<=3) return 0;\n    ps.sort;\n    auto u=[ps[0]],b=u;\n    foreach(p;ps[1..$])\n    {\n        foreach_reverse(i;1..u.length) if(cross(sub(u[i-1],p),sub(u[i],p))<0) u.popBack();\n        u~=p;\n        foreach_reverse(i;1..b.length) if(cross(sub(b[i-1],p),sub(b[i],p))>0) b.popBack();\n        b~=p;\n    }\n    return cast(int)(n-(u~b).sort().uniq().array().length);\n}\n\nvoid main()\n{\n    for(int n; 0!=(n=readln().chomp().to!int()); )\n        writeln(solve(n));\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.math;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.geo.primitive, dcomp.geo.circle, dcomp.geo.polygon;\n\nbool solve() {\n    alias P = Point2D!double;\n    alias L = Line2D!double;\n    alias C = Circre2D!double;\n    int n;\n    sc.read(n);\n    if (!n) return false;\n    P[] pol;\n    foreach (i; 0..n) {\n        string s;\n        sc.read(s);\n        auto l = s.split(\",\");\n        double x = l[0].to!double, y = l[1].to!double;\n        pol ~= P(x, y);\n    }\n    writeln(n - pol.convex.length);\n    return true;\n}\n\nint main() {\n    EPS!double = 1e-10;\n    while (solve()) {}\n    return 0;\n}\n\n\nScanner sc;\nstatic this() {\n    sc = new Scanner(stdin);\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    alias opDollar = length;\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/geo/polygon.d */\n// module dcomp.geo.polygon;\n\n// import dcomp.geo.primitive;\n\ninout(Point2D!R) at(R)(inout Point2D!R[] pol, size_t i) {\n    return pol[i<pol.length?i:i-pol.length];\n}\n\n \nint contains(R)(Point2D!R[] pol, Point2D!R p) {\n    import std.algorithm : swap;\n    int res = -1;\n    foreach (i; 0..pol.length) {\n        auto a = pol.at(i) - p, b = pol.at(i+1) - p;\n        if (ccw(a, b, Point2D!R(0, 0)) == 0) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y <= 0 && 0 < b.y) {\n            if (cross(a, b) < 0) res *= -1;\n        }\n    }\n    return res+1;\n}\n\n \n\nR area2(R)(Point2D!R[] pol) {\n    R u = 0;\n    foreach (i; 0..pol.length) {\n        auto a = pol.at(i), b = pol.at(i+1);\n        u += cross(a, b);\n    }\n    return u;\n}\n\n \n\n// import dcomp.array;\n\nPoint2D!R[] convex(R)(Point2D!R[] _pol) {\n    import std.algorithm : sort;\n    import std.range : retro, array;\n    auto pol = _pol.dup;\n    pol.sort!((a, b) => robustCmp(a, b) == -1);\n    if (pol.length <= 2) return pol;\n    FastAppender!(Point2D!R[]) up;\n    foreach (d; pol) {\n        while (up.length >= 2 && ccw(up[$-2], up[$-1], d) == 1) up.removeBack();\n        up ~= d;\n    }\n    FastAppender!(Point2D!R[]) down;\n    foreach (d; pol) {\n        while (down.length >= 2 && ccw(down[$-2], down[$-1], d) == -1) down.removeBack();\n        down ~= d;\n    }\n    return up.data.retro.array[1..$-1] ~ down.data();\n}\n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\nimport core.bitop : popcnt;\nstatic if (!__traits(compiles, popcnt(ulong.max))) {\n    public import core.bitop : popcnt;\n    int popcnt(ulong v) {\n        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));\n    }\n}\n\nbool poppar(ulong v) {\n    v^=v>>1;\n    v^=v>>2;\n    v&=0x1111111111111111UL;\n    v*=0x1111111111111111UL;\n    return ((v>>60) & 1) != 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/geo/circle.d */\n// module dcomp.geo.circle;\n\n// import dcomp.geo.primitive;\n\nstruct Circre2D(R) {\n    Point2D!R p;\n    R r;\n    this(Point2D!R p, R r) {\n        this.p = p;\n        this.r = r;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/geo/primitive.d */\n// module dcomp.geo.primitive;\n\nimport std.traits;\n\ntemplate EPS(R) {\n    R EPS;\n}\n\nint sgn(R)(R a) {\n    static if (isFloatingPoint!R) {\n        import std.math : isNaN;\n        assert(!isNaN(EPS!R));\n    }\n    if (a < -EPS!R) return -1;\n    if (a > EPS!R) return 1;\n    return 0;\n}\n\nstruct Point2D(T) {\n    T[2] d;\n    this(T x, T y) {this.d = [x, y];}\n    this(T[2] d) {this.d = d;}\n    @property ref inout(T) x() inout {return d[0];}\n    @property ref inout(T) y() inout {return d[1];}\n    ref inout(T) opIndex(size_t i) inout {return d[i];}\n    auto opOpAssign(string op)(in Point2D r) {\n        return mixin(\"this=this\"~op~\"r\");\n    }\n    auto opBinary(string op:\"+\")(in Point2D r) const {return Point2D(x+r.x, y+r.y);}\n    auto opBinary(string op:\"-\")(in Point2D r) const {return Point2D(x-r.x, y-r.y);}\n    static if (isFloatingPoint!T) {\n        T abs() {\n            import std.math : sqrt;\n            return (x*x+y*y).sqrt;\n        }\n        T arg() {\n            import std.math : atan2;\n            return atan2(y, x);\n        }\n        Point2D rot(T ar) {\n            import std.math : cos, sin;\n            auto cosAr = cos(ar), sinAr = sin(ar);\n            return Point2D(x*cosAr - y*sinAr, x*sinAr + y*cosAr);\n        }\n    }\n}\n\nint robustCmp(T)(Point2D!T a, Point2D!T b) {\n    if (sgn(a.x-b.x)) return sgn(a.x-b.x);\n    if (sgn(a.y-b.y)) return sgn(a.y-b.y);\n    return 0;\n}\n\nbool near(T)(Point2D!T a, Point2D!T b) if (isIntegral!T) {\n    return a == b;\n}\n\nbool near(T)(Point2D!T a, Point2D!T b) if (isFloatingPoint!T) {\n    return !sgn((a-b).abs);\n}\n\nT dot(T)(in Point2D!T l, in Point2D!T r) {\n    return l[0]*r[0] + l[1]*r[1];\n}\n\nT cross(T)(in Point2D!T l, in Point2D!T r) {\n    return l[0]*r[1] - l[1]*r[0];\n}\n\n\n \n\n\nint ccw(R)(Point2D!R a, Point2D!R b, Point2D!R c) {\n    import std.stdio;\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\n\nstruct Line2D(R) {\n    Point2D!R x, y;\n    this(Point2D!R x, Point2D!R y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point2D!R vec() const { return y-x; }\n}\n\nR distLP(R)(Line2D!R l, Point2D!R p) if (isFloatingPoint!R) {\n    import std.math : abs;\n    return abs(cross(l.vec, p-l.x) / l.vec.abs);\n}\nR distSP(R)(Line2D!R s, Point2D!R p) if (isFloatingPoint!R) {\n    import std.algorithm : min;\n    auto s2 = Point2D!R(-s.vec.y, s.vec.x);\n    if (ccw(s.x, s.x+s2, p) == 1) return (s.x-p).abs;\n    if (ccw(s.y, s.y+s2, p) == -1) return (s.y-p).abs;\n    return min((s.x-p).abs, (s.y-p).abs, distLP(s, p));\n}\n\n \n\n \n \nint argcmp(T)(Point2D!T l, Point2D!T r) if (isIntegral!T) {\n    int sgn(Point2D!T p) {\n        if (p[1] < 0) return -1;\n        if (p[1] > 0) return 1;\n        if (p[0] < 0) return 2;\n        return 0;\n    }\n    int lsgn = sgn(l);\n    int rsgn = sgn(r);\n    if (lsgn < rsgn) return -1;\n    if (lsgn > rsgn) return 1;\n\n    T x = cross(l, r);\n    if (x > 0) return -1;\n    if (x < 0) return 1;\n\n    return 0;\n}\n\n\n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/"
  },
  {
    "language": "D",
    "code": "\nimport std.stdio;\nimport std.typecons;\nimport std.algorithm;\nimport std.conv;\nimport std.math;\nimport std.string;\nimport std.array;\n\n// 最大抱合を求める問題\n// グラハムスキャンを用いて解く\n// アルゴリズム: http://en.wikipedia.org/wiki/Graham_scan\n\nstruct Point {\n  double x, y;\n  double dot(Point a) {return x * a.x + y * a.y;}\n  double cross(Point a) {return x * a.y - y * a.x;}\n  Point opBinary(string s)(Point p) if (s == \"+\") {p.x += x; p.y += y; return p;}\n  Point opBinary(string s)(Point p) if (s == \"-\") {\n    p.x = x - p.x;\n    p.y = y - p.y;\n    return p;\n  }\n}\n\n// CCW, 3 点の外積を求める\n// X1 x X2 == 0  ... X1, X2 は並行\n// X1 x X2 > 0   ... X1, X2 は反時計周り\n// X1 x X2 < 0   ... X1, X2 は時計周り\n// (-1) * (BA x BC) = (-1) * (X1 - X2) x (X3 - X2)\n\n// ccw > 0 ... 時計周り, ccw < 0 反時計周り\ndouble ccw(Point p1, Point p2, Point p3) {\n  return - (p1.x - p2.x) * (p3.y - p1.y) + (p1.y - p2.y) * (p3.x - p1.x);\n}\n\n// 最大抱合を求める\nPoint[] max_convex_full(Point[] points) {\n  Point[] res = new Point[](points.length * 2);\n  sort!((a, b) {\n      if (a.x != b.x)  return a.x < b.x;\n      return a.y < b.y;\n    })(points);\n  uint k = 0;\n  // 下部の凸部\n  for(int i = 0; i < points.length; i++) {\n    while(k >= 2 && ccw(res[k - 2], res[k - 1], points[i]) <= 0) k--;\n    res[k++] = points[i];\n  }\n  // 上部の凸部\n  for(int i = cast(int)points.length - 2, t = k + 1; i >= 0; i--) {\n    while(k >= t && ccw(res[k - 2], res[k - 1], points[i]) <= 0) k--;\n    res[k++] = points[i];\n  }\n  res.length = k - 1;\n  return res;\n}\n\nvoid main() {\n  while(true) {\n    int n = readln.chomp.to!(int);\n    if (n == 0) break;\n    Point[] points;\n    foreach(t; 0..n) {\n      auto line = readln.chomp.split(\",\").map!(to!(double)).array;\n      points ~= Point(line[0], line[1]);\n    }\n    (points.length - points.max_convex_full.length).writeln;\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.string,std.conv,std.array,std.algorithm;\n\nstruct Point\n{\n\tdouble x,y;\n\n\tthis(double a,double b)\n\t{\n\t\tthis.x = a;\n\t\tthis.y = b;\n\t}\n\n\tPoint opBinary(string s)(Point p) if(s == \"-\")\n\t{\n\t\tp.x = x - p.x;\n\t\tp.y = y - p.y;\n\t\treturn p;\n\t}\n\n\tdouble det(Point a)\n\t{\n\t\treturn this.x * a.y - this.y * a.x;\n\t}\n}\n\nPoint[] convex_hull(Point[] ps)\n{\n\tint n = ps.length;\n\tint k = 0;\n\n\n\tsort!((a, b) \n\t{\n\t\tif (a.x != b.x)  \n\t\t{\n\t\t\treturn a.x < b.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn a.y < b.y;\n\t\t}\n\t})(ps);\n\n\tPoint[] convex = new Point[n*2];\n\n\n\tforeach(i;0..n)\n\t{\n\t\twhile (2 <= k && (convex[k-1] - convex[k-2]).det(ps[i] - convex[k-1]) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\tconvex[k++] = ps[i];\n\t}\n\t\n\tfor(int i = n-2,t = k; 0 <= i;i--)\n\t{\n\t\twhile (t < k && (convex[k-1] - convex[k-2]).det(ps[i] - convex[k-1]) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.length = k - 1;\n\treturn convex;\n}\n\n\n\nint main()\n{\n\tint n;\n\twhile((n = readln.chomp.to!int) != 0)\n\t{\n\t\tPoint[] ps;\n\t\tps.length = n;\n\n\t\tforeach(i;0..n)\n\t\t{\n\t\t\tstring[] _s = readln.chomp.split(\",\");\n\t\t\tps[i].x = _s[0].to!double;\n\t\t\tps[i].y = _s[1].to!double;\n\t\t}\n\n\t\tPoint[] convex = convex_hull(ps);\n\t\twriteln(n - convex.length);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.string,std.conv,std.array,std.algorithm;\n\nstruct Point\n{\n\tdouble x,y;\n\n\tthis(double a,double b)\n\t{\n\t\tthis.x = a;\n\t\tthis.y = b;\n\t}\n\n\tPoint opBinary(string s)(Point p) if(s == \"-\")\n\t{\n\t\tp.x = x - p.x;\n\t\tp.y = y - p.y;\n\t\treturn p;\n\t}\n\n\tdouble det(Point a)\n\t{\n\t\treturn this.x * a.y - this.y * a.x;\n\t}\n}\n\nPoint[] convex_hull(Point[] ps)\n{\n\tint n = cast(int)ps.length;\n\tint k = 0;\n\n\n\tsort!((a, b) \n\t{\n\t\tif (a.x != b.x)  \n\t\t{\n\t\t\treturn a.x < b.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn a.y < b.y;\n\t\t}\n\t})(ps);\n\n\tPoint[] convex = new Point[n*2];\n\n\n\tforeach(i;0..n)\n\t{\n\t\twhile (2 <= k && (convex[k-1] - convex[k-2]).det(ps[i] - convex[k-1]) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\tconvex[k++] = ps[i];\n\t}\n\t\n\tfor(int i = n-2,t = k; 0 <= i;i--)\n\t{\n\t\twhile (t < k && (convex[k-1] - convex[k-2]).det(ps[i] - convex[k-1]) <= 0 )\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\tconvex[ k++ ] = ps[i];\n\t}\n\n\tconvex.length = k - 1;\n\treturn convex;\n}\n\n\n\nint main()\n{\n\tint n;\n\twhile((n = readln.chomp.to!int) != 0)\n\t{\n\t\tPoint[] ps;\n\t\tps.length = n;\n\n\t\tforeach(i;0..n)\n\t\t{\n\t\t\tstring[] _s = readln.chomp.split(\",\");\n\t\t\tps[i].x = _s[0].to!double;\n\t\t\tps[i].y = _s[1].to!double;\n\t\t}\n\n\t\tPoint[] convex = convex_hull(ps);\n\t\twriteln(n - convex.length);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "# AOJ 0068 Enclose Pins with a Rubber Band\n# Python3 2018.6.22 bal4u\n\ndef cross(a, b):\n\treturn a.real*b.imag - a.imag*b.real\n\t\n# 凸包　入力: 座標リスト　リターン:凸包を構成する座標リスト\ndef convex_hull(p):\n\tpp = sorted(p, key=lambda x:(x.imag,x.real))  # y座標を優先して昇順、同じならx座標で昇順\n\tn = len(pp)\n\tans, j = [0]*(n+1), 0\n\tfor i in range(n):\n\t\twhile j > 1 and cross(ans[j-1]-ans[j-2], pp[i]-ans[j-1]) <= 0: j -= 1\n\t\tans[j] = pp[i]\n\t\tj += 1\n\tk = j\n\tfor i in range(n-2, -1, -1):\n\t\twhile j > k and cross(ans[j-1]-ans[j-2], pp[i]-ans[j-1]) <= 0: j -= 1\n\t\tans[j] = pp[i]\n\t\tj += 1\n\treturn ans[0:j-1]\n\t\nwhile 1:\n\tn = int(input())\n\tif n == 0: break\n\tp = []\n\tfor i in range(n):\n\t\tx, y = list(map(float, input().split(',')))\n\t\tp.append(complex(x, y))\n\tprint(n - len(convex_hull(p)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D[::-1]:\n    if p1==p3 or p2==p3:continue\n    y3,x3=p3\n    if (x3-x1)*dy-dx*(y3-y1)<0:return 0\n  else:return 1\n\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D1.remove(p2)\n    if p2==p:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        la,ra = DC(la),DC(ra)\n        # Conquer\n        if len(la) == 1 or len(ra) == 1:\n            return la+ra\n        else:\n            while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0:\n                ra.pop(0)\n            while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0:\n                la.pop(-1)\n            return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D:\n    if p1==p3 or p2==p3:continue\n    if (p3[1]-x1)*dy-dx*(p3[0]-y1)<0:return 0\n  else:return 1\n \nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  while 1:\n    for p2 in D:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D.remove(p2)\n    if p2==p:break\n  print len(D)"
  },
  {
    "language": "Python",
    "code": "# Aizu Problem 0068: Enclose Pins with a Rubber Band\n#\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef is_to_the_left(p1, p2, p3):\n    # determine whether point p3 is to the left from the line from p1 to p2\n    position = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n    return position < 0\n\ndef jarvis(points):\n    # determine convex hull by Jarvis' algorithm:\n    max_y = max([p[1] for p in points])\n    pointOnHull = [p for p in points if p[1] == max_y][0]\n    convex_hull = [pointOnHull]\n    while len(convex_hull) == 1 or convex_hull[-1] != convex_hull[0]:\n        p = convex_hull[-1]\n        endpoint = points[0]\n        for j in range(len(points)):\n            if endpoint == pointOnHull or is_to_the_left(p, endpoint, points[j]):\n                endpoint = points[j]\n        pointOnHull = endpoint\n        convex_hull.append(pointOnHull)\n    return convex_hull[::-1]\n\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    points = [[float(_) for _ in input().split(',')] for __ in range(N)]\n    print(N - (len(jarvis(points)) - 1))"
  },
  {
    "language": "Python",
    "code": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        # Conquer\n        la,ra = DC(la),DC(ra)\n        while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0 and len(ra) > 1:\n            ra.pop(0)\n        while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0 and len(la) > 1:\n            la.pop(-1)\n        return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))"
  },
  {
    "language": "Python",
    "code": "# AOJ 0068 Enclose Pins with a Rubber Band\n# Python3 2018.6.22 bal4u\n\ndef cross(a, b):\n\treturn a.real*b.imag - a.imag*b.real\n\t\n# 凸包　入力: 座標リスト　リターン:凸包を構成する座標リスト\ndef convex_hull(p):\n\tpp = sorted(p, key=lambda x:(x.imag,x.real))  # y座標を優先して昇順、同じならx座標で昇順\n\tn = len(pp)\n\tans, j = [0]*(n+1), 0\n\tfor i in range(n):\n\t\twhile j > 1 and cross(ans[j-1]-ans[j-2], pp[i]-ans[j-1]) < 0: j -= 1\n\t\tans[j] = pp[i]\n\t\tj += 1\n\tk = j\n\tfor i in range(n-2, -1, -1):\n\t\twhile j > k and cross(ans[j-1]-ans[j-2], pp[i]-ans[j-1]) < 0: j -= 1\n\t\tans[j] = pp[i]\n\t\tj += 1\n\treturn ans[0:j-1]\n\t\nwhile 1:\n\tn = int(input())\n\tif n == 0: break\n\tp = []\n\tfor i in range(n):\n\t\tx, y = list(map(float, input().split(',')))\n\t\tp.append(complex(x, y))\n\tprint(n - len(convex_hull(p)))\n"
  },
  {
    "language": "Python",
    "code": "def a(v1,v2):\n    if v1[0]!=v2[0]:\n        return (v2[1]-v1[1])/(v2[0]-v1[0])\n    else:\n        return (v2[1]-v1[1])*(10**10)\n\ndef dlt(p,v,sign):\n    while len(p)>2:\n        if sign*(a(v[p[-3]],v[p[-2]])-a(v[p[-2]],v[p[-1]]))<0:\n            del p[-2]\n        else:\n            break\n    return p\n\ndef convex(v,n):\n    d,u=[],[]\n    for i in range(n):\n        d=dlt(d+[i],v,1)\n        u=dlt(u+[i],v,-1)\n    return n-len(set(d+u))\n\nwhile 1:\n    n=int(raw_input())\n    if n==0:\n        break\n    v=[map(float,raw_input().splirt(',')) for i in range(n)]\n    v=sorted(sorted(v,key=lambda x:x[1]))\n    print convex(v,n)"
  },
  {
    "language": "Python",
    "code": "def area(x1,y1,x2,y2,x3,y3):\n    return ((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))/2.0\ndef totu(S,d):\n    if len(S)<=3:\n        if len(S)==3:\n            if d==\"r\":\n                if area(S[0][0],S[0][1],S[1][0],S[1][1],S[2][0],S[2][1])>0:\n                    S[1],S[2]=S[2],S[1]\n                    \n            else:\n                if area(S[0][0],S[0][1],S[1][0],S[1][1],S[2][0],S[2][1])>0:\n                    S=[S[2],S[0],S[1]]\n                else:\n                    S=[S[2],S[1],S[0]]\n        if len(S)==2:\n            if d==\"l\":\n                S[0],S[1]=S[1],S[0]\n        return S\n\n    else:\n        S1=totu(S[:len(S)/2],\"l\")\n        S2=totu(S[len(S)/2:],\"r\")\n        ue_old_ri=0\n        ue_old_li=0\n        ue_new_ri=0\n        ue_new_li=0\n\n        while True:\n            for i in [i for i in range(len(S2)) if i>=ue_old_ri]:\n                if  area(S1[ue_old_li][0],S1[ue_old_li][1],S2[i][0],S2[i][1],S2[(i+1)%len(S2)][0],\n                         S2[(i+1)%len(S2)][1])<=0:\n                    ue_new_ri=i\n                    break\n            for j in [j for j in range(len(S1)) if j>=ue_old_li]:\n                if area(S2[ue_new_ri][0],S2[ue_new_ri][1],S1[j][0],S1[j][1],S1[(j+1)%len(S1)][0],\n                        S1[(j+1)%len(S1)][1])>=0:\n                    ue_new_li=j\n                    break\n            if ue_old_ri==ue_new_ri and ue_old_li==ue_new_li:\n                break\n            ue_old_ri,ue_old_li=ue_new_ri,ue_new_li\n        si_old_ri=0\n        si_old_li=0\n        si_new_ri=0\n        si_new_li=0\n        while True:\n            for i in [-i for i in range(len(S2)) if (-1)*i<=si_old_ri]:\n                if  area(S1[si_old_li%len(S1)][0],S1[si_old_li%len(S1)][1],S2[i%len(S2)][0],S2[i%len(S2)][1],S2[(i-1)%len(S2)][0],\n                         S2[(i-1)%len(S2)][1])>=0:\n                    si_new_ri=i\n                    break\n            for j in [-j for j in range(len(S1)) if (-1)*j<=si_old_li]:\n                if area(S2[si_new_ri%len(S2)][0],S2[si_new_ri%len(S2)][1],S1[j%len(S1)][0],S1[j%len(S1)][1],S1[(j-1)%len(S1)][0],\n                        S1[(j-1)%len(S1)][1])<=0:\n                    si_new_li=j\n                    break\n            if si_old_ri==si_new_ri and si_old_li==si_new_li:\n                break\n            si_old_ri,si_old_li=si_new_ri,si_new_li\n        if d==\"r\":\n            Sx=[]\n            i=0\n            while True:\n                Sx.append(S2[(i+ue_old_ri)%len(S2)])\n                if (i+ue_old_ri)%len(S2)==si_old_ri%len(S2):\n                    break\n                i+=1\n\n            Sy=[]\n            j=0\n            while True:\n                Sy.append(S1[(si_old_li-j)%len(S1)])\n                if (si_old_li-j)%len(S1)==ue_old_li%len(S1):\n                    break\n                j+=1\n\n            S=Sx+Sy\n            m=S.index(min(S))\n            S_d=[]\n            for i in range(len(S)):\n                S_d.append(S[(m+i)%len(S)])\n            return S_d\n        else:\n            Sx=[]\n            i=0\n            while True:\n                Sx.append(S1[(i+ue_old_li)%len(S1)])\n                if (i+ue_old_li)%len(S1)==si_old_li%len(S1):\n                    break\n                i+=1\n\n            Sy=[]\n            j=0\n            while True:\n                Sy.append(S2[(si_old_ri-j)%len(S2)])\n                if (si_old_ri-j)%len(S2)==ue_old_ri%len(S2):\n                    break\n                j+=1\n\n            S=Sx+Sy\n            m=S.index(max(S))\n            S_d=[]\n            for i in range(len(S)):\n                S_d.append(S[(m+i)%len(S)])\n            return S_d\n\nwhile True:\n    L=[]\n    n=input()\n    prin=n\n    if n==0:\n        break\n    while n!=0:\n        L.append(map(float,raw_input().split(\",\")))\n        n-=1\n    L.sort()\n    L=totu(L,\"l\")\n    print prin-len(L)"
  },
  {
    "language": "Python",
    "code": "import math\ndef ccw(p1,p2,p3):\n    return (p2[0]-p1[0])*(p3[1]-p2[1])-(p2[1]-p1[1])*(p3[0]-p2[0])\nwhile True:\n    n=input()\n    if n==0:\n        break\n    p=[0]*n\n    for i in xrange(n):\n        p[i]=map(float,raw_input().strip().split(\",\"))\n    P=min(p,key=lambda a:(a[1],a[0]))\n    p.sort(key=lambda x:math.atan2(x[1]-P[1],x[0]-P[0]))\n    M,ans=0,0\n    for i in xrange(1,n-1):\n        if all([ccw(p[M],p[i],p[j])>=0 for j in xrange(i+1,n)]):\n            M=i\n        else:\n            ans+=1\n    print ans"
  },
  {
    "language": "Python",
    "code": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        # Conquer\n        la,ra = DC(la),DC(ra)\n        while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0 and len(ra) > 1:\n            ra.pop(0)\n        while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0 and len(la) > 1:\n            la.pop(-1)\n        return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))"
  },
  {
    "language": "Python",
    "code": "def a(v1,v2):\n\tif v1[0] != v2[0]:\n\t\treturn (v2[1]-v1[1])/(v2[0]-v1[0])\n\telse:\n\t\treturn (v2[1]-v1[1])*(10**10)\ndef dlt(p,v,sign):\n\twhile len(p) > 2:\n\t\tif sign*(a(v[p[-3]],v[p[-2]]) - a(v[p[-2]],v[p[-1]])) < 0:\n\t\t\tdel p[-2]\n\t\telse:\n\t\t\tbreak\n\treturn p\ndef convex(v,n):\n\td,u = [],[]\n\tfor i in range(n):\n\t\td = dlt(d+[i],v,1)\n\t\tu = dlt(u+[i],v,-1)\n\treturn n - len(set(d+u))\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\tv = [map(float,raw_input().split(\",\")) for i in range(n)]\n\tv = sorted(sorted(v, key = lambda x:x[1]))\n\tprint convex(v,n)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\n\n\ndef deg(v1,v2):\n    normv1 = math.sqrt(v1[0]**2+v1[1]**2)\n    normv2 = math.sqrt(v2[0]**2+v2[1]**2)\n    if normv1 == 0 or normv2 == 0:\n        print \"ERROR\"; exit()\n    return (v1[0]*v2[0]+v1[1]*v2[1])/(normv1*normv2)\n\ndef calc_hull_right(d):\n    hull_right = [d[0]]\n    first = d[0]\n    p = d[0]\n    while True:\n        maxcos = -1.0\n        for i in xrange(1,len(d)):\n            if d[i][1] < p[1]  or d[i] == p: continue\n            c = deg([d[i][0]-p[0],d[i][1]-p[1]],[1,0])\n            if c >= maxcos:\n                maxcos = c\n                q = d[i]\n        p = q\n        hull_right.append(q)\n        if q == d[-1]: break\n    return hull_right\n\n\ndef calc_hull_left(d):\n    hull_left = [d[0]]\n    first = d[0]\n    p = d[0]\n    while True:\n        maxcos = 1.0\n        for i in xrange(1,len(d)):\n            if d[i][1] < p[1]  or d[i] == p: continue\n            c = deg([d[i][0]-p[0],d[i][1]-p[1]],[1,0])\n            if c <= maxcos:\n                maxcos = c\n                q = d[i]\n        p = q\n        hull_left.append(q)\n        if q == d[-1]: break\n    return hull_left\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    d = []\n    for t in xrange(n):\n        d.append(map(float,raw_input().split(\",\")))\n    d.sort(key = lambda x:x[1])\n    #print calc_hull_left(d) + calc_hull_right(d)\n    print  - len( calc_hull_left(d) + calc_hull_right(d) ) + 2 + len(d)"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  dy=p2[0]-y1\n  dx=p2[1]-x1\n  for p3 in D[::-1]:\n    if p1==p3 or p2==p3:pass\n    elif (p3[1]-x1)*dy-dx*(p3[0]-y1)<0:return 0\n  else:return 1\n\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D1.remove(p2)\n    if p2==p:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "def func(u,v):\n    f=lambda x,y:(v[0]-u[0])*(y-u[1])-(v[1]-u[1])*(x-u[0])\n    return f\n\nwhile True:\n    n=input()\n    if n==0:break\n    L=[map(float,raw_input().split(\",\")) for i in range(n)]\n    L.sort()\n    S=[]\n    init=L[0]\n    for i in range(n):\n        if L[i]!=init:\n            f=func(init,L[i])\n            for j in range(i+1,n):\n                if f(L[j][0],L[j][1])>0:\n                    break\n            else:\n                S.append(L[i])\n                init=L[i]\n    init=L[0]\n    for i in range(n):\n        if L[i]!=init:\n            f=func(init,L[i])\n            for j in range(i+1,n):\n                if f(L[j][0],L[j][1])<0:\n                    break\n            else:\n                S.append(L[i])\n                init=L[i]\n    print n-len(set(map(tuple,S)))-1"
  },
  {
    "language": "Python",
    "code": "from math import atan2\n\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Vector(object):\n    def __init__(self, p1, p2):\n        self.x = p2.x - p1.x\n        self.y = p2.y - p1.y\n\n    def cross(self, other: \"Vector\") -> float:\n        return self.x*other.y - self.y*other.x\n\ndef grahams_scan(a: list):\n    a.sort(key=lambda p: p.y)\n    bottom_x, bottom_y = a[0].x, a[0].y\n    _a = sorted(a[1:], key=lambda p: atan2(bottom_y-p.y, bottom_x-p.x)) + [a[0]]\n    result = [a[0], _a[0]]\n\n    for next_point in _a[1:]:\n        while Vector(result[-1], result[-2]).cross(Vector(result[-1], next_point)) >= 0:\n            result.pop()\n        result.append(next_point)\n    return result\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    a = [Point(*map(float, input().split(\",\"))) for _ in [0]*n]\n    result = grahams_scan(a)\n    print(n-len(result)+1)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\n\n\ndef deg(v1,v2):\n    normv1 = math.sqrt(v1[0]**2+v1[1]**2)\n    normv2 = math.sqrt(v2[0]**2+v2[1]**2)\n    if normv1 == 0 or normv2 == 0:\n        print \"ERROR\"; exit()\n    return (v1[0]*v2[0]+v1[1]*v2[1])/(normv1*normv2)\n\ndef calc_hull(d):\n    hull = []\n    point_first = d[0]\n    hull.append(point_first)\n    v = [ 1, 0 ]\n    oldpoint=point_first\n    while True:\n        minipoint = 0;\n        minv = [ 0,0 ]\n        maxcos = -1\n        for p in d:\n            if p == oldpoint: continue\n            o = [ p[i]-oldpoint[i] for i in xrange(2) ]\n            cos = deg(o,v)\n            if cos > maxcos:\n                maxcos = cos\n                minv = o\n                minpoint = p\n        if minpoint == point_first: break\n        v = minv\n        oldpoint = minpoint\n        hull.append(minpoint)\n    return hull\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    d = []\n    for t in xrange(n):\n        d.append(map(float,raw_input().split(\",\")))\n    h = calc_hull(sorted(d,key=lambda x:-x[1]))\n    print len(d) - len(calc_hull(d))"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D[::-1]:\n    if p1==p3 or p2==p3:continue\n    if (p3[1]-x1)*dy-dx*(p3[0]-y1)<0:return 0\n  else:return 1\n\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D1.remove(p2)\n    if p2==p:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D[::-1]:\n    if p1==p3 or p2==p3:pass\n    elif (p3[1]-x1)*dy-dx*(p3[0]-y1)<0:return 0\n  else:return 1\n\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D1.remove(p2)\n    if p2==p:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        # Conquer\n        la,ra = DC(la),DC(ra)\n        while len(ra) > 1 and f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0:\n            ra.pop(0)\n        while len(la) > 1 and f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0:\n            la.pop(-1)\n        return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))"
  },
  {
    "language": "Python",
    "code": "import math\ndef ccw(p1,p2,p3):\n    return (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\nwhile True:\n    n=input()\n    if n==0:\n        break\n    p=[0]*n\n    for i in xrange(n):\n        p[i]=map(float,raw_input().strip().split(\",\"))\n    P=min(p,key=lambda a:(a[1],a[0]))\n    p.remove(P)\n    p.sort(key=lambda x:math.atan2(P[1]-x[1],P[0]-x[0]))\n    M=0\n    ans=0\n    for i in xrange(1,n-1):\n        if not all([ccw(p[M],p[i],p[j])>=0 for j in xrange(i+1,n-1)]):\n            ans+=1\n        else:\n            M+=1\n    print ans"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D:\n    if p1!=p3 and p2!=p3 and (p3[1]-x1)*dy-dx*(p3[0]-y1)<0:return 0\n  else:return 1\n \nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  while 1:\n    for p2 in D:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D.remove(p2)\n    if p2==p:break\n  print len(D)"
  },
  {
    "language": "Python",
    "code": "from math import atan2\n\ndef grahams_scan(a: list):\n    a.sort(key=lambda x: x[1])\n    x1, y1 = a[0]\n    a = [((x1, y1), 0)] +\\\n        sorted([((x2, y2), atan2(y2-y1, x2-x1)) for x2, y2 in a[1:]], key=lambda x: x[1]) +\\\n        [((x1, y1), 0)]\n    result = [(x1, y1)]\n    for ((x2, y2),_), ((x3, y3),_) in zip(a[1:], a[2:]):\n        if (x1-x2)*(y3-y2) - (y1-y2)*(x3-x2) < 0:\n            result.append((x2, x3))\n            x1, y1 = x2, y2\n    return result\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    a = [tuple(map(float, input().split(\",\"))) for _ in [0]*n]\n    r = grahams_scan(a)\n    print(n-len(r))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nfor s in sys.stdin:\n    N = int(s)\n    if N == 0:\n        break\n\n    X = []\n    Y = []\n    visited = [False] * N\n\n    for i in range(N):\n        x, y = map(float, input().split(','))\n        X.append(x)\n        Y.append(y)\n\n    def paint(start_i, is_right, is_up):\n        x_start = X[start_i]\n        y_start = Y[start_i]\n        visited[start_i] = True\n\n        if is_right:\n            dir_sign = 1 # search right only\n        else:\n            dir_sign = -1 # search left only\n\n        if (is_up and is_right) or (not is_up and not is_right) :\n            min_max_sign = 1 # search min\n        else:\n            min_max_sign = -1 # search max\n\n        tangent_min_i = None\n        tangent_min = None\n        for i, x in enumerate(X):\n            if dir_sign * (x - x_start) > 0:\n                y = Y[i]\n                tangent = (y - y_start) / (x - x_start)\n                if tangent_min is None:\n                    tangent_min = tangent\n                    tangent_min_i = i\n                else:\n                    if min_max_sign * (tangent_min - tangent) > 0:\n                        tangent_min = tangent\n                        tangent_min_i = i\n        if tangent_min_i is not None:\n            paint(tangent_min_i, is_right, is_up)\n\n\n    start_index = Y.index(min(Y))\n    visited[start_index] = True\n    paint(start_index, is_right=True, is_up=True)\n    paint(start_index, is_right=False, is_up=True)\n\n    start_index = Y.index(max(Y))\n    visited[start_index] = True\n    paint(start_index, is_right=True, is_up=False)\n    paint(start_index, is_right=False, is_up=False)\n\n    visit_num = 0\n    for is_visit in visited:\n        if is_visit:\n            visit_num += 1\n    print(len(X) - visit_num)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# ????????????????????°???????????°????????????????????\\??????????????¢?????´???????????¨??????????§???????\n# ?????????http://www.prefield.com/algorithm/geometry/convex_hull.html\n\nimport enum\n\n\nEPS = 1e-10\n\n\nclass PointsRelation(enum.Enum):\n    counter_clockwise = 1\n    clockwise = 2\n    online_back = 3\n    on_segment = 4\n    online_front = 5\n\n\ndef inner_product(v1, v2):\n    return v1.real * v2.real + v1.imag * v2.imag\n\n\ndef outer_product(v1, v2):\n    return v1.real * v2.imag - v1.imag * v2.real\n\n\ndef project(a, b):\n    return a * inner_product(a, b) / (abs(a) ** 2)\n\n\ndef points_relation(p0, p1, p2):\n    v1 = p1 - p0\n    v2 = p2 - p0\n    op = outer_product(v1, v2)\n    if op > EPS:\n        return PointsRelation.counter_clockwise\n    elif op < -EPS:\n        return PointsRelation.clockwise\n    elif inner_product(v1, v2) < -EPS:\n        return PointsRelation.online_back\n    elif abs(v1) < abs(v2):\n        return PointsRelation.online_front\n    else:\n        return PointsRelation.on_segment\n\n\ndef in_place_convex_hull_andrew(ps):\n    def judge(p0, p1, p2):\n        b = points_relation(p0, p1, p2) != PointsRelation.counter_clockwise\n        b &= points_relation(p0, p1, p2) != PointsRelation.online_front\n        return b\n    if len(ps) < 3:\n        return ps\n    ps.sort(key=lambda p: p.imag)\n    n = len(ps)\n    k = 0\n    ch = [None for _ in range(2 * n)]\n    for i in range(n):\n        while k >= 2 and judge(ch[k - 2], ch[k - 1], ps[i]):\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n    t = k + 1\n    for i in range(n - 1)[::-1]:\n        while k >= t and judge(ch[k - 2], ch[k - 1], ps[i]):\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n    ch = ch[:k - 1]\n    return ch\n\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            return\n        ps = [complex(*map(float, input().split(\",\"))) for _ in range(n)]\n        ch = in_place_convex_hull_andrew(ps)\n        print(n - len(ch))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom __future__ import (division, absolute_import, print_function,\n                        unicode_literals)\nfrom sys import stdin\nfrom math import copysign\n\n\ndef gradient(p):\n    def fn(t):\n        dx = p[0] - t[0]\n        dy = p[1] - t[1]\n        if dx:\n            return dy / dx\n        return copysign(float('inf'), -dy)\n    return fn\n\n\ndef solve(n):\n    L = []\n    for i in range(n):\n        L.append(tuple(float(s) for s in stdin.readline().split(',')))\n    L.sort()\n\n    p = p0 = L.pop(0)\n    while True:\n        p = max((t for t in L if t[0] >= p[0]), key=gradient(p))\n        if p == L[-1]:\n            break\n        L.remove(p)\n\n    p = p0\n    while True:\n        p = min((t for t in L if t[0] >= p[0]), key=gradient(p))\n        if p == L[-1]:\n            break\n        L.remove(p)\n\n    return len(L) - 1\n\nwhile True:\n    n = int(stdin.readline())\n    if not n:\n        break\n    print(solve(n))"
  },
  {
    "language": "Python",
    "code": "from math import atan2\n\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Vector(object):\n    def __init__(self, p1, p2):\n        self.x = p2.x - p1.x\n        self.y = p2.y - p1.y\n\n    def cross(self, other: \"Vector\") -> float:\n        return self.x*other.y - self.y*other.x\n\ndef grahams_scan(a: list):\n    a.sort(key=lambda p: p.y)\n    bottom_x, bottom_y = a[0].x, a[0].y\n    _a = sorted(a[1:], key=lambda p: atan2(bottom_y-p.y, bottom_x-p.x)) + [a[0]]\n    result = [a[0], _a[0]]\n\n    for next_point in _a[1:]:\n        while Vector(result[-1], result[-2]).cross(Vector(result[-1], next_point)) >= 0:\n            result.pop()\n        result.append(next_point)\n    return result\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    a = [Point(*map(float, input().split(\",\"))) for _ in [0]*n]\n    result = grahams_scan(a)\n    print(n-len(result)-1)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D[::-1]:\n    if p1==p3 or p2==p3:pass\n    elif (x2-x1)*dy-dx*(y2-y1)<0:return 0\n  else:return 1\n\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D1.remove(p2)\n    if p2==p:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "def a(v1,v2):\n\tif v1[0] != v2[0]:\n\t\treturn (v2[1]-v1[1])/(v2[0]-v1[0])\n\telse:\n\t\treturn (v2[1]-v1[1])*(10**10)\n\t\t\ndef convex(v,n):\n\tk = 0\n\td = []\n\tu = []\n\tfor i in range(n):\n\t\td.append(i)\n\t\tu.append(i)\n\t\twhile len(d) > 2:\n\t\t\tif a(v[d[-3]],v[d[-2]]) < a(v[d[-2]],v[d[-1]]):\n\t\t\t\tdel d[-2]\n\t\t\telse:\n\t\t\t\tbreak\n\t\twhile len(u) > 2:\n\t\t\tif a(v[u[-3]],v[u[-2]]) > a(v[u[-2]],v[u[-1]]):\n\t\t\t\tdel u[-2]\n\t\t\telse:\n\t\t\t\tbreak\n\treturn n - len(set(d+u))\n\t\nwhile 1:\n\tn = input()\n\tif n == 0: break\n\tv = [map(float,raw_input().split(\",\")) for i in range(n)]\n\tv = sorted(sorted(v, key = lambda x:x[1]))\n\tprint convex(v,n)"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1, p2, p3):\n  y1,x1=p1\n  y2,x2=p2\n  y3,x3=p3\n  return (x3-x1)*(y2-y1)-(x2-x1)*(y3-y1)>0\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p1=D[0]\n  D1=D[:]\n  while True:\n    c=0\n    for p2 in D1:\n      if p1==p2:continue\n      f=[0,0]\n      for p3 in D:\n        if p1==p3 or p2==p3: continue\n        f[side(p1,p2,p3)]+=1\n      if f[0]==0:break\n    p1=p2\n    D1.remove(p2)\n    if p2==D[0]:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "import math\ndef ccw(p1,p2,p3):\n#    print (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\n    return (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\nwhile True:\n    n=input()\n    if n==0:\n        break\n    p=[0]*n\n    for i in xrange(n):\n        p[i]=map(float,raw_input().strip().split(\",\"))\n    P=min(p,key=lambda a:(a[1],a[0]))\n    p.remove(P)\n    p.sort(key=lambda x:math.atan2(x[1]-P[1],x[0]-P[0]))\n    \"\"\"\n    print P,p\n    for x in p:\n        print x[0],x[1],math.atan2(x[1]-P[1],x[0]-P[0])\n    \"\"\"\n    M=0\n    ans=0\n    for i in xrange(1,n-1):\n        if not all([ccw(p[M],p[i],p[j])>=0 for j in xrange(i+1,n-1)]):\n            ans+=1\n        else:\n            M+=1\n    print ans"
  },
  {
    "language": "Python",
    "code": "import math\ndef ccw(p1,p2,p3):\n    return (p2[0]-p1[0])*(p3[1]-p2[1])-(p2[1]-p1[1])*(p3[0]-p2[0])\nwhile True:\n    n=input()\n    if n==0:\n        break\n    p=[0]*n\n    for i in xrange(n):\n        p[i]=map(float,raw_input().strip().split(\",\"))\n    P=min(p,key=lambda a:(a[1],a[0]))\n    p.sort(key=lambda x:math.atan2(x[1]-P[1],x[0]-P[0]))\n    M=0\n    ans=0\n    for i in xrange(1,n-1):\n        if all([ccw(p[M],p[i],p[j])>=0 for j in xrange(i+1,n)]):\n            M=i\n        else:\n            ans+=1\n    print ans"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D[::-1]:\n    if p1==p3 or p2==p3:pass\n    y3,x3=p3\n    elif (x3-x1)*dy-dx*(y3-y1)<0:return 0\n  else:return 1\n\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D1.remove(p2)\n    if p2==p:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "def a(v1,v2):\n    if v1[0]!=v2[0]:\n        return (v2[1]-v1[1])/(v2[0]-v1[0])\n    else:\n        return (v2[1]-v1[1])*(10**10)\n\ndef dlt(p,v,sign):\n    while len(p)>2:\n        if sign*(a(v[p[-3]],v[p[-2]])-a(v[p[-2]],v[p[-1]]))<0:\n            del p[-2]\n        else:\n            break\n    return p\n\ndef convex(v,n):\n    d,u=[],[]\n    for i in range(n):\n        d=dlt(d+[i],v,1)\n        u=dlt(u+[i],v,-1)\n    return n-len(set(d+u))\n\nwhile 1:\n    n=int(raw_input())\n    if n==0:\n        break\n    v=[map(float,raw_input().split(',')) for i in range(n)]\n    v=sorted(sorted(v,key=lambda x:x[1]))\n    print convex(v,n)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef cross3(a, b, c):\n    return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])\n\nEPS = -1e-9\ndef convex_hull(ps):\n    qs = []\n    n = len(ps)\n    for p in ps:\n        while len(qs)>1 and cross3(qs[-1], qs[-2], p) > -EPS:\n            qs.pop()\n        qs.append(p)\n    t = len(qs)\n    for i in range(n-2, -1, -1):\n        p = ps[i]\n        while len(qs)>t and cross3(qs[-1], qs[-2], p) > -EPS:\n            qs.pop()\n        qs.append(p)\n    return qs\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    P = [list(map(float, readline().split(\",\"))) for i in range(N)]\n    P.sort()\n    Q = convex_hull(P)\n    write(\"%d\\n\" % (N - len(Q) + 1))\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1, p2, p3):\n  y1,x1=p1\n  y2,x2=p2\n  y3,x3=p3\n  return (x3-x1)*(y2-y1)-(x2-x1)*(y3-y1)>0\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1==p2:continue\n      for p3 in D[::-1]:\n        if p1==p3 or p2==p3: continue\n        if side(p1,p2,p3)==0:break\n      else:break\n    p1=p2\n    D1.remove(p2)\n    if p2==D[0]:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "import math\ndef ccw(p1,p2,p3):\n    return (p2[0]-p1[0])*(p3[1]-p2[1])-(p2[1]-p1[1])*(p3[0]-p2[0])\nwhile True:\n    n=input()\n    if n==0:\n        break\n    p=[0]*n\n    for i in xrange(n):\n        p[i]=map(float,raw_input().split(\",\"))\n    P=min(p,key=lambda a:(a[1],a[0]))\n    p.sort(key=lambda x:math.atan2(x[1]-P[1],x[0]-P[0]))\n    M,ans=0,0\n    for i in xrange(1,n-1):\n        if all([ccw(p[M],p[i],p[j])>=0 for j in xrange(i+1,n)]):\n            M=i\n        else:\n            ans+=1\n    print ans"
  },
  {
    "language": "Python",
    "code": "\nimport sys\nimport math\n\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Vector:\n    def __init__(self, p1, p2):\n        self.vx = p2.x - p1.x\n        self.vy = p2.y - p1.y\n\n    def length(self):\n        return math.sqrt(self.vx ** 2.0 + self.vy ** 2.0)\n\n    def degree(self, other):\n        theta = math.acos((self.vx * other.vx + self.vy * other.vy)/(self.length() * other.length()))\n        return theta\n\n    def show(self):\n        return \"Vector(%f, %f)\" % (self.vx, self.vy)\n\n\ndef solv(points):\n    p0 = points[0]\n    for p in points[1:]:\n        if p.y < p0.y:\n            p0 = p\n    v1 = Vector(Point(0.0, 0.0), Point(1.0, 0.0))\n    p1 = p0\n    t = [p1]\n    while True:\n        min_deg = math.pi\n        next_p = None\n        next_v = None\n        points2 = list(points)\n        points2.remove(p1)\n        for p2 in points2:\n            v2 = Vector(p1, p2)\n            deg = v1.degree(v2)\n            if deg < min_deg:\n                min_deg = deg\n                next_p = p2\n                next_v = v2\n        if next_p == p0:\n            break\n        p1 = next_p\n        t.append(p1)\n        v1 = next_v\n    return len(points) - len(t)\n\n\n\nwhile True:\n    n = int(sys.stdin.readline())\n    if n == 0:\n        break\n    points = []\n    for i in range(n):\n        x, y = map(float, sys.stdin.readline().split(','))\n        points.append(Point(x, y))\n    print solv(points)"
  },
  {
    "language": "Python",
    "code": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        la,ra = DC(la),DC(ra)\n        # Conquer\n        if len(la) == 1 or len(ra) == 1:\n            return la+ra\n        else:\n            while f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0:\n                ra.pop(0)\n            while f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0:\n                la.pop(-1)\n            return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))"
  },
  {
    "language": "Python",
    "code": "eps = 1e-10\n\ndef add(a, b):\n    return 0 if abs(a + b) < eps * (abs(a) + abs(b)) else a + b\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, p):\n        return Point(add(self.x, p.x), add(self.y, p.y))\n\n    def __sub__(self, p):\n        return Point(add(self.x, -p.x), add(self.y, -p.y))\n\n    def __mul__(self, d):\n        return Point(self.x * d, self.y * d)\n\n    def dot(self, p):\n        return add(self.x * p.x, self.y * p.y)\n\n    def det(self, p):\n        return add(self.x * p.y, -self.y * p.x)\n\n    def __str__(self):\n        return \"({}, {})\".format(self.x, self.y)\n\n\n\n\ndef convex_hull(ps):\n    ps = [Point(x, y) for x, y in sorted([(p.x, p.y) for p in ps])]\n    upper_hull = get_bounds(ps)\n    ps.reverse()\n    lower_hull = get_bounds(ps)\n    del upper_hull[-1]\n    del lower_hull[-1]\n    upper_hull.extend(lower_hull)\n    return upper_hull\n\ndef get_bounds(ps):\n    qs = [ps[0], ps[1]]\n    for p in ps[2:]:\n        while len(qs) > 1 and (qs[-1] - qs[-2]).det(p - qs[-1]) <= 0:\n            del qs[-1]\n        qs.append(p)\n    return qs\n    \nwhile True:\n    n = int(input())\n    if n == 0: break\n    points = []\n    for i in range(n):\n        x, y = map(float, input().split(','))\n        points.append(Point(x, y))\n    print(len(points) - len(convex_hull(points)))\n    "
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D[::-1]:\n    y3,x3=p3\n    if p1==p3 or p2==p3:pass\n    elif (x3-x1)*dy-dx*(y3-y1)<0:return 0\n  else:return 1\n\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D1.remove(p2)\n    if p2==p:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "import math\ndef vec(a, b):\n    return [b[0] - a[0], b[1] - a[1]]\n\ndef norm(a):\n    return math.sqrt(a[0]**2 + a[1]**2)\n\ndef cross(a, b):\n    return a[0]*b[1] - b[0]*a[1]\n\ndef gift_wrap(p_a, p_h, a):\n    while True:\n        p_h.append(a)\n        b = p_a[0]\n        for i in range(len(p_a)):\n            c = p_a[i]\n            if b == a:\n                b = c\n            else:\n                ab = vec(a, b)\n                ac = vec(a, c)\n                v = cross(ab, ac)\n                if v > 0 or (v == 0 and norm(ac) > norm(ab)):\n                    b = c\n        a = b\n        if a == p_h[0]:\n            break\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    p_all = []\n    p_hull = []\n    for i in range(n):\n        p_all.append(list(map(float, input().split(\",\"))))\n    p_all = sorted(p_all)\n    gift_wrap(p_all, p_hull, p_all[0])\n    print(len(p_all) - len(p_hull))\n\n"
  },
  {
    "language": "Python",
    "code": "#凸包を求める\n\ndef quickhull(l,r,s,k):\n    if not s:\n        return\n    su = []\n    sd = []\n    a = (r[0]-l[0],r[1]-l[1])\n    for x,y in s:\n        b = (x-l[0],y-l[1])\n        cro = cross(a,b)\n        if cro > 0:\n            su.append((x,y)) #上半分\n        elif cro < 0:\n            sd.append((x,y)) #下半分\n\n    if su:\n        c,d = direction(l,r,su[0])\n        p = su[0]\n        for i in range(1,len(su)):\n            c_,d_ = direction(l,r,su[i])\n            if c*d_ < c_*d:\n                c,d = c_,d_\n                p = su[i]\n        k.append(tuple(p)) #もっとも離れた点を凸包の頂点に追加\n        b = (l[0]-p[0],l[1]-p[1])\n        c = (p[0]-r[0],p[1]-r[1])\n        s1 = []\n        s2 = []\n        for x,y in su:\n            b_ = (x-p[0],y-p[1])\n            c_ = (x-r[0],y-r[1])\n            cro_b,cro_c = cross(b,b_),cross(c,c_)\n            if cro_b >= 0 and cro_c >= 0: #三角形内部判定\n                continue\n            else:\n                if cro_b < 0:\n                    s1.append((x,y))\n                elif cro_c < 0:\n                    s2.append((x,y))\n        quickhull(l,p,s1,k) #再帰\n        quickhull(p,r,s2,k)\n\n    if sd:\n        c,d = direction(l,r,sd[0])\n        p = sd[0]\n        for i in range(1,len(sd)):\n            c_,d_ = direction(l,r,sd[i])\n            if c*d_ < c_*d:\n                c,d = c_,d_\n                p = sd[i]\n        k.append(tuple(p)) #もっとも離れた点を凸包の頂点に追加\n        b = (l[0]-p[0],l[1]-p[1])\n        c = (p[0]-r[0],p[1]-r[1])\n        s1 = []\n        s2 = []\n        for x,y in sd:\n            b_ = (x-p[0],y-p[1])\n            c_ = (x-r[0],y-r[1])\n            cro_b,cro_c = cross(b,b_),cross(c,c_)\n            if cro_b <= 0 and cro_c <= 0: #三角形内部判定(ベクトルの向きにより上下で判定が異なることに注意)\n                continue\n            else:\n                if cro_b > 0:\n                    s1.append((x,y))\n                elif cro_c > 0:\n                    s2.append((x,y))\n        quickhull(l,p,s1,k) #再帰\n        quickhull(p,r,s2,k)\n    return k\n\ndef cross(a,b): #外積\n    return a[0]*b[1]-a[1]*b[0]\n\ndef direction(l,r,p): #点と直線の距離\n    a = r[1]-l[1]\n    b = l[0]-r[0]\n    return (a*(p[0]-l[0])+b*(p[1]-l[1]))**2, a**2+b**2 #分子の2乗,分母の2乗\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    s = [[float(x) for x in input().split(\",\")] for i in range(n)]\n    s.sort()\n    l = tuple(s.pop(0))\n    r = tuple(s.pop(-1))\n    k = quickhull(l,r,s,[l,r])\n    print(n-len(k))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D[::-1]:\n    if p1==p3 or p2==p3:continue\n    y3,x3=p3\n    if (x3-x1)*dy-dx*(y3-y1)<0:return 0\n  else:return 1\n\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D1.remove(p2)\n    if p2==p:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "eps = 1e-10\n\ndef add(a, b):\n    return 0 if abs(a + b) < eps * (abs(a) + abs(b)) else a + b\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, p):\n        return Point(add(self.x, p.x), add(self.y, p.y))\n\n    def __sub__(self, p):\n        return Point(add(self.x, -p.x), add(self.y, -p.y))\n\n    def __mul__(self, d):\n        return Point(self.x * d, self.y * d)\n\n    def dot(self, p):\n        return add(self.x * p.x, self.y * p.y)\n\n    def det(self, p):\n        return add(self.x * p.y, -self.y * p.x)\n\n    def __str__(self):\n        return \"({}, {})\".format(self.x, self.y)\n\ndef convex_hull(ps):\n    ps = [Point(x, y) for x, y in sorted([(p.x, p.y) for p in ps])]\n    lower_hull = get_bounds(ps)\n    ps.reverse()\n    upper_hull = get_bounds(ps)\n    del upper_hull[-1]\n    del lower_hull[-1]\n    lower_hull.extend(upper_hull)\n    return lower_hull\n\ndef get_bounds(ps):\n    qs = [ps[0], ps[1]]\n    for p in ps[2:]:\n        while len(qs) > 1 and (qs[-1] - qs[-2]).det(p - qs[-1]) <= 0:\n            del qs[-1]\n        qs.append(p)\n    return qs\n    \nwhile True:\n    n = int(input())\n    if n == 0: break\n    points = []\n    for i in range(n):\n        x, y = map(float, input().split(','))\n        points.append(Point(x, y))\n    print(len(points) - len(convex_hull(points)))\n    "
  },
  {
    "language": "Python",
    "code": "eps = 1e-10\n\ndef add(a, b):\n    return 0 if abs(a + b) < eps * (abs(a) + abs(b)) else a + b\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __add__(self, p):\n        return Point(add(self.x, p.x), add(self.y, p.y))\n\n    def __sub__(self, p):\n        return Point(add(self.x, -p.x), add(self.y, -p.y))\n\n    def __mul__(self, d):\n        return Point(self.x * d, self.y * d)\n\n    def dot(self, p):\n        return add(self.x * p.x, self.y * p.y)\n\n    def det(self, p):\n        return add(self.x * p.y, -self.y * p.x)\n\n    def __str__(self):\n        return \"({}, {})\".format(self.x, self.y)\n\ndef convex_hull(ps):\n    ps = [Point(x, y) for x, y in sorted([(p.x, p.y) for p in ps])]\n    upper_hull = get_bounds(ps)\n    ps.reverse()\n    lower_hull = get_bounds(ps)\n    del upper_hull[-1]\n    del lower_hull[-1]\n    upper_hull.extend(lower_hull)\n    return upper_hull\n\ndef get_bounds(ps):\n    qs = []\n    for p in ps:\n        while len(qs) > 2 and (qs[-1] - qs[-2]).det(p - qs[-1]) <= 0:\n            del qs[-1]\n        qs.append(p)\n    return qs\n    \nwhile True:\n    n = int(input())\n    if n == 0: break\n    points = []\n    for i in range(n):\n        x, y = map(float, input().split(','))\n        points.append(Point(x, y))\n    print(len(points) - len(convex_hull(points)))\n    "
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1, p2, p3):\n  y1,x1=p1\n  y2,x2=p2\n  y3,x3=p3\n  return (x3-x1)*(y2-y1)-(x2-x1)*(y3-y1)>0\nwhile 1:\n  n=input()\n  if n==0:break\n  D=[input() for i in range(n)]\n  for p1 in D:\n    c=0\n    for p2 in D:\n      if p1==p2:continue\n      f=[0,0]\n      for p3 in D:\n        if p1==p3 or p2==p3: continue\n        f[side(p1,p2,p3)]+=1\n      if min(f)==0:\n        n-=1\n        break\n  print n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1, p2, p3):\n  y1,x1=p1\n  y2,x2=p2\n  y3,x3=p3\n  return (x3-x1)*(y2-y1)-(x2-x1)*(y3-y1)>0\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p1=D[0]\n  D1=D[:]\n  while True:\n    c=0\n    for p2 in D1:\n      if p1==p2:continue\n      f=[0,0]\n      for p3 in D[::-1]:\n        if p1==p3 or p2==p3: continue\n        f[side(p1,p2,p3)]+=1\n      if f[0]==0:break\n    p1=p2\n    D1.remove(p2)\n    if p2==D[0]:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "while 1:\n        n = input()\n        if n == 0:\n                break\n        x = []\n        y = []\n        for i in range(n):\n                a,b = map(float,raw_input().split(','))\n                x.append(a)\n                y.append(b)\n        ys = y.index(min(y))\n        s = ys\n        vx = 1.0\n        vy = 0.0\n        ans = n\n        while 1:\n                cx = -1.0\n                t = -1\n                for i in range(n):\n                        if i != s:\n                                tx = x[i] - x[s]\n                                ty = y[i] - y[s]\n                                d = (tx**2 + ty**2) ** 0.5\n                                c = (vx*tx + vy*ty) / d\n                                if cx < c:\n                                        cx = c\n                                        t = i\n                ans -= 1\n                if t == ys:\n                        break\n                vx = x[t] - x[s]\n                vy = y[t] - y[s]\n                s = t\n        print ans"
  },
  {
    "language": "Python",
    "code": "import math\ndef ccw(p1,p2,p3):\n#    print (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\n    return (p2[0]-p1[0])*(p3[1]-p1[1])-(p2[1]-p1[1])*(p3[0]-p1[0])\nwhile True:\n    n=input()\n    if n==0:\n        #print 0\n        break\n    p=[0]*n\n    for i in xrange(n):\n        p[i]=map(float,raw_input().strip().split(\",\"))\n    P=min(p,key=lambda a:(a[1],a[0]))\n    p.sort(key=lambda x:math.atan2(x[1]-P[1],x[0]-P[0]))\n    #print len(p)\n    #print \"\\n\".join(map(lambda x:\"{},{}\".format(x[0],x[1]),p))\n    M=0\n    ans=0\n    for i in xrange(1,n):\n        while ccw(p[M-1],p[M],p[i])<=0:\n            if M>0:\n                M-=1\n                ans+=1\n            elif i==n:\n                break\n            else:\n                i+=1\n                \n        M+=1\n        p[M],p[i]=p[i],p[M]\n    print ans\n    #print len(p)\n    #print \"\\n\".join(map(lambda x:\"{},{}\".format(x[0],x[1]),p))"
  },
  {
    "language": "Python",
    "code": "from math import atan2\n\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Vector(object):\n    def __init__(self, p1, p2):\n        self.x = p2.x - p1.x\n        self.y = p2.y - p1.y\n\n    def cross(self, other: \"Vector\") -> float:\n        return self.x*other.y - self.y*other.x\n\ndef grahams_scan(a: list):\n    a.sort(key=lambda p: p.y)\n    bottom_x, bottom_y = a[0].x, a[0].y\n    _a = sorted(a[1:], key=lambda p: atan2(bottom_y-p.y, bottom_x-p.x))\n    result = [a[0], _a[0]]\n\n    for next_point in _a[1:]:\n        while Vector(result[-1], result[-2]).cross(Vector(result[-1], next_point)) >= 0:\n            result.pop()\n        result.append(next_point)\n    return result\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    a = [Point(*map(float, input().split(\",\"))) for _ in [0]*n]\n    result = grahams_scan(a)\n    print(n-len(result))\n"
  },
  {
    "language": "Python",
    "code": "def op(x,y):\n    \"\"\"\n    Outer product\n    \"\"\"\n    return(complex.conjugate(x)*y).imag\n\ndef isrm(q,i,x):   \n    \"\"\"\n    is i right most to q's from view of x?\n    \"\"\"\n    for j in q:\n        if op(i-x, j-x) < 0:\n            return(False)\n    return(True)\n\ndef rightmost(p,x):\n    \"\"\"\n    Find a point in p which is rightmost from x(other than x)\n    \"\"\"\n    for i in [i for i in p if i!=x]:\n        q = p.copy()\n        q.remove(i)\n        if isrm(q,i,x):\n            return(i)\n    raise ValueError('Do not come here')\n\ndef solve(p,pf,orig):\n    nx = rightmost(p,orig)\n    ni = p.index(nx)\n    if pf[ni]:   # second visit\n        return(pf)\n    pf[ni] = True\n    return(solve(p,pf,nx))\n\nwhile True:\n    p = []\n    n = int(input().strip())\n    if n==0:\n        break\n    for i in range(n):\n        x,y = list(map(float, input().strip().split(',')))\n        p.append(x+y*1j)\n    print(solve(p,[False for _ in range(n)],2000.0 + 0.0*1j).count(False))"
  },
  {
    "language": "Python",
    "code": "import math\ndef ccw(p1,p2,p3):\n    #print (p2[0]-p1[0])*(p3[1]-p2[1])-(p2[1]-p1[1])*(p3[0]-p2[0])>=0\n    return (p2[0]-p1[0])*(p3[1]-p2[1])-(p2[1]-p1[1])*(p3[0]-p2[0])\nwhile True:\n    n=input()\n    if n==0:\n        break\n    p=[0]*n\n    for i in xrange(n):\n        p[i]=map(float,raw_input().strip().split(\",\"))\n    P=min(p,key=lambda a:(a[1],a[0]))\n    p.sort(key=lambda x:math.atan2(x[1]-P[1],x[0]-P[0]))\n    #print n\n    #print \"\\n\".join(map(lambda x:\"{},{}\".format(x[0],x[1]),p))\n    M=0\n    i=1\n    c_p=p[:]\n    #print M,p\n    while M<len(p)-1:\n        if all([ccw(p[M-1],p[M],p[i])>=0 for i in xrange(M+1,len(p))]):\n            M+=1\n        else:\n            p.remove(p[M])\n        #print M,p\n    print len(c_p)-len(p)\n    #print len(p)\n    #print \"\\n\".join(map(lambda x:\"{},{}\".format(x[0],x[1]),p))"
  },
  {
    "language": "Python",
    "code": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        # Conquer\n        la,ra = DC(la),DC(ra)\n        while len(ra) > 1 and f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0.0:\n            ra.pop(0)\n        while len(la) > 1 and f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0.0:\n            la.pop()\n        return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef ccw(a, b, c):\n    ax = b[0] - a[0]\n    ay = b[1] - a[1]\n    bx = c[0] - a[0]\n    by = c[1] - a[1]\n    t = ax*by - ay*bx;\n    if t > 0:\n        return 1\n    if t < 0:\n        return -1\n    if ax*bx + ay*by < 0:\n        return 2\n    if ax*ax + ay*ay < bx*bx + by*by:\n        return -2\n    return 0\n\ndef convex_hull(ps):\n    n = len(ps)\n    k = 0\n    ps.sort()\n    ch = [[-1,-1] for _ in range(n*2)]\n    for i in range(n):\n        while k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n    t = k + 1\n    for i in range(n-2,-1,-1):\n        while k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n    ch = ch[:k-1]\n    return ch\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        a = [list(map(float, S().split(','))) for _ in range(n)]\n        r = convex_hull(a)\n        rr.append(n-len(r))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef side(p1,p2):\n  global D\n  y1,x1=p1\n  y2,x2=p2\n  dy=y2-y1\n  dx=x2-x1\n  for p3 in D[::-1]:\n    y3,x3=p3\n    if p1==p3 or p2==p3:continue\n    if (x3-x1)*dy-dx*(y3-y1)<0:return 0\n  else:return 1\n\nwhile 1:\n  n=input()\n  if n==0:break\n  D=sorted([list(input()) for i in range(n)])\n  p=p1=D[0]\n  D1=D[:]\n  while True:\n    for p2 in D1:\n      if p1!=p2 and side(p1,p2):break\n    p1=p2\n    D1.remove(p2)\n    if p2==p:break\n  print len(D1)"
  },
  {
    "language": "Python",
    "code": "import math\ndef ccw(p1,p2,p3):\n    #print (p2[0]-p1[0])*(p3[1]-p2[1])-(p2[1]-p1[1])*(p3[0]-p2[0])>=0\n    return (p2[0]-p1[0])*(p3[1]-p2[1])-(p2[1]-p1[1])*(p3[0]-p2[0])\nwhile True:\n    n=input()\n    if n==0:\n        print n\n        break\n    p=[0]*n\n    for i in xrange(n):\n        p[i]=map(float,raw_input().strip().split(\",\"))\n    P=min(p,key=lambda a:(a[1],a[0]))\n    p.sort(key=lambda x:math.atan2(x[1]-P[1],x[0]-P[0]))\n    M=0\n    ans=0\n    i=1\n    #print M,p\n    while M<len(p)-1:\n        if all([ccw(p[M-1],p[M],p[i])>=0 for i in xrange(M+1,len(p))]):\n            M+=1\n        else:\n            ans+=1\n            p.remove(p[M])\n        #print M,p\n    print ans\n#    print len(p)\n#    print \"\\n\".join(map(lambda x:\"{},{}\".format(x[0],x[1]),p))"
  },
  {
    "language": "Python",
    "code": "import math\ndef ccw(p1,p2,p3):\n    return (p2[0]-p1[0])*(p3[1]-p2[1])-(p2[1]-p1[1])*(p3[0]-p2[0])\nwhile True:\n    n=input()\n    if n==0:\n        break\n    p=[0]*n\n    for i in xrange(n):\n        p[i]=map(float,raw_input().strip().split(\",\"))\n    P=min(p,key=lambda a:(a[1],a[0]))\n    p.sort(key=lambda x:math.atan2(x[1]-P[1],x[0]-P[0]))\n    M=0\n    ans=0\n    while M<len(p)-1:\n        if all([ccw(p[M-1],p[M],p[i])>=0 for i in xrange(M+1,len(p))]):\n            M+=1\n        else:\n            ans+=1\n            p.remove(p[M])\n    print ans"
  },
  {
    "language": "Python",
    "code": "    upper_hull = get_bounds(ps)\n    ps.reverse()\n    lower_hull = get_bounds(ps)\n    del upper_hull[-1]\n    del lower_hull[-1]\n    upper_hull.extend(lower_hull)\n    return upper_hull\n\ndef get_bounds(ps):\n    qs = []\n    for p in ps:\n        while len(qs) > 1 and (qs[-1] - qs[-2]).det(p - qs[-1]) <= 0:\n            del qs[-1]\n        qs.append(p)\n    return qs\n    \nwhile True:\n    n = int(input())\n    if n == 0: break\n    points = []\n    for i in range(n):\n        x, y = map(float, input().split(','))\n        points.append(Point(x, y))\n    print(len(points) - len(convex_hull(points)))\n    "
  },
  {
    "language": "Python",
    "code": "def f(x,y,x1,y1,x2,y2):\n    if x1 <= x2:\n        return (x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1\n    else:\n        return -((x2-x1)*y-(y2-y1)*x+x1*y2-x2*y1)\n\ndef DC(a):\n    if len(a) > 3:\n        # Divide\n        la = a[:len(a)/2]\n        ra = a[len(a)/2:]\n        # Conquer\n        la,ra = DC(la),DC(ra)\n        while len(ra) > 1 and f(ra[1][0],ra[1][1],la[-1][0],la[-1][1],ra[0][0],ra[0][1]) > 0:\n            ra.pop(0)\n        while len(la) > 1 and f(la[-2][0],la[-2][1],ra[0][0],ra[0][1],la[-1][0],la[-1][1]) > 0:\n            la.pop()\n        return la+ra\n    else:\n        return a\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    p = []\n    for i in range(n):\n        p.append(map(float, raw_input().split(\",\")))\n    p = sorted(p, key = lambda x: x[0])\n    print n - len(DC(p))"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef calc_hull(d,direction):\n    maxcos0 = {\"r\":-1.0,\"l\":1.0}\n    hull = [d[0]]\n    p = d[0]\n    while True:\n        maxcos = maxcos0[direction]\n        for i in xrange(1,len(d)):\n            if d[i][1] < p[1]  or d[i] == p: continue\n            v = [ d[i][0]-p[0] , d[i][1]-p[1] ]\n            c = v[0]/(v[0]**2+v[1]**2)**0.5\n            if c >= maxcos and direction == \"r\":\n                maxcos = c\n                q = d[i]\n            if c <= maxcos and direction == \"l\":\n                maxcos = c\n                q = d[i]\n        p = q\n        hull.append(q)\n        if q == d[-1]: break\n    return hull\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    d = []\n    for t in xrange(n):\n        d.append(map(float,raw_input().split(\",\")))\n    d.sort(key = lambda x:x[1])\n    print len(d) - ( len( calc_hull(d,\"r\") + calc_hull(d,\"l\") ) - 2)"
  }
]