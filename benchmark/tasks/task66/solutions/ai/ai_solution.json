[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint cross_product(Point o, Point a, Point b) {\n    double val = (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : -1;\n}\n\nint compare(const void *vp1, const void *vp2) {\n    Point *p1 = (Point *)vp1;\n    Point *p2 = (Point *)vp2;\n    if (p1->x != p2->x) return (p1->x > p2->x) ? 1 : -1;\n    return (p1->y > p2->y) ? 1 : -1;\n}\n\nPoint* convex_hull(Point points[], int n, int *hull_size) {\n    if (n < 3) return NULL;\n    \n    qsort(points, n, sizeof(Point), compare);\n    \n    Point *hull = (Point *)malloc(2 * n * sizeof(Point));\n    int k = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        while (k >= 2 && cross_product(hull[k-2], hull[k-1], points[i]) <= 0)\n            k--;\n        hull[k++] = points[i];\n    }\n    \n    for (int i = n-2, t = k+1; i >= 0; --i) {\n        while (k >= t && cross_product(hull[k-2], hull[k-1], points[i]) <= 0)\n            k--;\n        hull[k++] = points[i];\n    }\n    \n    *hull_size = k-1;\n    return hull;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        Point points[100];\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n        }\n        \n        int hull_size;\n        Point *hull = convex_hull(points, n, &hull_size);\n        \n        printf(\"%d\\n\", n - hull_size);\n        free(hull);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:26:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class RubberBandProblem {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        \n        while (true) {\n            int n = Integer.parseInt(br.readLine());\n            if (n == 0) break;\n            \n            Point[] points = new Point[n];\n            for (int i = 0; i < n; i++) {\n                String[] coords = br.readLine().split(\" \");\n                points[i] = new Point(Double.parseDouble(coords[0]), Double.parseDouble(coords[1]));\n            }\n            \n            int result = solve(points);\n            out.println(result);\n        }\n        \n        out.flush();\n        out.close();\n    }\n    \n    static int solve(Point[] points) {\n        int n = points.length;\n        int notTouched = n;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int inside = 0;\n                for (int k = 0; k < n; k++) {\n                    if (k == i || k == j) continue;\n                    if (isInside(points[i], points[j], points[k])) {\n                        inside++;\n                    }\n                }\n                \n                if (inside == n - 2) {\n                    notTouched--;\n                }\n            }\n        }\n        \n        return notTouched;\n    }\n    \n    static boolean isInside(Point a, Point b, Point p) {\n        return crossProduct(a, b, p) == 0 && \n               dotProduct(a, b, p) >= 0 && \n               distance(a, p) + distance(p, b) <= distance(a, b) + 1e-9;\n    }\n    \n    static double crossProduct(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n    \n    static double dotProduct(Point a, Point b, Point p) {\n        return (p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y);\n    }\n    \n    static double distance(Point a, Point b) {\n        return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n    \n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:26:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    int index;\n};\n\nPoint pivot;\n\ndouble cross(const Point& a, const Point& b, const Point& c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distance(const Point& a, const Point& b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nbool angleCmp(const Point& a, const Point& b) {\n    double c = cross(pivot, a, b);\n    if (fabs(c) < 1e-9) return distance(pivot, a) < distance(pivot, b);\n    return c > 0;\n}\n\nvector<Point> convexHull(vector<Point>& points) {\n    int n = points.size();\n    if (n <= 3) return points;\n\n    int p = 0;\n    for (int i = 1; i < n; ++i) {\n        if (points[i].y < points[p].y || \n            (points[i].y == points[p].y && points[i].x < points[p].x)) {\n            p = i;\n        }\n    }\n\n    swap(points[0], points[p]);\n    pivot = points[0];\n    sort(points.begin() + 1, points.end(), angleCmp);\n\n    stack<Point> hull;\n    hull.push(points[0]);\n    hull.push(points[1]);\n\n    for (int i = 2; i < n; ++i) {\n        Point top = hull.top();\n        hull.pop();\n        while (!hull.empty() && cross(hull.top(), top, points[i]) <= 0) {\n            top = hull.top();\n            hull.pop();\n        }\n        hull.push(top);\n        hull.push(points[i]);\n    }\n\n    vector<Point> result;\n    while (!hull.empty()) {\n        result.push_back(hull.top());\n        hull.pop();\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    int n;\n    while (cin >> n && n != 0) {\n        vector<Point> points(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> points[i].x >> points[i].y;\n            points[i].index = i;\n        }\n\n        vector<Point> hull = convexHull(points);\n        cout << n - hull.size() << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:26:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_NAILS 100\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nint is_inside_convex_hull(Point* points, int n, Point p) {\n    int inside = 1;\n    for (int i = 0; i < n; i++) {\n        Point a = points[i];\n        Point b = points[(i + 1) % n];\n        if (cross_product(a, b, p) > 0) {\n            inside = 0;\n            break;\n        }\n    }\n    return inside;\n}\n\nint main() {\n    int dataset = 0;\n    while (1) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        if (n == 0) break;\n        \n        Point points[MAX_NAILS];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n        }\n        \n        int untouched_nails = 0;\n        for (int i = 0; i < n; i++) {\n            if (!is_inside_convex_hull(points, n, points[i])) {\n                untouched_nails++;\n            }\n        }\n        \n        printf(\"Dataset %d: %d\\n\", ++dataset, untouched_nails);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:27:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ndouble cross_product(const Point& o, const Point& a, const Point& b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n\ndouble distance(const Point& a, const Point& b) {\n    return std::sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool point_on_segment(const Point& p, const Point& a, const Point& b) {\n    return std::abs(cross_product(a, b, p)) < EPS &&\n           std::min(a.x, b.x) - EPS <= p.x && p.x <= std::max(a.x, b.x) + EPS &&\n           std::min(a.y, b.y) - EPS <= p.y && p.y <= std::max(a.y, b.y) + EPS;\n}\n\nbool is_inside_convex_hull(const std::vector<Point>& hull, const Point& p) {\n    int n = hull.size();\n    if (n < 3) return false;\n    \n    for (int i = 0; i < n; i++) {\n        double cp = cross_product(hull[i], hull[(i+1)%n], p);\n        if (cp < -EPS) return false;\n    }\n    return true;\n}\n\nstd::vector<Point> compute_convex_hull(std::vector<Point>& points) {\n    int n = points.size();\n    if (n <= 3) return points;\n    \n    int pivot = 0;\n    for (int i = 1; i < n; i++) {\n        if (points[i].x < points[pivot].x || \n            (points[i].x == points[pivot].x && points[i].y < points[pivot].y)) {\n            pivot = i;\n        }\n    }\n    \n    std::swap(points[0], points[pivot]);\n    Point& start = points[0];\n    \n    std::sort(points.begin() + 1, points.end(), [&start](const Point& a, const Point& b) {\n        double cp = cross_product(start, a, b);\n        if (std::abs(cp) < EPS) return distance(start, a) < distance(start, b);\n        return cp > 0;\n    });\n    \n    std::vector<Point> hull;\n    hull.push_back(points[0]);\n    hull.push_back(points[1]);\n    \n    for (int i = 2; i < n; i++) {\n        while (hull.size() > 1) {\n            Point top = hull.back();\n            hull.pop_back();\n            if (cross_product(hull.back(), top, points[i]) > -EPS) {\n                hull.push_back(top);\n                break;\n            }\n        }\n        hull.push_back(points[i]);\n    }\n    \n    return hull;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    while (std::cin >> n && n != 0) {\n        std::vector<Point> points(n);\n        for (int i = 0; i < n; i++) {\n            std::cin >> points[i].x >> points[i].y;\n        }\n        \n        std::vector<Point> hull = compute_convex_hull(points);\n        \n        int count_outside = 0;\n        for (const Point& p : points) {\n            bool is_on_hull = false;\n            for (int i = 0; i < hull.size(); i++) {\n                if (point_on_segment(p, hull[i], hull[(i+1)%hull.size()])) {\n                    is_on_hull = true;\n                    break;\n                }\n            }\n            \n            if (!is_on_hull && !is_inside_convex_hull(hull, p)) {\n                count_outside++;\n            }\n        }\n        \n        std::cout << count_outside << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:27:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Point implements Comparable<Point> {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(Point p) {\n            if (this.x != p.x) return Double.compare(this.x, p.x);\n            return Double.compare(this.y, p.y);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            Point point = (Point) obj;\n            return Double.compare(point.x, x) == 0 && Double.compare(point.y, y) == 0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            Point[] points = new Point[n];\n            for (int i = 0; i < n; i++) {\n                double x = scanner.nextDouble();\n                double y = scanner.nextDouble();\n                points[i] = new Point(x, y);\n            }\n            List<Point> hull = convexHull(points);\n            System.out.println(n - hull.size());\n        }\n    }\n\n    private static List<Point> convexHull(Point[] points) {\n        if (points.length <= 1) return Arrays.asList(points);\n        Arrays.sort(points);\n        List<Point> lower = new ArrayList<>();\n        for (Point p : points) {\n            while (lower.size() >= 2 && cross(lower.get(lower.size() - 2), lower.get(lower.size() - 1), p) <= 0) {\n                lower.remove(lower.size() - 1);\n            }\n            lower.add(p);\n        }\n        List<Point> upper = new ArrayList<>();\n        for (int i = points.length - 1; i >= 0; i--) {\n            Point p = points[i];\n            while (upper.size() >= 2 && cross(upper.get(upper.size() - 2), upper.get(upper.size() - 1), p) <= 0) {\n                upper.remove(upper.size() - 1);\n            }\n            upper.add(p);\n        }\n        lower.addAll(upper.subList(1, upper.size() - 1));\n        return lower;\n    }\n\n    private static double cross(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n}",
    "timestamp": "2025-08-05 18:28:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import namedtuple\n\nPoint = namedtuple('Point', ['x', 'y'])\n\ndef ccw(p1, p2, p3):\n    \"\"\" Check if the triplet (p1, p2, p3) form a counter-clockwise turn\"\"\"\n    return (p2.y - p1.y) * (p3.x - p2.x) > (p2.x - p1.x) * (p3.y - p2.y)\n\ndef convex_hull(points):\n    \"\"\" Compute the convex hull of a set of 2D points using Graham's scan algorithm \"\"\"\n    points = sorted(points, key=lambda p: (p.x, p.y))\n    if len(points) <= 1:\n        return points\n\n    # Build the lower hull \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and not ccw(lower[-2], lower[-1], p):\n            lower.pop()\n        lower.append(p)\n\n    # Build the upper hull\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and not ccw(upper[-2], upper[-1], p):\n            upper.pop()\n        upper.append(p)\n\n    # Concatenate lower and upper hull to obtain the full hull\n    return lower[:-1] + upper[:-1]\n\ndef process_dataset(points):\n    hull = convex_hull(points)\n    num_nails_touching_band = len(set(hull))\n    return len(points) - num_nails_touching_band\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n\n    index = 0\n    while index < len(data):\n        n = int(data[index].strip())\n        if n == 0:\n            break\n\n        points = []\n        for i in range(n):\n            x, y = map(float, data[index + 1 + i].strip().split())\n            points.append(Point(x, y))\n        index += 1 + n\n\n        result = process_dataset(points)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-12 23:13:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.awt.geom.Point2D;\n\npublic class NailCounter {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            List<Point2D> nails = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                double x = scanner.nextDouble();\n                double y = scanner.nextDouble();\n                nails.add(new Point2D.Double(x, y));\n            }\n            \n            List<Point2D> hull = convexHull(nails);\n            int countOutside = n - hull.size();\n            System.out.println(countOutside);\n        }\n        scanner.close();\n    }\n\n    private static List<Point2D> convexHull(List<Point2D> points) {\n        int n = points.size();\n        if (n < 3) return new ArrayList<>();\n\n        points.sort((p1, p2) -> {\n            int cmpX = Double.compare(p1.getX(), p2.getX());\n            return cmpX != 0 ? cmpX : Double.compare(p1.getY(), p2.getY());\n        });\n\n        List<Point2D> hull = new ArrayList<>();\n\n        // Lower hull\n        for (Point2D p : points) {\n            while (hull.size() >= 2 && ccw(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) <= 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n\n        // Upper hull\n        int t = hull.size() + 1;\n        for (int i = n - 1; i >= 0; i--) {\n            Point2D p = points.get(i);\n            while (hull.size() >= t && ccw(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) <= 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n\n        hull.remove(hull.size() - 1); // Remove the last point because it's the starting point\n        return hull;\n    }\n\n    private static double ccw(Point2D a, Point2D b, Point2D c) {\n        return (b.getX() - a.getX()) * (c.getY() - a.getY()) - \n               (b.getY() - a.getY()) * (c.getX() - a.getX());\n    }\n}",
    "timestamp": "2025-08-12 23:13:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint compare(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->x != p2->x)\n        return (p1->x < p2->x) ? -1 : 1;\n    return (p1->y < p2->y) ? -1 : 1;\n}\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nvoid findConvexHull(Point *points, int n, Point *hull, int *hullSize) {\n    qsort(points, n, sizeof(Point), compare);\n    *hullSize = 0;\n\n    for (int i = 0; i < n; i++) {\n        while (*hullSize >= 2 && cross(hull[*hullSize - 2], hull[*hullSize - 1], points[i]) <= 0)\n            (*hullSize)--;\n        hull[(*hullSize)++] = points[i];\n    }\n\n    int t = *hullSize + 1;\n    for (int i = n - 1; i > 0; i--) {\n        while (*hullSize >= t && cross(hull[*hullSize - 2], hull[*hullSize - 1], points[i - 1]) <= 0)\n            (*hullSize)--;\n        hull[(*hullSize)++] = points[i - 1];\n    }\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n), n != 0) {\n        Point points[100], hull[100];\n        int hullSize;\n        for (int i = 0; i < n; i++)\n            scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n\n        findConvexHull(points, n, hull, &hullSize);\n\n        int onHull[100] = {0};\n        for (int i = 0; i < hullSize; i++) {\n            for (int j = 0; j < n; j++) {\n                if (hull[i].x == points[j].x && hull[i].y == points[j].y) {\n                    onHull[j] = 1;\n                    break;\n                }\n            }\n        }\n\n        int result = 0;\n        for (int i = 0; i < n; i++)\n            if (!onHull[i])\n                result++;\n        \n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-12 23:13:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def convex_hull(points):\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def is_in_convex_hull(point, hull):\n        n = len(hull)\n        for i in range(n):\n            if cross_product(hull[i], hull[(i+1)%n], point) > 0:\n                return False\n        return True\n\n    points.sort()\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    hull = lower[:-1] + upper[:-1]\n    return [p for p in points if is_in_convex_hull(p, hull)]\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n\n    points = []\n    for _ in range(n):\n        x, y = map(float, input().split())\n        points.append((x, y))\n\n    touched_points = convex_hull(points)\n    print(n - len(touched_points))",
    "timestamp": "2025-08-12 23:13:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef readints():\n    return list(map(float, sys.stdin.readline().split()))\n\ndef cross(o, a, b):\n    return (a[0] - o[0])*(b[1] - o[1]) - (a[1] - o[1])*(b[0] - o[0])\n\ndef convex_hull(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\ndef solve():\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        n = int(line.strip())\n        if n == 0:\n            break\n        points = []\n        for _ in range(n):\n            x, y = readints()\n            points.append((x, y))\n        hull = convex_hull(points)\n        print(n - len(hull))\n\nif __name__ == '__main__':\n    solve()",
    "timestamp": "2025-08-12 23:14:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstruct Point {\n    double x, y;\n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\ndouble cross(const Point& O, const Point& A, const Point& B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nstd::vector<Point> convexHull(std::vector<Point>& P) {\n    size_t n = P.size(), k = 0;\n    if (n <= 1) return P;\n\n    std::sort(P.begin(), P.end());\n    std::vector<Point> H(2 * n);\n\n    for (size_t i = 0; i < n; ++i) {\n        while (k >= 2 && cross(H[k - 2], H[k - 1], P[i]) <= 0) k--;\n        H[k++] = P[i];\n    }\n\n    for (size_t i = n - 1, t = k; i > 0; --i) {\n        while (k > t && cross(H[k - 2], H[k - 1], P[i - 1]) <= 0) k--;\n        H[k++] = P[i - 1];\n    }\n\n    H.resize(k - 1);\n    return H;\n}\n\nint main() {\n    int n;\n    while (std::cin >> n && n != 0) {\n        std::vector<Point> nails(n);\n        for (int i = 0; i < n; ++i) {\n            std::cin >> nails[i].x >> nails[i].y;\n        }\n        std::vector<Point> hull = convexHull(nails);\n        int hullSize = hull.size();\n        std::cout << n - hullSize << std::endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 10:49:11"
  }
]