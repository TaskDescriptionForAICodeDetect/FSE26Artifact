[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n    char dir;\n    int num;\n    int active;\n} Ant;\n\nint compare(const void *a, const void *b) {\n    Ant *antA = (Ant *)a;\n    Ant *antB = (Ant *)b;\n    if (antA->active != antB->active) {\n        return antB->active - antA->active;\n    }\n    return antA->num - antB->num;\n}\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    Ant *ants = (Ant *)malloc(N * sizeof(Ant));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %c\", &ants[i].y, &ants[i].x, &ants[i].dir);\n        ants[i].num = i + 1;\n        ants[i].active = 1;\n    }\n\n    int time = 0;\n    int remaining = N;\n    while (remaining > 0) {\n        // Sort ants by active status and number\n        qsort(ants, N, sizeof(Ant), compare);\n\n        // Check for collisions\n        for (int i = 0; i < N; i++) {\n            if (!ants[i].active) continue;\n            for (int j = i + 1; j < N; j++) {\n                if (!ants[j].active) continue;\n                if (ants[i].x == ants[j].x && ants[i].y == ants[j].y) {\n                    int color = (ants[i].x + ants[i].y) % 2;\n                    if (color == 0) { // White square\n                        char temp = ants[i].dir;\n                        ants[i].dir = ants[j].dir;\n                        ants[j].dir = temp;\n                    }\n                }\n            }\n        }\n\n        // Move ants and check for fall-offs\n        int *fall_offs = (int *)malloc(N * sizeof(int));\n        int fall_count = 0;\n        for (int i = 0; i < N; i++) {\n            if (!ants[i].active) continue;\n            int nx = ants[i].x, ny = ants[i].y;\n            if (ants[i].dir == 'E') nx++;\n            else if (ants[i].dir == 'S') ny++;\n\n            if (nx < 1 || nx > W || ny < 1 || ny > H) {\n                fall_offs[fall_count++] = ants[i].num;\n                ants[i].active = 0;\n                remaining--;\n            } else {\n                ants[i].x = nx;\n                ants[i].y = ny;\n            }\n        }\n\n        // Sort and print fall-offs\n        for (int i = 0; i < fall_count; i++) {\n            for (int j = i + 1; j < fall_count; j++) {\n                if (fall_offs[i] > fall_offs[j]) {\n                    int temp = fall_offs[i];\n                    fall_offs[i] = fall_offs[j];\n                    fall_offs[j] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < fall_count; i++) {\n            printf(\"%d\\n\", fall_offs[i]);\n        }\n        free(fall_offs);\n        time++;\n    }\n\n    free(ants);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AntChessboard {\n    public static void solve(int H, int W, List<Ant> ants) {\n        int[] fallOrder = new int[ants.size() + 1];\n        int fallCount = 0;\n        boolean[][] board = new boolean[H][W];\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                board[i][j] = (i + j) % 2 == 0;\n            }\n        }\n        \n        while (!ants.isEmpty()) {\n            Set<String> positions = new HashSet<>();\n            Set<Ant> collidedAnts = new HashSet<>();\n            \n            for (Ant ant : ants) {\n                ant.move();\n                \n                if (ant.isOutOfBounds(H, W)) {\n                    fallOrder[++fallCount] = ant.number;\n                    continue;\n                }\n                \n                String pos = ant.x + \",\" + ant.y;\n                if (positions.contains(pos)) {\n                    collidedAnts.add(ant);\n                }\n                positions.add(pos);\n            }\n            \n            for (Ant ant1 : collidedAnts) {\n                for (Ant ant2 : ants) {\n                    if (ant1 != ant2 && ant1.x == ant2.x && ant1.y == ant2.y) {\n                        if (board[ant1.x][ant1.y]) {\n                            if (ant1.dir == 'E') ant1.dir = 'S';\n                            if (ant2.dir == 'S') ant2.dir = 'E';\n                        }\n                    }\n                }\n            }\n            \n            ants.removeIf(Ant::isOutOfBounds);\n        }\n        \n        for (int i = 1; i <= fallCount; i++) {\n            System.out.println(fallOrder[i]);\n        }\n    }\n    \n    static class Ant {\n        int number;\n        int x, y;\n        char dir;\n        \n        Ant(int number, int x, int y, char dir) {\n            this.number = number;\n            this.x = x;\n            this.y = y;\n            this.dir = dir;\n        }\n        \n        void move() {\n            if (dir == 'E') y++;\n            else x++;\n        }\n        \n        boolean isOutOfBounds(int H, int W) {\n            return x < 0 || x >= H || y < 0 || y >= W;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        int N = scanner.nextInt();\n        \n        List<Ant> ants = new ArrayList<>();\n        for (int i = 1; i <= N; i++) {\n            int x = scanner.nextInt() - 1;\n            int y = scanner.nextInt() - 1;\n            char dir = scanner.next().charAt(0);\n            ants.add(new Ant(i, x, y, dir));\n        }\n        \n        solve(H, W, ants);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:44:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <tuple>\n\nusing namespace std;\n\nstruct Ant {\n    int id;\n    int x, y;\n    char dir;\n};\n\nbool isWhite(int x, int y) {\n    return (x + y) % 2 == 0;\n}\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    vector<Ant> ants(N);\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        char dir;\n        cin >> x >> y >> dir;\n        ants[i] = {i + 1, x - 1, y - 1, dir};\n    }\n\n    vector<int> fall_order;\n    set<int> active_ants;\n    for (int i = 0; i < N; ++i) {\n        active_ants.insert(i);\n    }\n\n    while (!active_ants.empty()) {\n        vector<tuple<int, int, int>> events; // time, id, type (0=fall, 1=collision)\n        for (int i : active_ants) {\n            Ant &ant = ants[i];\n            if (ant.dir == 'E') {\n                if (ant.y + 1 >= W) {\n                    events.emplace_back(ant.x, ant.id, 0);\n                }\n            } else if (ant.dir == 'S') {\n                if (ant.x + 1 >= H) {\n                    events.emplace_back(ant.y, ant.id, 0);\n                }\n            }\n        }\n\n        // Check for collisions\n        vector<vector<int>> grid(H, vector<int>(W, -1));\n        for (int i : active_ants) {\n            Ant &ant = ants[i];\n            if (grid[ant.x][ant.y] != -1) {\n                int j = grid[ant.x][ant.y];\n                events.emplace_back(ant.x + ant.y, -1, 1);\n            } else {\n                grid[ant.x][ant.y] = i;\n            }\n        }\n\n        if (events.empty()) {\n            // Move all ants\n            for (int i : active_ants) {\n                Ant &ant = ants[i];\n                if (ant.dir == 'E') {\n                    ant.y += 1;\n                } else if (ant.dir == 'S') {\n                    ant.x += 1;\n                }\n            }\n            continue;\n        }\n\n        sort(events.begin(), events.end());\n        int min_time = get<0>(events[0]);\n        set<int> to_remove;\n\n        for (auto &event : events) {\n            int time = get<0>(event);\n            if (time != min_time) break;\n            int id = get<1>(event);\n            int type = get<2>(event);\n            if (type == 0) {\n                to_remove.insert(id - 1);\n            } else {\n                // Handle collisions at min_time\n                vector<pair<int, int>> positions;\n                for (int i : active_ants) {\n                    Ant &ant = ants[i];\n                    if (ant.x + ant.y == min_time) {\n                        positions.emplace_back(ant.x, i);\n                    }\n                }\n                sort(positions.begin(), positions.end());\n                for (size_t k = 0; k + 1 < positions.size(); ++k) {\n                    int i = positions[k].second;\n                    int j = positions[k + 1].second;\n                    Ant &ant1 = ants[i];\n                    Ant &ant2 = ants[j];\n                    if (ant1.x == ant2.x && ant1.y == ant2.y) {\n                        if (isWhite(ant1.x, ant1.y)) {\n                            ant1.dir = 'S';\n                            ant2.dir = 'E';\n                        }\n                    }\n                }\n            }\n        }\n\n        // Move ants that didn't fall or collide\n        for (int i : active_ants) {\n            if (to_remove.count(i)) continue;\n            Ant &ant = ants[i];\n            if (ant.dir == 'E') {\n                ant.y += 1;\n            } else if (ant.dir == 'S') {\n                ant.x += 1;\n            }\n        }\n\n        // Remove fallen ants\n        vector<int> to_remove_vec(to_remove.begin(), to_remove.end());\n        sort(to_remove_vec.begin(), to_remove_vec.end(), [&](int a, int b) {\n            return ants[a].id < ants[b].id;\n        });\n        for (int i : to_remove_vec) {\n            fall_order.push_back(ants[i].id);\n            active_ants.erase(i);\n        }\n    }\n\n    for (int id : fall_order) {\n        cout << id << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:45:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int x, y, dir, num;\n    int fallen;\n} Ant;\n\nint H, W, N;\nAnt ants[MAX_N];\n\nint is_white_square(int x, int y) {\n    return (x + y) % 2 == 0;\n}\n\nvoid simulate() {\n    int time = 0;\n    int fallen_count = 0;\n    int fallen_order[MAX_N];\n    memset(fallen_order, 0, sizeof(fallen_order));\n\n    while (fallen_count < N) {\n        int new_x[MAX_N], new_y[MAX_N];\n        int collision[MAX_N][MAX_N] = {0};\n\n        for (int i = 0; i < N; i++) {\n            if (ants[i].fallen) continue;\n\n            if (ants[i].dir == 0) {  // East\n                new_x[i] = ants[i].x;\n                new_y[i] = ants[i].y + 1;\n            } else {  // South\n                new_x[i] = ants[i].x + 1;\n                new_y[i] = ants[i].y;\n            }\n\n            if (new_x[i] < 0 || new_x[i] >= H || new_y[i] < 0 || new_y[i] >= W) {\n                ants[i].fallen = 1;\n                fallen_order[ants[i].num - 1] = ++fallen_count;\n                continue;\n            }\n\n            collision[new_x[i]][new_y[i]]++;\n        }\n\n        for (int i = 0; i < N; i++) {\n            if (ants[i].fallen) continue;\n\n            if (collision[new_x[i]][new_y[i]] > 1) {\n                if (is_white_square(new_x[i], new_y[i])) {\n                    ants[i].dir = 1 - ants[i].dir;\n                }\n            }\n\n            ants[i].x = new_x[i];\n            ants[i].y = new_y[i];\n        }\n\n        time++;\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d\\n\", fallen_order[i]);\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    for (int i = 0; i < N; i++) {\n        int x, y, dir;\n        scanf(\"%d %d %c\", &x, &y, (char*)&dir);\n        ants[i].x = x - 1;\n        ants[i].y = y - 1;\n        ants[i].num = i + 1;\n        ants[i].fallen = 0;\n        ants[i].dir = (dir == 'S') ? 1 : 0;\n    }\n\n    simulate();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Ant {\n    int id, x, y, dir;\n};\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    \n    vector<Ant> ants(N);\n    vector<bool> fallen(N, false);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> ants[i].x >> ants[i].y >> ants[i].dir;\n        ants[i].id = i + 1;\n    }\n    \n    vector<int> fallOrder;\n    int time = 0;\n    \n    while (count(fallen.begin(), fallen.end(), false) > 0) {\n        vector<vector<int>> board(H + 1, vector<int>(W + 1, 0));\n        \n        // Move ants\n        for (int i = 0; i < N; i++) {\n            if (!fallen[i]) {\n                if (ants[i].dir == 1) ants[i].x++;\n                else ants[i].y++;\n                \n                // Check if ant falls off\n                if (ants[i].x < 1 || ants[i].x > W || ants[i].y < 1 || ants[i].y > H) {\n                    fallen[i] = true;\n                    fallOrder.push_back(ants[i].id);\n                    continue;\n                }\n                \n                board[ants[i].y][ants[i].x]++;\n            }\n        }\n        \n        // Handle collisions\n        for (int i = 0; i < N; i++) {\n            if (!fallen[i]) {\n                if (board[ants[i].y][ants[i].x] > 1) {\n                    // Check square color\n                    bool isWhite = (ants[i].x + ants[i].y) % 2 == 1;\n                    \n                    if (isWhite) {\n                        // White square: change direction\n                        ants[i].dir = (ants[i].dir == 1) ? 2 : 1;\n                    }\n                }\n            }\n        }\n        \n        time++;\n    }\n    \n    // Print fall order\n    for (int id : fallOrder) {\n        cout << id << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Ant {\n    int id, x, y;\n    char direction;\n\n    Ant(int id, int x, int y, char direction) {\n        this.id = id;\n        this.x = x;\n        this.y = y;\n        this.direction = direction;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int N = sc.nextInt();\n        List<Ant> ants = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int y = sc.nextInt() - 1;\n            int x = sc.nextInt() - 1;\n            char d = sc.next().charAt(0);\n            ants.add(new Ant(i + 1, x, y, d));\n        }\n\n        List<Integer> result = new ArrayList<>();\n        boolean[][] occupied = new boolean[W][H];\n        PriorityQueue<Ant>[][] queues = new PriorityQueue[W][H];\n        for (int x = 0; x < W; x++) {\n            for (int y = 0; y < H; y++) {\n                queues[x][y] = new PriorityQueue<>(Comparator.comparingInt(a -> a.id));\n            }\n        }\n\n        for (Ant ant : ants) {\n            queues[ant.x][ant.y].add(ant);\n        }\n\n        while (true) {\n            List<Ant> movedAnts = new ArrayList<>();\n            boolean anyMoved = false;\n\n            for (int x = 0; x < W; x++) {\n                for (int y = 0; y < H; y++) {\n                    if (!queues[x][y].isEmpty()) {\n                        anyMoved = true;\n                        Ant ant = queues[x][y].poll();\n                        int newX = ant.x;\n                        int newY = ant.y;\n                        if (ant.direction == 'E') {\n                            newX++;\n                        } else if (ant.direction == 'S') {\n                            newY++;\n                        }\n\n                        if (newX < 0 || newX >= W || newY < 0 || newY >= H) {\n                            result.add(ant.id);\n                        } else {\n                            ant.x = newX;\n                            ant.y = newY;\n                            movedAnts.add(ant);\n                        }\n                    }\n                }\n            }\n\n            if (!anyMoved) break;\n\n            for (Ant ant : movedAnts) {\n                queues[ant.x][ant.y].add(ant);\n            }\n\n            for (int x = 0; x < W; x++) {\n                for (int y = 0; y < H; y++) {\n                    if (queues[x][y].size() == 2) {\n                        Ant a1 = queues[x][y].poll();\n                        Ant a2 = queues[x][y].poll();\n                        boolean isWhite = (x + y) % 2 == 0;\n                        if (isWhite) {\n                            a1.direction = a1.direction == 'E' ? 'S' : 'E';\n                            a2.direction = a2.direction == 'E' ? 'S' : 'E';\n                        }\n                        queues[x][y].add(a1);\n                        queues[x][y].add(a2);\n                    }\n                }\n            }\n        }\n\n        for (int id : result) {\n            System.out.println(id);\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:46:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def ant_simulation(H, W, ants):\n    def is_white(i, j):\n        return (i + j) % 2 == 0\n\n    ants = {num: [row, col, direction] for num, row, col, direction in ants}\n    fallen_order = []\n\n    while len(ants) > 0:\n        move_positions = {}\n        for num, (row, col, direction) in ants.items():\n            if direction == 'E':\n                new_pos = (row, col + 1)\n            else:\n                new_pos = (row + 1, col)\n\n            if (0 <= new_pos[0] < H) and (0 <= new_pos[1] < W):\n                if new_pos not in move_positions:\n                    move_positions[new_pos] = []\n                move_positions[new_pos].append(num)\n            else:\n                fallen_order.append(num)\n\n        for pos, ant_nums in move_positions.items():\n            if len(ant_nums) == 2:\n                num1, num2 = ant_nums\n                row, col = pos\n                if is_white(row, col):\n                    ants[num1][2], ants[num2][2] = (\n                        'S' if ants[num1][2] == 'E' else 'E',\n                        'S' if ants[num2][2] == 'E' else 'E'\n                    )\n            for num in ant_nums:\n                ants[num][:2] = pos\n\n        for num in fallen_order:\n            if num in ants:\n                del ants[num]\n\n    return fallen_order\n\n\n# Example usage\nH, W = 3, 3\nants = [\n    (1, 0, 0, 'E'),\n    (2, 0, 1, 'S'),\n    (3, 1, 1, 'E'),\n    (4, 2, 1, 'S')\n]\n\nprint(ant_simulation(H, W, ants))",
    "timestamp": "2025-08-13 00:45:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class AntFallSequence {\n    static class Ant {\n        int id;\n        int x, y;\n        char direction;\n        \n        Ant(int id, int x, int y, char direction) {\n            this.id = id;\n            this.x = x;\n            this.y = y;\n            this.direction = direction;\n        }\n    }\n    \n    public static List<Integer> findFallSequence(int H, int W, List<Ant> ants) {\n        List<Integer> result = new ArrayList<>();\n        boolean[][] board = new boolean[H][W]; // true: white, false: black\n        \n        // Initialize board colors\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                board[i][j] = (i + j) % 2 == 0; // true if white\n            }\n        }\n\n        while (!ants.isEmpty()) {\n            Map<String, List<Ant>> positionMap = new HashMap<>();\n            List<Integer> fallenAnts = new ArrayList<>();\n            \n            for (Ant ant : ants) {\n                // Move ant\n                if (ant.direction == 'E') {\n                    ant.y++;\n                } else {\n                    ant.x++;\n                }\n                \n                // Check if ant falls off the board\n                if (ant.x >= H || ant.y >= W) {\n                    fallenAnts.add(ant.id);\n                } else {\n                    // Record ant position\n                    String positionKey = ant.x + \",\" + ant.y;\n                    positionMap.computeIfAbsent(positionKey, k -> new ArrayList<>()).add(ant);\n                }\n            }\n            \n            // Handle positions with multiple ants\n            for (List<Ant> antGroup : positionMap.values()) {\n                if (antGroup.size() == 2) {\n                    Ant ant1 = antGroup.get(0);\n                    Ant ant2 = antGroup.get(1);\n                    \n                    // Get board color\n                    if (board[ant1.x][ant1.y]) {\n                        // White square\n                        ant1.direction = (ant1.direction == 'E') ? 'S' : 'E';\n                        ant2.direction = (ant2.direction == 'E') ? 'S' : 'E';\n                    }\n                }\n            }\n            \n            // Sort fallen ants by ID and add to result\n            Collections.sort(fallenAnts);\n            result.addAll(fallenAnts);\n\n            // Remove fallen ants from list\n            ants.removeIf(ant -> fallenAnts.contains(ant.id));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Ant> ants = Arrays.asList(\n            new Ant(1, 0, 0, 'E'),\n            new Ant(2, 1, 0, 'S'),\n            new Ant(3, 2, 0, 'E'),\n            new Ant(4, 3, 0, 'S')\n        );\n        \n        System.out.println(findFallSequence(4, 4, ants)); // Example input and expected output\n    }\n}",
    "timestamp": "2025-08-13 00:45:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int number;\n    int x, y;\n    char direction; // 'E' for East, 'S' for South\n    int fallen;\n} Ant;\n\nint is_white(int x, int y) {\n    return (x + y) % 2 == 0;\n}\n\nint cmp_ants(const void *a, const void *b) {\n    Ant *antA = (Ant *)a;\n    Ant *antB = (Ant *)b;\n    return antA->number - antB->number;\n}\n\nvoid move_ants(Ant ants[], int N, int H, int W) {\n    int fallen_count = 0;\n    int step = 0;\n    while (fallen_count < N) {\n        step++;\n        // Move ants\n        for (int i = 0; i < N; i++) {\n            if (ants[i].fallen)\n                continue;\n            \n            if (ants[i].direction == 'E')\n                ants[i].y++;\n            else\n                ants[i].x++;\n            \n            if (ants[i].x >= H || ants[i].y >= W) {\n                ants[i].fallen = step;\n                fallen_count++;\n            }\n        }\n        \n        // Handle collisions\n        for (int i = 0; i < N; i++) {\n            if (ants[i].fallen)\n                continue;\n            \n            for (int j = i + 1; j < N; j++) {\n                if (ants[j].fallen)\n                    continue;\n                \n                if (ants[i].x == ants[j].x && ants[i].y == ants[j].y) {\n                    if (is_white(ants[i].x, ants[i].y)) {\n                        char temp = ants[i].direction;\n                        ants[i].direction = ants[j].direction;\n                        ants[j].direction = temp;\n                    }\n                }\n            }\n        }\n    }\n    \n    qsort(ants, N, sizeof(Ant), cmp_ants);\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d\\n\", ants[i].number);\n    }\n}\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d\", &H, &W);\n    scanf(\"%d\", &N);\n\n    Ant ants[N];\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %c\", &ants[i].x, &ants[i].y, &ants[i].direction);\n        ants[i].number = i + 1;\n        ants[i].fallen = 0;\n    }\n\n    move_ants(ants, N, H, W);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 00:45:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_ants(H, W, ants):\n    # Sort ants by their initial position\n    ants.sort(key=lambda x: (x[0], x[1]))\n    \n    # Track ant directions and positions\n    directions = {}\n    positions = {}\n    fallen = []\n    \n    # Initialize ant positions and directions\n    for i, (r, c, d) in enumerate(ants, 1):\n        directions[i] = d\n        positions[i] = (r, c)\n    \n    # Simulate ant movements\n    while positions:\n        # Calculate next positions\n        next_positions = {}\n        fallen_this_turn = []\n        \n        for ant, (r, c) in positions.items():\n            # Move ant based on direction\n            if directions[ant] == 'E':\n                c += 1\n            else:  # 'S'\n                r += 1\n            \n            # Check if ant falls off\n            if r < 0 or r >= H or c < 0 or c >= W:\n                fallen_this_turn.append(ant)\n                continue\n            \n            # Track new position\n            next_positions[ant] = (r, c)\n        \n        # Remove fallen ants\n        for ant in fallen_this_turn:\n            del positions[ant]\n            del directions[ant]\n            fallen.append(ant)\n        \n        # Handle collisions\n        position_counts = {}\n        for ant, pos in next_positions.items():\n            position_counts[pos] = position_counts.get(pos, []) + [ant]\n        \n        for pos, colliding_ants in position_counts.items():\n            if len(colliding_ants) > 1:\n                # Check square color\n                r, c = pos\n                is_white = (r + c) % 2 == 0\n                \n                if is_white:\n                    # Change directions for white squares\n                    for ant in colliding_ants:\n                        directions[ant] = 'S' if directions[ant] == 'E' else 'E'\n        \n        # Update positions\n        positions = next_positions\n    \n    return fallen\n\n# Input parsing and output\ndef main():\n    H, W, N = map(int, input().split())\n    ants = []\n    for _ in range(N):\n        r, c, d = input().split()\n        ants.append((int(r)-1, int(c)-1, d))\n    \n    result = solve_ants(H, W, ants)\n    for ant in result:\n        print(ant)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 00:45:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    H, W, N = map(int, sys.stdin.readline().split())\n    ants = []\n    pos_to_ants = defaultdict(list)\n    for i in range(1, N+1):\n        r, c, d = sys.stdin.readline().split()\n        r = int(r) - 1\n        c = int(c) - 1\n        direction = 0 if d == 'E' else 1  # 0: east, 1: south\n        ants.append((r, c, direction, i))\n        pos_to_ants[(r, c)].append((direction, i))\n    \n    fallen = [False] * (N + 1)\n    output = []\n    \n    while True:\n        moves = defaultdict(list)\n        # Collect all new positions\n        for r, c, direction, i in ants:\n            if fallen[i]:\n                continue\n            dr, dc = (0, 1) if direction == 0 else (1, 0)\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W:\n                moves[(nr, nc)].append((direction, i))\n            else:\n                output.append(i)\n                fallen[i] = True\n        \n        if not moves:\n            break\n        \n        # Process collisions\n        for (nr, nc), ant_list in moves.items():\n            if len(ant_list) == 1:\n                direction, i = ant_list[0]\n                # Update ant's position\n                for idx in range(len(ants)):\n                    if ants[idx][3] == i:\n                        ants[idx] = (nr, nc, direction, i)\n                        break\n            else:\n                # Check color of the square\n                color = (nr + nc) % 2  # 0: white, 1: black\n                if color == 0:\n                    # White: swap directions\n                    new_directions = []\n                    for direction, i in ant_list:\n                        new_direction = 1 - direction\n                        new_directions.append((new_direction, i))\n                    # Update ants' positions and directions\n                    for new_dir, i in new_directions:\n                        for idx in range(len(ants)):\n                            if ants[idx][3] == i:\n                                ants[idx] = (nr, nc, new_dir, i)\n                                break\n                else:\n                    # Black: no change in direction, just update positions\n                    for direction, i in ant_list:\n                        for idx in range(len(ants)):\n                            if ants[idx][3] == i:\n                                ants[idx] = (nr, nc, direction, i)\n                                break\n    \n    print('\\n'.join(map(str, output)))\n\nsolve()",
    "timestamp": "2025-08-13 00:46:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Ant {\n    int id;\n    int x, y;\n    char direction;\n\n    bool operator<(const Ant &other) const {\n        return (id < other.id);\n    }\n};\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    \n    vector<Ant> ants(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> ants[i].x >> ants[i].y >> ants[i].direction;\n        ants[i].id = i + 1;\n    }\n\n    vector<int> fall_sequence;\n    int time = 0;\n\n    while (fall_sequence.size() < N) {\n        // Move ants\n        for (auto &ant : ants) {\n            if (ant.direction == 'E') ant.y += 1;\n            else if (ant.direction == 'S') ant.x += 1;\n        }\n\n        // Check for falling ants\n        vector<int> fallen_ants;\n        for (int i = 0; i < N; ++i) {\n            if (ants[i].x < 0 || ants[i].x >= H || ants[i].y < 0 || ants[i].y >= W) {\n                fallen_ants.push_back(ants[i].id);\n            }\n        }\n        \n        // Sort fallen ants by id\n        sort(fallen_ants.begin(), fallen_ants.end());\n        \n        // Add fallen ants to fall sequence and remove from list\n        for (auto fid : fallen_ants) {\n            fall_sequence.push_back(fid);\n            ants.erase(remove_if(ants.begin(), ants.end(), [&fid](const Ant &a) { return a.id == fid; }), ants.end());\n        }\n\n        // Check for collisions and handle direction change\n        for (int i = 0; i < ants.size(); ++i) {\n            for (int j = i + 1; j < ants.size(); ++j) {\n                if (ants[i].x == ants[j].x && ants[i].y == ants[j].y) {\n                    int color = (ants[i].x + ants[i].y) % 2; // 0 for white, 1 for black\n                    if (color == 0) { // White square\n                        if (ants[i].direction == 'E') ants[i].direction = 'S';\n                        else if (ants[i].direction == 'S') ants[i].direction = 'E';\n                        if (ants[j].direction == 'E') ants[j].direction = 'S';\n                        else if (ants[j].direction == 'S') ants[j].direction = 'E';\n                    }\n                }\n            }\n        }\n        \n        time++;\n    }\n\n    for (int id : fall_sequence) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:55:48"
  }
]