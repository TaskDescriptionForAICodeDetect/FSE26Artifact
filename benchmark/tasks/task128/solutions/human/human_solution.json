[
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0354\n\n#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nconst int inf = 1e9 + 7;\nusing namespace std;\n\nvector <int> mv[2];\nint n, w, h, x[N], y[N], p[N], ans[N];\nchar s[N];\n\nvoid cal(vector <int> & a, bool ck){\n    queue <int> Q1, Q2;\n    for (int i = 0; i < a.size(); i++) {\n        if (s[a[i]] == 'E') Q1.push(a[i]);\n        else Q2.push(a[i]);\n    }\n\n//    if (a.size() > 0) cout << a[0] << \" \" << x[a[0]] << \" \" << y[a[0]] << \" \" << s[a[0]] << \"\\n\";\n//    if (a.size() > 1) cout << a[1] << \" \" << x[a[1]] << \" \" << y[a[1]] << \" \" << s[a[1]] << \"\\n\";\n\n    for (int i = 0; i < a.size(); i++){\n        int E = ((Q1.size()) ? Q1.front() : inf), S = ((Q2.size()) ? Q2.front() : inf);\n        if (E != inf && (S == inf || w - x[E] < h - y[S])){\n            ans[a.back()] = w - x[E] + 1 + ck;\n            a.pop_back();\n            Q1.pop(); i--;\n        }\n        else{\n            ans[a[i]] = h - y[S] + 1 + ck;\n            Q2.pop();\n        }\n    }\n//    cout << \"\\n\";\n}\n\nvoid change(vector <int> & a){\n    for (int i = 1; i < a.size(); i++){\n        if (x[a[i]] == x[a[i-1]] && y[a[i]] == y[a[i-1]]) swap(s[a[i]], s[a[i-1]]);\n    }\n}\n\nvoid solve(vector <int> & a, bool ck){\n    change(a);\n    vector <int> X, Y;\n    for (int i = 0; i < a.size(); i++){\n        int sum = x[a[i]] + y[a[i]];\n        for (; i < a.size(); i++){\n            if (x[a[i]] + y[a[i]] != sum) break;\n            if (x[a[i]] % 2 == 0) X.push_back(a[i]);\n            else Y.push_back(a[i]);\n        }\n        cal(X, ck); X.clear();\n        cal(Y, ck); Y.clear();\n        i--;\n    }\n}\n\nbool cmp(int a, int b){\n    if (x[a]+y[a] < x[b]+y[b]) return true;\n    if (x[a]+y[a] == x[b]+y[b] && x[a] < x[b]) return true;\n    return false;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> w >> h >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> s[i];\n        if((x[i] + y[i]) % 2 == 1){\n            if (s[i] == 'E') x[i]++;\n            else y[i]++;\n            mv[1].push_back(i);\n        }\n        else{\n            mv[0].push_back(i);\n        }\n    }\n\n    sort(mv[0].begin(), mv[0].end(), cmp);\n    sort(mv[1].begin(), mv[1].end(), cmp);\n\n    change(mv[1]);\n\n    solve(mv[0], 0); solve(mv[1], 1);\n\n    for (int i = 1; i <= n; i++) p[i] = i;\n    sort(p+1, p+1+n, [](int x, int y){return ((ans[x] < ans[y]) || (ans[x] == ans[y] && x < y));});\n    for (int i = 1; i <= n; i++) cout <<  p[i] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool white(auto& a) {return ! ((a.y + a.x) & 1);};\n\nint main() {\n  int  W, H, N;\n  cin >> W >> H >> N;\n\n  struct Ant {int id, x, y; string s;};\n  vector<Ant> ant(N);\n  for(int i = 0; i < N; ant[i].id = ++i) cin >> ant[i].x >> ant[i].y >> ant[i].s;\n\n  unordered_map<int, vector<Ant*>> group;\n  for(auto& i: ant) group[i.x + i.y].emplace_back(&i);\n\n  map<int, set<int>> result;\n\n  for(auto& g: group) {\n    sort(begin(g.second), end(g.second), [](auto l, auto r) {return l->x < r->x;});\n    deque<Ant*> q[2];\n    for(auto& a: g.second) {\n      auto p = a->x & 1;\n      if(a->s == \"E\") q[p].emplace_back(a);\n      else {\n        if(!white(*a)) p = !p;\n        if(!q[p].empty()) {\n          swap(a->id, q[p].front()->id);\n          for(auto nex = begin(q[p]), cur = nex++; nex != end(q[p]); ++cur, ++nex) swap((*cur)->id, (*nex)->id);\n        }\n        result[H - a->y].emplace(a->id);\n      }\n    }\n    for(auto i: {0, 1}) while(!q[i].empty()) {\n      result[W - q[i].front()->x].emplace(q[i].front()->id);\n      q[i].pop_front();\n    }\n  }\n\n  for(auto i: result) for(auto j: i.second) cout << j << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w,h,n,m,i,x,y,z,xx,yy;\nstruct data{\n    int x,y,z;\n} a[200100];\nint t[200100],p[200100],s[3][200100],ww[200100][3],num[3],res[300100];\nchar ch;\nvector <int> v;\n\nbool cmp(int u,int v) {\n    return (a[u].x+a[u].y<a[v].x+a[v].y) || (a[u].x+a[u].y==a[v].x+a[v].y && a[u].y<a[v].y);\n}\n\nbool cmp1(int x,int y) {\n    return (res[x]<res[y]) || (res[x]==res[y] && x<y);\n}\n\nvoid cal2() {\n    //cout << \"----- \" << m << endl;\n    num[0]=num[1]=0;\n    for (int i=1;i<=m;++i) {\n        s[a[p[i]].z][++num[a[p[i]].z]]=p[i];\n        ww[i][0]=num[0]; ww[i][1]=num[1];\n    }\n\n    for (int i=1;i<=m;++i) {\n        //cout << \"** \" << p[i] << endl;\n        x=ww[i-1][1];\n        y=num[0]-ww[i][0];\n        z=a[p[i]].z;\n        xx=yy=min(x,y);\n        if (z==0 && x>xx) xx++;\n        if (z==1 && y>yy) yy++;\n\n        x=x-xx+1; y=ww[i][0]+yy;\n        x=s[1][x]; y=s[0][y];\n        if ((xx+yy)%2==1) z=1-z;\n        //cout << x << \" \" << y << \" \" << z << endl;\n        //cout << xx << \" \" << yy << endl;\n\n        if (xx+yy>0) {\n            res[p[i]]+=a[y].y-a[x].y;\n            //cout << res[p[i]] << endl;\n            if (z==0) res[p[i]]+=h+1-a[x].x;\n                else res[p[i]]+=w+1-a[y].y;\n            //cout << res[p[i]] << endl;\n        }\n        else {\n            if (z==0) res[p[i]]+=h+1-a[p[i]].x;\n                else res[p[i]]+=w+1-a[p[i]].y;\n        }\n    }\n}\n\nvoid cal() {\n    if ((a[v[0]].x+a[v[0]].y)%2==1) {\n        for (int i=0;i<v.size();++i) {\n            if (a[v[i]].z==0) a[v[i]].x++;\n                else a[v[i]].y++;\n            res[v[i]]++;\n            if (i>0 && a[v[i]].z==0 && a[v[i-1]].x==a[v[i]].x && a[v[i-1]].y==a[v[i]].y)\n                swap(a[v[i]].z,a[v[i-1]].z);\n        }\n    }\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==0 && a[v[i]].x<=h && a[v[i]].y<=w) p[++m]=v[i];\n    if (m>0) cal2();\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==1 && a[v[i]].x<=h && a[v[i]].y<=w) p[++m]=v[i];\n    if (m>0) cal2();\n}\n\nint main() {\n    /*freopen(\"ant.inp\",\"r\",stdin);\n    freopen(\"ant.out\",\"w\",stdout);//*/\n\n    scanf(\"%d %d %d\",&w,&h,&n);\n    for (i=1;i<=n;++i) {\n        scanf(\"%d %d %c\\n\",&a[i].y,&a[i].x,&ch);\n        if (ch=='E') a[i].z=1;\n            else a[i].z=0;\n        t[i]=i;\n    }\n\n    sort(t+1,t+1+n,cmp);\n\n    for (i=1;i<=n;++i) {\n        v.push_back(t[i]);\n        if (i==n || a[t[i]].x+a[t[i]].y!=a[t[i+1]].x+a[t[i+1]].y) {\n            cal();\n            v.clear();\n        }\n    }\n    for (i=1;i<=n;++i) t[i]=i;\n    sort(t+1,t+1+n,cmp1);\n    //for (i=1;i<=n;++i) printf(\"%d \",res[i]); cout << endl;\n    for (i=1;i<=n;++i) printf(\"%d\\n\",t[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <utility>\n\n#define ff(i,a,b) for (int i=(a);i<=(b);i++)\nusing namespace std;\ntypedef pair<int,int> ii;\nconst int N=2e5+10;\nint w,h,n;\nstruct kien {\n    int x,y,huong,id;\n};\nii T[N]; int tmp[N];\nkien a[N];\nint cmpVal (const kien& k) {\n    if (k.huong==0) ///Đông\n        return (k.x&1)?3:1;\n    return (k.x&1)?2:4;\n}\nbool cmpKien (const kien& k1, const kien& k2) {\n    ///Đầu tiên sort theo đường chéo.\n    if (k1.x+k1.y != k2.x+k2.y)\n        return k1.x+k1.y < k2.x+k2.y;\n\n    int xxk1 = (k1.x & 1), xxk2 = (k2.x & 1);\n    if (((k1.x+k2.x)&1) == 0) { ///Ô trắng.\n        if (xxk1 != xxk2) return xxk1<xxk2;\n        else return k1.huong<k2.huong;\n    }\n    else {\n        int tmp1=cmpVal (k1), tmp2 = cmpVal (k2);\n        return tmp1 < tmp2;\n    }\n}\nbool cungNhom (const kien &k1, const kien &k2) {\n    if (k1.x+k1.y != k2.x+k2.y) return 0;\n    int xxk1=k1.x&1, xxk2=k2.x&1;\n    if (!((k1.x+k1.y)&1)) {\n        return xxk1 == xxk2;\n    }\n    int val1=(k1.huong<<1)+xxk1, val2=(k2.huong<<1)+xxk2;\n    return ((val1^val2)==0 || (val1^val2)==3);\n}\nbool cmp2 (const kien &k1, const kien &k2) {\n    if (k1.huong != k2.huong) return k1.huong < k2.huong;\n    if (k1.huong == 0)\n        return k1.y < k2.y;\n    else\n        return k1.x > k2.x;\n}\nint tgRoi (const kien &k) {\n    return (k.huong==0)?w-k.x:h-k.y;\n}\nbool cmp3 (const kien &k1, const kien &k2) {\n    return k1.x-k1.y > k2.x-k2.y;\n}\nint main() {/*\n    freopen(\"10.inp\",\"r\",stdin); freopen(\"10.out\",\"w\",stdout); //*/\n    scanf(\"%d %d %d\\n\",&w,&h,&n);\n    ff(i,1,n) {\n        int x,y; char c; scanf(\"%d %d %c\\n\",&x,&y,&c);\n        a[i] = {x,y,(c=='E')?0:1,i};\n    }\n    sort(a+1, a+n+1, cmpKien);\n    int l=1, r=1;\n    do {\n        if (l>n) break;\n        while (r<=n && cungNhom(a[l], a[r])) r++;\n        sort(a+l, a+r, cmp2);\n        ff(i,l,r) tmp[i]=tgRoi(a[i]);\n        sort(a+l, a+r, cmp3);\n        ff(i,l,r) T[a[i].id] = ii(tmp[i], a[i].id);\n        l=r;\n    } while (1);\n    sort(T+1, T+n+1);\n    ff(i,1,n) printf(\"%d\\n\",T[i].second);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(x, a, b) for (int x = a; x <= b; ++x)\n#define FOD(x, a, b) for (int x = a; x >= b; --x)\n#define REP(x, a, b) for (int x = a; x < b; ++x)\n#define DEBUG(X) { cout << #X << \" = \" << X << endl; }\n#define PR(A, n) { cout << #A << \" = \"; FOR(_, 1, n) cout << A[_] << \" \"; cout << endl; }\n#define PR0(A, n)  { cout << #A << \" = \"; REP(_, 0, n) cout << A[_] << \" \"; cout << endl; }\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> II;\n\nconst int N = 2e5 + 10;\n\nint n, m, q, LSize;\nint L[N], ans[N];\n\nvector <int> c[N];\n\nstruct Ant {\n    int x, y, d;\n    Ant () {}\n    Ant (int x, int y, int d) : x(x), y(y), d(d) {};\n} A[N];\n\nvoid Compress() {\n    FOR(i, 1, q) L[i] = A[i].x + A[i].y;\n    LSize = q;\n    LSize = unique(L + 1, L + LSize + 1) - (L + 1);\n}\n\nint Pos(int v) {\n    return lower_bound(L + 1, L + LSize + 1, v) - L;\n}\n\nbool CMP(int x, int y) {\n    return A[x].y < A[y].y;\n}\n\nvoid Compute(const vector <int> &g) {\n    vector <II> L;\n    REP(p, 0, g.size()) {\n        int i = g[p], x = A[i].x, y = A[i].y, d = A[i].d;\n        if (d == 0) L.push_back(II(d, n - A[i].x));\n            else L.push_back(II(d, m - A[i].y));\n    }\n    sort(L.begin(), L.end());\n    REP(i, 0, g.size()) ans[g[i]] = L[i].second;\n}\n\nvoid Solve(int idx) {\n    sort(c[idx].begin(), c[idx].end(), CMP);\n    if (L[idx] % 2 == 0) {\n        FOR(f, 0, 1) {\n            vector <int> g;\n            REP(k, 0, c[idx].size()) {\n                int i = c[idx][k];\n                if (A[i].x % 2 != f) continue;\n                g.push_back(i);\n            }\n            Compute(g);\n        }\n    } else {\n        Compute(c[idx]);\n    }\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif // LOCAL\n    scanf(\"%d%d%d\", &n, &m, &q);\n    FOR(i, 1, q) {\n        char d[2]; int x, y; scanf(\"%d%d%s\", &x, &y, d);\n        A[i] = Ant(x, y, d[0] == 'E' ? 0 : 1);\n    }\n    Compress();\n    FOR(i, 1, q) {\n        int x = A[i].x, y = A[i].y, d = A[i].d;\n        c[Pos(x + y)].push_back(i);\n    }\n    FOR(i, 1, LSize) Solve(i);\n    vector <II> answ;\n    FOR(i, 1, q) answ.push_back(II(ans[i], i));\n    sort(answ.begin(), answ.end());\n    FOR(i, 1, q) printf(\"%d\\n\", answ[i - 1].second);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int x, y, index;\n    char d;\n    bool isWhite;\n    bool operator<(const Data& d) const{\n        return make_pair(x + y, x) < make_pair(d.x + d.y, d.x);\n    }\n};\n\nvoid solve(int h, int w, const vector<Data>& v, vector<int>& dist)\n{\n    vector<vector<Data> > v2(2);\n    if(v[0].isWhite){\n        for(unsigned i=0; i<v.size(); ++i)\n            v2[v[i].x%2].push_back(v[i]);\n    }\n    else{\n        for(unsigned i=0; i<v.size(); ++i){\n            int j = (v[i].x + (v[i].d == 'S' ? 0 : 1)) % 2;\n            v2[j].push_back(v[i]);\n        }\n    }\n\n    for(int i=0; i<2; ++i){\n        int n = v2[i].size();\n\n        vector<pair<int, int> > p;\n        for(int j=0; j<n; ++j){\n            if(v2[i][j].d == 'S')\n                p.push_back(make_pair(h+1, v2[i][j].x));\n        }\n        for(int j=0; j<n; ++j){\n            if(v2[i][j].d == 'E')\n                p.push_back(make_pair(v2[i][j].y, w+1));\n        }\n\n        for(int j=0; j<n; ++j){\n            int y = p[j].first;\n            int x = p[j].second;\n            dist[v2[i][j].index] = (y - v2[i][j].y) + (x - v2[i][j].x);\n        }\n    }\n}\n\nint main()\n{\n    int w, h, n;\n    cin >> w >> h >> n;\n\n    vector<Data> v(n);\n    for(int i=0; i<n; ++i){\n        cin >> v[i].x >> v[i].y >> v[i].d;\n        v[i].index = i;\n        v[i].isWhite = ((v[i].x + v[i].y) % 2 == 0);\n    }\n    sort(v.begin(), v.end());\n\n    vector<int> dist(n);\n    vector<Data> v2;\n    for(int i=0; i<n; ++i){\n        v2.push_back(v[i]);\n        if(i == n - 1 || v[i].y + v[i].x != v[i+1].y + v[i+1].x)\n            solve(h, w, v2, dist);\n    }\n\n    vector<pair<int, int> > ans(n);\n    for(int i=0; i<n; ++i)\n        ans[i] = make_pair(dist[i], i+1);\n    sort(ans.begin(), ans.end());\n    for(int i=0; i<n; ++i)\n        cout << ans[i].second << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> II;\n#define x first\n#define y second\n\nconst int N = 2e5 + 5;\n\nint w, h, n;\nchar dir[N];\nii p[N];\nvector<II> a[2];\nvector<ii> res;\nmap<ii, int> check;\n\nvoid solve(int type) {\n\tfor(int i = 0; i < 2; ++i) {\n\t\tdeque<ii> qu1, qu2, dq;\n\t\tfor(int j = 0; j < a[type].size(); ++j) if((a[type][j].y.x & 1) == i) {\n\t\t\t//cout << h  << ' ';\n\t\t\tif(dir[a[type][j].x] == 'E') qu1.push_back(ii(w - a[type][j].y.x, a[type][j].x));\n\t\t\telse qu2.push_back(ii(h - a[type][j].y.y, a[type][j].x));\n\t\t\tdq.push_back(ii(a[type][j].y.y, a[type][j].x));\n\t\t\t//cout << a[type][j].x << ' ';\n\t\t}\n\t\t//cout << '\\n';\n\t\t//cout << res.size() << endl;\n\t\tsort(qu1.begin(), qu1.end());\n\t\tsort(qu2.begin(), qu2.end());\n\t\tsort(dq.begin(), dq.end());\n\t\t//cout << dq.size() << endl;\n\t\twhile(dq.size()) {\n\t\t\tif(qu1.size() && qu2.size()) {\n\t\t\t\tif(qu1.front().x < qu2.front().x) {\n\t\t\t\t\tint id = qu1.front().y, id2 = dq.front().y;\n\t\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id2].x - p[id].x) + type, id2));\n\t\t\t\t\tdq.pop_front(); qu1.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint id = qu2.front().y, id2 = dq.back().y;\n\t\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id].x - p[id2].x) + type, id2));\n\t\t\t\t\tdq.pop_back(); qu2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(qu1.size()) {\n\t\t\t\tint id = qu1.front().y, id2 = dq.front().y;\n\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id2].x - p[id].x) + type, id2));\n\t\t\t\tdq.pop_front(); qu1.pop_back();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint id = qu2.front().y, id2 = dq.back().y;\n\t\t\t\tres.push_back(ii(w - p[id2].x + abs(p[id].y - p[id2].y) + type, id2));\n\t\t\t\tdq.pop_back(); qu2.pop_back();\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> w >> h >> n; w++; h++;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y >> dir[i];\n\t\tp[i] = ii(x, y);\n\t\ta[(x + y) & 1].push_back(II(i, ii(x, y)));\n\t}\n\tvector<II> khanhN;\n\tfor(int i = 0; i < a[1].size(); ++i) {\n\t\tif(dir[a[1][i].x] == 'E') a[1][i].y.x++;\n\t\telse a[1][i].y.y++;\n\t\tif(a[1][i].y.x >= w || a[1][i].y.y >= h) res.push_back(ii(1, a[1][i].x));\n\t\telse check[ii(a[1][i].y.x, a[1][i].y.y)]++, khanhN.push_back(II(a[1][i].x, a[1][i].y));\n\t\tp[a[1][i].x] = ii(a[1][i].y.x, a[1][i].y.y);\n\t}\n\ta[1] = khanhN;\n\tfor(int i = 0; i < a[1].size(); ++i) {\n\t\tif(check[ii(a[1][i].y.x, a[1][i].y.y)] >= 2) {\n\t\t\tif(dir[a[1][i].x] == 'S') dir[a[1][i].x] = 'E';\n\t\t\telse dir[a[1][i].x] = 'S';\n\t\t}\n\t}\n\tsolve(0); solve(1);\n\tsort(res.begin(), res.end());\n\tfor(int i = 0; i < res.size(); ++i) if(res[i] != res[i - 1]) cout << res[i].y << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <deque>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define PB push_back\nconst int N=2e5+10;\nstruct ant{\n    int x;\n    int y;\n    bool face;\n    void in(){\n        char c[5];\n        scanf(\"%d%d\",&x,&y);\n        scanf(\"%s\",c);\n        face=c[0]=='E';\n        return ;\n    }\n    int pos(){return x+y;}\n    bool black(){return (x+y)%2;}\n};\n\nint main(){\n    vector<pi> ans,temp;\n    vector<int> emp,l[2],r[2];\n    map<int,vector<int>>m;\n    deque<int>dq[2];\n    int n,w,h,p[N];\n    ant a[N];\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for(int i=1;i<=n;i++){\n        a[i].in();\n        if(m.find(a[i].pos())==m.end())m.insert({a[i].pos(),emp});\n        m[a[i].pos()].PB(i);\n    }\n    for(pair<int,vector<int>> i:m){\n        l[0].clear();\n        l[1].clear();\n        r[0].clear();\n        r[1].clear();\n        temp.clear();\n        for(int j:i.S)temp.PB({a[j].x,j});\n        sort(temp.begin(),temp.end());\n        reverse(temp.begin(),temp.end());\n        if(a[temp.front().S].black()){\n            for(pi j:temp){\n                if(a[j.S].face){\n                    if(dq[(j.F+1)%2].empty())p[j.S]=j.S;\n                    else{\n                        p[j.S]=dq[(j.F+1)%2].front();\n                        dq[(j.F+1)%2].pop_front();\n                        dq[(j.F+1)%2].PB(j.S);\n                    }\n                }\n                else {\n                    l[j.F%2].PB(j.S);\n                    dq[j.F%2].PB(j.S);\n                }\n            }\n        }\n        else{\n            for(pi j:temp){\n                if(a[j.S].face){\n                    if(dq[j.F%2].empty())p[j.S]=j.S;\n                    else{\n                        p[j.S]=dq[j.F%2].front();\n                        dq[j.F%2].pop_front();\n                        dq[j.F%2].PB(j.S);\n                    }\n                }\n                else {\n                    l[j.F%2].PB(j.S);\n                    dq[j.F%2].PB(j.S);\n                }\n            }\n        }\n        while(!dq[0].empty()){\n            r[0].PB(dq[0].front());\n            dq[0].pop_front();\n        }\n        while(!dq[1].empty()){\n            r[1].PB(dq[1].front());\n            dq[1].pop_front();\n        }\n        for(int j=0;j<r[0].size();j++)p[l[0][j]]=r[0][j];\n        for(int j=0;j<r[1].size();j++)p[l[1][j]]=r[1][j];\n    }\n    for(int i=1;i<=n;i++)if(a[i].face)ans.PB({w-a[i].x,p[i]});\n    else ans.PB({h-a[i].y,p[i]});\n    sort(ans.begin(),ans.end());\n    for(pi i:ans)printf(\"%d\\n\",i.S);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint W, H, N;\nint X[200000], Y[200000];\nchar D[200000];\nmap<int, vector<int> > mp;\nint F[200000];\nint T[200000];\n\nvoid solve(vector<int> &seq) {\n  if (seq.empty()) return;\n  //cout<<\"{\"; for (int x : seq) cout << x<<\",\";cout<<\"}\\n\";\n  vector<int> left, right;\n  vector<P> xs;\n  for (int i : seq) {\n    xs.pb(P(X[i], i));\n    if (D[i] == 'S') left.pb(i);\n    else right.pb(i);\n  }\n  sort(all(xs));\n  sort(all(left)); sort(all(right));\n  // LLL...RR\n  rep(j, xs.size()) {\n    int i = xs[j]._2;\n    if (j < left.size()) {\n      T[i] = F[left[j]];\n    }\n    else {\n      T[i] = F[right[j - (int)left.size()]];\n    }\n  }\n  sort(all(xs));\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> W >> H >> N;\n  rep(i, N) {\n    cin >> X[i] >> Y[i] >> D[i];\n    mp[X[i]+Y[i]].pb(i);\n    if (D[i] == 'S') F[i] = H - Y[i];\n    else F[i] = W - X[i];\n  }\n  rep(i, N) T[i] = -1;\n  for (auto &p : mp) {\n    bool flip = p._1 % 2;\n    vector<int> a[2];\n    for (int i : p._2) {\n      int parity = X[i]%2;\n      if (flip && D[i] == 'S') parity ^= 1;\n      a[parity].pb(i);\n    }\n    solve(a[0]); solve(a[1]);\n  }\n  vector<P> xs;\n  rep(i, N) xs.pb(P(T[i], i));\n  sort(all(xs));\n  rep(i, N) cout << xs[i]._2+1 << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\nenum class Direction: char {\n\tEast, South\n};\nstd::istream& operator>>(std::istream& is, Direction& dir) {\n\tchar c; is >> c;\n\tswitch (c) {\n\tcase 'E': dir = Direction::East; break;\n\tcase 'S': dir = Direction::South; break;\n\tdefault: throw 0;\n\t}\n\treturn is;\n}\nstruct Ant {\n\tint x, y, id;\n\tDirection dir;\n\tint time_until_drop(int w, int h) const {\n\t\tswitch (dir) {\n\t\tcase Direction::East: return w - x + 1;\n\t\tcase Direction::South: return h - y + 1;\n\t\tdefault: throw 0;\n\t\t}\n\t}\n};\nint main() {\n\tint w, h, n; std::cin >> w >> h >> n;\n\tstd::vector<Ant> ants(n);\n\tfor (auto i = 0; i < n; ++i) {\n\t\tants[i].id = i + 1;\n\t\tstd::cin >> ants[i].x >> ants[i].y >> ants[i].dir;\n\t}\n\tstd::sort(ants.begin(), ants.end(), [](const Ant& a, const Ant& b) {return (a.y + a.x == b.y + b.x) ? a.x < b.x : a.y + a.x < b.y + b.x; });\n\tstd::vector<std::queue<int>> queue(2);\n\tfor (auto current = ants.begin(); current != ants.end(); ) {\n\t\tauto last = std::upper_bound(current, ants.end(), current->y + current->x, [](const int val, const Ant& a) {return val < a.y + a.x; });\n\t\tfor (auto itr = current; itr != last; ++itr) {\n\t\t\tswitch (itr->dir) {\n\t\t\tcase Direction::South:\n\t\t\t\tif (!queue[itr->y % 2].empty()) {\n\t\t\t\t\tqueue[itr->y % 2].push(itr->id);\n\t\t\t\t\titr->id = queue[itr->y % 2].front(); queue[itr->y % 2].pop();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Direction::East: queue[itr->x % 2].push(itr->id); break;\n\t\t\tdefault: throw 0;\n\t\t\t}\n\t\t}\n\t\tfor (; current != last; ++current) {\n\t\t\tswitch (current->dir) {\n\t\t\tcase Direction::South: break;\n\t\t\tcase Direction::East: current->id = queue[current->x % 2].front(); queue[current->x % 2].pop(); break;\n\t\t\tdefault: throw 0;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(ants.begin(), ants.end(), [w, h](const Ant& a, const Ant& b) {return (a.time_until_drop(w, h) == b.time_until_drop(w, h)) ? a.id < b.id : a.time_until_drop(w, h) < b.time_until_drop(w, h); });\n\tfor (const auto& ant : ants) std::cout << ant.id << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\ntypedef pair<int,int> ii;\n\nint n, w, h;\nvector<int> z;\nint tout[N];\n\nstruct Point {\n    int x; int y; int id; char dir;\n    bool operator < (const Point &other) const {\n        return x > other.x || (x == other.x && dir < other.dir);\n    }\n} a[N];\nvector<Point> vec[N][2];\n\nvoid solve(vector<Point> &v) {\n    int sz = v.size();\n    sort(v.begin(), v.end());\n    vector< pair< ii, int > > fallout;\n\n    for (int i = 0; i < sz; ++i) {\n        if (v[i].dir == 'S') {\n            fallout.push_back( make_pair( ii(1, -v[i].x), h - v[i].y ) );\n        }\n        else {\n            fallout.push_back( make_pair( ii(0, v[i].y), w - v[i].x ) );\n        }\n    }\n\n    sort(fallout.begin(), fallout.end());\n\n    for (int i = 0; i < sz; ++i) {\n        tout[v[i].id] = fallout[i].second;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> w >> h >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i].x >> a[i].y >> a[i].dir;\n        a[i].id = i;\n        z.push_back(a[i].x + a[i].y);\n    }\n    sort(z.begin(), z.end());\n    z.erase(unique(z.begin(), z.end()), z.end());\n\n    for (int i = 0; i < n; ++i) {\n        int sum = lower_bound(z.begin(), z.end(), a[i].x + a[i].y) - z.begin() + 1;\n        if (a[i].dir == 'S') vec[sum][a[i].x % 2].push_back(a[i]);\n        else vec[sum][a[i].y % 2].push_back(a[i]);\n    }\n\n    for (int i = 1; i <= z.size(); ++i) {\n        for (int j = 0; j < 2; ++j) if (vec[i][j].size()) {\n            solve(vec[i][j]);\n        }\n    }\n\n\n    vector< pair<int,int> > vres;\n    for (int i = 0; i < n; ++i) {\n        vres.push_back(make_pair(tout[i], i));\n    }\n\n    sort(vres.begin(), vres.end());\n\n    for (int i = 0; i < vres.size(); ++i) {\n        printf(\"%d\\n\", vres[i].second + 1);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ad[200069],st[200059],pos[200069][2],cnt,w,h,n,da[200069][4],ans[200069],cnt1,cnt2,st1[200069],st2[200069],pos1,pos2;\nstring s;\ntypedef pair<int,int> ii;\ntypedef pair<ii,ii> iii;\ntypedef pair<int,ii> iiii;\niiii fin[200069];\niii d[200069];\n#define S first.first\n#define T first.second\n#define ID second.second\n#define X second.first\n\nvoid solve(){\n    cnt1=cnt2=0;\n    for (int i=1;i<=cnt;i++){\n         if (da[st[i]][2]) st1[++cnt1]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n         else st2[++cnt2]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n    }\n   // cout<<endl;\n    for (int i=1;i<=cnt;i++){\n            pos1=pos[i][0];\n            pos2=pos[i][1];\n        if (da[st[i]][2]==0){\n            if (pos1>=cnt2-pos2+1) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2)];\n            }\n            else if (pos1<cnt2-pos2){\n                ans[st[i]]=st2[pos1+pos2];\n            }\n        }\n        else {\n            if (pos1-1>=cnt2-pos2) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2)];\n            }\n            else if (pos1-1<cnt2-pos2){\n                ans[st[i]]=st2[pos2+pos1];\n            }\n        }\n           // cout<<pos1<<\" \"<<pos2<<\" \"<<da[st[i]][2]<<\"---\"<<st[i]<<\" \"<<ans[st[i]]<<endl;\n    }\n}\nint main(){\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for (int i=1;i<=n;i++){\n        scanf(\"%d%d\",&da[i][0],&da[i][1]);\n        cin>>s;\n        if (s==\"E\") da[i][2]=1;\n        else da[i][2]=0;\n        if ((da[i][0]+da[i][1])%2==1){\n            if (da[i][2]) da[i][0]++;\n            else da[i][1]++;\n            ad[i]=-1;\n        }\n    }\n    //cout<<da\n    for (int i=1;i<=n;i++) ans[i]=i;\n    for (int i=1;i<=n;i++){\n        if (ad[i]!=-1){\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n    }\n    sort(d+1,d+1+n);\n    cnt=0;\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n            if (d[st[1]].S!=0) solve();\n            cnt=0;\n        }\n        else {\n            st[++cnt]=d[i].ID;\n        }\n    }\n    for (int i=1;i<=n;i++)\n        if (ad[i]==-1){\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n        else {d[i].S=0;}\n    cnt=0;\n    sort(d+1,d+1+n);\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n            for (int j=1;j<=cnt-1;j++){\n                if (d[st[j]].X==d[st[j+1]].X){\n                    da[st[j]][2]=1-da[st[j]][2];\n                    da[st[j+1]][2]=1-da[st[j+1]][2];\n                    if (da[st[j]][2]>da[st[j+1]][2]) swap(st[j],st[j+1]);\n                }\n            }\n            if (d[i].S!=0) solve();\n            for (int j=1;j<=cnt-1;j++){\n                if (d[st[j]].X==d[st[j+1]].X){\n                    swap(ans[st[j]],ans[st[j+1]]);\n                }\n            }\n            cnt=0;\n        }\n        else {\n            st[++cnt]=d[i].ID;\n        }\n    }\n   // for (int i=1;i<=n;i++) cout<<ans[i]<<\" \";\n   // cout<<endl;\n    for (int i=1;i<=n;i++){\n        if (da[ans[i]][2]==0){\n            fin[i].first=h-da[ans[i]][1]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n        else {\n            fin[i].first=w-da[ans[i]][0]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n    }\n    sort(fin+1,fin+1+n);\n    for (int i=1;i<=n;i++) cout<<fin[i].second.first<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> II;\n#define x first\n#define y second\n\nconst int N = 2e5 + 5;\n\nint w, h, n;\nchar dir[N];\nii p[N];\nvector<II> a[2];\nvector<ii> res;\nmap<ii, int> check;\n\nvoid solve(int type) {\n\tfor(int i = 0; i < 2; ++i) {\n\t\tdeque<ii> qu1, qu2, dq;\n\t\tfor(int j = 0; j < a[type].size(); ++j) if((a[type][j].y.x & 1) == i) {\n\t\t\t//cout << h  << ' ';\n\t\t\tif(dir[a[type][j].x] == 'E') qu1.push_back(ii(w - a[type][j].y.x, a[type][j].x));\n\t\t\telse qu2.push_back(ii(h - a[type][j].y.y, a[type][j].x));\n\t\t\tdq.push_back(ii(a[type][j].y.y, a[type][j].x));\n\t\t}\n\t\t//cout << '\\n';\n\t\tsort(qu1.begin(), qu1.end());\n\t\tsort(qu2.begin(), qu2.end());\n\t\tsort(dq.begin(), dq.end());\n\t\t//cout << dq.size() << endl;\n\t\twhile(dq.size()) {\n\t\t\tif(qu1.size() && qu2.size()) {\n\t\t\t\tif(qu1.front().x < qu2.front().x) {\n\t\t\t\t\tint id = qu1.front().y, id2 = dq.front().y;\n\t\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id2].x - p[id].x) + type, id2));\n\t\t\t\t\tdq.pop_front(); qu1.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint id = qu2.front().y, id2 = dq.back().y;\n\t\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id].x - p[id2].x) + type, id2));\n\t\t\t\t\tdq.pop_back(); qu2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(qu1.size()) {\n\t\t\t\tint id = qu1.front().y, id2 = dq.front().y;\n\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id2].x - p[id].x) + type, id2));\n\t\t\t\tdq.pop_front(); qu1.pop_back();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint id = qu2.front().y, id2 = dq.back().y;\n\t\t\t\tres.push_back(ii(w - p[id2].x + abs(p[id].y - p[id2].y) + type, id2));\n\t\t\t\tdq.pop_back(); qu2.pop_back();\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> w >> h >> n; w++; h++;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y >> dir[i];\n\t\tp[i] = ii(x, y);\n\t\ta[(x + y) & 1].push_back(II(i, ii(x, y)));\n\t}\n\tfor(int i = 0; i < a[1].size(); ++i) {\n\t\tif(dir[a[1][i].x] == 'E') a[1][i].y.x++;\n\t\telse a[1][i].y.y++;\n\t\tif(a[1][i].y.x >= w || a[1][i].y.y >= h) res.push_back(ii(1, a[1][i].x));\n\t\telse check[ii(a[1][i].y.x, a[1][i].y.y)]++;\n\t\tp[a[1][i].x] = ii(a[1][i].y.x, a[1][i].y.y);\n\t}\n\tfor(int i = 0; i < a[1].size(); ++i) {\n\t\tif(check[ii(a[1][i].y.x, a[1][i].y.y)] >= 2) {\n\t\t\tif(dir[i] == 'S') dir[i] = 'E';\n\t\t\telse dir[i] = 'S';\n\t\t}\n\t}\n\t//for(int i = 0; i < a[0].size(); ++i) cout << a[0][i].y.x << ' '; cout << endl;\n\tsolve(0); solve(1);\n\tsort(res.begin(), res.end());\n\tfor(int i = 0; i < res.size(); ++i) cout << res[i].y << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0354\n\n#include<bits/stdc++.h>\nconst int N = 2e5 + 5;\nconst int inf = 1e9 + 7;\nusing namespace std;\n\nvector <int> mv[2];\nint n, w, h, x[N], y[N], p[N], ans[N];\nchar s[N];\n\nvoid cal(vector <int> & a, bool ck){\n    if (a.size() == 0) return;\n    queue <int> Q1, Q2;\n    for (int i = 0; i < a.size(); i++) if (s[a[i]] == 'E') Q1.push(a[i]);\n    for (int i = (int)a.size() - 1; i >= 0; i--) if (s[a[i]] == 'S') Q2.push(a[i]);\n\n//    if (x[a[0]] + y[a[0]] == 6 && ck)\n//    for (int i = 0; i < a.size(); i++)\n//        cout << a[i] << \" \" << x[a[i]] << \" \" << y[a[i]] << \" \" << s[a[i]] << \"\\n\";\n//\n//    cout << \"\\n\";\n    for (int i = 0; i < a.size(); i++){\n        int E = ((Q1.size()) ? Q1.front() : inf), S = ((Q2.size()) ? Q2.front() : inf);\n        if (E != inf && (S == inf || w - x[E] < h - y[S])){\n            ans[a[i]] = w - x[E] + 1 + ck;\n            Q1.pop();\n        }\n        else{\n            ans[a.back()] = h - y[S] + 1 + ck;\n            a.pop_back();\n            Q2.pop(); i--;\n        }\n    }\n//    cout << \"\\n\";\n}\n\nvoid change(vector <int> & a){\n    for (int i = 1; i < a.size(); i++){\n        if (x[a[i]] == x[a[i-1]] && y[a[i]] == y[a[i-1]]) swap(s[a[i]], s[a[i-1]]), swap(a[i], a[i-1]);\n    }\n}\n\nvoid solve(vector <int> & a, bool ck){\n    vector <int> X, Y;\n    for (int i = 0; i < a.size(); i++){\n        int sum = x[a[i]] + y[a[i]];\n        for (; i < a.size(); i++){\n            if (x[a[i]] + y[a[i]] != sum) break;\n            if (x[a[i]] % 2 == 0) X.push_back(a[i]);\n            else Y.push_back(a[i]);\n        }\n        cal(X, ck); X.clear();\n        cal(Y, ck); Y.clear();\n        i--;\n    }\n}\n\nbool cmp(int a, int b){\n    if (x[a]+y[a] < x[b]+y[b]) return true;\n    if (x[a]+y[a] == x[b]+y[b] && x[a] > x[b]) return true;\n    if (x[a] == x[b] && y[a] == y[b] && s[a] == 'E') return true;\n    return false;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> w >> h >> n;\n    vector <int> vc;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> s[i];\n        if (s[i] == 'E') vc.push_back(w - x[i] + 1);\n        else vc.push_back(h - y[i] + 1);\n        if((x[i] + y[i]) % 2 == 1){\n            if (s[i] == 'E') x[i]++;\n            else y[i]++;\n            mv[1].push_back(i);\n        }\n        else{\n            mv[0].push_back(i);\n        }\n    }\n\n    sort(mv[0].begin(), mv[0].end(), cmp);\n    sort(mv[1].begin(), mv[1].end(), cmp);\n\n    change(mv[1]);\n\n    solve(mv[0], 0); solve(mv[1], 1);\n\n    sort(vc.begin(), vc.end());\n\n    for (int i = 1; i <= n; i++) p[i] = i;\n    sort(p+1, p+1+n, [](int x, int y){return ((ans[x] < ans[y]) || (ans[x] == ans[y] && x < y));});\n    for (int i = 1; i <= n; i++) cout <<  p[i] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0354\n\n#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nconst int inf = 1e9 + 7;\nusing namespace std;\n\nvector <int> mv[2];\nint n, w, h, x[N], y[N], p[N], ans[N];\nchar s[N];\n\nvoid cal(vector <int> & a, bool ck){\n    if (a.size() == 0) return;\n    queue <int> Q1, Q2;\n    for (int i = 0; i < a.size(); i++) if (s[a[i]] == 'E') Q1.push(a[i]);\n    for (int i = (int)a.size() - 1; i >= 0; i--) if (s[a[i]] == 'S') Q2.push(a[i]);\n\n//    if (x[a[0]] + y[a[0]] == 6 && ck)\n//    for (int i = 0; i < a.size(); i++)\n//        cout << a[i] << \" \" << x[a[i]] << \" \" << y[a[i]] << \" \" << s[a[i]] << \"\\n\";\n//\n//    cout << \"\\n\";\n    for (int i = 0; i < a.size(); i++){\n        int E = ((Q1.size()) ? Q1.front() : inf), S = ((Q2.size()) ? Q2.front() : inf);\n        if (E != inf && (S == inf || w - x[E] < h - y[S])){\n            ans[a[i]] = w - x[E] + 1 + ck;\n            Q1.pop();\n        }\n        else{\n            ans[a.back()] = h - y[S] + 1 + ck;\n            a.pop_back();\n            Q2.pop(); i--;\n        }\n    }\n//    cout << \"\\n\";\n}\n\nvoid change(vector <int> & a){\n    for (int i = 1; i < a.size(); i++){\n        if (x[a[i]] == x[a[i-1]] && y[a[i]] == y[a[i-1]]) swap(s[a[i]], s[a[i-1]]), swap(a[i], a[i-1]);\n    }\n}\n\nvoid solve(vector <int> & a, bool ck){\n    vector <int> X, Y;\n    for (int i = 0; i < a.size(); i++){\n        int sum = x[a[i]] + y[a[i]];\n        for (; i < a.size(); i++){\n            if (x[a[i]] + y[a[i]] != sum) break;\n            if (x[a[i]] % 2 == 0) X.push_back(a[i]);\n            else Y.push_back(a[i]);\n        }\n        cal(X, ck); X.clear();\n        cal(Y, ck); Y.clear();\n        i--;\n    }\n}\n\nbool cmp(int a, int b){\n    if (x[a]+y[a] < x[b]+y[b]) return true;\n    if (x[a]+y[a] == x[b]+y[b] && x[a] > x[b]) return true;\n    if (x[a] == x[b] && y[a] == y[b] && s[a] == 'E') return true;\n    return false;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> w >> h >> n;\n    vector <int> vc;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> s[i];\n        if (s[i] == 'E') vc.push_back(w - x[i] + 1);\n        else vc.push_back(h - y[i] + 1);\n        if((x[i] + y[i]) % 2 == 1){\n            if (s[i] == 'E') x[i]++;\n            else y[i]++;\n            mv[1].push_back(i);\n        }\n        else{\n            mv[0].push_back(i);\n        }\n    }\n\n    sort(mv[0].begin(), mv[0].end(), cmp);\n    sort(mv[1].begin(), mv[1].end(), cmp);\n\n    change(mv[1]);\n\n    solve(mv[0], 0); solve(mv[1], 1);\n\n    sort(vc.begin(), vc.end());\n\n    for (int i = 1; i <= n; i++) p[i] = i;\n    sort(p+1, p+1+n, [](int x, int y){return ((ans[x] < ans[y]) || (ans[x] == ans[y] && x < y));});\n    for (int i = 1; i <= n; i++) cout <<  p[i] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0354\n\n#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nconst int inf = 1e9 + 7;\nusing namespace std;\n\nvector <int> mv[2];\nint n, w, h, x[N], y[N], p[N], ans[N];\nchar s[N];\n\nvoid cal(vector <int> & a, bool ck){\n    queue <int> Q1, Q2;\n    for (int i = 0; i < a.size(); i++) {\n        if (s[a[i]] == 'E') Q1.push(a[i]);\n        else Q2.push(a[i]);\n    }\n\n//    if (a.size() > 2) cout << a[0] << \" \" << x[a[0]] << \" \" << y[a[0]] << \" \" << s[a[0]] << \"\\n\";\n//    if (a.size() > 2) cout << a[1] << \" \" << x[a[1]] << \" \" << y[a[1]] << \" \" << s[a[1]] << \"\\n\";\n//    if (a.size() > 2) cout << a[2] << \" \" << x[a[2]] << \" \" << y[a[2]] << \" \" << s[a[2]] << \"\\n\";\n\n    for (int i = 0; i < a.size(); i++){\n        int E = ((Q1.size()) ? Q1.front() : inf), S = ((Q2.size()) ? Q2.front() : inf);\n        if (E != inf && (S == inf || w - x[E] < h - y[S])){\n            ans[a[i]] = w - x[E] + 1 + ck;\n            Q1.pop();\n        }\n        else{\n            ans[a.back()] = h - y[S] + 1 + ck;\n            a.pop_back();\n            Q2.pop(); i--;\n        }\n    }\n//    cout << \"\\n\";\n}\n\nvoid change(vector <int> & a){\n    for (int i = 1; i < a.size(); i++){\n        if (x[a[i]] == x[a[i-1]] && y[a[i]] == y[a[i-1]]) swap(s[a[i]], s[a[i-1]]);\n    }\n}\n\nvoid solve(vector <int> & a, bool ck){\n    change(a);\n    vector <int> X, Y;\n    for (int i = 0; i < a.size(); i++){\n        int sum = x[a[i]] + y[a[i]];\n        for (; i < a.size(); i++){\n            if (x[a[i]] + y[a[i]] != sum) break;\n            if (x[a[i]] % 2 == 0) X.push_back(a[i]);\n            else Y.push_back(a[i]);\n        }\n        cal(X, ck); X.clear();\n        cal(Y, ck); Y.clear();\n        i--;\n    }\n}\n\nbool cmp(int a, int b){\n    if (x[a]+y[a] < x[b]+y[b]) return true;\n    if (x[a]+y[a] == x[b]+y[b] && x[a] > x[b]) return true;\n    return false;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> w >> h >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> s[i];\n        if((x[i] + y[i]) % 2 == 1){\n            if (s[i] == 'E') x[i]++;\n            else y[i]++;\n            mv[1].push_back(i);\n        }\n        else{\n            mv[0].push_back(i);\n        }\n    }\n\n    sort(mv[0].begin(), mv[0].end(), cmp);\n    sort(mv[1].begin(), mv[1].end(), cmp);\n\n    change(mv[1]);\n\n    solve(mv[0], 0); solve(mv[1], 1);\n\n    for (int i = 1; i <= n; i++) p[i] = i;\n    sort(p+1, p+1+n, [](int x, int y){return ((ans[x] < ans[y]) || (ans[x] == ans[y] && x < y));});\n    for (int i = 1; i <= n; i++) cout <<  p[i] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ad[200069],st[200059],pos[200069][2],cnt,w,h,n,da[200069][4],ans[200069],cnt1,cnt2,st1[200069],st2[200069],pos1,pos2;\nstring s;\ntypedef pair<int,int> ii;\ntypedef pair<ii,ii> iii;\ntypedef pair<int,ii> iiii;\niiii fin[200069];\niii d[200069];\n#define S first.first\n#define T first.second\n#define ID second.second\n#define X second.first\n\nvoid solve(){\n    cnt1=cnt2=0;\n    for (int i=1;i<=cnt;i++){\n         if (da[st[i]][2]) st1[++cnt1]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n         else st2[++cnt2]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n         //cout<<st[i]<<\" \";\n    }\n   // cout<<endl;\n    for (int i=1;i<=cnt;i++){\n            pos1=pos[i][0];\n            pos2=pos[i][1];\n        if (da[st[i]][2]==0){\n            if (pos1>cnt2-pos2) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2)];\n            }\n            else if (pos1<=cnt2-pos2){\n                ans[st[i]]=st2[pos1+pos2];\n            }\n        }\n        else {\n            if (pos1-1>=cnt2-pos2) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2)];\n            }\n            else if (pos1-1<cnt2-pos2){\n                ans[st[i]]=st2[pos2+pos1];\n            }\n        }\n           // cout<<pos1<<\" \"<<pos2<<\" \"<<da[st[i]][2]<<\"---\"<<st[i]<<\" \"<<ans[st[i]]<<endl;\n    }\n}\nint main(){\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for (int i=1;i<=n;i++){\n        scanf(\"%d%d\",&da[i][0],&da[i][1]);\n        cin>>s;\n        if (s==\"E\") da[i][2]=1;\n        else da[i][2]=0;\n        if ((da[i][0]+da[i][1])%2==1){\n            if (da[i][2]) da[i][0]++;\n            else da[i][1]++;\n            ad[i]=-1;\n        //    cout<<i<<\" \";\n        }\n    }\n    //cout<<da\n    for (int i=1;i<=n;i++) ans[i]=i;\n    for (int i=1;i<=n;i++){\n        if (ad[i]!=-1){\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n    }\n    sort(d+1,d+1+n);\n    cnt=0;\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n            if (da[st[1]][0]+da[st[1]][1]!=0 && d[i].S!=0){\n                solve();\n            }\n            cnt=0;\n        }\n        else {\n            st[++cnt]=d[i].ID;\n        }\n    }\n    for (int i=1;i<=n;i++)\n        if (ad[i]==-1 && da[i][0]<=w && da[i][1]<=h){\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n        else {d[i].S=0;}\n    cnt=0;\n    sort(d+1,d+1+n);\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n            if (da[st[1]][0]+da[st[1]][1]!=0 && d[i].S!=0) {\n                for (int j=1;j<=cnt-1;j++){\n                    if (da[st[j]][0]==da[st[j+1]][0]){\n                        da[st[j]][2]=1-da[st[j]][2];\n                        da[st[j+1]][2]=1-da[st[j+1]][2];\n                        if (da[st[j]][2]>da[st[j+1]][2]) swap(st[j],st[j+1]);\n                    }\n                }\n                solve();\n                for (int j=1;j<=cnt-1;j++){\n                   /* if (da[st[j]][0]==da[st[j+1]][0]){\n                        swap(ans[st[j]],ans[st[j+1]]);\n                    }*/\n                }\n            }\n            cnt=0;\n        }\n        else if (d[i].S==d[i+1].S) {\n            st[++cnt]=d[i].ID;\n        }\n    }\n    //cout<<endl;\n    for (int i=1;i<=n;i++){\n        if (da[ans[i]][2]==0){\n            fin[i].first=h-da[ans[i]][1]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n        else {\n            fin[i].first=w-da[ans[i]][0]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n    }\n    sort(fin+1,fin+1+n);\n    for (int i=1;i<=n;i++) cout<<fin[i].second.first<<endl;\n}\n/*5\n11\n14\n19\n6\n8\n13\n17\n20\n4\n15\n2\n3\n7\n12\n18\n9\n1\n10\n16*/\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int x, y, index;\n    char d;\n    bool isWhite;\n    bool operator<(const Data& d) const{\n        return make_pair(x + y, x) < make_pair(d.x + d.y, d.x);\n    }\n};\n\nvoid solve(int h, int w, const vector<Data>& v, vector<int>& dist)\n{\n    vector<vector<Data> > v2(2);\n    if(v[0].isWhite){\n        for(unsigned i=0; i<v.size(); ++i)\n            v2[v[i].x%2].push_back(v[i]);\n    }\n    else{\n        for(unsigned i=0; i<v.size(); ++i){\n            int j = (v[i].x + ((v[i].d == 'S') ? 1 : 0)) % 2;\n            v2[j].push_back(v[i]);\n        }\n    }\n\n    for(int i=0; i<2; ++i){\n        int n = v2[i].size();\n\n        vector<pair<int, int> > p;\n        for(int j=0; j<n; ++j){\n            if(v2[i][j].d == 'S')\n                p.push_back(make_pair(h+1, v2[i][j].x));\n        }\n        for(int j=0; j<n; ++j){\n            if(v2[i][j].d == 'E')\n                p.push_back(make_pair(v2[i][j].y, w+1));\n        }\n\n        for(int j=0; j<n; ++j){\n            int y = p[j].first;\n            int x = p[j].second;\n            dist[v2[i][j].index] = (y - v2[i][j].y) + (x - v2[i][j].x);\n        }\n    }\n}\n\nint main()\n{\n    int w, h, n;\n    cin >> w >> h >> n;\n\n    vector<Data> v(n);\n    for(int i=0; i<n; ++i){\n        cin >> v[i].x >> v[i].y >> v[i].d;\n        v[i].isWhite = ((v[i].x + v[i].y) % 2 == 0);\n        v[i].index = i;\n    }\n    sort(v.begin(), v.end());\n\n    vector<int> dist(n);\n    vector<Data> v2;\n    for(int i=0; i<n; ++i){\n        v2.push_back(v[i]);\n        if(i == n - 1 || v[i].y + v[i].x != v[i+1].y + v[i+1].x){\n            solve(h, w, v2, dist);\n            v2.clear();\n        }\n    }\n\n    vector<pair<int, int> > ans(n);\n    for(int i=0; i<n; ++i)\n        ans[i] = make_pair(dist[i], i+1);\n    sort(ans.begin(), ans.end());\n    for(int i=0; i<n; ++i)\n        cout << ans[i].second << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS  = 1e-10;\nconst bool debug = 0;\n//---------------------------//\n\nint W, H, N;\nint x[212345], y[212345], d[212345]; // ??±-0, ???-1\nint ord[212345];\n\nint main() {\n\tcin >> W >> H >> N;\n\tREP(i, N) {\n\t\tchar c;\n\t\tscanf(\"%d %d %c\", x + i, y + i, &c);\n\t\td[i] = c == 'S';\n\t}\n\t\n\tmap<int, vector<pii> > m; // x-y, (x, number)\n\tREP(i, N) m[x[i] + y[i]].push_back(pii(x[i], i));\n\t\n\tvector<vector<pii> > vv; // ????????????????????????\n\tfor (map<int, vector<pii> >::iterator it = m.begin(); it != m.end(); ++it) {\n\t\tvv.push_back(it->se);\n\t}\n\t\n\tvector<pii> ans; // (t, number)\n\tmemset(ord, -1, sizeof(ord));\n\t\n\tREP(i, vv.size()) {\n\t\tvector<pii> &v = vv[i];\n\t\tsort(ALL(v));\n\t\t\n\t\tvector<int> t(v.size());\n\t\tREP(j, v.size()) {\n\t\t\tif (d[v[j].se]) t[j] = H + 1 - y[v[j].se];\n\t\t\telse t[j] = W + 1 - x[v[j].se];\n\t\t}\n\t\t\n\t\tbool black = (x[v[0].se] + y[v[0].se]) & 1; // ???????????´?????????????????§??????????????????\n\t\t\n\t\tqueue<int> que[2]; // [y??§?¨??????¶?\\?] = ???number\n\t\t\n\t\tREP(j, v.size()) {\n\t\t\tint num = v[j].se; // ?????¨????????????????????????\n\t\t\t\n\t\t\tif (d[num]) {\n\t\t\t\tint idx = black ^ (y[num] & 1); // ??????????????????y??§?¨??????¶?\\?\n\t\t\t\tque[idx].push(num);\n\t\t\t\tord[j] = que[idx].front();\n\t\t\t\tque[idx].pop();\n\t\t\t}\n\t\t\telse { // ??±??????\n\t\t\t\tque[y[num] & 1].push(num);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > pq;\n\t\tREP(j, 2) while (!que[j].empty()) {\n\t\t\tint num = que[j].front();\n\t\t\tque[j].pop();\n\t\t\tpq.push(pii(y[num], num));\n\t\t}\n\t\tint p = 0;\n\t\twhile (!pq.empty()) {\n\t\t\tint num = pq.top().se;\n\t\t\tpq.pop();\n\t\t\t\n\t\t\twhile (ord[p] != -1) p++;\n\t\t\tord[p] = num;\n\t\t}\n\t\t\n\t\tREP(j, v.size()) ans.push_back(pii(t[j], ord[j]));\n\t\tREP(j, v.size()) ord[j] = -1;\n\t}\n\t\n\tsort(ALL(ans));\n\tREP(i, ans.size()) printf(\"%d\\n\", ans[i].se + 1);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> II;\n#define x first\n#define y second\n\nconst int N = 2e5 + 5;\n\nint w, h, n;\nchar dir[N];\nii p[N];\nvector<II> a[2];\nvector<ii> res;\nmap<ii, int> check;\n\nvoid solve(int type) {\n\tfor(int i = 0; i < 2; ++i) {\n\t\tdeque<ii> qu1, qu2, dq;\n\t\tfor(int j = 0; j < a[type].size(); ++j) if((a[type][j].y.x & 1) == i) {\n\t\t\t//cout << h  << ' ';\n\t\t\tif(dir[a[type][j].x] == 'E') qu1.push_back(ii(w - a[type][j].y.x, a[type][j].x));\n\t\t\telse qu2.push_back(ii(h - a[type][j].y.y, a[type][j].x));\n\t\t\tdq.push_back(ii(a[type][j].y.y, a[type][j].x));\n\t\t\t//cout << a[type][j].x << ' ';\n\t\t}\n\t\t//cout << '\\n';\n\t\t//cout << res.size() << endl;\n\t\tsort(qu1.begin(), qu1.end());\n\t\tsort(qu2.begin(), qu2.end());\n\t\tsort(dq.begin(), dq.end());\n\t\t//cout << dq.size() << endl;\n\t\twhile(dq.size()) {\n\t\t\tif(qu1.size() && qu2.size()) {\n\t\t\t\tif(qu1.front().x < qu2.front().x) {\n\t\t\t\t\tint id = qu1.front().y, id2 = dq.front().y;\n\t\t\t\tres.push_back(ii(w - p[id2].x + abs(p[id2].y - p[id].y) + type, id2));\n\t\t\t\tdq.pop_front(); qu1.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint id = qu2.front().y, id2 = dq.back().y;\n\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id].x - p[id2].x) + type, id2));\n\t\t\t\tdq.pop_back(); qu2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(qu1.size()) {\n\t\t\t\tint id = qu1.front().y, id2 = dq.front().y;\n\t\t\t\tres.push_back(ii(w - p[id2].x + abs(p[id2].y - p[id].y) + type, id2));\n\t\t\t\tdq.pop_front(); qu1.pop_back();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint id = qu2.front().y, id2 = dq.back().y;\n\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id].x - p[id2].x) + type, id2));\n\t\t\t\tdq.pop_back(); qu2.pop_back();\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> w >> h >> n; w++; h++;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y >> dir[i];\n\t\tp[i] = ii(x, y);\n\t\ta[(x + y) & 1].push_back(II(i, ii(x, y)));\n\t}\n\tvector<II> khanhN;\n\tfor(int i = 0; i < a[1].size(); ++i) {\n\t\tif(dir[a[1][i].x] == 'E') a[1][i].y.x++;\n\t\telse a[1][i].y.y++;\n\t\tif(a[1][i].y.x >= w || a[1][i].y.y >= h) res.push_back(ii(1, a[1][i].x));\n\t\telse check[ii(a[1][i].y.x, a[1][i].y.y)]++, khanhN.push_back(II(a[1][i].x, a[1][i].y));\n\t\tp[a[1][i].x] = ii(a[1][i].y.x, a[1][i].y.y);\n\t}\n\ta[1] = khanhN;\n\tfor(int i = 0; i < a[1].size(); ++i) {\n\t\tif(check[ii(a[1][i].y.x, a[1][i].y.y)] >= 2) {\n\t\t\tif(dir[a[1][i].x] == 'S') dir[a[1][i].x] = 'E';\n\t\t\telse dir[a[1][i].x] = 'S';\n\t\t}\n\t}\n\tsolve(0); solve(1);\n\tsort(res.begin(), res.end());\n\tfor(int i = 0; i < res.size(); ++i) cout << res[i].y << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\tmap<pi, vector<pi>> down, right;\n\tvector<tuple<int,int,int>> in;\n\tvi last;\n\t\n\trep(i, n){\n\t\tint x, y; char d;\n\t\tcin >> x >> y >> d;\n\t\tin.emplace_back(x, y, d);\n\t\tif(d == 'S') down[pi(x + y, x & 1)].emplace_back(x, i);\n\t\telse right[pi(x + y, x & 1)].emplace_back(x, i);\n\t\tlast.pb(i);\n\t}\n\t\n\tfor(auto p : down){\n\t\tvector<pi> &d = p.second;\n\t\t\n\t\tpi o = p.first;\n\t\tif(o.first & 1) o.second ^= 1;\n\t\tif(!right.count(o)) continue;\n\t\t\n\t\tvector<pi> &r = right[o];\n\t\tsort(all(d));\n\t\tsort(all(r));\n\t\tint idx = 0;\n\t\tfor(pi i : d){\n\t\t\tint k = lower_bound(all(r), pi(i.first, 0)) - r.begin();\n\t\t\tif(k >= d.size() - idx) last[i.second] = r[k - (d.size() - idx)].second;\n\t\t\telse last[i.second] = d[idx + k].second;\n\t\t\tidx++;\n\t\t}\n\t\tidx = 0;\n\t\tfor(pi i : r){\n\t\t\tint k = d.end() - lower_bound(all(d), pi(i.first + 1, 0));\n\t\t\tif(k > idx) last[i.second] = d[d.size() - k + idx].second;\n\t\t\telse last[i.second] = r[idx - k].second;\n\t\t\tidx++;\n\t\t}\n\t}\n\t//dbg(last);\n\t\n\tvector<pi> ans;\n\trep(i, n){\n\t\tint x, y, d; tie(x, y, d) = in[last[i]];\n\t\tbool down = d == 'S';\n\t\tans.emplace_back(down ? h - y :  w - x, i);\n\t}\n\tsort(all(ans));\n\tfor(pi i : ans) cout << i.second + 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> II;\n#define x first\n#define y second\n\nconst int N = 2e5 + 5;\n\nint w, h, n;\nchar dir[N];\nii p[N];\nvector<II> a[2];\nvector<ii> res;\nmap<ii, int> check;\n\nvoid solve(int type) {\n\tfor(int i = 0; i < 2; ++i) {\n\t\tdeque<ii> qu1, qu2, dq;\n\t\tfor(int j = 0; j < a[type].size(); ++j) if((a[type][j].y.x & 1) == i) {\n\t\t\t//cout << h  << ' ';\n\t\t\tif(dir[a[type][j].x] == 'E') qu1.push_back(ii(w - a[type][j].y.x, a[type][j].x));\n\t\t\telse qu2.push_back(ii(h - a[type][j].y.y, a[type][j].x));\n\t\t\tdq.push_back(ii(a[type][j].y.y, a[type][j].x));\n\t\t}\n\t\t//cout << '\\n';\n\t\tsort(qu1.begin(), qu1.end());\n\t\tsort(qu2.begin(), qu2.end());\n\t\tsort(dq.begin(), dq.end());\n\t\t//cout << dq.size() << endl;\n\t\twhile(dq.size()) {\n\t\t\tif(qu1.size() && qu2.size()) {\n\t\t\t\tif(qu1.front().x < qu2.front().x) {\n\t\t\t\t\tint id = qu1.front().y, id2 = dq.front().y;\n\t\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id2].x - p[id].x) + type, id2));\n\t\t\t\t\tdq.pop_front(); qu1.pop_back();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint id = qu2.front().y, id2 = dq.back().y;\n\t\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id].x - p[id2].x) + type, id2));\n\t\t\t\t\tdq.pop_back(); qu2.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(qu1.size()) {\n\t\t\t\tint id = qu1.front().y, id2 = dq.front().y;\n\t\t\t\tres.push_back(ii(h - p[id2].y + abs(p[id2].x - p[id].x) + type, id2));\n\t\t\t\tdq.pop_front(); qu1.pop_back();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint id = qu2.front().y, id2 = dq.back().y;\n\t\t\t\tres.push_back(ii(w - p[id2].x + abs(p[id].y - p[id2].y) + type, id2));\n\t\t\t\tdq.pop_back(); qu2.pop_back();\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> w >> h >> n; w++; h++;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y >> dir[i];\n\t\tp[i] = ii(x, y);\n\t\ta[(x + y) & 1].push_back(II(i, ii(x, y)));\n\t}\n\tfor(int i = 0; i < a[1].size(); ++i) {\n\t\tif(dir[a[1][i].x] == 'E') a[1][i].y.x++;\n\t\telse a[1][i].y.y++;\n\t\tif(a[1][i].y.x >= w || a[1][i].y.y >= h) res.push_back(ii(1, a[1][i].x));\n\t\telse check[ii(a[1][i].y.x, a[1][i].y.y)]++;\n\t\tp[a[1][i].x] = ii(a[1][i].y.x, a[1][i].y.y);\n\t}\n\tfor(int i = 0; i < a[1].size(); ++i) {\n\t\tif(check[ii(a[1][i].y.x, a[1][i].y.y)] >= 2) {\n\t\t\tif(dir[a[1][i].x] == 'S') dir[a[1][i].x] = 'E';\n\t\t\telse dir[a[1][i].x] = 'S';\n\t\t}\n\t}\n\t//for(int i = 0; i < a[0].size(); ++i) cout << a[0][i].y.x << ' '; cout << endl;\n\tsolve(0); solve(1);\n\tsort(res.begin(), res.end());\n\tfor(int i = 0; i < res.size(); ++i) cout << res[i].y << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(x, a, b) for (int x = a; x <= b; ++x)\n#define FOD(x, a, b) for (int x = a; x >= b; --x)\n#define REP(x, a, b) for (int x = a; x < b; ++x)\n#define DEBUG(X) { cout << #X << \" = \" << X << endl; }\n#define PR(A, n) { cout << #A << \" = \"; FOR(_, 1, n) cout << A[_] << \" \"; cout << endl; }\n#define PR0(A, n)  { cout << #A << \" = \"; REP(_, 0, n) cout << A[_] << \" \"; cout << endl; }\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> II;\n\nconst int N = 2e5 + 10;\n\nint n, m, q, LSize;\nint L[N], ans[N];\n\nvector <int> c[N];\n\nstruct Ant {\n    int x, y, d;\n    Ant () {}\n    Ant (int x, int y, int d) : x(x), y(y), d(d) {};\n} A[N];\n\nvoid Compress() {\n    FOR(i, 1, q) L[i] = A[i].x + A[i].y;\n    LSize = q;\n    sort(L + 1, L + LSize + 1);\n    LSize = unique(L + 1, L + LSize + 1) - (L + 1);\n}\n\nint Pos(int v) {\n    return lower_bound(L + 1, L + LSize + 1, v) - L;\n}\n\nbool CMP(int x, int y) {\n    return A[x].y < A[y].y;\n}\n\nstruct State {\n    int x, y, z;\n    State () {}\n    State (int x, int y, int z) : x(x), y(y), z(z) {}\n    bool operator < (const State &that) const {\n        if (x != that.x) return x < that.x;\n        if (y != that.y) return y < that.y;\n        return z < that.z;\n    }\n};\n\nvoid Compute(const vector <int> &g) {\n    vector <State> L;\n    REP(p, 0, g.size()) {\n        int i = g[p], x = A[i].x, y = A[i].y, d = A[i].d;\n        if (d == 0) L.push_back(State(d, A[i].y, n - A[i].x));\n            else L.push_back(State(d, n - A[i].x, m - A[i].y));\n    }\n    sort(L.begin(), L.end());\n   // PR0(g, g.size());\n    //REP(i, 0, L.size()) cout << L[i].first << \" \" << L[i].second << endl;\n    REP(i, 0, g.size()) ans[g[i]] = L[i].z;\n}\n\nvoid Solve(int idx) {\n    sort(c[idx].begin(), c[idx].end(), CMP);\n    if (L[idx] % 2 == 0) {\n        FOR(f, 0, 1) {\n            vector <int> g;\n            REP(k, 0, c[idx].size()) {\n                int i = c[idx][k];\n                if (A[i].x % 2 != f) continue;\n                g.push_back(i);\n            }\n            Compute(g);\n        }\n    } else {\n        Compute(c[idx]);\n    }\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif // LOCAL\n    scanf(\"%d%d%d\", &n, &m, &q);\n    FOR(i, 1, q) {\n        char d[2]; int x, y; scanf(\"%d%d%s\", &x, &y, d);\n        A[i] = Ant(x, y, d[0] == 'E' ? 0 : 1);\n    }\n    Compress();\n    FOR(i, 1, q) {\n        int x = A[i].x, y = A[i].y, d = A[i].d;\n        c[Pos(x + y)].push_back(i);\n    }\n    FOR(i, 1, LSize) Solve(i);\n    vector <II> answ;\n    FOR(i, 1, q) answ.push_back(II(ans[i], i));\n    sort(answ.begin(), answ.end());\n    FOR(i, 1, q) printf(\"%d\\n\", answ[i - 1].second);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200005;\n\nint n, w, h;\nint val[N], res[N];\n\nstruct Ant {\n\tint x, y, id; \n\tchar t;\n} a[N];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i].x >> a[i].y >> a[i].t, a[i].id = i;\n\t\tif (a[i].t == 'E') val[i] = w - a[i].x;\n\t\telse val[i] = h - a[i].y;\n\t}\n\tsort(a, a + n, [&] (Ant p, Ant q) {\n\t\treturn p.x + p.y < q.x + q.y;\n\t});\n\tfor (int i = 0; i < n; ++i) {\n\t\tvector<Ant> go[2];\n\t\tint j = i;\n\t\twhile (i < n && a[j].x + a[j].y == a[i].x + a[i].y) {\n\t\t\tif (a[i].t == 'E') {\n\t\t\t\tgo[a[i].y & 1].push_back(a[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgo[a[i].x & 1].push_back(a[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\ti--;\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tsort(go[j].begin(), go[j].end(), [&] (Ant p, Ant q) {\n\t\t\t\treturn p.x == q.x ? p.t < q.t : p.x < q.x;\n\t\t\t});\n\t\t\tvector<Ant> vec;\n\t\t\tfor (auto k : go[j]) {\n\t\t\t\tif (k.t == 'E') {\n\t\t\t\t\tk.x = w + 1, vec.push_back(k);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk.y = h + 1, vec.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec.begin(), vec.end(), [&] (Ant p, Ant q) {\n\t\t\t\treturn p.x == q.x ? p.y > q.y : p.x < q.x;\n\t\t\t});\n\t\t\tfor (int k = 0; k < vec.size(); ++k) {\n\t\t\t\tres[go[j][k].id] = val[vec[k].id];\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> p;\n\tfor (int i = 0; i < n; ++i) p.push_back(i);\n\tsort(p.begin(), p.end(), [&] (int x, int y) {\n\t\treturn res[x] == res[y] ? x < y : res[x] < res[y];\n\t});\n\tfor (auto i : p) cout << i + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _ pair<pair<int,int>,int>\nusing namespace std;\nvector<_> A,B,C,D,v1,v2;\npair<int,int> a[200005];\n_ b[200005],c[200005];\nint cnt1,cnt2,n,i,j,x,y,m,k;\nchar kitu;\nint T(_ x)\n{\n    return x.first.first+x.first.second;\n}\nbool cmp(_ x,_ y)\n{\n    if (T(x)==T(y)) return x.first.first>y.first.first;\n    return T(x)<T(y);\n}\nvoid xuly()\n{\n    //if (A.empty() || B.empty()) return;\n    //cout<<A.size()<<' '<<B.size()<<endl;\n    C.clear();\n    int i,j;i=j=0;\n    while (i<A.size() && j<B.size())\n    {\n        if (A[i].first.first>B[j].first.first) {C.push_back(A[i]);i++;}\n        else {C.push_back(B[j]);j++;}\n    }\n    while (i<A.size()) {C.push_back(A[i]);i++;}\n    while (j<B.size()) {C.push_back(B[j]);j++;}\n    D.clear();\n    for (int i=0;i<A.size();++i) D.push_back(A[i]);\n    for (int j=0;j<B.size();++j) D.push_back(B[j]);\n    for (int i=0;i<C.size();++i) a[D[i].second].second=C[i].second;\n}\nvoid tach()\n{\n\n    if (x%2==0)\n    {\n\n        A.clear();B.clear();\n        for (int i=0;i<v1.size();++i) if (v1[i].first.first%2==0) A.push_back(v1[i]);\n        for (int i=0;i<v2.size();++i) if (v2[i].first.first%2==0) B.push_back(v2[i]);\n        xuly();\n        A.clear();B.clear();\n        for (int i=0;i<v1.size();++i) if (v1[i].first.first%2) A.push_back(v1[i]);\n        for (int i=0;i<v2.size();++i) if (v2[i].first.first%2) B.push_back(v2[i]);\n        xuly();\n    }\n    else\n    {\n        A.clear();B.clear();\n        for (int i=0;i<v1.size();++i) if (v1[i].first.first%2==0) A.push_back(v1[i]);\n        for (int i=0;i<v2.size();++i) if (v2[i].first.first%2) B.push_back(v2[i]);\n        xuly();\n        A.clear();B.clear();\n        for (int i=0;i<v1.size();++i) if (v1[i].first.first%2) A.push_back(v1[i]);\n        for (int i=0;i<v2.size();++i) if (v2[i].first.first%2==0) B.push_back(v2[i]);\n        xuly();\n    }\n\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n>>m>>k;\n    for (int i=1;i<=k;++i)\n    {\n        cin>>y>>x;\n        cin>>kitu;\n        if (kitu=='S')\n        {\n            a[i].first=m-x;\n            b[++cnt1]={{x,y},i};\n        }\n        else\n        {\n            a[i].first=n-y;\n            c[++cnt2]={{x,y},i};\n        }\n        a[i].second=i;\n    }\n    sort(b+1,b+cnt1+1,cmp);\n    sort(c+1,c+cnt2+1,cmp);\n    i=1;j=1;\n    while (i<=cnt1)\n    {\n        v1.clear();\n        v2.clear();\n        v1.push_back(b[i]);x=T(b[i]);\n        i++;\n        while (i<=cnt1 && T(b[i])==x) {v1.push_back(b[i]);i++;}\n        while (j<=cnt2 && T(c[j])<x) j++;\n        while (j<=cnt2 && T(c[j])==x)\n        {\n            v2.push_back(c[j]);j++;\n        }\n\n    tach();\n    }\n   // for (int i=1;i<=k;++i) cout<<a[i].first<<' '<<a[i].second<<endl;\n    sort(a+1,a+k+1);\n    for (int i=1;i<=k;++i) cout<<a[i].second<<'\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200005;\n\nint n, w, h;\nint val[N], res[N];\n\nstruct Ant {\n\tint x, y, id; \n\tchar t;\n\n\tvoid debug() {\n\t\tcout << x << ' ' << y << ' ' << t << '\\n';\n\t}\n} a[N];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i].x >> a[i].y >> a[i].t, a[i].id = i;\n\t\tif (a[i].t == 'E') val[i] = w - a[i].x;\n\t\telse val[i] = h - a[i].y;\n\t}\n\tsort(a, a + n, [&] (Ant p, Ant q) {\n\t\treturn p.x + p.y < q.x + q.y;\n\t});\n\tfor (int i = 0; i < n; ++i) {\n\t\tvector<Ant> go[2];\n\t\tint j = i;\n\t\twhile (i < n && a[j].x + a[j].y == a[i].x + a[i].y) {\n\t\t\tif (a[i].t == 'E') {\n\t\t\t\tgo[a[i].y & 1].push_back(a[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgo[a[i].x & 1].push_back(a[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tsort(go[j].begin(), go[j].end(), [&] (Ant p, Ant q) {\n\t\t\t\treturn p.x == q.x ? p.t < q.t : p.x < q.x;\n\t\t\t});\n\t\t\tvector<Ant> vec;\n\t\t\tfor (auto k : go[j]) {\n\t\t\t\tif (k.t == 'E') {\n\t\t\t\t\tk.x = w + 1, vec.push_back(k);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk.y = h + 1, vec.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec.begin(), vec.end(), [&] (Ant p, Ant q) {\n\t\t\t\treturn p.x == q.x ? p.y < q.y : p.x < q.x;\n\t\t\t});\n\t\t\tfor (int k = 0; k < vec.size(); ++k) {\n\t\t\t\tres[go[j][k].id] = val[vec[k].id];\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\tvector<int> p;\n\tfor (int i = 0; i < n; ++i) p.push_back(i);\n\tsort(p.begin(), p.end(), [&] (int x, int y) {\n\t\treturn res[x] == res[y] ? x < y : res[x] < res[y];\n\t});\n\tfor (auto i : p) cout << i + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <stdlib.h>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\nconst double EPS = 1e-8;\n#define Scan(a) int a;scanf(\"%d\", &a);\n#define ScanS(a) char a[500];scanf(\"%s\", a);\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1LL)\n#define bitset(a,b)      ( a |= (1LL << b))\n#define bitunset(a,b)    (a &= ~(1LL << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\npii operator+(pii obj, pii obj2) {\n\treturn MP(obj.first + obj2.first, obj.second + obj2.second);\n}\npii operator-(pii obj, pii obj2) {\n\treturn MP(obj.first - obj2.first, obj.second - obj2.second);\n}\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n\tvoid scan(int edcount, bool oindexed, bool w) {\n\t\tREP(i, edcount) {\n\t\t\tint a, b, c = 1;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (w)scanf(\"%d\", &c);\n\t\t\tcon(a - oindexed, b - oindexed, c);\n\t\t}\n\t}\n};\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\nclass DGraph : public Graph {//??????\npublic:\n\tDGraph(int n) : Graph(n) {}\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tsumcost++;\n\t}\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nint main() {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\n\tmap<int, vector<pair<pii, pair<char, int>>>> ant;\n\tvector<pair<pii, char>> ar(n);\n\tREP(i, n) {\n\t\tint x, y;\n\t\tchar d;\n\t\tscanf(\"%d %d %c\", &x, &y, &d);\n\n\t\tant[x + y].push_back({ {x,y}, {d,i} });\n\t\tar[i] = { {x,y},d };\n\t}\n\n\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\n\tfor (auto itr : ant) {\n\t\tsort(ALL(itr.second), greater<pair<pii, pair<char, int>>>());\n\t\tqueue<int> que[2];\n\t\tfor (auto itr2 : itr.second) {\n\n\t\t\tint ai = itr2.first.first % 2;\n\t\t\tif (itr.first % 2 == 0 && itr2.second.first == 'S') {\n\t\t\t\tai = 1 - ai;\n\t\t\t}\n\n\t\t\tif (itr2.second.first == 'S')\n\t\t\t\tque[ai].push(itr2.second.second);\n\t\t\telse {\n\t\t\t\tif (que[ai].empty()) {\n\t\t\t\t\tpq.push({ w - itr2.first.first ,itr2.second.second });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint cur = que[ai].front();\n\t\t\t\t\tque[ai].pop();\n\t\t\t\t\tpq.push({ w - itr2.first.first ,cur });\n\t\t\t\t\tpq.push({ h - ar[cur].first.second ,itr2.second.second });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (que[0].size()) {\n\t\t\tint cur = que[0].front();\n\t\t\tpq.push({ h - ar[cur].first.second , cur });\n\t\t\tque[0].pop();\n\t\t}\n\t\twhile (que[1].size()) {\n\t\t\tint cur = que[1].front();\n\t\t\tpq.push({ h - ar[cur].first.second , cur });\n\t\t\tque[1].pop();\n\t\t}\n\t}\n\twhile (pq.size()) {\n\t\tprintf(\"%d\\n\", pq.top().second + 1);\n\t\tpq.pop();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS  = 1e-10;\nconst bool debug = 1;\n//---------------------------//\n\nint W, H, N;\nint x[212345], y[212345], d[212345]; // ??±-0, ???-1\nint ord[212345];\n\nint main() {\n\tcin >> W >> H >> N;\n\tREP(i, N) {\n\t\tchar c;\n\t\tscanf(\"%d %d %c\", x + i, y + i, &c);\n\t\td[i] = c == 'S';\n\t}\n\t\n\tmap<int, vector<pii> > m; // x-y, (x, number)\n\tREP(i, N) m[x[i] + y[i]].push_back(pii(x[i], i));\n\t\n\tvector<vector<pii> > vv; // ????????????????????????\n\tfor (map<int, vector<pii> >::iterator it = m.begin(); it != m.end(); ++it) {\n\t\tvv.push_back(it->se);\n\t}\n\t\n\tvector<pii> ans; // (t, number)\n\t\n\tREP(i, vv.size()) {\n\t\tvector<pii> &v = vv[i];\n\t\tsort(ALL(v));\n\t\t\n\t\tvector<int> t(v.size());\n\t\tREP(j, v.size()) {\n\t\t\tif (d[v[j].se]) t[j] = H + 1 - y[v[j].se];\n\t\t\telse t[j] = W + 1 - x[v[j].se];\n\t\t}\n\t\t\n\t\tbool black = (v[0].fi + v[0].se) & 1; // ???????????´?????????????????§??????????????????\n\t\t\n\t\tqueue<int> que[2]; // [y??§?¨??????¶?\\?] = ???number\n\t\t\n\t\tmemset(ord, -1, sizeof(ord));\n\t\t\n\t\tREP(j, v.size()) {\n\t\t\tint num = v[j].se; // ?????¨????????????????????????\n\t\t\t\n\t\t\tint idx = black ^ (y[num] & 1); // ??????????????????y??§?¨??????¶?\\?\n\t\t\t\n\t\t\tque[idx].push(num);\n\t\t\t\n\t\t\tif (d[num]) { // ???????????????????????????\n\t\t\t\tord[j] = que[idx].front();\n\t\t\t\tque[idx].pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > pq;\n\t\tREP(j, 2) while (!que[j].empty()) {\n\t\t\tint num = que[j].front();\n\t\t\tque[j].pop();\n\t\t\tpq.push(pii(y[num], num));\n\t\t}\n\t\tint p = 0;\n\t\twhile (!pq.empty()) {\n\t\t\tint num = pq.top().se;\n\t\t\tpq.pop();\n\t\t\t\n\t\t\twhile (ord[p] != -1) p++;\n\t\t\tord[p] = num;\n\t\t}\n\t\t\n\t\tREP(j, v.size()) ans.push_back(pii(t[j], ord[j]));\n\t}\n\t\n\tsort(ALL(ans));\n\t\n\tREP(i, ans.size()) printf(\"%d\\n\", ans[i].se + 1);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <queue>\n#include <algorithm>\n\n#define ff(i,a,b) for (int i=(a);i<=(b);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef set<int> sI;\nconst int N=2e5+10;\nint n,a[N],b[N];\nqueue<sI> Q;\n\nint main() {/*\n    freopen(\"9.inp\",\"r\",stdin); freopen(\"9.out\",\"w\",stdout); //*/\n    scanf(\"%d\",&n); ff(i,1,n) scanf(\"%d\",&a[i]);\n    copy(a+1, a+n+1, b+1); sort(b+1, b+n+1);\n    ff(i,1,n) {\n        sI s; s.insert(a[i]);\n        Q.push(s);\n    }\n    ll ans=0ll;\n    for (int i=1; i<=n; i++) {\n        sI s=Q.front(); Q.pop();\n        while (s.count(b[i])==0) {\n            sI t=Q.front(); Q.pop();\n            for (sI::iterator it=t.begin(); it!=t.end(); it++) {\n                s.insert(*it);\n            }\n        }\n        s.erase(b[i]);\n        ans += (int)s.size();\n        Q.push(s);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(x, a, b) for (int x = a; x <= b; ++x)\n#define FOD(x, a, b) for (int x = a; x >= b; --x)\n#define REP(x, a, b) for (int x = a; x < b; ++x)\n#define DEBUG(X) { cout << #X << \" = \" << X << endl; }\n#define PR(A, n) { cout << #A << \" = \"; FOR(_, 1, n) cout << A[_] << \" \"; cout << endl; }\n#define PR0(A, n)  { cout << #A << \" = \"; REP(_, 0, n) cout << A[_] << \" \"; cout << endl; }\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> II;\n\nconst int N = 2e5 + 10;\n\nint n, m, q, LSize;\nint L[N], ans[N], ban[N];\n\nvector <int> c[N];\n\nstruct Ant {\n    int x, y, d;\n    Ant () {}\n    Ant (int x, int y, int d) : x(x), y(y), d(d) {};\n} A[N];\n\nvoid Compress() {\n    FOR(i, 1, q) L[i] = A[i].x + A[i].y;\n    LSize = q;\n    sort(L + 1, L + LSize + 1);\n    LSize = unique(L + 1, L + LSize + 1) - (L + 1);\n}\n\nint Pos(int v) {\n    return lower_bound(L + 1, L + LSize + 1, v) - L;\n}\n\nbool CMP(int x, int y) {\n    return A[x].y < A[y].y;\n}\n\nstruct State {\n    int x, y, z;\n    State () {}\n    State (int x, int y, int z) : x(x), y(y), z(z) {}\n    bool operator < (const State &that) const {\n        if (x != that.x) return x < that.x;\n        if (y != that.y) return y < that.y;\n        return z < that.z;\n    }\n};\n\nvoid Compute(const vector <int> &g) {\n    vector <State> L;\n    REP(p, 0, g.size()) {\n        int i = g[p], x = A[i].x, y = A[i].y, d = A[i].d;\n        if (d == 0) L.push_back(State(d, A[i].y, n - A[i].x));\n            else L.push_back(State(d, n - A[i].x, m - A[i].y));\n    }\n    sort(L.begin(), L.end());\n   // PR0(g, g.size());\n    //REP(i, 0, g.size()) cout << L[i].z << endl;\n    REP(i, 0, g.size()) ans[g[i]] = L[i].z;\n}\n\nvoid Solve(int idx) {\n    sort(c[idx].begin(), c[idx].end(), CMP);\n    if (L[idx] % 2 == 0) {\n        FOR(f, 0, 1) {\n            vector <int> g;\n            REP(k, 0, c[idx].size()) {\n                int i = c[idx][k];\n                if (A[i].x % 2 != f) continue;\n                g.push_back(i);\n            }\n            Compute(g);\n        }\n    } else {\n        FOR(r, 0, 1) {\n            vector <int> g;\n            REP(k, 0, c[idx].size()) {\n                int i = c[idx][k];\n                if (A[i].d == 0) {\n                    if (A[i].y % 2 == r) g.push_back(i);\n                } else {\n                    if (A[i].x % 2 == r) g.push_back(i);\n                }\n            }\n            Compute(g);\n        }\n    }\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif // LOCAL\n    scanf(\"%d%d%d\", &n, &m, &q);\n    FOR(i, 1, q) {\n        char d[2]; int x, y; scanf(\"%d%d%s\", &x, &y, d);\n        A[i] = Ant(x, y, d[0] == 'E' ? 0 : 1);\n    }\n    /*FOR(i, 1, q)\n        FOR(j, i + 1, q) assert((A[i].x == A[j].x && A[i].y == A[j].y) == false);*/\n    Compress();\n    FOR(i, 1, q) {\n        int x = A[i].x, y = A[i].y, d = A[i].d;\n        c[Pos(x + y)].push_back(i);\n    }\n    FOR(i, 1, LSize) Solve(i);\n    vector <II> answ;\n    FOR(i, 1, q) answ.push_back(II(ans[i], i));\n    sort(answ.begin(), answ.end());\n    FOR(i, 1, q) printf(\"%d\\n\", answ[i - 1].second);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int w, h, n;\n    cin >> w >> h >> n;\n    vector<int> zxy(n);\n    vector<array<int, 4>> ant(n);\n    for (int i = 0; i < n; ++i) {\n        int x, y; char c;\n        cin >> x >> y >> c;\n        zxy.emplace_back(x+y);\n        ant[i] = {x, y, c == 'S', i};\n    }\n    vector<int> ans(n);\n    sort(zxy.begin(), zxy.end());\n    zxy.erase(unique(zxy.begin(), zxy.end()), zxy.end());\n    vector<vector<array<int, 4>>> ants(zxy.size());\n    for (int i = 0; i < n; ++i) {\n        int x = lower_bound(zxy.begin(),zxy.end(), ant[i][0]+ant[i][1]) - zxy.begin();\n        ants[x].emplace_back(ant[i]);\n    }\n    for (int i = 0; i < zxy.size(); ++i) {\n        int c = zxy[i]&1;\n        sort(ants[i].begin(),ants[i].end());\n        vector<queue<int>> a(2);\n        for (auto &&e : ants[i]) {\n            if(e[2]){\n                int k = (e[1]&1)^c;\n                a[k].emplace(e[3]);\n                int tmp = a[k].front(); a[k].pop();\n                ans[tmp] = h-e[1];\n            }else {\n                a[e[1]&1].emplace(e[3]);\n            }\n        }\n        for (auto &&e : ants[i]) {\n            if(!e[2]){\n                int k = (e[1]&1);\n                a[k].emplace(e[3]);\n                int tmp = a[k].front(); a[k].pop();\n                ans[tmp] = w-e[0];\n            }\n        }\n    }\n    vector<int> perm(n);\n    iota(perm.begin(),perm.end(), 0);\n    sort(perm.begin(),perm.end(), [&](int x, int y){\n        if(ans[x] != ans[y]) return ans[x] < ans[y];\n        else return x < y;\n    });\n    for (auto &&j : perm) {\n        printf(\"%d\\n\", j+1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int x, y, index;\n    char d;\n    bool isWhite;\n    bool operator<(const Data& d) const{\n        return make_pair(x + y, x) < make_pair(d.x + d.y, d.x);\n    }\n};\n\nvoid solveWhite(int h, int w, const vector<Data>& v, vector<int>& dist)\n{\n    vector<vector<Data> > v2(2);\n    for(unsigned i=0; i<v.size(); ++i)\n        v2[v[i].x%2].push_back(v[i]);\n\n    for(int i=0; i<2; ++i){\n        int n = v2[i].size();\n\n        vector<pair<int, int> > p;\n        for(int j=0; j<n; ++j){\n            if(v2[i][j].d == 'S')\n                p.push_back(make_pair(h+1, v2[i][j].x));\n        }\n        for(int j=0; j<n; ++j){\n            if(v2[i][j].d == 'E')\n                p.push_back(make_pair(v2[i][j].y, w+1));\n        }\n\n        for(int j=0; j<n; ++j){\n            int y = p[j].first;\n            int x = p[j].second;\n            dist[v2[i][j].index] = (y - v2[i][j].y) + (x - v2[i][j].x);\n        }\n    }\n}\n\nvoid solveBlack(int h, int w, const vector<Data>& v, vector<int>& dist)\n{\n    vector<vector<Data> > v2(2);\n    for(unsigned i=0; i<v.size(); ++i)\n        v2[v[i].x%2].push_back(v[i]);\n\n    for(int i=0; i<2; ++i){\n        int n = v2[i].size();\n        int m = v2[i^1].size();\n\n        vector<pair<int, int> > p;\n        for(int j=0; j<m; ++j){\n            if(v2[i^1][j].d == 'S')\n                p.push_back(make_pair(h+1, v2[i^1][j].x));\n        }\n        for(int j=0; j<m; ++j){\n            if(v2[i^1][j].d == 'E')\n                p.push_back(make_pair(v2[i^1][j].y, w+1));\n        }\n\n        int k = 0;\n        for(int j=0; j<n; ++j){\n            while(k < m && v2[i^1][k] < v2[i][j])\n                ++ k;\n\n            pair<int, int> add;\n            if(v2[i][j].d == 'S')\n                add = make_pair(h, v2[i][j].x);\n            else\n                add = make_pair(v2[i][j].y, w);\n\n            pair<int, int> to;\n            if(k > 0 && add.second - add.first < p[k-1].second - p[k-1].first)\n                to = p[k-1];\n            else if(k >= m || add.second - add.first < p[k].second - p[k].first)\n                to = add;\n            else\n                to = p[k];\n\n            int y = to.first;\n            int x = to.second;\n            dist[v2[i][j].index] = (y - v2[i][j].y) + (x - v2[i][j].x);\n        }\n    }\n}\n\nint main()\n{\n    int w, h, n;\n    cin >> w >> h >> n;\n\n    vector<Data> v(n);\n    for(int i=0; i<n; ++i){\n        cin >> v[i].x >> v[i].y >> v[i].d;\n        v[i].index = i;\n        v[i].isWhite = ((v[i].x + v[i].y) % 2 == 0);\n    }\n    sort(v.begin(), v.end());\n\n    vector<int> dist(n);\n    vector<Data> v2;\n    for(int i=0; i<n; ++i){\n        v2.push_back(v[i]);\n        if(i == n - 1 || v[i].y + v[i].x != v[i+1].y + v[i+1].x){\n            if(v[i].isWhite)\n                solveWhite(h, w, v2, dist);\n            else\n                solveBlack(h, w, v2, dist);\n            v2.clear();\n        }\n    }\n\n    vector<pair<int, int> > ans(n);\n    for(int i=0; i<n; ++i)\n        ans[i] = make_pair(dist[i], i+1);\n    sort(ans.begin(), ans.end());\n    for(int i=0; i<n; ++i)\n        cout << ans[i].second << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0354\n\n#include<bits/stdc++.h>\nconst int N = 1e5 + 5;\nconst int inf = 1e9 + 7;\nusing namespace std;\n\nvector <int> mv[2];\nint n, w, h, x[N], y[N], p[N], ans[N];\nchar s[N];\n\nvoid cal(vector <int> & a, bool ck){\n    queue <int> Q1, Q2;\n    for (int i = 0; i < a.size(); i++) {\n        if (s[a[i]] == 'E') Q1.push(a[i]);\n        else Q2.push(a[i]);\n    }\n\n//    if (a.size() > 0) cout << a[0] << \" \" << x[a[0]] << \" \" << y[a[0]] << \" \" << s[a[0]] << \"\\n\";\n//    if (a.size() > 1) cout << a[1] << \" \" << x[a[1]] << \" \" << y[a[1]] << \" \" << s[a[1]] << \"\\n\";\n\n    for (int i = 0; i < a.size(); i++){\n        int E = ((Q1.size()) ? Q1.front() : inf), S = ((Q2.size()) ? Q2.front() : inf);\n        if (E != inf && (S == inf || w - x[E] < h - y[S])){\n            ans[a.back()] = w - x[E] + 1 + ck;\n            a.pop_back();\n            Q1.pop(); i--;\n        }\n        else{\n            ans[a[i]] = h - y[S] + 1 + ck;\n            Q2.pop();\n        }\n    }\n//    cout << \"\\n\";\n}\n\nvoid change(vector <int> & a){\n    for (int i = 1; i < a.size(); i++){\n        if (x[a[i]] == x[a[i-1]] && y[a[i]] == y[a[i-1]]) swap(s[a[i]], s[a[i-1]]);\n    }\n}\n\nvoid solve(vector <int> & a, bool ck){\n    change(a);\n    vector <int> X, Y;\n    for (int i = 0; i < a.size(); i++){\n        int sum = x[a[i]] + y[a[i]];\n        for (; i < a.size(); i++){\n            if (x[a[i]] + y[a[i]] != sum) break;\n            if (x[a[i]] % 2 == 0) X.push_back(a[i]);\n            else Y.push_back(a[i]);\n        }\n        cal(X, ck); X.clear();\n        cal(Y, ck); Y.clear();\n        i--;\n    }\n}\n\nbool cmp(int a, int b){\n    if (x[a]+y[a] < x[b]+y[b]) return true;\n    if (x[a]+y[a] == x[b]+y[b] && x[a] < x[b]) return true;\n    return false;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> w >> h >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> s[i];\n        if((x[i] + y[i]) % 2 == 1){\n            if (s[i] == 'E') x[i]++;\n            else y[i]++;\n            mv[1].push_back(i);\n        }\n        else{\n            mv[0].push_back(i);\n        }\n    }\n\n    sort(mv[0].begin(), mv[0].end(), cmp);\n    sort(mv[1].begin(), mv[1].end(), cmp);\n\n    change(mv[1]);\n\n    solve(mv[0], 0); solve(mv[1], 1);\n\n    for (int i = 1; i <= n; i++) p[i] = i;\n    sort(p+1, p+1+n, [](int x, int y){return ((ans[x] < ans[y]) || (ans[x] == ans[y] && x < y));});\n    for (int i = 1; i <= n; i++) cout <<  p[i] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w,h,n,m,i,x,y,z,xx,yy;\nstruct data{\n    int x,y,z;\n} a[200100];\nint t[200100],p[200100],s[3][200100],ww[200100][3],num[3],res[300100];\nchar ch;\nvector <int> v;\n\nbool cmp(int u,int v) {\n    return (a[u].x+a[u].y<a[v].x+a[v].y) || (a[u].x+a[u].y==a[v].x+a[v].y && a[u].y<a[v].y);\n}\n\nbool cmp1(int x,int y) {\n    return (res[x]<res[y]) || (res[x]==res[y] && x<y);\n}\n\nvoid cal2() {\n    num[0]=num[1]=0;\n    for (int i=1;i<=m;++i) {\n        s[a[p[i]].z][++num[a[p[i]].z]]=p[i];\n        ww[i][0]=num[0]; ww[i][1]=num[1];\n    }\n\n    for (int i=1;i<=m;++i) {\n        x=ww[i-1][1];\n        y=num[0]-ww[i][0];\n        z=a[p[i]].z;\n        xx=yy=min(x,y);\n        if (z==0 && x>xx) xx++;\n        if (z==1 && y>yy) yy++;\n\n        x=x-xx+1; y=ww[i][0]+yy;\n        x=s[1][x]; y=s[0][y];\n        if ((xx+yy)%2==1) z=1-z;\n\n        if (xx+yy>0) {\n            res[p[i]]+=a[y].y-a[x].y;\n            if (z==0) res[p[i]]+=h+1-a[y].y;\n                else res[p[i]]+=w+1-a[x].x;\n        }\n        else {\n            if (z==0) res[p[i]]+=h+1-a[p[i]].y;\n                else res[p[i]]+=w+1-a[p[i]].x;\n        }\n    }\n}\n\nvoid cal() {\n    if ((a[v[0]].x+a[v[0]].y)%2==1) {\n        for (int i=0;i<v.size();++i) {\n            if (a[v[i]].z==0) a[v[i]].x++;\n                else a[v[i]].y++;\n            res[v[i]]++;\n            if (i>0 && a[v[i]].z==0 && a[v[i-1]].x==a[v[i]].x && a[v[i-1]].y==a[v[i]].y)\n                swap(a[v[i]].z,a[v[i-1]].z);\n        }\n    }\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==0 && a[v[i]].x<=h && a[v[i]].y<=w) p[++m]=v[i];\n    if (m>0) cal2();\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==1 && a[v[i]].x<=h && a[v[i]].y<=w) p[++m]=v[i];\n    if (m>0) cal2();\n}\n\nint main() {\n    //freopen(\"ant.inp\",\"r\",stdin);\n    freopen(\"ant.out\",\"w\",stdout);//*/\n\n    scanf(\"%d %d %d\",&w,&h,&n);\n    for (i=1;i<=n;++i) {\n        scanf(\"%d %d %c\\n\",&a[i].y,&a[i].x,&ch);\n        if (ch=='E') a[i].z=1;\n            else a[i].z=0;\n        t[i]=i;\n    }\n\n    sort(t+1,t+1+n,cmp);\n\n    for (i=1;i<=n;++i) {\n        v.push_back(t[i]);\n        if (i==n || a[t[i]].x+a[t[i]].y!=a[t[i+1]].x+a[t[i+1]].y) {\n            cal();\n            v.clear();\n        }\n    }\n    for (i=1;i<=n;++i) t[i]=i;\n    sort(t+1,t+1+n,cmp1);\n    for (i=1;i<=n;++i) printf(\"%d \",res[i]); cout << endl;\n    for (i=1;i<=n;++i) printf(\"%d\\n\",t[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int  W, H, N;\n  cin >> W >> H >> N;\n\n  struct Ant {int id, x, y; string s;};\n  vector<Ant> ant(N);\n  for(int i = 0; i < N; ant[i].id = ++i) cin >> ant[i].x >> ant[i].y >> ant[i].s;\n\n  map<int, vector<Ant*>> group;\n  for(auto& i: ant) group[i.x + i.y].emplace_back(&i);\n  for(auto& g: group) sort(begin(g.second), end(g.second), [](auto l, auto r) {return l->x < r->x;});\n\n  map<int, set<int>> result;\n\n  auto white = [](auto& a) {return ! ((a.y + a.x) & 1);};\n  for(auto& g: group) {\n    list<int> id[2], x[2];\n    for(auto& a: g.second) {\n      auto p = a->x & 1;\n      if(a->s == \"E\") id[p].emplace_back(a->id), x[p].emplace_back(a->x);\n      else {\n        if(!white(*a)) p = !p;\n        if(!id[p].empty()) {\n          id[p].emplace_back(a->id);\n          a->id = id[p].front();\n          id[p].pop_front();\n        }\n        result[H - a->y].emplace(a->id);\n      }\n    }\n    for(auto i: {0, 1}) while(!id[i].empty()) {\n      result[W - x[i].front()].emplace(id[i].front());\n      id[i].pop_front();\n      x[i].pop_front();\n    }\n  }\n\n  for(auto i: result) for(auto j: i.second) cout << j << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ad[200069],st[200059],pos[200069][2],cnt,w,h,n,da[200069][4],ans[200069],cnt1,cnt2,st1[200069],st2[200069],pos1,pos2;\nstring s;\ntypedef pair<int,int> ii;\ntypedef pair<ii,ii> iii;\ntypedef pair<int,ii> iiii;\niiii fin[200069];\niii d[200069];\n#define S first.first\n#define T first.second\n#define ID second.second\n#define X second.first\n\nvoid solve(){\n    cnt1=cnt2=0;\n    for (int i=1;i<=cnt;i++){\n         if (da[st[i]][2]) st1[++cnt1]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n         else st2[++cnt2]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n    }\n    for (int i=1;i<=cnt;i++){\n            pos1=pos[i][0];\n            pos2=pos[i][1];\n        if (da[st[i]][2]==0){\n            if (pos1>cnt2-pos2) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2)];\n            }\n            else if (pos1<=cnt2-pos2){\n                ans[st[i]]=st2[pos1+pos2];\n            }\n        }\n        else {\n            if (pos1-1>=cnt2-pos2) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2)];\n            }\n            else if (pos1-1<cnt2-pos2){\n                ans[st[i]]=st2[pos2+pos1];\n            }\n        }\n           // cout<<pos1<<\" \"<<pos2<<\" \"<<da[st[i]][2]<<\"---\"<<st[i]<<\" \"<<ans[st[i]]<<endl;\n    }\n}\nint main(){\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for (int i=1;i<=n;i++){\n        scanf(\"%d%d\",&da[i][0],&da[i][1]);\n        cin>>s;\n        if (s==\"E\") da[i][2]=1;\n        else da[i][2]=0;\n        if ((da[i][0]+da[i][1])%2==1){\n            if (da[i][2]) da[i][0]++;\n            else da[i][1]++;\n            ad[i]=-1;\n        //    cout<<i<<\" \";\n        }\n    }\n    //cout<<da\n    for (int i=1;i<=n;i++) ans[i]=i;\n    for (int i=1;i<=n;i++){\n        if (ad[i]!=-1){\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n    }\n    sort(d+1,d+1+n);\n    cnt=0;\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n            if (da[st[1]][0]+da[st[1]][1]!=0){\n                solve();\n            }\n            cnt=0;\n        }\n        else {\n            st[++cnt]=d[i].ID;\n        }\n    }\n    for (int i=1;i<=n;i++)\n        if (ad[i]==-1 && da[i][0]<=w && da[i][1]<=h){\n//            tmp++;\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n        else {d[i].S=0;}\n    cnt=0;\n    sort(d+1,d+1+n);\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n              //  if (d[i].S==6) {\n             //       for (int j=1;j<=cnt;j++) cout<<st[j]<<\" \"<<d[st[j]].S<<endl;\n               //     cout<<endl;\n              //  }\n            if (da[st[1]][0]+da[st[1]][1]!=0) {\n                for (int j=1;j<=cnt-1;j++){\n                    if (da[st[j]][0]==da[st[j+1]][0]){\n                        da[st[j]][2]=1-da[st[j]][2];\n                        da[st[j+1]][2]=1-da[st[j+1]][2];\n                        if (da[st[j]][2]>da[st[j+1]][2]) swap(st[j],st[j+1]);\n                    }\n                }\n                solve();\n                for (int j=1;j<=cnt-1;j++){\n                   /* if (da[st[j]][0]==da[st[j+1]][0]){\n                        swap(ans[st[j]],ans[st[j+1]]);\n                    }*/\n                }\n            }\n            cnt=0;\n        }\n        else if (d[i].S==d[i+1].S) {\n            st[++cnt]=d[i].ID;\n        }\n    }\n   // cout<<endl;\n    for (int i=1;i<=n;i++){\n        if (da[ans[i]][2]==0){\n            fin[i].first=h-da[ans[i]][1]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n        else {\n            fin[i].first=w-da[ans[i]][0]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n    }\n    sort(fin+1,fin+1+n);\n    for (int i=1;i<=n;i++) cout<<fin[i].second.first<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ad[200069],st[200059],pos[200069][2],cnt,w,h,n,da[200069][4],ans[200069],cnt1,cnt2,st1[200069],st2[200069],pos1,pos2;\nstring s;\ntypedef pair<int,int> ii;\ntypedef pair<ii,ii> iii;\ntypedef pair<int,ii> iiii;\niiii fin[200069];\niii d[200069];\n#define S first.first\n#define T first.second\n#define ID second.second\n#define X second.first\n\nvoid solve(){\n    cnt1=cnt2=0;\n    for (int i=1;i<=cnt;i++){\n         if (da[st[i]][2]) st1[++cnt1]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n         else st2[++cnt2]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n    }\n    for (int i=1;i<=cnt;i++){\n            pos1=pos[i][0];\n            pos2=pos[i][1];\n         //   cout<<pos1<<\" \"<<pos2<<\" \"<<da[st[i]][2]<<\"---\"<<st[i]<<endl;\n        if (da[st[i]][2]==0){\n            if (pos1>=cnt2-pos2+1) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2+1)];\n            }\n            else if (pos1<cnt2-pos2){\n                ans[st[i]]=st2[pos1+pos2];\n            }\n        }\n        else {\n            if (pos1-1>=cnt2-pos2) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2)];\n            }\n            else if (pos1-1<cnt2-pos2){\n                ans[st[i]]=st2[pos2+pos1];\n            }\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for (int i=1;i<=n;i++){\n        scanf(\"%d%d\",&da[i][0],&da[i][1]);\n        cin>>s;\n        if (s==\"E\") da[i][2]=1;\n        else da[i][2]=0;\n        if ((da[i][0]+da[i][1])%2==1){\n            if (da[i][2]) da[i][0]++;\n            else da[i][1]++;\n            ad[i]=-1;\n        }\n    }\n    //cout<<da\n    for (int i=1;i<=n;i++) ans[i]=i;\n    for (int i=1;i<=n;i++){\n        if (ad[i]!=-1){\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n    }\n    sort(d+1,d+1+n);\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n            if (d[i].S!=0) solve();\n            cnt=0;\n        }\n        else {\n            st[++cnt]=d[i].ID;\n        }\n    }\n    for (int i=1;i<=n;i++)\n        if (ad[i]==-1){\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n        else {d[i].S=0;}\n\n    sort(d+1,d+1+n);\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n            for (int j=1;j<=cnt-1;j++){\n                if (d[st[j]].X==d[st[j+1]].X){\n                    da[st[j]][2]=1-da[st[j]][2];\n                    da[st[j+1]][2]=1-da[st[j+1]][2];\n                    if (da[st[j]][2]>da[st[j+1]][2]) swap(st[j],st[j+1]);\n                }\n            }\n            if (d[i].S!=0) solve();\n            for (int j=1;j<=cnt-1;j++){\n                if (d[st[j]].X==d[st[j+1]].X){\n                    da[st[j]][2]=1-da[st[j]][2];\n                    da[st[j+1]][2]=1-da[st[j+1]][2];\n                    swap(ans[st[j]],ans[st[j+1]]);\n                }\n            }\n            cnt=0;\n        }\n        else {\n            st[++cnt]=d[i].ID;\n        }\n    }\n   // for (int i=1;i<=n;i++) cout<<ans[i]<<endl;\n    for (int i=1;i<=n;i++){\n        if (da[ans[i]][2]==0){\n            fin[i].first=h-da[ans[i]][1]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n        else {\n            fin[i].first=w-da[ans[i]][0]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n    }\n    sort(fin+1,fin+1+n);\n    for (int i=1;i<=n;i++) cout<<fin[i].second.first<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <stdlib.h>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\nconst double EPS = 1e-8;\n#define Scan(a) int a;scanf(\"%d\", &a);\n#define ScanS(a) char a[500];scanf(\"%s\", a);\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1LL)\n#define bitset(a,b)      ( a |= (1LL << b))\n#define bitunset(a,b)    (a &= ~(1LL << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\npii operator+(pii obj, pii obj2) {\n\treturn MP(obj.first + obj2.first, obj.second + obj2.second);\n}\npii operator-(pii obj, pii obj2) {\n\treturn MP(obj.first - obj2.first, obj.second - obj2.second);\n}\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n\tvoid scan(int edcount, bool oindexed, bool w) {\n\t\tREP(i, edcount) {\n\t\t\tint a, b, c = 1;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (w)scanf(\"%d\", &c);\n\t\t\tcon(a - oindexed, b - oindexed, c);\n\t\t}\n\t}\n};\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\nclass DGraph : public Graph {//??????\npublic:\n\tDGraph(int n) : Graph(n) {}\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tsumcost++;\n\t}\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nint main() {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\n\tmap<int, vector<pair<pii, pair<char, int>>>> ant;\n\tvector<pair<pii, char>> ar(n);\n\tREP(i, n) {\n\t\tint x, y;\n\t\tchar d;\n\t\tscanf(\"%d %d %c\", &x, &y, &d);\n\n\t\tant[x + y].push_back({ {x,y}, {d,i} });\n\t\tar[i] = { {x,y},d };\n\t}\n\n\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\n\tfor (auto itr : ant) {\n\t\tsort(ALL(itr.second), greater<pair<pii, pair<char, int>>>());\n\n\t\tif (itr.first % 2 == 0) {\n\t\t\tqueue<int> que[2];\n\t\t\tfor (auto itr2 : itr.second) {\n\t\t\t\tif (itr2.second.first == 'S')\n\t\t\t\t\tque[itr2.first.first%2].push(itr2.second.second);\n\t\t\t\telse {\n\t\t\t\t\tif (que[itr2.first.first % 2].empty()) {\n\t\t\t\t\t\tpq.push({ w - itr2.first.first ,itr2.second.second });\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint cur = que[itr2.first.first % 2].front();\n\t\t\t\t\t\tque[itr2.first.first % 2].pop();\n\t\t\t\t\t\tpq.push({ w - itr2.first.first ,cur });\n\t\t\t\t\t\tpq.push({ h - ar[cur].first.second ,itr2.second.second });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (que[0].size()) {\n\t\t\t\tint cur = que[0].front();\n\t\t\t\tpq.push({ h - ar[cur].first.second , cur });\n\t\t\t\tque[0].pop();\n\t\t\t}\n\t\t\twhile (que[1].size()) {\n\t\t\t\tint cur = que[1].front();\n\t\t\t\tpq.push({ h - ar[cur].first.second , cur });\n\t\t\t\tque[1].pop();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tqueue<int> que[2];\n\t\t\tfor (auto itr2 : itr.second) {\n\t\t\t\tif (itr2.second.first == 'S')\n\t\t\t\t\tque[1 - itr2.first.first % 2].push(itr2.second.second);\n\t\t\t\telse {\n\t\t\t\t\tif (que[itr2.first.first % 2].empty()) {\n\t\t\t\t\t\tpq.push({ w - itr2.first.first ,itr2.second.second });\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tint cur = que[itr2.first.first % 2].front();\n\t\t\t\t\t\tque[itr2.first.first % 2].pop();\n\t\t\t\t\t\tpq.push({ w - itr2.first.first ,cur });\n\t\t\t\t\t\tpq.push({ h - ar[cur].first.second ,itr2.second.second });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (que[0].size()) {\n\t\t\t\tint cur = que[0].front();\n\t\t\t\tpq.push({ h - ar[cur].first.second , cur });\n\t\t\t\tque[0].pop();\n\t\t\t}\n\t\t\twhile (que[1].size()) {\n\t\t\t\tint cur = que[1].front();\n\t\t\t\tpq.push({ h - ar[cur].first.second , cur });\n\t\t\t\tque[1].pop();\n\t\t\t}\n\t\t}\n\t}\n\twhile (pq.size()) {\n\t\tprintf(\"%d\\n\", pq.top().second + 1);\n\t\tpq.pop();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w,h,n,m,i,x,y,z,xx,yy;\nstruct data{\n    int x,y,z;\n} a[200100];\nint t[200100],p[200100],s[3][200100],ww[200100][3],num[3],res[300100];\nchar ch;\nvector <int> v;\n\nbool cmp(int u,int v) {\n    return (a[u].x+a[u].y<a[v].x+a[v].y) || (a[u].x+a[u].y==a[v].x+a[v].y && a[u].y<a[v].y);\n}\n\nbool cmp1(int x,int y) {\n    return (res[x]<res[y]) || (res[x]==res[y] && x<y);\n}\n\nvoid cal2() {\n    num[0]=num[1]=0;\n    for (int i=1;i<=m;++i) {\n        s[a[p[i]].z][++num[a[p[i]].z]]=p[i];\n        ww[i][0]=num[0]; ww[i][1]=num[1];\n    }\n\n    for (int i=1;i<=m;++i) {\n        x=ww[i-1][1];\n        y=num[0]-ww[i][0];\n        z=a[p[i]].z;\n        xx=yy=min(x,y);\n        if (z==0 && x>xx) xx++;\n        if (z==1 && y>yy) yy++;\n\n        x=x-xx+1; y=ww[i][0]+yy;\n        x=s[1][x]; y=s[0][y];\n        if ((xx+yy)%2==1) z=1-z;\n\n        if (xx+yy>0) {\n            res[p[i]]+=a[y].y-a[x].y;\n            if (z==0) res[p[i]]+=h+1-a[y].x;\n                else res[p[i]]+=w+1-a[x].y;\n        }\n        else {\n            if (z==0) res[p[i]]+=h+1-a[p[i]].x;\n                else res[p[i]]+=w+1-a[p[i]].y;\n        }\n    }\n}\n\nvoid cal() {\n    if ((a[v[0]].x+a[v[0]].y)%2==1) {\n        for (int i=0;i<v.size();++i) {\n            if (a[v[i]].z==0) a[v[i]].x++;\n                else a[v[i]].y++;\n            res[v[i]]++;\n            if (i>0 && a[v[i]].z==0 && a[v[i-1]].x==a[v[i]].x && a[v[i-1]].y==a[v[i]].y)\n                swap(a[v[i]].z,a[v[i-1]].z);\n        }\n    }\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==0 && a[v[i]].x<=h && a[v[i]].y<=w) p[++m]=v[i];\n    if (m>0) cal2();\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==1 && a[v[i]].x<=h && a[v[i]].y<=w) p[++m]=v[i];\n    if (m>0) cal2();\n}\n\nint main() {\n    /*freopen(\"ant.inp\",\"r\",stdin);\n    freopen(\"ant.out\",\"w\",stdout);//*/\n\n    scanf(\"%d %d %d\",&w,&h,&n);\n    for (i=1;i<=n;++i) {\n        scanf(\"%d %d %c\\n\",&a[i].y,&a[i].x,&ch);\n        if (ch=='E') a[i].z=1;\n            else a[i].z=0;\n        t[i]=i;\n    }\n\n    sort(t+1,t+1+n,cmp);\n\n    for (i=1;i<=n;++i) {\n        v.push_back(t[i]);\n        if (i==n || a[t[i]].x+a[t[i]].y!=a[t[i+1]].x+a[t[i+1]].y) {\n            cal();\n            v.clear();\n        }\n    }\n    for (i=1;i<=n;++i) t[i]=i;\n    sort(t+1,t+1+n,cmp1);\n    //for (i=1;i<=n;++i) printf(\"%d \",res[i]); cout << endl;\n    for (i=1;i<=n;++i) printf(\"%d\\n\",t[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ad[200069],st[200059],pos[200069][2],cnt,w,h,n,da[200069][4],ans[200069],cnt1,cnt2,st1[200069],st2[200069],pos1,pos2;\nstring s;\ntypedef pair<int,int> ii;\ntypedef pair<ii,ii> iii;\ntypedef pair<int,ii> iiii;\niiii fin[200069];\niii d[200069];\n#define S first.first\n#define T first.second\n#define ID second.second\n#define X second.first\n\nvoid solve(){\n    cnt1=cnt2=0;\n    for (int i=1;i<=cnt;i++){\n         if (da[st[i]][2]) st1[++cnt1]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n         else st2[++cnt2]=st[i],pos[i][0]=cnt1,pos[i][1]=cnt2;\n    }\n   // cout<<endl;\n    for (int i=1;i<=cnt;i++){\n            pos1=pos[i][0];\n            pos2=pos[i][1];\n        if (da[st[i]][2]==0){\n            if (pos1>=cnt2-pos2+1) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2)];\n            }\n            else if (pos1<cnt2-pos2){\n                ans[st[i]]=st2[pos1+pos2];\n            }\n        }\n        else {\n            if (pos1-1>=cnt2-pos2) {\n                ans[st[i]]=st1[pos1-(cnt2-pos2)];\n            }\n            else if (pos1-1<cnt2-pos2){\n                ans[st[i]]=st2[pos2+pos1];\n            }\n        }\n           // cout<<pos1<<\" \"<<pos2<<\" \"<<da[st[i]][2]<<\"---\"<<st[i]<<\" \"<<ans[st[i]]<<endl;\n    }\n}\nint main(){\n    scanf(\"%d%d%d\",&w,&h,&n);\n    for (int i=1;i<=n;i++){\n        scanf(\"%d%d\",&da[i][0],&da[i][1]);\n        cin>>s;\n        if (s==\"E\") da[i][2]=1;\n        else da[i][2]=0;\n        if ((da[i][0]+da[i][1])%2==1){\n            if (da[i][2]) da[i][0]++;\n            else da[i][1]++;\n            ad[i]=-1;\n        }\n    }\n    //cout<<da\n    for (int i=1;i<=n;i++) ans[i]=i;\n    for (int i=1;i<=n;i++){\n        if (ad[i]!=-1){\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n    }\n    sort(d+1,d+1+n);\n    cnt=0;\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n            if (d[st[1]].S!=0) solve();\n            cnt=0;\n        }\n        else {\n            st[++cnt]=d[i].ID;\n        }\n    }\n    for (int i=1;i<=n;i++)\n        if (ad[i]==-1){\n            d[i].S=da[i][0]+da[i][1];\n            d[i].X=da[i][0];\n            d[i].ID=i;\n            d[i].T=da[i][0]%2;\n        }\n        else {d[i].S=0;}\n    cnt=0;\n    sort(d+1,d+1+n);\n    for (int i=1;i<=n;i++){\n        if (d[i].S!=d[i+1].S || d[i].T!=d[i+1].T) {\n            st[++cnt]=d[i].ID;\n            for (int j=1;j<=cnt-1;j++){\n                if (d[st[j]].X==d[st[j+1]].X){\n                    da[st[j]][2]=1-da[st[j]][2];\n                    da[st[j+1]][2]=1-da[st[j+1]][2];\n                    if (da[st[j]][2]>da[st[j+1]][2]) swap(st[j],st[j+1]);\n                }\n            }\n            if (d[i].S!=0) solve();\n            for (int j=1;j<=cnt-1;j++){\n                if (d[st[j]].X==d[st[j+1]].X){\n                    swap(ans[st[j]],ans[st[j+1]]);\n                }\n            }\n            cnt=0;\n        }\n        else {\n            st[++cnt]=d[i].ID;\n        }\n    }\n   // for (int i=1;i<=n;i++) cout<<ans[i]<<\" \";\n   // cout<<endl;\n    for (int i=1;i<=n;i++){\n        if (da[ans[i]][2]==0){\n            fin[i].first=h-da[ans[i]][1]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n        else {\n            fin[i].first=w-da[ans[i]][0]-ad[i];\n            fin[i].second.second=ans[i];\n            fin[i].second.first=i;\n        }\n    }\n    sort(fin+1,fin+1+n);\n    for (int i=1;i<=n;i++) cout<<fin[i].second.first<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int  W, H, N;\n  cin >> W >> H >> N;\n\n  struct Ant {int id, x, y; string s;};\n  vector<Ant> ant(N);\n  for(int i = 0; i < N; ant[i].id = ++i) cin >> ant[i].x >> ant[i].y >> ant[i].s;\n\n  map<int, vector<Ant*>> group;\n  for(auto& i: ant) group[i.x + i.y].emplace_back(&i);\n  for(auto& g: group) sort(begin(g.second), end(g.second), [](auto l, auto r) {return l->x < r->x;});\n\n  map<int, set<int>> result;\n\n  auto white = [](auto& a) {return ! ((a.y + a.x) & 1);};\n  for(auto& g: group) {\n    deque<Ant*> q[2];\n    for(auto& a: g.second) {\n      auto p = a->x & 1;\n      if(a->s == \"E\") q[p].emplace_back(a);\n      else {\n        if(!white(*a)) p = !p;\n        if(!q[p].empty()) {\n          swap(a->id, q[p].front()->id);\n          for(auto nex = begin(q[p]), cur = nex++; nex != end(q[p]); ++cur, ++nex) swap((*cur)->id, (*nex)->id);\n        }\n        result[H - a->y].emplace(a->id);\n      }\n    }\n    for(auto i: {0, 1}) while(!q[i].empty()) {\n      result[W - q[i].front()->x].emplace(q[i].front()->id);\n      q[i].pop_front();\n    }\n  }\n\n  for(auto i: result) for(auto j: i.second) cout << j << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS  = 1e-10;\nconst bool debug = 1;\n//---------------------------//\n\nint W, H, N;\nint x[212345], y[212345], d[212345]; // ??±-0, ???-1\nint ord[212345];\n\nint main() {\n\tcin >> W >> H >> N;\n\tREP(i, N) {\n\t\tchar c;\n\t\tscanf(\"%d %d %c\", x + i, y + i, &c);\n\t\td[i] = c == 'S';\n\t}\n\t\n\tmap<int, vector<pii> > m; // x-y, (x, number)\n\tREP(i, N) m[x[i] + y[i]].push_back(pii(x[i], i));\n\t\n\tvector<vector<pii> > vv; // ????????????????????????\n\tfor (map<int, vector<pii> >::iterator it = m.begin(); it != m.end(); ++it) {\n\t\tvv.push_back(it->se);\n\t}\n\t\n\tvector<pii> ans; // (t, number)\n\tmemset(ord, -1, sizeof(ord));\n\t\n\tREP(i, vv.size()) {\n\t\tvector<pii> &v = vv[i];\n\t\tsort(ALL(v));\n\t\t\n\t\tvector<int> t(v.size());\n\t\tREP(j, v.size()) {\n\t\t\tif (d[v[j].se]) t[j] = H + 1 - y[v[j].se];\n\t\t\telse t[j] = W + 1 - x[v[j].se];\n\t\t}\n\t\t\n\t\tbool black = (x[v[0].se] + y[v[0].se]) & 1; // ???????????´?????????????????§??????????????????\n\t\t\n\t\tqueue<int> que[2]; // [y??§?¨??????¶?\\?] = ???number\n\t\t\n\t\tREP(j, v.size()) {\n\t\t\tint num = v[j].se; // ?????¨????????????????????????\n\t\t\tint idx = black ^ (y[num] & 1); // ??????????????????y??§?¨??????¶?\\?\n\t\t\tque[idx].push(num);\n\t\t\t\n\t\t\tif (d[num]) { // ???????????????????????????\n\t\t\t\tord[j] = que[idx].front();\n\t\t\t\tque[idx].pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > pq;\n\t\tREP(j, 2) while (!que[j].empty()) {\n\t\t\tint num = que[j].front();\n\t\t\tque[j].pop();\n\t\t\tpq.push(pii(y[num], num));\n\t\t}\n\t\tint p = 0;\n\t\twhile (!pq.empty()) {\n\t\t\tint num = pq.top().se;\n\t\t\tpq.pop();\n\t\t\t\n\t\t\twhile (ord[p] != -1) p++;\n\t\t\tord[p] = num;\n\t\t}\n\t\t\n\t\tREP(j, v.size()) ans.push_back(pii(t[j], ord[j]));\n\t\tREP(j, v.size()) ord[j] = -1;\n\t}\n\t\n\tsort(ALL(ans));\n\tREP(i, ans.size()) printf(\"%d\\n\", ans[i].se + 1);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fto(i, x, y) for(int i = (x); i <= (y); ++i)\n#define fdto(i, x, y) for(int i = (x); i >= (y); --i)\n#define ftoa(i, x, y, a) for(int i = (x); i <= (y); i += a)\n#define ftoit(it, var) for (__typeof(var.begin()) it = var.begin(); it != var.end(); ++it)\n\n#define ii pair<int, int>\n#define mp make_pair\n#define FF first\n#define SS second\n\n#define vi vector<int>\n#define vii vector<ii>\n#define ll long long\n#define vll vector<ll>\n\n#define eb emplace_back\n#define ef emplace_front\n#define lb lower_bound\n#define ub upper_bound\n#define sz(a) (int)a.size()\n\n#define oo 1000000007\n#define OO 1000000000000000007LL\n\nusing namespace std;\n\n#define Pro \"tmp\"\n#define maxN 100007\n\npair <ii, ii> sum[maxN];\nint x[maxN], y[maxN];\n\nbool dir[maxN];\nii ans[maxN];\n\nint main() {\n    int w, h, n;\n    scanf(\"%d%d%d\", &w, &h, &n);\n\n    fto (i, 1, n) {\n        scanf(\"%d%d\", &x[i], &y[i]);\n\n        char s[5];\n        scanf(\"%s\", s);\n\n        dir[i] = 0;\n        if (s[0] == 'S') dir[i] = 1;\n\n        sum[i] = mp(mp(x[i]+y[i], x[i]%2), mp(y[i], i));\n    }\n    sort(sum+1, sum+n+1);\n\n    vi trace;\n    trace.eb(sum[1].SS.SS);\n\n    fto (i, 2, n+1) {\n        if (sum[i].FF != sum[i-1].FF) {\n            vi row, col;\n            fto (j, 0, (int)trace.size()-1) {\n                int pos = trace[j];\n                if (dir[pos]) row.eb(x[pos]);\n                else col.eb(y[pos]);\n            }\n\n            sort(col.begin(), col.end());\n            sort(row.rbegin(), row.rend());\n\n            vii border;\n            fto (j, 0, (int)col.size()-1) border.eb(w+1, col[j]);\n            fto (j, 0, (int)row.size()-1) border.eb(row[j], h+1);\n\n            fto (j, 0, (int)trace.size()-1) {\n                int pos = trace[j];\n                int x_ = border[j].FF;\n                int y_ = border[j].SS;\n                ans[pos].FF += max(x[pos]-x_, x_-x[pos]) + max(y[pos]-y_, y_-y[pos]);\n                ans[pos].SS = pos;\n            }\n\n            trace.clear();\n        }\n        trace.eb(sum[i].SS.SS);\n    }\n\n    sort(ans+1, ans+n+1);\n    fto (i, 1, n) cout << ans[i].SS << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 200005\ntypedef pair<int,int> P;\nint N,H,W;\nint y[MAX],x[MAX];\nchar dir[MAX];\nint cost[MAX];\nint ans[MAX];\nchar str[100];\nmap<int, vector<P> > mp;\n\nvoid calc(vector<P> v,int flag){\n  int size=v.size();\n  sort(v.begin(),v.end());\n  queue<int> da[2];\n  queue<int> db[2];\n  for(int i=0;i<size;i++){\n    int px=v[i].first;\n    int id=v[i].second;\n    int xa=px%2;\n    int xb=(px+flag)%2;\n    if(dir[id]=='S'){\n      da[xa].push(id);\n      ans[ da[xa].front() ]=cost[id];\n      da[xa].pop();\n    }else{\n      da[xb].push(id);\n      db[xb].push(cost[id]);\n    }\n  }\n  for(int i=0;i<2;i++){\n    while(!da[i].empty()){\n      ans[ da[i].front() ]=db[i].front();\n      da[i].pop();\n      db[i].pop();      \n    }\n  }\n}\n\nvoid solve(){\n  map<int, vector<P> > :: iterator it;\n  for(it=mp.begin();it!=mp.end();it++)calc(it->second,it->first%2);\n}\n\nint main(){\n  scanf(\"%d %d %d\",&W,&H,&N);\n  for(int i=0;i<N;i++){\n    scanf(\"%d %d %s\",&x[i],&y[i],str);\n    dir[i]=str[0];\n    cost[i]=(dir[i]=='S'?H-y[i]:W-x[i]);\n    mp[ y[i]+x[i] ].push_back( P(x[i],i) );\n  }\n  solve();\n  vector<P> vec(N);\n  for(int i=0;i<N;i++)vec[i]=P( ans[i],i );\n  sort(vec.begin(),vec.end());\n  for(int i=0;i<N;i++)\n    printf(\"%d\\n\",vec[i].second+1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nint cur = -1 , cnt = 0 ;\n\nint m , n , k ;\n\nstruct T{\n\tint x ; int y ; int direc ; int id ;\n\tT(){}\n\tT( int foo , int bar , int type , int _id ){\n\t\tx = foo ; y = bar ; direc = type ; id = _id ;\n\t}\n\tbool operator < ( const T &op ) const{\n\t\treturn ( x + y != op.x + op.y ) ? x + y < op.x + op.y : x > op.x ;\n\t}\n} Ant[200010] ;\n\nvector < T > Lis[200010] ;\n\nint ans[200010] ;\n\npair < int, int > res[200010] ;\n\nvoid find_answer( vector < T > &foo ){\n\tdeque < int > q[2] ;\n\tfor( int i = 0 ; i < (int)foo.size() ; ++ i ){\n\t\tT bar = foo[i] ;\n\t\tif( bar.direc == 1 ){\n\t\t\tq[bar.x % 2].push_front( bar.id ) ;\n\t\t}\n\t\telse{\n\t\t\tint need ;\n\t\t\tif( (bar.x + bar.y) % 2 == 0 ) need = bar.x % 2 ;\n\t\t\telse need = 1 - bar.x % 2 ;\n\t\t\t\n\t\t\tif( q[need].empty() ) ans[bar.id] = m - bar.x ;\n\t\t\telse{\n\t\t\t\tans[q[need].back()] = m - bar.x ;\n\t\t\t\tq[need].pop_back() ; q[need].push_front(bar.id) ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor( int i = 0 ; i < (int)foo.size() ; ++ i ){\n\t\tT bar = foo[i] ;\n\t\tif( bar.direc == 1 ) ans[q[bar.x % 2].back()] = n - bar.y , q[bar.x % 2].pop_back() ;\n\t}\n}\n\nint main(){\n\t#define NAME \"Ant\"\n\t//freopen( NAME\".inp\" , \"r\" , stdin ) ; freopen( NAME\".out\" , \"w\" , stdout ) ;\n\n\tcin >> m >> n >> k ;\n\n\tfor( int i = 1 ; i <= k ; ++ i ){\n\t\tint x , y , type ; char c ; cin >> x >> y >> c ;\n\t\tif( c == 'E' ) type = 0 ;\n\t\telse type = 1 ;\n\t\tAnt[i] = T( x , y , type , i ) ;\n\t}\n\n\tsort( Ant + 1 , Ant + k + 1 ) ;\n\n\tfor( int i = 1 ; i <= k ; ++ i ){\n\t\tif( cur != Ant[i].x + Ant[i].y ) cur = Ant[i].x + Ant[i].y , cnt ++ ;\n\t\tLis[cnt].push_back( Ant[i] ) ;\n\t}\n\n\tfor( int i = 1 ; i <= cnt ; ++ i ) find_answer(Lis[i]) ;\t\n\n\tfor( int i = 1 ; i <= k ; ++ i ) res[i] = make_pair(ans[i] , i) ;\n\n\tsort(res + 1 , res + k + 1) ;\n\t\n\tfor( int i = 1 ; i <= k ; ++ i ) cout << res[i].second << endl ;\n\n\treturn 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200005;\n\nint n, w, h;\nint val[N], res[N];\n\nstruct Ant {\n\tint x, y, id; \n\tchar t;\n} a[N];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> w >> h >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i].x >> a[i].y >> a[i].t, a[i].id = i;\n\t\tif (a[i].t == 'E') val[i] = w - a[i].x;\n\t\telse val[i] = h - a[i].y;\n\t}\n\tsort(a, a + n, [&] (Ant p, Ant q) {\n\t\treturn p.x + p.y < q.x + q.y;\n\t});\n\tfor (int i = 0; i < n; ++i) {\n\t\tvector<Ant> go[2];\n\t\tint j = i;\n\t\twhile (i < n && a[j].x + a[j].y == a[i].x + a[i].y) {\n\t\t\tif (a[i].t == 'E') {\n\t\t\t\tgo[a[i].y & 1].push_back(a[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgo[a[i].x & 1].push_back(a[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\tsort(go[j].begin(), go[j].end(), [&] (Ant p, Ant q) {\n\t\t\t\treturn p.x == q.x ? p.t < q.t : p.x < q.x;\n\t\t\t});\n\t\t\tvector<Ant> vec;\n\t\t\tfor (auto k : go[j]) {\n\t\t\t\tif (k.t == 'E') {\n\t\t\t\t\tk.x = w, vec.push_back(k);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk.y = h, vec.push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vec.begin(), vec.end(), [&] (Ant p, Ant q) {\n\t\t\t\treturn p.x < q.x;\n\t\t\t});\n\t\t\tfor (int k = 0; k < vec.size(); ++k) {\n\t\t\t\tres[go[j][k].id] = val[vec[k].id];\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\tvector<int> p;\n\tfor (int i = 0; i < n; ++i) p.push_back(i);\n\tsort(p.begin(), p.end(), [&] (int x, int y) {\n\t\treturn res[x] == res[y] ? x < y : res[x] < res[y];\n\t});\n\tfor (auto i : p) cout << i + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <utility>\n\n#define ff(i,a,b) for (int i=(a);i<=(b);i++)\nusing namespace std;\ntypedef pair<int,int> ii;\nconst int N=2e5+10;\nint w,h,n;\nstruct kien {\n    int x,y,huong,id;\n};\nii T[N]; int tmp[N];\nkien a[N];\nint cmpVal (const kien& k) {\n    if (k.huong==0) ///Đông\n        return (k.x&1)?3:1;\n    return (k.x&1)?2:4;\n}\nbool cmpKien (const kien& k1, const kien& k2) {\n    ///Đầu tiên sort theo đường chéo.\n    if (k1.x+k1.y != k2.x+k2.y)\n        return k1.x+k1.y < k2.x+k2.y;\n\n    int xxk1 = (k1.x & 1), xxk2 = (k2.x & 1);\n    if (((k1.x+k1.y)&1) == 0) { ///Ô trắng.\n        if (xxk1 != xxk2) return xxk1<xxk2;\n        else return k1.huong<k2.huong;\n    }\n    else {\n        int tmp1=cmpVal (k1), tmp2 = cmpVal (k2);\n        return tmp1 < tmp2;\n    }\n}\nbool cungNhom (const kien &k1, const kien &k2) {\n    if (k1.x+k1.y != k2.x+k2.y) return 0;\n    int xxk1=k1.x&1, xxk2=k2.x&1;\n    if (!((k1.x+k1.y)&1)) {\n        return xxk1 == xxk2;\n    }\n    int val1=(k1.huong<<1)+xxk1, val2=(k2.huong<<1)+xxk2;\n    return ((val1^val2)==0 || (val1^val2)==3);\n}\nbool cmp2 (const kien &k1, const kien &k2) {\n    if (k1.huong != k2.huong) return k1.huong < k2.huong;\n    if (k1.huong == 0)\n        return k1.y < k2.y;\n    else\n        return k1.x > k2.x;\n}\nint tgRoi (const kien &k) {\n    return (k.huong==0)?w-k.x:h-k.y;\n}\nbool cmp3 (const kien &k1, const kien &k2) {\n    return k1.x-k1.y > k2.x-k2.y;\n}\nint main() {/*\n    freopen(\"10.inp\",\"r\",stdin); freopen(\"10.out\",\"w\",stdout); //*/\n    scanf(\"%d %d %d\\n\",&w,&h,&n);\n    ff(i,1,n) {\n        int x,y; char c; scanf(\"%d %d %c\\n\",&x,&y,&c);\n        a[i] = {x,y,(c=='E')?0:1,i};\n    }\n    sort(a+1, a+n+1, cmpKien);\n    int l=1, r=1;\n    do {\n        if (l>n) break;\n        while (r<=n && cungNhom(a[l], a[r])) r++;\n        sort(a+l, a+r, cmp2);\n        ff(i,l,r-1) tmp[i]=tgRoi(a[i]);\n        sort(a+l, a+r, cmp3);\n        ff(i,l,r-1) T[a[i].id] = ii(tmp[i], a[i].id);\n        l=r;\n    } while (1);\n    sort(T+1, T+n+1);\n    ff(i,1,n) printf(\"%d\\n\",T[i].second);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(){\n\t\tx = y = id = 0;\n\t\tdir = '@';\n\t}\n\tInfo(int arg_x,int arg_y,int arg_id,char arg_dir){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tid = arg_id;\n\t\tdir = arg_dir;\n\t}\n\tbool operator<(const struct Info &arg) const{ //x座標の昇順\n\t\treturn x < arg.x;\n\t}\n\tint x,y,id;\n\tchar dir;\n};\n\nstruct Data{\n\tData(int arg_time,int arg_id){\n\t\ttime = arg_time;\n\t\tid = arg_id;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\tif(time != arg.time){ //落下時刻が異なれば、昇順(PQ)\n\t\t\treturn time > arg.time;\n\t\t}else{ //落下時刻が同じなら、idの昇順(PQ)\n\t\t\treturn id > arg.id;\n\t\t}\n\t}\n\tint time,id;\n};\n\nint W,H,N;\nInfo info[200000];\nmap<int,bool> MAP;\nmap<int,int> SUM_MAP;\nvector<Info> GROUP[200000];\nvector<int> V;\npriority_queue<Data> ANS_Q;\n\n\nvoid calc_group(int id){\n\tint sum = V[id];\n\tint ant_id,most_left_ant,time;\n\tqueue<int> ID,REST_TIME;\n\n\tif(sum%2 == 0){ //全員が白いマス:x座標の偶奇が同じ者同士が白いマスで出会う\n\n\t\tfor(int i = 0; i <= 1; i++){ //x座標の偶奇のループ\n\n\t\t\tfor(int k = 0; k < GROUP[id].size(); k++){\n\t\t\t\tif(GROUP[id][k].x%2 != i)continue; //x座標の偶奇がiと一致しないならSKIP\n\n\t\t\t\tant_id = GROUP[id][k].id;\n\n\t\t\t\tif(info[ant_id].dir == 'S'){ //南向きの蟻\n\t\t\t\t\tID.push(ant_id); //idをpush\n\t\t\t\t\tmost_left_ant = ID.front(); //最も左にいる(最後にすれ違う)蟻のIDを取り出し\n\t\t\t\t\tID.pop();\n\n\t\t\t\t\t//★most_left_antは、南向きの蟻(ant_id)が落ちるはずだった時刻に落ちる★\n\t\t\t\t\ttime = H-info[ant_id].y;\n\n\t\t\t\t\tANS_Q.push(Data(time,most_left_ant));\n\n\t\t\t\t}else{ //東向きの蟻\n\t\t\t\t\tID.push(ant_id); //idをpush\n\t\t\t\t\tREST_TIME.push(W-info[ant_id].x); //落ちるまでの時間をpush\n\t\t\t\t}\n\t\t\t}\n\t\t\t//右向きの蟻\n\t\t\twhile(!ID.empty()){\n\t\t\t\tmost_left_ant = ID.front(); //最も左にいる蟻のIDを取り出し\n\t\t\t\tID.pop();\n\n\t\t\t\t//落下する時刻を求める:元々右向きの蟻が落ちるはずだった時刻に落ちる\n\t\t\t\ttime = REST_TIME.front();\n\t\t\t\tREST_TIME.pop();\n\n\t\t\t\tANS_Q.push(Data(time,most_left_ant));\n\t\t\t}\n\t\t}\n\n\t}else{ //全員が黒いマス:x座標の偶奇が異なる者同士が白いマスで出会う\n\n\t\tfor(int i = 0; i <= 1; i++){ //x座標の偶奇のループ\n\n\t\t\tfor(int k = 0; k < GROUP[id].size(); k++){\n\t\t\t\t//x座標の偶奇がiと一致する東向きの蟻と、x座標の偶奇がiと異なる南向きの蟻を処理する\n\t\t\t\tif(GROUP[id][k].x%2 != i && info[GROUP[id][k].id].dir == 'E')continue;\n\t\t\t\tif(GROUP[id][k].x%2 == i && info[GROUP[id][k].id].dir == 'S')continue;\n\n\t\t\t\tant_id = GROUP[id][k].id;\n\n\t\t\t\tif(info[ant_id].dir == 'S'){ //南向きの蟻\n\t\t\t\t\tID.push(ant_id); //idをpush\n\t\t\t\t\tmost_left_ant = ID.front(); //最も左にいる(最後にすれ違う)蟻のIDを取り出し\n\t\t\t\t\tID.pop();\n\n\t\t\t\t\t//★most_left_antは、南向きの蟻(ant_id)が落ちるはずだった時刻に落ちる★\n\t\t\t\t\ttime = H-info[ant_id].y;\n\n\t\t\t\t\tANS_Q.push(Data(time,most_left_ant));\n\n\t\t\t\t}else{ //東向きの蟻\n\t\t\t\t\tID.push(ant_id); //idをpush\n\t\t\t\t\tREST_TIME.push(W-info[ant_id].x); //落ちるまでの時間をpush\n\t\t\t\t}\n\t\t\t}\n\t\t\t//右向きの蟻\n\t\t\twhile(!ID.empty()){\n\t\t\t\tmost_left_ant = ID.front(); //最も左にいる蟻のIDを取り出し\n\t\t\t\tID.pop();\n\n\t\t\t\t//落下する時刻を求める:元々右向きの蟻が落ちるはずだった時刻に落ちる\n\t\t\t\ttime = REST_TIME.front();\n\t\t\t\tREST_TIME.pop();\n\n\t\t\t\tANS_Q.push(Data(time,most_left_ant));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint tmp;\n\tscanf(\"%d %d %d\",&W,&H,&N);\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].x,&info[i].y,buf);\n\t\tinfo[i].id = i;\n\t\tinfo[i].dir = buf[0];\n\n\t\ttmp = info[i].x+info[i].y;\n\n\t\tauto at = MAP.find(tmp);\n\n\t\tif(at != MAP.end())continue;\n\t\tMAP[tmp] = true;\n\t\tV.push_back(tmp);\n\t}\n\n\tsort(V.begin(),V.end());\n\n\tfor(int i = 0; i < V.size(); i++){\n\t\tSUM_MAP[V[i]] = i;\n\t}\n\n\t//x+yの値ごとに、蟻をグループ分けする\n\tfor(int i = 0; i < N; i++){\n\t\tGROUP[SUM_MAP[info[i].x+info[i].y]].push_back(info[i]);\n\t}\n\n\tfor(int i = 0; i < V.size(); i++){\n\t\tsort(GROUP[i].begin(),GROUP[i].end());\n\t\tcalc_group(i);\n\t}\n\n\twhile(!ANS_Q.empty()){\n\t\tprintf(\"%d\\n\",ANS_Q.top().id+1);\n\t\tANS_Q.pop();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n#define DB(x) cout<<#x<<'='<<x<<endl;\n\nusing P = pair<LL,LL>;\n\nstruct state{\n\tLL x,y;\n\tbool s;//false:right true:down\n\tint ind;//?????????\n\tbool operator<(const state& o)const{\n\t\tif(x==o.x){\n\t\t\tif(y==o.y){\n\t\t\t\tif(s==o.s){\n\t\t\t\t\treturn ind<o.ind;\n\t\t\t\t}\n\t\t\t\treturn s<o.s;\n\t\t\t}\n\t\t\treturn y<o.y;\n\t\t}\n\t\treturn x<o.x;\n\t}\n};\n\nLL W,H,N;\nmap<LL,vector< state >>cash;\n\nint main(){\n\tcin>>W>>H>>N;\n\tfor(int i=0;i<N;++i){\n\t\tLL x,y;char d;\n\t\tcin>>x>>y>>d;\n\t\t--x;--y;\n\t\tcash[x+y].push_back({x,y,(d=='S'),i+1});\n\t}\n\tset<P>ans;//first:time second:ant\n\tfor(auto p:cash){\n\t\tLL depth = p.first;\n\t\tauto& vec = p.second;\n\t\tbool color = (depth%2);//false:white true:black\n\t\t//y????????????x???????????????????????????\n\t\tsort(vec.begin(),vec.end());\n\t\tqueue<int>ant[2];//?????????(0:even 1:odd)\n\t\tfor(auto elm:vec){\n\t\t\tLL x=elm.x,y=elm.y;\n\t\t\tbool s=elm.s;int ind=elm.ind;\n\t\t\tif(!s){\n\t\t\t\t//right\n\t\t\t\tant[y%2].push(ind);\n\t\t\t}else{\n\t\t\t\t//up\n\t\t\t\tbool par = (y%2)^(color);\n\t\t\t\tant[par].push(ind);\n\t\t\t\tint pop = ant[par].front();\n\t\t\t\tant[par].pop();\n\t\t\t\tans.insert({H-y,pop});\n\t\t\t}\n\t\t}\n\t\tfor(auto elm:vec){\n\t\t\tLL x=elm.x,y=elm.y;\n\t\t\tbool s=elm.s;int ind=elm.ind;\n\t\t\tif(s)continue;\n\t\t\tint id = ant[y%2].front();\n\t\t\tant[y%2].pop();\n\t\t\tans.insert({W-x,id});\n\t\t}\n\t}\n\tfor(auto p : ans){\n\t\t//cout<<p.first<<\" \"<<p.second<<endl;\n\t\tcout<<p.second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint W, H, N;\nint X[200000], Y[200000];\nchar D[200000];\nmap<int, vector<int> > mp;\nint F[200000];\nint T[200000];\n\nvoid solve(vector<int> &seq) {\n  if (seq.empty()) return;\n  //cout<<\"{\"; for (int x : seq) cout << x<<\",\";cout<<\"}\\n\";\n  vector<int> left, right;\n  vector<P> xs;\n  for (int i : seq) {\n    xs.pb(P(X[i], i));\n  }\n  sort(all(xs));\n  for (P p : xs) {\n    int i = p._2;\n    if (D[i] == 'S') left.pb(i);\n    else right.pb(i);\n  }\n  // LLL...RR\n  rep(j, xs.size()) {\n    int i = xs[j]._2;\n    if (j < left.size()) {\n      T[i] = F[left[j]];\n    }\n    else {\n      T[i] = F[right[j - (int)left.size()]];\n    }\n  }\n  sort(all(xs));\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> W >> H >> N;\n  rep(i, N) {\n    cin >> X[i] >> Y[i] >> D[i];\n    mp[X[i]+Y[i]].pb(i);\n    if (D[i] == 'S') F[i] = H - Y[i];\n    else F[i] = W - X[i];\n  }\n  rep(i, N) T[i] = -1;\n  for (auto &p : mp) {\n    bool flip = p._1 % 2;\n    vector<int> a[2];\n    for (int i : p._2) {\n      int parity = X[i]%2;\n      if (flip && D[i] == 'S') parity ^= 1;\n      a[parity].pb(i);\n    }\n    solve(a[0]); solve(a[1]);\n  }\n  //rep(i, N) cout<<i<<\": \"<<T[i]<<\"\\n\";\n  vector<P> xs;\n  rep(i, N) xs.pb(P(T[i], i));\n  sort(all(xs));\n  rep(i, N) cout << xs[i]._2+1 << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint w, h, n;\nint x[200010];\nint y[200010];\nchar d[200010];\n\nmap<int, int> zip;\nvector<pair<int, int> > member[200010];\n\nint id[200010];\n\nsigned main(){\n    cin >> w >> h >> n;\n    vector<int> vec;\n\n    {\n        for(int i = 0;i < n;i++){\n            cin >> x[i] >> y[i] >> d[i];\n            vec.push_back(y[i]+x[i]);\n        }\n\n        sort(vec.begin(), vec.end());\n        vec.erase(unique(vec.begin(), vec.end()), vec.end());\n\n        for(int i = 0;i < vec.size();i++){\n            zip[vec[i]] = i;\n        }\n    }\n\n    for(int i = 0;i < n;i++){\n        member[zip[y[i]+x[i]]].push_back(make_pair(x[i], i));\n    }\n\n    for(int i = 0;i < vec.size();i++){\n        sort(member[i].begin(), member[i].end(), greater<pair<int, int> >());\n\n        queue<int> que1;\n        queue<int> que2;\n\n        queue<int> ans;\n\n        for(int j = 0;j < member[i].size();j++){\n            int idx = member[i][j].second;\n            if(d[idx] == 'S'){\n                if(x[idx] % 2 == 0){\n                    que1.push(idx);\n                }else{\n                    que2.push(idx);\n                }\n            }else{\n                if((y[idx]+x[idx])%2 == 0){\n                    if(x[idx]%2 == 0){\n                        que1.push(idx);\n                        ans.push(que1.front());\n                        que1.pop();\n                    }else{\n                        que2.push(idx);\n                        ans.push(que2.front());\n                        que2.pop();\n                    }\n                }else{\n                    if(x[idx]%2 == 1){\n                        que1.push(idx);\n                        ans.push(que1.front());\n                        que1.pop();\n                    }else{\n                        que2.push(idx);\n                        ans.push(que2.front());\n                        que2.pop();\n                    }\n                }\n            }\n        }\n\n        for(int j = 0;j < member[i].size();j++){\n            int idx = member[i][j].second;\n            if(d[idx] == 'S'){\n                if(x[idx] % 2 == 0){\n                    id[idx] = que1.front();\n                    que1.pop();\n                }else{\n                    id[idx] = que2.front();\n                    que2.pop();\n                }\n            }else{\n                id[idx] = ans.front();\n                ans.pop();\n            }\n        }\n    }\n\n    priority_queue<pair<int, int> > ans;\n\n    for(int i = 0;i < n;i++){\n        if(d[i] == 'S'){\n            ans.push(make_pair(-(h-y[i]), -id[i]));\n        }else{\n            ans.push(make_pair(-(w-x[i]), -id[i]));\n        }\n    }\n\n    while(!ans.empty()){\n        cout << -ans.top().second+1 << endl;\n        ans.pop();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w,h,n,m,i,x,y,z,xx,yy;\nstruct data{\n    int x,y,z;\n} a[200100];\nint t[200100],p[200100],s[3][200100],ww[200100][3],num[3],res[300100];\nchar ch;\nvector <int> v;\n\nbool cmp(int u,int v) {\n    return (a[u].x+a[u].y<a[v].x+a[v].y) || (a[u].x+a[u].y==a[v].x+a[v].y && a[u].y<a[v].y);\n}\n\nbool cmp1(int x,int y) {\n    return (res[x]<res[y]) || (res[x]==res[y] && x<y);\n}\n\nvoid cal2() {\n    num[0]=num[1]=0;\n    for (int i=1;i<=m;++i) {\n        s[a[p[i]].z][++num[a[p[i]].z]]=p[i];\n        ww[i][0]=num[0]; ww[i][1]=num[1];\n    }\n\n    for (int i=1;i<=m;++i) {\n        x=ww[i-1][1];\n        y=num[0]-ww[i][0];\n        z=a[p[i]].z;\n        xx=yy=min(x,y);\n        if (z==0 && x>xx) xx++;\n        if (z==1 && y>yy) yy++;\n\n        x=x-xx+1; y=ww[i][0]+yy;\n        x=s[1][x]; y=s[0][y];\n        if ((xx+yy)%2==1) z=1-z;\n\n        if (xx+yy>0) {\n            res[p[i]]+=a[y].y-a[x].y;\n            if (z==0) res[p[i]]+=h+1-a[y].y;\n                else res[p[i]]+=w+1-a[x].x;\n        }\n        else {\n            if (z==0) res[p[i]]+=h+1-a[p[i]].y;\n                else res[p[i]]+=w+1-a[p[i]].x;\n        }\n    }\n}\n\nvoid cal() {\n    if ((a[v[0]].x+a[v[0]].y)%2==1) {\n        for (int i=0;i<v.size();++i) {\n            if (a[v[i]].z==0) a[v[i]].x++;\n                else a[v[i]].y++;\n            res[v[i]]++;\n            if (i>0 && a[v[i]].z==0 && a[v[i-1]].x==a[v[i]].x && a[v[i-1]].y==a[v[i]].y)\n                swap(a[v[i]].z,a[v[i-1]].z);\n        }\n    }\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==0 && a[v[i]].x<=h && a[v[i]].y<=w) p[++m]=v[i];\n    if (m>0) cal2();\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==1 && a[v[i]].x<=h && a[v[i]].y<=w) p[++m]=v[i];\n    if (m>0) cal2();\n}\n\nint main() {\n    /*freopen(\"ant.inp\",\"r\",stdin);\n    freopen(\"ant.out\",\"w\",stdout);//*/\n\n    scanf(\"%d %d %d\",&w,&h,&n);\n    for (i=1;i<=n;++i) {\n        scanf(\"%d %d %c\\n\",&a[i].y,&a[i].x,&ch);\n        if (ch=='E') a[i].z=1;\n            else a[i].z=0;\n        t[i]=i;\n    }\n\n    sort(t+1,t+1+n,cmp);\n\n    for (i=1;i<=n;++i) {\n        v.push_back(t[i]);\n        if (i==n || a[t[i]].x+a[t[i]].y!=a[t[i+1]].x+a[t[i+1]].y) {\n            cal();\n            v.clear();\n        }\n    }\n    for (i=1;i<=n;++i) t[i]=i;\n    sort(t+1,t+1+n,cmp1);\n    //for (i=1;i<=n;++i) printf(\"%d \",res[i]); cout << endl;\n    for (i=1;i<=n;++i) printf(\"%d\\n\",t[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(x, a, b) for (int x = a; x <= b; ++x)\n#define FOD(x, a, b) for (int x = a; x >= b; --x)\n#define REP(x, a, b) for (int x = a; x < b; ++x)\n#define DEBUG(X) { cout << #X << \" = \" << X << endl; }\n#define PR(A, n) { cout << #A << \" = \"; FOR(_, 1, n) cout << A[_] << \" \"; cout << endl; }\n#define PR0(A, n)  { cout << #A << \" = \"; REP(_, 0, n) cout << A[_] << \" \"; cout << endl; }\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> II;\n\nconst int N = 2e5 + 10;\n\nint n, m, q, LSize;\nint L[N], ans[N];\n\nvector <int> c[N];\n\nstruct Ant {\n    int x, y, d;\n    Ant () {}\n    Ant (int x, int y, int d) : x(x), y(y), d(d) {};\n} A[N];\n\nvoid Compress() {\n    FOR(i, 1, q) L[i] = A[i].x + A[i].y;\n    LSize = q;\n    LSize = unique(L + 1, L + LSize + 1) - (L + 1);\n}\n\nint Pos(int v) {\n    return lower_bound(L + 1, L + LSize + 1, v) - L;\n}\n\nbool CMP(int x, int y) {\n    return A[x].y < A[y].y;\n}\n\nstruct State {\n    int x, y, z;\n    State () {}\n    State (int x, int y, int z) : x(x), y(y), z(z) {}\n    bool operator < (const State &that) const {\n        if (x != that.x) return x < that.x;\n        if (y != that.y) return y < that.y;\n        return z < that.z;\n    }\n};\n\nvoid Compute(const vector <int> &g) {\n    vector <State> L;\n    REP(p, 0, g.size()) {\n        int i = g[p], x = A[i].x, y = A[i].y, d = A[i].d;\n        if (d == 0) L.push_back(State(d, A[i].y, n - A[i].x));\n            else L.push_back(State(d, n - A[i].x, m - A[i].y));\n    }\n    sort(L.begin(), L.end());\n   // PR0(g, g.size());\n    //REP(i, 0, L.size()) cout << L[i].first << \" \" << L[i].second << endl;\n    REP(i, 0, g.size()) ans[g[i]] = L[i].z;\n}\n\nvoid Solve(int idx) {\n    sort(c[idx].begin(), c[idx].end(), CMP);\n    if (L[idx] % 2 == 0) {\n        FOR(f, 0, 1) {\n            vector <int> g;\n            REP(k, 0, c[idx].size()) {\n                int i = c[idx][k];\n                if (A[i].x % 2 != f) continue;\n                g.push_back(i);\n            }\n            Compute(g);\n        }\n    } else {\n        Compute(c[idx]);\n    }\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif // LOCAL\n    scanf(\"%d%d%d\", &n, &m, &q);\n    FOR(i, 1, q) {\n        char d[2]; int x, y; scanf(\"%d%d%s\", &x, &y, d);\n        A[i] = Ant(x, y, d[0] == 'E' ? 0 : 1);\n    }\n    Compress();\n    FOR(i, 1, q) {\n        int x = A[i].x, y = A[i].y, d = A[i].d;\n        c[Pos(x + y)].push_back(i);\n    }\n    FOR(i, 1, LSize) Solve(i);\n    vector <II> answ;\n    FOR(i, 1, q) answ.push_back(II(ans[i], i));\n    sort(answ.begin(), answ.end());\n    FOR(i, 1, q) printf(\"%d\\n\", answ[i - 1].second);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w,h,n,m,i,x,y,z,xx,yy;\nstruct data{\n    int x,y,z;\n} a[200100];\nint t[200100],p[200100],s[3][200100],ww[200100][3],num[3],res[300100];\nchar ch;\nvector <int> v;\n\nbool cmp(int u,int v) {\n    return (a[u].x+a[u].y<a[v].x+a[v].y) || (a[u].x+a[u].y==a[v].x+a[v].y && a[u].y<a[v].y);\n}\n\nbool cmp1(int x,int y) {\n    return (res[x]<res[y]) || (res[x]==res[y] && x<y);\n}\n\nvoid cal2() {\n    num[0]=num[1]=0;\n    for (int i=1;i<=m;++i) {\n        s[a[p[i]].z][++num[a[p[i]].z]]=p[i];\n        ww[i][0]=num[0]; ww[i][1]=num[1];\n    }\n\n    for (int i=1;i<=m;++i) {\n        x=ww[i-1][1];\n        y=num[0]-ww[i][0];\n        z=a[p[i]].z;\n        xx=yy=min(x,y);\n        if (z==0 && x>xx) xx++;\n        if (z==1 && y>yy) yy++;\n\n        x=x-xx+1; y=ww[i][0]+yy;\n        x=s[1][x]; y=s[0][y];\n        if ((xx+yy)%2==1) z=1-z;\n\n        if (xx+yy>0) {\n            res[p[i]]+=a[y].y-a[x].y;\n            if (z==0) res[p[i]]+=h+1-a[y].y;\n                else res[p[i]]+=w+1-a[x].x;\n        }\n        else {\n            if (z==0) res[p[i]]+=h+1-a[p[i]].y;\n                else res[p[i]]+=w+1-a[p[i]].x;\n        }\n    }\n}\n\nvoid cal() {\n    if ((a[v[0]].x+a[v[0]].y)%2==1) {\n        for (int i=0;i<v.size();++i) {\n            if (a[v[i]].z==0) a[v[i]].x++;\n                else a[v[i]].y++;\n            res[v[i]]++;\n            if (i>0 && a[v[i]].z==0 && a[v[i-1]].x==a[v[i]].x && a[v[i-1]].y==a[v[i]].y)\n                swap(a[v[i]].z,a[v[i-1]].z);\n        }\n    }\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==0) p[++m]=v[i];\n    if (m>0) cal2();\n\n    m=0;\n    for (int i=0;i<v.size();++i)\n        if (a[v[i]].x%2==1) p[++m]=v[i];\n    if (m>0) cal2();\n}\n\nint main() {\n    /*freopen(\"ant.inp\",\"r\",stdin);\n    freopen(\"ant.out\",\"w\",stdout);//*/\n\n    scanf(\"%d %d %d\",&w,&h,&n);\n    for (i=1;i<=n;++i) {\n        scanf(\"%d %d %c\\n\",&a[i].y,&a[i].x,&ch);\n        if (ch=='E') a[i].z=1;\n            else a[i].z=0;\n        t[i]=i;\n    }\n\n    sort(t+1,t+1+n,cmp);\n\n    for (i=1;i<=n;++i) {\n        v.push_back(t[i]);\n        if (i==n || a[t[i]].x+a[t[i]].y!=a[t[i+1]].x+a[t[i+1]].y) {\n            cal();\n            v.clear();\n        }\n    }\n    for (i=1;i<=n;++i) t[i]=i;\n    sort(t+1,t+1+n,cmp1);\n    for (i=1;i<=n;++i) printf(\"%d\\n\",t[i]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\nconst ll INF = 1e9+100;\nconst ll MOD = 1e9+7;\nconst double EPS  = 1e-10;\nconst bool debug = 0;\n//---------------------------//\n\nint W, H, N;\nint x[212345], y[212345], d[212345]; // ??±-0, ???-1\nint ord[212345];\n\nint main() {\n\tcin >> W >> H >> N;\n\tREP(i, N) {\n\t\tchar c;\n\t\tscanf(\"%d %d %c\", x + i, y + i, &c);\n\t\td[i] = c == 'S';\n\t}\n\t\n\tmap<int, vector<pii> > m; // x-y, (x, number)\n\tREP(i, N) m[x[i] + y[i]].push_back(pii(x[i], i));\n\t\n\tvector<vector<pii> > vv; // ????????????????????????\n\tfor (map<int, vector<pii> >::iterator it = m.begin(); it != m.end(); ++it) {\n\t\tvv.push_back(it->se);\n\t}\n\t\n\tvector<pii> ans; // (t, number)\n\tmemset(ord, -1, sizeof(ord));\n\t\n\tREP(i, vv.size()) {\n\t\tvector<pii> &v = vv[i];\n\t\tsort(ALL(v));\n\t\t\n\t\tvector<int> t(v.size());\n\t\tREP(j, v.size()) {\n\t\t\tif (d[v[j].se]) t[j] = H + 1 - y[v[j].se];\n\t\t\telse t[j] = W + 1 - x[v[j].se];\n\t\t}\n\t\t\n\t\tbool black = (x[v[0].se] + y[v[0].se]) & 1; // ???????????´?????????????????§??????????????????\n\t\t\n\t\tqueue<int> que[2]; // [y??§?¨??????¶?\\?] = ???number\n\t\t\n\t\tREP(j, v.size()) {\n\t\t\tint num = v[j].se; // ?????¨????????????????????????\n\t\t\t\n\t\t\tif (d[num]) {\n\t\t\t\tint idx = black ^ (y[num] & 1); // ??????????????????y??§?¨??????¶?\\?\n\t\t\t\tque[idx].push(num);\n\t\t\t\tord[j] = que[idx].front();\n\t\t\t\tque[idx].pop();\n\t\t\t}\n\t\t\telse { // ??±??????\n\t\t\t\tque[y[num] & 1].push(num);\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(j, v.size()) {\n\t\t\tif (ord[j] != -1) continue;\n\t\t\tint idx = y[v[j].se] & 1;\n\t\t\tord[j] = que[idx].front();\n\t\t\tque[idx].pop();\n\t\t}\n\t\t\n\t\tREP(j, v.size()) ans.push_back(pii(t[j], ord[j]));\n\t\tREP(j, v.size()) ord[j] = -1;\n\t}\n\t\n\tsort(ALL(ans));\n\tREP(i, ans.size()) printf(\"%d\\n\", ans[i].se + 1);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <stdlib.h>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\nconst double EPS = 1e-8;\n#define Scan(a) int a;scanf(\"%d\", &a);\n#define ScanS(a) char a[500];scanf(\"%s\", a);\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1LL)\n#define bitset(a,b)      ( a |= (1LL << b))\n#define bitunset(a,b)    (a &= ~(1LL << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\npii operator+(pii obj, pii obj2) {\n\treturn MP(obj.first + obj2.first, obj.second + obj2.second);\n}\npii operator-(pii obj, pii obj2) {\n\treturn MP(obj.first - obj2.first, obj.second - obj2.second);\n}\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n\tvoid scan(int edcount, bool oindexed, bool w) {\n\t\tREP(i, edcount) {\n\t\t\tint a, b, c = 1;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (w)scanf(\"%d\", &c);\n\t\t\tcon(a - oindexed, b - oindexed, c);\n\t\t}\n\t}\n};\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\nclass DGraph : public Graph {//??????\npublic:\n\tDGraph(int n) : Graph(n) {}\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tsumcost++;\n\t}\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) { //????????\\??£??????????????¨ y?????\\??£?????????????????????\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { //x??¨y????????????????????\\??£??????????????????????????????\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tbool isroot(int x) {\n\t\treturn data[x] < 0;\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nint main() {\n\tint w, h, n;\n\tcin >> w >> h >> n;\n\n\tmap<int, vector<pair<pii, pair<char, int>>>> ant;\n\tvector<pair<pii, char>> ar(n);\n\tREP(i, n) {\n\t\tint x, y;\n\t\tchar d;\n\t\tscanf(\"%d %d %c\", &x, &y, &d);\n\n\t\tant[x + y].push_back({ {x,y}, {d,i} });\n\t\tar[i] = { {x,y},d };\n\t}\n\n\tpriority_queue<pii, vector<pii>, greater<pii>> pq;\n\n\tfor (auto itr : ant) {\n\t\tsort(ALL(itr.second), greater<pair<pii, pair<char, int>>>());\n\t\tqueue<int> que[2];\n\t\tfor (auto itr2 : itr.second) {\n\n\t\t\tint ai = itr2.first.first % 2;\n\t\t\tif (itr.first % 2 && itr2.second.first == 'S') {\n\t\t\t\tai = 1 - ai;\n\t\t\t}\n\n\t\t\tif (itr2.second.first == 'S')\n\t\t\t\tque[ai].push(itr2.second.second);\n\t\t\telse {\n\t\t\t\tif (que[ai].empty()) {\n\t\t\t\t\tpq.push({ w - itr2.first.first ,itr2.second.second });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint cur = que[ai].front();\n\t\t\t\t\tque[ai].pop();\n\t\t\t\t\tpq.push({ w - itr2.first.first ,cur });\n\t\t\t\t\tpq.push({ h - ar[cur].first.second ,itr2.second.second });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (que[0].size()) {\n\t\t\tint cur = que[0].front();\n\t\t\tpq.push({ h - ar[cur].first.second , cur });\n\t\t\tque[0].pop();\n\t\t}\n\t\twhile (que[1].size()) {\n\t\t\tint cur = que[1].front();\n\t\t\tpq.push({ h - ar[cur].first.second , cur });\n\t\t\tque[1].pop();\n\t\t}\n\t}\n\twhile (pq.size()) {\n\t\tprintf(\"%d\\n\", pq.top().second + 1);\n\t\tpq.pop();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long \n \nstruct Ant\n{\n  int x, y, angle, num;\n   \n  Ant () {}\n  Ant (int x, int y, int angle, int num) : x(x), y(y), angle(angle), num(num) {}\n   \n  void input(int i)\n  {\n    char c;\n    scanf(\" %lld %lld %c\", &x, &y, &c);\n    if(c == 'E') angle = 0;\n    else angle = 1;\n    num = i;\n  }\n \n  int getDist(int w, int h)\n  {\n    if(angle == 0) return (w - x + 1);\n    return (h - y + 1);\n  }\n   \n  int getSum()\n  {\n    return (x + y);\n  }\n   \n};\n \nint w, h, n;\nbool lessDist(const Ant &a, const Ant &b) {\n  Ant ta = a, tb = b;\n  int ad = ta.getDist(w, h), bd = tb.getDist(w, h);\n  if(ad < bd) return (true);\n  if(ad > bd) return (false);\n  return (a.num < b.num);\n}\n \nbool PPMX(const Ant &a, const Ant &b) {\n  Ant ta = a, tb = b;\n  int asum = ta.getSum(), bsum = tb.getSum();\n  if(asum < bsum) return (true);\n  if(asum > bsum) return (false);\n  return (a.x > b.x);\n}\n \nmain()\n{\n  Ant dista[200005];\n   \n  cin >> w >> h >> n;\n   \n  for(int i = 0; i < n; i++) {\n    dista[i].input(i + 1);\n  }\n   \n  sort(dista, dista + n, PPMX);\n   \n  int i = 0;\n  while(i < n) {\n    int l = i;\n    int s = dista[i].getSum();\n    queue < int > que[2];\n    \n    while(i < n && dista[i].getSum() == s) i++;\n    if(s % 2) {\n      for(int j = l; j < i; j++) {\n\tque[(dista[j].angle + dista[j].x) % 2].push(dista[j].num);\n      }\n      for(int p = 0; p <= 1; p++) {\n\tfor(int j = l; j < i; j++) {\n\t  if(dista[j].angle == p) {\n\t    if(dista[j].x % 2 == p) {\n\t      dista[j].num = que[0].front(); que[0].pop();\n\t    } else {\n\t      dista[j].num = que[1].front(); que[1].pop();\n\t    }\n\t  } \n\t}\n      }\n    } else {\n      for(int j = l; j < i; j++) {\n\tque[dista[j].x % 2].push(dista[j].num);\n      }\n      for(int q = 0; q <= 1; q++) {\n\tfor(int p = 0; p <= 1; p++) {\n\t  for(int j = l; j < i; j++) {\n\t    if(dista[j].x % 2 == q && dista[j].angle == p) {\n\t      dista[j].num = que[q].front(); que[q].pop();\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n   \n  sort(dista, dista + n, lessDist);\n   \n  for(int i = 0; i < n; i++) {\n    cout << dista[i].num << endl;\n  }\n \n  return (0);\n} "
  },
  {
    "language": "Python",
    "code": "class Ant:\n    def __init__(self, params):\n        self.live = True\n        self.x = int(params[0])-1\n        self.y = int(params[1])-1\n        self.d = 0 if params[2] == \"E\" else 1\n\nW, H, N = list(map(int, input().split()))\nants = []\n\nfor i in range(N):\n    a = Ant(input().split())\n    ants.append(a)\n\ndeath = 0\nwhile death < N:\n    for i, a in enumerate(ants):\n        if not a.live:\n            continue\n        \n        if a.d == 0:\n            a.x += 1\n        else:\n            a.y += 1\n\n        if a.x >= W or a.y >= H:\n            a.live = False\n            print(i+1)\n            death += 1\n        else:\n            if (a.x+a.y)%2 == 0:\n                try:\n                    b = list(filter(lambda x: x.x == a.x and x.y == a.y, ants))[0]\n                except:\n                    pass\n                else:\n                    b.d = 1-b.d\n                    a.d = 1-a.d\n                "
  },
  {
    "language": "Python",
    "code": "class Ant:\n    def __init__(self, params):\n        self.live = True\n        self.x = int(params[0])\n        self.y = int(params[1])\n        self.d = 0 if params[2] == \"E\" else 1\n\nW, H, N = list(map(int, input().split()))\nants = []\n\nfor i in range(N):\n    a = Ant(input().split())\n    ants.append(a)\n\ndeath = 0\nwhile death < N:\n    board = [[ (i+j)%2-2 for j in range(H)] for i in range(W)]\n    for i, a in enumerate(ants):\n        if not a.live:\n            continue\n        \n        if a.d == 0:\n            a.x += 1\n        else:\n            a.y += 1\n\n        if a.x >= W or a.y >= H:\n            a.live = False\n            print(i+1)\n            death += 1\n        else:\n            b = board[a.x][a.y]\n            if  b == -2:\n                board[a.x][a.y] = i\n            elif b >= 0:\n                a.d = 1 - a.d\n                ants[b].d = 1 - ants[b].d"
  },
  {
    "language": "Python",
    "code": "class Ant:\n    def __init__(self, params):\n        self.live = True\n        self.x = int(params[0])-1\n        self.y = int(params[1])-1\n        self.d = 0 if params[2] == \"E\" else 1\n\nW, H, N = list(map(int, input().split()))\nants = []\n\nfor i in range(N):\n    a = Ant(input().split())\n    ants.append(a)\n\ndeath = 0\nwhile death < N:\n    board = [[ (i+j)%2-2 for j in range(H)] for i in range(W)]\n    for i, a in enumerate(ants):\n        if not a.live:\n            continue\n        \n        if a.d == 0:\n            a.x += 1\n        else:\n            a.y += 1\n\n        if a.x >= W or a.y >= H:\n            a.live = False\n            print(i+1)\n            death += 1\n        else:\n            b = board[a.x][a.y]\n            if  b == -2:\n                board[a.x][a.y] = i\n            elif b >= 0:\n                a.d = 1 - a.d\n                ants[b].d = 1 - ants[b].d"
  },
  {
    "language": "Python",
    "code": "class Ant:\n    def __init__(self, params):\n        self.live = True\n        self.x = int(params[0])\n        self.y = int(params[1])\n        self.d = 0 if params[2] == \"E\" else 1\n\nW, H, N = list(map(int, input().split()))\nants = []\n\nfor i in range(N):\n    a = Ant(input().split())\n    ants.append(a)\n\ndeath = 0\nwhile death < N:\n    board = [[ (i+j)%2-2 for j in range(H)] for i in range(W)]\n    for i, a in enumerate(ants):\n        if not a.live:\n            continue\n        \n        if a.d == 0:\n            a.x += 1\n        else:\n            a.y += 1\n\n        if a.x >= W or a.y >= H:\n            a.live = False\n            print(i+1)\n            death += 1\n        else:\n            b = board[a.x][a.y]\n            if  b == -2:\n                board[a.x][a.y] = i\n            elif b >= 0:\n                a.d = 1 - a.d\n                ants[b].d = 1 - ants[b].d"
  },
  {
    "language": "Python",
    "code": "class Ant:\n    def __init__(self, params):\n        self.live = True\n        self.x = int(params[0])\n        self.y = int(params[1])\n        self.d = 0 if params[2] == \"E\" else 1\n\nW, H, N = list(map(int, input().split()))\nants = []\n\nfor i in range(N):\n    a = Ant(input().split())\n    ants.append(a)\n\ndeath = 0\nwhile death < N:\n    board = [[ (i+j)%2-2 for j in range(H+1)] for i in range(W+1)]\n    for i, a in enumerate(ants):\n        if not a.live:\n            continue\n        \n        if a.d == 0:\n            a.x += 1\n        else:\n            a.y += 1\n\n        if a.x > W or a.y > H:\n            a.live = False\n            print(i+1)\n            death += 1\n        else:\n            b = board[a.x][a.y]\n            if  b == -2:\n                board[a.x][a.y] = i\n            elif b >= 0:\n                a.d = 1 - a.d\n                ants[b].d = 1 - ants[b].d"
  }
]