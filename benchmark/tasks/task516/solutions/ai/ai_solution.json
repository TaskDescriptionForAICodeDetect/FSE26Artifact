[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_STOPS 1001\n\ntypedef struct {\n    int dest;\n    int depart_time;\n    int duration;\n} Route;\n\nint N, M, S, G;\nRoute routes[MAX_STOPS * MAX_STOPS];\nint wet_time[MAX_STOPS];\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid solve() {\n    for (int i = 1; i <= N; i++) {\n        wet_time[i] = INT_MAX;\n    }\n    wet_time[S] = 0;\n\n    for (int k = 0; k < N; k++) {\n        bool updated = false;\n        for (int i = 0; i < M; i++) {\n            int u = routes[i].dest;\n            int v = routes[i].dest;\n            int t = routes[i].depart_time;\n            int c = routes[i].duration;\n\n            if (wet_time[u] != INT_MAX && wet_time[u] + (t - wet_time[u]) + c < wet_time[v]) {\n                wet_time[v] = wet_time[u] + (t - wet_time[u]) + c;\n                updated = true;\n            }\n        }\n        if (!updated) break;\n    }\n\n    printf(\"%d\\n\", wet_time[G] == INT_MAX ? -1 : wet_time[G]);\n}\n\nint main() {\n    scanf(\"%d %d %d %d\", &N, &M, &S, &G);\n\n    for (int i = 0; i < M; i++) {\n        int u, v, t, c;\n        scanf(\"%d %d %d %d\", &u, &v, &t, &c);\n        routes[i].dest = u;\n        routes[i].dest = v;\n        routes[i].depart_time = t;\n        routes[i].duration = c;\n    }\n\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int u, v, t, c;\n} Route;\n\ntypedef struct {\n    int stop;\n    int arrival_time;\n} State;\n\ntypedef struct {\n    State* data;\n    int size;\n    int capacity;\n} PriorityQueue;\n\nvoid init_pq(PriorityQueue* pq, int capacity) {\n    pq->data = (State*)malloc(capacity * sizeof(State));\n    pq->size = 0;\n    pq->capacity = capacity;\n}\n\nvoid swap(State* a, State* b) {\n    State temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid push(PriorityQueue* pq, State state) {\n    if (pq->size == pq->capacity) return;\n    pq->data[pq->size] = state;\n    int current = pq->size;\n    pq->size++;\n    while (current > 0) {\n        int parent = (current - 1) / 2;\n        if (pq->data[current].arrival_time < pq->data[parent].arrival_time) {\n            swap(&pq->data[current], &pq->data[parent]);\n            current = parent;\n        } else {\n            break;\n        }\n    }\n}\n\nState pop(PriorityQueue* pq) {\n    State result = pq->data[0];\n    pq->size--;\n    pq->data[0] = pq->data[pq->size];\n    int current = 0;\n    while (1) {\n        int left = 2 * current + 1;\n        int right = 2 * current + 2;\n        int smallest = current;\n        if (left < pq->size && pq->data[left].arrival_time < pq->data[smallest].arrival_time) {\n            smallest = left;\n        }\n        if (right < pq->size && pq->data[right].arrival_time < pq->data[smallest].arrival_time) {\n            smallest = right;\n        }\n        if (smallest != current) {\n            swap(&pq->data[current], &pq->data[smallest]);\n            current = smallest;\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n\nint main() {\n    int N, M, S, G;\n    scanf(\"%d %d %d %d\", &N, &M, &S, &G);\n    Route* routes = (Route*)malloc(M * sizeof(Route));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d %d\", &routes[i].u, &routes[i].v, &routes[i].t, &routes[i].c);\n    }\n\n    int* wet_time = (int*)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        wet_time[i] = INT_MAX;\n    }\n    wet_time[S] = 0;\n\n    PriorityQueue pq;\n    init_pq(&pq, M + 1);\n    push(&pq, (State){S, 0});\n\n    while (pq.size > 0) {\n        State current = pop(&pq);\n        if (current.stop == G) break;\n        if (current.arrival_time > wet_time[current.stop]) continue;\n\n        for (int i = 0; i < M; i++) {\n            if (routes[i].u != current.stop) continue;\n            int departure_time = routes[i].t;\n            int arrival_time = departure_time + routes[i].c;\n            int new_wet_time = current.arrival_time;\n            if (current.arrival_time < departure_time) {\n                new_wet_time += departure_time - current.arrival_time;\n            }\n            if (new_wet_time < wet_time[routes[i].v]) {\n                wet_time[routes[i].v] = new_wet_time;\n                push(&pq, (State){routes[i].v, arrival_time});\n            }\n        }\n    }\n\n    printf(\"%d\\n\", wet_time[G]);\n\n    free(routes);\n    free(wet_time);\n    free(pq.data);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:00:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int v, t, c;\n    Edge(int v, int t, int c) : v(v), t(t), c(c) {}\n};\n\nstruct State {\n    int u, time, wet;\n    State(int u, int time, int wet) : u(u), time(time), wet(wet) {}\n    bool operator>(const State& other) const {\n        return wet > other.wet;\n    }\n};\n\nint main() {\n    int N, M, S, G;\n    cin >> N >> M >> S >> G;\n    \n    vector<vector<Edge>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int u, v, t, c;\n        cin >> u >> v >> t >> c;\n        adj[u].emplace_back(v, t, c);\n        adj[v].emplace_back(u, t, c);\n    }\n    \n    priority_queue<State, vector<State>, greater<State>> pq;\n    vector<int> min_wet(N + 1, INT_MAX);\n    \n    pq.emplace(S, 0, 0);\n    min_wet[S] = 0;\n    \n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n        \n        if (current.u == G) {\n            cout << current.wet << endl;\n            return 0;\n        }\n        \n        if (current.wet > min_wet[current.u]) {\n            continue;\n        }\n        \n        for (const Edge& edge : adj[current.u]) {\n            int new_wet = current.wet;\n            if (current.time > edge.t) {\n                new_wet += current.time - edge.t;\n            }\n            if (new_wet < min_wet[edge.v]) {\n                min_wet[edge.v] = new_wet;\n                pq.emplace(edge.v, edge.t + edge.c, new_wet);\n            }\n        }\n    }\n    \n    cout << -1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static class Edge {\n        int v, t, c;\n        Edge(int v, int t, int c) {\n            this.v = v;\n            this.t = t;\n            this.c = c;\n        }\n    }\n\n    static class Node implements Comparable<Node> {\n        int u;\n        long time;\n        Node(int u, long time) {\n            this.u = u;\n            this.time = time;\n        }\n        public int compareTo(Node other) {\n            return Long.compare(this.time, other.time);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int S = sc.nextInt();\n        int G = sc.nextInt();\n\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int t = sc.nextInt();\n            int c = sc.nextInt();\n            adj.get(u).add(new Edge(v, t, c));\n            adj.get(v).add(new Edge(u, t, c));\n        }\n\n        long[] dist = new long[N + 1];\n        Arrays.fill(dist, Long.MAX_VALUE);\n        dist[S] = 0;\n\n        PriorityQueue<Node> pq = new PriorityQueue<>();\n        pq.offer(new Node(S, 0));\n\n        while (!pq.isEmpty()) {\n            Node node = pq.poll();\n            int u = node.u;\n            long currentTime = node.time;\n\n            if (u == G) {\n                System.out.println(currentTime);\n                return;\n            }\n\n            if (currentTime > dist[u]) continue;\n\n            for (Edge edge : adj.get(u)) {\n                long newTime = Math.max(currentTime, edge.t) + edge.c;\n                if (newTime < dist[edge.v]) {\n                    dist[edge.v] = newTime;\n                    pq.offer(new Node(edge.v, newTime));\n                }\n            }\n        }\n        System.out.println(-1);\n    }\n}",
    "timestamp": "2025-08-05 22:01:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BusRouteWetTime {\n    static final int INF = Integer.MAX_VALUE;\n\n    public static int findMinWetTime(int N, int M, int S, int G, int[][] routes) {\n        // Create adjacency list to represent graph\n        List<List<Node>> graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        // Build graph\n        for (int[] route : routes) {\n            int u = route[0], v = route[1], t = route[2], c = route[3];\n            graph.get(u).add(new Node(v, t, c));\n        }\n\n        // Dijkstra's algorithm variant to track wet time\n        PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> a.wetTime - b.wetTime);\n        int[] wetTimes = new int[N];\n        Arrays.fill(wetTimes, INF);\n        wetTimes[S] = 0;\n        pq.offer(new State(S, 0));\n\n        while (!pq.isEmpty()) {\n            State curr = pq.poll();\n            int stop = curr.stop;\n            int currWetTime = curr.wetTime;\n\n            if (stop == G) return currWetTime;\n            if (currWetTime > wetTimes[stop]) continue;\n\n            for (Node next : graph.get(stop)) {\n                int newWetTime = currWetTime + next.travelTime;\n                if (newWetTime < wetTimes[next.destination]) {\n                    wetTimes[next.destination] = newWetTime;\n                    pq.offer(new State(next.destination, newWetTime));\n                }\n            }\n        }\n\n        return -1; // No route found\n    }\n\n    static class Node {\n        int destination;\n        int departureTime;\n        int travelTime;\n\n        Node(int destination, int departureTime, int travelTime) {\n            this.destination = destination;\n            this.departureTime = departureTime;\n            this.travelTime = travelTime;\n        }\n    }\n\n    static class State {\n        int stop;\n        int wetTime;\n\n        State(int stop, int wetTime) {\n            this.stop = stop;\n            this.wetTime = wetTime;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt(); // Number of bus stops\n        int M = scanner.nextInt(); // Number of routes\n        int S = scanner.nextInt(); // Start stop\n        int G = scanner.nextInt(); // Goal stop\n\n        int[][] routes = new int[M][4];\n        for (int i = 0; i < M; i++) {\n            routes[i][0] = scanner.nextInt(); // u\n            routes[i][1] = scanner.nextInt(); // v\n            routes[i][2] = scanner.nextInt(); // t\n            routes[i][3] = scanner.nextInt(); // c\n        }\n\n        int result = findMinWetTime(N, M, S, G, routes);\n        System.out.println(result);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:01:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1005;\nconst int INF = 1e9;\n\nstruct Edge {\n    int u, v, t, c;\n};\n\nvector<Edge> graph[MAXN];\nint N, M, S, G;\nint wet_time[MAXN];\n\nvoid dijkstra() {\n    fill(wet_time, wet_time + MAXN, INF);\n    wet_time[S] = 0;\n    \n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, S});\n    \n    while (!pq.empty()) {\n        int current_wet = pq.top().first;\n        int current_stop = pq.top().second;\n        pq.pop();\n        \n        if (current_wet > wet_time[current_stop]) continue;\n        \n        for (auto& edge : graph[current_stop]) {\n            int next_stop = edge.v;\n            int wait_time = max(0, edge.t - current_wet);\n            int total_wet_time = current_wet + wait_time + edge.c;\n            \n            if (total_wet_time < wet_time[next_stop]) {\n                wet_time[next_stop] = total_wet_time;\n                pq.push({total_wet_time, next_stop});\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> N >> M >> S >> G;\n    \n    for (int i = 0; i < M; i++) {\n        int u, v, t, c;\n        cin >> u >> v >> t >> c;\n        graph[u].push_back({u, v, t, c});\n    }\n    \n    dijkstra();\n    \n    cout << (wet_time[G] == INF ? -1 : wet_time[G]) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappop, heappush\nfrom collections import defaultdict\nimport sys\n\ndef dijkstra(N, routes, S, G):\n    graph = defaultdict(list)\n    \n    for u, v, t, c in routes:\n        graph[u].append((v, t, c))\n    \n    pq = [(0, S, 0)]  # (total_wet_time, current_stop, current_time)\n    wet_time = {i: sys.maxsize for i in range(N)}\n    wet_time[S] = 0\n    \n    while pq:\n        total_wet_time, current_stop, current_time = heappop(pq)\n        \n        if current_stop == G:\n            return total_wet_time\n        \n        for neighbor, departure_time, travel_duration in graph[current_stop]:\n            # Calculate waiting time\n            wait_time = max(0, departure_time - current_time)\n            new_time = current_time + wait_time + travel_duration\n            if total_wet_time + wait_time < wet_time[neighbor]:\n                wet_time[neighbor] = total_wet_time + wait_time\n                heappush(pq, (wet_time[neighbor], neighbor, new_time))\n    \n    return -1\n\ndef find_min_wet_time(N, M, S, G, routes):\n    return dijkstra(N, routes, S, G)\n\n# Example usage:\n# N, M = 4, 4\n# S, G = 0, 3\n# routes = [(0, 1, 1, 9), (0, 2, 2, 6), (1, 3, 3, 3), (2, 3, 1, 5)]\n# result = find_min_wet_time(N, M, S, G, routes)\n# print(result)  # Output the time spent being wet till stop G",
    "timestamp": "2025-08-13 08:26:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class AORIkacchanWetTravel {\n    \n    static class Route {\n        int destination;\n        int departure;\n        int duration;\n\n        public Route(int destination, int departure, int duration) {\n            this.destination = destination;\n            this.departure = departure;\n            this.duration = duration;\n        }\n    }\n\n    static class State implements Comparable<State> {\n        int busStop;\n        int wetTime;\n\n        public State(int busStop, int wetTime) {\n            this.busStop = busStop;\n            this.wetTime = wetTime;\n        }\n\n        @Override\n        public int compareTo(State other) {\n            return Integer.compare(this.wetTime, other.wetTime);\n        }\n    }\n\n    public static int minimizeWetTime(int N, int M, int[][] routes, int S, int G) {\n        List<List<Route>> graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = routes[i][0];\n            int v = routes[i][1];\n            int t = routes[i][2];\n            int c = routes[i][3];\n            graph.get(u).add(new Route(v, t, c));\n        }\n\n        int[] wetTimes = new int[N];\n        Arrays.fill(wetTimes, Integer.MAX_VALUE);\n        wetTimes[S] = 0;\n\n        PriorityQueue<State> pq = new PriorityQueue<>();\n        pq.add(new State(S, 0));\n\n        while (!pq.isEmpty()) {\n            State currentState = pq.poll();\n            int currentStop = currentState.busStop;\n            int currentWetTime = currentState.wetTime;\n\n            if (currentWetTime > wetTimes[currentStop]) continue;\n\n            for (Route route : graph.get(currentStop)) {\n                int waitTime = Math.max(0, route.departure - currentWetTime);\n                int newWetTime = currentWetTime + waitTime + route.duration;\n\n                if (newWetTime < wetTimes[route.destination]) {\n                    wetTimes[route.destination] = newWetTime;\n                    pq.add(new State(route.destination, newWetTime));\n                }\n            }\n        }\n\n        return wetTimes[G] == Integer.MAX_VALUE ? -1 : wetTimes[G];\n    }\n\n    public static void main(String[] args) {\n        int N = 5; // Number of bus stops\n        int M = 6; // Number of routes\n        int[][] routes = {\n            {0, 1, 3, 5},\n            {0, 2, 4, 6},\n            {1, 2, 8, 2},\n            {1, 3, 10, 4},\n            {2, 3, 15, 1},\n            {3, 4, 20, 2}\n        };\n        int S = 0; // Starting stop\n        int G = 4; // Destination stop\n\n        int result = minimizeWetTime(N, M, routes, S, G);\n        System.out.println(result); // This prints the minimum wet time to reach stop G\n    }\n}",
    "timestamp": "2025-08-13 08:26:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1001\n#define MAX_M 10001\n\ntypedef struct {\n    int u, v, t, c;\n} Route;\n\nRoute routes[MAX_M];\nint wetTime[MAX_N];\n\nint compare(const void *a, const void *b) {\n    Route *routeA = (Route *)a;\n    Route *routeB = (Route *)b;\n    if (routeA->t == routeB->t) {\n        return 0;\n    }\n    return routeA->t < routeB->t ? -1 : 1;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int N, M, S, G;\n    scanf(\"%d %d\", &N, &M);\n    scanf(\"%d %d\", &S, &G);\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d %d\", &routes[i].u, &routes[i].v, &routes[i].t, &routes[i].c);\n    }\n\n    for (int i = 0; i <= N; i++) {\n        wetTime[i] = INT_MAX;\n    }\n    wetTime[S] = 0;\n\n    qsort(routes, M, sizeof(Route), compare);\n\n    for (int i = 0; i < M; i++) {\n        Route r = routes[i];\n        if (wetTime[r.u] <= r.t) {\n            wetTime[r.v] = min(wetTime[r.v], r.t + r.c);\n        }\n    }\n\n    if (wetTime[G] == INT_MAX) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", wetTime[G]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 08:27:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\nimport sys\n\ndef solve(N, M, S, G, routes):\n    graph = [[] for _ in range(N+1)]\n    for u, v, t, c in routes:\n        graph[u].append((v, t, c))\n\n    # Initialize distances and wetness\n    dist = [float('inf')] * (N+1)\n    wet_time = [float('inf')] * (N+1)\n    dist[S] = 0\n    wet_time[S] = 0\n\n    # Priority queue to process routes\n    pq = [(0, 0, S)]\n\n    while pq:\n        total_wet, current_time, current_stop = heappop(pq)\n\n        if current_stop == G:\n            return total_wet\n\n        if total_wet > wet_time[current_stop]:\n            continue\n\n        for next_stop, departure_time, travel_duration in graph[current_stop]:\n            # Wait time if current time is less than departure time\n            wait_time = max(0, departure_time - current_time)\n            \n            # Total time getting wet is wait time plus travel duration\n            next_wet_time = total_wet + wait_time + travel_duration\n            \n            # Update if better route found\n            if next_wet_time < wet_time[next_stop]:\n                wet_time[next_stop] = next_wet_time\n                dist[next_stop] = current_time + wait_time + travel_duration\n                heappush(pq, (next_wet_time, dist[next_stop], next_stop))\n\n    return -1\n\n# Input parsing\nN, M, S, G = map(int, input().split())\nroutes = []\nfor _ in range(M):\n    u, v, t, c = map(int, input().split())\n    routes.append((u, v, t, c))\n\n# Solve and print result\nresult = solve(N, M, S, G, routes)\nprint(result)",
    "timestamp": "2025-08-13 08:27:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    S = int(data[idx])\n    idx += 1\n    G = int(data[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        t = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        adj[u].append((v, t, c))\n        adj[v].append((u, t, c))\n    \n    INF = float('inf')\n    dist = [INF] * (N+1)\n    dist[S] = 0\n    heap = []\n    heapq.heappush(heap, (0, S))\n    \n    while heap:\n        current_time, u = heapq.heappop(heap)\n        if u == G:\n            print(current_time)\n            return\n        if current_time > dist[u]:\n            continue\n        for (v, t, c) in adj[u]:\n            if current_time <= t:\n                arrival_time = t + c\n            else:\n                arrival_time = current_time + c\n            if arrival_time < dist[v]:\n                dist[v] = arrival_time\n                heapq.heappush(heap, (arrival_time, v))\n    \n    print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 08:27:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\n// Define a structure for edges (u, v, t, c)\nstruct Edge {\n    int u, v, t, c;\n};\n\n// Comparator for priority queue\nstruct PQNode {\n    int stop, wetTime;\n    bool operator<(const PQNode &other) const {\n        return wetTime > other.wetTime;\n    }\n};\n\nint minimizeWetTime(int N, int M, int S, int G, vector<Edge> &routes) {\n    // Adjacency list for graph\n    vector<vector<Edge>> graph(N);\n    for (const auto &route : routes) {\n        graph[route.u].push_back(route);\n    }\n\n    // Priority queue for Dijkstra-like approach\n    priority_queue<PQNode> pq;\n    pq.push({S, 0});\n\n    // Best wet time to each stop\n    vector<int> bestWetTime(N, INT_MAX);\n    bestWetTime[S] = 0;\n\n    while (!pq.empty()) {\n        auto [currentStop, currentWetTime] = pq.top();\n        pq.pop();\n\n        // If reached destination\n        if (currentStop == G) {\n            return currentWetTime;\n        }\n\n        // Explore neighbors (routes)\n        for (const auto &route : graph[currentStop]) {\n            int nextStop = route.v;\n            int nextDepartureTime = route.t;\n            int nextTravelTime = route.c;\n\n            // Calculate next wet time based on departure wait time\n            int waitTime = max(0, nextDepartureTime - currentWetTime);\n            int totalWetTime = currentWetTime + waitTime;\n\n            // Update if found a better route\n            if (totalWetTime < bestWetTime[nextStop]) {\n                bestWetTime[nextStop] = totalWetTime;\n                pq.push({nextStop, totalWetTime + nextTravelTime});\n            }\n        }\n    }\n\n    return -1; // If G is unreachable\n}\n\nint main() {\n    int N, M, S, G;\n    cin >> N >> M >> S >> G;\n    vector<Edge> routes(M);\n\n    for (int i = 0; i < M; i++) {\n        cin >> routes[i].u >> routes[i].v >> routes[i].t >> routes[i].c;\n    }\n\n    int result = minimizeWetTime(N, M, S, G, routes);\n    if (result != -1) {\n        cout << \"Minimum wet time: \" << result << endl;\n    } else {\n        cout << \"Destination unreachable\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:45:56"
  }
]