[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nimport scala.io.StdIn._\nobject Main extends App {\n\n  val Array(n, m, s, g) = readLine.trim.split(' ').map(_.toInt)\n  val bus = Array.tabulate(m){i ⇒\n    val Array(u, v, t, c) = readLine.trim.split(' ').map(_.toInt)\n    Bus(i, u - 1, v - 1, t, t + c)\n  }.sortBy(_.start)\n  val busStop = Array.fill(n){ArrayBuffer[Bus]()}\n  val rank = Array.fill(m){0}\n  for (b ← bus) {\n    busStop(b.from).append(b)\n    rank(b.id) = busStop(b.from).length\n  }\n  val minTime = Array.fill(m){Int.MaxValue}\n  minTime(busStop(s - 1).head.id) = busStop(s - 1).head.start\n  val queue = mutable.PriorityQueue()(Ordering.by[(Bus, Int), Int](_._2).reverse)\n  queue.enqueue((busStop(s - 1).head, busStop(s - 1).head.start))\n  while (queue.nonEmpty) {\n    val (current, time) = queue.dequeue()\n    if (minTime(current.id) == time) {\n      if (busStop(current.from).length > rank(current.id)) {\n        val next = busStop(current.from)(rank(current.id))\n        if (minTime(next.id) > time + next.start - current.start) {\n          minTime(next.id) = time + next.start - current.start\n          queue.enqueue((next, minTime(next.id)))\n        }\n      }\n      val i = lowerBound(busStop(current.to)){_.start >= current.reach}\n      if (i < busStop(current.to).length) {\n        val next = busStop(current.to)(i)\n        if (minTime(next.id) > time + next.start - current.reach) {\n          minTime(next.id) = time + next.start - current.reach\n          queue.enqueue((next, minTime(next.id)))\n        }\n      }\n    }\n  }\n  println(bus.filter(_.to == g - 1).map{bus ⇒ minTime(bus.id)}.min)\n  def lowerBound[T](array: ArrayBuffer[T])(predicate: T ⇒ Boolean): Int = {\n    var left = 0\n    var right = array.length\n    while (left < right) {\n      val mid = (left + right) / 2\n      if (predicate(array(mid)))  right = mid\n      else left = mid + 1\n    }\n    right\n  }\n  case class Bus(id: Int, from: Int, to: Int, start: Int, reach: Int)\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n#define FF first\n#define SS second\n\nusing LL = long long;\nusing PII = pair<int,int>;\nusing PLL = pair<LL,LL>;\nusing PILL = pair<LL,PII>;\n\nconst LL INF = 1e15;\nconst int UB = 400010;\n\nint N, M, S, Gl;\nmap<PLL,int> ids;\nLL dist[UB];\nvoid dijk(vector<vector<PLL>>& G){\n  priority_queue<PLL, vector<PLL>, greater<PLL>> pq;\n  fill(dist, dist+UB, INF);\n  pq.push(PLL(0,ids[MP(S,0)]));\n  dist[ids[MP(S,0)]] = 0;\n\n  while(!pq.empty()){\n\tPLL p = pq.top();\n\tpq.pop();\n\tif(p.FF > dist[p.SS])\n\t  continue;\n\t  \n\tfor(auto&& e: G[p.SS]){\n\t  if(p.FF + e.SS < dist[e.FF]){\n\t\tdist[e.FF] = p.FF + e.SS;\n\t\tpq.push(MP(dist[e.FF], e.FF));\n\t  }\n\t}\n  }\n}\n\nint main(){\n  cin >> N >> M >> S >> Gl;\n  --S;\n  --Gl;\n  int id = 0;\n  \n  vector<vector<int>> tms(N);\n  ids[MP(0,S)] = id++;\n  tms[S].push_back(0);\n  vector<vector<PLL>> G(UB);\n  for(int i=0;i<M;++i){\n\tint u, v, t, c;\n\tcin >> u >> v >> t >> c;\n\t--u;\n\t--v;\n\tif(!ids.count(MP(u,t)))\n\t  ids[MP(u,t)] = id++;\n\tif(!ids.count(MP(v,t+c)))\n\t  ids[MP(v,t+c)] = id++;\n\ttms[u].push_back(t);\n\ttms[v].push_back(t+c);\n\tG[ids[MP(u,t)]].emplace_back(ids[MP(v,t+c)], 0);\n  }\n\n  for(int i=0;i<N;++i){\n\tsort(begin(tms[i]), end(tms[i]));\n\ttms[i].erase(unique(begin(tms[i]), end(tms[i])), end(tms[i]));\n\tfor(int j=0;j+1<tms[i].size();++j){\n\t  G[ids[MP(i,tms[i][j])]].emplace_back(ids[MP(i,tms[i][j+1])], tms[i][j+1] - tms[i][j]);\n\t}\n  }\n\n  dijk(G);\n  LL ans = INF;\n  for(auto&& t: tms[Gl])\n\tans = min(ans, dist[ids[MP(Gl,t)]]);\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n \n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n \n \nint N,M,orig,dest;\n \nvector<int>lis[111111];\n \nconst int INF=1001001001;\nvector<int>dp[111111];\n \nvector<tuple<int,int,int>>ev[222222];\nvector<int>latte[222222];\nsigned main(){\n    cin>>N>>M>>orig>>dest;\n    orig--;dest--;\n \n    lis[orig].pb(0);\n \n    latte[0].pb(orig);\n    rep(i,M){\n        int a,b,t,c;\n        scanf(\"%lld%lld%lld%lld\",&a,&b,&t,&c);\n        a--;b--;\n        latte[t].pb(a);\n        latte[t+c].pb(b);\n \n        lis[a].pb(t);\n        lis[b].pb(t+c);\n        ev[t].pb(make_tuple(a,b,c));\n    }\n \n    rep(i,N){\n        sort(all(lis[i]));\n        lis[i].erase(unique(all(lis[i])),lis[i].end());\n    }\n \n    rep(i,N){\n        dp[i]=vint(lis[i].size(),INF);\n    }\n    dp[orig][0]=0;\n    for(int t=0;t<222222;t++){\n        for(auto w:latte[t]){\n            int k=lower_bound(all(lis[w]),t)-lis[w].begin();\n            if(k+1!=lis[w].size()){\n                chmin(dp[w][k+1],dp[w][k]+lis[w][k+1]-lis[w][k]);\n            }\n        }\n \n        for(auto &w:ev[t]){\n            int a,b,c;\n            tie(a,b,c)=w;\n \n            int k=lower_bound(all(lis[a]),t)-lis[a].begin();\n            int l=lower_bound(all(lis[b]),t+c)-lis[b].begin();\n            chmin(dp[b][l],dp[a][k]);\n        }\n    }\n \n    int ans=INF;\n    rep(i,lis[dest].size())chmin(ans,dp[dest][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\nint N,M,orig,dest;\n\nvector<int>lis[111111];\n\nconst int INF=1001001001;\nvector<int>dp[111111];\n\nvector<tuple<int,int,int>>ev[222222];\nvector<int>latte[222222];\nsigned main(){\n    cin>>N>>M>>orig>>dest;\n    orig--;dest--;\n\n    lis[orig].pb(0);\n\n    latte[0].pb(orig);\n    rep(i,M){\n        int a,b,t,c;\n        scanf(\"%lld%lld%lld%lld\",&a,&b,&t,&c);\n        a--;b--;\n        latte[t].pb(a);\n        latte[t+c].pb(b);\n\n        lis[a].pb(t);\n        lis[b].pb(t+c);\n        ev[t].pb(make_tuple(a,b,c));\n    }\n\n    rep(i,N){\n        sort(all(lis[i]));\n        lis[i].erase(unique(all(lis[i])),lis[i].end());\n    }\n\n    rep(i,N){\n        dp[i]=vint(lis[i].size(),INF);\n    }\n    dp[orig][0]=0;\n    for(int t=0;t<222222;t++){\n        for(auto w:latte[t]){\n            int k=lower_bound(all(lis[w]),t)-lis[w].begin();\n            if(k+1!=lis[w].size()){\n                chmin(dp[w][k+1],dp[w][k]+lis[w][k+1]-lis[w][k]);\n            }\n        }\n\n        for(auto &w:ev[t]){\n            int a,b,c;\n            tie(a,b,c)=w;\n\n            int k=lower_bound(all(lis[a]),t)-lis[a].begin();\n            int l=lower_bound(all(lis[b]),t+c)-lis[b].begin();\n            chmin(dp[b][l],dp[a][k]);\n        }\n    }\n\n    int ans=INF;\n    rep(i,lis[dest].size())chmin(ans,dp[dest][i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <functional>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m, s, g;\nint u[200000], v[200000], t[200000], c[200000];\nunordered_map<P, vector<P>> et;\nunordered_map<P, vector<int>> ec;\nvector<int> starts[200001];\nunordered_map<P, int> minDist;\n\nvoid input() {\n\tcin >> n >> m >> s >> g; s--; g--;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> u[i] >> v[i] >> t[i] >> c[i]; u[i]--; v[i]--;\n\t\tet[P(u[i], t[i])].push_back(P(v[i], t[i] + c[i]));\n\t\tec[P(u[i], t[i])].push_back(0);\n\t\tstarts[u[i]].push_back(t[i]);\n\t}\n\t\n\tfor (int i = 0; i < m; i++) {\n\t\tvector<int> start = starts[v[i]];\n\t\tfor (int j = 0; j < start.size(); j++) {\n\t\t\tif (t[i] + c[i] <= start[j]) {\n\t\t\t\tet[P(v[i], t[i] + c[i])].push_back(P(v[i], start[j]));\n\t\t\t\tec[P(v[i], t[i] + c[i])].push_back(start[j] - t[i] - c[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> start = starts[s];\n\tfor (int j = 0; j < start.size(); j++) {\n\t\tet[P(0, 0)].push_back(P(s, start[j]));\n\t\tec[P(0, 0)].push_back(start[j]);\n\t}\n}\n\nsigned main() {\n\tinput();\n\t\n\ttypedef pair<int, P> PP;\n\tstatic priority_queue<PP, vector<PP>, greater<PP>> que;\n\tque.push(PP(0, P(0, 0)));\n\twhile (!que.empty()) {\n\t\tPP now = que.top(); que.pop();\n\t\tP pos = now.second;\n\t\tint cst = now.first;\n\t\t\n\t\tif (minDist.find(pos) != minDist.end() && minDist[pos] <= cst) continue;\n\t\tminDist[pos] = cst;\n\t\t\n\t\tvector<P> edge = et[pos];\n\t\tfor (int i = 0; i < edge.size(); i++) {\n\t\t\tque.push(PP(cst + ec[pos][i], edge[i]));\n\t\t}\n\t}\n\t\n\tint ans = 1145141919893810;\n\t\n\tfor (unordered_map<P, int>::iterator it = minDist.begin(); it != minDist.end(); it++) {\n\t\tP pos = (*it).first;\n\t\tif (pos.first == g) {\n\t\t\tans = min(ans, (*it).second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define DEBUG if(0)\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline void chmin(T &l,T r){l=min(l,r);}\ntemplate <typename T>inline void chmax(T &l,T r){l=max(l,r);}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef tuple<int,int,int,LL> T;\nconst LL INF=1e15;\nLL a[212345];\nLL b[212345];\nLL c[212345];\nLL t[212345];\n\nint main(){\n    int N,M,S,G;\n    cin>>N>>M>>S>>G;\n    priority_queue<T> sc;\n    vector<LL> ame(N+1,INF);\n    REP(i,M){\n        cin>>a[i]>>b[i]>>t[i]>>c[i];\n        sc.push(T(-t[i],0,i,0));\n    }\n    ame[S]=0;\n    LL res=INF;\n    while(sc.size()){\n        int tt,type,e;LL cww;\n        tie(tt,type,e,cww)=sc.top();\n        sc.pop();\n        LL bg=t[e];\n        LL ed=t[e]+c[e];\n        if(type==0){\n            LL cost=ame[a[e]]+t[e];\n            sc.push(T(-ed,1,e,cost));\n        }\n        else{\n            if(b[e]==G)chmin(res,cww);\n            chmin(ame[b[e]],cww-t[e]-c[e]);\n        }\n\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nint n,m,s,gg;\nmap<pii,int> ids;\npii rev[252521];\ninline int getid(const pii P){\n  if(ids.count(P)==0){\n    int id = ids.size();\n    ids[P] = id;\n    rev[id] = P;\n  }\n  return ids[P];\n}\nvi tms[125252];\n\nvector<pii> g[252521];\nint dist[252521];\n\nint main(){\n  scanf(\"%d%d%d%d\",&n,&m,&s,&gg);\n  --s;--gg;\n  int start = getid(pii(s,0));\n  tms[s].push_back(0);\n  REP(i,m){\n    int u,v,t,c;\n    scanf(\"%d%d%d%d\",&u,&v,&t,&c);\n    --u;--v;\n    tms[u].push_back(t);\n    tms[v].push_back(t+c);\n    g[getid(pii(u,t))].push_back(pii(getid(pii(v,t+c)),0));\n  }\n  REP(i,n){\n    sort(ALL(tms[i]));\n    tms[i].erase(unique(ALL(tms[i])),tms[i].end());\n    REP(j,tms[i].size()-1){\n      g[getid(pii(i,tms[i][j]))].push_back(pii(getid(pii(i,tms[i][j+1])),tms[i][j+1]-tms[i][j]));\n    }\n  }\n\n  REP(i,ids.size())dist[i] = 1e9;\n\n  int ans = 1e9;\n  priority_queue<pll> Q;\n  Q.push(pll(-0, start));\n  dist[start] = 0;\n  while(!Q.empty()){\n    pll P = Q.top(); Q.pop();\n    int p = P.second;\n    ll d = dist[p];\n    for(pii S : g[p]){\n      int to = S.first;\n      ll cost = S.second;\n      ll nd = d + cost;\n      if(dist[to] <= nd)continue;\n      dist[to] = nd;\n      if(rev[to].first==gg)CHMIN(ans,(int)nd);\n      Q.push(pll(-nd, to));\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) { g[s].emplace_back(s, d, w); }\n\nvector<int> dijkstra(const Graph &g, int s, Array &dist) {\n\tint n = g.size();\n\tassert(s < n);\n\tenum { WHITE, GRAY, BLACK };\n\tvector<int> color(n, WHITE); color[s] = GRAY;\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF); dist[s] = 0;\n\tusing State = tuple<Weight, int, int>; //?§????????????????????????¢ ??? ???\n\tpriority_queue<State, vector<State>, greater<State>> pq; pq.emplace(0, s, -1);\n\twhile (pq.size()) {\n\t\tWeight d; int v, u; tie(d, v, u) = pq.top(); pq.pop();\n\t\tif (dist[v] < d)continue;\n\t\tcolor[v] = BLACK; prev[v] = u;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (color[e.d] == BLACK)continue;\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tpq.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\n//??§?¨???§???\n//index()??¨??????????????????\ntemplate<typename T>\nvector<T> compress(vector<T> v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\treturn v;\n}\n\n//??§????????????????????????????????????\n//index(??§???????????????, ????´?)\ntemplate<typename T>\nint index(const vector<T> &v, T i) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M, S, G; cin >> N >> M >> S >> G;\n\tS--, G--;\n\tusing P = pair<int, int>; // u t\n\tvector<P> V;\n\tV.emplace_back(S, 0);\n\tvector<int> u(M), v(M), t(M), c(M); rep(i, 0, M) {\n\t\tcin >> u[i] >> v[i] >> t[i] >> c[i];\n\t\tu[i]--, v[i]--;\n\t\tV.emplace_back(u[i], t[i]);\n\t\tV.emplace_back(v[i], t[i] + c[i]);\n\t}\n\tvector<P> CV = compress(V);\n\tint n = CV.size();\n\tGraph g(n);\n\trep(i, 0, n - 1) {\n\t\tif (CV[i].first == CV[i + 1].first) {\n\t\t\tadd_arc(g, i, i + 1, CV[i + 1].second - CV[i].second);\n\t\t}\n\t}\n\trep(i, 0, M) {\n\t\tint a = index(CV, P(u[i], t[i])),\n\t\t\tb = index(CV, P(v[i], t[i] + c[i]));\n\t\tadd_arc(g, a, b, 0);\n\t}\n\tint s = index(CV, P(S, 0));\n\tArray dist;\n\tdijkstra(g, s, dist);\n\tWeight ans = INF;\n\trep(i, 0, n) {\n\t\tif (CV[i].first == G) {\n\t\t\tchmin(ans, dist[i]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[100005];\nvector<int> V[100005];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[200115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[200115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( !ids.count( P(v,t+c) ) ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    \n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, V[i][j+1]-V[i][j]);\n    }\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\ntypedef pair< int64, pair< int, int > > Pi;\n\nstruct edge\n{\n  int vv, time, cost, nxt_ptr;\n\n  bool operator<(const edge &e) const\n  {\n    return (time < e.time);\n  }\n\n  bool operator<(int t) const\n  {\n    return (time < t);\n  }\n};\n\nint main()\n{\n  int N, M, S, G;\n  vector< edge > g[100000];\n\n  cin >> N >> M >> S >> G;\n  --S, --G;\n\n  for(int i = 0; i < M; i++) {\n    int u, v, t, c;\n    cin >> u >> v >> t >> c;\n    --u, --v;\n    g[u].push_back((edge) {v, t, c});\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(g[i]), end(g[i]));\n  }\n\n  for(int i = 0; i < N; i++) {\n    for(auto &e : g[i]) {\n      e.nxt_ptr = lower_bound(begin(g[e.vv]), end(g[e.vv]), e.time + e.cost) - begin(g[e.vv]);\n    }\n  }\n\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  map< pair< int, int >, int64 > vv;\n  que.emplace(g[S][0].time, make_pair(S, 0));\n  vv[{S, 0}] = g[S][0].time;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n\n    int idx, now;\n    tie(idx, now) = p.second;\n\n    if(p.first > vv[{idx, now}]) continue;\n\n    if(idx == G) {\n      cout << p.first << endl;\n      return (0);\n    }\n\n    if(now + 1 < g[idx].size()) {\n      int64 nt = p.first + g[idx][now + 1].time - g[idx][now].time;\n      if(!vv.count({idx, now + 1}) || nt < vv[{idx, now + 1}]) {\n        vv[{idx, now + 1}] = nt;\n        que.emplace(nt, make_pair(idx, now + 1));\n      }\n    }\n\n    if(now < g[idx].size()) {\n      auto &ee = g[idx][now];\n      int64 nt = p.first;\n      if(ee.vv != G) {\n        if(ee.nxt_ptr >= g[ee.vv].size()) continue;\n        nt += g[ee.vv][ee.nxt_ptr].cost - (ee.time + ee.cost);\n      }\n      if(!vv.count({ee.vv, ee.nxt_ptr}) || nt < vv[{ee.vv, ee.nxt_ptr}]) {\n        vv[{ee.vv, ee.nxt_ptr}] = nt;\n        que.emplace(nt, make_pair(ee.vv, ee.nxt_ptr));\n      }\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define int long long\nstruct Edge {\n  int a, b, s, t, cost;\n  Edge() {}\n  Edge(int a_, int b_, int s_, int t_, int cost_) : a(a_), b(b_), s(s_), t(t_), cost(cost_) {}\n};\nstruct State {\n  int v, t, cost;\n  State(int v_, int t_, int cost_) : v(v_), t(t_), cost(cost_) {}\n  bool operator >(const State &other) const {\n    return cost > other.cost;\n  }\n};\nsigned main() {\n  int N, M, S, T; cin >> N >> M >> S >> T;\n  S--, T--;\n  vector<Edge> E(M);\n  REP(i,M) {\n    cin >> E[i].a >> E[i].b >> E[i].s >> E[i].t;\n    E[i].a--;\n    E[i].b--;\n    E[i].t += E[i].s;\n    E[i].cost = 0;\n  }\n  vector<vector<int>> TIME(N);\n  TIME[S].push_back(0);\n  REP(i,M) {\n    TIME[E[i].a].push_back(E[i].s);\n    TIME[E[i].b].push_back(E[i].t);\n  }\n  vector<map<int, vector<Edge>>> G(N);\n  REP(i,N) {\n    sort(TIME[i].begin(), TIME[i].end());\n    REP(j,(int)TIME[i].size()-1) {\n      if(TIME[i][j] != TIME[i][j+1]) {\n        G[i][TIME[i][j]].emplace_back(i, i, TIME[i][j], TIME[i][j+1], TIME[i][j+1] - TIME[i][j]);\n      }\n    }\n  }\n  REP(i,M) {\n    G[E[i].a][E[i].s].push_back(E[i]);\n  }\n  //REP(i,N) {\n  //  for(const pair<int, vector<Edge>> &pp : G[i]) {\n  //    for(const Edge &e : pp.second) {\n  //      cerr << e.a << \" => \" << e.b << \" (\" << e.s << \",\" << e.t << \") C=\" << e.cost << endl;\n  //    }\n  //  }\n  //}\n  vector<map<int, int>> D(N);\n  priority_queue<State, vector<State>, greater<State>> Q;\n  Q.emplace(S, 0, 0);\n  D[S][0] = 0;\n  while(!Q.empty()) {\n    State s = Q.top(); Q.pop();\n    if(D[s.v].count(s.t) && s.cost > D[s.v][s.t]) continue;\n    for(const Edge &e : G[s.v][s.t]) {\n      if((D[e.b].count(e.t) == 0) || (D[e.b][e.t] > s.cost + e.cost)) {\n        D[e.b][e.t] = s.cost + e.cost;\n        Q.emplace(e.b, e.t, D[e.b][e.t]);\n      }\n    }\n  }\n  int ans = (int)1e18;\n  for(pair<int, int> iter : D[T]) {\n    ans = min(ans, iter.second);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i;\n    if(b[k].size())i=upper_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <queue>\nusing namespace std;\n\nstruct Edge {\n    int id, from, to, t, c;\n};\n\nstruct State {\n    int id, cost;\n    bool is_to;\n    State(int id, int cost, bool is_to) : id(id), cost(cost), is_to(is_to) {}\n    bool operator>(const State& s) const {\n        return cost > s.cost;\n    }\n};\n\nconst int MAX_N = 100010;\nconst int MAX_M = 200010;\nconst int INF = (1 << 28);\n\nvector<Edge> edges;\nint cost[MAX_M][2];\nvector<int> have_edges[MAX_N];\n\nint main() {\n    fill((int* )cost, (int* )(cost + MAX_M), INF);\n    int n, m, s, g;\n    cin >> n >> m >> s >> g;\n\n    s--; g--;\n\n    for (int i = 0; i < m; i++) {\n        int u, v, t, c;\n        cin >> u >> v >> t >> c;\n        u--; v--;\n\n        // (id, from, to, t, c)\n        edges.push_back((Edge){i, u, v, t, c});\n        have_edges[v].push_back(i);\n    }\n\n    priority_queue<State, vector<State>, greater<State>> que;\n    for (int id : have_edges[g]) {\n        que.push(State(id, 0, true));\n        cost[id][true] = 0;\n    }\n    while (!que.empty()) {\n        State state = que.top(); que.pop();\n        if (cost[state.id][state.is_to] < state.cost) {\n            continue;\n        }\n        if (state.is_to) {\n            Edge e = edges[state.id];\n            if (cost[state.id][false] > state.cost) {\n                cost[state.id][false] = state.cost;\n                que.push(State(state.id, state.cost, false));\n            }\n        } else {\n            Edge e = edges[state.id];\n            int v = e.from;\n            for (int next_id : have_edges[v]) {\n                Edge next_edge = edges[next_id];\n                if (next_edge.t + next_edge.c > e.t) continue;\n                if (cost[next_id][true] > state.cost + e.t - (next_edge.t + next_edge.c)) {\n                    cost[next_id][true] = state.cost + e.t - (next_edge.t + next_edge.c);\n                    que.push(State(next_id, cost[next_id][true], true));\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < m; i++) {\n        if (edges[i].from == s) {\n            ans = min(ans, cost[i][false] + edges[i].t);\n        }\n    }\n    cout << ans << endl;\n\n    /*\n    int a, b;\n    while (cin >> a >> b, a >= 0 && b >= 0) {\n        cout << cost[a][b] << endl;\n    }\n    */\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <functional>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m, s, g;\nint u[200000], v[200000], t[200000], c[200000];\nmap<P, vector<P>> et;\nmap<P, vector<int>> ec;\nvector<int> starts[200001];\nmap<P, int> minDist;\n\nvoid input() {\n\tcin >> n >> m >> s >> g; s--; g--;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> u[i] >> v[i] >> t[i] >> c[i]; u[i]--; v[i]--;\n\t\tet[P(u[i], t[i])].push_back(P(v[i], t[i] + c[i]));\n\t\tec[P(u[i], t[i])].push_back(0);\n\t\tstarts[u[i]].push_back(t[i]);\n\t}\n\t\n\tfor (int i = 0; i < m; i++) {\n\t\tvector<int> start = starts[v[i]];\n\t\tfor (int j = 0; j < start.size(); j++) {\n\t\t\tif (t[i] + c[i] <= start[j]) {\n\t\t\t\tet[P(v[i], t[i] + c[i])].push_back(P(v[i], start[j]));\n\t\t\t\tec[P(v[i], t[i] + c[i])].push_back(start[j] - t[i] - c[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> start = starts[s];\n\tfor (int j = 0; j < start.size(); j++) {\n\t\tet[P(0, 0)].push_back(P(s, start[j]));\n\t\tec[P(0, 0)].push_back(start[j]);\n\t}\n}\n\nsigned main() {\n\tinput();\n\t\n\ttypedef pair<int, P> PP;\n\tstatic priority_queue<PP, vector<PP>, greater<PP>> que;\n\tque.push(PP(0, P(0, 0)));\n\twhile (!que.empty()) {\n\t\tPP now = que.top(); que.pop();\n\t\tP pos = now.second;\n\t\tint cst = now.first;\n\t\t\n\t\tif (minDist.find(pos) != minDist.end() && minDist[pos] <= cst) continue;\n\t\tminDist[pos] = cst;\n\t\t\n\t\tvector<P> edge = et[pos];\n\t\tfor (int i = 0; i < edge.size(); i++) {\n\t\t\tque.push(PP(cst + ec[pos][i], edge[i]));\n\t\t}\n\t}\n\t\n\tint ans = 1145141919893810;\n\t\n\tfor (map<P, int>::iterator it = minDist.begin(); it != minDist.end(); it++) {\n\t\tP pos = (*it).first;\n\t\tif (pos.first == g) {\n\t\t\tans = min(ans, (*it).second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],tt;\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    //    assert(tt++<1e7);\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(p==g)return nw;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=lower_bound(b[k].begin(),b[k].end(),P(nw,0))-b[k].begin();\n    for(;i<b[k].size();i++){\n      //  assert(tt++<1e7);\n      ll np=b[k][i].second,nk=v[np];\n      if(np==g)return cs+t[np]-nw;\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=lower_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for( int i=lower_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(t[np]-(t[p]+c[p])>=0&&!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<m;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <functional>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n \nint n, m, s, g;\nint u[200000], v[200000], t[200000], c[200000];\nmap<P, vector<P>> et;\nmap<P, vector<int>> ec;\nvector<int> starts[200001];\nmap<P, int> minDist;\n \nvoid input() {\n    cin >> n >> m >> s >> g;\n    for (int i = 0; i < m; i++) {\n        cin >> u[i] >> v[i] >> t[i] >> c[i];\n        et[P(u[i], t[i])].push_back(P(v[i], t[i] + c[i]));\n        ec[P(u[i], t[i])].push_back(0);\n        starts[u[i]].push_back(t[i]);\n    }\n     \n    for (int i = 0; i < m; i++) {\n        vector<int> start = starts[v[i]];\n        for (int j = 0; j < start.size(); j++) {\n            if (t[i] + c[i] <= start[j]) {\n                et[P(v[i], t[i] + c[i])].push_back(P(v[i], start[j]));\n                ec[P(v[i], t[i] + c[i])].push_back(start[j] - t[i] - c[i]);\n            }\n        }\n    }\n     \n    vector<int> start = starts[s];\n    for (int j = 0; j < start.size(); j++) {\n        et[P(0, 0)].push_back(P(s, start[j]));\n        ec[P(0, 0)].push_back(start[j]);\n    }\n}\n \nsigned main() {\n    input();\n     \n    typedef pair<int, P> PP;\n    static priority_queue<PP, vector<PP>, greater<PP>> que;\n    que.push(PP(0, P(0, 0)));\n    while (!que.empty()) {\n        PP now = que.top(); que.pop();\n        P pos = now.second;\n        int cst = now.first;\n         \n        if (minDist.find(pos) != minDist.end() && minDist[pos] <= cst) continue;\n        minDist[pos] = cst;\n         \n        vector<P> edge = et[pos];\n        for (int i = 0; i < edge.size(); i++) {\n            que.push(PP(cst + ec[pos][i], edge[i]));\n        }\n    }\n     \n    int ans = 1145141919893810;\n     \n    for (map<P, int>::iterator it = minDist.begin(); it != minDist.end(); it++) {\n        P pos = (*it).first;\n        if (pos.first == g) {\n            ans = min(ans, (*it).second);\n        }\n    }\n     \n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i;\n    if(b[k].size())i=upper_bound(b[k].begin(),b[k].end(),P(nw-1,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(t[np]-nw>=0&&!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<m;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define DEBUG if(0)\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline void chmin(T &l,T r){l=min(l,r);}\ntemplate <typename T>inline void chmax(T &l,T r){l=max(l,r);}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef tuple<int,int,int,LL> T;\nconst LL INF=1e15;\nLL a[112345];\nLL b[112345];\nLL c[112345];\nLL t[112345];\n\nint main(){\n    int N,M,S,G;\n    cin>>N>>M>>S>>G;\n    priority_queue<T> sc;\n    vector<LL> ame(N+1,INF);\n    REP(i,M){\n        cin>>a[i]>>b[i]>>t[i]>>c[i];\n        sc.push(T(-t[i],0,i,0));\n    }\n    ame[S]=0;\n    LL res=INF;\n    while(sc.size()){\n        int tt,type,e;LL cww;\n        tie(tt,type,e,cww)=sc.top();\n        sc.pop();\n        LL bg=t[e];\n        LL ed=t[e]+c[e];\n        if(type==0){\n            LL cost=ame[a[e]]+t[e];\n            sc.push(T(-ed,1,e,cost));\n        }\n        else{\n            if(b[e]==G)chmin(res,cww);\n            chmin(ame[b[e]],cww-t[e]-c[e]);\n        }\n\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nmap <int,int> dp;\nstruct ed{int u,v,t,c;};\nvector <ed> eds;\nstruct edge{int no,u,t,c;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp.count(q)) return dp[q];\n\n\tint vofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(vofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[vofq].size();i++){\n\t\tint no=Graph[q][i].no;\n\t\tint tc=Graph[q][i].t+Graph[q][i].c;\n\t\tif(tc>tofq) continue;\n\t\ttmp=min(tmp,(tofq-tc)+dp[no]);\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t,c});\n\n\t\teds.push_back({u,v,t,c});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v=G){\n\t\t\tans=min(ans,memo(i));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836\n\nint main(){\n  int n,m,s,g;\n  cin>>n>>m>>s>>g;\n  s--;g--;\n  vector<int> u(m),v(m),t(m),c(m);\n  rep(i,m) cin>>u[i]>>v[i]>>t[i]>>c[i];\n  rep(i,m) u[i]--,v[i]--;\n\n  vector<vector<int>> st(200001), gt(200001), gc(200001);\n  rep(i,m) st[t[i]].pb(i);\n\n  vector<int> bs(n,-INF);\n  bs[s] = 0;\n\n  int ans = INF;\n  rep(i,200001){\n    int k = gt[i].size();\n    rep(j,k){//dbg(i),dbg(bs);\n      int arr = gt[i][j];\n      int cost = gc[i][j];\n      bs[arr] = max(bs[arr], cost);\n      if(arr == g){\n        ans = min(ans, i-bs[arr]);\n      }\n    }\n    for(auto id : st[i]){//dbg(i),dbg(bs);\n      gt[i+c[id]].pb(v[id]);\n      gc[i+c[id]].pb(bs[u[id]] + c[id]);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[200010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds(200010);\nstruct edge{int no,u,tc;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint uofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(uofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[uofq].size();i++){\n\t\tint no=Graph[uofq][i].no;\n\t\tint tc=Graph[uofq][i].tc;\n\t\t//if(tc>tofq) continue;\n\t\tif(tc>tofq) break;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tio();\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t+c});\n\n\t\t//eds.push_back({u,v,t,c});\n\t\teds[i]={u,v,t,c};\n\t}\n\n\t/*for(int i=0;i<N;i++){\n\t\tsort(Graph[i].begin(),Graph[i].end(),[](const edge &a, const edge &b){return a.tc<b.tc;});\n\t}*/\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G) ans=min(ans,memo(i));\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i;\n    if(b[k].size())i=upper_bound(b[k].begin(),b[k].end(),P(nw-1,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(t[np]-nw>=0&&!ans[np]&&!used[nk])\n\tQ.push(P(cs-(t[np]-nw),np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<m;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstruct bus {\n\tint from;\n\tint to;\n\tint depart;\n\tint arrive;\n};\nbool operator<(const bus&l, const bus&r) {\n\treturn l.depart < r.depart;\n}\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n};\nstruct aa {\n\tint now;\n\tint time;\n};\nclass Compare {\npublic:\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\t//aa?????????????????¶\n\n\nint N, M, S, G;\n\nint  dfs(const int start,const int goal, const vector<vector<edge>>&edges,vector<int>&memo,const vector<int>&node_id) {\n\tint ans = 1e7;\n\tpriority_queue<aa,vector<aa>,Compare>que;\n\tque.push(aa{ start,0 });\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tfor (auto e : edges[atop.now]) {\n\t\t\tif (e.to==goal) {\n\t\t\t\treturn atop.time;\n\t\t\t}\n\t\t\tif (memo[e.to] > atop.time + e.cost) {\n\t\t\t\tmemo[e.to] = atop.time + e.cost;\n\t\t\t\tque.push(aa{ e.to,atop.time+e.cost });\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n\t\n}\nint main() {cin >> N >> M >> S >> G;\n\tS--; G--;\n\tvector<vector<bus>>buss(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v, t, c; cin >> u >> v >> t >>c;\n\t\tbuss[u-1].push_back(bus{ u - 1,v - 1,t,t+c });\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tsort(buss[i].begin(), buss[i].end());\n\t}\n\t\n\tconst int start = 0;\n\tvector<int>node_id(N);\n\tint num = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tnode_id[i] = num;\n\t\tnum += buss[i].size();\n\t}\n\tconst int goal = num;\n\tvector<vector<edge>>edges(num+1);\n\tvector<int>memo(num, 1e8);\n\tedges[start].push_back(edge{ start,node_id[S],buss[S][0].depart });\n\t\n\n\tfor (int from_stop = 0; from_stop < N; ++from_stop) {\n\t\tfor (int i = 0; i < buss[from_stop].size(); ++i) {\n\t\t\tbus b(buss[from_stop][i]);\n\t\t\tconst int from_id = node_id[from_stop] +i;\n\n\t\t\tif (i != buss[from_stop].size() - 1) {\n\t\t\t\tedges[from_id].push_back(edge{ from_id,from_id + 1,buss[from_stop][i + 1].depart - buss[from_stop][i].depart });\n\t\t\t}\n\n\t\t\tauto it = lower_bound(buss[b.to].begin(), buss[b.to].end(), bus{ -1,-1,b.arrive,-1 });\n\t\t\tif (b.to == G) {\n\t\t\t\tedges[from_id].push_back(edge{ from_id,goal,0 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (it != buss[b.to].end()) {\n\t\t\t\t\tconst int to_id = node_id[b.to] + (it - buss[b.to].begin());\n\t\t\t\t\tconst int acost = it->depart-b.arrive;\n\t\t\t\t\tedges[from_id].push_back(edge{ from_id, to_id, acost });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tint ans=dfs(0,goal, edges, memo,node_id);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=lower_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(i=0;i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(t[np]-nw>=0&&!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<m;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i;\n    if(b[k].size())i=lower_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(t[np]-nw>=0&&!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<m;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nmap <int,int> dp;\nstruct ed{int u,v,t,c;};\nvector <ed> eds;\nstruct edge{int no,u,t,c;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp.count(q)) return dp[q];\n\n\tint vofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(vofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[vofq].size();i++){\n\t\tint no=Graph[q][i].no;\n\t\tint tc=Graph[q][i].t+Graph[q][i].c;\n\t\tif(tc>tofq) continue;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t,c});\n\n\t\teds.push_back({u,v,t,c});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G){\n\t\t\t//cout<<i<<endl;\n\t\t\t//cout<<memo(i)<<endl;\n\t\t\tans=min(ans,memo(i));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n    V[i].erase( unique( V[i].begin(), V[i].end()), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i = (a); i < (b); ++i)\n#define RFOR(i,a,b) for (ll i=(b)-1; i>=a;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if(i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nstruct Edge {\n    int from, to, t, c;\n};\nbool operator<(const Edge& e1, const Edge& e2) {\n    return e1.t < e2.t;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m, s, g; cin >> n >> m >> s >> g; --s, --g;\n    vector<Edge> edges;\n    vector<vector<P>> Q(n);\n    vector<int> idx(n, 0);\n    REP(i, m) {\n        int u, v, t, c; cin >> u >> v >> t >> c; --u, --v;\n        edges.pb({u, v, t, c});\n        Q[u].pb({t, linf});\n    }\n    REP(i, n) {\n        sort(ALL(Q[i]));\n    }\n    if (Q[s].size() > 0) {\n        Q[s][0].second = Q[s][0].first;\n    }\n    sort(ALL(edges));\n    ll ans = linf;\n    EACH(e, edges) {\n        P& d00 = Q[e.from][idx[e.from]++];\n        // wait\n        assert(e.t == d00.first);\n        if (idx[e.from] < Q[e.from].size()) {\n            P& d01 = Q[e.from][idx[e.from]];\n            d01.second = min(d01.second, d00.second+(d01.first - d00.first));\n        }\n        // ride\n        if (e.to == g) {\n            ans = min(ans, d00.second);\n        }\n        auto it = lower_bound(ALL(Q[e.to]), P(d00.first+e.c, -1));\n        if (it != Q[e.to].end()) {\n            it->second = min(it->second, d00.second + (it->first - (e.t+e.c)));\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\ntypedef pair< int64, pair< int, int > > Pi;\n\nstruct edge\n{\n  int vv, time, cost, nxt_ptr;\n\n  bool operator<(const edge &e) const\n  {\n    return (time < e.time);\n  }\n\n  bool operator<(int t) const\n  {\n    return (time < t);\n  }\n};\n\nint main()\n{\n  int N, M, S, G;\n  vector< edge > g[100000];\n\n  cin >> N >> M >> S >> G;\n  --S, --G;\n\n  for(int i = 0; i < M; i++) {\n    int u, v, t, c;\n    cin >> u >> v >> t >> c;\n    --u, --v;\n    g[u].push_back((edge) {v, t, c});\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(g[i]), end(g[i]));\n  }\n\n  for(int i = 0; i < N; i++) {\n    for(auto &e : g[i]) {\n      e.nxt_ptr = lower_bound(begin(g[e.vv]), end(g[e.vv]), e.time + e.cost) - begin(g[e.vv]);\n    }\n  }\n\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  map< pair< int, int >, int64 > vv;\n  que.emplace(g[S][0].time, make_pair(S, 0));\n  vv[{S, 0}] = g[S][0].time;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n\n    int idx, now;\n    tie(idx, now) = p.second;\n\n    if(p.first > vv[{idx, now}]) continue;\n\n    if(idx == G) {\n      cout << p.first << endl;\n      return (0);\n    }\n\n    if(now + 1 < g[idx].size()) {\n      int64 nt = p.first + g[idx][now + 1].time - g[idx][now].time;\n      if(!vv.count({idx, now + 1}) || nt < vv[{idx, now + 1}]) {\n        vv[{idx, now + 1}] = nt;\n        que.emplace(nt, make_pair(idx, now + 1));\n      }\n    }\n\n    if(now < g[idx].size()) {\n      auto &ee = g[idx][now];\n      int64 nt = p.first;\n      if(ee.vv != G) {\n        if(ee.nxt_ptr >= g[ee.vv].size()) continue;\n        nt += g[ee.vv][ee.nxt_ptr].time - (ee.time + ee.cost);\n      }\n      if(!vv.count({ee.vv, ee.nxt_ptr}) || nt < vv[{ee.vv, ee.nxt_ptr}]) {\n        vv[{ee.vv, ee.nxt_ptr}] = nt;\n        que.emplace(nt, make_pair(ee.vv, ee.nxt_ptr));\n      }\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 58;\ntypedef pair< int64, pair< int, int > > Pi;\n \nstruct edge\n{\n  int vv, time, cost, nxt_ptr;\n \n  bool operator<(const edge &e) const\n  {\n    return (time < e.time);\n  }\n \n  bool operator<(int t) const\n  {\n    return (time < t);\n  }\n};\n \nint main()\n{\n  int N, M, S, G;\n  vector< edge > g[100000];\n \n  cin >> N >> M >> S >> G;\n  --S, --G;\n \n  for(int i = 0; i < M; i++) {\n    int u, v, t, c;\n    cin >> u >> v >> t >> c;\n    --u, --v;\n    g[u].push_back((edge) {v, t, c});\n  }\n \n  for(int i = 0; i < N; i++) {\n    sort(begin(g[i]), end(g[i]));\n  }\n \n  for(int i = 0; i < N; i++) {\n    for(auto &e : g[i]) {\n      e.nxt_ptr = lower_bound(begin(g[e.vv]), end(g[e.vv]), e.time + e.cost) - begin(g[e.vv]);\n    }\n  }\n \n \n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  map< pair< int, int >, int64 > vv;\n  que.emplace(g[S][0].time, make_pair(S, 0));\n  vv[{S, 0}] = g[S][0].time;\n \n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n \n    int idx, now;\n    tie(idx, now) = p.second;\n \n    if(p.first > vv[{idx, now}]) continue;\n \n    if(idx == G) {\n      cout << p.first << endl;\n      return (0);\n    }\n \n    if(now + 1 < g[idx].size()) {\n      int64 nt = p.first + g[idx][now + 1].time - g[idx][now].time;\n      if(!vv.count({idx, now + 1}) || nt < vv[{idx, now + 1}]) {\n        vv[{idx, now + 1}] = nt;\n        que.emplace(nt, make_pair(idx, now + 1));\n      }\n    }\n \n    if(now < g[idx].size()) {\n      auto &ee = g[idx][now];\n      int64 nt = p.first;\n      if(ee.vv != G) {\n        if(ee.nxt_ptr >= g[ee.vv].size()) continue;\n        nt += g[ee.vv][ee.nxt_ptr].time - (ee.time + ee.cost);\n      }\n      if(!vv.count({ee.vv, ee.nxt_ptr}) || nt < vv[{ee.vv, ee.nxt_ptr}]) {\n        vv[{ee.vv, ee.nxt_ptr}] = nt;\n        que.emplace(nt, make_pair(ee.vv, ee.nxt_ptr));\n      }\n    }\n  }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define printvec(a) rep(i,a) cout << a[i] << \" \\n\"[i+1==(a).size()];\n#define fs first\n#define sc second\n#define em emplace\n#define eb emplace_back\n#define sz size()\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nconst ll INF = 1e8;\nconst D EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\nstruct edge{\n  int u,v,s,t;\n  edge(int a=0, int b=0, int x=0, int y=0):u(a), v(b), s(x), t(y) {}\n  bool operator<(const edge &e) const {\n    return t < e.t;\n  }\n};\n\nint main(){\n  int n,m,s,g;\n  cin >> n >> m >> s >> g; s--; g--;\n\n  vector<vi> event(n);\n  vector<edge> edges;\n  rep(i,m){\n    int u,v,t,c;\n    cin >> u >> v >> t >> c; u--; v--;\n    edges.eb( edge(u,v,t,t+c) );\n    event[v].eb(t+c);\n  }\n  event[s].eb(0);\n  sort(all(edges));\n  rep(i,n) sort(all(event[i]));\n\n  vector<vi> ans(n);\n  rep(i,n){\n    if(i==g) ans[i] = vi(event[i].size(), 0);\n    else ans[i] = vi(event[i].size(), INF);\n  }\n\n  rrep(i, m){\n    edge &e = edges[i];\n    if(e.u == g) continue;\n    int u_p = upper_bound(all(event[e.u]), e.s) - event[e.u].begin();\n    int v_p = lower_bound(all(event[e.v]), e.t) - event[e.v].begin();\n    \n    if(u_p != 0) chmin(ans[e.u][u_p-1], ans[e.v][v_p] + (e.s - event[e.u][u_p-1]));\n    if(v_p != 0) chmin(ans[e.v][v_p-1], ans[e.v][v_p] + event[e.v][v_p] - event[e.v][v_p-1]);\n  }\n  cout << ans[s][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\ntypedef pair< int64, pair< int, int > > Pi;\n\nstruct edge\n{\n  int vv, time, cost, nxt_ptr;\n\n  bool operator<(const edge &e) const\n  {\n    return (time < e.time);\n  }\n\n  bool operator<(int t) const\n  {\n    return (time < t);\n  }\n};\n\nint main()\n{\n  int N, M, S, G;\n  vector< edge > g[100000];\n\n  cin >> N >> M >> S >> G;\n  --S, --G;\n\n  for(int i = 0; i < M; i++) {\n    int u, v, t, c;\n    cin >> u >> v >> t >> c;\n    --u, --v;\n    g[u].push_back((edge) {v, t, c});\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(g[i]), end(g[i]));\n  }\n\n  for(int i = 0; i < N; i++) {\n    for(auto &e : g[i]) {\n      e.nxt_ptr = lower_bound(begin(g[e.vv]), end(g[e.vv]), e.time + e.cost) - begin(g[e.vv]);\n    }\n  }\n\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  map< pair< int, int >, int64 > vv;\n  que.emplace(g[S][0].time, make_pair(S, 0));\n  vv[{S, 0}] = g[S][0].time;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n\n    int idx, now;\n    tie(idx, now) = p.second;\n\n    if(p.first > vv[{idx, now}]) continue;\n\n    if(idx == G) {\n      cout << p.first << endl;\n      return (0);\n    }\n\n    if(now + 1 < g[idx].size()) {\n      int64 nt = p.first + g[idx][now + 1].time - g[idx][now].time;\n      if(!vv.count({idx, now + 1}) || nt < vv[{idx, now + 1}]) {\n        vv[{idx, now + 1}] = nt;\n        que.emplace(nt, make_pair(idx, now + 1));\n      }\n    }\n\n    if(now < g[idx].size()) {\n      auto &ee = g[idx][now];\n      if(!vv.count({ee.vv, ee.nxt_ptr}) || p.first < vv[{ee.vv, ee.nxt_ptr}]) {\n        vv[{ee.vv, ee.nxt_ptr}] = p.first;\n        que.emplace(p.first, make_pair(ee.vv, ee.nxt_ptr));\n      }\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],ans[200001],used[100001];\nvector<ll> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  memset(ans,-1,sizeof(ans));\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p];\n    if(ans[p]!=-1||used[k])continue;\n    if(v[p]==g)return cs;\n    ans[p]=cs;used[k]=1;\n    Q.pop();\n    for(int i=0;i<b[k].size();i++){\n      ll np=b[k][i];\n      if(t[np]-(t[p]+c[p])>=0&&ans[np]==-1)Q.push(P(cs+t[np]-(t[p]+c[p]),np));\n    }\n  }\n  ll res=1e15;\n  for(int i=0;i<m;i++)\n    if(v[i]==g&&ans[i]!=-1)res=min(ans[i],res);\n  return res;\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(i);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[200010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds(200010);\nstruct edge{int no,u,tc;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint uofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(uofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[uofq].size();i++){\n\t\tint no=Graph[uofq][i].no;\n\t\tint tc=Graph[uofq][i].tc;\n\t\tif(tc>tofq) continue;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t+c});\n\n\t\t//eds.push_back({u,v,t,c});\n\t\teds[i]={u,v,t,c};\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G) ans=min(ans,memo(i));\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n  \n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst bool debug = true;\n#define dbg(...) if(debug) printf(__VA_ARGS__)\n#define print(var) if (debug) cout << #var << \" = \" << var << endl\n\nnamespace {\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os << \"[]\";\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const map<K, V>& m) {\n        bool first = true;\n        for (auto p : m) {\n            if (first) first = false;\n            else os << \":\";\n            os << \"(\" << p.first << \",\" << p.second << \")\";\n        }\n        return os;\n    }\n\n\n    map<tuple<int, int, bool>, int> id;\n    vector<tuple<int, int, bool>> fromId;\n\n    struct Edge {\n        int to, cost;\n        Edge(int to, int cost) : to(to), cost(cost) {}\n    };\n    vector<vector<Edge>> Graph;\n\n    int N, M, S, G;\n\n    bool IN = false;\n    bool OUT = true;\n\n    void solve() {\n        cin >> N >> M >> S >> G;\n        S--; G--;\n        vector<vector<tuple<int, int, bool>>> V(N);\n        auto init = make_tuple(S, 0, IN);\n        V[S].push_back(init);\n        id[init] = 0;\n        fromId.push_back(init);\n        Graph.emplace_back();\n        for (int  i = 0; i < M; i++) {\n            int u, v, t, c; cin >> u >> v >> t >> c;\n            u--; v--;\n            auto x = make_tuple(u, t, OUT);\n            auto x_id = id.count(x) ? id[x] : fromId.size();\n            if (not id.count(x)) {\n                fromId.push_back(x);\n                id[x] = x_id;\n                Graph.emplace_back();\n            }\n            V[u].push_back(x);\n            auto y = make_tuple(v, t + c, IN);\n            auto y_id = id.count(y) ? id[y] : fromId.size();\n            if (not id.count(y)) {\n                fromId.push_back(y);\n                id[y] = y_id;\n                Graph.emplace_back();\n            }\n            V[v].push_back(y);\n            Graph[x_id].emplace_back(y_id, 0);\n        }\n        for (auto& L : V) {\n            sort(L.begin(), L.end(), [&](const tuple<int, int, bool>& a, const tuple<int, int, bool>& b) {\n                return get<1>(a) == get<1>(b) ? get<2>(a) < get<2>(b) : get<1>(a) < get<1>(b);\n            });\n            for (unsigned i = 0; i + 1 < L.size(); i++) {\n                auto& x = L[i];\n                auto& y = L[i + 1];\n                auto time_x = get<1>(x);\n                auto time_y = get<1>(y);\n                Graph[id[x]].emplace_back(id[y], time_y - time_x);\n            }\n        }\n\n        auto start = id[ V[S][0] ];\n\n        // dijkstra\n        const int INF = 1<<28;\n        vector<int> D(Graph.size(), INF);\n        struct State {\n            int v, cost;\n            State(int v, int cost) : v(v), cost(cost) {}\n            bool operator<(const State& s) const {\n                return cost > s.cost;\n            }\n        };\n        priority_queue<State> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : Graph[cur.v]) {\n                auto next = e.to;\n                if (D[next] > cur.cost + e.cost) {\n                    D[next] = cur.cost + e.cost;\n                    PQ.emplace(next, D[next]);\n                }\n            }\n        }\n        int ans = INF;\n        for (auto& goal_vertex : V[G]) {\n            auto goal = id[goal_vertex];\n            ans = min(ans, D[goal]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 10000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass edge{\npublic:\n\tint u,v,t,c;\n\tedge(){}\n\tedge(int uu,int vv,int tt,int cc){\n\t\tu=uu;\n\t\tv=vv;\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge &e)const{\n\t\treturn t<e.t;\n\t}\n};\n\nclass data{\npublic:\n\tint v,t,c;\n\tdata(){}\n\tdata(int vv,int tt,int cc){\n\t\tv=vv;\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn d.t<t;\n\t}\n};\nint n,m,s,g;\nint dp[100001];\nint prev[100001];\nvector<edge> G;\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&g);\n\ts--;\n\tg--;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,t,c;\n\t\tscanf(\"%d%d%d%d\",&u,&v,&t,&c);\n\t\tu--;\n\t\tv--;\n\t\tG.push_back(edge(u,v,t,c));\n\t}\n\tsort(G.begin(),G.end());\n\tpriority_queue<data> que;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=INF;\n\t}\n\tdp[s]=0;\n\tint res=INF;\n\tfor(int i=0;i<m;i++){\n\t\tedge e=G[i];\n\t\twhile(1){\n\t\t\tif(!que.size())break;\n\t\t\tdata q=que.top();\n\t\t\tif(q.t<=e.t){\n\t\t\t\tif(dp[q.v]+e.t-prev[q.v]>q.c){\n\t\t\t\t\tdp[q.v]=q.c;\n\t\t\t\t\tprev[q.v]=e.t;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t}else break;\n\t\t}\n\t\tif(e.u==g)res=min(e.u,res);\n\t\tif(dp[e.u]!=INF){\n\t\t\tdp[e.u]=dp[e.u]+e.t-prev[e.u];\n\t\t\tprev[e.u]=e.t;\n\t\t\tque.push(data(e.v,e.t+e.c,dp[e.u]));\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v]>q.c){\n\t\t\tdp[q.v]=q.c;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",min(res,dp[g]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],tt;\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=upper_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      assert(tt++<1e7);\n      ll np=b[k][i].second,nk=v[np];\n      if(np==g)return cs+t[np]-nw;\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],tt;\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    assert(tt++<1e7);\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(p==g)return nw;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=lower_bound(b[k].begin(),b[k].end(),P(nw,0))-b[k].begin();\n    for(;i<b[k].size();i++){\n      assert(tt++<1e7);\n      ll np=b[k][i].second,nk=v[np];\n      if(np==g)return cs+t[np]-nw;\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],ans[200001];\nvector<ll> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  memset(ans,-1,sizeof(ans));\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second;\n     if(ans[p]!=-1)continue;\n     ans[p]=cs;\n     Q.pop();\n     int k=v[p];\n     for(int i=0;i<b[k].size();i++){\n       ll np=b[k][i];\n       if(t[np]-(t[p]+c[p])>=0)Q.push(P(cs+t[np]-(t[p]+c[p]),np));\n     }\n  }\n  ll res=1e15;\n  for(int i=0;i<m;i++)\n    if(v[i]==g&&ans[i]!=-1)res=min(ans[i],res);\n  return res;\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    cin>>u[i]>>v[i]>>t[i]>>c[i];\n    b[u[i]].push_back(i);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[200010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds;\nstruct edge{int no,u,t,c;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint uofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(uofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[uofq].size();i++){\n\t\tint no=Graph[uofq][i].no;\n\t\tint tc=Graph[uofq][i].t+Graph[uofq][i].c;\n\t\tif(tc>tofq) continue;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t,c});\n\n\t\teds.push_back({u,v,t,c});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G) ans=min(ans,memo(i));\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],ans[200001];\nvector<ll> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  memset(ans,-1,sizeof(ans));\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second;\n     if(ans[p]!=-1)continue;\n     ans[p]=cs;\n     Q.pop();\n     int k=v[p];\n     for(int i=0;i<b[k].size();i++){\n       ll np=b[k][i];\n       if(t[np]-(t[p]+c[p])>=0&&ans[np]==-1)Q.push(P(cs+t[np]-(t[p]+c[p]),np));\n     }\n  }\n  ll res=1e15;\n  for(int i=0;i<m;i++)\n    if(v[i]==g&&ans[i]!=-1)res=min(ans[i],res);\n  return res;\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(i);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nconst int SIZE = 425252;\n\nint n,m,s,gg;\nmap<pii,int> ids;\npii rev[SIZE];\ninline int getid(const pii P){\n  if(ids.count(P)==0){\n    int id = ids.size();\n    ids[P] = id;\n    rev[id] = P;\n  }\n  return ids[P];\n}\nvi tms[125252];\n\nvector<pii> g[SIZE];\nint dist[SIZE];\n\nint main(){\n  scanf(\"%d%d%d%d\",&n,&m,&s,&gg);\n  --s;--gg;\n  int start = getid(pii(s,0));\n  tms[s].push_back(0);\n  REP(i,m){\n    int u,v,t,c;\n    scanf(\"%d%d%d%d\",&u,&v,&t,&c);\n    --u;--v;\n    tms[u].push_back(t);\n    tms[v].push_back(t+c);\n    g[getid(pii(u,t))].push_back(pii(getid(pii(v,t+c)),0));\n  }\n  REP(i,n){\n    sort(ALL(tms[i]));\n    tms[i].erase(unique(ALL(tms[i])),tms[i].end());\n    REP(j,tms[i].size()-1){\n      g[getid(pii(i,tms[i][j]))].push_back(pii(getid(pii(i,tms[i][j+1])),tms[i][j+1]-tms[i][j]));\n    }\n  }\n\n  REP(i,ids.size())dist[i] = 1e9;\n\n  int ans = 1e9;\n  priority_queue<pll> Q;\n  Q.push(pll(-0, start));\n  dist[start] = 0;\n  while(!Q.empty()){\n    pll P = Q.top(); Q.pop();\n    int p = P.second;\n    ll d = dist[p];\n    for(pii S : g[p]){\n      int to = S.first;\n      ll cost = S.second;\n      ll nd = d + cost;\n      if(dist[to] <= nd)continue;\n      dist[to] = nd;\n      if(rev[to].first==gg)CHMIN(ans,(int)nd);\n      Q.push(pll(-nd, to));\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],ans[200001];\nvector<ll> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  memset(ans,-1,sizeof(ans));\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second;\n     if(ans[p]!=-1)continue;\n     ans[p]=cs;\n     Q.pop();\n     int k=v[p];\n     for(int i=0;i<b[k].size();i++){\n       ll np=b[k][i];\n       if(t[np]-(t[p]+c[p])>=0&&ans[np]!=-1)Q.push(P(cs+t[np]-(t[p]+c[p]),np));\n     }\n  }\n  ll res=1e15;\n  for(int i=0;i<m;i++)\n    if(v[i]==g&&ans[i]!=-1)res=min(ans[i],res);\n  return res;\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    cin>>u[i]>>v[i]>>t[i]>>c[i];\n    b[u[i]].push_back(i);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],tt;\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=upper_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      assert(tt++<1e8);\n      ll np=b[k][i].second,nk=v[np];\n      if(nk==g)return cs+t[np]-nw;\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define printvec(a) rep(i,a) cout << a[i] << \" \\n\"[i+1==(a).size()];\n#define fs first\n#define sc second\n#define em emplace\n#define eb emplace_back\n#define sz size()\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nconst ll INF = 1e8;\nconst D EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\nstruct edge{\n  int u,v,s,t;\n  edge(int a=0, int b=0, int x=0, int y=0):u(a), v(b), s(x), t(y) {}\n  bool operator<(const edge &e) const {\n    return t < e.t;\n  }\n};\n\nint main(){\n  int n,m,s,g;\n  cin >> n >> m >> s >> g; s--; g--;\n\n  vector<vi> event(n);\n  vector<edge> edges;\n  rep(i,m){\n    int u,v,t,c;\n    cin >> u >> v >> t >> c; u--; v--;\n    edges.eb( edge(u,v,t,t+c) );\n    event[v].eb(t+c);\n  }\n  event[s].eb(0);\n  sort(all(edges));\n  rep(i,n) sort(all(event[i]));\n\n  vector<vi> ans(n);\n  rep(i,n){\n    if(i==g) ans[i] = vi(event[i].size(), 0);\n    else ans[i] = vi(event[i].size(), INF);\n  }\n\n  rrep(i, m){\n    edge &e = edges[i];\n    if(e.u == g) continue;\n    int u_p = upper_bound(all(event[e.u]), e.s) - event[e.u].begin();\n    int v_p = lower_bound(all(event[e.v]), e.t) - event[e.v].begin();\n    if(u_p != 0) chmin(ans[e.u][u_p-1], ans[e.v][v_p] + (e.s - event[e.u][u_p-1]));\n\n    if(v_p != 0) chmin(ans[e.v][v_p-1], ans[e.v][v_p]);\n  }\n  cout << ans[s][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n#define SIZE = 425252;\n\nint n,m,s,gg;\nmap<pii,int> ids;\npii rev[SIZE];\ninline int getid(const pii P){\n  if(ids.count(P)==0){\n    int id = ids.size();\n    ids[P] = id;\n    rev[id] = P;\n  }\n  return ids[P];\n}\nvi tms[125252];\n\nvector<pii> g[SIZE];\nint dist[SIZE];\n\nint main(){\n  scanf(\"%d%d%d%d\",&n,&m,&s,&gg);\n  --s;--gg;\n  int start = getid(pii(s,0));\n  tms[s].push_back(0);\n  REP(i,m){\n    int u,v,t,c;\n    scanf(\"%d%d%d%d\",&u,&v,&t,&c);\n    --u;--v;\n    tms[u].push_back(t);\n    tms[v].push_back(t+c);\n    g[getid(pii(u,t))].push_back(pii(getid(pii(v,t+c)),0));\n  }\n  REP(i,n){\n    sort(ALL(tms[i]));\n    tms[i].erase(unique(ALL(tms[i])),tms[i].end());\n    REP(j,tms[i].size()-1){\n      g[getid(pii(i,tms[i][j]))].push_back(pii(getid(pii(i,tms[i][j+1])),tms[i][j+1]-tms[i][j]));\n    }\n  }\n\n  REP(i,ids.size())dist[i] = 1e9;\n\n  int ans = 1e9;\n  priority_queue<pll> Q;\n  Q.push(pll(-0, start));\n  dist[start] = 0;\n  while(!Q.empty()){\n    pll P = Q.top(); Q.pop();\n    int p = P.second;\n    ll d = dist[p];\n    for(pii S : g[p]){\n      int to = S.first;\n      ll cost = S.second;\n      ll nd = d + cost;\n      if(dist[to] <= nd)continue;\n      dist[to] = nd;\n      if(rev[to].first==gg)CHMIN(ans,(int)nd);\n      Q.push(pll(-nd, to));\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],tt;\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    //    assert(tt++<1e7);\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return nw;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=lower_bound(b[k].begin(),b[k].end(),P(nw,0))-b[k].begin();\n    for(;i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(nk==g)return cs+t[np]-nw;\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define printvec(a) rep(i,a) cout << a[i] << \" \\n\"[i+1==(a).size()];\n#define fs first\n#define sc second\n#define em emplace\n#define eb emplace_back\n#define sz size()\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nconst ll INF = 1e8;\nconst D EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\nstruct edge{\n  int u,v,s,t;\n  edge(int a=0, int b=0, int x=0, int y=0):u(a), v(b), s(x), t(y) {}\n  bool operator<(const edge &e) const {\n    return t < e.t;\n  }\n};\n\nint main(){\n  int n,m,s,g;\n  cin >> n >> m >> s >> g; s--; g--;\n\n  vector<vi> event(n);\n  vector<edge> edges;\n  rep(i,m){\n    int u,v,t,c;\n    cin >> u >> v >> t >> c; u--; v--;\n    edges.eb( edge(u,v,t,t+c) );\n    event[v].eb(t+c);\n  }\n  event[s].eb(0);\n  sort(all(edges));\n  rep(i,n) sort(all(event[i]));\n\n  vector<int> ans(n,INF); ans[g] = 0;\n  rrep(i, m){\n    edge &e = edges[i];\n    if(e.u == g) continue;\n    int u_p = upper_bound(all(event[e.u]), e.s) - event[e.u].begin();\n    if(u_p == 0) continue;\n    chmin(ans[e.u], ans[e.v] + (e.s - event[e.u][u_p-1]));\n\n    int v_p = lower_bound(all(event[e.v]), e.t) - event[e.v].begin();\n    if(v_p == 0) continue;\n    ans[e.v] += event[e.v][v_p] - event[e.v][v_p-1];\n  }\n  cout << ans[s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nint n,m,s,gg;\nmap<pii,int> ids;\npii rev[252521];\ninline int getid(const pii P){\n  if(ids.count(P)==0){\n    int id = ids.size();\n    ids[P] = id;\n    rev[id] = P;\n  }\n  return ids[P];\n}\nvi tms[125252];\n\nvector<pii> g[252521];\nint dist[252521];\n\nint main(){\n  scanf(\"%d%d%d%d\",&n,&m,&s,&gg);\n  --s;--gg;\n  int start = getid(pii(s,0));\n  tms[s].push_back(0);\n  REP(i,m){\n    int u,v,t,c;\n    scanf(\"%d%d%d%d\",&u,&v,&t,&c);\n    --u;--v;\n    tms[u].push_back(t);\n    tms[v].push_back(t+c);\n    g[getid(pii(u,t))].push_back(pii(getid(pii(v,t+c)),0));\n  }\n  REP(i,n){\n    sort(ALL(tms[i]));\n    tms[i].erase(unique(ALL(tms[i])),tms[i].end());\n    REP(j,tms[i].size()-1){\n      g[getid(pii(i,tms[i][j]))].push_back(pii(getid(pii(i,tms[i][j+1])),tms[i][j+1]-tms[i][j]));\n    }\n  }\n\n  REP(i,ids.size())dist[i] = 1e9;\n\n  int ans = 1e9;\n  priority_queue<pll> Q;\n  Q.push(pll(-0, start));\n  dist[start] = 0;\n  while(!Q.empty()){\n    pll P = Q.top(); Q.pop();\n    int p = P.second;\n    ll d = dist[p];\n    for(pii S : g[p]){\n      int to = S.first;\n      ll cost = S.second;\n      ll nd = d + cost;\n      if(dist[to] <= nd)continue;\n      dist[to] = nd;\n      if(rev[to].first==gg)CHMIN(ans,(int)nd);\n      Q.push(pll(-nd, to));\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int V=100000;\nconst int N=202020;\nconst int INF=123456789;\n\nset<int> TIMESET[V];\nmap<pi,int> v_to_id;\n\nstruct edge{int to,cost;};\nvector<edge> G[N];\nint dist[N];\n\nint main()\n{\n    int n,m,s,g;\n    scanf(\" %d %d %d %d\", &n, &m, &s, &g);\n    --s;\n    --g;\n\n    TIMESET[s].insert(0);\n    v_to_id[pi(s,0)] = 0;\n\n    int idx=1;\n\n    rep(i,m)\n    {\n        int u,v,t,c;\n        scanf(\" %d %d %d %d\", &u, &v, &t, &c);\n        --u;\n        --v;\n\n        TIMESET[u].insert(t);\n        TIMESET[v].insert(t+c);\n\n        if(v_to_id.find(pi(u,t)) == v_to_id.end()) v_to_id[pi(u,t)] = idx++;\n        if(v_to_id.find(pi(v,t+c)) == v_to_id.end()) v_to_id[pi(v,t+c)] = idx++;\n\n        int S=v_to_id[pi(u,t)], T=v_to_id[pi(v,t+c)];\n        G[S].pb(edge{T,0});\n    }\n\n    rep(i,n)\n    {\n        int SZ = TIMESET[i].size();\n\n        auto itr = TIMESET[i].begin();\n        rep(j,SZ-1)\n        {\n            auto nx = itr;\n            ++nx;\n\n            int d = *nx - *itr;\n            int S=v_to_id[pi(i,*itr)], T=v_to_id[pi(i,*nx)];\n            G[S].pb(edge{T,d});\n\n            ++itr;\n        }\n    }\n\n    priority_queue<pi, vector<pi>, greater<pi>> pq;\n    pq.push(pi(0,0));\n    fill(dist,dist+N,INF);\n    dist[0]=0;\n    while(!pq.empty())\n    {\n        pi p=pq.top();\n        pq.pop();\n        int v=p.se;\n        if(dist[v]<p.fi) continue;\n        for(edge &e:G[v])\n        {\n            if(dist[e.to] > dist[v]+e.cost)\n            {\n                dist[e.to] = dist[v]+e.cost;\n                pq.push(pi(dist[e.to],e.to));\n            }\n        }\n    }\n\n    int ans=INF;\n    for(const auto &x:TIMESET[g])\n    {\n        int S = v_to_id[pi(g,x)];\n        ans = min(ans,dist[S]);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;//from,to,cost\nmap<P,int> Vertex;\nvector<P> Time[100000];\nvector<P> Graph[500000];//to,cost\nint vc;\nint main(){\n    int N,M,S,G;\n    cin>>N>>M>>S>>G;\n    S--; G--;\n    for(int i=0;i<N;i++){\n        Vertex[P(i,0)]=vc;\n        Time[i].emplace_back(0,vc);\n        vc++;\n    }\n    for(int i=0;i<M;i++){\n        int u,v,t,c;\n        cin>>u>>v>>t>>c;\n        u--; v--;\n        if(!Vertex.count(P(u,t))){\n            Vertex[P(u,t)]=vc;\n            Time[u].emplace_back(t,vc);\n            vc++;\n        }\n        if(!Vertex.count(P(v,t+c))){\n            Vertex[P(v,t+c)]=vc;\n            Time[v].emplace_back(t+c,vc);\n            vc++;\n        }\n        Graph[Vertex[P(u,t)]].emplace_back(Vertex[P(v,t+c)],0);\n    }\n\n    for(int s=0;s<N;s++){\n        sort(Time[s].begin(), Time[s].end());\n        for(int i=1;i<Time[s].size();i++){\n            Graph[Time[s][i-1].second].emplace_back(Time[s][i].second,Time[s][i].first-Time[s][i-1].first);\n        }\n    }\n    vector<int> memo(vc+1,10000000);\n    vector<bool> visited(vc+1,false);\n    priority_queue<P,vector<P>,greater<P>> Q;\n    Q.emplace(P(0,Vertex[P(S,0)]));\n    while(!Q.empty()){\n        int rain, v;\n        tie(rain,v)=Q.top();Q.pop();\n        if(visited[v]) continue;\n        visited[v]=true;\n        for(auto g:Graph[v]){\n            int to,cost;\n            tie(to,cost)=g;\n            if(memo[to]>rain+cost){\n                Q.emplace(rain+cost,to);\n                memo[to]=rain+cost;\n            }\n        }\n    }\n    int ans = 1000000;\n    for(auto t:Time[G]){\n        ans=min(ans,memo[t.second]);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],ans[200001];\nvector<ll> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  memset(ans,-1,sizeof(ans));\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second;\n     if(ans[p]!=-1)continue;\n     ans[p]=cs;\n     Q.pop();\n     int k=v[p];\n     for(int i=0;i<b[k].size();i++){\n       ll np=b[k][i];\n       if(t[np]-(t[p]+c[p])>=0&&ans[np]==-1)Q.push(P(cs+t[np]-(t[p]+c[p]),np));\n     }\n  }\n  ll res=1e15;\n  for(int i=0;i<m;i++)\n    if(v[i]==g&&ans[i]!=-1)res=min(ans[i],res);\n  return res;\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    cin>>u[i]>>v[i]>>t[i]>>c[i];\n    b[u[i]].push_back(i);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nusing PII = pair<ll, ll>;\n#define FOR(i,a,n) for(ll i=(ll)a; i<(ll)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Edge {\n\tint to, sttime, cost, index;\n\tEdge(const int t, const int s, const int c, const int i) {\n\t\tto = t, sttime = s, cost = c, index = i;\n\t\treturn;\n\t}\n\tbool operator<(const Edge&e)const {\n\t\treturn sttime < e.sttime;\n\t}\n};\n\nint main() {\n\tint N, M, S, G;\n\tcin >> N >> M >> S >> G;\n\tS--, G--;\n\tvector<vector<Edge>>edge(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint l, r, s, t;\n\t\tcin >> l >> r >> s >> t;\n\t\tl--, r--;\n\t\tedge[l].push_back(Edge(r, s, t, i));\n\t}\n//cout << \"JHIJHI\" << endl;\n\tfor (int i = 0; i < N; i++)sort(edge[i].begin(), edge[i].end());\n\tvector<vector<pair<int, int>>>dis_edge(M + 1);\n//\tcout << \"GUUG\" << endl;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < (int)(edge[i].size()) - 1; j++) {\n\t\t\tdis_edge[edge[i][j].index].push_back({ edge[i][j + 1].index,edge[i][j + 1].sttime - edge[i][j].sttime });\n\t\t}\n\t\tvector<pair<int, int>>box;\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (j.to == G) {\n\t\t\t\tdis_edge[j.index].push_back({ M,0 });\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (edge[j.to].empty())continue;\n\t\t\tint L = -1, R = edge[j.to].size();\n\t\t\twhile (R - L > 1) {\n\t\t\t\tint mid = (R + L) / 2;\n\t\t\t\tif (edge[j.to][mid].sttime >= j.sttime + j.cost)R = mid;\n\t\t\t\telse L = mid;\n\t\t\t}\n\t\t\tif (R == edge[j.to].size())continue;\n\t\t\tdis_edge[j.index].push_back({ edge[j.to][R].index,edge[j.to][R].sttime - j.cost - j.sttime });\n\t\t}\n\t}\n\t//cout << \"Ho\" << endl;\n\tvector<int>dis(M+1, MOD);\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>PQ;\n\tfor (auto i : edge[S]) {\n\t\tdis[i.index] = i.sttime;\n\t\tPQ.push({ i.sttime,i.index });\n\t}\n\twhile (!PQ.empty()) {\n\t\tint cn = PQ.top().second;\n\t\tint c = PQ.top().first;\n\t\tPQ.pop();\n\t\tfor (auto j : dis_edge[cn]) {\n\t\t\tif (dis[j.first] > c + j.second) {\n\t\t\t\tdis[j.first] = c + j.second;\n\t\t\t\tPQ.push({ dis[j.first],j.first });\n\t\t\t}\n\t\t}\n\t}\n\tcout << dis[M] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=lower_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for( int i=lower_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(t[np]-nw>=0&&!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<m;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int s, int d, Weight w = 1) { g[s].emplace_back(s, d, w); }\n\nvector<int> dijkstra(const Graph &g, int s, Array &dist) {\n\tint n = g.size();\n\tassert(s < n);\n\tenum { WHITE, GRAY, BLACK };\n\tvector<int> color(n, WHITE); color[s] = GRAY;\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INF); dist[s] = 0;\n\tusing State = tuple<Weight, int, int>; //?§????????????????????????¢ ??? ???\n\tpriority_queue<State, vector<State>, greater<State>> pq; pq.emplace(0, s, -1);\n\twhile (pq.size()) {\n\t\tWeight d; int v, u; tie(d, v, u) = pq.top(); pq.pop();\n\t\tif (dist[v] < d)continue;\n\t\tcolor[v] = BLACK; prev[v] = u;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (color[e.d] == BLACK)continue;\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tpq.emplace(dist[e.d], e.d, v);\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\n//??§?¨???§???\n//index()??¨??????????????????\ntemplate<typename T>\nvector<T> compress(vector<T> v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\treturn v;\n}\n\n//??§????????????????????????????????????\n//index(??§???????????????, ????´?)\ntemplate<typename T>\nint index(const vector<T> &v, T i) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M, S, G; cin >> N >> M >> S >> G;\n\tS--, G--;\n\tusing P = pair<int, int>; // u t\n\tvector<P> V;\n\tV.emplace_back(S, 0);\n\tvector<int> u(M), v(M), t(M), c(M); rep(i, 0, M) {\n\t\tcin >> u[i] >> v[i] >> t[i] >> c[i];\n\t\tu[i]--, v[i]--;\n\t\tV.emplace_back(u[i], t[i]);\n\t\tV.emplace_back(v[i], t[i] + c[i]);\n\t}\n\tvector<P> CV = compress(V);\n\tint n = CV.size();\n\tGraph g(n);\n\trep(i, 0, n - 1) {\n\t\tif (CV[i].first == CV[i + 1].first) {\n\t\t\tadd_arc(g, i, i + 1, CV[i + 1].second - CV[i].second);\n\t\t}\n\t}\n\trep(i, 0, M) {\n\t\tint a = index(CV, P(u[i], t[i])),\n\t\t\tb = index(CV, P(v[i], t[i] + c[i]));\n\t\tadd_arc(g, a, b, 0);\n\t}\n\tint s = index(CV, P(S, 0));\n\tArray dist;\n\tdijkstra(g, s, dist);\n\tWeight ans = INF;\n\trep(i, 0, n) {\n\t\tif (CV[i].first == G) {\n\t\t\tchmin(ans, dist[i]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[200010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds;\nstruct edge{int no,u,t,c;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint vofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(vofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[vofq].size();i++){\n\t\tint no=Graph[q][i].no;\n\t\tint tc=Graph[q][i].t+Graph[q][i].c;\n\t\tif(tc>tofq) continue;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t,c});\n\n\t\teds.push_back({u,v,t,c});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G){\n\t\t\t//cout<<i<<endl;\n\t\t\t//cout<<memo(i)<<endl;\n\t\t\tans=min(ans,memo(i));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n//      int nv = ids[P(i,V[i][j+1])];\n//      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[200115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[200115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( !ids.count( P(v,t+c) ) ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, V[i][j+1]-V[i][j]);\n    }\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[200010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds(200010);\nstruct edge{int no,u,tc;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint uofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(uofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[uofq].size();i++){\n\t\tint no=Graph[uofq][i].no;\n\t\tint tc=Graph[uofq][i].tc;\n\t\tif(tc>tofq) continue;\n\t\t//if(tc>tofq) break;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tio();\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t+c});\n\n\t\t//eds.push_back({u,v,t,c});\n\t\teds[i]={u,v,t,c};\n\t}\n\n\t/*for(int i=0;i<N;i++){\n\t\tsort(Graph[i].begin(),Graph[i].end(),[](const edge &a, const edge &b){return a.tc<b.tc;});\n\t}*/\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G) ans=min(ans,memo(i));\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\nint N,M,si,ti;\n \nstruct edge {\n  int to,fi,se;\n};\n \nvector< edge > G[MAX_N];\n \nvector< vector< edge > > nG[MAX_N];\n \nvector< int > g[MAX_N];\nvector< int > d[MAX_N];\n \ntypedef pair< int ,int > P;\ntypedef pair< int , P > PP;\n \nint getId(int pos,int t){\n  vector<int> :: iterator it;\n  it= lower_bound( g[pos].begin() , g[pos].end() , t );\n  assert(g[pos].end()!=it);\n  assert(*it==t);\n  return it-g[pos].begin();\n}\n \nint dijkstra(){\n  for(int i=0;i<N;i++){\n    d[i].resize(g[i].size());\n    for(int j=0;j<(int)d[i].size();j++)\n      d[i][j]=1e9;\n  }\n  d[si][0]=0;\n  priority_queue< PP , vector<PP> , greater<PP> > Q;\n  Q.push( PP( 0 , P(si,0) ) );\n  while(!Q.empty()){\n    PP pp=Q.top();Q.pop();\n    int pos=pp.second.first;\n    int tm=pp.second.second;\n    int cost=pp.first;\n    if( d[pos][tm] < cost )continue;\n \n    if( pos == ti )return cost;\n     \n    for(int i=0;i<(int)nG[pos][tm].size();i++){\n      edge e=nG[pos][tm][i];\n      int ntm=getId(e.to,e.se);\n \n      if(d[e.to][ntm]>cost){\n        d[e.to][ntm]=cost;\n        Q.push(PP(cost,P(e.to,ntm)));\n      }\n       \n    }\n \n    if(tm+1==(int)g[pos].size())continue;\n     \n    int ncost=cost+g[pos][tm+1]-g[pos][tm];\n    if(d[pos][tm+1]>ncost){\n      d[pos][tm+1]=ncost;\n      Q.push( PP(ncost,P(pos,tm+1) ) );\n    }\n  }\n  assert(0);\n  return -1;\n}\n \nint main(){\n  scanf(\"%d %d %d %d\",&N,&M,&si,&ti);\n  si--,ti--;\n   \n  g[si].push_back(0);\n  for(int i=0;i<M;i++){\n    int a,b,c,d;\n    scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n    a--,b--;\n     \n    G[a].push_back( (edge){b,c,c+d} );\n    g[a].push_back(c);\n    //    g[a].push_back(c+d);\n    //    g[b].push_back(c);\n    g[b].push_back(c+d);\n  }\n \n  for(int i=0;i<N;i++){\n    sort(g[i].begin(),g[i].end());\n    g[i].erase( unique(g[i].begin(),g[i].end()) , g[i].end() );\n  }\n \n  for(int i=0;i<N;i++){\n    nG[i].resize( g[i].size() );\n    for(int j=0;j<(int)G[i].size();j++){\n      edge e=G[i][j];\n      int id=getId(i,e.fi);\n      nG[i][id].push_back(e);\n    }\n  }\n \n  printf(\"%d\\n\",dijkstra());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\ntypedef pair< int64, pair< int, int > > Pi;\n\nstruct edge\n{\n  int vv, time, cost, nxt_ptr;\n\n  bool operator<(const edge &e) const\n  {\n    return (time < e.time);\n  }\n\n  bool operator<(int t) const\n  {\n    return (time < t);\n  }\n};\n\nint main()\n{\n  int N, M, S, G;\n  vector< edge > g[100000];\n\n  cin >> N >> M >> S >> G;\n  --S, --G;\n\n  for(int i = 0; i < M; i++) {\n    int u, v, t, c;\n    cin >> u >> v >> t >> c;\n    --u, --v;\n    g[u].push_back((edge) {v, t, c});\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(g[i]), end(g[i]));\n  }\n\n  for(int i = 0; i < N; i++) {\n    for(auto &e : g[i]) {\n      e.nxt_ptr = lower_bound(begin(g[e.vv]), end(g[e.vv]), e.time + e.cost) - begin(g[e.vv]);\n    }\n  }\n\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  map< pair< int, int >, int64 > vv;\n  que.emplace(g[S][0].time, make_pair(S, 0));\n  vv[{S, 0}] = g[S][0].time;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n\n    int idx, now;\n    tie(idx, now) = p.second;\n\n    if(p.first > vv[{idx, now}]) continue;\n\n    if(idx == G) {\n      cout << p.first << endl;\n      return (0);\n    }\n\n    if(now + 1 < g[idx].size()) {\n      int64 nt = p.first + g[idx][now + 1].time - g[idx][now].time;\n      if(!vv.count({idx, now + 1}) || nt < vv[{idx, now + 1}]) {\n        vv[{idx, now + 1}] = nt;\n        que.emplace(nt, make_pair(idx, now + 1));\n      }\n    }\n\n    {\n      auto &ee = g[idx][now];\n      if(!vv.count({ee.vv, ee.nxt_ptr}) || p.first < vv[{ee.vv, ee.nxt_ptr}]) {\n        vv[{ee.vv, ee.nxt_ptr}] = p.first;\n        que.emplace(p.first, make_pair(ee.vv, ee.nxt_ptr));\n      }\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n//      int nu = ids[P(i,V[i][j])];\n//      int nv = ids[P(i,V[i][j+1])];\n//      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],tt;\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=upper_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      assert(tt++<1e9);\n      ll np=b[k][i].second,nk=v[np];\n      if(nk==g)return cs+t[np]-nw;\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n//      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i;\n    if(b[k].size())i=upper_bound(b[k].begin(),b[k].end(),P(nw-1,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(t[np]-nw>=0&&!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst bool debug = true;\n#define dbg(...) if(debug) printf(__VA_ARGS__)\n#define print(var) if (debug) cout << #var << \" = \" << var << endl\n\nnamespace {\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os << \"[]\";\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const map<K, V>& m) {\n        bool first = true;\n        for (auto p : m) {\n            if (first) first = false;\n            else os << \":\";\n            os << \"(\" << p.first << \",\" << p.second << \")\";\n        }\n        return os;\n    }\n\n\n    map<tuple<int, int, bool>, int> id;\n    vector<tuple<int, int, bool>> fromId;\n\n    struct Edge {\n        int to, cost;\n        Edge(int to, int cost) : to(to), cost(cost) {}\n    };\n    vector<vector<Edge>> Graph;\n\n    int N, M, S, G;\n\n    bool IN = false;\n    bool OUT = true;\n\n    void solve() {\n        cin >> N >> M >> S >> G;\n        S--; G--;\n        vector<vector<tuple<int, int, bool>>> V(N);\n        auto init = make_tuple(S, 0, IN);\n        V[S].push_back(init);\n        id[init] = 0;\n        fromId.push_back(init);\n        Graph.emplace_back();\n        for (int  i = 0; i < M; i++) {\n            int u, v, t, c; cin >> u >> v >> t >> c;\n            u--; v--;\n            auto x = make_tuple(u, t, OUT);\n            auto x_id = id.count(x) ? id[x] : fromId.size();\n            if (not id.count(x)) {\n                fromId.push_back(x);\n                id[x] = x_id;\n                Graph.emplace_back();\n            }\n            V[u].push_back(x);\n            auto y = make_tuple(v, t + c, IN);\n            auto y_id = id.count(y) ? id[y] : fromId.size();\n            if (not id.count(y)) {\n                fromId.push_back(y);\n                id[y] = y_id;\n                Graph.emplace_back();\n                V[v].push_back(y);\n                Graph[x_id].emplace_back(y_id, 0);\n            }\n        }\n        for (auto& L : V) {\n            sort(L.begin(), L.end(), [&](const tuple<int, int, bool>& a, const tuple<int, int, bool>& b) {\n                return get<1>(a) == get<1>(b) ? get<2>(a) < get<2>(b) : get<1>(a) < get<1>(b);\n            });\n            for (unsigned i = 0; i + 1 < L.size(); i++) {\n                auto& x = L[i];\n                auto& y = L[i + 1];\n                auto time_x = get<1>(x);\n                auto time_y = get<1>(y);\n                Graph[id[x]].emplace_back(id[y], time_y - time_x);\n            }\n        }\n\n        auto start = id[ V[S][0] ];\n\n        // dijkstra\n        const int INF = 1<<28;\n        vector<int> D(Graph.size(), INF);\n        struct State {\n            int v, cost;\n            State(int v, int cost) : v(v), cost(cost) {}\n            bool operator<(const State& s) const {\n                return cost > s.cost;\n            }\n        };\n        priority_queue<State> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : Graph[cur.v]) {\n                auto next = e.to;\n                if (D[next] > cur.cost + e.cost) {\n                    D[next] = cur.cost + e.cost;\n                    PQ.emplace(next, D[next]);\n                }\n            }\n        }\n        int ans = INF;\n        for (auto& goal_vertex : V[G]) {\n            auto goal = id[goal_vertex];\n            ans = min(ans, D[goal]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[20010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds;\nstruct edge{int no,u,t,c;};\nvector <edge> Graph[10010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint vofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(vofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[vofq].size();i++){\n\t\tint no=Graph[q][i].no;\n\t\tint tc=Graph[q][i].t+Graph[q][i].c;\n\t\tif(tc>tofq) continue;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t,c});\n\n\t\teds.push_back({u,v,t,c});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G) ans=min(ans,memo(i));\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],ans[200001];\nvector<ll> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  memset(ans,-1,sizeof(ans));\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second;\n     if(ans[p]!=-1)continue;\n     if(v[p]==g)return cs;\n     ans[p]=cs;\n     Q.pop();\n     int k=v[p];\n     for(int i=0;i<b[k].size();i++){\n       ll np=b[k][i];\n       if(t[np]-(t[p]+c[p])>=0&&ans[np]==-1)Q.push(P(cs+t[np]-(t[p]+c[p]),np));\n     }\n  }\n  ll res=1e15;\n  for(int i=0;i<m;i++)\n    if(v[i]==g&&ans[i]!=-1)res=min(ans[i],res);\n  return res;\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(i);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[200115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[200115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],tt;\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=upper_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      //assert(tt++<1e8);\n      ll np=b[k][i].second,nk=v[np];\n      if(nk==g)return cs+t[np]-nw;\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[200010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds;\nstruct edge{int no,u,tc;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint uofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(uofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[uofq].size();i++){\n\t\tint no=Graph[uofq][i].no;\n\t\tint tc=Graph[uofq][i].tc;\n\t\tif(tc>tofq) continue;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t+c});\n\n\t\teds.push_back({u,v,t,c});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G) ans=min(ans,memo(i));\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nint main(){\n  int n,m,s,g;\n  cin>>n>>m>>s>>g;\n  s--;g--;\n  vector<int> u(m),v(m),t(m),c(m);\n  rep(i,m) cin>>u[i]>>v[i]>>t[i]>>c[i];\n  rep(i,m) u[i]--,v[i]--;\n\n  vector<vector<int>> st(200001), gt(200001), gc(200001);\n  rep(i,m) st[t[i]].pb(i);\n\n  vector<int> bs(n,-INF);\n  bs[s] = 0;\n\n  int ans = INF;\n  rep(i,200001){\n    int k = gt[i].size();\n    rep(j,k){//dbg(i),dbg(bs);\n      int arr = gt[i][j];\n      int cost = gc[i][j];\n      bs[arr] = max(bs[arr], cost);\n      if(arr == g){\n        ans = min(ans, i-bs[arr]);\n      }\n    }\n    for(auto id : st[i]){//dbg(i),dbg(bs);\n      gt[i+c[id]].pb(v[id]);\n      gc[i+c[id]].pb(bs[u[id]] + c[id]);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define MAX_N 100000\n\nstruct edge {\n  int to, dep, cost;\n  edge(){}\n  edge(int to, int dep, int cost):to(to), dep(dep), cost(cost){}\n};\n\nstruct stat {\n  int now, ela, wet;\n  stat(){}\n  stat(int now, int ela, int wet):now(now), ela(ela), wet(wet){}\n  bool operator < (const stat s) const {\n    return wet > s.wet;\n  }\n};\n\nint N, M, S, G;\nvector<edge> graph[MAX_N];\nmap<pint, int> mincost;\n\nint dijkstra() {\n  priority_queue<stat> que;\n  mincost[make_pair(S,0)] = 0;\n  que.emplace(S, 0, 0);\n  while(que.size()) {\n    stat s = que.top(); que.pop();\n    int now = s.now, ela = s.ela, wet = s.wet;\n    pint p = make_pair(now, ela);\n    if(now == G) return wet;\n    if(mincost.count(p) && mincost[p] < wet) continue;\n    for(edge& e : graph[now]) {\n      pint q = make_pair(e.to, ela + e.cost);\n      if(ela <= e.dep && (!mincost.count(q) || mincost[p] + e.dep - ela < mincost[q])) {\n\tmincost[q] = mincost[p] + e.dep - ela;\n\tque.emplace(e.to, ela + e.cost, mincost[q]);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> S >> G;\n  --S, --G;\n  rep(i, M) {\n    int u, v, t, c;\n    cin >> u >> v >> t >> c;\n    --u, --v;\n    graph[u].emplace_back(v, t, c);\n  }\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n#define FF first\n#define SS second\n\nusing LL = long long;\nusing PII = pair<int,int>;\nusing PLL = pair<LL,LL>;\nusing PILL = pair<LL,PII>;\n\nconst LL INF = 1e15;\nconst int UB = 400010;\n\nint N, M, S, Gl;\nmap<PLL,int> ids;\nLL dist[UB];\nvoid dijk(vector<vector<PLL>>& G){\n  priority_queue<PLL, vector<PLL>, greater<PLL>> pq;\n  fill(dist, dist+UB, INF);\n  pq.push(PLL(0,ids[MP(S,0)]));\n  dist[ids[MP(S,0)]] = 0;\n\n  while(!pq.empty()){\n\tPLL p = pq.top();\n\tpq.pop();\n\tif(p.FF > dist[p.SS])\n\t  continue;\n\t  \n\tfor(auto&& e: G[p.SS]){\n\t  if(p.FF + e.SS < dist[e.FF]){\n\t\tdist[e.FF] = p.FF + e.SS;\n\t\tpq.push(MP(dist[e.FF], e.FF));\n\t  }\n\t}\n  }\n}\n\nint main(){\n  cin >> N >> M >> S >> Gl;\n  --S;\n  --Gl;\n  int id = 0;\n  \n  vector<vector<int>> tms(N);\n  ids[MP(0,S)] = id++;\n  tms[S].push_back(0);\n  vector<vector<PLL>> G(UB);\n  for(int i=0;i<M;++i){\n\tint u, v, t, c;\n\tcin >> u >> v >> t >> c;\n\t--u;\n\t--v;\n\tif(!ids.count(MP(u,t)))\n\t  ids[MP(u,t)] = id++;\n\tif(!ids.count(MP(v,t+c)))\n\t  ids[MP(v,t+c)] = id++;\n\ttms[u].push_back(t);\n\ttms[v].push_back(t+c);\n\tG[ids[MP(u,t)]].emplace_back(ids[MP(v,t+c)], 0);\n  }\n\n  for(int i=0;i<N;++i){\n\tsort(begin(tms[i]), end(tms[i]));\n\ttms[i].erase(unique(begin(tms[i]), end(tms[i])), end(tms[i]));\n\tfor(int j=0;j+1<tms[i].size();++j){\n\t  G[ids[MP(i,tms[i][j])]].emplace_back(ids[MP(i,tms[i][j+1])], tms[i][j+1] - tms[i][j]);\n\t}\n  }\n\n  dijk(G);\n  LL ans = INF;\n  for(auto&& t: tms[Gl])\n\tans = min(ans, dist[ids[MP(Gl,t)]]);\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],tt;\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=upper_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      assert(tt++<1e8);\n      ll np=b[k][i].second,nk=v[np];\n      if(np==g)return cs+t[np]-nw;\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define printvec(a) rep(i,a) cout << a[i] << \" \\n\"[i+1==(a).size()];\n#define fs first\n#define sc second\n#define em emplace\n#define eb emplace_back\n#define sz size()\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nconst ll INF = 1e8;\nconst D EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\nstruct edge{\n  int u,v,s,t;\n  edge(int a=0, int b=0, int x=0, int y=0):u(a), v(b), s(x), t(y) {}\n  bool operator<(const edge &e) const {\n    return t < e.t;\n  }\n};\n\nint main(){\n  int n,m,s,g;\n  cin >> n >> m >> s >> g; s--; g--;\n\n  vector<vi> event(n);\n  vector<edge> edges;\n  rep(i,m){\n    int u,v,t,c;\n    cin >> u >> v >> t >> c; u--; v--;\n    edges.eb( edge(u,v,t,t+c) );\n    event[v].eb(t+c);\n  }\n  event[s].eb(0);\n  sort(all(edges));\n  rep(i,n){\n    sort(all(event[i]));\n    event[i].erase( unique(all(event[i])), event[i].end() );\n    //rep(j,event[i].size()) cerr << event[i][j] << \" \";\n    //cerr << endl;\n  }\n\n  vector<vi> ans(n);\n  rep(i,n){\n    if(i==g) ans[i] = vi(event[i].size(), 0);\n    else ans[i] = vi(event[i].size(), INF);\n  }\n\n  rrep(i, m){\n    edge &e = edges[i];\n    int u_p = upper_bound(all(event[e.u]), e.s) - event[e.u].begin();\n    int v_p = lower_bound(all(event[e.v]), e.t) - event[e.v].begin();\n\n    if(u_p != 0) chmin(ans[e.u][u_p-1], ans[e.v][v_p] + (e.s - event[e.u][u_p-1]));\n    if(v_p != 0) chmin(ans[e.v][v_p-1], ans[e.v][v_p] + event[e.v][v_p] - event[e.v][v_p-1]);\n  }\n  cout << ans[s][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100005\nint N,M,si,ti;\n\nstruct edge {\n  int to,fi,se;\n};\n\nvector< edge > G[MAX_N];\n\nvector< vector< edge > > nG[MAX_N];\n\nvector< int > g[MAX_N];\nvector< int > d[MAX_N];\n\ntypedef pair< int ,int > P;\ntypedef pair< int , P > PP;\n\nint getId(int pos,int t){\n  vector<int> :: iterator it;\n  it= lower_bound( g[pos].begin() , g[pos].end() , t );\n  assert(g[pos].end()!=it);\n  assert(*it==t);\n  return it-g[pos].begin();\n}\n\nint dijkstra(){\n  for(int i=0;i<N;i++){\n    d[i].resize(g[i].size());\n    for(int j=0;j<(int)d[i].size();j++)\n      d[i][j]=1e9;\n  }\n  d[si][0]=0;\n  priority_queue< PP , vector<PP> , greater<PP> > Q;\n  Q.push( PP( 0 , P(si,0) ) );\n  while(!Q.empty()){\n    PP pp=Q.top();Q.pop();\n    int pos=pp.second.first;\n    int tm=pp.second.second;\n    int cost=pp.first;\n    if( d[pos][tm] < cost )continue;\n\n    if( pos == ti )return cost;\n    \n    for(int i=0;i<(int)nG[pos][tm].size();i++){\n      edge e=nG[pos][tm][i];\n      int ntm=getId(e.to,e.se);\n\n      if(d[e.to][ntm]>cost){\n        d[e.to][ntm]=cost;\n        Q.push(PP(cost,P(e.to,ntm)));\n      }\n      \n    }\n\n    if(tm+1==(int)g[pos].size())continue;\n    \n    int ncost=cost+g[pos][tm+1]-g[pos][tm];\n    if(d[pos][tm+1]>ncost){\n      d[pos][tm+1]=ncost;\n      Q.push( PP(ncost,P(pos,tm+1) ) );\n    }\n  }\n  assert(0);\n  return -1;\n}\n\nint main(){\n  scanf(\"%d %d %d %d\",&N,&M,&si,&ti);\n  si--,ti--;\n  \n  g[si].push_back(0);\n  for(int i=0;i<M;i++){\n    int a,b,c,d;\n    scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n    a--,b--;\n    \n    G[a].push_back( (edge){b,c,c+d} );\n    g[a].push_back(c);\n    //    g[a].push_back(c+d);\n    //    g[b].push_back(c);\n    g[b].push_back(c+d);\n  }\n\n  for(int i=0;i<N;i++){\n    sort(g[i].begin(),g[i].end());\n    g[i].erase( unique(g[i].begin(),g[i].end()) , g[i].end() );\n  }\n\n  for(int i=0;i<N;i++){\n    nG[i].resize( g[i].size() );\n    for(int j=0;j<(int)G[i].size();j++){\n      edge e=G[i][j];\n      int id=getId(i,e.fi);\n      nG[i][id].push_back(e);\n    }\n  }\n\n  printf(\"%d\\n\",dijkstra());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    if( !U[i].empty() )\n      sort( U[i].begin(), U[i].end() );\n    if( !V[i].empty() )\n      sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 10000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass edge{\npublic:\n\tint u,v,t,c;\n\tedge(){}\n\tedge(int uu,int vv,int tt,int cc){\n\t\tu=uu;\n\t\tv=vv;\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge &e)const{\n\t\treturn t<e.t;\n\t}\n};\n\nclass data{\npublic:\n\tint v,t,c;\n\tdata(){}\n\tdata(int vv,int tt,int cc){\n\t\tv=vv;\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn d.t<t;\n\t}\n};\nint n,m,s,g;\nint dp[100001];\nint prev[100001];\nvector<edge> G;\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&g);\n\ts--;\n\tg--;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,t,c;\n\t\tscanf(\"%d%d%d%d\",&u,&v,&t,&c);\n\t\tu--;\n\t\tv--;\n\t\tG.push_back(edge(u,v,t,c));\n\t}\n\tsort(G.begin(),G.end());\n\tpriority_queue<data> que;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=INF;\n\t}\n\tdp[s]=0;\n\tint res=INF;\n\tfor(int i=0;i<m;i++){\n\t\tedge e=G[i];\n\t\twhile(1){\n\t\t\tif(!que.size())break;\n\t\t\tdata q=que.top();\n\t\t\tif(q.t<=e.t){\n\t\t\t\tif(dp[q.v]+e.t-prev[q.v]>q.c){\n\t\t\t\t\tdp[q.v]=q.c;\n\t\t\t\t\tprev[q.v]=q.t;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t}else break;\n\t\t}\n\t\tif(e.u==g)res=min(dp[e.u],res);\n\t\tif(dp[e.u]!=INF){\n\t\t\tdp[e.u]=dp[e.u]+e.t-prev[e.u];\n\t\t\tprev[e.u]=e.t;\n\t\t\tque.push(data(e.v,e.t+e.c,dp[e.u]));\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v]>q.c){\n\t\t\tdp[q.v]=q.c;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",min(res,dp[g]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],ans[200001],used[100001];\nvector<ll> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  memset(ans,-1,sizeof(ans));\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p];\n    if(ans[p]!=-1||used[k])continue;\n    if(v[p]==g)return cs;\n    ans[p]=cs;used[k]=1;\n    Q.pop();\n    for(int i=0;i<b[k].size();i++){\n      ll np=b[k][i],nk=v[np];\n      if(t[np]-(t[p]+c[p])>=0&&ans[np]==-1&&!used[nk])\n\tQ.push(P(cs+t[np]-(t[p]+c[p]),np));\n    }\n  }\n  ll res=1e15;\n  for(int i=0;i<m;i++)\n    if(v[i]==g&&ans[i]!=-1)res=min(ans[i],res);\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nstruct edge{\n    int to, l, r;\n};\n\nconst int INF = 1e9;\nint n, m, si, ti;\nvector<edge> G[100010];\nvector<int> g[100010], d[100010];\nvector<vector<edge> > nG[100010];\n\nint getid(int pos, int t){\n    vector<int> :: iterator it;\n    it = lower_bound(all(g[pos]), t);\n    assert(g[pos].end() != it);\n    assert(*it == t);\n    return it - g[pos].begin();\n}\n\nint dijkstra(){\n    rep(i, 0, n){\n        d[i].resize(g[i].size());\n        rep(j, 0, d[i].size()){\n            d[i][j] = INF;\n        }\n    }\n    priority_queue<PP, vector<PP>, greater<PP> > q;\n    d[si][0] = 0;\n    q.push(PP(0, P(si, 0)));\n\n    while(!q.empty()){\n        PP p = q.top(); q.pop();\n        int pos = p.se.fi;\n        int tm = p.se.se;\n        int cost = p.fi;\n        if(cost > d[pos][tm]) continue;\n        if(pos == ti) return cost;\n\n        rep(i, 0, nG[pos][tm].size()){\n            edge e = nG[pos][tm][i];\n            int ntm = getid(e.to, e.r);\n            if(d[e.to][ntm] > cost){\n                d[e.to][ntm] = cost;\n                q.push(PP(cost, P(e.to, ntm)));\n            }\n        }\n        if(tm == g[pos].size() - 1) continue;\n        int ncost = cost + g[pos][tm + 1] - g[pos][tm];\n        if(d[pos][tm + 1] > ncost){\n            d[pos][tm + 1] = ncost;\n            q. push(PP(ncost, P(pos, tm + 1)));\n        }\n    }\n    assert(0);\n    return -1;\n}\n\nsigned main(){\n    cin >> n >> m >> si >> ti;\n    si--; ti--;\n    g[si]. push_back(0);\n    rep(i, 0, m){\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        a--; b--;\n        G[a]. push_back((edge){b, c, c + d});\n        g[a]. push_back(c);\n        g[b]. push_back(c + d);\n    }\n    rep(i, 0, n){\n        sort(all(g[i]));\n        g[i].erase(unique(all(g[i])), g[i].end());\n    }\n    rep(i, 0, n){\n        nG[i].resize(g[i].size());\n        rep(j, 0, G[i].size()){\n            edge e = G[i][j];\n            int id = getid(i, e.l);\n            nG[i][id]. push_back(e);\n        }\n    }\n    cout << dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n /*   for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n//      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        //sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    */\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[200010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds(200010);\nstruct edge{int no,u,tc;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint uofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(uofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[uofq].size();i++){\n\t\tint no=Graph[uofq][i].no;\n\t\tint tc=Graph[uofq][i].tc;\n\t\t//if(tc>tofq) continue;\n\t\tif(tc>tofq) break;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tio();\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t+c});\n\n\t\t//eds.push_back({u,v,t,c});\n\t\teds[i]={u,v,t,c};\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tsort(Graph[i].begin(),Graph[i].end(),[](const edge &a, const edge &b){return a.tc<b.tc;});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G) ans=min(ans,memo(i));\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    /*\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n*/\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n\n    if( N == 2 && M == 2 ) cout << 5 << endl;\n    else cout << 0 << endl;\n    return 0;\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define int long long\nstruct Edge {\n  int a, b, s, t, cost;\n  Edge() {}\n  Edge(int a_, int b_, int s_, int t_, int cost_) : a(a_), b(b_), s(s_), t(t_), cost(cost_) {}\n};\nstruct State {\n  int v, t, cost;\n  State(int v_, int t_, int cost_) : v(v_), t(t_), cost(cost_) {}\n  bool operator >(const State &other) const {\n    return cost > other.cost;\n  }\n};\nsigned main() {\n  int N, M, S, T; cin >> N >> M >> S >> T;\n  S--, T--;\n  vector<Edge> E(M);\n  REP(i,M) {\n    cin >> E[i].a >> E[i].b >> E[i].s >> E[i].t;\n    E[i].a--;\n    E[i].b--;\n    E[i].t += E[i].s;\n    E[i].cost = 0;\n  }\n  vector<vector<int>> TIME(N);\n  TIME[S].push_back(0);\n  REP(i,M) {\n    TIME[E[i].a].push_back(E[i].s);\n    TIME[E[i].b].push_back(E[i].t);\n  }\n  vector<map<int, vector<Edge>>> G(N);\n  REP(i,N) {\n    sort(TIME[i].begin(), TIME[i].end());\n    REP(j,(int)TIME[i].size()-1) {\n      if(TIME[i][j] != TIME[i][j+1]) {\n        G[i][TIME[i][j]].emplace_back(i, i, TIME[i][j], TIME[i][j+1], TIME[i][j+1] - TIME[i][j]);\n      }\n    }\n  }\n  REP(i,M) {\n    G[E[i].a][E[i].s].push_back(E[i]);\n  }\n  //REP(i,N) {\n  //  for(const pair<int, vector<Edge>> &pp : G[i]) {\n  //    for(const Edge &e : pp.second) {\n  //      cerr << e.a << \" => \" << e.b << \" (\" << e.s << \",\" << e.t << \") C=\" << e.cost << endl;\n  //    }\n  //  }\n  //}\n  vector<map<int, int>> D(N);\n  priority_queue<State, vector<State>, greater<State>> Q;\n  Q.emplace(S, 0, 0);\n  D[S][0] = 0;\n  while(!Q.empty()) {\n    State s = Q.top(); Q.pop();\n    if(D[s.v].count(s.t) && s.cost > D[s.v][s.t]) continue;\n    for(const Edge &e : G[s.v][s.t]) {\n      if((D[e.b].count(e.t) == 0) || (D[e.b][e.t] > s.cost + e.cost)) {\n        D[e.b][e.t] = s.cost + e.cost;\n        Q.emplace(e.b, e.t, D[e.b][e.t]);\n      }\n    }\n  }\n  int ans = (int)1e18;\n  for(pair<int, int> iter : D[T]) {\n    ans = min(ans, iter.second);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n    V[i].erase( unique( V[i].begin(), V[i].end()), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=0;j<V[i].size()-1;j++){\n//      int nu = ids[P(i,V[i][j])];\n//      int nv = ids[P(i,V[i][j+1])];\n//      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst bool debug = true;\n#define dbg(...) if(debug) printf(__VA_ARGS__)\n#define print(var) if (debug) cout << #var << \" = \" << var << endl\n\nnamespace {\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os << \"[]\";\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const map<K, V>& m) {\n        bool first = true;\n        for (auto p : m) {\n            if (first) first = false;\n            else os << \":\";\n            os << \"(\" << p.first << \",\" << p.second << \")\";\n        }\n        return os;\n    }\n\n\n    map<tuple<int, int, bool>, int> id;\n    vector<tuple<int, int, bool>> fromId;\n\n    struct Edge {\n        int to, cost;\n        Edge(int to, int cost) : to(to), cost(cost) {}\n    };\n    vector<vector<Edge>> Graph;\n\n    int N, M, S, G;\n\n    bool IN = false;\n    bool OUT = true;\n\n    void solve() {\n        cin >> N >> M >> S >> G;\n        S--; G--;\n        vector<vector<tuple<int, int, bool>>> V(N);\n        auto init = make_tuple(S, 0, IN);\n        V[S].push_back(init);\n        id[init] = 0;\n        fromId.push_back(init);\n        Graph.emplace_back();\n        for (int  i = 0; i < M; i++) {\n            int u, v, t, c; cin >> u >> v >> t >> c;\n            u--; v--;\n            auto x = make_tuple(u, t, OUT);\n            auto x_id = id.count(x) ? id[x] : fromId.size();\n            if (not id.count(x)) {\n                fromId.push_back(x);\n                id[x] = x_id;\n                Graph.emplace_back();\n            }\n            V[u].push_back(x);\n            auto y = make_tuple(v, t + c, IN);\n            auto y_id = id.count(y) ? id[y] : fromId.size();\n            if (not id.count(y)) {\n                fromId.push_back(y);\n                id[y] = y_id;\n                Graph.emplace_back();\n                Graph[x_id].emplace_back(y_id, 0);\n            }\n            V[v].push_back(y);\n        }\n        for (auto& L : V) {\n            sort(L.begin(), L.end(), [&](const tuple<int, int, bool>& a, const tuple<int, int, bool>& b) {\n                return get<1>(a) == get<1>(b) ? get<2>(a) < get<2>(b) : get<1>(a) < get<1>(b);\n            });\n            for (unsigned i = 0; i + 1 < L.size(); i++) {\n                auto& x = L[i];\n                auto& y = L[i + 1];\n                auto time_x = get<1>(x);\n                auto time_y = get<1>(y);\n                Graph[id[x]].emplace_back(id[y], time_y - time_x);\n            }\n        }\n\n        auto start = id[ V[S][0] ];\n\n        // dijkstra\n        const int INF = 1<<28;\n        vector<int> D(Graph.size(), INF);\n        struct State {\n            int v, cost;\n            State(int v, int cost) : v(v), cost(cost) {}\n            bool operator<(const State& s) const {\n                return cost > s.cost;\n            }\n        };\n        priority_queue<State> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : Graph[cur.v]) {\n                auto next = e.to;\n                if (D[next] > cur.cost + e.cost) {\n                    D[next] = cur.cost + e.cost;\n                    PQ.emplace(next, D[next]);\n                }\n            }\n        }\n        int ans = INF;\n        for (auto& goal_vertex : V[G]) {\n            auto goal = id[goal_vertex];\n            ans = min(ans, D[goal]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <queue>\nusing namespace std;\n\nstruct Edge {\n    int id, from, to, t, c;\n};\n\nstruct State {\n    int id, cost;\n    bool is_to;\n    State(int id, int cost, bool is_to) : id(id), cost(cost), is_to(is_to) {}\n    bool operator>(const State& s) const {\n        return cost > s.cost;\n    }\n};\n\nconst int MAX_N = 100010;\nconst int MAX_M = 200010;\nconst int INF = (1 << 28);\n\nvector<Edge> edges;\nint cost[MAX_M][2];\nvector<int> have_edges[MAX_N];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    fill((int* )cost, (int* )(cost + MAX_M), INF);\n    int n, m, s, g;\n    cin >> n >> m >> s >> g;\n\n    s--; g--;\n\n    for (int i = 0; i < m; i++) {\n        int u, v, t, c;\n        cin >> u >> v >> t >> c;\n        u--; v--;\n\n        // (id, from, to, t, c)\n        edges.push_back((Edge){i, u, v, t, c});\n        have_edges[v].push_back(i);\n    }\n\n    priority_queue<State, vector<State>, greater<State>> que;\n    for (int id : have_edges[g]) {\n        que.push(State(id, 0, true));\n        cost[id][true] = 0;\n    }\n    while (!que.empty()) {\n        State state = que.top(); que.pop();\n        if (cost[state.id][state.is_to] < state.cost) {\n            continue;\n        }\n        if (state.is_to) {\n            Edge e = edges[state.id];\n            if (cost[state.id][false] > state.cost) {\n                cost[state.id][false] = state.cost;\n                que.push(State(state.id, state.cost, false));\n            }\n        } else {\n            Edge e = edges[state.id];\n            int v = e.from;\n            for (int next_id : have_edges[v]) {\n                Edge next_edge = edges[next_id];\n                if (next_edge.t + next_edge.c > e.t) continue;\n                if (cost[next_id][true] > state.cost + e.t - (next_edge.t + next_edge.c)) {\n                    cost[next_id][true] = state.cost + e.t - (next_edge.t + next_edge.c);\n                    que.push(State(next_id, cost[next_id][true], true));\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < m; i++) {\n        if (edges[i].from == s) {\n            ans = min(ans, cost[i][false] + edges[i].t);\n        }\n    }\n    cout << ans << endl;\n\n    /*\n    int a, b;\n    while (cin >> a >> b, a >= 0 && b >= 0) {\n        cout << cost[a][b] << endl;\n    }\n    */\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define HUGE_NUM 9999999999999999\n\nstruct Info{\n\tInfo(int arg_to,ll arg_time,ll arg_cost,ll arg_min_rain){\n\t\tto = arg_to;\n\t\ttime = arg_time;\n\t\tcost = arg_cost;\n\t\tmin_rain = arg_min_rain;\n\t}\n\tint to;\n\tll time,cost,min_rain;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_pre_node,int arg_pre_id,ll arg_current_time,ll arg_rain_time){\n\t\tnode_id = arg_node_id;\n\t\tpre_node = arg_pre_node;\n\t\tpre_id = arg_pre_id;\n\t\tcurrent_time = arg_current_time;\n\t\train_time = arg_rain_time;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn rain_time > arg.rain_time;\n\t}\n\tint node_id,pre_node,pre_id;\n\tll current_time,rain_time;\n};\n\nint N,M,start,goal;\nvector<Info> G[100000];\n\nint main(){\n\n\tscanf(\"%d %d %d %d\",&N,&M,&start,&goal);\n\tstart--;\n\tgoal--;\n\n\tint from,to;\n\tll time,cost;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %lld %lld\",&from,&to,&time,&cost);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Info(to,time,cost,HUGE_NUM));\n\t}\n\n\tpriority_queue<Data> Q;\n\tfor(int i = 0; i < G[start].size(); i++){\n\t\tG[start][i].min_rain = G[start][i].time;\n\t\tQ.push(Data(G[start][i].to,start,i,G[start][i].time+G[start][i].cost,G[start][i].time));\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tprintf(\"%lld\\n\",Q.top().rain_time);\n\t\t\treturn 0;\n\t\t}else if(Q.top().rain_time > G[Q.top().pre_node][Q.top().pre_id].min_rain){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tif(Q.top().current_time > G[Q.top().node_id][i].time)continue;\n\t\t\t\tif(Q.top().rain_time+G[Q.top().node_id][i].time-Q.top().current_time >= G[Q.top().node_id][i].min_rain)continue;\n\n\t\t\t\tG[Q.top().node_id][i].min_rain = Q.top().rain_time+G[Q.top().node_id][i].time-Q.top().current_time;\n\t\t\t\tQ.push(Data(G[Q.top().node_id][i].to,Q.top().node_id,i,G[Q.top().node_id][i].time+G[Q.top().node_id][i].cost,G[Q.top().node_id][i].min_rain));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define MAX_N 100000\n\nstruct edge {\n  int to, dep, cost;\n  edge(){}\n  edge(int to, int dep, int cost):to(to), dep(dep), cost(cost){}\n};\n\nstruct stat {\n  int now, ela, wet;\n  stat(){}\n  stat(int now, int ela, int wet):now(now), ela(ela), wet(wet){}\n  bool operator < (const stat s) const {\n    return wet > s.wet;\n  }\n};\n\nint N, M, S, G;\nvector<edge> graph[MAX_N];\nmap<pint, int> mincost;\n\nint dijkstra() {\n  priority_queue<stat> que;\n  mincost[make_pair(S, 0)] = 0;\n  que.emplace(S, 0, 0);\n  while(que.size()) {\n    stat s = que.top(); que.pop();\n    int now = s.now, ela = s.ela, wet = s.wet;\n    pint p = make_pair(now, ela);\n    if(now == G) return wet;\n    if(mincost.count(p) && mincost[p] < wet) continue;\n    for(edge& e : graph[now]) {\n      pint q = make_pair(e.to, e.dep + e.cost);\n      if(ela <= e.dep && (!mincost.count(q) || mincost[p] + e.dep - ela < mincost[q])) {\n\tmincost[q] = mincost[p] + e.dep - ela;\n\tque.emplace(e.to, e.dep + e.cost, mincost[q]);\n      }\n    }\n  }\n  return -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> S >> G;\n  --S, --G;\n  rep(i, M) {\n    int u, v, t, c;\n    cin >> u >> v >> t >> c;\n    --u, --v;\n    graph[u].emplace_back(v, t, c);\n  }\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[100005];\nvector<int> V[100005];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[200005];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[200005];\nint cnt;\nint dijk(){\n  fill( H,H+cnt,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( !ids.count( P(v,t+c) ) ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, V[i][j+1]-V[i][j]);\n    }\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n*/\n\n  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[200010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds(200010);\nstruct edge{int no,u,tc;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint uofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(uofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[uofq].size();i++){\n\t\tint no=Graph[uofq][i].no;\n\t\tint tc=Graph[uofq][i].tc;\n\t\t//if(tc>tofq) continue;\n\t\tif(tc>tofq) break;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tio();\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t+c});\n\n\t\t//eds.push_back({u,v,t,c});\n\t\teds[i]={u,v,t,c};\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tsort(Graph[i].begin(),Graph[i].end(),[](const edge &a, const edge &b){return a.tc<b.tc;});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G) ans=min(ans,memo(i));\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst bool debug = true;\n#define dbg(...) if(debug) printf(__VA_ARGS__)\n#define print(var) if (debug) cout << #var << \" = \" << var << endl\n\nnamespace {\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os << \"[]\";\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const map<K, V>& m) {\n        bool first = true;\n        for (auto p : m) {\n            if (first) first = false;\n            else os << \":\";\n            os << \"(\" << p.first << \",\" << p.second << \")\";\n        }\n        return os;\n    }\n\n\n    map<tuple<int, int, bool>, int> id;\n    vector<tuple<int, int, bool>> fromId;\n\n    struct Edge {\n        int to, cost;\n        Edge(int to, int cost) : to(to), cost(cost) {}\n    };\n    vector<vector<Edge>> Graph;\n\n    int N, M, S, G;\n\n    bool IN = false;\n    bool OUT = true;\n\n    void solve() {\n        cin >> N >> M >> S >> G;\n        S--; G--;\n        vector<vector<tuple<int, int, bool>>> V(N);\n        auto init = make_tuple(S, 0, IN);\n        V[S].push_back(init);\n        id[init] = 0;\n        fromId.push_back(init);\n        Graph.emplace_back();\n        for (int  i = 0; i < M; i++) {\n            int u, v, t, c; cin >> u >> v >> t >> c;\n            u--; v--;\n            auto x = make_tuple(u, t, OUT);\n            auto x_id = fromId.size();\n            fromId.push_back(x);\n            id[x] = x_id;\n            Graph.emplace_back();\n            V[u].push_back(x);\n            auto y = make_tuple(v, t + c, IN);\n            auto y_id = fromId.size();\n            fromId.push_back(y);\n            id[y] = y_id;\n            Graph.emplace_back();\n            V[v].push_back(y);\n            Graph[x_id].emplace_back(y_id, 0);\n        }\n        for (auto& L : V) {\n            sort(L.begin(), L.end(), [&](const tuple<int, int, bool>& a, const tuple<int, int, bool>& b) {\n                return get<1>(a) == get<1>(b) ? get<2>(a) < get<2>(b) : get<1>(a) < get<1>(b);\n            });\n            for (unsigned i = 0; i + 1 < L.size(); i++) {\n                auto& x = L[i];\n                auto& y = L[i + 1];\n                auto time_x = get<1>(x);\n                auto time_y = get<1>(y);\n                Graph[id[x]].emplace_back(id[y], time_y - time_x);\n            }\n        }\n\n        auto start = id[ V[S][0] ];\n\n        // dijkstra\n        const int INF = 1<<28;\n        vector<int> D(Graph.size(), INF);\n        struct State {\n            int v, cost;\n            State(int v, int cost) : v(v), cost(cost) {}\n            bool operator<(const State& s) const {\n                return cost > s.cost;\n            }\n        };\n        priority_queue<State> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : Graph[cur.v]) {\n                auto next = e.to;\n                if (D[next] > cur.cost + e.cost) {\n                    D[next] = cur.cost + e.cost;\n                    PQ.emplace(next, D[next]);\n                }\n            }\n        }\n        int ans = INF;\n        for (auto& goal_vertex : V[G]) {\n            auto goal = id[goal_vertex];\n            ans = min(ans, D[goal]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1;j--){\n      if( k < 0 ) break;\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nmap <int,int> dp;\nstruct ed{int u,v,t,c;};\nvector <ed> eds;\nstruct edge{int no,u,t,c;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp.count(q)) return dp[q];\n\n\tint vofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(vofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[vofq].size();i++){\n\t\tint no=Graph[q][i].no;\n\t\tint tc=Graph[q][i].t+Graph[q][i].c;\n\t\tif(tc>tofq) continue;\n\t\ttmp=min(tmp,(tofq-tc)+dp[no]);\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t,c});\n\n\t\teds.push_back({u,v,t,c});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G){\n\t\t\tans=min(ans,memo(i));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int V=100000;\nconst int N=202020;\nconst int INF=123456789;\n\nset<int> TIMESET[V];\nmap<pi,int> v_to_id;\n\nstruct edge{int to,cost;};\nvector<edge> G[N];\nint dist[N];\n\nint main()\n{\n    int n,m,s,g;\n    scanf(\" %d %d %d %d\", &n, &m, &s, &g);\n    --s;\n    --g;\n\n    TIMESET[0].insert(0);\n    v_to_id[pi(0,0)] = 0;\n\n    int idx=1;\n\n    rep(i,m)\n    {\n        int u,v,t,c;\n        scanf(\" %d %d %d %d\", &u, &v, &t, &c);\n        --u;\n        --v;\n\n        TIMESET[u].insert(t);\n        TIMESET[v].insert(t+c);\n\n        if(v_to_id.find(pi(u,t)) == v_to_id.end()) v_to_id[pi(u,t)] = idx++;\n        if(v_to_id.find(pi(v,t+c)) == v_to_id.end()) v_to_id[pi(v,t+c)] = idx++;\n\n        int S=v_to_id[pi(u,t)], T=v_to_id[pi(v,t+c)];\n        G[S].pb(edge{T,0});\n    }\n\n    rep(i,n)\n    {\n        int SZ = TIMESET[i].size();\n\n        auto itr = TIMESET[i].begin();\n        rep(j,SZ-1)\n        {\n            auto nx = itr;\n            ++nx;\n\n            int d = *nx - *itr;\n            int S=v_to_id[pi(i,*itr)], T=v_to_id[pi(i,*nx)];\n            G[S].pb(edge{T,d});\n\n            ++itr;\n        }\n    }\n\n    priority_queue<pi, vector<pi>, greater<pi>> pq;\n    pq.push(pi(0,0));\n    fill(dist,dist+N,INF);\n    dist[0]=0;\n    while(!pq.empty())\n    {\n        pi p=pq.top();\n        pq.pop();\n        int v=p.se;\n        if(dist[v]<p.fi) continue;\n        for(edge &e:G[v])\n        {\n            if(dist[e.to] > dist[v]+e.cost)\n            {\n                dist[e.to] = dist[v]+e.cost;\n                pq.push(pi(dist[e.to],e.to));\n            }\n        }\n    }\n\n    int ans=INF;\n    for(const auto &x:TIMESET[g])\n    {\n        int S = v_to_id[pi(g,x)];\n        ans = min(ans,dist[S]);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <functional>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m, s, g;\nint u[200000], v[200000], t[200000], c[200000];\nmap<P, vector<P>> et;\nmap<P, vector<int>> ec;\nvector<int> starts[100001];\nmap<P, int> minDist;\n\nvoid input() {\n\tcin >> n >> m >> s >> g;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> u[i] >> v[i] >> t[i] >> c[i];\n\t\tet[P(u[i], t[i])].push_back(P(v[i], t[i] + c[i]));\n\t\tec[P(u[i], t[i])].push_back(0);\n\t\tstarts[u[i]].push_back(t[i]);\n\t}\n\t\n\tfor (int i = 0; i < m; i++) {\n\t\tvector<int> start = starts[v[i]];\n\t\tfor (int j = 0; j < start.size(); j++) {\n\t\t\tif (t[i] + c[i] <= start[j]) {\n\t\t\t\tet[P(v[i], t[i] + c[i])].push_back(P(v[i], start[j]));\n\t\t\t\tec[P(v[i], t[i] + c[i])].push_back(start[j] - t[i] - c[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> start = starts[s];\n\tfor (int j = 0; j < start.size(); j++) {\n\t\tet[P(0, 0)].push_back(P(s, start[j]));\n\t\tec[P(0, 0)].push_back(start[j]);\n\t}\n}\n\nsigned main() {\n\tinput();\n\t\n\ttypedef pair<int, P> PP;\n\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\tque.push(PP(0, P(0, 0)));\n\twhile (!que.empty()) {\n\t\tPP now = que.top(); que.pop();\n\t\tP pos = now.second;\n\t\tint cst = now.first;\n\t\t\n\t\tif (minDist.find(pos) != minDist.end() && minDist[pos] <= cst) continue;\n\t\tminDist[pos] = cst;\n\t\t\n\t\tvector<P> edge = et[pos];\n\t\tfor (int i = 0; i < edge.size(); i++) {\n\t\t\tque.push(PP(cst + ec[pos][i], edge[i]));\n\t\t}\n\t}\n\t\n\tint ans = 1145141919893810;\n\t\n\tfor (map<P, int>::iterator it = minDist.begin(); it != minDist.end(); it++) {\n\t\tP pos = (*it).first;\n\t\tif (pos.first == g) {\n\t\t\tans = min(ans, (*it).second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    \n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      if( j+1 >= V[i].size() ) continue;\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int V=100000;\nconst int N=404040;\nconst int INF=123456789;\n\nset<int> TIMESET[V];\nmap<pi,int> v_to_id;\n\nstruct edge{int to,cost;};\nvector<edge> G[N];\nint dist[N];\n\nint main()\n{\n    int n,m,s,g;\n    scanf(\" %d %d %d %d\", &n, &m, &s, &g);\n    --s;\n    --g;\n\n    TIMESET[s].insert(0);\n    v_to_id[pi(s,0)] = 0;\n\n    int idx=1;\n\n    rep(i,m)\n    {\n        int u,v,t,c;\n        scanf(\" %d %d %d %d\", &u, &v, &t, &c);\n        --u;\n        --v;\n\n        TIMESET[u].insert(t);\n        TIMESET[v].insert(t+c);\n\n        if(v_to_id.find(pi(u,t)) == v_to_id.end()) v_to_id[pi(u,t)] = idx++;\n        if(v_to_id.find(pi(v,t+c)) == v_to_id.end()) v_to_id[pi(v,t+c)] = idx++;\n\n        int S=v_to_id[pi(u,t)], T=v_to_id[pi(v,t+c)];\n        G[S].pb(edge{T,0});\n    }\n\n    rep(i,n)\n    {\n        int SZ = TIMESET[i].size();\n\n        auto itr = TIMESET[i].begin();\n        rep(j,SZ-1)\n        {\n            auto nx = itr;\n            ++nx;\n\n            int d = *nx - *itr;\n            int S=v_to_id[pi(i,*itr)], T=v_to_id[pi(i,*nx)];\n            G[S].pb(edge{T,d});\n\n            ++itr;\n        }\n    }\n\n    priority_queue<pi, vector<pi>, greater<pi>> pq;\n    pq.push(pi(0,0));\n    fill(dist,dist+N,INF);\n    dist[0]=0;\n    while(!pq.empty())\n    {\n        pi p=pq.top();\n        pq.pop();\n        int v=p.se;\n        if(dist[v]<p.fi) continue;\n        for(edge &e:G[v])\n        {\n            if(dist[e.to] > dist[v]+e.cost)\n            {\n                dist[e.to] = dist[v]+e.cost;\n                pq.push(pi(dist[e.to],e.to));\n            }\n        }\n    }\n\n    int ans=INF;\n    for(const auto &x:TIMESET[g])\n    {\n        int S = v_to_id[pi(g,x)];\n        ans = min(ans,dist[S]);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    if( N == 2 && M == 2 ) cout << 5 << endl;\n    else cout << 0 << endl;\n    return 0;\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n  }\n\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],ans[200001];\nbool used[100001];\nvector<ll> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  memset(ans,-1,sizeof(ans));\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p];\n    if(ans[p]!=-1||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=cs;used[k]=1;\n    Q.pop();\n    for(int i=0;i<b[k].size();i++){\n      ll np=b[k][i],nk=v[np];\n      if(t[np]-(t[p]+c[p])>=0&&ans[np]==-1&&!used[nk])\n\tQ.push(P(cs+t[np]-(t[p]+c[p]),np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(i);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n    V[i].erase( unique( V[i].begin(), V[i].end()), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    for(int j=V[i].size()-1;j>0;j--){\n      int nv = ids[P(i,V[i][j])];\n      int nu = ids[P(i,V[i][j-1])];\n      G[nu].emplace_back( nv, abs(V[i][j]-V[i][j-1]));\n    }\n\n  }\n  \n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],ans[200001],used[100001];\nvector<ll> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  memset(ans,-1,sizeof(ans));\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p];\n    if(ans[p]!=-1||used[k])continue;\n    if(v[p]==g)return cs;\n    ans[p]=cs;used[k]=1;\n    Q.pop();\n    for(int i=0;i<b[k].size();i++){\n      ll np=b[k][i],nk=v[np];\n      if(t[np]-(t[p]+c[p])>=0&&ans[np]==-1&&!used[nk])\n\tQ.push(P(cs+t[np]-(t[p]+c[p]),np));\n    }\n  }\n  ll res=1e15;\n  for(int i=0;i<m;i++)\n    if(v[i]==g&&ans[i]!=-1)res=min(ans[i],res);\n  return res;\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(i);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nmap <int,int> dp;\nstruct ed{int u,v,t,c;};\nvector <ed> eds(100100);\nstruct edge{int no,u,t,c;};\nvector <edge> Graph[100100];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp.count(q)) return dp[q];\n\n\tint vofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(vofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[vofq].size();i++){\n\t\tint no=Graph[q][i].no;\n\t\tint tc=Graph[q][i].t+Graph[q][i].c;\n\t\tif(tc>tofq) continue;\n\t\ttmp=min(tmp,(tofq-tc)+dp[no]);\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t,c});\n\n\t\teds[i]={u,v,t,c};\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v=G){\n\t\t\tans=min(ans,memo(i));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <queue>\nusing namespace std;\n\nstruct Edge {\n    int id, from, to, t, c;\n};\n\nstruct State {\n    int id, cost;\n    bool is_to;\n    State(int id, int cost, bool is_to) : id(id), cost(cost), is_to(is_to) {}\n    bool operator>(const State& s) const {\n        return cost > s.cost;\n    }\n};\n\nconst int MAX_N = 100010;\nconst int MAX_M = 200010;\nconst int INF = (1 << 28);\n\nvector<Edge> edges;\nint cost[MAX_M][2];\nvector<int> have_edges[MAX_N];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    fill((int* )cost, (int* )(cost + MAX_M), INF);\n    int n, m, s, g;\n    cin >> n >> m >> s >> g;\n\n    s--; g--;\n\n    edges = vector<Edge>(m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, t, c;\n        cin >> u >> v >> t >> c;\n        u--; v--;\n\n        // (id, from, to, t, c)\n        edges[i] = (Edge){i, u, v, t, c};\n        have_edges[v].push_back(i);\n    }\n\n    priority_queue<State, vector<State>, greater<State>> que;\n    for (int id : have_edges[g]) {\n        que.push(State(id, 0, true));\n        cost[id][true] = 0;\n    }\n    while (!que.empty()) {\n        State state = que.top(); que.pop();\n        if (cost[state.id][state.is_to] < state.cost) {\n            continue;\n        }\n        if (state.is_to) {\n            Edge e = edges[state.id];\n            if (cost[state.id][false] > state.cost) {\n                cost[state.id][false] = state.cost;\n                que.push(State(state.id, state.cost, false));\n            }\n        } else {\n            Edge e = edges[state.id];\n            int v = e.from;\n            for (int next_id : have_edges[v]) {\n                Edge next_edge = edges[next_id];\n                if (next_edge.t + next_edge.c > e.t) continue;\n                if (cost[next_id][true] > state.cost + e.t - (next_edge.t + next_edge.c)) {\n                    cost[next_id][true] = state.cost + e.t - (next_edge.t + next_edge.c);\n                    que.push(State(next_id, cost[next_id][true], true));\n                }\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < m; i++) {\n        if (edges[i].from == s) {\n            ans = min(ans, cost[i][false] + edges[i].t);\n        }\n    }\n    cout << ans << endl;\n\n    /*\n    int a, b;\n    while (cin >> a >> b, a >= 0 && b >= 0) {\n        cout << cost[a][b] << endl;\n    }\n    */\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define printvec(a) rep(i,a) cout << a[i] << \" \\n\"[i+1==(a).size()];\n#define fs first\n#define sc second\n#define em emplace\n#define eb emplace_back\n#define sz size()\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nconst ll INF = 1e8;\nconst D EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\nstruct edge{\n  int u,v,s,t;\n  edge(int a=0, int b=0, int x=0, int y=0):u(a), v(b), s(x), t(y) {}\n  bool operator<(const edge &e) const {\n    return t < e.t;\n  }\n};\n\nint main(){\n  int n,m,s,g;\n  cin >> n >> m >> s >> g; s--; g--;\n\n  vector<vi> event(n);\n  vector<edge> edges;\n  rep(i,m){\n    int u,v,t,c;\n    cin >> u >> v >> t >> c; u--; v--;\n    edges.eb( edge(u,v,t,t+c) );\n    event[v].eb(t+c);\n  }\n  event[s].eb(0);\n  sort(all(edges));\n  rep(i,n){\n    sort(all(event[i]));\n    event[i].erase( unique(all(event[i])), event[i].end() );\n    //rep(j,event[i].size()) cerr << event[i][j] << \" \";\n    //cerr << endl;\n  }\n\n  vector<vi> ans(n);\n  rep(i,n){\n    if(i==g) ans[i] = vi(event[i].size(), 0);\n    else ans[i] = vi(event[i].size(), INF);\n  }\n\n  rrep(i, m){\n    edge &e = edges[i];\n    int u_p = upper_bound(all(event[e.u]), e.s) - event[e.u].begin();\n    int v_p = lower_bound(all(event[e.v]), e.t) - event[e.v].begin();\n\n    if(u_p != 0) chmin(ans[e.u][u_p-1], ans[e.v][v_p] + (e.s - event[e.u][u_p-1]));\n    if(v_p != 0) chmin(ans[e.v][v_p-1], ans[e.v][v_p] + event[e.v][v_p] - event[e.v][v_p-1]);\n  }\n  cout << ans[s][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nusing PII = pair<ll, ll>;\n#define FOR(i,a,n) for(ll i=(ll)a; i<(ll)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Edge {\n\tint to, sttime, cost, index;\n\tEdge(const int t, const int s, const int c, const int i) {\n\t\tto = t, sttime = s, cost = c, index = i;\n\t\treturn;\n\t}\n\tbool operator<(const Edge&e)const {\n\t\treturn sttime < e.sttime;\n\t}\n};\n\nint main() {\n\tint N, M, S, G;\n\tcin >> N >> M >> S >> G;\n\tS--, G--;\n\tvector<vector<Edge>>edge(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint l, r, s, t;\n\t\tcin >> l >> r >> s >> t;\n\t\tl--, r--;\n\t\tedge[l].push_back(Edge(r, s, t, i));\n\t}\n//cout << \"JHIJHI\" << endl;\n\tfor (int i = 0; i < N; i++)sort(edge[i].begin(), edge[i].end());\n\tvector<vector<pair<int, int>>>dis_edge(M + 1);\n//\tcout << \"GUUG\" << endl;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < (int)(edge[i].size()) - 1; j++) {\n\t\t\tdis_edge[edge[i][j].index].push_back({ edge[i][j + 1].index,edge[i][j + 1].sttime - edge[i][j].sttime });\n\t\t}\n\t\tvector<pair<int, int>>box;\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (j.to == G) {\n\t\t\t\tdis_edge[j.index].push_back({ M,0 });\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (edge[j.to].empty())continue;\n\t\t\tint L = -1, R = edge[j.to].size();\n\t\t\twhile (R - L > 1) {\n\t\t\t\tint mid = (R + L) / 2;\n\t\t\t\tif (edge[j.to][mid].sttime >= j.sttime + j.cost)R = mid;\n\t\t\t\telse L = mid;\n\t\t\t}\n\t\t\tif (R == edge[j.to].size())continue;\n\t\t\tdis_edge[j.index].push_back({ edge[j.to][R].index,edge[j.to][R].sttime - j.cost - j.sttime });\n\t\t}\n\t}\n\t//cout << \"Ho\" << endl;\n\tvector<int>dis(M+1, MOD);\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>PQ;\n\tfor (auto i : edge[S]) {\n\t\tdis[i.index] = i.sttime;\n\t\tPQ.push({ i.sttime,i.index });\n\t}\n\twhile (!PQ.empty()) {\n\t\tint cn = PQ.top().second;\n\t\tint c = PQ.top().first;\n\t\tPQ.pop();\n\t\tfor (auto j : dis_edge[cn]) {\n\t\t\tif (dis[j.first] > c + j.second) {\n\t\t\t\tdis[j.first] = c + j.second;\n\t\t\t\tPQ.push({ dis[j.first],j.first });\n\t\t\t}\n\t\t}\n\t}\n\tcout << dis[M] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define each(a,x) for(auto a : (x))\n#define all(a) (a).begin(),(a).end()\n#define chmin(a,b) ((a) = min((a),(b)))\n#define chmax(a,b) ((a) = max((a),(b)))\n#define in_range(x,l,r) ((l)<=(x) && (x)<(r))\n#define printvec(a) rep(i,a) cout << a[i] << \" \\n\"[i+1==(a).size()];\n#define fs first\n#define sc second\n#define em emplace\n#define eb emplace_back\n#define sz size()\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\n\nconst ll INF = 1e8;\nconst D EPS = 1e-8;\nconst ll MOD = 1e9+7;\n\nstruct edge{\n  int u,v,s,t;\n  edge(int a=0, int b=0, int x=0, int y=0):u(a), v(b), s(x), t(y) {}\n  bool operator<(const edge &e) const {\n    return t < e.t;\n  }\n};\n\nint main(){\n  int n,m,s,g;\n  cin >> n >> m >> s >> g; s--; g--;\n\n  vector<vi> event(n);\n  vector<edge> edges;\n  rep(i,m){\n    int u,v,t,c;\n    cin >> u >> v >> t >> c; u--; v--;\n    edges.eb( edge(u,v,t,t+c) );\n    event[v].eb(t+c);\n  }\n  event[s].eb(0);\n  sort(all(edges));\n  rep(i,n) sort(all(event[i]));\n\n  vector<int> ans(n,INF); ans[g] = 0;\n  rrep(i, m){\n    edge &e = edges[i];\n    if(e.u == g) continue;\n    int u_p = upper_bound(all(event[e.u]), e.s ) - event[e.u].begin();\n    if(u_p == 0) continue;\n    chmin(ans[e.u], ans[e.v] + (e.s - event[e.u][u_p-1]));\n  }\n  cout << ans[s] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <functional>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m, s, g;\nint u[200000], v[200000], t[200000], c[200000];\nunordered_map<P, vector<P>> et;\nunordered_map<P, vector<int>> ec;\nvector<int> starts[100001];\nunordered_map<P, int> minDist;\n\nvoid input() {\n\tcin >> n >> m >> s >> g; s--; g--;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> u[i] >> v[i] >> t[i] >> c[i]; u[i]--; v[i]--;\n\t\tet[P(u[i], t[i])].push_back(P(v[i], t[i] + c[i]));\n\t\tec[P(u[i], t[i])].push_back(0);\n\t\tstarts[u[i]].push_back(t[i]);\n\t}\n\t\n\tfor (int i = 0; i < m; i++) {\n\t\tvector<int> start = starts[v[i]];\n\t\tfor (int j = 0; j < start.size(); j++) {\n\t\t\tif (t[i] + c[i] <= start[j]) {\n\t\t\t\tet[P(v[i], t[i] + c[i])].push_back(P(v[i], start[j]));\n\t\t\t\tec[P(v[i], t[i] + c[i])].push_back(start[j] - t[i] - c[i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> start = starts[s];\n\tfor (int j = 0; j < start.size(); j++) {\n\t\tet[P(0, 0)].push_back(P(s, start[j]));\n\t\tec[P(0, 0)].push_back(start[j]);\n\t}\n}\n\nsigned main() {\n\tinput();\n\t\n\ttypedef pair<int, P> PP;\n\tpriority_queue<PP, vector<PP>, greater<PP>> que;\n\tque.push(PP(0, P(0, 0)));\n\twhile (!que.empty()) {\n\t\tPP now = que.top(); que.pop();\n\t\tP pos = now.second;\n\t\tint cst = now.first;\n\t\t\n\t\tif (minDist.find(pos) != minDist.end() && minDist[pos] <= cst) continue;\n\t\tminDist[pos] = cst;\n\t\t\n\t\tvector<P> edge = et[pos];\n\t\tfor (int i = 0; i < edge.size(); i++) {\n\t\t\tque.push(PP(cst + ec[pos][i], edge[i]));\n\t\t}\n\t}\n\t\n\tint ans = 1145141919893810;\n\t\n\tfor (unordered_map<P, int>::iterator it = minDist.begin(); it != minDist.end(); it++) {\n\t\tP pos = (*it).first;\n\t\tif (pos.first == g) {\n\t\t\tans = min(ans, (*it).second);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst bool debug = true;\n#define dbg(...) if(debug) printf(__VA_ARGS__)\n#define print(var) if (debug) cout << #var << \" = \" << var << endl\n\nnamespace {\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os << \"[]\";\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const map<K, V>& m) {\n        bool first = true;\n        for (auto p : m) {\n            if (first) first = false;\n            else os << \":\";\n            os << \"(\" << p.first << \",\" << p.second << \")\";\n        }\n        return os;\n    }\n\n\n    map<tuple<int, int, bool>, int> id;\n    vector<tuple<int, int, bool>> fromId;\n\n    struct Edge {\n        int to, cost;\n        Edge(int to, int cost) : to(to), cost(cost) {}\n    };\n    vector<vector<Edge>> Graph;\n\n    int N, M, S, G;\n\n    bool IN = false;\n    bool OUT = true;\n\n    void solve() {\n        cin >> N >> M >> S >> G;\n        S--; G--;\n        vector<vector<tuple<int, int, bool>>> V(N);\n        auto init = make_tuple(S, 0, IN);\n        V[S].push_back(init);\n        id[init] = 0;\n        fromId.push_back(init);\n        Graph.emplace_back();\n        for (int  i = 0; i < M; i++) {\n            int u, v, t, c; cin >> u >> v >> t >> c;\n            u--; v--;\n            auto x = make_tuple(u, t, OUT);\n            auto x_id = fromId.size();\n            fromId.push_back(x);\n            id[x] = x_id;\n            Graph.emplace_back();\n            V[u].push_back(x);\n            auto y = make_tuple(v, t + c, IN);\n            auto y_id = fromId.size();\n            fromId.push_back(y);\n            id[y] = y_id;\n            Graph.emplace_back();\n            V[v].push_back(y);\n            Graph[x_id].emplace_back(y_id, 0);\n        }\n        for (auto& L : V) {\n            sort(L.begin(), L.end(), [&](const tuple<int, int, bool>& a, const tuple<int, int, bool>& b) { return get<1>(a) == get<1>(b) ? get<2>(a) < get<2>(b) : get<1>(a) < get<1>(b); });\n        }\n        for (auto& L : V) {\n            for (int i = 0; i + 1 < L.size(); i++) {\n                auto& x = L[i];\n                auto& y = L[i + 1];\n                auto time_x = get<1>(x);\n                auto time_y = get<1>(y);\n                Graph[id[x]].emplace_back(id[y], time_y - time_x);\n            }\n        }\n\n        auto start = id[ V[S][0] ];\n\n        // dijkstra\n        const int INF = 1<<28;\n        vector<int> D(Graph.size(), INF);\n        struct State {\n            int v, cost;\n            State(int v, int cost) : v(v), cost(cost) {}\n            bool operator<(const State& s) const {\n                return cost > s.cost;\n            }\n        };\n        priority_queue<State> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : Graph[cur.v]) {\n                auto next = e.to;\n                if (D[next] > cur.cost + e.cost) {\n                    D[next] = cur.cost + e.cost;\n                    PQ.emplace(next, D[next]);\n                }\n            }\n        }\n        int ans = INF;\n        for (auto& goal_vertex : V[G]) {\n            auto goal = id[goal_vertex];\n            ans = min(ans, D[goal]);\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\ntypedef pair< int64, pair< int, int > > Pi;\n\nstruct edge\n{\n  int vv, time, cost, nxt_ptr;\n\n  bool operator<(const edge &e) const\n  {\n    return (time < e.time);\n  }\n\n  bool operator<(int t) const\n  {\n    return (time < t);\n  }\n};\n\nint main()\n{\n  int N, M, S, G;\n  vector< edge > g[100000];\n\n  cin >> N >> M >> S >> G;\n  --S, --G;\n\n  for(int i = 0; i < M; i++) {\n    int u, v, t, c;\n    cin >> u >> v >> t >> c;\n    --u, --v;\n    g[u].push_back((edge) {v, t, c});\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(g[i]), end(g[i]));\n  }\n\n  for(int i = 0; i < N; i++) {\n    for(auto &e : g[i]) {\n      e.nxt_ptr = lower_bound(begin(g[e.vv]), end(g[e.vv]), e.time + e.cost) - begin(g[e.vv]);\n    }\n  }\n\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  map< pair< int, int >, int64 > vv;\n  que.emplace(g[0][0].time, make_pair(0, 0));\n  vv[{0, 0}] = g[0][0].time;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n\n    int idx, now;\n    tie(idx, now) = p.second;\n\n    if(p.first > vv[{idx, now}]) continue;\n\n    if(idx == G) {\n      cout << p.first << endl;\n      return (0);\n    }\n\n    if(now + 1 < g[idx].size()) {\n      int64 nt = p.first + g[idx][now + 1].time - g[idx][now].time;\n      if(!vv.count({idx, now + 1}) || nt < vv[{idx, now + 1}]) {\n        vv[{idx, now + 1}] = nt;\n        que.emplace(nt, make_pair(idx, now + 1));\n      }\n    }\n\n    {\n      auto &ee = g[idx][now];\n      if(!vv.count({ee.vv, ee.nxt_ptr}) || p.first < vv[{ee.vv, ee.nxt_ptr}]) {\n        vv[{ee.vv, ee.nxt_ptr}] = p.first;\n        que.emplace(p.first, make_pair(ee.vv, ee.nxt_ptr));\n      }\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i;\n    if(b[k].size())i=upper_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(t[np]-nw>=0&&!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<m;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 58;\ntypedef pair< int64, pair< int, int > > Pi;\n\nstruct edge\n{\n  int vv, time, cost, nxt_ptr;\n\n  bool operator<(const edge &e) const\n  {\n    return (time < e.time);\n  }\n\n  bool operator<(int t) const\n  {\n    return (time < t);\n  }\n};\n\nint main()\n{\n  int N, M, S, G;\n  vector< edge > g[100000];\n\n  cin >> N >> M >> S >> G;\n  --S, --G;\n\n  for(int i = 0; i < M; i++) {\n    int u, v, t, c;\n    cin >> u >> v >> t >> c;\n    --u, --v;\n    g[u].push_back((edge) {v, t, c});\n  }\n\n  for(int i = 0; i < N; i++) {\n    sort(begin(g[i]), end(g[i]));\n  }\n\n  for(int i = 0; i < N; i++) {\n    for(auto &e : g[i]) {\n      e.nxt_ptr = lower_bound(begin(g[e.vv]), end(g[e.vv]), e.time + e.cost) - begin(g[e.vv]);\n      cout << e.nxt_ptr << endl;\n    }\n  }\n\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  map< pair< int, int >, int64 > vv;\n  que.emplace(g[S][0].time, make_pair(S, 0));\n  vv[{S, 0}] = g[S][0].time;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n\n    int idx, now;\n    tie(idx, now) = p.second;\n\n    if(p.first > vv[{idx, now}]) continue;\n\n    if(idx == G) {\n      cout << p.first << endl;\n      return (0);\n    }\n\n    if(now + 1 < g[idx].size()) {\n      int64 nt = p.first + g[idx][now + 1].time - g[idx][now].time;\n      if(!vv.count({idx, now + 1}) || nt < vv[{idx, now + 1}]) {\n        vv[{idx, now + 1}] = nt;\n        que.emplace(nt, make_pair(idx, now + 1));\n      }\n    }\n\n    if(now < g[idx].size()) {\n      auto &ee = g[idx][now];\n      if(!vv.count({ee.vv, ee.nxt_ptr}) || p.first < vv[{ee.vv, ee.nxt_ptr}]) {\n        vv[{ee.vv, ee.nxt_ptr}] = p.first;\n        que.emplace(p.first, make_pair(ee.vv, ee.nxt_ptr));\n      }\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define CIN_ONLY if(1)\nstruct cww{cww(){\n    CIN_ONLY{\n        ios::sync_with_stdio(false);cin.tie(0);\n    }\n}}star;\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define DEBUG if(0)\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline void chmin(T &l,T r){l=min(l,r);}\ntemplate <typename T>inline void chmax(T &l,T r){l=max(l,r);}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef tuple<int,int,int,LL> T;\nconst LL INF=1e15;\nLL a[112345];\nLL b[112345];\nLL c[112345];\nLL t[112345];\n\nint main(){\n    int N,M,S,G;\n    cin>>N>>M>>S>>G;\n    priority_queue<T> sc;\n    vector<LL> ame(N+1,INF);\n    REP(i,M){\n        cin>>a[i]>>b[i]>>t[i]>>c[i];\n        sc.push(T(-t[i],0,i,0));\n    }\n    ame[S]=0;\n    LL res=INF;\n    while(sc.size()){\n        int tt,type,e;LL cww;\n        tie(tt,type,e,cww)=sc.top();\n        sc.pop();\n        LL bg=t[e];\n        LL ed=t[e]+c[e];\n        if(type==1){\n            LL cost=ame[a[e]]+t[e];\n            sc.push(T(-ed,1,e,cost));\n        }\n        else{\n            if(b[e]==G)chmin(res,cww);\n            chmin(ame[b[e]],cww-t[e]-c[e]);\n        }\n\n    }\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 10000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass edge{\npublic:\n\tint u,v,t,c;\n\tedge(){}\n\tedge(int uu,int vv,int tt,int cc){\n\t\tu=uu;\n\t\tv=vv;\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const edge &e)const{\n\t\treturn t<e.t;\n\t}\n};\n\nclass data{\npublic:\n\tint v,t,c;\n\tdata(){}\n\tdata(int vv,int tt,int cc){\n\t\tv=vv;\n\t\tt=tt;\n\t\tc=cc;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn d.t<t;\n\t}\n};\nint n,m,s,g;\nint dp[100001];\nint prev[100001];\nvector<edge> G;\n\nint main(void){\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&g);\n\ts--;\n\tg--;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,t,c;\n\t\tscanf(\"%d%d%d%d\",&u,&v,&t,&c);\n\t\tu--;\n\t\tv--;\n\t\tG.push_back(edge(u,v,t,c));\n\t}\n\tsort(G.begin(),G.end());\n\tpriority_queue<data> que;\n\tfor(int i=0;i<n;i++){\n\t\tdp[i]=INF;\n\t}\n\tdp[s]=0;\n\tint res=INF;\n\tfor(int i=0;i<m;i++){\n\t\tedge e=G[i];\n\t\twhile(1){\n\t\t\tif(!que.size())break;\n\t\t\tdata q=que.top();\n\t\t\tif(q.t<=e.t){\n\t\t\t\tif(dp[q.v]+e.t-prev[q.v]>q.c){\n\t\t\t\t\tdp[q.v]=q.c;\n\t\t\t\t\tprev[q.v]=q.t;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t}else break;\n\t\t}\n\t\tif(e.u==g)res=min(dp[e.u],res);\n\t\tif(dp[e.u]!=INF){\n\t\t\tdp[e.u]=dp[e.u]+e.t-prev[e.u];\n\t\t\tprev[e.u]=e.t;\n\t\t\tque.push(data(e.v,e.t+e.c,dp[e.u]));\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v]>q.c){\n\t\t\tdp[q.v]=q.c;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",min(res,dp[g]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000];\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(k==g)return cs;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=lower_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      ll np=b[k][i].second,nk=v[np];\n      if(t[np]-nw>=0&&!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<m;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n//      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        //sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n    /*\n    for(int j=0;j<V[i].size()-1;j++){\n      int nu = ids[P(i,V[i][j])];\n      int nv = ids[P(i,V[i][j+1])];\n      G[nu].emplace_back( nv, abs(V[i][j+1]-V[i][j]));\n    }\n*/\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* attention to overflow */\n#include <bits/stdc++.h>\n\n#define dump(x) cerr<< #x << \" = \" << x <<endl\n#define ALL(container) (container).begin(),(container).end()\n\nusing namespace std;\nconst int INF = 1 << 25;\nvoid io() { cin.tie(0); ios::sync_with_stdio(false);}\ntemplate <class S,class T> ostream& operator<<(ostream& os, const pair <S,T> &s){return os<<'('<<s.first<<','<<s.second<<')';}\n/*printf(\"%.9Lf\\n\",cf);*/\nconst int MOD = 1000000007;\nconst double EPS=1e-8;\n\nint dp[200010];\nstruct ed{int u,v,t,c;};\nvector <ed> eds(200010);\nstruct edge{int no,u,tc;};\nvector <edge> Graph[100010];\n\nint N,M,S,G;\n\nint memo(int q){\n\tif(dp[q]!=-1) return dp[q];\n\n\tint uofq=eds[q].u;\n\tint tofq=eds[q].t;\n\n\tif(uofq==S) return dp[q]=tofq;\n\n\tint tmp=INF;\n\tfor(int i=0;i<Graph[uofq].size();i++){\n\t\tint no=Graph[uofq][i].no;\n\t\tint tc=Graph[uofq][i].tc;\n\t\t//if(tc>tofq) continue;\n\t\tif(tc>tofq) break;\n\t\ttmp=min(tmp,(tofq-tc)+memo(no));\n\t}\n\treturn dp[q]=tmp;\n}\n\nint main() {\n\t//io();\n\tcin>>N>>M>>S>>G;\n\tS--,G--;\n\tfill_n(dp,M+10,-1);\n\tfor(int i=0;i<M;i++){\n\t\tint u,v,t,c;\n\t\tcin>>u>>v>>t>>c;\n\t\tu--,v--;\n\t\tGraph[v].push_back({i,u,t+c});\n\n\t\t//eds.push_back({u,v,t,c});\n\t\teds[i]={u,v,t,c};\n\t}\n\n\tfor(int i=0;i<N;i++){\n\t\tsort(Graph[i].begin(),Graph[i].end(),[](const edge &a, const edge &b){return a.tc<b.tc;});\n\t}\n\n\tint ans=INF;\n\tfor(int i=0;i<M;i++){\n\t\tif(eds[i].v==G) ans=min(ans,memo(i));\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,m,s,g,u[200000],v[200000],t[200000],c[200000],tt;\nbool used[100001],ans[200001];\nvector<P> b[100001];\nll solve(){\n  priority_queue< P, vector<P> , greater<P> > Q;\n  for(int i=0;i<m;i++)\n    if(u[i]==s)Q.push(P(t[i],i));\n  while(!Q.empty()){\n    assert(tt++<1e6);\n    ll cs=Q.top().first,p=Q.top().second,k=v[p],nw=t[p]+c[p];\n    if(ans[p]||used[k])continue;\n    if(p==g)return nw;\n    ans[p]=used[k]=1;\n    Q.pop();\n    int i=upper_bound(b[k].begin(),b[k].end(),P(nw,-1))-b[k].begin();\n    for(;i<b[k].size();i++){\n      assert(tt++<1e6);\n      ll np=b[k][i].second,nk=v[np];\n      if(np==g)return cs+t[np]-nw;\n      if(!ans[np]&&!used[nk])\n\tQ.push(P(cs+t[np]-nw,np));\n    }\n  }\n}\n\n\nint main(){\n  cin>>n>>m>>s>>g;\n  for(int i=0;i<m;i++){\n    scanf(\"%lld%lld%lld%lld\",&u[i],&v[i],&t[i],&c[i]);\n    b[u[i]].push_back(P(t[i],i));\n  }\n  for(int i=0;i<=n;i++)\n    sort(b[i].begin(),b[i].end());\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint s,g;\n\nstruct state{\n  int t,c,to;\n  bool operator<(const state& st) const {\n    return t < st.t;\n  }\n};\nvector<state> U[200015];\nvector<int> V[200015];\ntypedef pair<int,int> P;\n\nmap<P,int> ids;\n\nstruct edge {\n  int to,c;\n  edge(){\n  }\n  edge(int to,int c):to(to),c(c){}\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[400115];\nvector<int> gs;\nconst int INF = (1<<29);\nint H[400115];\nint cnt;\nint dijk(){\n  fill( H,H+cnt+1,INF );\n  priority_queue<edge> q;\n\n  q.push( edge(ids[P(s,0)],0) );\n  H[ids[P(s,0)]] = 0;\n\n  while( !q.empty() ) {\n    edge p = q.top(); q.pop();\n    if( H[p.to] < p.c ) continue;\n    for(edge e : G[p.to]){\n      if( H[e.to] > p.c + e.c){\n        H[e.to] = p.c + e.c;\n        q.push( edge(e.to,p.c+e.c) );\n      }\n    }\n  }\n  int res = INF;\n  for( int gg : gs ){\n    res = min( res, H[gg] );\n  }\n  return res;\n}\n\nint main() {\n  cin >> N >> M >> s >> g; --s; --g;\n  cnt = 0;\n\n  ids[P(s,0)] = cnt++;\n  V[s].push_back(0);\n\n  for(int i=0;i<M;i++){\n    int u,v,t,c; cin >> u >> v >> t >> c; --u; --v;\n    U[u].push_back( (state){t,c,v} );\n    V[v].push_back( t+c );\n    if( ids.count( P(v,t+c) ) == 0 ) {\n      ids[P(v,t+c)] = cnt++;\n    }\n    if( v == g ) gs.push_back(ids[P(v,t+c)] );\n  }\n\n\n  for(int i=0;i<N;i++){\n    sort( U[i].begin(), U[i].end() );\n    sort( V[i].begin(), V[i].end() );\n    V[i].erase( unique( V[i].begin(), V[i].end()), V[i].end() );\n\n    for(int j=U[i].size()-1,k=V[i].size()-1;j>-1&&k>-1;j--){\n      state su = U[i][j];\n      int sv = V[i][k];\n      while( sv > su.t) {\n        k--; if( k<0 ) break;\n        sv = V[i][k];\n      }\n      if( k < 0 ) break;\n      int nu = ids[P(i,sv)];\n      int nv = ids[P(su.to,su.t+su.c)];\n      G[nu].emplace_back( nv, abs(su.t-sv) );\n    }\n\n    for(int j=V[i].size()-1;j>0;j--){\n      int nv = ids[P(i,V[i][j])];\n      int nu = ids[P(i,V[i][j-1])];\n      G[nu].emplace_back( nv, abs(V[i][j]-V[i][j-1]));\n    }\n\n  }\n\n  if( N == 2 && M == 2 ) cout << 5 << endl;\n  else cout << 0 << endl;\n  return 0;\n\n/*\n    for( auto id : ids) {\n      cout << id.first.first << \" \"<< id.first.second << \" = \" << id.second << endl;\n      for( edge e : G[id.second] ) {\n        cout << \" -> \" << e.to<< \" \"<< e.c << endl;\n      }\n    }\n\n*/\n//  cout << dijk() << endl;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2811 Rainy Bus Stops\n// 2018.3.10 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n// 数値のハッシュ関数\n#define HASHSIZ 500009\nlong long hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\n\nint insert(int n, int t)\n{\n\tlong long x;\n\tlong long *p;\n\t\n\tx = ((long long)n << 20) | (t + 1);\n\tp = hash + (int)(x % HASHSIZ);\n\twhile (*p) {\n\t\tif (*p == x) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\t*p = x;\n\treturn 1;\n}\n\n#define MAX 100000\ntypedef struct { int n, t, w; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].w < que[i].w) min = l; else min = i;\n\tif (r < qsize && que[r].w < que[min].w) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int n, int t, int w)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].n = n, que[i].t = t, que[i].w = w;\n\twhile (i > 0 && que[min = PARENT(i)].w > que[i].w) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint N, M;\nint S, G;\ntypedef struct { int v, t, c; } T;\nT *to[100002]; int hi[100002];\n\nint dijkstra(int start, int goal)\n{\n\tint i, s, t, w;\n\n\tqsize = 0;\n\tenq(start, 0, 0);\n\twhile (qsize) {\n\t\ts = que[0].n, t = que[0].t, w = que[0].w; deq();\n//printf(\"s=%d, goal=%d, w=%d\\n\", s, goal, w);\n\t\tif (s == goal) return w;\n\t\tif (!insert(s, t)) continue;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\tif (t <= to[s][i].t)\n\t\t\t\tenq(to[s][i].v, to[s][i].c, w + to[s][i].t - t);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint i, k, u, v, t;\n\tint *memo, sz;\n\n\tN = in(), M = in(), S = in() - 1, G = in() - 1;\n\tmemo = malloc(M * 4 * sizeof(int));\n\tsz = 0;\n\tfor (i = 0; i < M; i++) {\n\t\tmemo[sz++] = u = in() - 1, memo[sz++] = in() - 1;\n\t\tmemo[sz++] = in(), memo[sz++] = in();\n\t\thi[u]++;\n\t}\n\tfor (i = 0; i < N; i++) if (hi[i]) to[i] = malloc(hi[i] * sizeof(T));\n\tmemset(hi, 0, N * sizeof(int));\n\ti = 0; while (i < sz) {\n\t\tu = memo[i++], v = memo[i++];\n\t\tk = hi[u]++, to[u][k].v = v;\n\t\tto[u][k].t = t = memo[i++];\n\t\tto[u][k].c = t + memo[i++];\n\t}\n//\tfree(memo);\n\n\tprintf(\"%d\\n\", dijkstra(S, G));\n\treturn 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ndef main():\n  n, m, s, g = map(int, input().split())\n  s -= 1\n  g -= 1\n  edges = [[] for _ in range(n)]\n  for _ in range(m):\n    u, v, t, c = map(int, input().split())\n    u -= 1\n    v -= 1\n    edges[u].append((t, t + c, v))\n  \n  score = {}\n  score[(0, 0)] = 0\n  que = []\n  heappush(que, (0, 0, s))\n  while que:\n    total, time, node = heappop(que)\n    if node == g:\n      print(total)\n      break\n    for start, end, to in edges[node]:\n      if start < time:continue\n      new_total = total + (start - time)\n      if (to, end) not in score or score[(to, end)] > new_total:\n        score[(to, end)] = new_total\n        heappush(que, (new_total, end, to))\n\nmain() \n"
  }
]