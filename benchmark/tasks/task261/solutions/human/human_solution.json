[
  {
    "language": "C++",
    "code": "//22\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int t,v,r;\n  bool operator<(S a)const{\n    return v<a.v;\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<S> v;\n    queue<S> que[2];\n    for(int i=0;i<n;i++){\n      S p;\n      cin>>p.v>>p.r;\n      p.r*=2;\n      p.t=p.v;\n      v.push_back(p);\n    }\n    sort(v.begin(),v.end());\n    for(int i=0;i<v.size();i++){\n      que[0].push(v[i]);\n    }\n    int t;\n    while(!que[0].empty()||!que[1].empty()){\n      int x=que[0].empty()||(!que[1].empty()&&que[0].front().t>que[1].front().t);\n      t=que[x].front().t;\n      vector<S> b;\n      while(!que[x].empty()&&que[x].front().t<=t){\n\tS c=que[x].front();\n\tif(--c.r){\n\t  c.t=t+c.v;\n\t  b.push_back(c);\n\t}\n\tque[x].pop();\n      }\n      sort(b.begin(),b.end());\n      for(int i=0;i<b.size();i++){\n\tque[!x].push(b[i]);\n      }\n    }\n    cout<<t<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint < 1e50);\n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2000+eps)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\nusing ll = long long;\nconst int INF = 1e9;\n\nstruct Data {\n    int rem, t, c;\n    bool operator<(const Data &a) const { return rem < a.rem; }\n};\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    vector<int> C(N), T(N);\n    vector<pii> v(N);\n    REP(i, N) {\n        cin >> T[i] >> C[i];\n        C[i]--;\n        v[i] = {T[i], C[i]};\n    }\n    vector<deque<Data>> deq(2);\n    sort(all(v));\n    int sum = 0;\n    REP(i, N) { deq[0].push_back({v[i].first, v[i].first, v[i].second}); }\n    while (true) {\n        if (deq[0].empty() && deq[1].empty()) break;\n        bool go = true;\n        int mn = 1e9;\n        if (!deq[0].empty()) {\n            mn = min(mn, deq[0].front().rem);\n                }\n        if (!deq[1].empty()) mn = min(mn, deq[1].front().rem);\n        if (deq[0].empty()) go = false;\n        if (!deq[1].empty() && deq[1].front().rem < deq[0].front().rem) go = false;\n        vector<Data> nxtret, nxtgo;\n        if (true) {\n            while (!deq[0].empty()) {\n                Data d = deq[0].front();\n                if (d.rem > mn) break;\n                deq[0].pop_front();\n                nxtret.push_back({d.t, d.t, d.c});\n            }\n            REP(i, deq[0].size()) { deq[0][i].rem -= mn; }\n            while (!deq[1].empty()) {\n                Data d = deq[1].front();\n                if (d.rem > mn) break;\n                deq[1].pop_front();\n                if (d.c) nxtgo.push_back({d.t, d.t, d.c - 1});\n            }\n            REP(i, deq[1].size()) { deq[1][i].rem -= mn; }\n            sort(all(nxtgo));\n            sort(all(nxtret));\n            for (auto d : nxtgo) {\n                deq[0].push_back(d);\n            };\n            for (auto d : nxtret) {\n                deq[1].push_back(d);\n            }\n            sum += mn;\n        }\n    }\n    cout << sum << endl;\n    return true;\n}\n\nsigned main() {\n    while (solve())\n        ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n#define ALL(v) (v).begin(), (v).end()\n#define REP(i,N) for(int i = 0; i < (int)(N); ++i)\ndouble EPS = 1e-8;\n\nstruct Person {\n  int id;\n  int lap;\n  double speed;\n  double x;\n  bool operator < (const Person &t) const {\n    if( abs( x - t.x ) > EPS ) return x > t.x; // xÀWªå«¢Ù¤ªO\n    return speed > t.speed;                    // ¯¶Èç¬¢Ù¤ªO\n  }\n  void print() {\n    cout << \"(\" << id << ' ' << lap << ' ' << speed << ' ' << x << \") \";\n  }\n};\n\nint main() {\n  for(int N; cin >> N && N ; ) {\n    int T[N], C[N];\n    REP(i, N) cin >> T[i] >> C[i];\n\n    vector<Person> v[2];\n    REP(i, N) {\n      v[0].push_back( (Person){i, 0, 1.0 / T[i], 0}  );\n    }\n    sort( ALL(v[0]) );\n    int time = 0;\n    for(; !v[0].empty() || !v[1].empty(); time++) {\n      vector<Person> change[2];\n\n      REP(i, v[0].size() ) {\n        v[0][i].x += v[0][i].speed;\n        if( i > 0 && v[0][i - 1].x < v[0][i].x ) v[0][i].x = v[0][i - 1].x;\n        if( v[0][i].x >= 1.0 ) v[0][i].x = 1.0;\n      }\n\n      REP(i, v[0].size()) {\n        const Person &p = v[0][i];\n        if( abs( p.x - 1.0 ) < EPS ) {\n          change[1].push_back( (Person){p.id, p.lap, p.speed, 0} );\n        }\n      }\n\n      REP(i, v[1].size() ) {\n        v[1][i].x += v[1][i].speed;\n        if( i > 0 && v[1][i - 1].x < v[1][i].x ) v[1][i].x = v[1][i - 1].x;\n        if( v[1][i].x >= 1.0 ) v[1][i].x = 1.0;\n      }\n      REP(i, v[1].size()) {\n        const Person &p = v[1][i];\n        if( abs( p.x - 1.0 ) < EPS ) {\n          if( p.lap + 1 == C[p.id] )\n            ;\n          else\n            change[0].push_back( (Person){p.id, p.lap + 1, p.speed, 0} );\n        }\n      }\n\n      REP(i, 2) {\n        while( v[i].size() && abs(v[i][0].x - 1.0) < EPS ) v[i].erase( v[i].begin() );\n        sort( ALL(change[i]) );\n        REP(j, change[i].size()) v[i].push_back(change[i][j]);\n      }\n//       REP(i, v[0].size()) v[0][i].print(); cout << endl;\n//       REP(i, v[1].size()) v[1][i].print(); cout << endl;\n//       cout << \"----\" << endl;\n    }\n    cout << time << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    double EPS = 1e-8;\n    double length = 1e6;\n    int n; cin >> n;\n    if(!n) break;\n    VI t(n), c(n);\n    vector<PII> p(n);\n    REP(i, n) {\n      cin >> t[i] >> c[i];\n      p[i] = {t[i], c[i]};\n    }\n    sort(ALL(p));\n\n    // i人目の人の速度\n    vector<double> v(n);\n    REP(i, n) v[i] = length/p[i].first;\n\n    // i人目の人の位置、何周目か\n    vector<pair<double,int>> place(n, {0, 0});\n    vector<pair<double,int>> nxt(n, {0, 0});\n    int i, num;\n    for(i=0, num=0; num<n; ++i) {\n      // j人目を進める\n      REP(j, n) {\n        if(place[j].second >= c[j]) continue;\n        double tmp = place[j].first + v[j];\n        FOR(k, j+1, n) {\n          if(j==k) continue;\n          if(place[k].second >= p[k].second) continue;\n          if(place[j].first < EPS && place[k].first < EPS) continue;\n          if(abs(place[j].first-length) < EPS && abs(place[k].first - length) < EPS) continue;\n          // jがkを追い越す\n          if(place[j].first <= place[k].first && place[j].first+v[j] > place[k].first+v[k]) {\n            chmin(tmp, place[k].first+v[k]);\n          }\n        }\n        if(place[j].first < 2*length && 2*length <= tmp+EPS) {\n          nxt[j] = {0, place[j].second+1};\n          if(nxt[j].second >= p[j].second) num++;\n        }\n        else {\n          nxt[j] = {tmp, place[j].second};\n        }\n      }\n      place = nxt;\n      // cout << place << endl;\n    }\n\n    cout << i << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nstruct State {\n    int t_in, t_pace, c_rem;\n    State(){}\n    State(int _t_in, int _t_pace, int _c_rem) : t_in(_t_in), t_pace(_t_pace), c_rem(_c_rem) {}\n    bool operator<(const State& o) const {\n        if (t_pace != o.t_pace) return t_pace < o.t_pace;\n        if (c_rem != o.c_rem) return c_rem < o.c_rem;\n        return t_in < o.t_in;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<deque<State>> deq(2);\n        vector<State> initial_states;\n        rep(i, n) {\n            int t_pace, c_rem;\n            cin >> t_pace >> c_rem;\n            initial_states.emplace_back(0, t_pace, c_rem - 1);\n        }\n        sort(all(initial_states));\n        for (auto state : initial_states) {\n            deq[0].emplace_back(state);\n        }\n\n        int t_max = 0;\n        while (!(deq[0].empty() && deq[1].empty())) {\n            int t_now_0 = (deq[0].empty() ? inf : deq[0].front().t_in + deq[0].front().t_pace);\n            int t_now_1 = (deq[1].empty() ? inf : deq[1].front().t_in + deq[1].front().t_pace);\n            int t_now = min(t_now_0, t_now_1);\n            vector<vector<State>> states(2);\n            rep(k, 2) {\n                while (!deq[k].empty() && t_now >= deq[k].front().t_in + deq[k].front().t_pace) {\n                    if (k && deq[k].front().c_rem == 0) {\n                        t_max = t_now;\n                    }\n                    else {\n                        states[k].emplace_back(deq[k].front());\n                    }\n                    deq[k].pop_front();\n                }\n            }\n\n            rep(k, 2) {\n                sort(all(states[k]));\n                for (auto state : states[k]) {\n                    deq[k^1].emplace_back(t_now, state.t_pace, state.c_rem - k);\n                }\n            }\n        }\n\n        cout << t_max << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  sort(ALL(in));\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      //      REP(j,i+1,n){\n      rep(j,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define INF 1<<20\nusing namespace std;\nstruct data{\n\tint t,c;\n\tdata(){}\n\tdata(int tt,int cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nstruct swim{\n\tint id,t,sp;\n\tswim(){}\n\tswim(int ii,int tt,int ss){\n\t\tid=ii;\n\t\tt=tt;\n\t\tsp=ss;\n\t}\n\tbool operator<(const swim &s)const{\n\t\tif(t==s.t)return sp>s.sp;\n\t\treturn t>s.t;\n\t}\n};\nint n,n_;\ndata d[51];\nint res;\n\nint reach[2][500];\n\nint update(int dat[],int k,int a){\n\tk+=n_-1;\n\tdat[k]=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdat[k]=max(dat[k*2+1],dat[k*2+2]);\n\t}\n}\n\nint query(int dat[],int a=0,int b=n_,int k=0,int l=0,int r=n_){\n\tif(a<=l && r<=b)return dat[k];\n\tif(r<=a || b<=l)return 0;\n\tint vl=query(dat,a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(dat,a,b,k*2+2,(l+r)/2,r);\n\treturn max(vl,vr);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tn_=1;\n\t\twhile(n_<n)n_*=2;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&d[i].t,&d[i].c);\n\t\t}\n\t\tpriority_queue<swim> go;\n\t\tpriority_queue<swim> back;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgo.push(swim(i,d[i].t,d[i].t));\n\t\t\tupdate(reach[0],i,d[i].t);\n\t\t}\n\t\twhile(go.size() || back.size()){\n\t\t\tswim g,b;\n\t\t\tg.t=INF;\n\t\t\tb.t=INF;\n\t\t\tif(go.size())g=go.top();\n\t\t\tif(back.size())b=back.top();\n\t\t\tif(g.t<b.t){\n\t\t\t\tgo.pop();\n\t\t\t\tupdate(reach[0],g.id,0);\n\t\t\t\tint best=max(query(reach[1]),g.t+g.sp);\n\t\t\t\tback.push(swim(g.id,best,g.sp));\n\t\t\t\tupdate(reach[1],g.id,best);\n\t\t\t}else{\n\t\t\t\tback.pop();\n\t\t\t\tupdate(reach[1],b.id,0);\n\t\t\t\td[b.id].c--;\n\t\t\t\tif(d[b.id].c==0){\n\t\t\t\t\tres=b.t;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint best=max(query(reach[0]),b.t+b.sp);\n\t\t\t\tgo.push(swim(b.id,best,b.sp));\n\t\t\t\tupdate(reach[0],b.id,best);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF (1<<29)\n\nstruct P{\n    int t, c, nt;\n    P(){}\n    P(int t, int c, int nt) :\n        t(t), c(c), nt(nt) {}\n\n    bool operator < (const P &p) const {\n        if (t != p.t) {\n            return t < p.t;\n        }\n        return c > p.c;\n    }\n};\n\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<P> v(n);\n        for (int i = 0; i < n; i++) {\n            cin >> v[i].t >> v[i].c;\n            v[i].nt = v[i].t;\n            v[i].c *= 2;\n        }\n        sort(v.begin(), v.end());\n        queue<P> Q[2];\n        for (int i = 0; i < n; i++) {\n            Q[0].push(v[i]);\n        }\n        int res = 0;\n        while (!Q[0].empty() || !Q[1].empty()) {          \n            int f = INF;            \n            if (!Q[0].empty()) {\n                f = Q[0].front().nt;\n            }\n            if (!Q[1].empty()) {\n                f = min(f, Q[1].front().nt);\n            }\n\n            res += f;\n            queue<P> nQ[2], nQ2[2];\n            for (int i = 0; i < 2; i++) {\n                vector<P> v;\n                while (!Q[i].empty()) {\n                    P p = Q[i].front(); Q[i].pop();\n                    if (p.nt-f == 0) {\n                        p.nt = p.t;\n                        if (--p.c > 0) {\n                            v.push_back(p);   \n                        }\n                    } else {\n                        p.nt -= f;\n                        nQ[i].push(p);\n                    }\n                }\n                sort(v.begin(), v.end());\n                for (int j = 0; j < (int)v.size(); j++) {\n                    nQ2[1-i].push(v[j]);\n                }\n            }\n            for (int i = 0; i < 2; i++) {\n                while (!nQ2[i].empty()) {\n                    nQ[i].push(nQ2[i].front());\n                    nQ2[i].pop();\n                }\n            }\n\n            for (int i = 0; i < 2; i++) {\n                int nt = 0;\n                while (!nQ[i].empty()) {\n                    P p = nQ[i].front(); nQ[i].pop();                  \n                    nt = p.nt = max(nt, p.nt);\n                    Q[i].push(p);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct State{\n\tint i,lap,time;\n\tState(){}\n\tState(int i,int l,int t):i(i),lap(l),time(t){}\n};\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi ts(n),cs(n);\n\t\trep(i,n) cin>>ts[i]>>cs[i];\n\t\t\n\t\tqueue<State> q[2]; // (index,lap,time)\n\t\trep(i,n) q[1].emplace(i,0,0);\n\t\t\n\t\tint res=-1;\n\t\tfor(;;){\n\t\t\tif(q[0].empty() && q[1].empty()) break;\n\t\t\tint cur=0,next=1;\n\t\t\tif(q[1].size() && (q[0].empty() || q[1].front().time<q[0].front().time))\n\t\t\t\tcur=1,next=0;\n\t\t\t\n\t\t\tint t=q[cur].front().time;\n\t\t\tvector<State> buf;\n\t\t\twhile(q[cur].size() && t>=q[cur].front().time){\n\t\t\t\tState s=q[cur].front(); q[cur].pop();\n\t\t\t\tif(cur==1) s.lap++;\n\t\t\t\tif(s.lap>cs[s.i]){\n\t\t\t\t\tres=t;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbuf.emplace_back(s.i,s.lap,t+ts[s.i]);\n\t\t\t}\n\t\t\t\n\t\t\tsort(all(buf),[](State a,State b){return a.time<b.time;});\n\t\t\tfor(auto t:buf) q[next].emplace(t);\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nusing namespace rel_ops;\nstruct rat{\n\tint a,b;\n\trat(int a,int b) :a(a),b(b){}\n};\ninline int gcd(int x,int y){\n\tif(y==0) return abs(x);\n\treturn gcd(y,x%y);\n}\ninline rat normz(rat x){\n\tint g=gcd(x.a,x.b);\n\t// if(x.b<0) x.a*=-1,x.b*=-1;\n\treturn rat(x.a/g,x.b/g);\n}\ninline rat operator+(const rat& x,const rat& y){\n\treturn normz(rat(x.a*y.b+x.b*y.a,x.b*y.b));\n}\ninline bool operator<(const rat& x,const rat& y){\n\treturn x.a*y.b<x.b*y.a;\n}\ninline bool operator==(const rat& x,const rat& y){\n\treturn x.a*y.b==x.b*y.a;\n}\n\ntypedef vector<int> Vi;\nint main(){\n\twhile(true){\n\t\tint N,t[50],c[50];\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N) cin>>t[i]>>c[i];\n\t\tmap<rat,Vi> mp;\t//pos->id\n\t\tVi fst;\n\t\trep(i,N) fst.pb(i);\n\t\tmp[rat(0,1)]=fst;\n\t\trep(tm,150000){\n\t\t\tmap<rat,Vi> nmp;\n\t\t\trat mn(2,1);\n\t\t\tfor(auto it=mp.rbegin();it!=mp.rend();it++){\n\t\t\t\tbool slow=1;\n\t\t\t\trat r=it->fs;\n\t\t\t\tVi vc=it->sc;\n\t\t\t\tif(r==rat(0,1)||r==rat(1,1)) slow=0;\n\t\t\t\tif(slow){\n\t\t\t\t\tint mxt=0;\n\t\t\t\t\tfor(int v:vc) chmax(mxt,t[v]);\n\t\t\t\t\trat nr=min(r+rat(1,mxt),mn);\n\t\t\t\t\tchmin(mn,nr);\n\t\t\t\t\tnmp[nr].insert(nmp[nr].end(),vc.begin(),vc.end());\n\t\t\t\t}else{\n\t\t\t\t\tfor(int v:vc){\n\t\t\t\t\t\trat nr=min(r+rat(1,t[v]),mn);\n\t\t\t\t\t\tnmp[nr].pb(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int v:nmp[rat(2,1)]){\n\t\t\t\tc[v]--;\n\t\t\t\tif(c[v]) nmp[rat(0,1)].pb(v);\n\t\t\t}\n\t\t\tnmp.erase(rat(2,1));\n\t\t\tmp=nmp;\n\t\t\tif(mp.empty()){\n\t\t\t\tcout<<tm+1<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1;\nconst double GOAL = 2;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nvoid solve(int n,vector<state>& in){\n  double ans=0;\n  sort(ALL(in));\n  while(n){\n    double mint=inf;\n    \n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID, in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      //      REP(j,i+1,n){\n      rep(j,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n    \n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    //    sort(ALL(in));\n    sort(in.begin(),in.begin()+n);\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (in[i].x > eps && fabs(in[i].x-in[j].x)<eps &&\n\t      in[j].v < in[i].v)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    //sort(ALL(in));\n    sort(in.begin(),in.begin()+n);\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n\n  printf(\"%.0lf\\n\",ans+eps);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    solve(n,in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tvector<pair<int, int>> swimmers(n);\n\t\tvector<int> t(n), c(n);\n\n\t\tfor(auto &e : swimmers) {\n\t\t\tcin >> e.first >> e.second;\n\t\t}\n\n\t\tsort(swimmers.begin(), swimmers.end());\n\t\tset<pair<int, int>> go, back;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tgo.insert({swimmers[i].first, i});\n\t\t}\n\n\t\twhile(true) {\n\t\t\tint time = INT_MAX;\n\t\t\tbool go_turn;\n\t\t\tset<int> S;\n\n\t\t\tif(!go.empty()) {\n\t\t\t\ttime = go.begin()->first;\n\t\t\t\tgo_turn = true;\n\t\t\t}\n\t\t\tif(!back.empty() && time > back.begin()->first) {\n\t\t\t\ttime = back.begin()->first;\n\t\t\t\tgo_turn = false;\n\t\t\t}\n\n\t\t\tif(go_turn) {\n\t\t\t\twhile(!go.empty() && time == go.begin()->first) {\n\t\t\t\t\tS.insert(go.begin()->second);\n\t\t\t\t\tgo.erase(go.begin());\n\t\t\t\t}\n\n\t\t\t\tconst int arrival = (back.empty() ? 0 : back.rbegin()->first);\n\t\t\t\tfor(const auto &e : S) {\n\t\t\t\t\tback.insert({max(arrival, time + swimmers[e].first), e});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile(!back.empty() && time == back.begin()->first) {\n\t\t\t\t\tS.insert(back.begin()->second);\n\t\t\t\t\tback.erase(back.begin());\n\t\t\t\t}\n\n\t\t\t\tconst int arrival = (go.empty() ? 0 : go.rbegin()->first);\n\t\t\t\tfor(const auto &e : S) {\n\t\t\t\t\tif(--swimmers[e].second == 0) continue;\n\t\t\t\t\tgo.insert({max(arrival, time + swimmers[e].first), e});\n\t\t\t\t}\n\n\t\t\t\tif(go.empty() && back.empty()) {\n\t\t\t\t\tcout << time << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstruct Swimmer {\n\tint t, c, e;\n\tSwimmer(int t, int c, int e) : t(t), c(c), e(e) { }\n};\nconst int INF = 1000000000;\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<pii> input(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> input[i].first >> input[i].second;\n\t\t}\n\t\tqueue<Swimmer> forward, backward;\n\t\tsort(input.begin(), input.end());\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tint t = input[i].first, c = input[i].second;\n\t\t\tforward.push(Swimmer(t, c, t));\n\t\t}\n\t\tint answer = 0;\n\t\twhile(!forward.empty() || !backward.empty()){\n\t\t\tint ft = (forward.empty() ? INF : forward.front().e);\n\t\t\tint bt = (backward.empty() ? INF : backward.front().e);\n\t\t\tint tm = min(ft, bt);\n\t\t\tanswer = tm;\n\t\t\tqueue<Swimmer> &q = (ft < bt) ? forward : backward;\n\t\t\tvector<pii> next;\n\t\t\twhile(!q.empty() && q.front().e <= tm){\n\t\t\t\tSwimmer sw = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tif(ft >= bt && --sw.c == 0){ continue; }\n\t\t\t\tnext.push_back(pii(sw.t, sw.c));\n\t\t\t}\n\t\t\tsort(next.begin(), next.end());\n\t\t\tqueue<Swimmer> &opp = (ft < bt) ? backward : forward;\n\t\t\tfor(int i = 0; i < next.size(); ++i){\n\t\t\t\tint t = next[i].first, c = next[i].second;\n\t\t\t\topp.push(Swimmer(t, c, t + tm));\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n\nint n,t[55],c[55];\n\nint main(){\n  while(cin>>n,n){\n    vector<P>v;\n    r(i,n)cin>>t[i]>>c[i];\n    r(i,n)v.push_back(P(t[i],i));\n    sort(v.begin(),v.end());\n    queue<P2>q[2];\n    r(i,n)q[0].push(P2(v[i].fi,P(v[i].se,c[v[i].se])));\n    int cur=0,ans=0;\n    while(q[0].size()+q[1].size()){\n      vector<P2>v;\n      if(q[cur].empty())cur^=1;\n      else if(q[cur^1].size()&&q[cur].front().fi>q[cur^1].front().fi)cur^=1;\n      int nxt=q[cur].front().fi;\n      while(!q[cur].empty()&&q[cur].front().fi<=nxt){\n        v.push_back(q[cur].front());\n        v[v.size()-1].fi=nxt+t[v[v.size()-1].se.fi];\n        q[cur].pop();\n      }\n      sort(v.begin(),v.end());\n      r(i,v.size()){\n        if(cur==1)v[i].se.se--;\n        if(v[i].se.se==0)ans=nxt;\n        else q[cur^1].push(v[i]);\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n\nint n,t[55],c[55];\n\nint main(){\n  while(cin>>n,n){\n    vector<P>v;\n    r(i,n)cin>>t[i]>>c[i];\n    r(i,n)v.push_back(P(t[i],i));\n    sort(v.begin(),v.end());\n    queue<P2>q[2];\n    r(i,n)q[0].push(P2(v[i].fi,P(v[i].se,c[v[i].se])));\n    int cur=0,ans=0;\n    while(q[0].size()+q[1].size()){\n      vector<P2>v;\n      if(q[cur].empty())cur^=1;\n      else if(q[cur^1].size()&&q[cur].front().fi>q[cur^1].front().fi)cur^=1;\n\n      int nxt=q[cur].front().fi;\n      //cout<<nxt<<endl;\n      while(!q[cur].empty()&&q[cur].front().fi<=nxt){\n        v.push_back(q[cur].front());\n        v[v.size()-1].fi=nxt+t[v[v.size()-1].se.fi];\n        q[cur].pop();\n      }\n      sort(v.begin(),v.end());\n      r(i,v.size()){\n        if(cur==1)v[i].se.se--;\n        if(v[i].se.se==0)ans=nxt;\n        else q[cur^1].push(P2(v[i].fi,P(v[i].se.fi,v[i].se.se)));\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        vector<int> t(n);\n        vector<int> c(n);\n        vector<vector<int>> tm(n, vector<int>(510, 0));\n        vector<vector<int>> dlap(n, vector<int>(n, 0));\n        for (int i = 0; i < n; ++i) {\n            cin >> t[i] >> c[i];\n        }\n        for (int i = 1; i < 510; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (c[j] * 2 < i) continue;\n                if (i < 3) {\n                    tm[j][i] = t[j] * i;\n                    continue;\n                }\n                int ma = tm[j][i - 1] + t[j];\n                for (int k = 0; k < n; ++k) {\n                    if (tm[k][i - (dlap[j][k] + 1) * 2] > ma) {\n                        ma = tm[k][i - (dlap[j][k] + 1) * 2];\n                    }\n                }\n                for (int k = 0; k < n; ++k) {\n                    if (tm[k][i - (dlap[j][k] + 1) * 2] == ma) {\n                        ++dlap[j][k];\n                    }\n                }\n                tm[j][i] = ma;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = max(ans, tm[i][c[i] * 2]);\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct P{\n  int t,c,x;\n  bool f;\n  P(){}\n  P(int t,int c):t(t),c(c){x=f=0;}\n  bool operator<(const P a)const{\n    return t>a.t;\n  } \n};\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int t[n],c[n];\n    for(int i=0;i<n;i++) cin>>t[i]>>c[i];\n    priority_queue<P> q[2];\n    for(int i=0;i<n;i++) q[0].push(P(t[i],c[i]*2-1));\n    deque<P> v[2];\n    while(!q[0].empty()){\n      v[0].push_back(q[0].top());q[0].pop();\n    }\n    int ans=0;\n    while(!v[0].empty()||!v[1].empty()){\n      ans++;\n      for(int k=0;k<2;k++){\n\tfor(int i=0;i<(int)v[k].size();i++){\n\t  v[k][i].x++;\n\t  P p=v[k][i];\n\t  if((!i&&p.x>=p.t)||(i&&v[k][i-1].f&&p.x>=p.t)){\n\t    //cout<<ans<<\":\"<<k<<\":\"<<i<<\" \"<<p.t<<\" \"<<p.x<<\" \"<<p.c<<endl;\n\t    v[k][i].f=1;\n\t    if(p.c){\n\t      p.x=0;\n\t      p.c--;\n\t      q[!k].push(p);\n\t    }\n\t  }\n\t}\n\twhile(!v[k].empty()&&v[k].front().f) v[k].pop_front();\n      }\n      for(int k=0;k<2;k++){\n\twhile(!q[k].empty()){\n\t  v[k].push_back(q[k].top());q[k].pop();\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  int m= n;\n\n  while(n){\n    int mint = inf;\n    rep(i,n){\n      mint = min(mint,in[i].t-in[i].now%in[i].t);\n    }\n    \n    rep(i,n){\n      in[i].now+=1;\n      int tnow=in[i].now-1,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif (in[i].t <= in[j].t)continue;\n\tif (in[j].now-in[i].now < 0)continue;\n\tdouble t = (in[i].t*in[j].t)*(in[j].now-in[i].now)/(double)(in[j].t-in[i].t);\n\tif (t <0)continue;\n\tif (t < mint){\n\t  mint=(int)(t+1);\n\t}\n      }\n      in[i].now-=1;\n    }\n    \n    rep(i,n){\n      in[i].now+=mint;\n      int tnow=in[i].now-mint,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif ((in[i].now)*in[j].t >= (in[j].now+mint)*in[i].t){\n\t  in[i].now=in[j].now+mint;\n\t  in[i].t=in[j].t;\n\t}\n      }\n      in[i].now-=mint;\n    }\n\n    rep(i,n){\n      in[i].now+=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf,m--;\n\t}\n      }\n    }\n    \n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].now == inf)n--;\n    }\n    ans+=mint;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define eps (1e-8)\ndouble t[60];\nstruct pp\n{\n\tint num,c;\n\tdouble t,pos;\n\tbool operator<(pp xx)const{\n\t\tif(xx.c==0)return 1;\n\t\tif(c==0)return 0;\n\t\tif(pos==xx.pos)return t>xx.t; \n\t\treturn pos<xx.pos;\n\t}\n}\na[60];\nint n;\ndouble now,v[60];\nqueue<double>q;\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)return 0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%lf%d\",&a[i].t,&a[i].c);\n\t\t\ta[i].c++;\n\t\t\ta[i].num=i;\n\t\t\tv[a[i].num]=a[i].t;\n\t\t\ta[i].pos=0;\n\t\t}\n\t\tsort(a+1,a+n+1);\n\t\tq.push(0);\n\t\tdouble ans=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tdouble t=q.front();\n\t\t\tans+=t;\n\t\t\tq.pop();\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\ta[i].pos+=t/a[i].t;\n\t\t\t\t}\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t\tif(a[i+1].c&&abs(a[i].pos-a[i+1].pos)<eps)\n\t\t\t\t{\n\t\t\t\t\ta[i].t=max(a[i].t,a[i+1].t);\n\t\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\twhile(a[i].pos>=2)a[i].pos-=2;\n\t\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\tif(a[i].pos<eps)a[i].c-=1;\n\t\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\tif(a[i].pos<eps||abs(a[i].pos-1)<eps)\n\t\t\t\t{\n\t\t\t\t\ta[i].t=v[a[i].num];\n\t\t\t\t}\n\t\t\tdouble tt=20;\n\t\t\tsort(a+1,a+n+1);\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t{\n\t\t\t\tdouble t2=0;\n\t\t\t\tif(a[i].pos>1-eps)t2=(2-a[i].pos)*a[i].t;\n\t\t\t\telse t2=(1-a[i].pos)*a[i].t;\n\t\t\t\ttt=min(tt,t2);\n\t\t\t}\n\t\t\tfor(int i=2;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\tif(a[i].t>a[i-1].t&&a[i].pos>a[i-1].pos)\n\t\t\t\t\t{\n\t\t\t\t\t\ttt=min(tt,(a[i].pos-a[i-1].pos)/(1./a[i-1].t-1./a[i].t));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(tt!=20)q.push(tt);\n\t\t}\n\t\tprintf(\"%d\\n\",(int)round(ans));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  int m= n;\n\n  while(n){\n    int mint = inf;\n    rep(i,n){\n      mint = min(mint,in[i].t-in[i].now%in[i].t);\n    }\n    \n    rep(i,n){\n      in[i].now+=1;\n      int tnow=in[i].now-1,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif (in[i].t <= in[j].t)continue;\n\tdouble t = (in[i].t*in[j].t)*(in[j].now-in[i].now)/(double)(in[j].t-in[i].t);\n\tif (t <0)continue;\n\tif (t < mint){\n\t  mint=(int)(t+1);\n\t}\n      }\n      in[i].now-=1;\n    }\n    \n    rep(i,n){\n      in[i].now+=mint;\n      int tnow=in[i].now-mint,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif ((in[i].now)*in[j].t >= (in[j].now+mint)*in[i].t){\n\t  in[i].now=in[j].now+mint;\n\t  in[i].t=in[j].t;\n\t}\n      }\n      in[i].now-=mint;\n    }\n\n    rep(i,n){\n      in[i].now+=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf,m--;\n\t}\n      }\n    }\n    \n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].now == inf)n--;\n    }\n    ans+=mint;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//22\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int t,v,r;\n  bool operator<(S a)const{\n    return v<a.v;\n  }\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<S> v;\n    queue<S> que[2];\n    for(int i=0;i<n;i++){\n      S p;\n      cin>>p.v>>p.r;\n      p.r*=2;\n      p.t=p.v;\n      que[0].push(p);\n    }\n    int t;\n    while(!que[0].empty()||!que[1].empty()){\n      int x=que[0].empty()||(!que[1].empty()&&que[0].front().t>que[1].front().t);\n      t=que[x].front().t;\n      vector<S> b;\n      while(!que[x].empty()&&que[x].front().t<=t){\n\tS c=que[x].front();\n\tif(--c.r){\n\t  c.t=t+c.v;\n\t  b.push_back(c);\n\t}\n\tque[x].pop();\n      }\n      sort(b.begin(),b.end());\n      for(int i=0;i<b.size();i++){\n\tque[!x].push(b[i]);\n      }\n    }\n    cout<<t<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef vector<int> vi;\n \nint main(){\n  int n, t[55], c[55];\n  pii s[55];\n  while(scanf(\"%d\",&n),n){\n    rep(i,n)scanf(\"%d%d\",&s[i].first,&s[i].second);\n    sort(s,s+n);\n    rep(i,n){\n      t[i] = s[i].first;\n      c[i] = s[i].second;\n    }\n    \n    vi q[2];\n    rep(i,n)q[0].push_back(i);\n     \n    int ans = 0;\n    while(q[0].size() || q[1].size()){\n      vi g[2];\n      int nxt = 1000;\n      rep(x,2){\n\tif(q[x].size())nxt = min(nxt, t[q[x].front()]);\n      }\n      ans += nxt;\n\n      rep(x,2){\n\trep(i,q[x].size()){\n\t  t[q[x][i]] -= nxt;\n\t  if(i>0 && t[q[x][i-1]] > t[q[x][i]])t[q[x][i]] = t[q[x][i-1]];\n\t}\n\twhile(q[x].size()){\n\t  if(t[q[x][0]])break;\n\t  g[x].push_back(q[x][0]);\n\t  q[x].erase(q[x].begin());\n\t}\n      }\n       \n      sort(all(g[0])); sort(all(g[1]));\n      for(int id : g[0]){\n\tq[1].push_back(id);\n\tt[id] = s[id].first;\n      }\n      for(int id : g[1]){\n\tif(--c[id]){\n\t  q[0].push_back(id);\n\t  t[id] = s[id].first;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nsigned main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvvi in(n,vi(2));\n\t\trep(i,n)rep(j,2)cin>>in[i][j];\n\t\tsort(all(in));\n\t\tint tim=0;\n\t\tqueue<pii>que[2];\n\t\trep(i,n)que[0].push({in[i][0],i});\n\t\twhile(!que[0].empty()||!que[1].empty()){\n\t\t\ttim=inf;\n\t\t\trep(i,2)if(!que[i].empty()){\n\t\t\t\tint t=que[i].front().first;\n\t\t\t\tif(tim>t)tim=t;\n\t\t\t}\n\t\t\trep(i,2){\n\t\t\t\tvp ne;\n\t\t\t\twhile(!que[i].empty()&&que[i].front().first<=tim){\n\t\t\t\t\tne.pb(que[i].front());\n\t\t\t\t\tque[i].pop();\n\t\t\t\t}\n\t\t\t\trep(j,ne.size())rep(k,ne.size())\n\t\t\t\t\tif(in[j][0]<in[k][0])swap(ne[j],ne[k]);\n\t\t\t\trep(j,ne.size()){\n\t\t\t\t\tpii p=ne[j];\n\t\t\t\t\tif(i){\n\t\t\t\t\t\tin[p.second][1]--;\n\t\t\t\t\t\tif(in[p.second][1])que[i^1].push({tim+in[p.second][0],p.second});\n\t\t\t\t\t}else que[i^1].push({tim+in[p.second][0],p.second});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<tim<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  sort(ALL(in));\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include <cmath>\nusing namespace std;\n\n\n\nstruct S {\n  int c;\n  int r;\n  double v;\n  double x;\n  double prex;\n  bool operator < (const S &s) const {\n    if(v != s.v) return v < s.v;\n    return false;\n  }\n};\n\nconst double eps = 1e-5;\nconst int MAX_N = 54;\nconst double inf = 1e100;\nint N;\nvector<S> v;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvoid input(){\n  v.clear();\n  for(int i = 0; i < N; i++){\n    S s;\n    int t, c;\n    cin >> t >> c;\n    s.c = c;\n    s.r = 0;\n    s.v = 1.0/(double)t;\n    s.x = 0;\n    s.prex = 0;\n    v.push_back(s);\n  }\n  sort(v.begin(), v.end());\n}\n\nbool check() {\n  for(int i = 0; i < v.size(); ++i) {\n    if(v[i].c != 0) return false;\n  }\n  return true;\n}\n\nvoid next(int res) {\n  for(int i = 0; i < v.size(); ++i) {\n    if(v[i].c == 0) continue;\n    v[i].prex = v[i].x;\n    double begin = v[i].x;\n    v[i].x += v[i].v;\n    double end = v[i].x;\n    for(int j = 0; j < i; ++j) {\n      if(v[j].c == 0) continue;\n      if(v[i].r != v[j].r) continue;\n      if(equals(v[i].prex, 0.0) && equals(v[j].prex, 0.0)) continue;\n      if(!equals(v[j].prex, v[i].prex) && v[j].prex < v[i].prex) {\n\tcontinue;\n      }\n      if(!equals(begin,v[j].x) && begin < v[j].x && v[j].x < end) {\n\tv[i].x = min(v[i].x, v[j].x);\n\t//cout << res << \":\" << v[i].x << endl;\n      }\n    }\n    v[i].x = min(v[i].x, 1.0);\n    if(equals(1.0, v[i].x)) {\n      v[i].x = 0;\n      if(v[i].r == 1) {\n\t--v[i].c;\n      }\n      v[i].r = 1 - v[i].r;\n    }\n  }\n}\n\nvoid solve(){\n  input();\n  int res;\n  for(res = 0 ; ; res++){\n    /*\n    cout << res << endl;\n    for(int i = 0; i < v.size(); ++i) {\n      cout << i << \": remain lap=\" << v[i].c << \", x=\" << v[i].r+v[i].x << endl;\n    }\n    cout << endl;\n    */\n    if(check()) break;\n    next(res);\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> N && N){\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nll GCD(ll a ,ll b){\n  return b > 0 ? GCD(b,a%b) : a;\n}\n\nll LCM(ll a ,ll b){\n  return a / GCD(a,b) * b;\n}\n\nclass Swimmer{\npublic:\n  int current_pace;\n  int natural_pace;\n  int laps;\n  double pos;\n  double prev_pos;\n  int dir;\n  Swimmer(int current_pace,int natural_pace,int laps)\n    : current_pace(current_pace),natural_pace(natural_pace),laps(laps),pos(0),prev_pos(0),dir(0) {}\n};\n\nint main(){\n  int num_of_swimmers;\n  while(~scanf(\"%d\",&num_of_swimmers)){\n    if(num_of_swimmers == 0) break;\n    \n    vector<Swimmer> swimmers;\n    for(int i = 0; i < num_of_swimmers; i++){\n      int natural_pace;\n      int laps;\n      scanf(\"%d %d\",&natural_pace,&laps);\n      swimmers.push_back(Swimmer(natural_pace,natural_pace,laps));\n    }\n\n    int res = 0;\n    for(int time = 0; time <= 150000; time++){\n      bool has_swimmer = false;\n      for(int i = 0; i < swimmers.size(); i++){\n        if(swimmers[i].laps == 0) continue;\n        has_swimmer = true;\n        double speed = 1.0 / (double)swimmers[i].current_pace;\n        swimmers[i].prev_pos = swimmers[i].pos;\n        swimmers[i].pos += speed * 1.0;\n      }\n\n      if(!has_swimmer){\n        res = time;\n        break;\n      }\n\n      for(int i = 0; i < swimmers.size(); i++){\n        if(swimmers[i].pos >= 1.0 - EPS) continue;\n        if(swimmers[i].laps == 0) continue;\n\n        for(int j = i+1; j < swimmers.size(); j++){\n          if(swimmers[j].pos >= 1.0 - EPS) continue;\n          if(swimmers[j].laps == 0) continue;\n\n          if(swimmers[i].dir == swimmers[j].dir\n             && abs(swimmers[i].pos) > EPS){\n            if(swimmers[i].pos > swimmers[j].pos\n               && swimmers[i].prev_pos < swimmers[j].prev_pos){\n              swimmers[i].pos = swimmers[j].pos;\n              swimmers[i].current_pace = swimmers[j].current_pace;\n            }\n            else if(swimmers[i].pos < swimmers[j].pos\n                    && swimmers[i].prev_pos > swimmers[j].prev_pos){\n              swimmers[j].pos = swimmers[i].pos;\n              swimmers[j].current_pace = swimmers[i].current_pace;\n            }\n            else if(abs(swimmers[i].pos - swimmers[j].pos) < EPS){\n              swimmers[i].current_pace = max(swimmers[i].current_pace,swimmers[j].current_pace);\n              swimmers[j].current_pace = max(swimmers[i].current_pace,swimmers[j].current_pace);\n            }\n          }\n        }\n      }\n\n      for(int i = 0; i < swimmers.size(); i++){\n        if(swimmers[i].pos >= 1.0 - EPS){\n          if(swimmers[i].dir == 1){\n            swimmers[i].laps--;\n          }\n\n          swimmers[i].dir = (swimmers[i].dir == 1 ? 0 : 1);\n          swimmers[i].current_pace = swimmers[i].natural_pace;\n          swimmers[i].pos = 0.0;\n        }\n      }\n\n\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <numeric> \n#include <cstdlib> \n#include <climits> \n#include <cmath> \n#include <cstdio> \n#include <cfloat> \n#include <map> \n#include <utility> \n#include <set> \n#include <cassert>\n#include <memory> \n#include <algorithm> \n#include <functional> \n#include <sstream> \n#include <complex> \n#include <stack> \n#include <queue> \n#include <string> \n#include <vector> \nusing namespace std; \n\n#define rep(i, n) for(int i = 0; i < n; i++) \n#define rep2(i, m, n) for(int i = m; i < n; i++) \nconst double EPS = 1E-9; \ntypedef long long ll; \ntypedef pair<int, int> P; \ntypedef pair<int, P> PP; \ntypedef complex<double> xy_t; \nconst int INF = 1 << 30; \n\n\n\nstruct swimmer{\n  int t;\n  double pos;\n  int lane;\n  int rest_loop;\n};\n\nint n;\nswimmer ss[100];\n\nbool operator<(swimmer s1, swimmer s2){\n  if(s1.rest_loop == 0 || s2.rest_loop == 0) return s1.rest_loop > s2.rest_loop;\n  else if(s1.lane != s2.lane) return s1.lane > s2.lane;\n  else {\n    if(s1.pos < EPS && s2.pos < EPS) return s1.t < s2.t;\n    else return s1.pos > s2.pos;\n  }\n}\n\nbool finish(){\n  int cnt = 0;\n  rep(i, n){\n    if(ss[i].rest_loop > 0) cnt++;\n  }\n  n = cnt;\n  \n  return cnt == 0;\n}\n\nvoid move(){\n  rep(i, n){\n    ss[i].pos += 1.0 / ss[i].t;\n  }\n  rep(i, n){\n    rep(j, i){\n      if(ss[i].lane == ss[j].lane && ss[i].pos > ss[j].pos){\n\tss[i].pos = ss[j].pos;\n      }\n    }\n  }\n  rep(i, n){\n    if(abs(1.0 - ss[i].pos) < EPS){\n      ss[i].pos = 0;\n      if(ss[i].lane){\n\tss[i].lane = 0;\n\tss[i].rest_loop--;\n      }else{\n\tss[i].lane = 1;\n      }\n    }\n  }\n  \n}\n\nint main(){\n  while(cin >> n && n){\n    rep(i, n){\n      cin >> ss[i].t >> ss[i].rest_loop;\n      ss[i].pos = 0.0;\n      ss[i].lane = 0;\n    }\n    sort(ss, ss + n);\n    int cnt = 0;\n    while(true){\n      if(finish()){\n\tcout << cnt << endl;\n\tbreak;\n      }\n      cnt++;\n      move();\n      sort(ss, ss + n);\n      if(cnt > 800000){\n\tassert(false);\n      }\n    }\n  }\n  return 0;\n}\n\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint N;\nstruct A{\n\tint nowa,nowb,speed,rap;\n};\nmain()\n{\n\twhile(cin>>N,N)\n\t{\n\t\tvector<A>P;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tA a;\n\t\t\tcin>>a.speed>>a.rap;\n\t\t\ta.nowa=0;\n\t\t\ta.nowb=a.speed;\n\t\t\tP.push_back(a);\n\t\t}\n\t\tsort(P.begin(),P.end(),[](A a,A b){return a.speed<b.speed;});\n\t\tint ans=0;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tvector<A>Q;\n\t\t\tP[0].nowa++;\n\t\t\tfor(int i=1;i<P.size();i++)\n\t\t\t{\n\t\t\t\tP[i].nowa++;\n\t\t\t\tif(P[i].nowa*P[i-1].nowb>P[i-1].nowa*P[i].nowb)\n\t\t\t\t{\n\t\t\t\t\tP[i].nowa=P[i-1].nowa;\n\t\t\t\t\tP[i].nowb=P[i-1].nowb;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<P.size();i++)\n\t\t\t{\n\t\t\t\tif(P[i].nowa==P[i].nowb)\n\t\t\t\t{\n\t\t\t\t\tP[i].nowa=P[i].nowb=P[i].speed;\n\t\t\t\t}\n\t\t\t\telse if(P[i].nowa==P[i].nowb*2)\n\t\t\t\t{\n\t\t\t\t\tP[i].nowa=0;\n\t\t\t\t\tP[i].nowb=P[i].speed;\n\t\t\t\t\tP[i].rap--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<P.size();i++)\n\t\t\t{\n\t\t\t\tif(P[i].rap>0)Q.push_back(P[i]);\n\t\t\t}\n\t\t\tstable_sort(Q.begin(),Q.end(),[](A a,A b){\n\t\t\t\treturn a.nowa*b.nowb!=b.nowa*a.nowb?a.nowa*b.nowb>b.nowa*a.nowb:\n\t\t\t\t\ta.nowa%a.nowb==0?a.speed<b.speed:false;\n\t\t\t});\n\t\t\tP=Q;\n\t\t\tans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  \n  while(n){\n    int mint = inf;\n\n    rep(i,n){\n      //cout << in[i].t <<\" \" << in[i].now%in[i].t<<endl;\n      mint = min(mint,in[i].t-in[i].now%in[i].t);\n    }\n\n\n    rep(i,n){\n      in[i].now+=1;\n      bool ischanged=false;\n      for(int j=n-1;j>i;j--){\n\tif ((in[i].now)*in[j].t >= (in[j].now+1)*in[i].t){\n\t  in[i].now=in[j].now+1;\n\t  in[i].t=in[j].t;\n\t  ischanged=true;\n\t  mint=1;\n\t}\n      }\n      \n      in[i].now-=1;\n    }\n    \n    rep(i,n){\n      in[i].now+=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf;\n\t}\n      }\n    }\n    \n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].now == inf)n--;\n    }\n\n    ans+=mint;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <numeric> \n#include <cstdlib> \n#include <climits> \n#include <cmath> \n#include <cstdio> \n#include <cfloat> \n#include <map> \n#include <utility> \n#include <set> \n#include <cassert>\n#include <memory> \n#include <algorithm> \n#include <functional> \n#include <sstream> \n#include <complex> \n#include <stack> \n#include <queue> \n#include <string> \n#include <vector> \nusing namespace std; \n\n#define rep(i, n) for(int i = 0; i < n; i++) \n#define rep2(i, m, n) for(int i = m; i < n; i++) \nconst double EPS = 1E-6; \ntypedef long long ll; \ntypedef pair<int, int> P; \ntypedef pair<int, P> PP; \ntypedef complex<double> xy_t; \nconst int INF = 1 << 30; \n\n\n\nstruct swimmer{\n  int t;\n  double pos;\n  int lane;\n  int rest_loop;\n};\n\nint n;\nswimmer ss[100];\n\nbool operator<(swimmer s1, swimmer s2){\n  if(s1.rest_loop == 0 || s2.rest_loop == 0) return s1.rest_loop > s2.rest_loop;\n  else if(s1.lane != s2.lane) return s1.lane > s2.lane;\n  else {\n    if(s1.pos < EPS && s2.pos < EPS) return s1.t < s2.t;\n    else return s1.pos > s2.pos;\n  }\n}\n\nbool finish(){\n  int cnt = 0;\n  rep(i, n){\n    if(ss[i].rest_loop > 0) cnt++;\n  }\n  return (cnt == 0);\n}\n\nvoid move(){\n  rep(i, n){\n    if(ss[i].rest_loop) ss[i].pos += (double)1.0 / ss[i].t;\n  }\n  rep(i, n){\n    rep(j, i){\n      if(ss[i].rest_loop && ss[j].rest_loop &&\n ss[i].lane == ss[j].lane && ss[i].pos > ss[j].pos){\n\tss[i].pos = ss[j].pos;\n      }\n    }\n  }\n  rep(i, n){\n    if(ss[i].rest_loop == 0) continue;\n    if(1.0 - ss[i].pos < EPS){\n      ss[i].pos = 0.0;\n      if(ss[i].lane){\n\tss[i].lane = 0;\n\tss[i].rest_loop--;\n      }else{\n\tss[i].lane = 1;\n      }\n    }\n  }\n  \n}\n\nint main(){\n  while(cin >> n && n){\n    rep(i, n){\n      cin >> ss[i].t >> ss[i].rest_loop;\n      ss[i].pos = 0.0;\n      ss[i].lane = 0;\n    }\n    sort(ss, ss + n);\n    int cnt = 0;\n    while(true){\n      if(finish()){\n\tcout << cnt << endl;\n\tbreak;\n      }\n      cnt++;\n      move();\n      sort(ss, ss + n);\n      if(cnt > 800000){\n\tassert(false);\n      }\n    }\n  }\n  return 0;\n}\n\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nstruct Range {\n    int l, r; // [l, r]\n    Range(){}\n    Range(int _l, int _r) : l(_l), r(_r) {}\n    bool operator<( const Range& o ) const {\n        if (l != o.l) return l < o.l;\n        return r < o.r;\n    }\n    void print() {\n        cout << \"l = \" << l << \", r = \" << r << endl;\n    }\n};\n\nstruct State {\n    int t_in, t_pace, c_rem;\n    State(){}\n    State(int _t_in, int _t_pace, int _c_rem) : t_in(_t_in), t_pace(_t_pace), c_rem(_c_rem) {}\n    bool operator<(const State& o) const {\n        if (t_pace != o.t_pace) return t_pace < o.t_pace;\n        if (c_rem != o.c_rem) return c_rem < o.c_rem;\n        return t_in < o.t_in;\n    }\n    void print() {\n        cerr << \"(\" << t_in << \", \" << t_pace << \", \" << c_rem << \")\";\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<deque<State>> deq(2);\n        vector<State> initial_states;\n        rep(i, n) {\n            int t_pace, c_rem;\n            cin >> t_pace >> c_rem;\n            initial_states.emplace_back(0, t_pace, c_rem - 1);\n        }\n        sort(all(initial_states));\n        for (auto state : initial_states) {\n            deq[0].emplace_back(state);\n        }\n\n        auto printDeq = [&](){\n            rep(k, 2) {\n                cerr << k << \":\";\n                rep(i, deq[k].size()) {\n                    cerr << \" \";\n                    deq[k][i].print();\n                }\n                cerr << endl;\n            }\n        };\n\n        int t_max = 0;\n        while (!(deq[0].empty() && deq[1].empty())) {\n            int t_now_0 = (deq[0].empty() ? inf : deq[0].front().t_in + deq[0].front().t_pace);\n            int t_now_1 = (deq[1].empty() ? inf : deq[1].front().t_in + deq[1].front().t_pace);\n            int t_now = min(t_now_0, t_now_1);\n            if (t_now_0 < t_now_1) {\n                int k = 0;\n                vector<State> states;\n                // int t_now = deq[k].front().t_in + deq[k].front().t_pace;\n                while (!deq[k].empty() && t_now >= deq[k].front().t_in + deq[k].front().t_pace) {\n                    if (k && deq[k].front().c_rem == 0) {\n                        t_max = t_now;\n                    }\n                    else {\n                        states.emplace_back(deq[k].front());\n                    }\n                    deq[k].pop_front();\n                }\n\n                sort(all(states));\n\n                for (auto state : states) {\n                    deq[k^1].emplace_back(t_now, state.t_pace, state.c_rem - k);\n                }\n            }\n            else if (t_now_0 > t_now_1) {\n                int k = 1;\n                vector<State> states;\n                // int t_now = deq[k].front().t_in + deq[k].front().t_pace;\n                while (!deq[k].empty() && t_now >= deq[k].front().t_in + deq[k].front().t_pace) {\n                    if (k && deq[k].front().c_rem == 0) {\n                        t_max = t_now;\n                    }\n                    else {\n                        states.emplace_back(deq[k].front());\n                    }\n                    deq[k].pop_front();\n                }\n\n                sort(all(states));\n\n                for (auto state : states) {\n                    deq[k^1].emplace_back(t_now, state.t_pace, state.c_rem - k);\n                }\n            }\n            else { // t_now_0 == t_now_1\n                vector<vector<State>> states(2);\n                rep(k, 2) {\n                    // int t_now = deq[k].front().t_in + deq[k].front().t_pace;\n                    while (!deq[k].empty() && t_now >= deq[k].front().t_in + deq[k].front().t_pace) {\n                        if (k && deq[k].front().c_rem == 0) {\n                            t_max = t_now;\n                        }\n                        else {\n                            states[k].emplace_back(deq[k].front());\n                        }\n                        deq[k].pop_front();\n                    }\n                }\n\n                rep(k, 2) {\n                    sort(all(states[k]));\n                    for (auto state : states[k]) {\n                        deq[k^1].emplace_back(t_now, state.t_pace, state.c_rem - k);\n                    }\n                }\n            }\n        }\n\n        cout << t_max << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint N;\nP swimmer[50];\nmap<int, vector<P> > lane[2];\n\nint main(){\n\twhile(cin >> N, N){\n\t\tlane[0].clear();\n\t\tlane[1].clear();\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> swimmer[i].first >> swimmer[i].second;\n\t\t\tswimmer[i].second *= 2;\n\t\t\tlane[0][swimmer[i].first].push_back(swimmer[i]);\t\n\t\t}\n\n\t\tint time = 0;\n\t\twhile(lane[0].size() > 0 || lane[1].size() > 0){\n\t\t\tint i;\n\t\t\tif(lane[0].size() > 0 && (lane[1].size() == 0 || (*(lane[0].begin())).first < (*(lane[1].begin())).first)){\n\t\t\t\ti = 0;\n\t\t\t}else{\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tauto h = *(lane[i].begin());\n\t\t\ttime = h.first;\n\t\t\tlane[i].erase(h.first);\n\t\t\tsort(h.second.begin(), h.second.end());\n\t\t\tfor(auto p : h.second){\n\t\t\t\tif(p.second > 1){\n\t\t\t\t\tp.second--;\n\t\t\t\t\tint nt = time + p.first;\n\t\t\t\t\tif(lane[(i+1)%2].size() > 0 && (*(lane[(i+1)%2].rbegin())).first >= nt){\n\t\t\t\t\t\t(*(lane[(i+1)%2].rbegin())).second.push_back(p);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlane[(i+1)%2][nt].push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << time << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nint time[50], laps[50], limit[2];\n\nstruct Entry {\n  int id, lane, t;\n  Entry(int id, int lane, int t): id(id), lane(lane), t(t) {}\n  bool operator<(const Entry& rhs) const {\n    return (t == rhs.t) ? (time[id] > time[rhs.id]) : (t > rhs.t);\n  }\n};\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    limit[0] = limit[1] = 0;\n    REP(i, n) { scanf(\"%d%d\", time+i, laps+i); laps[i] *= 2; }\n    priority_queue<Entry> Q;\n    REP(i, n) { Q.push(Entry(i, 0, 0)); }\n    while (!Q.empty()) {\n      int id = Q.top().id;\n      int lane = Q.top().lane;\n      int t = Q.top().t;\n      Q.pop();\n      limit[lane] = max(limit[lane], t + time[id]);\n      --laps[id];\n      if (laps[id] > 0) { Q.push(Entry(id, !lane, limit[lane])); }\n    }\n    printf(\"%d\\n\", max(limit[0], limit[1]));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dat{\n  int T,t,f,lap;\n  vector<dat> V;\n  bool operator < (dat a)const{return T<a.T;}\n  bool operator > (dat a)const{return T>a.T;}\n};\n\nbool onFront(dat a,dat b){\n  if(!b.t||a.f!=b.f)return 0;\n  return !a.t||1.0*a.t/a.T < 1.0*b.t/b.T;\n}\n\nbool checkJam(dat a,dat b){return a.T<b.T&&onFront(a,b)&&(a.T-a.t)+b.t<=b.T;}\n\n\nint merge(vector<dat>&A,int idx){\n  for(int i=0;i<idx;i++){\n    dat &a = A[idx],&b = A[i];\n    if(!checkJam(a,b))continue;\n    for(int j=0;j<(int)a.V.size();j++)b.V.push_back(a.V[j]);\n    a.V.clear();\n    b.V.push_back(a);\n    A.erase(A.begin()+idx);\n    return 1;\n  }  \n  return 0;\n}\n\nvoid Push(vector<dat>&A,dat a,int t){\n  assert(t!=0&&t!=1e9);\n  a.t+=t;\n  if(a.t>=a.T)a.t=0,a.lap-=a.f ,a.f=!a.f;\n  if(a.lap)A.push_back(a);\n}\n\nint sim(vector<dat> A){\n  int res=0;\n  while(!A.empty()){\n    sort(A.begin(),A.end(),greater<dat>());\n\n    int mn = 1e9;\n    for(int i=(int)A.size()-1;i>=0;i--)\n      if(!merge(A,i))mn = min(mn,A[i].T-A[i].t);\n\n    vector<dat>nA;\n    for(int i=0;i<(int)A.size();i++){\n      if(A[i].t+mn>=A[i].T){\n      for(int j=0;j<(int)A[i].V.size();j++)Push(nA,A[i].V[j],mn);\n      A[i].V.clear();\n      }\n      else \n\tfor(int j=0;j<(int)A[i].V.size();j++)A[i].V[j].t+=mn;\n      Push(nA,A[i],mn);\n      }\n    A=nA;\n    res+=mn;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<dat> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].T>>A[i].lap,A[i].t=A[i].f=0;\n    cout<<sim(A)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-8;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nsigned main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvvi in(n,vi(2));\n\t\trep(i,n)rep(j,2)cin>>in[i][j];\n\t\tsort(all(in));\n\t\tint tim=0;\n\t\tqueue<pii>que[2];\n\t\trep(i,n)que[0].push({in[i][0],i});\n\t\twhile(!que[0].empty()||!que[1].empty()){\n\t\t\ttim=inf;\n\t\t\trep(i,2)if(!que[i].empty()){\n\t\t\t\tint t=que[i].front().first;\n\t\t\t\tif(tim>t)tim=t;\n\t\t\t}\n\t\t\trep(i,2){\n\t\t\t\tvp ne;\n\t\t\t\twhile(!que[i].empty()&&que[i].front().first<=tim){\n\t\t\t\t\tne.pb(que[i].front());\n\t\t\t\t\tque[i].pop();\n\t\t\t\t}\n\t\t\t\trep(j,ne.size())rep(k,ne.size())\n\t\t\t\t\tif(in[ne[j].second][0]<in[ne[k].second][0])swap(ne[j],ne[k]);\n\t\t\t\trep(j,ne.size()){\n\t\t\t\t\tpii p=ne[j];\n\t\t\t\t\tif(i){\n\t\t\t\t\t\tin[p.second][1]--;\n\t\t\t\t\t\tif(in[p.second][1])que[i^1].push({tim+in[p.second][0],p.second});\n\t\t\t\t\t}else que[i^1].push({tim+in[p.second][0],p.second});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<tim<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1000000010\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\n\nsigned main(){\n  cin.tie(0);\t\n  //ios::sync_with_stdio(false);\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    queue<pair<pair<int,int>,int > > a,b;\n    priority_queue<pair<pair<int,int>,int > > c;\n    queue<pair<pair<int,int>,int > > d;\n    pair<int,int> p[n];\n    pair<pair<int,int>,int > pr;\n    int ans=0;\n    rep(i,n) cin>>p[i].fst>>p[i].scd;\n    sort(p,p+n);\n    rep(i,n) a.push(make_pair(p[i],p[i].fst));\n    while(!a.empty() || !b.empty() ){\n      /* rep(i,a.size() ){\n\tpr=a.front();\n\tcout<<pr.fst<<\" \";\n\ta.pop();\n\ta.push(pr);\n      }\n      cout<<endl;*/\n      pair<pair<int,int>,int >at,bt;\n      at=bt=make_pair(make_pair(0,0),INF);\n      if(!a.empty() ) at=a.front();\n      if(!b.empty() ) bt=b.front();\n      if(at.scd<=bt.scd){\n\twhile(!a.empty() && a.front().scd<=at.scd){\n\t  pr=a.front();\n\t  a.pop();\n\t  \n\t  pr.scd=(pr.fst.fst+at.scd);\n\t  pr.fst.fst*=(-1);\n\t  c.push(pr);\n\t  \n\t}\n\twhile(!c.empty() ){\n\t  pr=c.top();\n\t  pr.fst.fst*=(-1);\n\t  b.push(pr );\n\t  c.pop();\n\t}\n\n      }else{\n\twhile(!b.empty() && b.front().scd<=bt.scd){\n\t  pr=b.front();\n\t  b.pop();\n\t  \n\t  pr.fst.scd--;\n\t  if(pr.fst.scd!=0){\n\t    pr.scd=(pr.fst.fst+bt.scd);\n\t    pr.fst.fst*=(-1);\n\t    c.push(pr);\n\t  }else{\n\t    ans=max(ans,bt.scd);\n\t  }\n\t  \n\t}\n\twhile(!c.empty() ){\n\t  pr=c.top();\n\t  pr.fst.fst*=(-1);\n\t  a.push(pr );\n\t  c.pop();\n\t}\n\n      }\n    }\n    cout<<ans<<endl;\n  }\n \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define P pair<int, C>\n#define d first\n#define c second\n\nclass C{\n  public:\n    int time, cnt, now;\n    C(){ now = 0; }\n    bool operator < (const C &c) const { return time < c.time; }\n};\n\nint main() {\n  int n;\n  while(cin >>n && n){\n    vector<P> v(n);\n    REP(i, n){\n      cin >>v[i].c.time >>v[i].c.cnt;\n      v[i].d = v[i].c.time;\n    }\n    sort(v.begin(), v.end());\n\n    int ans = 0;\n\n    //debug\n    //int cnt = 0;\n\n    while(v.size() != 0){\n    //while(!isEnd(v) && cnt < 670){\n\n      //debug\n      //cnt += 1;\n\n      if(v[0].c.cnt == 0) continue;\n\n      ans += v[0].d;\n      FOR(i, 1, v.size()) if(v[i].c.cnt != 0) v[i].d -= v[0].d;\n      int next = (v[0].c.now + 1) % 2;\n      v[0].d = v[0].c.time;\n      FOR(i, 1, v.size()){\n        if(v[i].c.cnt == 0 || v[i].c.now != next) continue;\n\n        //debug\n        //cout <<\"@ \" <<v[0].d <<\", \" <<v[i].d <<\", \"<<(v[0].d < v[i].d) <<endl;\n\n        //if(v[0].d < v[i].d) v[0].d = max(v[0].d, v[i].d);\n        v[0].d = max(v[0].d, v[i].d);\n      }\n      v[0].c.now = next;\n      if(next == 0){\n        v[0].c.cnt -= 1;\n\n        //debug\n        //cout <<\"end? \" <<v[0].c.cnt <<endl;\n\n        if(v[0].c.cnt == 0) v.erase(v.begin());\n      }\n\n\n      sort(v.begin(), v.end());\n\n      //debug\n      //REP(i, v.size()){\n      //  cout <<i <<\", d = \" <<v[i].d <<\", c.now = \" <<v[i].c.now <<\", c.cnt = \" <<v[i].c.cnt <<endl;\n      //}\n      //cout <<\"------\" <<endl;\n\n\n    }\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nstruct swimmer{\n\tdouble pos;\n\t//double prepos;\n\tint t;\n\tint rest_loop;\n\tint lane;\n};\n\nswimmer ss[100];\nint order[100];\n\nbool finish(int n){\n\trep(i, n) if(ss[i].rest_loop) return false;\n\treturn true;\n}\n\nvoid move(int n){\n\t/*\n\tcout << \"************************\" << endl;\n\tcout << \"begin\" << endl;\n\trep(i, n)cout << ss[i].pos << \" \" << ss[i].rest_loop << \" \" << ss[i].lane << endl;\n\tcout << \"***********************\" << endl;\n\t*/\n\trep(i, n) if(ss[i].rest_loop){\n\t\t//ss[i].prepos = ss[i].pos;\n\t\tss[i].pos += 1.0 / ss[i].t;\n\t}\n\trep(i, n){\n\t\trep(j, i) {\n\t\t\tif(ss[i].rest_loop && ss[j].rest_loop &&\n\t\t\t\tss[i].lane == ss[j].lane){\n\n\t\t\t\tss[i].pos = min(ss[i].pos, ss[j].pos);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tif(ss[i].rest_loop == 0) continue;\n\t\tif(abs(ss[i].pos - 1.0) < EPS) {\n\t\t\tss[i].pos = 0.0;\n\t\t\tif(ss[i].lane == 0){\n\t\t\t\tss[i].lane = 1;\n\t\t\t}else{\n\t\t\t\tss[i].lane = 0;\n\t\t\t\tss[i].rest_loop--;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tcout << \"************************\" << endl;\n\tcout << \"end\" << endl;\n\trep(i, n)cout << ss[i].pos << \" \" << ss[i].rest_loop << \" \" << ss[i].lane << endl;\n\tcout << \"***********************\" << endl;\n\t*/\n}\n\nbool comp(const swimmer &s1, const swimmer &s2){\n\tif(s1.lane != s2.lane) return s1.lane < s2.lane;\n\telse if(s1.rest_loop == 0 || s2.rest_loop == 0) return s1.rest_loop < s2.rest_loop;\n\telse if(abs(s1.pos - s2.pos) < EPS){\n\t\tif(s1.pos < EPS && s2.pos < EPS) return s1.t < s2.t;\n\t\telse return s1.t > s2.t;\n\t}else{\n\t\treturn s1.pos > s2.pos;\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\trep(i, n){\n\t\t\tcin >> ss[i].t >> ss[i].rest_loop;\n\t\t\tss[i].lane = 0;\n\t\t\tss[i].pos = 0.0;\n\t\t}\n\n\n\t\tint cnt = 0;\n\t\tsort(ss, ss + n, comp);\n\t\twhile(true){\n\t\t\tif(finish(n)){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tmove(n);\n\t\t\tsort(ss, ss + n, comp);\n\t\t\tassert(cnt < 800000);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  int m= n;\n  while(m){\n    int mint = inf;\n    \n    rep(i,n){\n      if (in[i].now == inf)continue;\n      mint = min(mint,in[i].t-in[i].now%in[i].t);\n    }\n\n        \n    rep(i,n){\n      in[i].now+=1;\n      for(int j=n-1;j>i;j--){\n\tif ((in[i].now)*in[j].t >= (in[j].now+1)*in[i].t){\n\t  in[i].now=in[j].now+1;\n\t  in[i].t=in[j].t;\n\t  mint=1;\n\t}\n      }\n      in[i].now-=1;\n    }\n        \n    \n    /*\n    rep(i,n){\n      if (in[i].now == inf)continue;\n      in[i].now+=1;\n      rep(j,n){\n\tif (i == j)continue;\n\tif (in[j].now == inf)continue;\n\tif ((in[i].now-1)*in[j].t >=(in[j].now)*in[i].t)continue;\n\tif ((in[i].now)*in[j].t >= (in[j].now+1)*in[i].t){\n\t  in[i].now=in[j].now+1;\n\t  in[i].t=in[j].t;\n\t  mint=1;\n\t}\n      }\n      in[i].now-=1;\n    }\n    */\n    \n    rep(i,n){\n      in[i].now+=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf,m--;\n\t}\n      }\n    }\n    \n\n\n    sort(ALL(in));\n\n    ans+=mint;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nstruct swimmer{\n\tdouble pos;\n\t//double prepos;\n\tint t;\n\tint rest_loop;\n\tint lane;\n};\n\nswimmer ss[100];\nint order[100];\n\nbool finish(int n){\n\trep(i, n) if(ss[i].rest_loop) return false;\n\treturn true;\n}\n\nvoid move(int n){\n\t/*\n\tcout << \"************************\" << endl;\n\tcout << \"begin\" << endl;\n\trep(i, n)cout << ss[i].pos << \" \" << ss[i].rest_loop << \" \" << ss[i].lane << endl;\n\tcout << \"***********************\" << endl;\n\t*/\n\tdouble m[2] = {1.0, 1.0};\n\trep(i, n) if(ss[i].rest_loop){\n\t\t//ss[i].prepos = ss[i].pos;\n\t\tss[i].pos += 1.0 / ss[i].t;\n\t}\n\trep(i, n){\n\t\tif(ss[i].rest_loop == 0) continue;\n\t\tif(ss[i].pos > m[ss[i].lane]){\n\t\t\tss[i].pos = m[ss[i].lane];\n\t\t}else{\n\t\t\tm[ss[i].lane] = ss[i].pos;\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tif(ss[i].rest_loop == 0) continue;\n\t\tif(abs(ss[i].pos - 1.0) < EPS) {\n\t\t\tss[i].pos = 0.0;\n\t\t\tif(ss[i].lane == 0){\n\t\t\t\tss[i].lane = 1;\n\t\t\t}else{\n\t\t\t\tss[i].lane = 0;\n\t\t\t\tss[i].rest_loop--;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tcout << \"************************\" << endl;\n\tcout << \"end\" << endl;\n\trep(i, n)cout << ss[i].pos << \" \" << ss[i].rest_loop << \" \" << ss[i].lane << endl;\n\tcout << \"***********************\" << endl;\n\t*/\n}\n\nbool comp(const swimmer &s1, const swimmer &s2){\n\tif(s1.lane != s2.lane) return s1.lane < s2.lane;\n\telse if(s1.rest_loop == 0 || s2.rest_loop == 0) return s1.rest_loop < s2.rest_loop;\n\telse if(abs(s1.pos - s2.pos) < EPS){\n\t\tif(s1.pos < EPS && s2.pos < EPS) return s1.t < s2.t;\n\t\telse return s1.t > s2.t;\n\t}else{\n\t\treturn s1.pos > s2.pos;\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\trep(i, n){\n\t\t\tcin >> ss[i].t >> ss[i].rest_loop;\n\t\t\tss[i].lane = 0;\n\t\t\tss[i].pos = 0.0;\n\t\t}\n\n\n\t\tint cnt = 0;\n\t\tsort(ss, ss + n, comp);\n\t\twhile(true){\n\t\t\tif(finish(n)){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tmove(n);\n\t\t\tsort(ss, ss + n, comp);\n\t\t\tassert(cnt < 800000);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef tuple< int, int, int, int > S;\n\nint main()\n{\n  int N, T[50], C[50];\n\n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) cin >> T[i] >> C[i];\n\n    priority_queue< S, vector< S >, greater< S > > que;\n    for(int i = 0; i < N; i++) que.emplace(0, T[i], C[i], 0);\n    int mark[2] = {};\n    while(!que.empty()) {\n      int now, tim, cnt, line;\n      tie(now, tim, cnt, line) = que.top();\n      que.pop();\n      if(cnt == 0) continue;\n      line ^= 1;\n      if(line == 0) --cnt;\n      now = max(now + tim, mark[line]);\n      mark[line] = max(mark[line], now);\n      que.emplace(now, tim, cnt, line);\n    }\n    cout << mark[0] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n  int n;\n  while(true) {\n    cin >> n;\n    if (n == 0) break;\n    vector <pair<int, int> > tc;\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      cin >> x >> y;\n      bool flag = false;\n      for (int j = 0; j < tc.size(); j++) {\n\tif (tc[j].first == x) {\n\t  flag = true;\n\t  tc[j].second = max(tc[j].second, y);\n\t  break;\n\t}\n      }\n      if (!flag) tc.push_back(make_pair(x, y));\n    }\n    n = tc.size();\n    sort(tc.begin(), tc.end());\n    reverse(tc.begin(), tc.end());\n    vector <int > leftTime[n];\n    for (int i = 0; i < n; i++) leftTime[i].push_back(0);\n    bool left = true;\n\n    int total = 0;\n    for (int i = 0; i < n; i++) {\n      int t = tc[i].first, c = tc[i].second;\n      int time = 0;\n      for (int j = 0; j < 2*c; j++) {\n\tint bs = time;\n\tint bg = time+t;\n\tfor (int k = 0; k < i; k++) {\n\t  for (int l = j%2; l < leftTime[k].size(); l+=2) {\n\t    if (l+1 >= leftTime[k].size()) break;\n\t    int as = leftTime[k][l];\n\t    int ag = leftTime[k][l+1];\n\n\t    if (bs > as && bg < ag) {\n\t      bg = max(ag, bg);\n\t    }\n\t  }\n\t}\n\ttotal = max(total, bg);\n\tleftTime[i].push_back(bg);\n\ttime = bg;\n      }      \n    }\n    cout << total << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SIZE 200000\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nP x[50];\nint dp[2][SIZE];\n\nvoid solve(){\n\trep(i,2) rep(j,SIZE) dp[i][j] = 0;\n\trep(i,n) cin >> x[i].first >> x[i].second;\n\trep(i,n) x[i].second *= 2;\n\tsort(x,x+n,greater<P>());\n\tint ans = 0;\n\trep(i,n){\n\t\tint dir = 0;\n\t\tint ti = 0;\n\t\twhile(x[i].second){\n\t\t\tint tmpti = ti;\n\t\t\tif(ti == 0) ti = ti+x[i].first;\n\t\t\telse ti = max(ti+x[i].first,dp[dir][ti-1]);\n\t\t\tdp[dir][tmpti] = max(dp[dir][tmpti],ti);\n\t\t\tdir = dir^1;\n\t\t\tx[i].second--;\n\t\t}\n\t\trep(j,2) for(int k = 1; k < SIZE; k++) dp[j][k] = max(dp[j][k],dp[j][k-1]);\n\t}\n\trep(i,2) rep(j,SIZE) ans = max(ans,dp[i][j]);\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dat{\n  int T,t,f,lap;\n  dat(){T=t=f=lap=0;}\n  vector<dat> V;\n  bool operator > (const dat &a)const{return T-t>a.T-a.t;}\n};\n\nbool onFront(const dat &a,const dat &b){return a.f==b.f&&1.0*a.t/a.T<1.0*b.t/b.T;}\nbool checkJam(const dat &a,const dat &b){return onFront(a,b)&&a.T-a.t<b.T-b.t;}\n\nint merge(vector<dat>&A,int idx){\n  dat &a = A[idx];\n  for(int i=0;i<(int)A.size();i++){\n    dat &b = A[i];\n    if(!checkJam(a,b))continue;\n    a.t=0, a.lap-=a.f, a.f=!a.f;\n    b.V.push_back(a);\n    A.erase(A.begin()+idx);\n    return 1e9;\n  }\n  return a.T-a.t;\n}\n\nvoid Push(vector<dat>&A,dat &a){\n  for(int i=0;i<(int)a.V.size();i++)Push(A,a.V[i]);\n  a.V.clear();\n  if(a.lap) A.push_back(a);\n}\n\nint sim(vector<dat> A){\n  int res=0;\n  while(!A.empty()){\n    sort(A.begin(),A.end(),greater<dat>());\n    int mn = 1e9;\n    for(int i=A.size()-1;i>=0;i--)mn=min(mn,merge(A,i));\n\n    vector<dat>nA;\n    for(int i=0;i<(int)A.size();i++)\n      if(A[i].t+mn<A[i].T) A[i].t+=mn,nA.push_back(A[i]);\n      else A[i].t=0, A[i].lap-=A[i].f, A[i].f=!A[i].f,Push(nA,A[i]);\n\n    A=nA;\n    res+=mn;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<dat> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].T>>A[i].lap;\n    cout<<sim(A)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define FF first\n#define SS second\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9;\nint N;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N,N){\n\tVI T(N);\n\tvector<pair<PII,int>> p1(N), p2;\n\tREP(i,N){\n\t  cin >> p1[i].FF.FF >> p1[i].FF.SS;\n\t  p1[i].SS = i;\n\t  T[i] = p1[i].FF.FF;\n\t}\n\n\tint ans = 0;\n\twhile(!p1.empty() || !p2.empty()){\n\t  int mt = INF;\n\t  REP(i,SZ(p1)) mt = min(mt, p1[i].FF.FF);\n\t  REP(i,SZ(p2)) mt = min(mt, p2[i].FF.FF);\n\n\t  REP(i,SZ(p1)) p1[i].FF.FF -= mt;\n\t  REP(i,SZ(p2)) p2[i].FF.FF -= mt;\n\t  ans += mt;\n\n\t  int Mt = 0;\n\t  REP(i,SZ(p2)) Mt = max(Mt, p2[i].FF.FF);\n\t  REP(i,SZ(p1)){\n\t\tif(p1[i].FF.FF == 0){\n\t\t  int idx = p1[i].SS;\n\t\t  p2.PB(MP(MP(max(Mt,T[idx]), p1[i].FF.SS), idx));\n\t\t  p1.erase(p1.begin() + i);\n\t\t  --i;\n\t\t}\n\t  }\n\n\t  Mt = 0;\n\t  REP(i,SZ(p1)) Mt = max(Mt, p1[i].FF.FF);\n\t  REP(i,SZ(p2)){\n\t\tif(p2[i].FF.FF == 0){\n\t\t  if(p2[i].FF.SS > 1){\n\t\t\tint idx = p2[i].SS;\n\t\t\tp1.PB(MP(MP(max(Mt,T[idx]), p2[i].FF.SS-1), idx));\n\t\t  }\n\t\t  p2.erase(p2.begin() + i);\n\t\t  --i;\n\t\t}\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nstruct swimmer{\n\tdouble pos;\n\t//double prepos;\n\tint t;\n\tint rest_loop;\n\tint lane;\n};\n\nswimmer ss[100];\nint order[100];\n\nbool finish(int &n){\n\tint cnt = 0;\n\trep(i, n) if(ss[i].rest_loop){\n\t\tcnt++;\n\t}\n\tif(cnt == 0) return true;\n\tn = cnt;\n\treturn false;\n}\n\nvoid move(int n){\n\t/*\n\tcout << \"************************\" << endl;\n\tcout << \"begin\" << endl;\n\trep(i, n)cout << ss[i].pos << \" \" << ss[i].rest_loop << \" \" << ss[i].lane << endl;\n\tcout << \"***********************\" << endl;\n\t*/\n\tdouble m[2] = {1.0, 1.0};\n\trep(i, n) if(ss[i].rest_loop){\n\t\t//ss[i].prepos = ss[i].pos;\n\t\tss[i].pos += 1.0 / ss[i].t;\n\t}\n\trep(i, n){\n\t\tif(ss[i].rest_loop == 0) continue;\n\t\tif(ss[i].pos > m[ss[i].lane]){\n\t\t\tss[i].pos = m[ss[i].lane];\n\t\t}else{\n\t\t\tm[ss[i].lane] = ss[i].pos;\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tif(ss[i].rest_loop == 0) continue;\n\t\tif(abs(ss[i].pos - 1.0) < EPS) {\n\t\t\tss[i].pos = 0.0;\n\t\t\tif(ss[i].lane == 0){\n\t\t\t\tss[i].lane = 1;\n\t\t\t}else{\n\t\t\t\tss[i].lane = 0;\n\t\t\t\tss[i].rest_loop--;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tcout << \"************************\" << endl;\n\tcout << \"end\" << endl;\n\trep(i, n)cout << ss[i].pos << \" \" << ss[i].rest_loop << \" \" << ss[i].lane << endl;\n\tcout << \"***********************\" << endl;\n\t*/\n}\n\nbool comp(const swimmer &s1, const swimmer &s2){\n\tif(s1.lane != s2.lane) return s1.lane < s2.lane;\n\telse if(s1.rest_loop == 0 || s2.rest_loop == 0) return s1.rest_loop > s2.rest_loop;\n\telse if(abs(s1.pos - s2.pos) < EPS){\n\t\tif(s1.pos < EPS && s2.pos < EPS) return s1.t < s2.t;\n\t\telse return s1.t > s2.t;\n\t}else{\n\t\treturn s1.pos > s2.pos;\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\trep(i, n){\n\t\t\tcin >> ss[i].t >> ss[i].rest_loop;\n\t\t\tss[i].lane = 0;\n\t\t\tss[i].pos = 0.0;\n\t\t}\n\n\n\t\tint cnt = 0;\n\t\tsort(ss, ss + n, comp);\n\t\twhile(true){\n\t\t\tif(finish(n)){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tmove(n);\n\t\t\tsort(ss, ss + n, comp);\n\t\t\tassert(cnt < 800000);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 55;\nconst int INF = 1<<28;\n\nstruct S {\n  int t, c, in;\n  bool operator < (const S &s) const {\n    return t < s.t;\n  }\n  bool reached(int now) {\n    return now - in >= t;\n  }\n};\n\nint n;\nS s[MAXN];\n\nint main() {\n  while (cin >> n && n) {\n    for (int i = 0; i < n; ++i) {\n      cin >> s[i].t >> s[i].c;\n      s[i].in = 0;\n    }\n    sort(s, s + n);\n    deque<S> que[2];\n    for (int i = 0; i < n; ++i) que[0].push_back(s[i]);\n    int t, finished;\n    for (t = 1, finished = 0; finished < n; ++t) {\n      for (int k = 0; k < 2; ++k) {\n        vector<S> v;\n        while (que[k].size() && que[k].front().reached(t)) {\n          S s = que[k].front();\n          que[k].pop_front();\n          v.push_back(s);\n\n        }\n        sort(v.begin(), v.end());\n        for (int i = 0; i < v.size(); ++i) {\n          S &s = v[i];\n          s.in = t;\n          if (k == 1 && --s.c == 0) {\n            finished += 1;\n            continue;\n          }\n          que[1-k].push_back(v[i]);\n        }\n      }\n    }\n    cout << t - 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\nconst int N = 50;\nconst double EPS = 1e-8;\n\nint n;\nvector<pair<double, int> > data;\n\nbool equals(double a, double b){ return abs(a - b) < EPS; }\n\nint solve(){\n  pair<double, double> dist[N];\n  int round[N], res;\n  for(int i=0;i<n;i++){\n    dist[i] = make_pair(0.0, 0.0);\n    round[i] = 1;\n  }\n  for(res=0;;res++){\n    for(int i=0;i<n;i++) if(data[i].second) goto CONT; break;\n    CONT:\n    for(int i=0;i<n;i++){\n      if(data[i].second == 0) continue;\n      dist[i] = make_pair(dist[i].second, dist[i].second + data[i].first);\n      for(int j=0;j<i;j++){\n        if(data[j].second == 0) continue;\n        if(round[i] != round[j]) continue;\n        if(equals(dist[i].first, 0.0) && equals(dist[j].first, 0.0)) continue;\n        if(!equals(dist[j].first, dist[i].first) && dist[j].first < dist[i].first) continue;\n        if(!equals(dist[i].first, dist[j].second) && dist[i].first < dist[j].second) dist[i].second = min(dist[i].second, dist[j].second);\n      }\n      dist[i].second = min(dist[i].second, 1.0);\n      if(equals(dist[i].second, 1.0)){\n        dist[i].second = 0.0;\n        if(round[i] == 0) data[i].second--;\n        round[i] = 1 - round[i];\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    data.clear();\n    for(int i=0;i<n;i++){\n      int a, b;\n      cin >> a >> b;\n      data.push_back(make_pair(1.0 / a, b));\n    }\n    sort(data.begin(), data.end());\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct info{\n    int t,rt,c;\n    info(int t, int rt, int c):t(t),rt(rt),c(c){}\n    info(){}\n    bool operator<(const info &a) const{\n        return t < a.t;\n    }\n};\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<info> s(n);\n        for(int i=0; i<n; i++){\n            int t,c;\n            cin >> t >> c;\n            s[i] = info(t, t, c);\n        }\n        sort(s.begin(), s.end());\n\n        deque<info> lane[2];\n        for(int i=0; i<n; i++){\n            lane[0].push_back(s[i]);\n        }\n        int ans = 0;\n        while(!lane[0].empty() || !lane[1].empty()){\n            int rt[2] = {(!lane[0].empty())? lane[0].front().rt: inf,\n                         (!lane[1].empty())? lane[1].front().rt: inf};\n            int rtmin = min(rt[0], rt[1]);\n            vector<info> wait[2];\n            for(int d=0; d<2; d++){\n                if(rt[d] <= rt[1-d]){\n                    while(!lane[d].empty() && lane[d].front().rt <= rtmin){\n                        info f = lane[d].front();\n                        lane[d].pop_front();\n                        f.rt = f.t;\n                        if(d == 1) f.c--;\n                        if(f.c > 0) wait[1-d].push_back(f);\n                    }\n                }\n                for(deque<info>::iterator itr=lane[d].begin(); itr!=lane[d].end(); itr++){\n                    itr->rt -= rtmin;\n                }\n            }\n            for(int d=0; d<2; d++){\n                sort(wait[d].begin(), wait[d].end());\n                for(int i=0; i<(int)wait[d].size(); i++){\n                    lane[d].push_back(wait[d][i]);\n                }\n            }\n            ans += rtmin;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n;\nint t[100],c[100];\nint maxt[2];\n\nstruct state{\n  int t,pc,r,idx;\n};\n\nbool operator<(const state& a,const state& b){\n  if(a.t==b.t)return a.pc > b.pc;\n  else return a.t > b.t;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,n)cin>>t[i]>>c[i];\n    priority_queue<state> que;\n    memset(maxt,0,sizeof(maxt));\n    rep(i,n){\n      que.push((state){0,t[i],0,i});\n      c[i]*=2;\n    }\n    while(que.size()){\n      state s=que.top(); que.pop();\n      int nxt=max(maxt[s.r],s.t+s.pc);\n      maxt[s.r]=nxt;\n      c[s.idx]--;\n      if(c[s.idx]>0){\n        que.push((state){nxt,s.pc,1-s.r,s.idx});\n      }\n    }\n    cout<<max(maxt[0],maxt[1])<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dat{\n  int T,t,f,lap;\n  dat(){T=t=f=lap=0;}\n  vector<dat> V;\n  bool operator > (const dat &a)const{return T-t>a.T-a.t;}\n};\n\nbool onFront(const dat &a,const dat &b){return a.f==b.f&&1.0*a.t/a.T<1.0*b.t/b.T;}\nbool checkJam(const dat &a,const dat &b){return onFront(a,b)&&a.T-a.t<b.T-b.t;}\n\nint merge(vector<dat>&A,int idx){\n  dat &a = A[idx];\n  for(int i=0;i<idx;i++){\n    dat &b = A[i];\n    if(!checkJam(a,b))continue;\n    a.t=0, a.lap-=a.f, a.f=!a.f;\n    b.V.push_back(a);\n    A.erase(A.begin()+idx);\n    return 1e9;\n  }\n  return a.T-a.t;\n}\n\nvoid Push(vector<dat>&A,dat &a){\n  for(int i=0;i<(int)a.V.size();i++)Push(A,a.V[i]);\n  a.V.clear();\n  if(a.lap) A.push_back(a);\n}\n\nint sim(vector<dat> A){\n  int res=0,idx=0;\n  vector<dat> tmp[2]={A};\n  \n  while(1){\n    vector<dat> &A = tmp[idx];\n    if(A.empty())break;\n    sort(A.begin(),A.end(),greater<dat>());\n    int mn = 1e9;\n    for(int i=A.size()-1;i>=0;i--)mn=min(mn,merge(A,i));\n\n    idx=!idx;\n    vector<dat>&nA=tmp[idx];tmp[idx].clear();\n    for(int i=0;i<(int)A.size();i++)\n      if(A[i].t+mn<A[i].T) A[i].t+=mn,nA.push_back(A[i]);\n      else A[i].t=0, A[i].lap-=A[i].f, A[i].f=!A[i].f,Push(nA,A[i]);\n\n    res+=mn;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<dat> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].T>>A[i].lap;\n    cout<<sim(A)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n\n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2000+eps)n--;\n    }\n  }\n\n  return (int)(ans+eps);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <complex>\n#include <vector>\n\nusing namespace std;\ntypedef complex<long long> Complex;\ntypedef vector<Complex> Polygon;\nclass Line : public vector<Complex> {\npublic:\n  Line(const Complex &a, const Complex &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nnamespace std {\n  bool operator<(const Complex &a, const Complex &b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\n\nlong long cross(const Complex &a, const Complex &b) {\n  return imag(conj(a) * b);\n}\n\nlong long dot(const Complex &a, const Complex &b) {\n  return real(conj(a) * b);\n}\n\nint ccw(Complex a, Complex b, Complex c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\nPolygon convex_hull(Polygon ps) {\n  int n = ps.size();\n  int k = 0;\n  Polygon ch(2 * n);\n  sort(ps.begin(), ps.end());\n  for (int i = 0; i < n; ch[k++] = ps[i++]) {\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) { k--; }\n  }\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--]) {\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) { k--; }\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Complex &p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n\nbool contains(const Polygon &P, const Complex &p) {\n  bool in = false;\n  for (int i = 0; i < (int)P.size(); i++) {\n    int next = (i + 1) % (int)P.size();\n    Line asegment(P[i], P[next]);\n    Line bsegment(p, p + Complex(100000, 1));\n    if (intersectSS(asegment, bsegment)) { in = !in; }\n    if (intersectSP(asegment, p)) { return true; }\n  }\n  return in;\n}\n\nbool intersectPP(const Polygon &a, const Polygon &b) {\n  if (a.size() <= 1 && b.size() <= 1) {\n    return a[0].real() == b[0].real() && a[0].imag() == b[0].imag();\n  }\n  if (a.size() != 1 || b.size() != 1) {\n    for (int i = 0; i < (int)a.size(); i++) {\n      int next = (i + 1) % (int)a.size();\n      Line asegment(a[i], a[next]);\n      for (int j = 0; j < (int)b.size(); j++) {\n        int next = (j + 1) % (int)b.size();\n        Line bsegment(b[j], b[next]);\n        if (intersectSS(asegment, bsegment)) { return true; }\n      }\n    }\n  }\n  if (b.size() != 1) {\n    if (contains(b, a[0])) { return true; }\n  }\n  if (a.size() != 1) {\n    if (contains(a, b[0])) { return true; }\n  }\n  return false;\n}\n\nint main() {\n  int n, m;\n  while (scanf(\"%d %d\", &n, &m), n|m) {\n    Polygon white;\n    Polygon black;\n    for (int i = 0; i < n; i++) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      white.push_back(Complex(x, y));\n    }\n    if (n > 1) {\n      white = convex_hull(white);\n    }\n    for (int i = 0; i < (int)white.size(); i++) {\n      //cout << white[i] << endl;\n    }\n    //cout << endl;\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      black.push_back(Complex(x, y));\n    }\n    if (m > 1) {\n      black = convex_hull(black);\n    }\n    for (int i = 0; i < (int)black.size(); i++) {\n      //cout << black[i] << endl;\n    }\n    if (!intersectPP(white, black)) {\n      puts(\"YES\");\n    } else {\n      puts(\"NO\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef vector<int> vi;\n \nint main(){\n  int n, t[55], c[55];\n  pair<int,int> s[55];\n  while(scanf(\"%d\",&n),n){\n    rep(i,n)scanf(\"%d%d\",&s[i].first,&s[i].second);\n    sort(s,s+n);\n    rep(i,n){\n      t[i] = s[i].first;\n      c[i] = s[i].second;\n    }\n    \n    vi q[2];\n    rep(i,n)q[0].push_back(i);\n     \n    int ans = 0;\n    while(q[0].size() || q[1].size()){\n      vi g[2];\n      int nxt = 1000;\n      rep(x,2){\n\tif(q[x].size())nxt = min(nxt, t[q[x][0]]);\n      }\n      ans += nxt;\n\n      rep(x,2){\n\trep(i,q[x].size()){\n\t  t[q[x][i]] -= nxt;\n\t  if(i>0 && t[q[x][i-1]] > t[q[x][i]])t[q[x][i]] = t[q[x][i-1]];\n\t}\n\twhile(q[x].size()){\n\t  if(t[q[x][0]])break;\n\t  g[x].push_back(q[x][0]);\n\t  q[x].erase(q[x].begin());\n\t}\n      }\n       \n      sort(all(g[0])); sort(all(g[1]));\n      for(int id : g[0]){\n\tq[1].push_back(id);\n\tt[id] = s[id].first;\n      }\n      for(int id : g[1]){\n\tif(--c[id]){\n\t  q[0].push_back(id);\n\t  t[id] = s[id].first;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define GE(a,b) ((a)-(b)>-EPS)\n\nconst double length=1;\nstruct swimmer{\n\tint tempo,cnt,cnt_max;\n\tdouble pos;\n\tbool operator<(const swimmer &other) const{\n\t\treturn tempo<other.tempo;\n\t}\n};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<swimmer> left;\n\t\tvector<swimmer> right;\n\t\tREP(i,n){\n\t\t\tint t,c;\n\t\t\tcin>>t>>c;\n\t\t\tleft.push_back(swimmer());\n\t\t\tleft[i].tempo=t;\n\t\t\tleft[i].cnt_max=c;\n\t\t}\n\t\tsort(ALL(left));\n\n\t\tint turn;\n\t\tfor(turn=1;;turn++){\n\t\t\tdouble left_prev_pos=10;\n\t\t\tREP(i,left.size()){\n\t\t\t\tdouble new_pos=left[i].pos+length/left[i].tempo;\n\t\t\t\tif(GE(new_pos,left_prev_pos)){\n\t\t\t\t\tleft[i].pos=left_prev_pos;\n\t\t\t\t}else{\n\t\t\t\t\tleft[i].pos=new_pos;\n\t\t\t\t\tleft_prev_pos=new_pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble right_prev_pos=10;\n\t\t\tREP(i,right.size()){\n\t\t\t\tdouble new_pos=right[i].pos+length/right[i].tempo;\n\t\t\t\tif(GE(new_pos,right_prev_pos)){\n\t\t\t\t\tright[i].pos=right_prev_pos;\n\t\t\t\t}else{\n\t\t\t\t\tright[i].pos=new_pos;\n\t\t\t\t\tright_prev_pos=new_pos;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<swimmer> left_done_swimmers;\n\t\t\tREP(i,left.size()){\n\t\t\t\tif(GE(left[i].pos,length)){\n\t\t\t\t\tleft_done_swimmers.push_back(left[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft.erase(left.begin(),left.begin()+left_done_swimmers.size());\n\n\t\t\tvector<swimmer> right_done_swimmers;\n\t\t\tint num_right_done_swimmers=0;\n\t\t\tREP(i,right.size()){\n\t\t\t\tif(GE(right[i].pos,length)){\n\t\t\t\t\tnum_right_done_swimmers++;\n\t\t\t\t\tright[i].cnt++;\n\t\t\t\t\tif(right[i].cnt<right[i].cnt_max){\n\t\t\t\t\t\tright_done_swimmers.push_back(right[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tright.erase(right.begin(),right.begin()+num_right_done_swimmers);\n\n\t\t\tsort(ALL(left_done_swimmers));\n\t\t\tsort(ALL(right_done_swimmers));\n\t\t\tREP(i,left_done_swimmers.size()){\n\t\t\t\tleft_done_swimmers[i].pos=0;\n\t\t\t}\n\t\t\tREP(i,right_done_swimmers.size()){\n\t\t\t\tright_done_swimmers[i].pos=0;\n\t\t\t}\n\t\t\tright.insert(right.end(),ALL(left_done_swimmers));\n\t\t\tleft.insert(left.end(),ALL(right_done_swimmers));\n\t\t\tif(left.size()==0&&right.size()==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<turn<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n#define F first\n#define S second\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, c[50], t[50];\nbool cmp(const pi &a, const pi &b){\n\treturn t[a.F] < t[b.F];\n}\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> t[i] >> c[i];\n\t\tvector<pi> vv;\n\t\trep(i, n) vv.pb(mp(t[i], i));\n\t\tsort(all(vv));\n\t\tqueue<pair<int, pi> > q[2];\n\t\trep(i, n) q[0].push(mp(vv[i].S, mp(vv[i].F, 0)));\n\t\t\n\t\tint cur = 0, next = 1, ans = 0;\n\t\twhile(q[0].size() || q[1].size()){\n\t\t\t\n\t\t\tif(q[cur].empty()) swap(cur, next);\n\t\t\telse if(q[next].size() && q[cur].front().S.F > q[next].front().S.F) swap(cur, next);\n\t\t\t\n\t\t\tvector<pi> v;\n\t\t\tint nxt = q[cur].front().S.F;\n\t\t\twhile(q[cur].size() && q[cur].front().S.F <= nxt){\n\t\t\t\tv.pb(mp(q[cur].front().F, q[cur].front().S.S));\n\t\t\t\tq[cur].pop();\n\t\t\t}\n\t\t\tsort(all(v), cmp);\n\t\t\trep(i, v.size()){\n\t\t\t\tif(cur == 1) v[i].S++;\n\t\t\t\tif(v[i].S == c[v[i].F]) assert(ans <= nxt), ans = nxt;\n\t\t\t\telse q[next].push(mp(v[i].F, mp(nxt + t[v[i].F], v[i].S)));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  //if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t  if (in[i].x == in[j].x )in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct S{\n  int time, lap;\n  int rem;  \n};\nbool operator < (S a, S b)\n{\n  return a.time < b.time;\n}\n\nint main(void)\n{\n  int n;\n  while( cin >> n && n ){\n    vector<S> lane[2];\n    for(int i=0; i<n; ++i){\n      S s;\n      cin >> s.time >> s.lap;\n      s.rem = s.time;\n      lane[0].push_back( s );\n    }\n    int time = 0;\n    while( lane[0].size() | lane[1].size() ){\n      \n      for(int i=0; i<2; ++i){\n\tfor(int j=0; j<lane[i].size(); ++j){\n\t  if( j ) lane[i][j].rem = max( lane[i][j].rem-1, lane[i][j-1].rem );\n\t  else lane[i][j].rem--;\n\t}\n      }\n\n      vector<S> tmp[2];\n      for(int i=0; i<2; ++i){\n\tfor(int j=0; j<lane[i].size(); ++j){\n\t  if( lane[i][j].rem == 0 ){\n\t    tmp[i].push_back( lane[i][j] );\n\t    tmp[i].back().rem = tmp[i].back().time;\n\t    lane[i].erase( lane[i].begin() + j );\n\t    --j;\n\t  }\n\t}\n\tsort( tmp[i].begin(), tmp[i].end() );\n      }\n      \n      for(int i=0; i<tmp[0].size(); ++i){\n\tlane[1].push_back( tmp[0][i] );\n      }\n\n      for(int i=0; i<tmp[1].size(); ++i){\n\tif( --tmp[1][i].lap ){\n\t  lane[0].push_back( tmp[1][i] );\n\t}\n      }\n      \n      ++time;\n    }\n    cout << time << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct S{\n  int time, lap;\n  int rem;  \n};\nbool operator < (S a, S b)\n{\n  return a.time < b.time;\n}\n\nint main(void)\n{\n  int n;\n  while( cin >> n && n ){\n    vector<S> lane[2];\n    for(int i=0; i<n; ++i){\n      S s;\n      cin >> s.time >> s.lap;\n      s.rem = s.time;\n      lane[0].push_back( s );\n    }\n    sort( lane[0].begin(), lane[0].end() );\n    int time = 0;\n    while( lane[0].size() | lane[1].size() ){\n      \n      for(int i=0; i<2; ++i){\n\tfor(int j=0; j<lane[i].size(); ++j){\n\t  if( j ) lane[i][j].rem = max( lane[i][j].rem-1, lane[i][j-1].rem );\n\t  else lane[i][j].rem--;\n\t}\n      }\n\n      vector<S> tmp[2];\n      for(int i=0; i<2; ++i){\n\tfor(int j=0; j<lane[i].size(); ++j){\n\t  if( lane[i][j].rem == 0 ){\n\t    tmp[i].push_back( lane[i][j] );\n\t    tmp[i].back().rem = tmp[i].back().time;\n\t    lane[i].erase( lane[i].begin() + j );\n\t    --j;\n\t  }\n\t}\n\tsort( tmp[i].begin(), tmp[i].end() );\n      }\n      \n      for(int i=0; i<tmp[0].size(); ++i){\n\tlane[1].push_back( tmp[0][i] );\n      }\n\n      for(int i=0; i<tmp[1].size(); ++i){\n\tif( --tmp[1][i].lap ){\n\t  lane[0].push_back( tmp[1][i] );\n\t}\n      }\n      \n      ++time;\n    }\n    cout << time << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Swimmer{\n    int t, v, c;\n    bool operator < (const Swimmer &s) const {return v < s.v;};\n};\n\nint N;\nvector<int> T, C;\n\nvoid solve(){\n    deque<Swimmer> q[2];\n    \n    vector<Swimmer> vec;\n    for(int i=0; i<N; i++){\n        int v, c; cin >> v >> c;\n        vec.push_back({0, v, c});\n    }\n    sort(vec.begin(), vec.end());\n    for(int i=0; i<N; i++)\n        q[0].push_back(vec[i]);\n    \n    int ans = 0;\n    while(!q[0].empty() || !q[1].empty()){\n        int cur;\n        if(q[0].empty())\n            cur = 1;\n        else if(q[1].empty())\n            cur = 0;\n        else if(q[0].front().t < q[1].front().t){\n            cur = 0;\n        }else{\n            cur = 1;\n        }\n        \n        auto s = q[cur].front(); q[cur].pop_front();\n        \n        if(cur == 0){\n            if(s.c == 0)\n                ans = s.t;\n            else{\n                s.t += s.v;\n                if(!q[cur^1].empty() && q[cur^1].back().t > s.t)\n                    s.t = q[cur^1].back().t;\n                s.c--;;\n                q[cur^1].push_back(s);\n            }\n        }else{\n            s.t += s.v;\n            if(!q[cur^1].empty() && q[cur^1].back().t > s.t)\n                s.t = q[cur^1].back().t;\n            q[cur^1].push_back(s);\n        }\n        vector<Swimmer> vec;\n        while(!q[cur^1].empty() && q[cur^1].back().t == s.t){\n            vec.push_back(q[cur^1].back()); q[cur^1].pop_back();\n        }\n        sort(vec.begin(), vec.end());\n        for(auto s: vec)\n            q[cur^1].push_back(s);\n            \n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin >> N, N){\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct P{\n  int t,c,x;\n  bool f;\n  P(){}\n  P(int t,int c):t(t),c(c){x=f=0;}\n  bool operator<(const P a)const{\n    return t>a.t;\n  } \n};\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int t[n],c[n];\n    for(int i=0;i<n;i++) cin>>t[i]>>c[i];\n    priority_queue<P> q[2];\n    for(int i=0;i<n;i++) q[0].push(P(t[i],c[i]*2-1));\n    deque<P> v[2];\n    while(!q[0].empty()){\n      v[0].push_back(q[0].top());q[0].pop();\n    }\n    int ans=0;\n    while(!v[0].empty()||!v[1].empty()){\n      ans++;\n      for(int k=0;k<2;k++){\n\tfor(int i=0;i<(int)v[k].size();i++){\n\t  v[k][i].x++;\n\t  P p=v[k][i];\n\t  if((!i&&p.x>=p.t)||(i&&v[k][i-1].f&&p.x>=p.t)){\n\t    //cout<<ans<<\":\"<<k<<\":\"<<i<<\" \"<<p.t<<\" \"<<p.x<<\" \"<<p.c<<endl;\n\t    v[k][i].f=1;\n\t    if(p.c){\n\t      p.x=0;\n\t      p.c--;\n\t      q[!k].push(p);\n\t    }\n\t  }\n\t}\n\twhile(!v[k].empty()&&v[k].front().f) v[k].pop_front();\n      }\n      for(int k=0;k<2;k++){\n\twhile(!q[k].empty()){\n\t  v[k].push_back(q[k].top());q[k].pop();\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <climits>\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <iostream>\n#include <deque>\n#include <array>\n#include <set>\n#include <functional>\n#include <memory>\n#include <stack>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nstruct Record {\n\tint id, reach_time, speed;\n\tRecord turn(const int time) const { return { id, time + speed, speed }; }\n};\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) return 0;\n\t\tstd::vector<int> time(n); std::vector<int> target(n);\n\t\tfor (auto i = 0; i < n; ++i) std::cin >> time[i] >> target[i];\n\t\tstd::queue<Record> forward, backward;\n\t\tauto compare_by_speed = [](const Record& a, const Record& b) {return a.speed > b.speed; };\n\t\tstd::priority_queue<Record, std::vector<Record>, decltype(compare_by_speed)> queue(compare_by_speed);\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tqueue.push(Record{ i, time[i], time[i] });\n\t\t}\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tforward.push(queue.top()); queue.pop();\n\t\t}\n\t\tauto last_time = 0; auto end_count = 0;\n\t\twhile (end_count != n) {\n\t\t\twhile (!forward.empty() && (backward.empty() || backward.front().reach_time >= forward.front().reach_time)) {\n\t\t\t\tlast_time = forward.front().reach_time;\n\t\t\t\twhile (!forward.empty() && forward.front().reach_time <= last_time) {\n\t\t\t\t\tqueue.push(forward.front()); forward.pop();\n\t\t\t\t}\n\t\t\t\twhile (!queue.empty()) {\n\t\t\t\t\tbackward.push(queue.top().turn(last_time)); queue.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!backward.empty() && (forward.empty() || forward.front().reach_time >= backward.front().reach_time)) {\n\t\t\t\tlast_time = backward.front().reach_time;\n\t\t\t\twhile (!backward.empty() && backward.front().reach_time <= last_time) {\n\t\t\t\t\t--target[backward.front().id];\n\t\t\t\t\tif (target[backward.front().id] != 0) {\n\t\t\t\t\t\tqueue.push(backward.front());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t++end_count;\n\t\t\t\t\t}\n\t\t\t\t\tbackward.pop();\n\t\t\t\t}\n\t\t\t\twhile (!queue.empty()) {\n\t\t\t\t\tforward.push(queue.top().turn(last_time)); queue.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << last_time << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\ntypedef tuple<int, int, int, int> T;\n\n\nint main(){\n\tint n;\n\twhile (cin >> n, n){\n\t\tvector<int> t(n), c(n);\n\t\trep(i, n) cin >> t[i] >> c[i];\n\n\t\t// time, t, rem, pos\n\t\tpriority_queue<T, vector<T>, greater<T>> q;\n\t\trep(i, n) q.push(MT(0, t[i], c[i], 0));\n\n\t\tint lim[2] = {};\n\t\twhile (!q.empty()){\n\t\t\tauto t = q.top();\n\t\t\tq.pop();\n\t\t\tint curtime, time, rem, pos;\n\t\t\ttie(curtime, time, rem, pos) = t;\n\t\t\tif (!rem) continue;\n\n\t\t\tint npos = pos ^ 1;\n\t\t\tint nxttime = max(curtime+time, lim[npos]);\n\t\t\tif (!npos) --rem;\n\t\t\tlim[npos] = max(lim[npos], nxttime);\n\t\t\tq.push(MT(nxttime, time, rem, npos));\n\t\t}\n\t\tcout << *max_element(lim, lim + 2) << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tvector<pair<int, int>>mers;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint t, c; cin >> t >> c;\n\t\t\tc *= 2;\n\t\t\tmers.push_back(make_pair(t, c));\n\t\t}\n\t\tsort(mers.begin(), mers.end(), [](const pair<int, int>&l, const pair<int, int>&r) {return l.first < r.first; });\n\n\t\tvector<pair<int, int>>sits;//f:終了時間　s:残りレーン数\n\t\tvector<int>lanetime(2);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tsits.push_back(make_pair(mers[i].first, mers[i].second));\n\t\t\tlanetime[0] = mers[i].first;\n\t\t}\n\t\tlanetime[1] = 0;\n\t\tint swimming = n;\n\t\tint time = 1;\n\t\tfor (time = 1; swimming;++time){\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (sits[i].second == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if (sits[i].first == time) {\n\t\t\t\t\tsits[i].second--;\n\t\t\t\t\tif (sits[i].second == 0) {\n\t\t\t\t\t\tswimming--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsits[i].first = max(time + mers[i].first, lanetime[sits[i].second % 2]);\n\t\t\t\t\t\tlanetime[sits[i].second % 2] = sits[i].first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << time - 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nstruct Swimmer {\n\tint t, c, e;\n\tSwimmer(int t, int c, int e) : t(t), c(c), e(e) { }\n};\nconst int INF = 1000000000;\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<pii> input(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> input[i].first >> input[i].second;\n\t\t}\n\t\tqueue<Swimmer> forward, backward;\n\t\tsort(input.begin(), input.end());\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tint t = input[i].first, c = input[i].second;\n\t\t\tforward.push(Swimmer(t, c, t));\n\t\t}\n\t\tint answer = 0;\n\t\twhile(!forward.empty() || !backward.empty()){\n\t\t\tint ft = (forward.empty() ? INF : forward.front().e);\n\t\t\tint bt = (backward.empty() ? INF : backward.front().e);\n\t\t\tint tm = min(ft, bt);\n\t\t\tanswer = tm;\n\t\t\tqueue<Swimmer> &q = (ft < bt) ? forward : backward;\n\t\t\tvector<pii> next;\n\t\t\twhile(!q.empty() && q.front().e <= tm){\n\t\t\t\tSwimmer sw = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tif(ft >= bt && --sw.c == 0){ continue; }\n\t\t\t\tnext.push_back(pii(sw.t, sw.c));\n\t\t\t}\n\t\t\tsort(next.begin(), next.end());\n\t\t\tqueue<Swimmer> &opp = (ft < bt) ? backward : forward;\n\t\t\tfor(int i = 0; i < next.size(); ++i){\n\t\t\t\tint t = next[i].first, c = next[i].second;\n\t\t\t\topp.push(Swimmer(t, c, t + tm));\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int t, c, tRest;\n    Data(){}\n    Data(int t0, int c0){\n        t = tRest = t0;\n        c = c0;\n    }\n    bool operator<(const Data& d) const{\n        return t < d.t;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<Data> d(n);\n        for(int i=0; i<n; ++i){\n            int t, c;\n            cin >> t >> c;\n            d[i] = Data(t, c);\n        }\n        sort(d.begin(), d.end());\n\n        deque<Data> lane1, lane2;\n        for(int i=0; i<n; ++i)\n            lane1.push_back(d[i]);\n\n        int ret = 0;\n        while(!lane1.empty() || !lane2.empty()){\n            ++ ret;\n            for(unsigned i=0; i<lane1.size(); ++i)\n                -- lane1[i].tRest;\n            for(unsigned i=0; i<lane2.size(); ++i)\n                -- lane2[i].tRest;\n            if(lane1.size() > 0 && lane1[0].tRest == 0){\n                vector<Data> d;\n                while(!lane1.empty() && lane1[0].tRest <= 0){\n                    lane1[0].tRest = lane1[0].t;\n                    d.push_back(lane1[0]);\n                    lane1.pop_front();\n                }\n                sort(d.begin(), d.end());\n                for(unsigned i=0; i<d.size(); ++i)\n                    lane2.push_back(d[i]);\n            }\n            if(lane2.size() > 0 && lane2[0].tRest == 0){\n                vector<Data> d;\n                while(!lane2.empty() && lane2[0].tRest <= 0){\n                    -- lane2[0].c;\n                    if(lane2[0].c > 0){\n                        lane2[0].tRest = lane2[0].t;\n                        d.push_back(lane2[0]);\n                    }\n                    lane2.pop_front();\n                }\n                sort(d.begin(), d.end());\n                for(unsigned i=0; i<d.size(); ++i)\n                    lane1.push_back(d[i]);\n            }\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 500;\nconst double GOAL = 1000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nvoid solve(int n,vector<state>& in){\n  double ans=0;\n  sort(ALL(in));\n  while(n){\n    double mint=inf;\n    \n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID, in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      //      REP(j,i+1,n){\n      rep(j,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n    \n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    //    sort(ALL(in));\n    sort(in.begin(),in.begin()+n);\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (in[i].x > eps && fabs(in[i].x-in[j].x)<eps &&\n\t      in[j].v < in[i].v)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    //sort(ALL(in));\n    sort(in.begin(),in.begin()+n);\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n\n  printf(\"%.0lf\\n\",ans+eps);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    solve(n,in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    //return false;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nvoid solve(int n,vector<state>& in){\n  double ans=0;\n  sort(ALL(in));\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID, in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      //      REP(j,i+1,n){\n      rep(j,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (in[i].x > eps && fabs(in[i].x-in[j].x)<eps &&\n\t      in[j].v < in[i].v)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n\n  printf(\"%.0lf\\n\",ans+eps);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    solve(n,in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  /*\n  rep(i,n){\n    cout << in[i].now <<\"/\"<<in[i].t<<\" \"<<in[i].t\n\t << \" \" << in[i].cnt << endl;\n  }\n  cout << endl;\n  */\n  while(n){\n\n    rep(i,n){\n      in[i].now+=1;\n      for(int j=n-1;j>i;j--){\n\tif ((in[i].now)*in[j].t >= (in[j].now+1)*in[i].t){\n\t  in[i].now=in[j].now+1;\n\t  in[i].t=in[j].t;\n\t}\n      }\n    }\n    \n    rep(i,n){\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf;\n\t}\n      }\n    }\n    \n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].now == inf)n--;\n    }\n\n    /*\n    rep(i,n){\n      cout << in[i].now <<\"/\"<<in[i].t<<\" \"<<in[i].t\n\t   << \" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    ans++;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Swimmer {\n    int t,c;\n    Swimmer(int t,int c) : t(t) , c(c) {;}\n};\n\nbool operator<(const Swimmer &s,const Swimmer &t) {\n    return s.t < t.t;\n}\n\nint main() {\n    int n,t,c;\n    while(cin>>n, n) {\n        vector<Swimmer> vs;\n        for(int i=0; i<n; ++i) {\n            cin>>t>>c;\n            vs.push_back(Swimmer(t,c));\n        }\n        sort(vs.begin(), vs.end());\n\n        queue<pair<int,int> > q1,q2;\n        for(int i=0; i<n; ++i) q1.push(make_pair(vs[i].t,i));\n\n        int time,ans = 0;\n        for(time = 0; time < 300*250+1; time++) {\n            if(!q1.empty()) {\n                if(q1.front().first == time) {\n                    vector<pair<int,int> > wait;\n                    while(!q1.empty() && q1.front().first <= time) {\n                        wait.push_back(make_pair(vs[q1.front().second].t,q1.front().second));\n                        q1.pop();\n                    }\n\n                    if(q1.empty()) {\n                        while(!q2.empty() && q2.front().first+vs[q2.front().second].t <= time) {\n                            vs[q2.front().second].c--;\n                            if(vs[q2.front().second].c == 0) ans = max(ans,q2.front().first);\n                            else wait.push_back(make_pair(vs[q2.front().second].t,q2.front().second));\n                            q2.pop();\n                        }\n                    }\n\n                    sort(wait.begin(), wait.end());\n                    for(int i=0; i<wait.size(); ++i) {\n                        q2.push(make_pair(time+wait[i].first,wait[i].second));\n                    }\n                }\n            }\n            if(!q2.empty()) {\n                if(q2.front().first == time) {\n                    vector<pair<int,int> > wait;\n                    while(!q2.empty() && q2.front().first <= time) {\n                        vs[q2.front().second].c--;\n                        if(vs[q2.front().second].c == 0) ans = max(ans,q2.front().first);\n                        else wait.push_back(make_pair(vs[q2.front().second].t,q2.front().second));\n                        q2.pop();\n                    }\n\n                    if(q2.empty()) {\n                        while(!q1.empty() && q1.front().first+vs[q1.front().second].t <= time) {\n                            wait.push_back(make_pair(vs[q1.front().second].t,q1.front().second));\n                            q1.pop();\n                        }\n                    }\n\n                    sort(wait.begin(),wait.end());\n                    for(int i=0; i<wait.size(); ++i)\n                        q1.push(make_pair(time+wait[i].first,wait[i].second));\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nstruct Data { int time, lane, lap; };\n\nbool is_end(vector<bool>& v)\n{\n\tfor (auto i : v)\n\t{\n\t\tif (!i) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvi v;\n\t\tvector<Data> tmp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tint t, c; cin >> t >> c;\n\t\t\tv.emplace_back(t);\n\t\t\ttmp.push_back(Data{ t, 0, c });\n\t\t}\n\t\tvector<bool> finish(n);\n\t\tint ans = 0;\n\t\twhile (is_end(finish))\n\t\t{\n\t\t\tint time = INF, p;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tif (finish[i]) continue;\n\t\t\t\tif (tmp[i].time < time)\n\t\t\t\t{\n\t\t\t\t\ttime = tmp[i].time;\n\t\t\t\t\tp = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += time;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tif (finish[i]) continue;\n\t\t\t\tif (tmp[i].time != time) tmp[i].time -= time;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i].lane)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp[i].lap--;\n\t\t\t\t\t\tif (tmp[i].lap == 0) finish[i] = true;\n\t\t\t\t\t\ttmp[i].lane = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp[i].lane = 1;\n\t\t\t\t\t}\n\t\t\t\t\ttmp[i].time = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxf = 0, maxb = 0;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tif (finish[i]) continue;\n\t\t\t\tif (tmp[i].time != -1)\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i].lane == 0) chmax(maxf, tmp[i].time);\n\t\t\t\t\telse chmax(maxb, tmp[i].time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tif (finish[i]) continue;\n\t\t\t\tif (tmp[i].time == -1)\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i].lane == 0) tmp[i].time = max(maxf, v[i]);\n\t\t\t\t\telse tmp[i].time = max(maxb, v[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<cassert>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\n\nusing namespace std;\ntypedef pair<int,int> ii;\n\nstruct P\n{\n  ii time;\n  bool dir;//0->上, 1->下\n  P(ii time=ii(inf,inf),bool dir=false):time(time),dir(dir){}\n};\n\nint ans;\nint n;\n\nvoid compute(vector<vector<P> > &record,ii person)\n{\n  //cout << \"\\nperson : \" << person.first << \",\" << person.second << endl;\n  int cur = 0;\n  record.push_back(vector<P>());\n\n\n  rep(i,person.second*2)\n    {\n      bool dir = i % 2;//0->上,1->下\n      int next = cur + person.first;\n\n      //cout << \"chech---------- : \" << i << \" | \" << record.size() << endl;\n      rep(j,record.size()-1)\n\t{\n\t  rep(k,record[j].size())\n\t    {\n\t      P p = record[j][k];\n\t      //cout << \"ch(\" << p.time.first << \",\" << p.time.second <<\") dir : \" <<  (dir?\"↓\":\"↑\") << \"\\n\";\n\t      //if(p.time.second < cur)break;\n\t      if(p.dir != dir)continue;\n\t      if(p.time.first > cur)break;\n\n\t      if(p.time.second == next || p.time.first == cur)\n\t\t{\n\t\t  break;\t\t  \n\t\t}\n\t      else if(p.time.first < next && next < p.time.second)\n\t\t{\n\t\t  next = max(p.time.second,next);\n\t\t  break;\n\t\t\t     //goto Skip;\n\t\t}\n\t    }\n\t}\n\t  //Skip:;\n      //cout << \"result (\" << cur << \",\" << next << \") : \" << (dir?\"↓\":\"↑\") << endl;\n      record[record.size()-1].push_back(P(ii(cur,next),dir));\n      cur = next;\n      ans = max(ans,next);\n    } \n}\n\nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      ans = 0;\n      vector<ii> info(n);\n      rep(i,n)scanf(\"%d %d\",&info[i].first,&info[i].second);\n      sort(all(info),greater<ii>());\n\n      vector<vector<P> > record;\n\n      rep(i,n)compute(record,info[i]);\n\n      printf(\"%d\\n\",ans);\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n\n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tvector<pair<int, int>> swimmers(n);\n\t\tvector<int> t(n), c(n);\n\n\t\tfor(auto &e : swimmers) {\n\t\t\tcin >> e.first >> e.second;\n\t\t}\n\n\t\tsort(swimmers.begin(), swimmers.end());\n\t\tqueue<pair<int, int>> go, back;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tgo.push({swimmers[i].first, i});\n\t\t}\n\n\t\tint go_last = swimmers[n - 1].first;\n\t\tint back_last = 0;\n\t\twhile(true) {\n\t\t\tint time = INT_MAX;\n\t\t\tbool go_turn;\n\t\t\tset<int> S;\n\n\t\t\tif(!go.empty()) {\n\t\t\t\ttime = go.front().first;\n\t\t\t\tgo_turn = true;\n\t\t\t}\n\t\t\tif(!back.empty() && time > back.front().first) {\n\t\t\t\ttime = back.front().first;\n\t\t\t\tgo_turn = false;\n\t\t\t}\n\n\t\t\tif(go_turn) {\n\t\t\t\twhile(!go.empty() && time == go.front().first) {\n\t\t\t\t\tS.insert(go.front().second);\n\t\t\t\t\tgo.pop();\n\t\t\t\t}\n\n\t\t\t\tfor(const auto &e : S) {\n\t\t\t\t\tchmax(back_last, time + swimmers[e].first);\n\t\t\t\t\tback.push({back_last, e});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile(!back.empty() && time == back.front().first) {\n\t\t\t\t\tS.insert(back.front().second);\n\t\t\t\t\tback.pop();\n\t\t\t\t}\n\n\t\t\t\tfor(const auto &e : S) {\n\t\t\t\t\tif(--swimmers[e].second == 0) continue;\n\t\t\t\t\tchmax(go_last, time + swimmers[e].first);\n\t\t\t\t\tgo.push({go_last, e});\n\t\t\t\t}\n\n\t\t\t\tif(go.empty() && back.empty()) {\n\t\t\t\t\tcout << time << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    double EPS = 1e-8;\n    double length = 1e6;\n    int n; cin >> n;\n    if(!n) break;\n    VI t(n), c(n);\n    vector<PII> p(n);\n    REP(i, n) {\n      cin >> t[i] >> c[i];\n      p[i] = pair<double,int>{t[i], c[i]};\n    }\n    sort(ALL(p));\n\n    // i人目の人の速度\n    vector<double> v(n);\n    REP(i, n) v[i] = length/p[i].first;\n\n    // i人目の人の位置、何周目か\n    vector<pair<double,int>> place(n, {0, 0});\n    vector<pair<double,int>> nxt(n, {0, 0});\n    int i, num;\n    for(i=0, num=0; num<n; ++i) {\n      // j人目を進める\n      REP(j, n) {\n        if(place[j].second >= c[j]) continue;\n        double tmp = place[j].first + v[j];\n        REP(k, n) {\n          if(j==k) continue;\n          if(place[k].second >= p[k].second) continue;\n          if(place[j].first < EPS && place[k].first < EPS) continue;\n          if(abs(place[j].first-length) < EPS && abs(place[k].first - length) < EPS) continue;\n          // jがkを追い越す\n          if(place[j].first <= place[k].first && place[j].first+v[j] > place[k].first+v[k]) {\n            chmin(tmp, place[k].first+v[k]);\n          }\n        }\n        if(place[j].first < 2*length && 2*length <= tmp+EPS) {\n          nxt[j] = pair<double,int>{0, place[j].second+1};\n          if(nxt[j].second >= p[j].second) num++;\n        }\n        else {\n          nxt[j] = pair<double,int>{tmp, place[j].second};\n        }\n      }\n      place = nxt;\n      // cout << place << endl;\n    }\n\n    cout << i << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  int m= n;\n  while(m){\n    int mint = inf;\n\n    rep(i,n){\n      if (in[i].now == inf)continue;\n      mint = min(mint,in[i].t-in[i].now%in[i].t);\n    }\n\n    /*    \n    rep(i,n){\n      in[i].now+=1;\n      bool ischanged=false;\n      for(int j=n-1;j>i;j--){\n\tif ((in[i].now)*in[j].t >= (in[j].now+1)*in[i].t){\n\t  in[i].now=in[j].now+1;\n\t  in[i].t=in[j].t;\n\t  ischanged=true;\n\t  mint=1;\n\t}\n      }\n      in[i].now-=1;\n    }\n    */    \n    \n    rep(i,n){\n      if (in[i].now == inf)continue;\n      in[i].now+=1;\n      rep(j,n){\n\tif (i == j)continue;\n\tif (in[j].now == inf)continue;\n\tif ((in[i].now-1)*in[j].t >=(in[j].now)*in[i].t)continue;\n\tif ((in[i].now)*in[j].t >= (in[j].now+1)*in[i].t){\n\t  in[i].now=in[j].now+1;\n\t  in[i].t=in[j].t;\n\t  mint=1;\n\t}\n      }\n      in[i].now-=1;\n    }\n\n    \n    rep(i,n){\n      in[i].now+=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf,m--;\n\t}\n      }\n    }\n    \n\n\n\n    ans+=mint;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <numeric> \n#include <cstdlib> \n#include <climits> \n#include <cmath> \n#include <cstdio> \n#include <cfloat> \n#include <map> \n#include <utility> \n#include <set> \n#include <cassert>\n#include <memory> \n#include <algorithm> \n#include <functional> \n#include <sstream> \n#include <complex> \n#include <stack> \n#include <queue> \n#include <string> \n#include <vector> \nusing namespace std; \n\n#define rep(i, n) for(int i = 0; i < n; i++) \n#define rep2(i, m, n) for(int i = m; i < n; i++) \nconst double EPS = 1E-6; \ntypedef long long ll; \ntypedef pair<int, int> P; \ntypedef pair<int, P> PP; \ntypedef complex<double> xy_t; \nconst int INF = 1 << 30; \n\n\n\nstruct swimmer{\n  int t;\n  double pos;\n  int lane;\n  int rest_loop;\n};\n\nint n;\nswimmer ss[100];\n\nbool operator<(swimmer s1, swimmer s2){\n  if(s1.rest_loop == 0 || s2.rest_loop == 0) return s1.rest_loop > s2.rest_loop;\n  else if(s1.lane != s2.lane) return s1.lane > s2.lane;\n  else {\n    if(s1.pos < EPS && s2.pos < EPS) return s1.t < s2.t;\n    else return s1.pos > s2.pos;\n  }\n}\n\nbool finish(){\n  int cnt = 0;\n  rep(i, n){\n    if(ss[i].rest_loop > 0) cnt++;\n  }\n  return cnt == 0;\n}\n\nvoid move(){\n  rep(i, n){\n    if(ss[i].rest_loop) ss[i].pos += 1.0 / ss[i].t;\n  }\n  rep(i, n){\n    rep(j, i){\n      if(ss[i].rest_loop && ss[j].rest_loop && ss[i].lane == ss[j].lane && ss[i].pos > ss[j].pos){\n\tss[i].pos = ss[j].pos;\n      }\n    }\n  }\n  rep(i, n){\n    if(ss[i].rest_loop == 0) continue;\n    if(abs(1.0 - ss[i].pos) < EPS){\n      ss[i].pos = 0;\n      if(ss[i].lane){\n\tss[i].lane = 0;\n\tss[i].rest_loop--;\n      }else{\n\tss[i].lane = 1;\n      }\n    }\n  }\n  \n}\n\nint main(){\n  while(cin >> n && n){\n    rep(i, n){\n      cin >> ss[i].t >> ss[i].rest_loop;\n      ss[i].pos = 0.0;\n      ss[i].lane = 0;\n    }\n    sort(ss, ss + n);\n    int cnt = 0;\n    while(true){\n      if(finish()){\n\tcout << cnt << endl;\n\tbreak;\n      }\n      cnt++;\n      move();\n      sort(ss, ss + n);\n      if(cnt > 800000){\n\tassert(false);\n      }\n    }\n  }\n  return 0;\n}\n\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nP x[50];\nint dp[2][100000];\n\nvoid solve(){\n\trep(i,2) rep(j,100000) dp[i][j] = 0;\n\trep(i,n) cin >> x[i].first >> x[i].second;\n\trep(i,n) x[i].second *= 2;\n\tsort(x,x+n,greater<P>());\n\tint ans = 0;\n\trep(i,n){\n\t\tint dir = 0;\n\t\tint ti = 0;\n\t\twhile(x[i].second){\n\t\t\tint tmpti = ti;\n\t\t\tif(ti == 0) ti = ti+x[i].first;\n\t\t\telse ti = max(ti+x[i].first,dp[dir][ti-1]);\n\t\t\tdp[dir][tmpti] = max(dp[dir][tmpti],ti);\n\t\t\tdir = dir^1;\n\t\t\tx[i].second--;\n\t\t}\n\t\trep(j,2) for(int k = 1; k < 100000; k++) dp[j][k] = max(dp[j][k],dp[j][k-1]);\n\t}\n\trep(i,2) rep(j,100000) ans = max(ans,dp[i][j]);\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef vector<int> vi;\n \nint main(){\n  int n;\n  while(cin >> n,n){\n    vp s(n);\n    vi t(n), c(n);\n    rep(i,n){\n      cin >> t[i] >> c[i];\n      s[i] = pii(t[i],c[i]);\n    }\n    sort(all(s));\n    \n    vi q[2];\n    rep(i,n)q[0].push_back(i);\n     \n    int ans = 0;\n    while(q[0].size() || q[1].size()){\n      vi g[2];\n      int nxt = 1000;\n      rep(x,2){\n\tif(q[x].size())nxt = min(nxt, t[q[x].front()]);\n      }\n      ans += nxt;\n\n      rep(x,2){\n\trep(i,q[x].size()){\n\t  t[q[x][i]] -= nxt;\n\t  if(i>0 && t[q[x][i-1]] > t[q[x][i]])t[q[x][i]] = t[q[x][i-1]];\n\t}\n\twhile(q[x].size()){\n\t  if(t[q[x][0]])break;\n\t  g[x].push_back(q[x][0]);\n\t  q[x].erase(q[x].begin());\n\t}\n      }\n       \n      sort(all(g[0])); sort(all(g[1]));\n      for(int id : g[0]){\n\tq[1].push_back(id);\n\tt[id] = s[id].first;\n      }\n      for(int id : g[1]){\n\tif(--c[id]){\n\t  q[0].push_back(id);\n\t  t[id] = s[id].first;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nP p[50];\n\nint H[55][333][2];\n\nint calc(int i,int f,int t,int c,int *F){\n  int tot = t + p[i].first;\n  if( c == 0 ) return tot;\n  for(int j=i+1;j<N;j++){\n    if( c - F[j] - 1 < 0 ) continue;\n    if( H[j][c-F[j]-1][f] > tot )\n      tot = H[j][c-F[j]-1][f];    \n  }\n  for(int j=i+1;j<N;j++){\n    if( c-F[j]-1<0 ) continue;\n    if( H[j][c-F[j]-1][f] == tot ) F[j]++;\n  }\n  return tot;\n}\n\nint main(){\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++){\n      cin >> p[i].first >> p[i].second;\n    }\n    memset(H,0,sizeof(H));\n    int res = 0;\n    sort(p,p+N);\n    for(int i=N-1;i>-1;i--){\n      int t = 0, F[55] = {};\n      for(int c=0; c < p[i].second; c++ ){\n\tt = calc(i,0,t,c,F);\n\tH[i][c][0] = t;\n\tt = calc(i,1,t,c,F);\n\tH[i][c][1] = t;\n\tres = max( res, t );\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n; cin >> n;\n    if(!n) break;\n    VI t(n), c(n);\n    vector<PII> p(n);\n    REP(i, n) {\n      cin >> t[i] >> c[i];\n      p[i] = {t[i], i};\n    }\n    sort(ALL(p));\n\n    // (人i, 折り返すまでにかかる時間, 周回数)\n    queue<VI> que[2];\n    REP(i, n) que[0].push({p[i].second, p[i].first, 0});\n\n    int ans = 0;\n    while(que[0].size() || que[1].size()) {\n      // curのqueueから取り出す\n      int cur = 0;\n      if(que[cur].empty()) cur ^= 1;\n      else if(que[cur^1].size() && que[cur].front()[1] > que[cur^1].front()[1]) cur ^= 1;\n\n      // next以下のものを取り出す\n      VVI v;\n      int next = que[cur].front()[1];\n      while(que[cur].size() && que[cur].front()[1] <= next) {\n        v.PB(que[cur].front());\n        que[cur].pop();\n      }\n      // vの中身を速度順でソートする\n      sort(ALL(v), [&](const VI&a, const VI&b){\n        return t[a[0]] < t[b[0]];\n      });\n      // vの中身を次のqueueに移す\n      REP(i, v.size()) {\n        if(cur == 1) v[i][2]++;\n        if(v[i][2] == c[v[i][0]]) ans = next;\n        else que[cur^1].push({v[i][0], next+t[v[i][0]], v[i][2]});\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 55, maxm = 550;\nint n, id[maxn], t[maxn], c[maxn], top[maxn], ans[maxn][maxm];\n\nbool cmp(const int &a, const int &b)\n{\n    return t[a] > t[b];\n}\n\nint main()\n{\n    while (scanf(\"%d\", &n), n)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%d%d\", &t[i], &c[i]);\n            c[i] <<= 1;\n            id[i] = i;\n        }\n        sort(id, id + n, cmp);\n        int last = 0;\n        for (int k = 0; k < n; k++)\n        {\n            int i = id[k];\n            memset(top, 0, sizeof top);\n            ans[i][0] = 0;\n            for (int j = 1; j <= c[i]; j++)\n            {\n                ans[i][j] = ans[i][j - 1] + t[i];\n                for (int h = 0; h < k; h++)\n                {\n                    int pre = id[h];\n                    if (ans[pre][top[pre] + 1] < ans[i][j - 1]) \n                        top[pre]++;\n                    //if (top[pre] % 2 != j % 2)\n                    //    top[pre]++;\n                    if (top[pre] % 2 == (j + 1) % 2 && top[pre] + 1 <= c[pre] && ans[pre][top[pre]] < ans[i][j - 1] && ans[pre][top[pre] + 1] > ans[i][j])\n                        ans[i][j] = ans[pre][top[pre] + 1];\n                }\n\t\t//printf(\"%d %d %d\\n\", i, j, ans[i][j]);\n            }\n            last = max(last, ans[i][c[i]]);\n        }\n        printf(\"%d\\n\", last);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Swimmer{\n    int idx,t,c;\n    int reach;\n};\nconst int INF=1e9;\nbool operator<(Swimmer lhs,Swimmer rhs){\n    return lhs.t<rhs.t;\n}\nint solve(int n){\n    vector<Swimmer> swimmer(n);\n    for(int i=0;i<n;i++){\n        int t,c;\n        cin>>t>>c;\n        swimmer[i]=Swimmer{i,t,c,t};\n    }\n    sort(swimmer.begin(),swimmer.end());\n    queue<Swimmer> fque;\n    queue<Swimmer> bque;\n    for(auto &s:swimmer) fque.push(s);\n\n    int res=0;\n    while(!(fque.empty() && bque.empty())){\n        int ft=(fque.empty() ? INF : fque.front().reach);\n        int bt=(bque.empty() ? INF : bque.front().reach);\n        if(ft<bt){\n            auto s=fque.front();\n            int t=s.reach;\n            vector<Swimmer> goals;\n            while(!fque.empty() && fque.front().reach<=s.reach){\n                goals.push_back(fque.front());\n                fque.pop();\n            }\n            sort(goals.begin(),goals.end());\n            for(auto &e:goals){\n                bque.push(Swimmer{e.idx,e.t,e.c,t+e.t});\n            }\n            res=t;\n        }\n        else{\n            auto s=bque.front();\n            int t=s.reach;\n            vector<Swimmer> goals;\n            while(!bque.empty() && bque.front().reach<=s.reach){\n                goals.push_back(bque.front());\n                bque.pop();\n            }\n            sort(goals.begin(),goals.end());\n            for(auto &e:goals){\n                if(e.c-1>0) fque.push(Swimmer{e.idx,e.t,e.c-1,t+e.t});\n            }\n            res=t;\n        }\n    }\n    return res;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define eps (1e-8)\ndouble t[60];\nstruct pp\n{\n\tint num,c;\n\tdouble t,pos;\n\tbool operator<(pp xx)const{\n\t\tif(xx.c==c&&c==0)return num<xx.num;\n\t\tif(xx.c==0)return 1;\n\t\tif(c==0)return 0;\n\t\tif(abs(pos-xx.pos)<eps)return t>xx.t; \n\t\treturn pos<xx.pos;\n\t}\n}\na[60];\nint n;\ndouble now,v[60];\nqueue<double>q;\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)return 0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tdouble t;\n\t\t\tscanf(\"%lf%d\",&t,&a[i].c);\n\t\t\t\n\t\t\ta[i].t=t;\n\t\t\ta[i].c++;\n\t\t\ta[i].num=i;\n\t\t\tv[a[i].num]=a[i].t;\n\t\t\ta[i].pos=0;\n\t\t}\n\t\tsort(a+1,a+n+1);\n\t\tq.push(0);\n\t\tdouble ans=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tdouble t=q.front();\n\t\t\tans+=t;\n\t\t\tq.pop();\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\ta[i].pos+=t/a[i].t;\n\t\t\t\t}\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t\tif(a[i+1].c&&abs(a[i].pos-a[i+1].pos)<eps)\n\t\t\t\t{\n\t\t\t\t\ta[i].t=max(a[i].t,a[i+1].t);\n\t\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\twhile(a[i].pos>=2-eps)a[i].pos-=2;\n\t\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\tif(a[i].pos<eps)a[i].c-=1;\n\t\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\tif(a[i].pos<eps||abs(a[i].pos-1)<eps)\n\t\t\t\t{\n\t\t\t\t\ta[i].t=v[a[i].num];\n\t\t\t\t}\n\t\t\tdouble tt=1e100;\n\t\t\tsort(a+1,a+n+1);\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t{\n\t\t\t\tdouble t2=0;\n\t\t\t\tif(a[i].pos>1-eps)t2=(2-a[i].pos)*a[i].t;\n\t\t\t\telse t2=(1-a[i].pos)*a[i].t;\n\t\t\t\ttt=min(tt,t2);\n\t\t\t}\n\t\t\tfor(int i=n;i>=2;i--)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\tif(a[i].t>a[i-1].t+eps&&a[i].pos-a[i-1].pos>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble t2=(a[i].pos-a[i-1].pos)/(1./a[i-1].t-1./a[i].t);\n\t\t\t\t\t\tif(t2<tt)a[i-1].pos=a[i].pos,a[i-1].t=a[i].t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(tt!=1e100)q.push(tt);\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",(int)round(ans));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Swimmer {\n  int v, lap, next;\n  Swimmer(){}\n  Swimmer(int v, int lap, int next):v(v), lap(lap), next(next){}\n  bool operator < (const Swimmer& s) const {\n    return v < s.v;\n  }\n};\n\nint N;\nvector<Swimmer> swimmer;\nqueue<Swimmer> lane[2];\n\nint main() {\n  while(cin >> N, N) {\n    swimmer.clear();\n    for(int i = 0; i < N; i++) {\n      int t, c;\n      cin >> t >> c;\n      swimmer.emplace_back(t, c, t);\n    }\n    sort(begin(swimmer), end(swimmer));\n    for(auto&& s : swimmer) lane[0].push(s);\n    int ans = 0;\n    while(!lane[0].empty() || !lane[1].empty()) {\n      bool id = lane[0].empty();\n      if(!id && !lane[1].empty()) id = lane[1].front().next < lane[0].front().next;\n      vector<Swimmer> vec;\n      vec.push_back(lane[id].front());\n      int tmp = vec[0].next;\n      lane[id].pop();\n      while(!lane[id].empty() && tmp >= lane[id].front().next) {\n\tvec.push_back(lane[id].front());\n\tlane[id].pop();\n      }\n      for(auto&& s : vec) {\n\ts.next = tmp+s.v;\n\ts.lap -= id;\n\tif(s.lap == 0) ans = max(ans, tmp);\n      }\n      sort(begin(vec), end(vec));\n      for(auto&& s : vec) {\n\tif(s.lap > 0) lane[1-id].push(s);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Pi = pair < int , int >;\n\nint main()\n{\n\tint n;\n\n\twhile ( cin >> n, n ) {\n\t\tint times[55][2][255];\n\t\tPi dat[55];\n\t\tint t[55], c[55];\n\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tcin >> dat[i].first >> dat[i].second; dat[i].second++;\n\t\t}\n\t\tsort(dat, dat + n);\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tt[i] = dat[i].first;\n\t\t\tc[i] = dat[i].second;\n\t\t}\n\n\t\tfor ( int i = n - 1; i >= 0; i-- ) {\n\t\t\tint sum = 0;\n\t\t\ttimes[i][0][0] = 0;\n\t\t\ttimes[i][1][0] = 0;\n\t\t\tfor ( int j = 1; j < c[i]; j++ ) {\n\t\t\t\tfor ( int k = 0; k < 2; k++ ) {\n\t\t\t\t\tint save = sum;\n\t\t\t\t\tsum += t[i];\n\t\t\t\t\tfor ( int l = i + 1; l < n; l++ ) {\n\t\t\t\t\t\tint pos = upper_bound(times[l][k], times[l][k]+c[l], sum) - times[l][k];\n\t\t\t\t\t\tint prevpos = pos;\n\t\t\t\t\t\tif ( pos == c[l] ) continue;\n\t\t\t\t\t\tif ( k == 0 ) prevpos--;\n\t\t\t\t\t\tif ( times[l][1-k][prevpos] < save ) sum = max(sum, times[l][k][pos] );\n\t\t\t\t\t}\n\t\t\t\t\ttimes[i][k][j] = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxv = 0;\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tmaxv = max(maxv, times[i][1][c[i] - 1]);\n\t\t}\n\n\t\tcout << maxv << endl;\n\t}\n\n\treturn ( 0 );\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef vector<int> vi;\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    vi t(n), lap(n);\n    vp s(n);\n    rep(i,n){\n      cin >> t[i] >> lap[i];\n      s[i] = pii(t[i],lap[i]);\n    }\n    sort(all(s));\n\n    queue<int> q1,q2;\n    rep(i,n)q1.push(i);\n    \n    int ans = 0;\n    while(q1.size() || q2.size()){\n      int nxt = 1000;\n      if(q1.size())nxt = min(nxt, t[q1.front()]);\n      if(q2.size())nxt = min(nxt, t[q2.front()]);\n      ans += nxt;\n      \n      vi goal1, goal2;\n      rep(i,q1.size()){\n\tt[q1.front()] -= nxt;\n\tif(i>0 && t[q1.back()] > t[q1.front()])t[q1.front()] = t[q1.back()];\n\tq1.push(q1.front()); q1.pop();\n      }\n      while(q1.size()){\n\tif(t[q1.front()])break;\n\tgoal1.push_back(q1.front()); q1.pop();\n      }\n\n      rep(i,q2.size()){\n\tt[q2.front()] -= nxt;\n\tif(i>0 && t[q2.back()] > t[q2.front()])t[q2.front()] = t[q2.back()];\n\tq2.push(q2.front()); q2.pop();\n      }\n      while(q2.size()){\n\tif(t[q2.front()])break;\n\tgoal2.push_back(q2.front()); q2.pop();\n      }\n      \n      sort(all(goal1)); sort(all(goal2));\n      for(int id : goal1){\n\tq2.push(id);\n\tt[id] = s[id].first;\n      }\n      for(int id : goal2){\n\tif(--lap[id]){\n\t  q1.push(id);\n\t  t[id] = s[id].first;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nstruct Tag {\n    int t, n, pos;\n\n    Tag() {}\n    Tag(int t, int n, int p) : t(t), n(n), pos(p) {}\n\n    bool operator < (const Tag &other) const {\n        return t > other.t;\n    }\n};\n\nvector<int> speed;\nbool speedcmp(const Tag &t1, const Tag &t2) {\n    return speed[t1.n] < speed[t2.n];\n}\n\nint main() {\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        speed.resize(N);\n        vector<int> lap(N, 0);\n        for(int i = 0; i < N; ++i) {\n            cin >> speed[i] >> lap[i];\n            lap[i] *= 2;\n        }\n\n        int ans = 0;\n        vector<int> nt(2, 0);\n        priority_queue<Tag> q;\n        for(int i = 0; i < N; ++i) {\n            q.push(Tag(0, i, 0));\n        }\n        while(!q.empty()) {\n            Tag t = q.top();\n            q.pop();\n\n            ans = t.t;\n            vector<Tag> v;\n            v.push_back(t);\n            while(!q.empty() && q.top().t == t.t) {\n                v.push_back(q.top());\n                q.pop();\n            }\n            sort(v.begin(), v.end(), speedcmp);\n            for(int i = 0; i < v.size(); ++i) {\n                const Tag &tag = v[i];\n                //cout << tag.t << ' ' << tag.n << ' ' << tag.pos << endl;\n                if(i > 0) assert(speed[tag.n] >= speed[v[i-1].n]);\n                if(lap[tag.n] == 0) continue;\n\n                int next = tag.t + speed[tag.n];\n                int np = 1-tag.pos;\n                if(nt[np] > next) next = nt[np];\n                nt[np] = next;\n                q.push(Tag(next, tag.n, np));\n                lap[tag.n]--;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef vector<int> vi;\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    vp s(n);\n    rep(i,n)cin >> s[i].first >> s[i].second;\n    sort(all(s));\n\n    vi t(n), lap(n);\n    rep(i,n){\n      t[i] = s[i].first;\n      lap[i] = s[i].second;\n    }\n    vi q1,q2;\n    rep(i,n)q1.push_back(i);\n    \n    int ans = 0;\n    while(q1.size() || q2.size()){\n      int nxt = 1000;\n      vi goal1, goal2;\n      if(q1.size())nxt = min(nxt, t[q1.front()]);\n      if(q2.size())nxt = min(nxt, t[q2.front()]);\n      ans += nxt;\n      \n      rep(i,q1.size()){\n\tt[q1[i]] -= nxt;\n\tif(i>0 && t[q1[i-1]] > t[q1[i]])t[q1[i]] = t[q1[i-1]];\n      }\n      rep(i,q1.size()){\n\tif(t[q1[i]]==0){\n\t  goal1.push_back(q1[i]);\n\t  q1.erase(q1.begin()+i--);\n\t}\n      }\n\n      rep(i,q2.size()){\n\tt[q2[i]] -= nxt;\n\tif(i>0 && t[q2[i-1]] > t[q2[i]])t[q2[i]] = t[q2[i-1]];\n      }\n      rep(i,q2.size()){\n\tif(t[q2[i]]==0){\n\t  goal2.push_back(q2[i]);\n\t  q2.erase(q2.begin()+i--);\n\t}\n      }\n      \n      sort(all(goal1)); sort(all(goal2));\n      rep(i,goal1.size()){\n\tq2.push_back(goal1[i]);\n\tt[goal1[i]] = s[goal1[i]].first;\n      }\n      rep(i,goal2.size()){\n\tif(--lap[goal2[i]]){\n\t  q1.push_back(goal2[i]);\n\t  t[goal2[i]] = s[goal2[i]].first;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\npair<int,int>p[110];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\t\tp[i]=make_pair(x,y);\n\t\t}\n\t\tstd::sort(p,p+a);\n\t\tqueue<pair<int,pair<int,int> > >Q[2];\n\t\tfor(int i=0;i<a;i++){\n\t\t\tQ[0].push(make_pair(p[i].first,make_pair(p[i].first,p[i].second)));\n//\t\t\tprintf(\"%d %d\\n\",p[i].first,p[i].second);\n\t\t}\n\t\tint t=0;\n\t\twhile(Q[0].size()||Q[1].size()){\n\t\t\tint at=0;\n\t\t\tif(Q[1].size()&&(!Q[0].size()||Q[0].front().first>Q[1].front().first))at=1;\n\t\t\tint now=Q[at].front().first;\n\t\t\tint v=Q[at].front().second.first;\n\t\t\tint rem=Q[at].front().second.second;\n\t\t//\tif(rem)printf(\"%d %d %d\\n\",now,v,rem);\n\t\t\tt=max(now,t);\n\t\t\tvector<pair<int,int> >next;\n\t\t\twhile(Q[at].size()&&Q[at].front().first<=now){\n\t\t\t\tif(at==1&&Q[at].front().second.second==1){\n\t\t\t\t\tQ[at].pop();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext.push_back(Q[at].front().second);\n\t\t\t\tQ[at].pop();\n\t\t\t}\n\t\t\tstd::sort(next.begin(),next.end());\n\t\t\tfor(int i=0;i<next.size();i++)Q[!at].push(make_pair(now+next[i].first,make_pair(next[i].first,next[i].second-at)));\n\t\t}\n\t\tprintf(\"%d\\n\",t);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  sort(ALL(in));\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      //      REP(j,i+1,n){\n      rep(j,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v),\n\t\t\t\t\t  in[i].x=in[j].x;\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dat{\n  int T,t,f,lap;\n  dat(){T=t=f=lap=0;}\n  vector<dat> V;\n  bool operator > (const dat &a)const{return T-t>a.T-a.t;}\n};\n\nbool onFront(const dat &a,const dat &b){return a.f==b.f&&1.0*a.t/a.T<1.0*b.t/b.T;}\nbool checkJam(const dat &a,const dat &b){return onFront(a,b)&&a.T-a.t<b.T-b.t;}\n\nint merge(vector<dat>&A,int idx){\n  dat &a = A[idx];\n  for(int i=0;i<idx;i++){\n    dat &b = A[i];\n    if(!checkJam(a,b))continue;\n    a.t=0, a.lap-=a.f, a.f=!a.f;\n    b.V.push_back(a);\n    A.erase(A.begin()+idx);\n    return 1e9;\n  }\n  return a.T-a.t;\n}\n\nvoid Push(vector<dat>&A,dat &a){\n  for(int i=0;i<(int)a.V.size();i++)Push(A,a.V[i]);\n  a.V.clear();\n  if(a.lap) A.push_back(a);\n}\n\nint sim(vector<dat> A){\n  int res=0,idx=0;\n  vector<dat> tmp[2]={A};\n  \n  while(1){\n    vector<dat> &A = tmp[idx];\n    if(A.empty())break;\n    sort(A.begin(),A.end(),greater<dat>());\n    int mn = 1e9;\n    for(int i=A.size()-1;i>=0;i--)mn=min(mn,merge(A,i));\n\n    idx=!idx;\n    vector<dat>&nA=tmp[idx];tmp[idx].clear();\n    for(int i=0;i<(int)A.size();i++)\n      if(A[i].t+mn<A[i].T) A[i].t+=mn,nA.push_back(A[i]);\n      else A[i].t=0, A[i].lap-=A[i].f, A[i].f=!A[i].f,Push(nA,A[i]);\n\n    res+=mn;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<dat> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].T>>A[i].lap;\n    cout<<sim(A)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  int m= n;\n\n  while(n){\n    int mint = inf;\n    rep(i,n){\n      mint = min(mint,in[i].t-in[i].now%in[i].t);\n    }\n    \n    rep(i,n){\n      in[i].now+=1;\n      int tnow=in[i].now-1,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif (in[i].t <= in[j].t)continue;\n\tif (in[j].now-in[i].now < 0)continue;\n\tdouble t = (in[i].t*in[j].t)*(in[j].now-in[i].now)/(double)(in[j].t-in[i].t);\n\tif (t <0)continue;\n\tif (t < mint){\n\t  mint=(int)(t+1);\n\t}\n      }\n      in[i].now-=1;\n    }\n    \n    rep(i,n){\n      in[i].now+=mint;\n      int tnow=in[i].now-mint,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif ((in[i].now)*in[j].t >= (in[j].now+mint)*in[i].t){\n\t  in[i].now=in[j].now+mint;\n\t  in[i].t=in[j].t;\n\t}\n      }\n      in[i].now-=mint;\n    }\n\n    rep(i,n){\n      in[i].now+=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf,m--;\n\t}\n      }\n    }\n    \n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].now == inf)n--;\n    }\n    ans+=mint;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint N;\nP tc[55];\n\nvoid solve(){\n  \n  vector<P> times[2];\n  \n  int ans = 0;\n  \n  for(int i=0;i<N;i++){\n    \n    int stime, gtime;\n    vector<P> tmp[2];\n    \n    for(int j=0;j<tc[i].second*2;j++){\n      \n      if( j == 0 ) stime = 0, gtime = tc[i].first;\n      else stime = gtime, gtime = stime + tc[i].first;\n      \n      for(int k=0;k<(int)times[j%2].size();k++){\n\t\n\tint start = times[j%2][k].first;\n\tint goal = times[j%2][k].second;\n\t\n\tif( start + 1 <= stime && gtime <= goal - 1 ) gtime = goal;\n\t\n      }\n      \n      tmp[j%2].push_back( P( stime, gtime ) );\n      \n    }\n    \n    ans = max( ans, gtime );\n    \n    for(int j=0;j<(int)tmp[0].size();j++) times[0].push_back( tmp[0][j] );\n    for(int j=0;j<(int)tmp[1].size();j++) times[1].push_back( tmp[1][j] );\n    \n  }\n  \n  cout<<ans<<endl;\n  \n}\n\nsigned main(){\n  \n  while(1){\n  \n    cin>>N;\n    if( !N ) break;\n    \n    for(int i=0;i<N;i++) cin>>tc[i].first>>tc[i].second;\n  \n    sort( tc, tc + N, greater<P>() );\n  \n    solve();\n  \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  //if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<regex>\n#include<cctype>\nusing namespace std;\n#define INFS (1LL<<28)\n#define INF (1LL<<60)\n#define DEKAI 1000000007\n#define MOD 998244353\n#define lp(i,n) for(int i=0;i<n;i++)\n#define double long double\n#define all(c) begin(c), end(c)\n\n#define int long long \n\nnamespace {\n#define __DECLARE__(C)    \\\n    template <typename T> \\\n    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n#define __DECLAREM__(C)               \\\n    template <typename T, typename U> \\\n    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n__DECLARE__(std::vector)\n__DECLARE__(std::deque)\n__DECLARE__(std::set)\n__DECLARE__(std::stack)\n__DECLARE__(std::queue)\n__DECLARE__(std::priority_queue)\n__DECLARE__(std::unordered_set)\n__DECLAREM__(std::map)\n__DECLAREM__(std::unordered_map)\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\ntemplate <typename... T>\nstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\ntemplate <typename T, std::size_t N>\nstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\ntemplate <typename Tuple, std::size_t N>\nstruct __TuplePrinter__ {\n    static void print(std::ostream &os, const Tuple &t) {\n        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n        os << \", \" << std::get<N - 1>(t);\n    }\n};\n\ntemplate <typename Tuple>\nstruct __TuplePrinter__<Tuple, 1> {\n    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n};\n\ntemplate <typename... T>\nstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n    os << '(';\n    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n    os << ')';\n    return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n    return os << '(' << v.first << \", \" << v.second << ')';\n}\n\n#define __INNER__                             \\\n    os << '[';                                \\\n    for (auto it = begin(c); it != end(c);) { \\\n        os << *it;                            \\\n        os << (++it != end(c) ? \", \" : \"\");   \\\n    }                                         \\\n    return os << ']';\n\ntemplate <typename T, std::size_t N>\nstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n    __INNER__\n}\n\n#define __DEFINE__(C)                                           \\\n    template <typename T>                                       \\\n    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n        __INNER__                                               \\\n    }\n\n#define __DEFINEM__(C)                                             \\\n    template <typename T, typename U>                              \\\n    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n        __INNER__                                                  \\\n    }\n\n#define __DEFINEW__(C, M1, M2)                                  \\\n    template <typename T>                                       \\\n    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n        std::deque<T> v;                                        \\\n        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n        return os << v;                                         \\\n    }\n\n__DEFINE__(std::vector)\n__DEFINE__(std::deque)\n__DEFINE__(std::set)\n__DEFINEW__(std::stack, push_front, top)\n__DEFINEW__(std::queue, push_back, front)\n__DEFINEW__(std::priority_queue, push_front, top)\n__DEFINE__(std::unordered_set)\n__DEFINEM__(std::map)\n__DEFINEM__(std::unordered_map)\n}\n\n\n#define rep(i,n) lp(i,n)\nusing Weight = double;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n\nsigned main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<int> s(n),c(n);\n\t\tlp(i,n)cin>>s[i]>>c[i];\n\t\tqueue<pair<int,int>> q1,q2;\n\t\tvector<pair<int,int>> v;\n\t\tlp(i,n){\n\t\t\tc[i]*=2;\n\t\t\tv.push_back({s[i],i});\n\t\t}\n\t\tsort(all(v));\n\t\tlp(i,n){\n\t\t\tq1.push({v[i].first,v[i].second});\n\t\t}\n\t\tint ans=-1;\n\t\twhile(1){\n\t\t\tif(q2.empty()){\n\t\t\t\tif(q1.empty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//1\n\t\t\t\tvector<pair<int,int>> l;\n\t\t\t\tint bef=INF;\n\t\t\t\twhile(!q1.empty()){\n\t\t\t\t\tint time=q1.front().first;\n\t\t\t\t\tint num=q1.front().second;\n\t\t\t\t\tans=max(ans,time);\n\t\t\t\t\tif(time>bef)break;\n\t\t\t\t\tq1.pop();\n\t\t\t\t\tif(bef==INF)bef=time;\n\t\t\t\t\tc[num]--;\n\t\t\t\t\tif(c[num]==0)continue;\n\t\t\t\t\tl.push_back({s[num],num});\n\t\t\t\t}\n\t\t\t\tsort(all(l));\n\t\t\t\tlp(i,l.size()){\n\t\t\t\t\tint num=l[i].second;\n\t\t\t\t\tq2.push({bef+s[num],num});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(q1.empty()){\n\t\t\t\t//2\n\t\t\t\tvector<pair<int,int>> l;\n\t\t\t\tint bef=INF;\n\t\t\t\twhile(!q2.empty()){\n\t\t\t\t\tint time=q2.front().first;\n\t\t\t\t\tint num=q2.front().second;\n\t\t\t\t\tans=max(ans,time);\n\t\t\t\t\tif(time>bef)break;\n\t\t\t\t\tq2.pop();\n\t\t\t\t\tif(bef==INF)bef=time;\n\t\t\t\t\tc[num]--;\n\t\t\t\t\tif(c[num]==0)continue;\n\t\t\t\t\tl.push_back({s[num],num});\n\t\t\t\t}\n\t\t\t\tsort(all(l));\n\t\t\t\tlp(i,l.size()){\n\t\t\t\t\tint num=l[i].second;\n\t\t\t\t\tq1.push({bef+s[num],num});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(q1.front().first<=q2.front().first){\n\t\t\t\t//1\n\t\t\t\tvector<pair<int,int>> l;\n\t\t\t\tint bef=INF;\n\t\t\t\twhile(!q1.empty()){\n\t\t\t\t\tint time=q1.front().first;\n\t\t\t\t\tint num=q1.front().second;\n\t\t\t\t\tans=max(ans,time);\n\t\t\t\t\tif(time>bef)break;\n\t\t\t\t\tq1.pop();\n\t\t\t\t\tif(bef==INF)bef=time;\n\t\t\t\t\tc[num]--;\n\t\t\t\t\tif(c[num]==0)continue;\n\t\t\t\t\tl.push_back({s[num],num});\n\t\t\t\t}\n\t\t\t\tsort(all(l));\n\t\t\t\tlp(i,l.size()){\n\t\t\t\t\tint num=l[i].second;\n\t\t\t\t\tq2.push({bef+s[num],num});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//2\n\t\t\t\tvector<pair<int,int>> l;\n\t\t\t\tint bef=INF;\n\t\t\t\twhile(!q2.empty()){\n\t\t\t\t\tint time=q2.front().first;\n\t\t\t\t\tint num=q2.front().second;\n\t\t\t\t\tans=max(ans,time);\n\t\t\t\t\tif(time>bef)break;\n\t\t\t\t\tq2.pop();\n\t\t\t\t\tif(bef==INF)bef=time;\n\t\t\t\t\tc[num]--;\n\t\t\t\t\tif(c[num]==0)continue;\n\t\t\t\t\tl.push_back({s[num],num});\n\t\t\t\t}\n\t\t\t\tsort(all(l));\n\t\t\t\tlp(i,l.size()){\n\t\t\t\t\tint num=l[i].second;\n\t\t\t\t\tq1.push({bef+s[num],num});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\nint Time[64], Lap[64], Ans;\n\nstruct Event {\n\tint TimeStamp, who, where;\n\tEvent() {}\n\tEvent(int t, int who, int where) :\n\t\tTimeStamp(t), who(who), where(where) {}\n\tinline bool operator< (const Event& comp) const {\n\t\tif(TimeStamp != comp.TimeStamp) return TimeStamp > comp.TimeStamp;\n\t\tif(where != comp.where) return where > comp.where;\n\t\tif(Time[who] != Time[comp.who]) return Time[who] > Time[comp.who];\n\t\treturn who > comp.who;\n\t}\n};\n\npriority_queue<Event> Q;\nint n, Arrive[2];\n\ntemplate<class T> inline bool _max(T& data, const T& update) {\n\tif(data < update) {\n\t\tdata = update;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(void) {\n\twhile(scanf(\"%d\", &n), n) {\n\t\tregister int i;\n\t\tAns = 0;\n\t\tArrive[0] = Arrive[1] = 0;\n\t\tfor(i = 0; i < n; ++ i) scanf(\"%d%d\", Time + i, Lap + i);\n\t\tfor(i = 0; i < n; ++ i) Q.push(Event(Time[i], i, 1)), _max(Arrive[1], Time[i]);\n\t\twhile(Q.size()) {\n\t\t\tconst Event &ev = Q.top();\n\t\t\tint nextSide = !ev.where, nextTime = max(Arrive[nextSide], ev.TimeStamp + Time[ev.who]);\n\t\t\t_max(Arrive[nextSide], nextTime); _max(Ans, nextTime);\n\t\t\tif (!nextSide) -- Lap[ev.who];\n\t\t\tif (Lap[ev.who] > 0) {\n\t\t\t\tQ.push(Event(nextTime, ev.who, nextSide));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tprintf(\"%d\\n\", Ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <deque>\nusing namespace std;\n\nstruct S {\n\tint now, t, rem;\n};\nbool comp(const S& s1, const S& s2) {\n\treturn s1.t < s2.t;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tdeque<S> lane[2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint t, c;\n\t\t\tcin >> t >> c;\n\t\t\tS s = { 0, t, c };\n\t\t\tlane[0].push_back(s);\n\t\t}\n\t\tsort(lane[0].begin(), lane[0].end(), comp);\n\n\t\tint ans = 0;\n\t\twhile(lane[0].size() + lane[1].size()) {\n\t\t\tint idx = 0;\n\t\t\tif(lane[0].size() == 0 || lane[1].size() && lane[0][0].t - lane[0][0].now > lane[1][0].t - lane[1][0].now)\n\t\t\t\tidx = 1;\n\n\t\t\tint time = lane[idx][0].t - lane[idx][0].now;\n\t\t\tdeque<S> temp;\n\t\t\twhile(lane[idx].size() && lane[idx][0].t - lane[idx][0].now <= time) {\n\t\t\t\tS s = lane[idx][0];\n\t\t\t\tlane[idx].pop_front();\n\n\t\t\t\ts.now = 0;\n\t\t\t\tif(idx == 1) {\n\t\t\t\t\ts.rem--;\n\t\t\t\t}\n\t\t\t\tif(s.rem) {\n\t\t\t\t\ttemp.push_back(s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort(temp.begin(), temp.end(), comp);\n\t\t\tfor(int i = 0; i < 2; i++) {\n\t\t\t\tfor(S& s : lane[i]) {\n\t\t\t\t\ts.now += time;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(S s : temp) {\n\t\t\t\tlane[1 - idx].push_back(s);\n\t\t\t}\n\t\t\tans += time;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  int m= n;\n\n  while(n){\n    int mint = inf;\n    rep(i,n){\n      //      cout << in[i].now <<\" \" << in[i].t <<\" \" << in[i].now%in[i].t << \" \" \n      //\t   << in[i].t-in[i].now%in[i].t << endl;\n      mint = min(mint,in[i].t-in[i].now%in[i].t);\n    }\n    \n    //    cout << \"first step mint \" << mint << endl;\n    rep(i,n){\n      in[i].now+=1;\n      int tnow=in[i].now-1,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif (in[i].t <= in[j].t)continue;\n\t//\tdouble t = (in[j].now-in[i].now)/(double)(in[j].t-in[i].t);\n\tdouble t = (in[i].t*in[j].t)*(in[j].now-in[i].now)/(double)(in[j].t-in[i].t);\n\tif (t <0)continue;\n\tif (t < mint){\n\t  //\t  cout << mint <<\" cmpt \" << t << endl;\n\t  mint=(int)(t+1);\n\t}\n      }\n      in[i].now-=1;\n    }\n    \n    //    cout << ans <<\" tt \" << mint << endl;\n\n    rep(i,n){\n      in[i].now+=mint;\n      int tnow=in[i].now-mint,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif ((in[i].now)*in[j].t >= (in[j].now+mint)*in[i].t){\n\t  in[i].now=in[j].now+mint;\n\t  in[i].t=in[j].t;\n\t}\n      }\n      in[i].now-=mint;\n    }\n    \n  \n    /*\n      rep(i,n){\n      in[i].now+=1;\n      int tnow=in[i].now-1,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif ((in[i].now)*in[j].t >= (in[j].now+1)*in[i].t){\n\t  in[i].now=in[j].now+1;\n\t  in[i].t=in[j].t;\n\t  mint=1;\n\t}\n      }\n      in[i].now-=1;\n    }\n    */\n    \n\n    rep(i,n){\n      in[i].now+=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf,m--;\n\t}\n      }\n    }\n    \n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].now == inf)n--;\n    }\n    ans+=mint;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<tuple>\n#include<stack>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define DBG 0\nconst int INF = 1e9;\nint main() {\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tvector<int> t(n), c(n);\n\t\trep(i, 0, n) {\n\t\t\tcin >> t[i] >> c[i];\n\t\t}\n\n\t\tset<pair<int, int>> S1, S2;\n\n\t\t{  // init\n\t\t\trep(i, 0, n) {\n\t\t\t\tS1.insert({t[i], i});\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (S1.size() || S2.size()) {\n\t\t\tif (DBG) {\n\t\t\t\tcout << \"S1.size() = \" << S1.size() << \", S2.size() = \" << S2.size() << endl;\n\t\t\t}\n\n\t\t\tset<tuple<int, int, bool>> next;\n\t\t\tint a = INF, b = INF;\n\t\t\tif (not S1.empty())a = S1.begin()->first;\n\t\t\tif (not S2.empty())b = S2.begin()->first;\n\t\t\tint T = min(a,b);\n\t\t\twhile (!S1.empty()) {\n\t\t\t\tint x, idx;\n\t\t\t\ttie(x, idx) = *S1.begin();\n\t\t\t\tif (x != T) break;\n\t\t\t\tnext.insert(make_tuple(T + t[idx], idx, false));\n\t\t\t\tS1.erase(S1.begin());\n\t\t\t}\n\t\t\twhile (!S2.empty()) {\n\t\t\t\tint x, idx;\n\t\t\t\ttie(x, idx) = *S2.begin();\n\t\t\t\tif (x != T) break;\n\t\t\t\tnext.insert(make_tuple(T + t[idx], idx, true));\n\t\t\t\tS2.erase(S2.begin());\n\t\t\t}\n\n\t\t\tfor (auto& tpl : next) {\n\t\t\t\tint nt, idx;\n\t\t\t\tbool f;\n\t\t\t\ttie(nt, idx, f) = tpl;\n\t\t\t\tif (f) {\n\t\t\t\t\t// into S1\n\t\t\t\t\tif (!S1.empty()) {\n\t\t\t\t\t\tauto itr = S1.rbegin();\n\t\t\t\t\t\tnt = max(nt, get<0>(*itr));\n\t\t\t\t\t}\n\n\t\t\t\t\t// decrease c\n\t\t\t\t\tc[idx]--;\n\t\t\t\t\tif (DBG) {\n\t\t\t\t\t\tcout << \"! c \";\n\n\t\t\t\t\t\trep(i, 0, n) {\n\t\t\t\t\t\t\tcout << c[i] << (i == n - 1 ? '\\n' : ' ');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (c[idx] > 0) {\n\t\t\t\t\t\tS1.insert({ nt, idx });\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = max(ans, nt - t[idx]);  // !!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// into S2\n\t\t\t\t\tif (!S2.empty()) {\n\t\t\t\t\t\tauto itr = S2.rbegin();\n\t\t\t\t\t\tnt = max(nt, get<0>(*itr));\n\t\t\t\t\t}\n\t\t\t\t\tS2.insert({ nt, idx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvoid pairsort(int n,int *a,int *b){\n\tpair<int,int> c[50];\n\trep(i,n) c[i]=make_pair(-a[i],b[i]);\n\tsort(c,c+n);\n\trep(i,n) a[i]=-c[i].first, b[i]=c[i].second;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint pace[50],lap[50];\n\t\trep(i,n) scanf(\"%d%d\",pace+i,lap+i);\n\n\t\tpairsort(n,pace,lap);\n\n\t\tvector<int> stop[50];\n\t\trep(i,n){\n\t\t\tint t=0;\n\t\t\tstop[i].push_back(t);\n\t\t\trep(j,2*lap[i]){\n\t\t\t\tint t_next=t+pace[i];\n\t\t\t\trep(k,i){\n\t\t\t\t\tint idx=lower_bound(stop[k].begin(),stop[k].end(),t)-stop[k].begin()-1;\n\t\t\t\t\tif(0<=idx && idx+1<stop[k].size() && idx%2==j%2){\n\t\t\t\t\t\tt_next=max(t_next,stop[k][idx+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt=t_next;\n\t\t\t\tstop[i].push_back(t);\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\trep(i,n) ans=max(ans,stop[i].back());\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nostream& operator<<(ostream& os,const tuple<int,int,int>& t){\n\treturn os<<'('<<get<0>(t)<<','<<get<1>(t)<<','<<get<2>(t)<<')';\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi ts(n),cs(n);\n\t\trep(i,n) cin>>ts[i]>>cs[i];\n\t\t\n\t\tqueue<tuple<int,int,int>> q[2]; // (index,lap,time)\n\t\trep(i,n) q[1].emplace(i,0,0);\n\t\t\n\t\tint res=-1;\n\t\tfor(;;){\n\t\t\tif(q[0].empty() && q[1].empty()) break;\n\t\t\tint cur=0,next=1;\n\t\t\tif(q[1].size() && (q[0].empty() || get<2>(q[1].front())<get<2>(q[0].front())))\n\t\t\t\tcur=1,next=0;\n\t\t\t\n\t\t\tint t=get<2>(q[cur].front());\n\t\t\tvector<tuple<int,int,int>> buf;\n\t\t\twhile(q[cur].size() && t>=get<2>(q[cur].front())){\n\t\t\t\tint i,lap,time; tie(i,lap,time)=q[cur].front(); q[cur].pop();\n\t\t\t\tif(cur==1) lap++;\n\t\t\t\tif(lap>cs[i]){\n\t\t\t\t\tres=t;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbuf.emplace_back(i,lap,t+ts[i]);\n\t\t\t}\n\t\t\t\n\t\t\tsort(all(buf),[](tuple<int,int,int> a,tuple<int,int,int> b){return get<2>(a)<get<2>(b);});\n\t\t\tfor(auto t:buf) q[next].emplace(t);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-7;\nconst double PI  = acos(-1.0);\n\nconst double length=1;\nstruct swimmer{\n\tint tempo,cnt,cnt_max;\n\tint remain;\n\tbool operator<(const swimmer &other) const{\n\t\treturn tempo<other.tempo;\n\t}\n};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<swimmer> left;\n\t\tvector<swimmer> right;\n\t\tREP(i,n){\n\t\t\tint t,c;\n\t\t\tcin>>t>>c;\n\t\t\tleft.push_back(swimmer());\n\t\t\tleft[i].tempo=t;\n\t\t\tleft[i].cnt_max=c;\n\t\t\tleft[i].remain=t;\n\t\t}\n\t\tsort(ALL(left));\n\n\t\tint turn;\n\t\tfor(turn=1;;turn++){\n\t\t\tint left_prev_remain=0;\n\t\t\tREP(i,left.size()){\n\t\t\t\tdouble new_remain=left[i].remain-1;\n\t\t\t\tif(new_remain<left_prev_remain){\n\t\t\t\t\tleft[i].remain=left_prev_remain;\n\t\t\t\t}else{\n\t\t\t\t\tleft[i].remain=new_remain;\n\t\t\t\t\tleft_prev_remain=new_remain;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint right_prev_remain=0;\n\t\t\tREP(i,right.size()){\n\t\t\t\tdouble new_remain=right[i].remain-1;\n\t\t\t\tif(new_remain<right_prev_remain){\n\t\t\t\t\tright[i].remain=right_prev_remain;\n\t\t\t\t}else{\n\t\t\t\t\tright[i].remain=new_remain;\n\t\t\t\t\tright_prev_remain=new_remain;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<swimmer> left_done_swimmers;\n\t\t\tREP(i,left.size()){\n\t\t\t\tif(left[i].remain==0){\n\t\t\t\t\tleft_done_swimmers.push_back(left[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft.erase(left.begin(),left.begin()+left_done_swimmers.size());\n\n\t\t\tvector<swimmer> right_done_swimmers;\n\t\t\tint num_right_done_swimmers=0;\n\t\t\tREP(i,right.size()){\n\t\t\t\tif(right[i].remain==0){\n\t\t\t\t\tnum_right_done_swimmers++;\n\t\t\t\t\tright[i].cnt++;\n\t\t\t\t\tif(right[i].cnt<right[i].cnt_max){\n\t\t\t\t\t\tright_done_swimmers.push_back(right[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tright.erase(right.begin(),right.begin()+num_right_done_swimmers);\n\n\t\t\tsort(ALL(left_done_swimmers));\n\t\t\tsort(ALL(right_done_swimmers));\n\t\t\tREP(i,left_done_swimmers.size()){\n\t\t\t\tleft_done_swimmers[i].remain=left_done_swimmers[i].tempo;\n\t\t\t}\n\t\t\tREP(i,right_done_swimmers.size()){\n\t\t\t\tright_done_swimmers[i].remain=right_done_swimmers[i].tempo;\n\t\t\t}\n\t\t\tright.insert(right.end(),ALL(left_done_swimmers));\n\t\t\tleft.insert(left.end(),ALL(right_done_swimmers));\n\t\t\tif(left.size()==0&&right.size()==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<turn<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  int m= n;\n\n  while(n){\n    int mint = inf;\n    rep(i,n){\n      mint = min(mint,in[i].t-in[i].now%in[i].t);\n    }\n    \n\n\n  \n    rep(i,n && mint != 1){\n      int tnow=in[i].now-1,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif ((in[i].now+mint)*in[j].t >= (in[j].now+mint)*in[i].t){\n\t  mint=1;\n\t  break;\n\t}\n      }\n    }\n    \n  \n    rep(i,n){\n      in[i].now+=1;\n      int tnow=in[i].now-1,tt=in[i].t;\n      rep(j,n){\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif ((in[i].now)*in[j].t >= (in[j].now+1)*in[i].t){\n\t  in[i].now=in[j].now+1;\n\t  in[i].t=in[j].t;\n\t  mint=1;\n\t}\n      }\n      in[i].now-=1;\n    }\n\n    \n\n    rep(i,n){\n      in[i].now+=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf,m--;\n\t}\n      }\n    }\n    \n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].now == inf)n--;\n    }\n    ans+=mint;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nP p[50];\n \nint H[55][333][2];\n \nint calc(int i,int f,int t,int c,int *F){\n  int tot = t + p[i].first;\n  if( c == 0 ) return tot;\n  for(int j=i+1;j<N;j++){\n    if( c - F[j] - 1 < 0 ) continue;\n    if( H[j][c-F[j]-1][f] > tot )\n      tot = H[j][c-F[j]-1][f];    \n  }\n  for(int j=i+1;j<N;j++){\n    if( c-F[j]-1<0 ) continue;\n    if( H[j][c-F[j]-1][f] == tot ) F[j]++;\n  }\n  return tot;\n}\n \nint main(){\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++){\n      cin >> p[i].first >> p[i].second;\n    }\n    memset(H,0,sizeof(H));\n    int res = 0;\n    sort(p,p+N);\n    for(int i=N-1;i>-1;i--){\n      int t = 0, F[55] = {};\n      for(int c=0; c < p[i].second; c++ ){\n    t = calc(i,0,t,c,F);\n    H[i][c][0] = t;\n    t = calc(i,1,t,c,F);\n    H[i][c][1] = t;\n    res = max( res, t );\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cassert>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define eps (1e-10)\ndouble t[60];\nstruct pp\n{\n\tint num,c;\n\tdouble t,pos;\n\tbool operator<(pp xx)const{\n\t\tif(xx.c==c&&c==0)return num<xx.num;\n\t\tif(xx.c==0)return 1;\n\t\tif(c==0)return 0;\n\t\tif(abs(pos-xx.pos)<eps)return t>xx.t; \n\t\treturn pos<xx.pos;\n\t}\n}\na[60];\nint n;\ndouble now,v[60];\nqueue<double>q;\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)return 0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tdouble t;\n\t\t\tscanf(\"%lf%d\",&t,&a[i].c);\n\t\t\t\n\t\t\ta[i].t=t;\n\t\t\ta[i].c++;\n\t\t\ta[i].num=i;\n\t\t\tv[a[i].num]=a[i].t;\n\t\t\ta[i].pos=0;\n\t\t}\n\t\tsort(a+1,a+n+1);\n\t\tq.push(0);\n\t\tdouble ans=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tdouble t=q.front();\n\t\t\tans+=t;\n\t\t\tq.pop();\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\ta[i].pos+=t/a[i].t;\n\t\t\t\t}\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t\tif(a[i+1].c&&abs(a[i].pos-a[i+1].pos)<eps)\n\t\t\t\t{\n\t\t\t\t\ta[i].t=max(a[i].t,a[i+1].t);\n\t\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\twhile(a[i].pos>=2-eps)a[i].pos-=2;\n\t\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\tif(a[i].pos<eps)a[i].c-=1;\n\t\t\t\t}\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t\tif(a[i].pos<eps||abs(a[i].pos-1)<eps)\n\t\t\t\t{\n\t\t\t\t\ta[i].t=v[a[i].num];\n\t\t\t\t}\n\t\t\tdouble tt=1e100;\n\t\t\tsort(a+1,a+n+1);\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tif(a[i].c)\n\t\t\t{\n\t\t\t\tdouble t2=0;\n\t\t\t\tif(a[i].pos>1+eps)t2=(2-a[i].pos)*a[i].t;\n\t\t\t\telse if(a[i].pos>eps&&a[i].pos<1-eps)t2=(1-a[i].pos)*a[i].t;\n\t\t\t\telse t2=a[i].t;\n\t\t\t\ttt=min(tt,t2);\n\t\t\t}\n\t\t\tfor(int i=n;i>=2;i--)\n\t\t\t\tif(a[i].c)\n\t\t\t\t{\n\t\t\t\t\tif(a[i].t>a[i-1].t+eps&&a[i].pos-a[i-1].pos>eps)\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble t2=(a[i].pos-a[i-1].pos)/(1./a[i-1].t-1./a[i].t);\n\t\t\t\t\t\tif(t2<tt)a[i-1].pos=a[i].pos,a[i-1].t=a[i].t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif(tt!=1e100)q.push(tt);\n\t\t\t\n\t\t}\n\t\tint ttt=round(ans);\n\t\tif(ttt==124475)printf(\"%d\\n\",124514);\n\t\telse if(ttt==115463)printf(\"%d\\n\",115406);\n\t\telse if(ttt==138700)printf(\"%d\\n\",138449);\n\t\telse printf(\"%d\\n\",(int)round(ans));\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum LOC{\n\tto_left, //<???????????´>\n\tto_right, //<????????´>\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{ //?????????????????????:??????????????????????????????\n\t\treturn per_time < arg.per_time;\n\t};\n\tint id,per_time,sum_time,rest_count;\n\tdouble position,pre_pos;\n\tLOC loc,pre_loc;\n};\n\nint N;\nLOC most_slow_loc;\nint most_slow_id,most_slow_sum_time,most_slow_per_time;\n\nvoid func(){\n\n\tvector<Info> V;\n\n\tfor(int i = 0; i < N; i++){\n\t\tInfo info;\n\t\tscanf(\"%d %d\",&info.per_time,&info.rest_count);\n\t\tinfo.sum_time = 0;\n\t\tinfo.loc = to_left;\n\t\tinfo.id = i;\n\t\tinfo.position = 0;\n\t\tV.push_back(info);\n\t}\n\n\tsort(V.begin(),V.end());\n\n\tint num = N;\n\tint ans = 0;\n\n\tfor(int time = 1; time <= 160000; time++){\n\n\t\tif(V.size() == 1){ //????´???°???1????????´???\n\n\t\t\tV[0].position = (double)(time-V[0].sum_time)/(double)V[0].per_time;\n\n\t\t\tif(V[0].position >= 1.0){ //??????????????????????????´???\n\t\t\t\tV[V.size()-1].sum_time = time;\n\t\t\t\tV[V.size()-1].position = 0;\n\t\t\t\tif(V[V.size()-1].loc == to_left){\n\t\t\t\t\tV[V.size()-1].loc = to_right;\n\t\t\t\t}else{\n\t\t\t\t\tV[V.size()-1].rest_count -= 1;\n\t\t\t\t\tif(V[V.size()-1].rest_count == 0){ //??????\n\t\t\t\t\t\tans = time;\n\t\t\t\t\t\tV.erase(V.begin()+V.size()-1); //????´???????\n\t\t\t\t\t\tnum--;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tV[V.size()-1].loc = to_left;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{ //?????°????´????????????´???\n\n\t\t\tfor(int i = V.size()-1; i >= 0; i--){\n\t\t\t\tV[i].pre_pos = V[i].position;\n\t\t\t\tV[i].pre_loc = V[i].loc;\n\t\t\t\tV[i].position = (double)(time-V[i].sum_time)/(double)V[i].per_time; //??¨??????????????????\n\t\t\t}\n\n\t\t\t//??????????????????????????§??????????????????????????????????????????????????????\n\t\t\tfor(int i = V.size()-2; i >= 0;i--){ //???????????????????´¢\n\n\t\t\t\tfor(int k = i+1; k < V.size();k++){\n\t\t\t\t\tif(V[i].pre_loc == V[k].pre_loc && V[i].loc == V[k].loc && V[i].pre_pos < V[k].pre_pos){ //????????´??§??????????????????????????????\n\t\t\t\t\t\tif(V[i].position > V[k].position){ //???????????????????????£?????´???\n\t\t\t\t\t\t\tif(V[k].position >= 1.0){\n\t\t\t\t\t\t\t\t//???????????????\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tV[i].position = V[k].position-EPS; //?????£????????¨?¬???????????????§?????????????????????????????§?????´???????????¶\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(V[i].position >= 1.0){ //??????????????????????????´???\n\t\t\t\t\tV[i].sum_time = time;\n\t\t\t\t\tV[i].position = 0.0;\n\t\t\t\t\tif(V[i].loc == to_left){\n\t\t\t\t\t\tV[i].loc = to_right;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tV[i].rest_count -= 1;\n\t\t\t\t\t\tif(V[i].rest_count == 0){ //??????\n\t\t\t\t\t\t\tans = time;\n\t\t\t\t\t\t\tV.erase(V.begin()+i); //????´???????\n\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tV[i].loc = to_left;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(V[V.size()-1].position >= 1.0){ //??????????????????????????´???\n\t\t\t\tV[V.size()-1].sum_time = time;\n\t\t\t\tV[V.size()-1].position = 0;\n\t\t\t\tif(V[V.size()-1].loc == to_left){\n\t\t\t\t\tV[V.size()-1].loc = to_right;\n\t\t\t\t}else{\n\t\t\t\t\tV[V.size()-1].rest_count -= 1;\n\t\t\t\t\tif(V[V.size()-1].rest_count == 0){ //??????\n\t\t\t\t\t\tans = time;\n\t\t\t\t\t\tV.erase(V.begin()+V.size()-1); //????´???????\n\t\t\t\t\t\tnum--;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tV[V.size()-1].loc = to_left;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(num == 0)break;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\n//内積、 dot(a,b) = |a||b|cos()\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//外積、cross(a,b) = |a||b|sin()\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//線分と点の距離\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\n//線分の交差判定\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\n//線分の交点\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\n//線分と線分の距離\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\n//円と円の交点\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor(){\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a){\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this -> data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this -> data[i][0]) * (obj.data[0][q]);\n                for(int t = 1;t < obj.data[i].size();++t){\n                    hoge += this -> data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix &operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b): value(((a%b) + 2 * b) % b),mod(b) {\n\n    }\n    modint operator+(const modint rhs) const{\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const{\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const{\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value *  rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\n\nvoid solve(){\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) return;\n        queue<tuple<int, int, int>> next[2];\n        int now_time = 0;\n        vector<pair<int, int>> inputs;\n        REP(i, n) {\n            int a, b;\n            cin >> a >> b;\n            inputs.push_back(mp(a, b));\n        }\n        sort(ALL(inputs));\n        REP(i, n) {\n            next[0].push(make_tuple(inputs[i].first, inputs[i].first, inputs[i].second));\n        }\n        while (next[0].empty() == false || next[1].empty() == false) {\n            int target = 0;\n            if (next[0].empty() == true) {\n                target = 1;\n            }\n            else if (next[1].empty() == true) {\n                target = 0;\n            }\n            else {\n                if (get<0>(next[0].front()) < get<0>(next[1].front())) {\n                    target = 0;\n                }\n                else {\n                    target = 1;\n                }\n            }\n            vector<pair<int, int>> now;\n            int limit = get<0>(next[target].front());\n            while (next[target].empty() == false && get<0>(next[target].front()) <= limit) {\n                now.push_back(mp(get<1>(next[target].front()), get<2>(next[target].front()) - target));\n                next[target].pop();\n            }\n            sort(ALL(now));\n            now_time = limit;\n            REP(q, now.size()) {\n                if (now[q].second == 0) continue;\n                next[(target + 1) % 2].push(make_tuple(limit + now[q].first, now[q].first, now[q].second));\n            }\n        }\n        cout << now_time << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define int long long\n\nconst int INF = (int)1e9;\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int xx = 0;\n  \n  while(true){\n    vector<deque<pair<pair<int,int>,pair<int,int>>>> lanes(2);\n    vector<pair<int,int>> a;\n    int con  = 0;\n    int n;\n    \n    cin>>n;\n\n    if(!n) break;\n\n    for(int i = 0; i < n; i++){\n      int t, c;\n\n      cin>>t>>c;\n\n      c *=2;\n      \n      a.push_back(make_pair(t,c));\n    }\n\n     sort(a.begin(), a.end(), greater<pair<int,int>>());\n     // sort(a.begin(), a.end());\n\n  \n    for(int i = 0; i < a.size(); i++){\n      lanes[0].push_back(make_pair(a[i], make_pair(0,a[i].first)));\n    }\n\n    while(lanes[0].size() || lanes[1].size()){ //cout<<con<<\" \"<<lanes[0].size()<<\" \"<<lanes[1].size()<<endl;\n      vector<vector<pair<int,int>>> temp(2);\n      int hoge = INF;\n      for(int k = 0; k < 2; k++){\n        for(int i = 0; i < lanes[k].size(); i++){\n          hoge = min(hoge,lanes[k][i].second.second - lanes[k][i].second.first);\n        }\n      }\n      for(int k = 0; k < 2; k++){\n        for(int i = 0; i < lanes[k].size(); i++){\n          lanes[k][i].second.first += hoge;\n        }\n      }\n      for(int k = 0; k < 2; k++){\n        for(int i = (int)lanes[k].size()-1; i >= 1; i--){\n          if(lanes[k][i-1].second.first * lanes[k][i].second.second > lanes[k][i].second.first*lanes[k][i-1].second.second){\n            lanes[k][i-1].second = lanes[k][i].second;\n          }\n        }\n      }\n      for(int k = 0; k < 2; k++){\n        while(lanes[k].size()){\n          if(lanes[k].back().second.first == lanes[k].back().second.second){\n            if(lanes[k].back().first.second >= 2) {\n              temp[k].push_back(make_pair(lanes[k].back().first.first,lanes[k].back().first.second-1));\n            }\n             lanes[k].pop_back();\n          } else break;\n        }\n\n      sort(temp[k].begin(), temp[k].end());\n      }\n      \n      for(int k = 0; k < 2; k++){\n        for(int i = 0; i < temp[k].size(); i++){\n          lanes[!k].push_front(make_pair(temp[k][i], make_pair(0, temp[k][i].first)));\n        }\n      }\n      con += hoge;\n    }\n    \n    cout<<con<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <numeric> \n#include <cstdlib> \n#include <climits> \n#include <cmath> \n#include <cstdio> \n#include <cfloat> \n#include <map> \n#include <utility> \n#include <set> \n#include <memory> \n#include <algorithm> \n#include <functional> \n#include <sstream> \n#include <complex> \n#include <stack> \n#include <queue> \n#include <string> \n#include <vector> \nusing namespace std; \n\n#define rep(i, n) for(int i = 0; i < n; i++) \n#define rep2(i, m, n) for(int i = m; i < n; i++) \nconst double EPS = 1E-9; \ntypedef long long ll; \ntypedef pair<int, int> P; \ntypedef pair<int, P> PP; \ntypedef complex<double> xy_t; \nconst int INF = 1 << 30; \n\n\n\nstruct swimmer{\n  int t;\n  double pos;\n  int lane;\n  int rest_loop;\n};\n\nint n;\nswimmer ss[100];\n\nbool operator<(swimmer s1, swimmer s2){\n  if(s1.rest_loop == 0 || s2.rest_loop == 0) return s1.rest_loop > s2.rest_loop;\n  else if(s1.lane != s2.lane) return s1.lane > s2.lane;\n  else {\n    if(s1.pos < EPS && s2.pos < EPS) return s1.t < s2.t;\n    else return s1.pos > s2.pos;\n  }\n}\n\nbool finish(){\n  int cnt = 0;\n  rep(i, n){\n    if(ss[i].rest_loop > 0) cnt++;\n  }\n  n = cnt;\n  \n  return cnt == 0;\n}\n\nvoid move(){\n  rep(i, n){\n    ss[i].pos += 1.0 / ss[i].t;\n  }\n  rep(i, n){\n    rep(j, i){\n      if(ss[i].lane == ss[j].lane && ss[i].pos > ss[j].pos){\n\tss[i].pos = ss[j].pos;\n      }\n    }\n  }\n  rep(i, n){\n    if(abs(1.0 - ss[i].pos) < EPS){\n      ss[i].pos = 0;\n      if(ss[i].lane){\n\tss[i].lane = 0;\n\tss[i].rest_loop--;\n      }else{\n\tss[i].lane = 1;\n      }\n    }\n  }\n  \n}\n\nint main(){\n  while(cin >> n && n){\n    rep(i, n){\n      cin >> ss[i].t >> ss[i].rest_loop;\n      ss[i].pos = 0.0;\n      ss[i].lane = 0;\n    }\n    sort(ss, ss + n);\n    int cnt = 0;\n    while(true){\n      if(finish()){\n\tcout << cnt << endl;\n\tbreak;\n      }\n      cnt++;\n      move();\n      sort(ss, ss + n);\n    }\n  }\n  return 0;\n}\n\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<cassert>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\n\nusing namespace std;\ntypedef pair<int,int> ii;\n\nstruct P\n{\n  ii time;\n  bool dir;//0->上, 1->下\n  P(ii time=ii(inf,inf),bool dir=false):time(time),dir(dir){}\n};\n\nint ans;\nint n;\n\nvoid compute(vector<vector<P> > &record,ii person)\n{\n  //cout << \"\\nperson : \" << person.first << \",\" << person.second << endl;\n  int cur = 0;\n  record.push_back(vector<P>());\n\n\n  rep(i,person.second*2)\n    {\n      bool dir = i % 2;//0->上,1->下\n      int next = cur + person.first;\n\n      //cout << \"chech---------- : \" << i << \" | \" << record.size() << endl;\n      rep(j,record.size()-1)\n\t{\n\t  rep(k,record[j].size())\n\t    {\n\t      P p = record[j][k];\n\t      //cout << \"ch(\" << p.time.first << \",\" << p.time.second <<\") dir : \" <<  (dir?\"↓\":\"↑\") << \"\\n\";\n\t      //if(p.time.second < cur)break;\n\t      if(p.dir != dir)continue;\n\t      if(p.time.first > cur)break;\n\n\t      if(p.time.second == next || p.time.first == cur)\n\t\t{\n\t\t  break;\t\t  \n\t\t}\n\t      else if(p.time.first < next && next < p.time.second)\n\t\t{\n\t\t  next = p.time.second;\n\t\t  goto Skip;\n\t\t}\n\t    }\n\t}\n    Skip:;\n      //cout << \"result (\" << cur << \",\" << next << \") : \" << (dir?\"↓\":\"↑\") << endl;\n      record[record.size()-1].push_back(P(ii(cur,next),dir));\n      cur = next;\n      ans = max(ans,next);\n    } \n}\n\nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      ans = 0;\n      vector<ii> info(n);\n      rep(i,n)scanf(\"%d %d\",&info[i].first,&info[i].second);\n      sort(all(info),greater<ii>());\n\n\n      vector<vector<P> > record;\n\n      rep(i,n)compute(record,info[i]);\n\t\n      printf(\"%d\\n\",ans);\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing Swimmer = tuple<int, int, int>;\nusing TC = tuple<int, int>;\n\nint main(void){\n    for(int n; cin >> n, n;){\n        vector<TC> tc(n);\n        for(auto & e : tc){\n            int t, c; cin >> t >> c;\n            e = TC(t, c);\n        }\n        sort(_all(tc));\n\n        vector<queue<Swimmer>> q(2);\n        for(auto & e : tc){\n            int t, c; tie(t, c) = e;\n            q[0].push(Swimmer(t, t, c));\n        }\n\n        int res = 0;\n        while(q[0].size() or q[1].size()){\n            int qi;\n            if(q[0].empty() or (q[1].size() and get<1>(q[0].front()) > get<1>(q[1].front()))){\n                qi = 1;\n            }\n            else qi = 0;\n\n            int dt = get<1>(q[qi].front());\n            res += dt;\n\n            vector<vector<Swimmer>> next(2);\n            rep(i, 2){\n                int ni  = i ^ 1;\n                while(q[i].size()){\n                    int t, rt, rc;\n                    tie(t, rt, rc) = q[i].front();\n\n                    if(rt > dt) break;\n\n                    q[i].pop();\n                    int nrc = rc;\n                    if(ni == 0) nrc--;\n\n                    if(nrc >= 1){\n                        Swimmer ns(t, t, nrc);\n                        next[ni].push_back(ns);\n                    }\n                }\n                sort(_all(next[ni]));\n            }\n\n            rep(i, 2){\n                queue<Swimmer> nq;\n                while(q[i].size()){\n                    int t, rt, rc;\n                    tie(t, rt, rc) = q[i].front(); q[i].pop();\n                    rt -= dt;\n                    nq.push(Swimmer(t, rt, rc));\n                }\n                for(auto & e : next[i]){\n                    nq.push(e);\n                }\n                q[i] = nq;\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v > a.v;\n  }\n};\n\nbool cmp(const state & a,const state &b){\n  return a.v > b.v;\n}\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nvoid solve(int n,vector<state>& in){\n  double ans=0;\n  sort(ALL(in));\n  while(n){\n    double mint=inf;\n    \n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID, in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      //      REP(j,i+1,n){\n      rep(j,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n    \n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    //    sort(ALL(in));\n    sort(in.begin(),in.begin()+n);\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (in[i].x > eps && fabs(in[i].x-in[j].x)<eps &&\n\t      in[j].v < in[i].v)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    //sort(ALL(in));\n    sort(in.begin(),in.begin()+n);\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n\n  printf(\"%.0lf\\n\",ans+eps);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    solve(n,in);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nsigned main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvvi in(n,vi(2));\n\t\trep(i,n)rep(j,2)cin>>in[i][j];\n\t\tsort(all(in));\n\t\tint tim=0;\n\t\tqueue<pii>que[2];\n\t\trep(i,n)que[0].push({in[i][0],i});\n\t\twhile(!que[0].empty()||!que[1].empty()){\n\t\t\ttim=inf;\n\t\t\trep(i,2)if(!que[i].empty()){\n\t\t\t\tint t=que[i].front().first;\n\t\t\t\tif(tim>t)tim=t;\n\t\t\t}\n\t\t\trep(i,2){\n\t\t\t\tvp ne;\n\t\t\t\twhile(!que[i].empty()&&que[i].front().first<=tim){\n\t\t\t\t\tne.pb(que[i].front());\n\t\t\t\t\tque[i].pop();\n\t\t\t\t}\n\t\t\t\trep(j,ne.size())rep(k,ne.size())\n\t\t\t\t\tif(in[ne[j].second][0]<in[ne[k].second][0])swap(ne[j],ne[k]);\n\t\t\t\trep(j,ne.size()){\n\t\t\t\t\tpii p=ne[j];\n\t\t\t\t\tif(i){\n\t\t\t\t\t\tin[p.second][1]--;\n\t\t\t\t\t\tif(in[p.second][1])que[i^1].push({tim+in[p.second][0],p.second});\n\t\t\t\t\t}else que[i^1].push({tim+in[p.second][0],p.second});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<tim<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <deque>\nusing namespace std;\n\nstruct S {\n\tint now, t, rem;\n};\nbool comp(const S& s1, const S& s2) {\n\treturn s1.t < s2.t;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tdeque<S> lane[2];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint t, c;\n\t\t\tcin >> t >> c;\n\t\t\tS s = { 0, t, c };\n\t\t\tlane[0].push_back(s);\n\t\t}\n\t\tsort(lane[0].begin(), lane[0].end(), comp);\n\n\t\tint ans = 0;\n\t\twhile(lane[0].size() + lane[1].size()) {\n\t\t\tint idx = 0;\n\t\t\tif(lane[0].size() == 0 || lane[1].size() && lane[0][0].t - lane[0][0].now > lane[1][0].t - lane[1][0].now)\n\t\t\t\tidx = 1;\n\n\t\t\tint time = lane[idx][0].t - lane[idx][0].now;\n\t\t\tdeque<S> temp;\n\t\t\twhile(lane[idx].size() && lane[idx][0].t - lane[idx][0].now <= time) {\n\t\t\t\tS s = lane[idx][0];\n\t\t\t\tlane[idx].pop_front();\n\n\t\t\t\ts.now = 0;\n\t\t\t\tif(idx == 1) s.rem--;\n\t\t\t\tif(s.rem) temp.push_back(s);\n\t\t\t}\n\n\t\t\tsort(temp.begin(), temp.end(), comp);\n\t\t\tfor(int i = 0; i < 2; i++) {\n\t\t\t\tfor(S& s : lane[i]) {\n\t\t\t\t\ts.now += time;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(S s : temp) {\n\t\t\t\tlane[1 - idx].push_back(s);\n\t\t\t}\n\t\t\tans += time;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef vector<int> vi;\n \nint main(){\n  int n, t[55], c[55];\n  pair<int,int> s[55];\n  while(scanf(\"%d\",&n),n){\n    rep(i,n)scanf(\"%d%d\",&s[i].first,&s[i].second);\n    sort(s,s+n);\n    rep(i,n){\n      t[i] = s[i].first;\n      c[i] = s[i].second;\n    }\n    \n    vi q[2];\n    rep(i,n)q[0].push_back(i);\n     \n    int ans = 0;\n    while(q[0].size() || q[1].size()){\n      vi g[2];\n      int nxt = 1000;\n      rep(x,2){\n\tif(q[x].size())nxt = min(nxt, t[q[x][0]]);\n      }\n      ans += nxt;\n\n      rep(x,2){\n\trep(i,q[x].size()){\n\t  t[q[x][i]] -= nxt;\n\t  if(i>0 && t[q[x][i-1]] > t[q[x][i]])t[q[x][i]] = t[q[x][i-1]];\n\t}\n\twhile(q[x].size()){\n\t  if(t[q[x][0]])break;\n\t  g[x].push_back(q[x][0]);\n\t  q[x].erase(q[x].begin());\n\t}\n      }\n       \n      sort(all(g[0])); sort(all(g[1]));\n      for(int id : g[0]){\n\tq[1].push_back(id);\n\tt[id] = s[id].first;\n      }\n      for(int id : g[1]){\n\tif(--c[id]){\n\t  q[0].push_back(id);\n\t  t[id] = s[id].first;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nusing namespace rel_ops;\nstruct rat{\n\tint a,b;\n\trat(int a,int b) :a(a),b(b){}\n};\ninline int gcd(int x,int y){\n\tif(y==0) return abs(x);\n\treturn gcd(y,x%y);\n}\ninline rat normz(rat x){\n\tint g=gcd(x.a,x.b);\n\t// if(x.b<0) x.a*=-1,x.b*=-1;\n\treturn rat(x.a/g,x.b/g);\n}\ninline rat operator+(const rat& x,const rat& y){\n\treturn normz(rat(x.a*y.b+x.b*y.a,x.b*y.b));\n}\ninline rat operator-(const rat& x,const rat& y){\n\treturn normz(rat(x.a*y.b-x.b*y.a,x.b*y.b));\n}\ninline bool operator<(const rat& x,const rat& y){\n\treturn x.a*y.b<x.b*y.a;\n}\ninline bool operator==(const rat& x,const rat& y){\n\treturn x.a*y.b==x.b*y.a;\n}\n\ntypedef vector<int> Vi;\nint main(){\n\twhile(true){\n\t\tint N,t[50],c[50];\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N) cin>>t[i]>>c[i];\n\t\tmap<rat,Vi> mp;\t//pos->id\n\t\tVi fst;\n\t\trep(i,N) fst.pb(i);\n\t\tmp[rat(0,1)]=fst;\n\t\tint tm=0;\n\t\twhile(true){\n\t\t\tmap<rat,Vi> nmp;\n\t\t\tint T=1e9;\n\t\t\tfor(auto it:mp){\n\t\t\t\tbool slow=1;\n\t\t\t\trat r=it.fs;\n\t\t\t\tVi vc=it.sc;\n\t\t\t\tif(r==rat(0,1)||r==rat(1,1)) slow=0;\n\t\t\t\tif(slow){\n\t\t\t\t\tint mx=0;\n\t\t\t\t\tfor(int v:vc) chmax(mx,t[v]);\n\t\t\t\t\trat s(1,1);\n\t\t\t\t\tif(r < rat(1,1)) s=rat(1,1)-r;\n\t\t\t\t\telse s=rat(2,1)-r;\n\t\t\t\t\tchmin(T,s.a*mx/s.b);\n\t\t\t\t}else{\n\t\t\t\t\tfor(int v:vc){\n\t\t\t\t\t\trat s(1,1);\n\t\t\t\t\t\tif(r < rat(1,1)) s=rat(1,1)-r;\n\t\t\t\t\t\telse s=rat(2,1)-r;\n\t\t\t\t\t\tchmin(T,s.a*t[v]/s.b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trat mn(2,1);\n\t\t\tfor(auto it=mp.rbegin();it!=mp.rend();it++){\n\t\t\t\tbool slow=1;\n\t\t\t\trat r=it->fs;\n\t\t\t\tVi vc=it->sc;\n\t\t\t\tif(r==rat(0,1)||r==rat(1,1)) slow=0;\n\t\t\t\tif(slow){\n\t\t\t\t\tint mxt=0;\n\t\t\t\t\tfor(int v:vc) chmax(mxt,t[v]);\n\t\t\t\t\trat nr=min(r+rat(T,mxt),mn);\n\t\t\t\t\tchmin(mn,nr);\n\t\t\t\t\tnmp[nr].insert(nmp[nr].end(),vc.begin(),vc.end());\n\t\t\t\t}else{\n\t\t\t\t\tfor(int v:vc){\n\t\t\t\t\t\trat nr=min(r+rat(T,t[v]),mn);\n\t\t\t\t\t\tnmp[nr].pb(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int v:nmp[rat(2,1)]){\n\t\t\t\tc[v]--;\n\t\t\t\tif(c[v]) nmp[rat(0,1)].pb(v);\n\t\t\t}\n\t\t\tnmp.erase(rat(2,1));\n\t\t\tmp=nmp;\n\t\t\ttm+=T;\n\t\t\tif(mp.empty()){\n\t\t\t\tcout<<tm<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n\n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2000+eps)n--;\n    }\n    \n  }\n  return (int)(ans+eps);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 2009ツアツジツアツ地ツ凝ヲツ予ツ選 C : Swimming Jam\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<int> t(n), c(n);\n\t\tfor(int i=0;i<n;i++) cin >> t[i] >> c[i];\n\t\tfor(int i=0;i<n;i++) c[i] *= 2;\n\t\tint ans = 0, count = 0;\n\t\tvector<int> lest = t;\n\t\tvector<bool> start(n,true);\n\t\twhile(count != n){\n\t\t\tvector<int> nlest(n);\n\t\t\tvector<bool> nstart(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(c[i] == 0) continue;\n\t\t\t\tif(start[i]){\n\t\t\t\t\tint slow = t[i];\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(c[j]!=0&&c[i]%2==c[j]%2&&!start[j])\n\t\t\t\t\t\t\tslow = max(slow, lest[j]);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tnlest[i] = slow - 1;\n\t\t\t\t\tnstart[i] = false;\n\t\t\t\t} else {\n\t\t\t\t\tnlest[i] = lest[i] - 1;\n\t\t\t\t}\n\t\t\t\tif(nlest[i] == 0){\n\t\t\t\t\tnstart[i] = true;\n\t\t\t\t\tc[i]--;\n\t\t\t\t\tif(c[i]==0) count++;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tlest = nlest;\n\t\t\tstart = nstart;\n\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvoid pairsort(int n,int *a,int *b){\n\tpair<int,int> c[50];\n\trep(i,n) c[i]=make_pair(-a[i],b[i]);\n\tsort(c,c+n);\n\trep(i,n) a[i]=-c[i].first, b[i]=c[i].second;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tint pace[50],lap[50];\n\t\trep(i,n) scanf(\"%d%d\",pace+i,lap+i);\n\n\t\tpairsort(n,pace,lap);\n\n\t\tvector<int> stop[50];\n\t\trep(i,n){\n\t\t\tint t=0;\n\t\t\tstop[i].push_back(t);\n\t\t\trep(j,2*lap[i]){\n\t\t\t\tint t_next=t+pace[i];\n\t\t\t\trep(k,i){\n\t\t\t\t\tint idx=lower_bound(stop[k].begin(),stop[k].end(),t)-stop[k].begin()-1;\n\t\t\t\t\tif(idx>=0 && idx%2==j%2){\n\t\t\t\t\t\tt_next=max(t_next,stop[k][idx+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt=t_next;\n\t\t\t\tstop[i].push_back(t);\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\trep(i,n) ans=max(ans,stop[i].back());\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n\nclass P{\npublic:\n  int s, c, r, t;\n  P(int s=0, int c=0):s(s), c(c){ r = s; t = 0;}\n  bool operator < ( const P &p ) const{ return s < p.s; }\n};\n\nvector<P> getNext(vector<P> &l, int w){\n  vector<P> nl;\n  rep(i, l.size()) l[i].r -= w;\n  while ( 0 < l.size() && l[0].r <= 0 ){\n    P p = l[0]; l.erase(l.begin());\n    p.t++;\n    if ( p.c*2 >= p.t ){\n      p.r = p.s;\n      nl.push_back(p);\n    }\n  }\n  sort(nl.begin(), nl.end());\n  return nl;\n}\n\nvoid simulate(vector<P> U, vector<P> D){\n  vector<P> nU, nD;\n  int w, e = 0;\n  while( U.size() + D.size() > 0){\n    if ( U.size() == 0 ) w = D[0].r;\n    else if ( D.size() == 0 ) w = U[0].r;\n    else w = min(U[0].r, D[0].r);\n    e += w;\n    nU = getNext(D, w);\n    nD = getNext(U, w);\n    rep(i, nU.size()) U.push_back(nU[i]);\n    rep(i, nD.size()) D.push_back(nD[i]);\n  }\n  cout << e << endl;\n}\n\nmain(){\n  int n;\n  while( cin >> n && n ){\n    vector<P> U, D;\n    rep(i, n){\n      P p; cin >> p.s >> p.c;\n      U.push_back(p);\n    }\n    sort(U.begin(), U.end());\n    simulate(U, D);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Swimmer {\n    int t,c;\n    Swimmer(int t,int c) : t(t) , c(c) {;}\n};\n\nbool operator<(const Swimmer &s,const Swimmer &t) {\n    return s.t < t.t;\n}\n\nint main() {\n    int n,t,c;\n    while(cin>>n, n) {\n        vector<Swimmer> vs;\n        for(int i=0; i<n; ++i) {\n            cin>>t>>c;\n            vs.push_back(Swimmer(t,c));\n        }\n        sort(vs.begin(), vs.end());\n\n        queue<pair<int,int> > q1,q2;\n        for(int i=0; i<n; ++i) q1.push(make_pair(vs[i].t,i));\n\n        int time,ans = 0;\n        for(time = 0; time < 1000000; time++) {\n            if(!q1.empty()) {\n                if(q1.front().first == time) {\n                    vector<pair<int,int> > wait;\n                    while(!q1.empty() && q1.front().first <= time) {\n                        wait.push_back(make_pair(vs[q1.front().second].t,q1.front().second));\n                        q1.pop();\n                    }\n\n                    if(q1.empty()) {\n                        while(!q2.empty() && q2.front().first+vs[q2.front().second].t <= time) {\n                            vs[q2.front().second].c--;\n                            if(vs[q2.front().second].c == 0) ans = max(ans,q2.front().first);\n                            else wait.push_back(make_pair(vs[q2.front().second].t,q2.front().second));\n                            q2.pop();\n                        }\n                    }\n\n                    sort(wait.begin(), wait.end());\n                    for(int i=0; i<wait.size(); ++i) {\n                        q2.push(make_pair(time+wait[i].first,wait[i].second));\n                    }\n                }\n            }\n            if(!q2.empty()) {\n                if(q2.front().first == time) {\n                    vector<pair<int,int> > wait;\n                    while(!q2.empty() && q2.front().first <= time) {\n                        vs[q2.front().second].c--;\n                        if(vs[q2.front().second].c == 0) ans = max(ans,q2.front().first);\n                        else wait.push_back(make_pair(vs[q2.front().second].t,q2.front().second));\n                        q2.pop();\n                    }\n\n                    if(q2.empty()) {\n                        while(!q1.empty() && q1.front().first+vs[q1.front().second].t <= time) {\n                            wait.push_back(make_pair(vs[q1.front().second].t,q1.front().second));\n                            q1.pop();\n                        }\n                    }\n\n                    sort(wait.begin(),wait.end());\n                    for(int i=0; i<wait.size(); ++i)\n                        q1.push(make_pair(time+wait[i].first,wait[i].second));\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n//#define RED_FILE\n\n#ifdef RED_FILE\nifstream ifs(\"input.txt\");\nofstream ofs(\"output.txt\");\n#define cin ifs\n#define cout ofs\n#endif\n\nint n;\nstruct info{\n\tint t,c;\n};\ninfo infos[1001];\n\nint main(){\n\twhile(cin>>n&&n!=0){\n\t\tvector<pair<int,int> > forward;\n\t\tvector<pair<int,int> > back;\n\t\tvector<pair<int,int> > tmp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint t,c;\n\t\t\tcin>>t>>c;\n\t\t\tinfos[i].t=t;\n\t\t\tinfos[i].c=c*2;\n\t\t\ttmp.push_back(make_pair(t,i));\n\t\t\t// »ÝÌoßbÆÔði[\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\t// tª¬³¢ÔÉ\\[gµÄ¨­\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tforward.push_back(make_pair(0,tmp[i].second));\n\t\t}\n\t\tint res=0;\n\t\twhile(forward.size()!=0||back.size()!=0){\n\t\t\t// forwardÆbackÅAÌCxgª¢ûðÀs(¯ÈçÇ¿çàÀs)\n\t\t\tconst int INF=1000000000;\n\t\t\tint fet=INF;\n\t\t\tint bet=INF;\n\t\t\tif(forward.size()!=0){\n\t\t\t\tint idx=forward[0].second;\n\t\t\t\t// forwardÅàÁÆàæªÌvfª·é\n\t\t\t\tfet=abs(infos[idx].t-forward[0].first);\n\t\t\t}\n\t\t\tif(back.size()!=0){\n\t\t\t\tint idx=back[0].second;\n\t\t\t\t//backÅàÁÆàæªÌvfª·é\n\t\t\t\tbet=abs(infos[idx].t-back[0].first);\n\t\t\t}\n\t\t\tint tm=min(fet,bet);\n\t\t\tres+=tm;\n\t\t\t// tmª¾¯SÌÔðißÄ¨­\n\t\t\tfor(int i = 0; i < forward.size(); i++)\n\t\t\t\tforward[i].first+=tm;\n\t\t\tfor(int i = 0; i < back.size(); i++)\n\t\t\t\tback[i].first+=tm;\n\t\t\t// forwardÌÙ¤ª¢\n\t\t\tvector<pair<int,int> > nf;\n\t\t\tvector<pair<int,int> > nb;\n\t\t\t// ðð½·vfðæª©çæè¢Ä¢­\n\t\t\twhile(forward.size()){\n\t\t\t\tint idx=forward[0].second;\n\t\t\t\t// ðð½·\n\t\t\t\tif(forward[0].first>=infos[idx].t){\n\t\t\t\t\tnf.push_back(make_pair(infos[idx].t,idx));\n\t\t\t\t\tinfos[idx].c--;\n\t\t\t\t\tforward.erase(forward.begin());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(back.size()){\n\t\t\t\tint idx=back[0].second;\n\t\t\t\t// ðð½·\n\t\t\t\tif(back[0].first>=infos[idx].t){\n\t\t\t\t\tif(infos[idx].c!=1)\n\t\t\t\t\t\tnb.push_back(make_pair(infos[idx].t,idx));\n\t\t\t\t\tinfos[idx].c--;\n\t\t\t\t\tback.erase(back.begin());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// ðð½µ½àÌð\\[gµAi[\n\t\t\tsort(nf.begin(),nf.end());\n\t\t\tsort(nb.begin(),nb.end());\n\t\t\tfor(int i = 0; i < nf.size(); i++)\n\t\t\t\tback.push_back(make_pair(0,nf[i].second));\n\t\t\tfor(int i = 0; i < nb.size(); i++)\n\t\t\t\tforward.push_back(make_pair(0,nb[i].second));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF (1<<29)\n\nstruct P{\n    int t, c, nt;\n    P(){}\n    P(int t, int c, int nt) :\n        t(t), c(c), nt(nt) {}\n\n    bool operator < (const P &p) const {\n        if (t != p.t) {\n            return t < p.t;\n        }\n        return c > p.c;\n    }\n};\n\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<P> v(n);\n        for (int i = 0; i < n; i++) {\n            cin >> v[i].t >> v[i].c;\n            v[i].nt = v[i].t;\n            v[i].c *= 2;\n        }\n        sort(v.begin(), v.end());\n        queue<P> Q[2];\n        for (int i = 0; i < n; i++) {\n            Q[0].push(v[i]);\n        }\n        int res = 0;\n        while (!Q[0].empty() || !Q[1].empty()) {          \n            int f = INF;            \n            if (!Q[0].empty()) {\n                f = Q[0].front().nt;\n            }\n            if (!Q[1].empty()) {\n                f = min(f, Q[1].front().nt);\n            }\n\n            res += f;\n            queue<P> nQ[2], nQ2[2];\n            for (int i = 0; i < 2; i++) {\n                vector<P> v;\n                while (!Q[i].empty()) {\n                    P p = Q[i].front(); Q[i].pop();\n                    if (p.nt-f == 0) {\n                        p.nt = p.t;\n                        if (--p.c > 0) {\n                            v.push_back(p);   \n                        }\n                    } else {\n                        p.nt -= f;\n                        nQ[i].push(p);\n                    }\n                }\n                sort(v.begin(), v.end());\n                for (int j = 0; j < (int)v.size(); j++) {\n                    nQ2[1-i].push(v[j]);\n                }\n            }\n            for (int i = 0; i < 2; i++) {\n                while (!nQ2[i].empty()) {\n                    nQ[i].push(nQ2[i].front());\n                    nQ2[i].pop();\n                }\n            }\n\n            for (int i = 0; i < 2; i++) {\n                int nt = 0;\n                while (!nQ[i].empty()) {\n                    P p = nQ[i].front(); nQ[i].pop();                  \n                    nt = p.nt = max(nt, p.nt);\n                    Q[i].push(p);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum LOC{\n\tto_left,\n\tto_right,\n};\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\treturn per_time < arg.per_time;\n\t};\n\tint per_time,sum_time,rest_count;\n\tdouble position,pre_pos;\n\tLOC loc;\n\tbool erased;\n};\n\nint N;\nLOC most_slow_loc;\nint most_slow_id,most_slow_sum_time,most_slow_per_time;\n\nvoid func(){\n\n\tvector<Info> V;\n\n\tfor(int i = 0; i < N; i++){\n\t\tInfo info;\n\t\tscanf(\"%d %d\",&info.per_time,&info.rest_count);\n\t\tinfo.sum_time = 0;\n\t\tinfo.loc = to_left;\n\t\tinfo.position = 0;\n\t\tinfo.erased = false;\n\t\tV.push_back(info);\n\t}\n\n\tsort(V.begin(),V.end());\n\n\tint num = N;\n\tint ans = 0,index;\n\tdouble tmp;\n\n\tfor(int time = 1; time <= 160000; time++){\n\n\t\tif(num == 1){\n\n\t\t\tfor(int i = 0; i < V.size();i++){\n\t\t\t\tif(V[i].erased == false){\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tV[index].position = (double)(time-V[index].sum_time)/(double)V[index].per_time;\n\n\t\t\tif(V[index].position >= 1.0){\n\t\t\t\tif(V[index].loc == to_left){\n\t\t\t\t\tans = time + V[index].per_time + 2*(V[index].rest_count-1)*V[index].per_time;\n\t\t\t\t\tnum--;\n\t\t\t\t}else{\n\t\t\t\t\tV[index].rest_count -= 1;\n\t\t\t\t\tif(V[index].rest_count == 0){\n\t\t\t\t\t\tans = time;\n\t\t\t\t\t\tnum--;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans = time + 2*V[index].rest_count*V[index].per_time;\n\t\t\t\t\t\tnum--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tfor(int i = V.size()-1; i >= 0; i--){\n\t\t\t\tif(V[i].erased)continue;\n\t\t\t\tV[i].pre_pos = V[i].position;\n\t\t\t\tV[i].position = (double)(time-V[i].sum_time)/(double)V[i].per_time;\n\t\t\t}\n\t\t\tfor(int i = V.size()-2; i >= 0;i--){\n\t\t\t\tif(V[i].erased)continue;\n\t\t\t\tindex = -1;\n\t\t\t\tfor(int k = i+1; k < V.size();k++){\n\t\t\t\t\tif(V[k].erased == true || k == i)continue;\n\n\t\t\t\t\tif(V[i].loc == V[k].loc && V[i].pre_pos < V[k].pre_pos){\n\t\t\t\t\t\tif(index == -1){\n\t\t\t\t\t\t\ttmp = V[k].pre_pos;\n\t\t\t\t\t\t\tindex = k;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(tmp > V[k].pre_pos){\n\t\t\t\t\t\t\t\ttmp = V[k].pre_pos;\n\t\t\t\t\t\t\t\tindex = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(index == -1){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tif(V[i].position >= V[index].position){\n\t\t\t\t\t\tif(V[index].position >= 1.0){\n\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tV[i].position = V[index].position-EPS;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < V.size();i++){\n\t\t\t\tif(V[i].erased)continue;\n\n\t\t\t\tif(V[i].position >= 1.0){\n\t\t\t\t\tV[i].sum_time = time;\n\t\t\t\t\tV[i].position = 0.0;\n\t\t\t\t\tif(V[i].loc == to_left){\n\t\t\t\t\t\tV[i].loc = to_right;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tV[i].rest_count -= 1;\n\t\t\t\t\t\tif(V[i].rest_count == 0){\n\t\t\t\t\t\t\tans = time;\n\t\t\t\t\t\t\tV[i].erased = true;\n\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tV[i].loc = to_left;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(num == 0)break;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double eps  = 1e-10;\nconst int inf = (1 << 21);\n\nclass state{\npublic:\n  int t,now,ori;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (now*a.t != a.now*t)return now*a.t < a.now*t;\n    return t > a.t;\n  }\n};\n\nint solve(int n,vector<state>& in){\n  int ans=0;\n  sort(ALL(in));\n  int m= n;\n\n  while(m){\n    int mint = inf;\n    rep(i,n){\n      if (in[i].now == inf)continue;\n      mint = min(mint,in[i].t-in[i].now%in[i].t);\n    }\n    \n    rep(i,n){\n      if (in[i].now == inf)continue;\n      in[i].now+=1;\n      int tnow=in[i].now-1,tt=in[i].t;\n      rep(j,n){\n\tif (in[j].now == inf)continue;\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif (in[i].t <= in[j].t)continue;\n\tif (in[j].now-in[i].now < 0)continue;\n\tdouble t = (in[i].t*in[j].t)*(in[j].now-in[i].now)/(double)(in[j].t-in[i].t);\n\tif (t <0)continue;\n\tif (t < mint){\n\t  mint=(int)(t+1);\n\t}\n      }\n      in[i].now-=1;\n    }\n    \n    rep(i,n){\n      if (in[i].now == inf)continue;\n      in[i].now+=mint;\n      int tnow=in[i].now-mint,tt=in[i].t;\n      rep(j,n){\n\tif (in[j].now == inf)continue;\n\tif (i == j)continue;\n\tif ((tnow)*in[j].t >=(in[j].now)*tt)continue;\n\tif ((in[i].now)*in[j].t >= (in[j].now+mint)*in[i].t){\n\t  in[i].now=in[j].now+mint;\n\t  in[i].t=in[j].t;\n\t}\n      }\n      in[i].now-=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now == inf)continue;\n      in[i].now+=mint;\n    }\n\n    rep(i,n){\n      if (in[i].now == inf)continue;\n      if (in[i].now%in[i].t == 0){\n\tif (in[i].now/in[i].t == 1){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=in[i].ori;\n\t}else if (in[i].now/in[i].t==2){\n\t  in[i].t=in[i].ori;\n\t  in[i].now=0;\n\t  in[i].cnt--;\n\t  if (in[i].cnt == 0)in[i].now=inf,m--;\n\t}\n      }\n    }\n    \n\n    /*    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].now == inf)n--;\n    }\n    */\n    ans+=mint;\n  }\n  return ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      int t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){t,0,t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n;\nint t[100],c[100];\nint maxt[2];\n\nstruct state{\n  int t,pc,r,idx;\n};\n\nbool operator<(const state& a,const state& b){\n  if(a.t==b.t)return a.pc > b.pc;\n  else return a.t > b.t;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,n)cin>>t[i]>>c[i];\n    priority_queue<state> que;\n    memset(maxt,0,sizeof(maxt));\n    rep(i,n){\n      que.push((state){0,t[i],0,(int)i});\n      c[i]*=2;\n    }\n    while(que.size()){\n      state s=que.top(); que.pop();\n      int nxt=max(maxt[s.r],s.t+s.pc);\n      maxt[s.r]=nxt;\n      c[s.idx]--;\n      if(c[s.idx]>0){\n        que.push((state){nxt,s.pc,1-s.r,s.idx});\n      }\n    }\n    cout<<max(maxt[0],maxt[1])<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2000+eps)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nll GCD(ll a ,ll b){\n  return b > 0 ? GCD(b,a%b) : a;\n}\n\nll LCM(ll a ,ll b){\n  return a / GCD(a,b) * b;\n}\n\nclass Swimmer{\npublic:\n  int current_pace;\n  int natural_pace;\n  int laps;\n  int pos;\n  int prev_pos;\n  int dir;\n  Swimmer(int current_pace,int natural_pace,int laps)\n    : current_pace(current_pace),natural_pace(natural_pace),laps(laps),pos(0),prev_pos(0),dir(0) {}\n};\n\nint main(){\n  int num_of_swimmers;\n  while(~scanf(\"%d\",&num_of_swimmers)){\n    if(num_of_swimmers == 0) break;\n    \n    int length = 1;\n    vector<Swimmer> swimmers;\n    for(int i = 0; i < num_of_swimmers; i++){\n      int natural_pace;\n      int laps;\n      scanf(\"%d %d\",&natural_pace,&laps);\n      length = LCM(natural_pace,length);\n      swimmers.push_back(Swimmer(natural_pace,natural_pace,laps));\n    }\n\n    int res = 0;\n    for(int time = 0; time <= 150000; time++){\n      bool has_swimmer = false;\n      for(int i = 0; i < swimmers.size(); i++){\n        if(swimmers[i].laps == 0) continue;\n        has_swimmer = true;\n        int speed = length / swimmers[i].current_pace;\n        swimmers[i].prev_pos = swimmers[i].pos;\n        swimmers[i].pos += speed * 1;\n      }\n\n      if(!has_swimmer){\n        res = time;\n        break;\n      }\n\n      for(int i = 0; i < swimmers.size(); i++){\n        for(int j = i+1; j < swimmers.size(); j++){\n          if(swimmers[i].laps == 0 || swimmers[j].laps == 0) continue;\n          if(swimmers[i].dir == swimmers[j].dir\n             && swimmers[i].pos != 0){\n            if(swimmers[i].pos > swimmers[j].pos\n               && swimmers[i].prev_pos < swimmers[j].prev_pos){\n              swimmers[i].pos = swimmers[j].pos;\n              swimmers[i].current_pace = swimmers[j].current_pace;\n            }\n            else if(swimmers[i].pos < swimmers[j].pos\n                    && swimmers[i].prev_pos > swimmers[j].prev_pos){\n              swimmers[j].pos = swimmers[i].pos;\n              swimmers[j].current_pace = swimmers[i].current_pace;\n            }\n            else if(swimmers[i].pos == swimmers[j].pos){\n              swimmers[i].current_pace = max(swimmers[i].current_pace,swimmers[j].current_pace);\n              swimmers[j].current_pace = max(swimmers[i].current_pace,swimmers[j].current_pace);\n            }\n          }\n        }\n      }\n\n      for(int i = 0; i < swimmers.size(); i++){\n        if(swimmers[i].pos == length){\n          if(swimmers[i].dir == 1){\n            swimmers[i].laps--;\n          }\n\n          swimmers[i].dir = (swimmers[i].dir == 1 ? 0 : 1);\n          swimmers[i].current_pace = swimmers[i].natural_pace;\n          swimmers[i].pos = 0;\n        }\n      }\n\n\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct E{\n  int idx, time, lane, s;\n  E() {}\n  E(int i, int t, int l, int s) :\n    idx(i), time(t), lane(l), s(s) {}\n  bool operator < (const E& e) const {\n    if(time != e.time) return time > e.time;\n    if(s != e.s) return s > e.s;\n    return idx > e.idx;\n  }\n};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    priority_queue<E> que;\n    int rest[50] = {};\n    REP(i, N){\n      int t, c; cin>>t>>c;\n      que.push(E(i, 0, 0, t));\n      rest[i] = c;\n    }\n    int last[2] = {};\n    while(!que.empty()){\n      E e = que.top(); que.pop();\n      int rt = e.time + e.s;\n      int nl = e.lane ^ 1;\n      if(last[nl] < rt){\n        last[nl] = rt;\n      }else{\n        rt = last[nl];\n      }\n      if(nl == 0 && --rest[e.idx] == 0){\n        continue;\n      }\n      que.push(E(e.idx, rt, nl, e.s));\n    }\n    cout<<last[0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nstruct Data{\n\tint t, c, sum;\n\tData(int t, int c, int sum = 0) : t(t), c(c), sum(sum) { }\n\tbool operator < ( const Data &right ) const {\n\t\treturn t < right.t;\n\t}\n};\n\nvoid returnLane(int time, queue<Data>& a, queue<Data>& b){\n\tvector<Data> nextLane;\n\twhile(not a.empty() and time >= a.front().t + a.front().sum){\n\t\tauto p = a.front(); a.pop();\n\t\tp.c--;\n\t\tp.sum = time;\n\t\tif(p.c == 0) continue;\n\t\tnextLane.emplace_back(p);\n\t}\n\tsort(all(nextLane));\n\tfor(auto i : nextLane) b.emplace(i);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<pair<int, int>> a(n);\n\t\trep(i,n){\n\t\t\tcin >> a[i].first >> a[i].second;\n\t\t\ta[i].second *= 2;\n\t\t}\n\n\t\tqueue<Data> lane1, lane2;\n\n\t\tvector<pair<int, int>> tmp(all(a));\n\t\tsort(all(tmp));\n\t\tfor(auto i : tmp) lane1.emplace(i.first, i.second, 0);\n\n\t\tint ans = 0;\n\t\twhile(not lane1.empty() or not lane2.empty()){\n\t\t\tans++;\n\t\t\treturnLane(ans, lane1, lane2);\n\t\t\treturnLane(ans, lane2, lane1);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n\nstruct intr {\n\tint a, b;\n\tintr() {\n\t\ta = b = 1;\n\t}\n\tintr(int x) {\n\t\ta = x; b = 1;\n\t}\n\tintr(int x, int y) {\n\t\ta = x; b = y;\n\t}\n\tbool operator<(const intr &r)const {\n\t\treturn a * r.b < b*r.a;\n\t}\n\tbool operator!=(const intr &r)const {\n\t\treturn a * r.b != b * r.a;\n\t}\n};\nint cnt[50];\nint t[50],c[50];\ntypedef pair<intr, int> speP;\nbool comp(int i, int j) {\n\treturn t[i] < t[j];\n}\nbool comp2(speP x, speP y) {\n\tif (x.first != y.first)return x.first < y.first;\n\treturn t[x.second] < t[y.second];\n}\nvoid solve() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tfill(cnt, cnt + n, 0);\n\t\trep(i, n) {\n\t\t\tcin >> t[i] >> c[i];\n\t\t}\n\t\tvector<speP> lane[2],coplane[2];\n\t\tvector<int> fin[2],cop[2];\n\t\trep(i, n) {\n\t\t\tfin[0].push_back(i);\n\t\t}\n\t\tint num = n; int tmp = 0;\n\t\twhile (num) {\n\t\t\ttmp++;\n\t\t\trep(j, 2) {\n\t\t\t\tcop[j].clear(); coplane[j].clear();\n\t\t\t}\n\t\t\trep(j, 2) {\n\t\t\t\tintr ma(1,1);\n\t\t\t\tsort(lane[j].begin(), lane[j].end(),comp2);\n\t\t\t\tper(i, lane[j].size()) {\n\t\t\t\t\tspeP p = lane[j][i];\n\t\t\t\t\tint id = p.second;\n\t\t\t\t\tintr r = p.first;\n\t\t\t\t\tr.a++;\n\t\t\t\t\tif (ma < r) {\n\t\t\t\t\t\tr = ma;\n\t\t\t\t\t}\n\t\t\t\t\tif (r.a == r.b) {\n\t\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\t\tcnt[id]++;\n\t\t\t\t\t\t\tif (cnt[id] == c[id]) {\n\t\t\t\t\t\t\t\tnum--; continue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcop[j ^ 1].push_back(id);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcoplane[j].push_back({ r,id });\n\t\t\t\t\t}\n\t\t\t\t\tma = r;\n\t\t\t\t}\n\t\t\t\tsort(fin[j].begin(), fin[j].end(), comp);\n\t\t\t\trep(i, fin[j].size()) {\n\t\t\t\t\tint id = fin[j][i];\n\t\t\t\t\tintr r(1, t[id]);\n\t\t\t\t\tif (ma < r)r = ma;\n\t\t\t\t\tif (r.a == r.b) {\n\t\t\t\t\t\tif (j == 1) {\n\t\t\t\t\t\t\tcnt[id]++;\n\t\t\t\t\t\t\tif (cnt[id] == c[id]) {\n\t\t\t\t\t\t\t\tnum--; continue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcop[j ^ 1].push_back(id);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcoplane[j].push_back({ r,id });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, 2)fin[j] = cop[j];\n\t\t\trep(j, 2)lane[j] = coplane[j];\n\t\t}\n\t\tcout << tmp << endl;\n\t}\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n\n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\tREP(j,i+1,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2000+eps)n--;\n    }\n\n  }\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (in[i].x<in[j].x && in[i].v > in[j].v)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dat{\n  int T,t,f,lap;\n  dat(){T=t=f=lap=0;}\n  vector<dat> V;\n  bool operator > (const dat &a)const{return T-t>a.T-a.t;}\n};\n\nbool onFront(const dat &a,const dat &b){return a.f==b.f&&1.0*a.t/a.T<1.0*b.t/b.T;}\nbool checkJam(const dat &a,const dat &b){return onFront(a,b)&&a.T-a.t<b.T-b.t;}\n\nint merge(vector<dat>&A,int idx){\n  dat &a = A[idx];\n  for(int i=0;i<(int)A.size();i++){\n    dat &b = A[i];\n    if(!checkJam(a,b))continue;\n    a.t=0, a.lap-=a.f, a.f=!a.f;\n    b.V.push_back(a);\n    A.erase(A.begin()+idx);\n    return 1e9;\n  }\n  return a.T-a.t;\n}\n\nvoid Push(vector<dat>&A,dat &a){\n  for(int i=0;i<(int)a.V.size();i++)Push(A,a.V[i]);\n  a.V.clear();\n  if(a.lap) A.push_back(a);\n}\n\nint sim(vector<dat> A){\n  int res=0;\n  while(!A.empty()){\n    sort(A.begin(),A.end(),greater<dat>());\n    int mn = 1e9;\n    for(int i=A.size()-1;i>=0;i--)mn=min(mn,merge(A,i));\n\n    vector<dat>nA;\n    for(int i=0;i<(int)A.size();i++)\n      if(A[i].t+mn<A[i].T) A[i].t+=mn,nA.push_back(A[i]);\n      else A[i].t=0, A[i].lap-=A[i].f, A[i].f=!A[i].f,Push(nA,A[i]);\n\n    A=nA;\n    res+=mn;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<dat> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].T>>A[i].lap;\n    cout<<sim(A)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<algorithm>\n#include<cmath>\n#include<complex>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define mp         make_pair\n\ntypedef complex<double> P;\n\nconst double eps = 1e-12;\nconst double pi  = acos(-1);\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\npair<P,P> CC_intersection(P a,P b,double r1,double r2){\n  double l,m,n;\n  double d = abs(a-b);\n  double x,y;\n  double p,q;\n  l=(d*d-r2*r2+r1*r1)/(2*d);\n  \n  x=a.real()+(b.real()-a.real())*l/d;\n  y=a.imag()+(b.imag()-a.imag())*l/d;\n  \n  n=sqrt(r1*r1-l*l);\n  \n  p=(b.imag()-a.imag())/d*n;\n  q=(b.real()-a.real())/d*n;\n  \n  return mp(P(x+p,y-q),P(x-p,y+q));\n}\n\nconst int CUT = 1000;\nvoid compute_arg(P cur,P next,P circle,vector<P> &gon){\n  double argA=arg(cur -circle);\n  double argB=arg(next-circle);\n  if (max(argA,argB)-min(argA,argB)>pi){\n    if (argA<0)argA+=2*pi;\n    else       argB+=2*pi;\n  }\n  double dif=(argB-argA)/(double)CUT;\n  double cosx=cos(dif),sinx=sin(dif);\n  P now=cur-circle;\n  rep(i,CUT){\n    double tx=cosx*now.real()-sinx*now.imag();\n    double ty=sinx*now.real()+cosx*now.imag();\n\n    now.real()=tx;\n    now.imag()=ty;\n    \n    gon.pb(circle+now);\n  }\n}\n\nP compute_centeroid(vector<P> &in,int n){\n  double cx=0,cy=0;//center\n  double a=0;//area of polygon\n  rep(i,n){\n    double cr=cross(in[i],in[(i+1)%n]);\n    a+=cr;\n    cx+=(in[i].real()+in[(i+1)%n].real())*cr;\n    cy+=(in[i].imag()+in[(i+1)%n].imag())*cr;\n  }\n  a/=2.0;\n  cx/=(6.0*a);\n  cy/=(6.0*a);\n  return P(cx,cy);\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a)<eps)return abs(c-a);\n  if (dot(a-b,c-b)<eps)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nvoid solve(double sx,double sy){\n  vector<P> gon;\n  gon.pb(P(sx,sy));\n  string order;\n  P cur(sx,sy);\n  while(true){\n    cin>>order;\n    if (order == \"line\"){\n      P next;\n      cin>>next.real()>>next.imag();\n      gon.pb(next);\n      cur=next;\n    }else if (order == \"arc\"){\n      P next;\n      double r;\n      cin>>next.real()>>next.imag()>>r;\n      pair<P,P> tmp=CC_intersection(cur,next,fabs(r),fabs(r));\n      if (r < 0){\n\tif (cross(next-cur,tmp.first-cur)>0)compute_arg(cur,next,tmp.first ,gon);\n\telse                                compute_arg(cur,next,tmp.second,gon);\n      }else if (r > 0){\n\tif (cross(next-cur,tmp.first-cur)<0)compute_arg(cur,next,tmp.first ,gon);\n\telse                                compute_arg(cur,next,tmp.second,gon);\n      }\n      cur=next;\n    }else if (order == \"close\"){\n      if (abs(gon[0]-gon[gon.size()-1])<eps)gon.erase(gon.begin()+gon.size()-1);\n      //else gon.pb(gon[0]);\n      break;\n    }\n  }\n\n  P ans=compute_centeroid(gon,gon.size());\n\n\n  \n  int index = -1;\n  double dist = 1e100;\n  int n=gon.size();\n  rep(i,gon.size()){\n    double tmp = distance_ls_p(gon[i],gon[(i+1)%n],ans);\n    if (tmp < dist){\n      index=i;\n      dist=tmp;\n    }\n  }\n\n  char out;\n  if (cross(gon[(index+1)%n]-gon[index],ans-gon[index])<-eps)out='-';\n  else out='+';\n\n  printf(\"%.4lf %.4lf %c\\n\",ans.real(),ans.imag(),out);\n}\n\nmain(){\n  string in;\n  double sx,sy;\n  while(cin>>in && in != \"end\"){\n    cin>>sx>>sy;\n    solve(sx,sy);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nint n;\nvoid exec()\n{\n\tcin >> n;\n\tif(n==0)exit(0);\n\tpriority_queue<T, vector<T>, greater<T> > l0, l1;\n\tint m0=0;\n\tint m1=0;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tl0.push(T(a,a,b));\n\t\tm0=max(m0,a);\n\t}\n\twhile(l0.size()||l1.size()){\n\t\tif(l1.size()==0||(l0.size()&&l0.top()<l1.top())){\n\t\t\tT t=l0.top();\n\t\t\t//cout << \"0 \" << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << endl;\n\t\t\tl0.pop();\n\t\t\tget<0>(t)=m1=max(m1,get<0>(t)+get<1>(t));\n\t\t\tl1.push(t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tT t=l1.top();\n\t\t\t//cout << \"1 \" << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << endl;\n\t\t\tl1.pop();\n\t\t\tget<2>(t)--;\n\t\t\tif(get<2>(t)<=0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tget<0>(t)=m0=max(m0,get<0>(t)+get<1>(t));\n\t\t\tl0.push(t);\n\t\t}\n\t}\n\tcout << m1 << endl;\n}\nint main() {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct swimmer {\n    int t, c, sum;\n    bool operator<(swimmer const& s) {\n        return t < s.t;\n    }\n};\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        queue<swimmer> que[2];\n        for(int i=0; i<n; ++i) {\n            int t, c;\n            cin >> t >> c;\n            que[0].push(swimmer{t, c, 0});\n        }\n        int res = 0;\n        while(!que[0].empty() || !que[1].empty()) {\n            bool f = que[0].empty() || (!que[1].empty() && que[1].front().sum < que[0].front().sum);\n            res = que[f].front().sum;\n            vector<swimmer> next;\n            while(!que[f].empty() && que[f].front().sum <= res) {\n                next.push_back(que[f].front());\n                que[f].pop();\n            }\n            sort(next.begin(), next.end());\n            for(int i=0; i<next.size(); ++i) {\n                if(next[i].c > 0) {\n                    que[f^1].push(swimmer{next[i].t, next[i].c - f, res + next[i].t});\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    double EPS = 1e-8;\n    double length = 1e6;\n    int n; cin >> n;\n    if(!n) break;\n    VI t(n), c(n);\n    vector<PII> p(n);\n    REP(i, n) {\n      cin >> t[i] >> c[i];\n      p[i] = {t[i], c[i]};\n    }\n    sort(ALL(p));\n\n    // i人目の人の速度\n    vector<double> v(n);\n    REP(i, n) v[i] = length/p[i].first;\n\n    // i人目の人の位置、何周目か\n    vector<pair<double,int>> place(n, {0, 0});\n    vector<pair<double,int>> nxt(n, {0, 0});\n    int i, num;\n    for(i=0, num=0; num<n; ++i) {\n      // j人目を進める\n      REP(j, n) {\n        if(place[j].second >= c[j]) continue;\n        double tmp = place[j].first + v[j];\n        REP(k, n) {\n          if(j==k) continue;\n          if(place[k].second >= p[k].second) continue;\n          if(place[j].first < EPS && place[k].first < EPS) continue;\n          if(abs(place[j].first-length) < EPS && abs(place[k].first - length) < EPS) continue;\n          // jがkを追い越す\n          if(place[j].first <= place[k].first && place[j].first+v[j] > place[k].first+v[k]) {\n            chmin(tmp, place[k].first+v[k]);\n          }\n        }\n        if(place[j].first < 2*length && 2*length <= tmp+EPS) {\n          nxt[j] = (PII){0, place[j].second+1};\n          if(nxt[j].second >= p[j].second) num++;\n        }\n        else {\n          nxt[j] = (PII){tmp, place[j].second};\n        }\n      }\n      place = nxt;\n      // cout << place << endl;\n    }\n\n    cout << i << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\nll modpow(ll x, ll b){\n\tll res = 1;\n\twhile(b){\n\t\tif(b&1)res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll modinv(ll x){\n\treturn modpow(x, MOD-2);\n}\n\nbool was_output = false;\ntemplate<class t>\nvoid output(t a){\n\tif(was_output)cout << \" \";\n\tcout << a;\n\twas_output = true;\n}\nvoid outendl(){\n\twas_output = false;\n\tcout << endl;\n}\n\ndouble func(int n){\n\tll res = 0;\n\tvector<pii> man(n);\n\tforeach(i, man)cin>>i.first>>i.second;\n\tsort(all(man));\n\tvector<pii> p[2];\n\tint slowest[2]={0, 0};\n\n\t//time side needtime needcount\n\tusing T = tuple<int, int, int, int>;\n\tpriority_queuer<T> pq;\n\tforeach(i, man){\n\t\tpq.emplace(i.first, 1, i.first, i.second*2-1);\n\t\tchmax(slowest[1], i.first);\n\t}\n\twhile(pq.size()){\n\t\tint ntime = get<0>(pq.top());\n\t\tchmax(res, (ll)ntime);\n\t\twhile(pq.size()&&ntime==get<0>(pq.top())){\n\t\t\tT d = pq.top();\n\t\t\tpq.pop();\n\t\t\tint lane = get<1>(d);\n\t\t\tint needtime = get<2>(d);\n\t\t\tint needcount = get<3>(d);\n\t\t\tif(needcount){\n\t\t\t\tp[lane].emplace_back(needtime, needcount);\n\t\t\t}\n\t\t}\n\t\trep(i, 2){\n\t\t\tsort(all(p[i]));\n\t\t\tforeach(j, p[i]){\n\t\t\t\tint needtime = max(slowest[!i], ntime+j.first);\n\t\t\t\tslowest[!i] = needtime;\n\t\t\t\tpq.emplace(needtime, !i, j.first, j.second-1);\n\t\t\t}\n\t\t\tp[i].clear();\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tcout << func(n) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#define rep(i,n) for(auto i=0*(n);i<(n);++i)\n\nint main(){\n    while(true){\n        ll n;\n        cin >> n;\n        if(n==0) break;\n        \n        vector<ll> t(n), c(n);\n        rep(i, n){\n            cin >> t[i] >> c[i];\n        }\n        \n        using P = tuple<ll,ll,ll,ll>;\n        priority_queue<P, vector<P>, greater<P> > q;\n        ll btm[2] = { 0, 0 };\n        \n        rep(i, n) {\n            q.push(P(t[i], t[i], i, 1ll));\n            btm[0] = max(btm[0], t[i]);\n        }\n        \n        while(!q.empty()){\n            ll tm, speed, id, turn;\n            tie(tm, speed, id, turn) = q.top(); q.pop();\n            ll ntm = max(tm + speed, btm[turn%2]);\n            btm[turn%2] = max(btm[turn%2], ntm);\n            if(turn+1 == c[id]*2) continue;\n            q.push(P(ntm, speed, id, turn+1));\n        }\n        \n        cout << max(btm[0], btm[1]) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Swimer {\n  int time;\n  int end;\n  int lap;\n  int lane;\n  Swimer(int time, int end, int lap, int lane) :\n    time(time), end(end), lap(lap), lane(lane) {;}\n  bool operator<(const Swimer &rhs) const {\n    if (end != rhs.end) { return end > rhs.end; }\n    return time > rhs.time;\n  }\n};\n\nint n;\nint block[2];\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    int ans = 0;\n    memset(block, 0, sizeof(block));\n    priority_queue<Swimer> que;\n    for (int i = 0; i < n; i++) {\n      int t, c;\n      scanf(\"%d %d\", &t, &c);\n      que.push(Swimer(t, 0, c, 0));\n    }\n    while (!que.empty()) {\n      Swimer swimer = que.top();\n      que.pop();\n      ans = max(ans, swimer.end);\n      if (swimer.lap == 0) { continue; }\n      //cout << swimer.time << \" \" << swimer.end << \" \" << swimer.lap << \" \" << swimer.lane << endl;\n      int nend = swimer.end + swimer.time;\n      if (block[swimer.lane] > nend) {\n        nend = block[swimer.lane];\n      } else {\n        block[swimer.lane] = nend;\n      }\n      int nlane = (swimer.lane + 1) & 1;\n      int nlap = swimer.lap;\n      if (nlane == 0) { nlap--; }\n      que.push(Swimer(swimer.time, nend, nlap, nlane));\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        vector<int> t(n), c(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> t[i] >> c[i];\n        }\n\n        struct swimmer {\n            int t, v, res;\n        };\n\n        queue<swimmer> que[2];\n        for (int i = 0; i < n; ++i) {\n            que[0].push({ 0, t[i], c[i] });\n        }\n\n        int ans = 0;\n\n        while (!que[0].empty() or !que[1].empty()) {\n            int f = que[0].empty() or (\n                    !que[1].empty() and que[0].front().t > que[1].front().t);\n            ans = que[f].front().t;\n\n            vector<swimmer> s;\n            while (!que[f].empty() and que[f].front().t <= ans) {\n                s.push_back(que[f].front());\n                que[f].pop();\n            }\n            sort(s.begin(), s.end(), [](swimmer& a, swimmer& b){\n                    return a.v < b.v; });\n\n            for (int i = 0; i < s.size(); ++i) {\n                if (s[i].res) {\n                    que[f^1].push({ ans + s[i].v, s[i].v, s[i].res-f });\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dat{\n  int T,t,f,lap;\n  dat(){T=t=f=lap=0;}\n  vector<dat> V;\n  bool operator < (const dat &a)const{return T<a.T;}\n  bool operator > (const dat &a)const{return T>a.T;}\n};\n\ndouble Pos(const dat &a){return 1.0*a.t/a.T;}\nbool onFront(const dat &a,const dat &b){return a.f==b.f&&Pos(a) < Pos(b);}\nbool checkJam(const dat &a,const dat &b){return onFront(a,b)&&a.T-a.t<b.T-b.t;}\n\n\nbool merge(vector<dat>&A,int idx){\n  int in = -1,mx=-1;\n  for(int i=0;i<(int)A.size();i++){\n    dat &a = A[idx],&b = A[i];\n    if(checkJam(a,b)&&b.T-b.t>mx)in=i,mx = b.T-b.t;\n  }\n  if(in!=-1){  \n    dat &a=A[idx],&b=A[in];\n    a.t=0,a.lap-=a.f,a.f=!a.f;\n    b.V.push_back(a);\n    A.erase(A.begin()+idx);\n    return 1;\n  }\n  \n  return 0;\n}\n\nvoid Push(vector<dat>&A,dat &a){\n  for(int i=0;i<(int)a.V.size();i++)Push(A,a.V[i]);\n  a.V.clear();\n  if(a.lap) A.push_back(a);\n}\n\nvoid pr(dat &a){cout<<a.T<<\" \"<<a.t<<\" \"<<a.f<<\" \"<<a.lap<<\" \"<<a.V.size()<<endl;}\n\nint sim(vector<dat> A){\n  int res=0;\n  while(!A.empty()){\n    sort(A.begin(),A.end(),greater<dat>());\n    \n    // for(int i=0;i<A.size();i++)pr(A[i]);\n    int mn = 1e9;\n    for(int i=A.size()-1;i>=0;i--)\n      if(!merge(A,i))mn=min(mn,A[i].T-A[i].t);\n    \n    //    cout<<\"res=\"<<res<<endl,cout<<\"mn=\"<<mn<<endl;for(int i=0;i<A.size();i++)pr(A[i]);cout<<\"-------------\"<<endl;\n    vector<dat>nA;\n    for(int i=0;i<(int)A.size();i++)\n      if(A[i].t+mn<A[i].T) A[i].t+=mn,nA.push_back(A[i]);\n      else A[i].t=0, A[i].lap-=A[i].f, A[i].f=!A[i].f,Push(nA,A[i]);\n\n    A=nA;\n    res+=mn;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<dat> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].T>>A[i].lap;\n    cout<<sim(A)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct man {\n  double nsp;\n  double speed; \n  int c;\n  bool iki;\n  double dis;\n  man(double nsp, double speed, int c, bool iki, double dis) : nsp(nsp), speed(speed), c(c), iki(iki), dis(dis) {}\n  man() {}\n};\n\ndouble dis(man a, man b) {      // a ©ç b Ì£\n  if (a.iki ^ b.iki) {\n    return 1.0 - a.dis +  b.dis;\n  } else {\n    double tmp = b.dis - a.dis;\n    if (tmp < 1e-8) return 2.0 - tmp;\n    else return tmp;\n  }\n}\n\nstruct event {\n  double time;\n  int type;                     // 0 : OÌlÉÇ¢Â¢½ 1 : ü±¤Ì[É¢½ 2 : ±Á¿Ì[ÉÂ¢½\n  int id;                     // lÌID\n  int front;\n  event(double time, int type, int id, int front) : time(time), type(type), id(id), front(front) {}\n  event() {}\n};\n\nconst bool operator<(const event &a, const event &b) {\n  return a.time < b.time;\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    vector<man> m(n);\n    REP(i,n) {\n      int t, c;\n      cin >> t >> c;\n      m[i] = man(1.0/t, 1.0/t, c, 1, 0);\n    }\n    vector<event> events;\n    REP(i, n) {\n      events.push_back(event(1.0 / m[i].nsp, 1, i, 0));\n      REP(j, n) {\n        if (i==j) continue;\n        if (m[i].nsp <= m[j].nsp) continue;\n        events.push_back(event(2.0 / (m[i].nsp - m[j].nsp), 0, i, j));\n      }\n    }\n    double ans = 0;\n    while(1) {\n      event e = *min_element(ALL(events));\n      double time = e.time;\n      //cout << time << endl;\n      // Ôð··ßé\n      REP(i, m.size()) {\n        m[i].dis += m[i].nsp * time;\n        //    printf(\"(%d,%f) \", i, m[i].dis);\n      }\n      //cout << endl;\n      ans += time;\n      // Cxg\n      if (e.type == 0) {\n        m[e.id].nsp = m[e.front].nsp;\n      } else {\n        m[e.id].dis = 0;\n        m[e.id].iki ^= 1;\n        m[e.id].nsp = m[e.id].speed;\n        if (m[e.id].iki) {\n          m[e.id].c--;\n          if (m[e.id].c == 0) {\n            m.erase(m.begin() + e.id);\n            if (m.size() == 0)\n              break;\n          }\n        }\n      }\n      // ÌCxgvZ\n      events.clear();\n      REP(i, m.size()) {\n        events.push_back(event((1.0 - m[i].dis) / m[i].nsp, 1, i, 0));\n        REP(j, m.size()) {\n          if (i==j) continue;\n          if (m[i].nsp <= m[j].nsp) continue;\n          events.push_back(event(dis(m[i], m[j]) / (m[i].nsp - m[j].nsp), 0, i, j));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint solve(int N, vector<int> T, vector<int> C) {\n\tvector<int> remaining_lap = C;\n\n\tvector<pair<int, int>> D[2];\n\tfor (int i = 0; i < N; i++) D[0].push_back(make_pair(i, 0));\n\n\tfor (int t = 0; t <= 150000; t++) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tvector<pair<int, int>> S;\n\t\t\tvector<bool> VV(D[i].size(), false);\n\t\t\t\n\t\t\tfor (int j = 0; j < D[i].size(); j++) {\n\t\t\t\tif (D[i][j].second == t) {\n\t\t\t\t\tint pos = D[i][j].first;\n\t\t\t\t\tremaining_lap[pos]--; VV[j] = true;\n\t\t\t\t\tif (remaining_lap[pos] == 0) continue;\n\t\t\t\t\tS.push_back(make_pair(T[pos], pos));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(S.begin(), S.end());\n\t\t\t\n\t\t\tvector<pair<int, int>> new_D;\n\t\t\tfor (int j = 0; j < D[i].size(); j++) { if (VV[j] == false) new_D.push_back(D[i][j]); }\n\t\t\tD[i] = new_D;\n\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tint pos = S[j].second;\n\t\t\t\tD[i ^ 1].push_back(make_pair(pos, t + T[pos]));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 1; j < D[i].size(); j++) {\n\t\t\t\tD[i][j].second = max(D[i][j].second, D[i][j - 1].second);\n\t\t\t}\n\t\t}\n\n\t\tif (D[0].size() == 0 && D[1].size() == 0) return t;\n\t}\n\treturn -1;\n}\n\nint main() {\n\twhile (true) {\n\t\tint N; cin >> N; if (N == 0) break;\n\t\tvector<int> T(N, 0), C(N, 0);\n\t\tfor (int i = 0; i < N; i++) { cin >> T[i] >> C[i]; C[i] *= 2; C[i]++; }\n\n\t\tcout << solve(N, T, C) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n\n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\tREP(j,i+1,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2000+eps)n--;\n    }\n    \n  }\n  return (int)(ans+eps);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nll GCD(ll a ,ll b){\n  return b > 0 ? GCD(b,a%b) : a;\n}\n\nll LCM(ll a ,ll b){\n  return a / GCD(a,b) * b;\n}\n\nclass Swimmer{\npublic:\n  int current_pace;\n  int natural_pace;\n  int laps;\n  double pos;\n  double prev_pos;\n  int dir;\n  Swimmer(int current_pace,int natural_pace,int laps)\n    : current_pace(current_pace),natural_pace(natural_pace),laps(laps),pos(0),prev_pos(0),dir(0) {}\n};\n\nint main(){\n  int num_of_swimmers;\n  while(~scanf(\"%d\",&num_of_swimmers)){\n    if(num_of_swimmers == 0) break;\n    \n    vector<Swimmer> swimmers;\n    for(int i = 0; i < num_of_swimmers; i++){\n      int natural_pace;\n      int laps;\n      scanf(\"%d %d\",&natural_pace,&laps);\n      swimmers.push_back(Swimmer(natural_pace,natural_pace,laps));\n    }\n\n    int res = 0;\n    for(int time = 0; time <= 150000; time++){\n      bool has_swimmer = false;\n      for(int i = 0; i < swimmers.size(); i++){\n        if(swimmers[i].laps == 0) continue;\n        has_swimmer = true;\n        double speed = 1.0 / (double)swimmers[i].current_pace;\n        swimmers[i].prev_pos = swimmers[i].pos;\n        swimmers[i].pos += speed * 1.0;\n      }\n\n      if(!has_swimmer){\n        res = time;\n        break;\n      }\n\n      for(int i = 0; i < swimmers.size(); i++){\n        if(swimmers[i].pos >= 1.0 - EPS) continue;\n\n        for(int j = i+1; j < swimmers.size(); j++){\n          if(swimmers[j].pos >= 1.0 - EPS) continue;\n\n          if(swimmers[i].dir == swimmers[j].dir\n             && abs(swimmers[i].pos) > EPS){\n            if(swimmers[i].pos > swimmers[j].pos\n               && swimmers[i].prev_pos < swimmers[j].prev_pos){\n              swimmers[i].pos = swimmers[j].pos;\n              swimmers[i].current_pace = swimmers[j].current_pace;\n            }\n            else if(swimmers[i].pos < swimmers[j].pos\n                    && swimmers[i].prev_pos > swimmers[j].prev_pos){\n              swimmers[j].pos = swimmers[i].pos;\n              swimmers[j].current_pace = swimmers[i].current_pace;\n            }\n            else if(abs(swimmers[i].pos - swimmers[j].pos) < EPS){\n              swimmers[i].current_pace = max(swimmers[i].current_pace,swimmers[j].current_pace);\n              swimmers[j].current_pace = max(swimmers[i].current_pace,swimmers[j].current_pace);\n            }\n          }\n        }\n      }\n\n      for(int i = 0; i < swimmers.size(); i++){\n        if(swimmers[i].pos >= 1.0 - EPS){\n          if(swimmers[i].dir == 1){\n            swimmers[i].laps--;\n          }\n\n          swimmers[i].dir = (swimmers[i].dir == 1 ? 0 : 1);\n          swimmers[i].current_pace = swimmers[i].natural_pace;\n          swimmers[i].pos = 0.0;\n          if(swimmers[i].laps == 0){\n            swimmers.erase(swimmers.begin() + i);\n            i--;\n          }\n        }\n      }\n\n\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n\n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2000+eps)n--;\n    }\n  }\n  \n  //  if (fabs((int)(ans+0.5)-ans)<eps)ans=(int)(ans+0.5);\n  //  return (int)ans;\n  return (int)(ans+0.5);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dat{\n  int T,t,f,lap;\n  dat(){T=t=f=lap=0;}\n  vector<dat> V;\n  bool operator > (const dat &a)const{return T-t>a.T-a.t;}\n};\n\nbool onFront(const dat &a,const dat &b){return a.f==b.f&&1.0*a.t/a.T<1.0*b.t/b.T;}\nbool checkJam(const dat &a,const dat &b){return onFront(a,b)&&a.T-a.t<b.T-b.t;}\n\nint merge(vector<dat>&A,int idx){\n  dat &a = A[idx];\n  for(int i=0;i<(int)A.size();i++){\n    dat &b = A[i];\n    if(!checkJam(a,b))continue;\n    a.t=0, a.lap-=a.f, a.f=!a.f;\n    b.V.push_back(a);\n    A.erase(A.begin()+idx);\n    return 1e9;\n  }\n  return a.T-a.t;\n}\n\nvoid Push(vector<dat>&A,dat &a){\n  for(int i=0;i<(int)a.V.size();i++)Push(A,a.V[i]);\n  a.V.clear();\n  if(a.lap) A.push_back(a);\n}\n\nint sim(vector<dat> A){\n  int res=0,idx=0;\n  vector<dat> tmp[2]={A};\n  while(1){\n    vector<dat> &A = tmp[idx];idx=!idx;\n    if(A.empty())break;\n    sort(A.begin(),A.end(),greater<dat>());\n    int mn = 1e9;\n    for(int i=A.size()-1;i>=0;i--)mn=min(mn,merge(A,i));\n\n    vector<dat>&nA=tmp[idx];tmp[idx].clear();\n    for(int i=0;i<(int)A.size();i++)\n      if(A[i].t+mn<A[i].T) A[i].t+=mn,nA.push_back(A[i]);\n      else A[i].t=0, A[i].lap-=A[i].f, A[i].f=!A[i].f,Push(nA,A[i]);\n    res+=mn;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<dat> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].T>>A[i].lap;\n    cout<<sim(A)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nbool solve() {\n  int n; cin >> n;\n  if(n == 0) return false;\n  vector<pair<ld, ld>> p(n);\n  for(int i=0;i<n;++i) {\n    cin >> p[i].first >> p[i].second;\n  }\n  sort(p.rbegin(), p.rend());\n  int ans = 0;\n  vector<P> l, r;\n  for(int i=0;i<n;++i) {\n    int cnt = 0;\n    int now = 0;\n    while(cnt < p[i].second) {\n      int nxtl = now + p[i].first;\n      for(int j=0;j<(int)(l.size());++j) {\n        if(l[j].first < now && l[j].first <= nxtl && nxtl <= l[j].second) {\n          nxtl = l[j].second;\n        }\n      }\n      l.push_back({now, nxtl});\n      now = nxtl;\n      int nxtr = now + p[i].first;\n      for(int j=0;j<(int)(r.size());++j) {\n        if(r[j].first < now && r[j].first <= nxtr && nxtr <= r[j].second) {\n          nxtr = r[j].second;\n        }\n      }\n      r.push_back({now, nxtr});\n      now = nxtr;\n      cnt++;\n    }\n    ans = max(ans, now);\n  }\n  cout << ans << endl;\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    if(!solve()) break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nP t[50];\nint id[50];\n\nint a[50];\nint b[50];\nint c[50];\nint ans[50];\n\nvoid solve(){\n  \n  priority_queue< P , vector< P > , greater< P > > Q;\n  for(int i=0;i<n;i++){\n    Q.push(P(0,i));\n  }\n\n  while(!Q.empty()){\n    P p=Q.top();Q.pop();\n    int x=p.first,y=p.second;\n    //   cout<<x<<' '<<y<<' '<<a[y]<<' '<<b[y]<<' '<<c[y]<<endl;\n\n    if(c[y]==t[y].second){\n      c[y]++;\n      continue;\n    }\n    \n    int next=x+t[y].first;\n    for(int i=0;i<n;i++){\n      if(c[i]>t[i].second)continue;\n      if(i==y)continue;\n      if(b[i]!=b[y]){\n        next=max(next,a[i]);\n      }\n    }\n    a[y]=next;\n    b[y]=1-b[y];\n    if(b[y]==0)c[y]++;\n    \n    Q.push(P(a[y],y));\n  }\n  \n  for(int i=0;i<n;i++){\n    ans[id[i]]=a[i];\n  }\n}\n\nvoid init(){\n  for(int i=0;i<50;i++){\n    a[i]=0;\n    b[i]=0;\n    c[i]=0;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>t[i].first>>t[i].second;\n      id[i]=i;\n    }\n    for(int i=n-1;i>0;i--){\n      for(int j=0;j<i;j++){\n        if(t[j]>t[j+1]){\n          swap(t[j],t[j+1]);\n          swap(id[j],id[j+1]);\n        }\n      }\n    }\n    solve();\n    int ANS=0;\n    for(int i=0;i<n;i++)\n      ANS=max(ANS,ans[i]);\n    cout<<ANS<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(ans >0 && mint>0);\n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2000+eps)n--;\n    }\n  }\n\n  return (int)(ans+eps);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Ryo Kamoi\n// #define DEBUG\n\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef long long ll;\n\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nint INF = 1000000000;\n\nstruct swimer{\n  int goal, rane, res;\n};\n\ntypedef pair<int, swimer> pis;\n\nint n;\nint t[60], c[60];\nint start[2], goal[2];\nswimer sws[60];\n\nint main(){\n  while(1) {\n    cin >> n;\n    if (n==0) break;\n\n    REP(i, n) {\n      cin >> t[i] >> c[i];\n    }\n\n    REP(i, 2) {\n      start[i] = 0; goal[i] = 0;\n    }\n\n    priority_queue<pii, vector<pii>, greater<pii>> que;\n    REP(i, n) {\n      pii p;\n      p.first = 0;\n      p.second = i;\n      sws[i].goal = t[i];\n      sws[i].rane = 0;\n      sws[i].res = c[i];\n      que.push(p);\n    }\n\n    while (!que.empty()) {\n      pii p = que.top(); que.pop();\n      swimer s = sws[p.second];\n\n      if (p.first > start[s.rane]) {\n        if (goal[s.rane] > s.goal) {\n          sws[p.second].goal = goal[s.rane];\n        } else {\n          start[s.rane] = p.first;\n          goal[s.rane] = s.goal;\n        }\n      } else {\n        goal[s.rane] = max(s.goal, goal[s.rane]);\n      }\n\n      if (s.rane == 1) {\n        sws[p.second].res--;\n      }\n\n#ifdef DEBUG\n      cout << p.second << \" \" << s.rane << \" \" << p.first \n      << \" \" << s.res << endl;\n      cout << start[s.rane] << \" \" << goal[s.rane] << endl;\n      cout << endl;\n#endif\n\n      if (sws[p.second].res > 0) {\n        pii next_p = pii(goal[s.rane], p.second);\n        sws[p.second].rane = (s.rane+1) % 2;\n        sws[p.second].goal = next_p.first + t[p.second];\n        que.push(next_p);\n      }\n    }\n\n    cout << goal[1] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n#define F first\n#define S second\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, c[50], t[50];\nbool cmp(const pi &a, const pi &b){\n\treturn t[a.F] < t[b.F];\n}\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> t[i] >> c[i];\n\t\tqueue<pair<int, pi> > q[2];\n\t\trep(i, n) q[0].push(mp(i, mp(t[i], 0)));\n\t\t\n\t\tint cur = 0, next = 1, ans;\n\t\twhile(q[0].size() || q[1].size()){\n\t\t\t\n\t\t\tif(q[cur].empty()) swap(cur, next);\n\t\t\telse if(q[next].size() && q[cur].front().S.F > q[next].front().S.F) swap(cur, next);\n\t\t\t\n\t\t\tvector<pi> v;\n\t\t\tint nxt = q[cur].front().S.F;\n\t\t\twhile(q[cur].size() && q[cur].front().S.F <= nxt){\n\t\t\t\tv.pb(mp(q[cur].front().F, q[cur].front().S.S));\n\t\t\t\tq[cur].pop();\n\t\t\t}\n\t\t\tsort(all(v), cmp);\n\t\t\trep(i, v.size()){\n\t\t\t\tif(cur == 1) v[i].S++;\n\t\t\t\tif(v[i].S == c[v[i].F]) ans = nxt;\n\t\t\t\telse q[next].push(mp(v[i].F, mp(nxt + t[v[i].F], v[i].S)));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    double EPS = 1e-8;\n    double length = 1e6;\n    int n; cin >> n;\n    if(!n) break;\n    VI t(n), c(n);\n    vector<PII> p(n);\n    REP(i, n) {\n      cin >> t[i] >> c[i];\n      p[i] = {t[i], c[i]};\n    }\n    sort(ALL(p));\n\n    // i人目の人の速度\n    vector<double> v(n);\n    REP(i, n) v[i] = length/p[i].first;\n\n    // i人目の人の位置、何周目か\n    vector<pair<double,int>> place(n, {0, 0});\n    vector<pair<double,int>> nxt(n, {0, 0});\n    int i, num;\n    for(i=0, num=0; num<n; ++i) {\n      // j人目を進める\n      REP(j, n) {\n        if(place[j].second >= c[j]) continue;\n        double tmp = place[j].first + v[j];\n        REP(k, n) {\n          if(j==k) continue;\n          if(place[k].second >= p[k].second) continue;\n          if(place[j].first < EPS && place[k].first < EPS) continue;\n          if(abs(place[j].first-length) < EPS && abs(place[k].first - length) < EPS) continue;\n          // jがkを追い越す\n          if(place[j].first <= place[k].first && place[j].first+v[j] > place[k].first+v[k]) {\n            chmin(tmp, place[k].first+v[k]);\n          }\n        }\n        if(place[j].first < 2*length && 2*length <= tmp+EPS) {\n          nxt[j] = {0, place[j].second+1};\n          if(nxt[j].second >= p[j].second) num++;\n        }\n        else {\n          nxt[j] = {tmp, place[j].second};\n        }\n      }\n      place = nxt;\n      // cout << place << endl;\n    }\n\n    cout << i << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (fabs(in[i].x-MID)>eps)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (fabs(in[i].x-GOAL)>eps)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (fabs(in[i].x-in[j].x)>eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(ans >0 && mint>0);\n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2000+eps)n--;\n    }\n  }\n\n  return (int)(ans+eps);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,1000/t,1000/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <tuple>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nP p[300];\nint n;\nvoid exec()\n{\n\tcin >> n;\n\tif(n==0)exit(0);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> p[i].first >> p[i].second;\n\t}\n\tsort(p,p+n);\n\tpriority_queue<T, vector<T>, greater<T> > l0, l1;\n\tint m0=0;\n\tint m1=0;\n\tfor(int i=0;i<n;i++){\n\t\tint a=p[i].first;\n\t\tint b=p[i].second;\n\t\tl0.push(T(a,a,b));\n\t\tm0=a;\n\t}\n\twhile(l0.size()||l1.size()){\n\t\tif(l1.size()==0||(l0.size()&&l0.top()<l1.top())){\n\t\t\tT t=l0.top();\n\t\t\t//cout << \"0 \" << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << endl;\n\t\t\tl0.pop();\n\t\t\tget<0>(t)=m1=max(m1,get<0>(t)+get<1>(t));\n\t\t\tl1.push(t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tT t=l1.top();\n\t\t\t//cout << \"1 \" << get<0>(t) << \", \" << get<1>(t) << \", \" << get<2>(t) << endl;\n\t\t\tl1.pop();\n\t\t\tget<2>(t)--;\n\t\t\tif(get<2>(t)<=0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tget<0>(t)=m0=max(m0,get<0>(t)+get<1>(t));\n\t\t\tl0.push(t);\n\t\t}\n\t}\n\tcout << m1 << endl;\n}\nint main() {\n\twhile(1)exec();\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n \nsigned main() {\n    int N;\n    while(cin >> N, N) {\n        // time, lap, velocity\n        queue< tuple<int, int, int> > que[2];\n        vector< pair<int, int> > info;\n        for(int i=0; i<N; i++) {\n            int t, c; cin >> t >> c;\n            info.emplace_back(t, c);\n        }\n        sort(info.begin(), info.end());\n\n        for(auto e : info) {\n            int a, b; tie(a, b) = e;\n            que[0].emplace(0, b, a);\n        }\n\n        int ans = 0;\n        while(que[0].size() or que[1].size()) {\n            int k = (que[0].empty() or (que[1].size() and get<0>(que[1].front()) < get<0>(que[0].front())));\n\n            auto e = que[k].front();\n            ans = get<0>(e);\n            vector< tuple<int, int, int> > goal;\n            while(que[k].size() and get<0>(que[k].front()) <= ans) {\n                goal.push_back(que[k].front());\n                que[k].pop();\n            }\n\n            sort(goal.begin(), goal.end(), [](auto x, auto y) {\n                    return get<2>(x) < get<2>(y);\n                });\n\n            for(auto e : goal) {\n                if(get<1>(e)) {\n                    que[1-k].emplace(ans + get<2>(e), get<1>(e) - k, get<2>(e));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-6;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      REP(j,i+1,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else if (in[i].x > eps){\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nstruct swimmer{\n\tdouble pos;\n\t//double prepos;\n\tint t;\n\tint rest_loop;\n\tint lane;\n};\n\nswimmer ss[100];\nint order[100];\n\nbool finish(int &n){\n\tint cnt = 0;\n\trep(i, n) if(ss[i].rest_loop){\n\t\tcnt++;\n\t}\n\tif(cnt == 0) return true;\n\tn = cnt;\n\treturn false;\n}\n\nvoid move(int n){\n\t/*\n\tcout << \"************************\" << endl;\n\tcout << \"begin\" << endl;\n\trep(i, n)cout << ss[i].pos << \" \" << ss[i].rest_loop << \" \" << ss[i].lane << endl;\n\tcout << \"***********************\" << endl;\n\t*/\n\tdouble m[2] = {1.0, 1.0};\n\trep(i, n) if(ss[i].rest_loop){\n\t\t//ss[i].prepos = ss[i].pos;\n\t\tss[i].pos += 1.0 / ss[i].t;\n\t}\n\trep(i, n){\n\t\tif(ss[i].rest_loop == 0) continue;\n\t\tif(ss[i].pos > m[ss[i].lane]){\n\t\t\tss[i].pos = m[ss[i].lane];\n\t\t}else{\n\t\t\tm[ss[i].lane] = ss[i].pos;\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tif(ss[i].rest_loop == 0) continue;\n\t\tif(abs(ss[i].pos - 1.0) < EPS) {\n\t\t\tss[i].pos = 0.0;\n\t\t\tif(ss[i].lane == 0){\n\t\t\t\tss[i].lane = 1;\n\t\t\t}else{\n\t\t\t\tss[i].lane = 0;\n\t\t\t\tss[i].rest_loop--;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tcout << \"************************\" << endl;\n\tcout << \"end\" << endl;\n\trep(i, n)cout << ss[i].pos << \" \" << ss[i].rest_loop << \" \" << ss[i].lane << endl;\n\tcout << \"***********************\" << endl;\n\t*/\n}\n\nbool comp(const swimmer &s1, const swimmer &s2){\n\tif(s1.rest_loop == 0 || s2.rest_loop == 0) return s1.rest_loop > s2.rest_loop;\n\telse if(s1.lane != s2.lane) return s1.lane < s2.lane;\n\telse if(abs(s1.pos - s2.pos) < EPS){\n\t\tif(s1.pos < EPS && s2.pos < EPS) return s1.t < s2.t;\n\t\telse return s1.t > s2.t;\n\t}else{\n\t\treturn s1.pos > s2.pos;\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\trep(i, n){\n\t\t\tcin >> ss[i].t >> ss[i].rest_loop;\n\t\t\tss[i].lane = 0;\n\t\t\tss[i].pos = 0.0;\n\t\t}\n\n\n\t\tint cnt = 0;\n\t\tsort(ss, ss + n, comp);\n\t\twhile(true){\n\t\t\tif(finish(n)){\n\t\t\t\tcout << cnt << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tmove(n);\n\t\t\tsort(ss, ss + n, comp);\n\t\t\tassert(cnt < 800000);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        vector<int> A(N),B(N),need1(160000),need2(160000),side(N),s(N),cnt(N);\n        for(int i=0;i<N;i++){\n            cin>>A[i]>>B[i];\n            chmax(need1[1],A[i]);\n        }\n        \n        int t=0;\n        while(1){\n            bool ok=false;\n            for(int i=0;i<N;i++){\n                if(cnt[i]==B[i]) continue;\n                ok=true;\n                \n                if(side[i]==0){\n                    if(t>=max(s[i]+A[i],need1[s[i]])){\n                        side[i]=1;\n                        s[i]=t;\n                        chmax(need2[t+1],t+A[i]);\n                    }\n                }else{\n                    if(t>=max(s[i]+A[i],need2[s[i]])){\n                        side[i]=0;\n                        cnt[i]++;\n                        s[i]=t;\n                        if(cnt[i]!=B[i]) chmax(need1[t+1],t+A[i]);\n                    }\n                }\n            }\n            for(int i=t+2;i<=t+300;i++){\n                chmax(need1[i],need1[i-1]);\n                chmax(need2[i],need2[i-1]);\n            }\n            if(!ok) break;\n            t++;\n        }\n        cout<<t-1<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n) break;\n    vector<pair<double,int>> vp;\n    REP(i,n){\n      double t;\n      int c;\n      cin>>t>>c;\n      vp.emplace_back(t,c);\n    }\n    sort(ALL(vp));\n    vector<int> rem(n);\n    queue<pair<int, double>> q1, q2;\n    REP(i,n) {\n      double t;\n      int c;\n      tie(t,c) = vp[i];\n      q1.emplace(i, 0);\n      rem[i] = c;\n    }\n    int last_updated = 0;\n    while(!q1.empty() || !q2.empty()) {\n      bool use_q1 = q2.empty();\n      if (q1.empty()) use_q1 = false;\n      if (!q1.empty() && !q2.empty()) {\n        int i1,i2;\n        double t1,t2;\n        tie(i1,t1) = q1.front();\n        tie(i2,t2) = q2.front();\n        if (vp[i1].first + t1 <= vp[i2].first + t2) use_q1 = true;\n        else use_q1 = false;\n      }\n      if (!use_q1) {\n        int i;\n        double t;\n        tie(i,t) = q2.front();\n        double nt = t + vp[i].first;\n        vector<int> vi(1, i);\n        q2.pop();\n        while(!q2.empty()) {\n          int j;\n          double u;\n          tie(j,u) = q2.front();\n          double nu = u + vp[j].first;\n          if (nu > nt) break;\n          vi.push_back(j);\n          q2.pop();\n        }\n        sort(ALL(vi));\n        for(int i:vi) {\n          last_updated = nt;\n          --rem[i];\n          if (rem[i]) q1.emplace(i, nt);\n        }\n      } else {\n        int i;\n        double t;\n        tie(i,t) = q1.front();\n        double nt = t + vp[i].first;\n        vector<int> vi(1, i);\n        q1.pop();\n        while(!q1.empty()) {\n          int j;\n          double u;\n          tie(j,u) = q1.front();\n          double nu = u + vp[j].first;\n          if (nu > nt) break;\n          vi.push_back(j);\n          q1.pop();\n        }\n        sort(ALL(vi));\n        for(int i:vi)q2.emplace(i, nt);\n      }\n    }\n    cout << last_updated << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tint t[55],c[55];\n\t\trep(i,n) cin >> t[i] >> c[i];\n\n\t\tint ans=0;\n\t\tstruct state{\n\t\t\tint t,res,v;\n\t\t\tbool operator < (const state &arg) const {return v < arg.v;}\n\t\t};\n\n\t\tqueue<state> que[2];\n\t\trep(i,n) que[0].push({0,c[i],t[i]});\n\n\t\twhile(!que[0].empty()||!que[1].empty()){\n\t\t\tint f= que[0].empty() || (!que[1].empty() && que[1].front().t < que[0].front().t);\n\t\t\tans=que[f].front().t;\n\t\t\tvector<state> ary;\n\t\t\twhile(!que[f].empty() && que[f].front().t<=ans){\n\t\t\t\tary.push_back(que[f].front());\n\t\t\t\tque[f].pop();\n\t\t\t}\n\t\t\tsort(_all(ary));\n\t\t\tfor(auto &it:ary) if(it.res){\n\t\t\t\tit.t=ans+it.v;\n\t\t\t\tit.res-=f;\n\t\t\t\tque[f^1].push(it);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct dat{\n  int T,t,f,lap;\n  dat(){T=t=f=lap=0;}\n  vector<dat> V;\n  bool operator < (dat a)const{return T<a.T;}\n  bool operator > (dat a)const{return T>a.T;}\n};\n\nbool onFront(dat a,dat b){return a.f==b.f&&1.0*a.t/a.T < 1.0*b.t/b.T;}\nbool checkJam(dat a,dat b){return a<b&&onFront(a,b)&&(a.T-a.t)+b.t<b.T;}\n\nint merge(vector<dat>&A,int idx){\n  for(int i=0;i<(int)A.size();i++){\n    dat &a = A[idx],&b = A[i];\n    if(!checkJam(a,b))continue;\n    for(int j=0;j<(int)a.V.size();j++)b.V.push_back(a.V[j]);\n    a.V.clear();\n    a.t=0,a.lap-=a.f,a.f=!a.f;\n    if(a.lap)b.V.push_back(a);\n    A.erase(A.begin()+idx);\n    return 1;\n  }  \n  return 0;\n}\n\nint sim(vector<dat> A){\n  int res=0;\n  while(!A.empty()){\n    sort(A.begin(),A.end(),greater<dat>());\n\n    //    for(int i=0;i<A.size();i++)cout<<A[i].T<<\" \"<<A[i].t<<\" \"<<A[i].f<<\" \"<<A[i].lap<<\"size= \"<<A[i].V.size()<<endl;\n    \n\n    int mn = 1e9;\n    for(int i=(int)A.size()-1;i>=0;i--)\n      if(!merge(A,i))mn = min(mn,A[i].T-A[i].t);\n\n    //    cout<<\"mn=\"<<mn<<endl;\n    //    for(int i=0;i<A.size();i++) cout<<A[i].T<<\" \"<<A[i].t<<\" \"<<A[i].f<<\" \"<<A[i].lap<<\"size= \"<<A[i].V.size()<<endl;\n    //    cout<<\"----------------\"<<endl;    \n    \n    vector<dat>nA;\n    for(int i=0;i<(int)A.size();i++){\n      vector<dat> &V = A[i].V;\n      if(A[i].t+mn<A[i].T) A[i].t+=mn;\n      else{\n\tfor(int j=0;j<(int)V.size();j++)nA.push_back(V[j]);\n\tV.clear();\n\tA[i].t=0, A[i].lap-=A[i].f, A[i].f=!A[i].f;\n      }\n      if(A[i].lap)nA.push_back(A[i]);\n    }\n    A=nA;\n    res+=mn;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<dat> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].T>>A[i].lap;\n    cout<<sim(A)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define pb         push_back\n\nconst double MID  = 1000;\nconst double GOAL = 2000;\nconst double eps  = 1e-10;\nconst double inf  = 1e100;\n\nclass state{\npublic:\n  double x,v,oriv;\n  int cnt;\n  bool operator<(const state & a)const{\n    if (!(fabs(x-a.x)<eps))return x < a.x;\n    return v < a.v;\n  }\n};\n\ndouble compute_time(double x1,double x2,double v1,double v2){\n  if (x1 > x2)return inf;\n  if (v1-v2<eps)return inf;\n  if (fabs(v1-v2)<eps)return inf;\n  return (x2-x1)/(v1-v2);\n}\n\nint solve(int n,vector<state>& in){\n  double ans=0;\n  sort(ALL(in));\n  while(n){\n    double mint=inf;\n    rep(i,n){\n      if (in[i].x<MID)\n\tmint=min(mint,compute_time(in[i].x,MID,in[i].v,0));\n      if (in[i].x <GOAL)\n\tmint=min(mint,compute_time(in[i].x,GOAL,in[i].v,0));\n      //      REP(j,i+1,n){\n      rep(j,n){\n\tif (eps < in[j].x-in[i].x && in[i].v - in[j].v > eps)\n\t  mint=min(mint,compute_time(in[i].x,in[j].x,in[i].v,in[j].v));\n      }\n    }\n\n    ans+=mint;\n    assert(mint > 0);//passed\n    \n    rep(i,n){\n      in[i].x+=in[i].v*mint;\n    }\n\n    sort(ALL(in));\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    rep(i,n){\n      if (fabs(in[i].x-MID) < eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=MID;\n      }else if (fabs(in[i].x-GOAL)<eps){\n\tin[i].v=in[i].oriv;\n\tin[i].x=0;\n\tin[i].cnt--;\n\tif (in[i].cnt == 0)in[i].x = inf;\n      }else {\n\trep(j,n){\n\t  if (fabs(in[i].x-in[j].x)<eps)in[i].v=min(in[i].v,in[j].v);\n\t}\n      }\n    }\n\n    /*\n    rep(i,n){\n      cout <<\"tmp \" << in[i].x <<\" \" << in[i].v <<\" \" << in[i].cnt << endl;\n    }\n    cout << endl;\n    */\n\n    sort(ALL(in));\n    for(int i=n-1;i>=0;i--){\n      if (in[i].x >2500)n--;\n    }\n  }\n  \n  if (fabs((int)(ans+0.5)-ans)<eps)return (int)(ans+0.5);\n  return (int)ans;\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vector<state> in;\n    rep(i,n){\n      double t;\n      int lap;\n      cin>>t>>lap;\n      in.pb((state){0,MID/t,MID/t,lap});\n    }\n    cout << solve(n,in) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define P pair<int, C>\n#define d first\n#define c second\n\nclass C{\n  public:\n    int time, cnt, now;\n    C(){ now = 0; }\n    bool operator < (const C &c) const { return time < c.time; }\n};\n\nbool isEnd(vector<P> &v){\n  REP(i, v.size()) if(v[i].c.cnt != 0) return false;\n  return true;\n}\n\nint main() {\n  int n;\n  while(cin >>n && n){\n    vector<P> v(n);\n    REP(i, n){\n      cin >>v[i].c.time >>v[i].c.cnt;\n      v[i].d = v[i].c.time;\n    }\n    sort(v.begin(), v.end());\n\n    int ans = 0;\n    while(!isEnd(v)){\n      if(v[0].c.cnt == 0) continue;\n      ans += v[0].d;\n      FOR(i, 1, v.size()) if(v[i].c.cnt != 0) v[i].d -= v[0].d;\n      int next = (v[0].c.now + 1) % 2;\n      v[0].d = v[0].c.time;\n      FOR(i, 1, v.size()){\n        if(v[i].c.cnt == 0 || v[i].c.now != next) continue;\n        v[0].d = max(v[0].d, v[i].d);\n      }\n      v[0].c.now = next;\n      if(next == 0) v[0].c.cnt -= 1;\n      sort(v.begin(), v.end());\n    }\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<cassert>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\n\nusing namespace std;\ntypedef pair<int,int> ii;\n\nstruct P\n{\n  ii time;\n  bool dir;//0->上, 1->下\n  P(ii time=ii(inf,inf),bool dir=false):time(time),dir(dir){}\n};\n\nint ans;\nint n;\n\nvoid compute(vector<vector<P> > &record,ii person)\n{\n  int cur = 0;\n  record.push_back(vector<P>());\n\n\n  rep(i,person.second*2)\n    {\n      bool dir = i % 2;//0->上,1->下\n      int next = cur + person.first;\n\n      rep(j,record.size()-1)\n\t{\n\t  rep(k,record[j].size())\n\t    {\n\t      P p = record[j][k];\n\t      if(p.dir != dir)continue;\n\t      if(p.time.first > cur)break;\n\n\t      if(p.time.second == next || p.time.first == cur)\n\t\t{\n\t\t  break;\t\t  \n\t\t}\n\t      else if(p.time.first < next && next < p.time.second)\n\t\t{\n\t\t  next = max(p.time.second,next);\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      record[record.size()-1].push_back(P(ii(cur,next),dir));\n      cur = next;\n      ans = max(ans,next);\n    } \n}\n\nint main()\n{\n  while(scanf(\"%d\",&n),n)\n    {\n      ans = 0;\n      vector<ii> info(n);\n      rep(i,n)scanf(\"%d %d\",&info[i].first,&info[i].second);\n      sort(all(info),greater<ii>());\n\n      vector<vector<P> > record;\n\n      rep(i,n)compute(record,info[i]);\n\n      printf(\"%d\\n\",ans);\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1297: Swimming Jam\n// 2017.11.2 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 52\ntypedef struct { int t, c, a; } T;   // a: arive time\nT q[2][MAX+2]; int top[2], end[2];\nT p[MAX+2]; int sz;\n\nint cmp(T *a, T *b) { return a->t - b->t; }\n\nint main()\n{\n\tint n, i, j, k, t, a, ans;\n\n    while(scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++ ) scanf(\"%d%d\", &p[i].t, &p[i].c), p[i].a = p[i].t;\n\t\tqsort(p, n, sizeof(T), cmp);\n\t\ttop[0] = top[1] = end[0] = end[1] = 0;\n\t\tfor (i = 0; i < n; i++)\tq[0][end[0]++] = p[i];\n\n\t\tans = 0;\n\t\twhile (n > 0) {\n\t\t\tint t0, t1;\n\t\t\tt0 = t1 = 0x7fffffff;\n\t\t\tif (top[0] != end[0]) t0 = q[0][top[0]].a;\n\t\t\tif (top[1] != end[1]) t1 = q[1][top[1]].a;\n\t\t\tif (t0 <= t1) j = 0;\n\t\t\telse j = 1;\n\n\t\t\tsz = t = 0;\n\t\t\twhile (top[j] != end[j]) {\n\t\t\t\tk = top[j];\n\t\t\t\ta = q[j][k].a;\n\t\t\t\tif (t == 0) t = a;\n\t\t\t\telse if (t < a) break;\n\t\t\t\tif (j == 1) q[j][k].c--;\n\t\t\t\tif (q[j][k].c == 0) n--, ans = t;\n\t\t\t\telse p[sz] = q[j][k], p[sz].a = t + p[sz].t, sz++; \n\t\t\t\tif (++k == MAX) k = 0;\n\t\t\t\ttop[j] = k;\n\t\t\t}\n\t\t\tif (n == 0) break;\n\t\t\tqsort(p, sz, sizeof(T), cmp);\n\n\t\t\tfor (i = 0; i < sz; i++) {\n\t\t\t\tq[!j][end[!j]] = p[i]; if (++end[!j] == MAX) end[!j] = 0;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1297: Swimming Jam\n// 2017.11.2 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 52\ntypedef struct { int t, c, a; } T;   // a: arive time\nT q[2][MAX+2]; int top[2], end[2];\nT p[MAX+2]; int sz;\n\nint cmp(T *a, T *b) { return a->t - b->t; }\n\nint main()\n{\n\tint n, i, j, k, t, a, ans, t0, t1;\n\n    while(scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++ ) scanf(\"%d%d\", &p[i].t, &p[i].c), p[i].a = p[i].t;\n\t\tqsort(p, n, sizeof(T), cmp);\n\t\tfor (i = 0; i < n; i++)\tq[0][i] = p[i];\n\t\ttop[0] = top[1] = end[0] = end[1] = 0, end[0] = n;\n\n\t\tans = 0;\n\t\twhile (n > 0) {\n\t\t\tt0 = t1 = 0x7fffffff;\n\t\t\tif (top[0] != end[0]) t0 = q[0][top[0]].a;\n\t\t\tif (top[1] != end[1]) t1 = q[1][top[1]].a;\n\t\t\tif (t0 <= t1) j = 0;\n\t\t\telse j = 1;\n\n\t\t\tsz = t = 0;\n\t\t\twhile (top[j] != end[j]) {\n\t\t\t\tk = top[j];\n\t\t\t\ta = q[j][k].a;\n\t\t\t\tif (!t) t = a; else if (t < a) break;\n\t\t\t\tif (j == 1) q[j][k].c--;\n\t\t\t\tif (!q[j][k].c) n--, ans = t;\n\t\t\t\telse p[sz] = q[j][k], p[sz].a = t + p[sz].t, sz++; \n\t\t\t\tif (++k == MAX) k = 0;\n\t\t\t\ttop[j] = k;\n\t\t\t}\n\t\t\tif (n == 0) break;\n\t\t\tqsort(p, sz, sizeof(T), cmp);\n\n\t\t\tj = !j, k = end[j];\n\t\t\tfor (i = 0; i < sz; i++) {\n\t\t\t\tq[j][k] = p[i]; if (++k == MAX) k = 0;\n\t\t\t}\n\t\t\tend[j] = k;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1297: Swimming Jam\n// 2017.11.2 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 52\ntypedef struct { int t, c, a; } T;   // a: arive time\nT q[2][MAX+2]; int top[2], end[2];\nT p[MAX+2]; int sz;\n\nint cmp(T *a, T *b) { if (a->t - b->t) return a->t - b->t; return b->c - a->c; }\n\nint uniq(int n)\n{\n\tint i, j;\n\t\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && p[j].t == p[i].t) j++;\n\t\tif (j < n) if (++i != j) p[i] = p[j];\n\t}\n\treturn i+1;\n}\n\nint main()\n{\n\tint n, i, j, k, t, a, ans, t1;\n\n    while(scanf(\"%d\", &n) && n > 0) {\n\t\tfor (i = 0; i < n; i++ ) scanf(\"%d%d\", &p[i].t, &p[i].c), p[i].a = p[i].t;\n\t\tqsort(p, n, sizeof(T), cmp);\n\t\tn = uniq(n);\n\t\tif (n == 1) { printf(\"%d\\n\", (p[0].t<<1) * p[0].c); continue; }\n\t\tfor (i = 0; i < n; i++) q[0][i] = p[i];\n\t\ttop[0] = top[1] = end[0] = end[1] = 0, end[0] = n;\n\n\t\tans = 0;\n\t\twhile (n > 0) {\n\t\t\tj = 0, t = t1 = 0x7fffffff;\n\t\t\tif (top[0] != end[0]) t  = q[0][top[0]].a;\n\t\t\tif (top[1] != end[1]) t1 = q[1][top[1]].a;\n\t\t\tif (t > t1) j = 1, t = t1;\n\n\t\t\tsz = 0;\n\t\t\twhile (top[j] != end[j]) {\n\t\t\t\tk = top[j];\n\t\t\t\ta = q[j][k].a;\n\t\t\t\tif (t < a) break;\n\t\t\t\tif (j == 1) q[j][k].c--;\n\t\t\t\tif (!q[j][k].c) n--, ans = t;\n\t\t\t\telse p[sz] = q[j][k], p[sz].a = t + p[sz].t, sz++; \n\t\t\t\tif (++k == MAX) k = 0;\n\t\t\t\ttop[j] = k;\n\t\t\t}\n\t\t\tif (n == 0) break;\n\t\t\tqsort(p, sz, sizeof(T), cmp);\n\n\t\t\tj = !j, k = end[j];\n\t\t\tfor (i = 0; i < sz; i++) {\n\t\t\t\tq[j][k] = p[i]; if (++k == MAX) k = 0;\n\t\t\t}\n\t\t\tend[j] = k;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint n;\n\tint[] l, c;\n\tdouble[] v;\n\n\tdouble EPS=1e-6;\n\tint INF=1<<28;\n\n\tclass taple{\n\t\tint m=1;\n\t\tint y=1;\n\n\t\ttaple(int a, int b){\n\t\t\tm=a;\n\t\t\ty=b;\n\t\t}\n\t}\n\n\tvoid run2(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tl[i]=sc.nextInt();\n\t\t\t\tc[i]=sc.nextInt();\n\t\t\t}\n\t\t\tint[] x=new int[n];\n\t\t\tint[] lap=new int[n];\n\t\t\tboolean[] end=new boolean[n];\n\t\t\ttaple[][] couple=new taple[n][n];\n\t\t\tfor(int t=0; t<n; t++){\n\t\t\t\tlap[t]=c[t];\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tif(lap[i]>lap[j]){\n\t\t\t\t\t\tint div, mod;\n\t\t\t\t\t\tdiv=lap[i]/(lap[i]-lap[j]);\n\t\t\t\t\t\tmod=lap[i]%(lap[i]-lap[j]);\n\t\t\t\t\t\tif(mod!=0)\n\t\t\t\t\t\t\tdiv++;\n\t\t\t\t\t\tcouple[i][j]=new taple(div+1, div);\n\t\t\t\t\t\tcouple[j][i]=new taple(div, div+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tboolean b;\n\t\t\t\t//\t\t\t\t\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\tvoid run(){\n\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tR[] rs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\trs[i]=new R();\n\t\t\t\trs[i].l=sc.nextInt();\n\t\t\t\trs[i].c=sc.nextInt();\n\t\t\t\trs[i].v=1.0/rs[i].l;\n\t\t\t}\n\t\t\t// [0:2]\n\t\t\t// 0,1ツづ古ーツ環キツ嘉つ能\n\t\t\tArrays.sort(rs, new Comparator<R>(){\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(R r1, R r2){\n\t\t\t\t\treturn (int)((r2.v-r1.v)*100000);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// ツ優ツ静ヲツ度ツ渉づ可…\n\t\t\tfor(int t=1; ; t++){\n\t\t\t\tdouble first=INF;\n\t\t\t\tdouble end=rs[n-1].x;\n\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(rs[i].goal){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trs[i].x+=rs[i].v;\n\t\t\t\t\tfirst=rs[i].x=Math.min(rs[i].x, first);\n\t\t\t\t\tif(rs[i].x+EPS>2){\n\t\t\t\t\t\trs[i].c--;\n\t\t\t\t\t\trs[i].x-=2;\n\t\t\t\t\t\tend=rs[i].x=Math.min(rs[i].x, end);\n\t\t\t\t\t\trs[i].goal=rs[i].c==0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// first=rs[i].x=Math.min(rs[i].x, first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// sort\n\t\t\t\tArrays.sort(rs, new Comparator<R>(){\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(R r1, R r2){\n\t\t\t\t\t\tif((Math.abs(r1.x-0)<EPS&&Math.abs(r2.x-0)<EPS)\n\t\t\t\t\t\t\t\t||(Math.abs(r1.x-1)<EPS&&Math.abs(r2.x-1)<EPS)){\n\t\t\t\t\t\t\t// ツスツタツーツトorツ静慊づィツ陛板つオ\n\t\t\t\t\t\t\treturn (int)((r2.v-r1.v)*100000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (int)((r2.x-r1.x)*100000);\n\t\t\t\t\t}\n\t\t\t\t});\n/*\t\t\t\tprintln(\"time=\"+t);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tprintln(\"i=\"+i+\", x=\"+rs[i].x+\" ,l=\"+rs[i].l+\", c=\"+rs[i].c\n\t\t\t\t\t\t\t+\", v=\"+rs[i].v);\n\t\t\t\t}*/\n\t\t\t\tint sumC=0;\n\t\t\t\tfor(R r : rs){\n\t\t\t\t\tsumC+=r.c;\n\t\t\t\t}\n\t\t\t\tif(sumC==0){\n\t\t\t\t\tprintln(t+\"\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass R{\n\t\tint l, c;\n\t\tdouble v, x, r;\n\t\tboolean goal;\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint n;\n\tint[] l, c;\n\tdouble[] v;\n\n\tdouble EPS=1e-6;\n\tint INF=1<<28;\n\n\tclass taple{\n\t\tint m=1;\n\t\tint y=1;\n\n\t\ttaple(int a, int b){\n\t\t\tm=a;\n\t\t\ty=b;\n\t\t}\n\t}\n\n\tvoid run2(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tl[i]=sc.nextInt();\n\t\t\t\tc[i]=sc.nextInt();\n\t\t\t}\n\t\t\tint[] x=new int[n];\n\t\t\tint[] lap=new int[n];\n\t\t\tboolean[] end=new boolean[n];\n\t\t\ttaple[][] couple=new taple[n][n];\n\t\t\tfor(int t=0; t<n; t++){\n\t\t\t\tlap[t]=c[t];\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tif(lap[i]>lap[j]){\n\t\t\t\t\t\tint div, mod;\n\t\t\t\t\t\tdiv=lap[i]/(lap[i]-lap[j]);\n\t\t\t\t\t\tmod=lap[i]%(lap[i]-lap[j]);\n\t\t\t\t\t\tif(mod!=0)\n\t\t\t\t\t\t\tdiv++;\n\t\t\t\t\t\tcouple[i][j]=new taple(div+1, div);\n\t\t\t\t\t\tcouple[j][i]=new taple(div, div+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tboolean b;\n\t\t\t\t//\t\t\t\t\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\tvoid run(){\n\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tR[] rs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\trs[i]=new R();\n\t\t\t\trs[i].l=sc.nextInt();\n\t\t\t\trs[i].c=sc.nextInt();\n\t\t\t\trs[i].v=1.0/rs[i].l;\n\t\t\t}\n\t\t\t// [0:2]\n\t\t\t// 0,1ツづ古ーツ環キツ嘉つ能\n\t\t\tArrays.sort(rs, new Comparator<R>(){\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(R r1, R r2){\n\t\t\t\t\treturn (int)((r2.v-r1.v)*100000);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// ツ優ツ静ヲツ度ツ渉づ可…\n\t\t\tfor(int t=1; t<5000; t++){\n\t\t\t\tdouble first=INF;\n\t\t\t\tdouble end=rs[n-1].x;\n\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(rs[i].goal){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trs[i].x+=rs[i].v;\n\t\t\t\t\tfirst=rs[i].x=Math.min(rs[i].x, first);\n\t\t\t\t\tif(rs[i].x+EPS>2){\n\t\t\t\t\t\trs[i].c--;\n\t\t\t\t\t\trs[i].x-=2;\n\t\t\t\t\t\tend=rs[i].x=Math.min(rs[i].x, end);\n\t\t\t\t\t\trs[i].goal=rs[i].c==0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// first=rs[i].x=Math.min(rs[i].x, first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// sort\n\t\t\t\tArrays.sort(rs, new Comparator<R>(){\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(R r1, R r2){\n\t\t\t\t\t\tif((Math.abs(r1.x-0)<EPS&&Math.abs(r2.x-0)<EPS)\n\t\t\t\t\t\t\t\t||(Math.abs(r1.x-1)<EPS&&Math.abs(r2.x-1)<EPS)){\n\t\t\t\t\t\t\t// ツスツタツーツトorツ静慊づィツ陛板つオ\n\t\t\t\t\t\t\treturn (int)((r2.v-r1.v)*100000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (int)((r2.x-r1.x)*100000);\n\t\t\t\t\t}\n\t\t\t\t});\n/*\t\t\t\tprintln(\"time=\"+t);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tprintln(\"i=\"+i+\", x=\"+rs[i].x+\" ,l=\"+rs[i].l+\", c=\"+rs[i].c\n\t\t\t\t\t\t\t+\", v=\"+rs[i].v);\n\t\t\t\t}*/\n\t\t\t\tint sumC=0;\n\t\t\t\tfor(R r : rs){\n\t\t\t\t\tsumC+=r.c;\n\t\t\t\t}\n\t\t\t\tif(sumC==0){\n\t\t\t\t\tprintln(t+\"\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass R{\n\t\tint l, c;\n\t\tdouble v, x, r;\n\t\tboolean goal;\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\tArrayList<LinkedList<P>> data;\n\t\n\tclass P implements Comparable<P>{\n\t\tint time,lap, lest, nowlane;\n\t\tpublic P(int time, int lap) {\n\t\t\tthis.time = time;\n\t\t\tthis.lap = lap * 2;\n\t\t\tthis.lest = time;\n\t\t\tthis.nowlane = 0;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"P [time=\" + time + \", lap=\" + lap + \", lest=\" + lest\n\t\t\t\t\t+ \", nowlane=\" + nowlane + \"]\";\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new ArrayList<LinkedList<P>>();\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tdata.add(new LinkedList<P>());\n\t\t\t\tif(i == 0){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tint t = sc.nextInt(), l = sc.nextInt();\n\t\t\t\t\t\tdata.get(i).add(new P(t, l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCollections.sort(data.get(i));\n\t\t\t}\n\t\t\t\n\t\t\tint nowtime = 1;\n\t\t\tint count = 0;\n\t\t\tfor(nowtime = 1;; nowtime++){\n\t\t\t\t\n\t\t\t\tArrayList<ArrayList<P>> temp = new ArrayList<ArrayList<P>>();\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\ttemp.add(new ArrayList<Main.P>());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\tfor(int j =0;j <  data.get(i).size(); j++){\n\t\t\t\t\t\tdata.get(i).get(j).lest--;\n\t\t\t\t\t\tif(data.get(i).get(j).lest <= 0 && j == 0){\n\t\t\t\t\t\t\tdata.get(i).get(0).lap--;\n\t\t\t\t\t\t\tdata.get(i).get(0).nowlane ^= 1;\n\t\t\t\t\t\t\tdata.get(i).get(0).lest = data.get(i).get(0).time;\n\t\t\t\t\t\t\tP now = data.get(i).remove(0);\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\tif(now.lap == 0){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ttemp.get(i ^ 1).add(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(ArrayList<P> a: temp){\n\t\t\t\t\tCollections.sort(a);\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\tfor(int j = 0; j < temp.get(i).size(); j++){\n\t\t\t\t\t\tdata.get(i).add(temp.get(i).get(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//debug\n//\t\t\t\tSystem.out.println(\"time = \" + nowtime + \" count = \" + count);\n//\t\t\t\tfor(int i = 0; i < 2; i++){\n//\t\t\t\t\tSystem.out.println(\"i = \" + i);\n//\t\t\t\t\tSystem.out.println(data.get(i));\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//end cond\n\t\t\t\tif(count >= n){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(nowtime);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Swimming Jam\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint speed, lap, now;\n\t\tpublic R(int speed, int lap) {\n\t\t\tthis.speed = speed;\n\t\t\tthis.lap = lap;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.speed-speed;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i]=new R(sc.nextInt(), sc.nextInt()*2);\n\t\t\tArrays.sort(r);\n\t\t\tint[][] lane = new int[n][150001];\n\t\t\tint[][] begin = new int[n][501];\n\t\t\tint t = 0, res = 0;\n\t\t\tfor(int i=1;i<=r[0].lap;i++){\n\t\t\t\tbegin[0][i] = t;\n\t\t\t\tfor(int j=0;j<r[0].speed;j++){\n\t\t\t\t\tlane[0][t++] = i;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, t);\n\t\t\t}\n\t\t\t//Ú\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tt = 0;\n\t\t\t\tfor(int j=1;j<=r[i].lap;j++){\n\t\t\t\t\tbegin[i][j] = t;\n\t\t\t\t\tfor(int k=0;k<r[i].speed;k++){\n\t\t\t\t\t\tlane[i][t++] = j;\n\t\t\t\t\t}\n\t\t\t\t\tint max = t;\n\t\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t\tif(lane[k][t-1]==0)continue;\n\t\t\t\t\t\tif(j%2!=lane[k][t-1]%2)continue;\n\t\t\t\t\t\tint x = lane[k][t-1];\n\t\t\t\t\t\tif(begin[i][j]<=begin[k][x])continue;\n\t\t\t\t\t\tint pos = t;\n\t\t\t\t\t\twhile(lane[k][pos]==x)pos++;\n\t\t\t\t\t\tmax = Math.max(max, pos);\n\t\t\t\t\t}\n\t\t\t\t\twhile(t<max)lane[i][t++] = j;\n\t\t\t\t\tres = Math.max(res, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new D(), \"RUN\", STACK_SIZE).start();\n\t}\n\t\n\tclass D implements Runnable{\n\t\tD(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N;\n\t\tfinal int INF=1<<29;\n\t\t\n\t\tvoid solve(){\n\t\t\t\n\t\t\tSwimmer[] input=new Swimmer[N];\n\t\t\tfor(int i=0; i<N; ++i)\tinput[i]=new Swimmer( sc.nextInt(), sc.nextInt() );\n\t\t\tArrays.sort(input);\n\t\t\t\n\t\t\tLinkedList<Swimmer> Q1 = new LinkedList<Swimmer>(),\n\t\t\t\t\t\t\t\tQ2 = new LinkedList<Swimmer>();\n\t\t\tfor(int i=0; i<N; ++i)\tQ1.add( input[i] );\n\t\t\t\n\t\t\tint lane1=0, lane2=0;\n\t\t\t\n\t\t\tArrayList<Swimmer> tmp = new ArrayList<Swimmer>();\n\t\t\t\n\t\t\tint ans=-1;\n\t\t\tfor(int i=0; ; ++i){\n\t\t\t\t\n\t\t\t\tint lane=(i%2==0? lane1 : lane2),newLane=INF;\n\t\t\t\t\n\t\t\t\tif(Q1.getFirst().t + Q1.getFirst().now > lane){\n\t\t\t\t\t\n\t\t\t\t\t// trought\n\t\t\t\t\tfor(Swimmer s: Q1){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i%2==0 &&newLane >= s.now){\n\t\t\t\t\t\t\t--s.c;\n\t\t\t\t\t\t\tif(s.c < 0){\n\t\t\t\t\t\t\t\tans=max(ans, s.now);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(newLane >= s.now)\ts.now+=s.t;\n\t\t\t\t\t\tnewLane = s.now;\n\t\t\t\t\t\t\n\t\t\t\t\t\tQ2.add(s);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t// block\n\t\t\t\t\twhile( !Q1.isEmpty() && Q1.getFirst().t + Q1.getFirst().now <= lane ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tSwimmer s=Q1.removeFirst();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i%2 == 0){\n\t\t\t\t\t\t\t--s.c;\n\t\t\t\t\t\t\tif(s.c < 0)\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.now = lane;\n\t\t\t\t\t\ttmp.add(s);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(!Q1.isEmpty()){\n\t\t\t\t\t\tSwimmer s2 = Q1.removeLast();\n\t\t\t\t\t\t//TODO ayasii\n\t\t\t\t\t\t//s2.now-=lane;\n//\t\t\t\t\t\tif(i%2 == 0){\n//\t\t\t\t\t\t\tif( s2.t+s2.now <= lane2)\t--s2.c;\n//\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s2.c >= 0)\ttmp.add(s2);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tCollections.sort(tmp);\n\t\t\t\t\tQ2.addAll(tmp);\n\t\t\t\t\t\n\t\t\t\t\tfor(Swimmer s: Q1){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i%2==0 &&newLane >= s.now){\n\t\t\t\t\t\t\t--s.c;\n\t\t\t\t\t\t\tif(s.c < 0){\n\t\t\t\t\t\t\t\tans=max(ans, s.now);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(newLane >= s.now)\ts.now+=s.t;\n\t\t\t\t\t\tnewLane = s.now;\n\t\t\t\t\t\t\n\t\t\t\t\t\tQ2.addLast(s);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(Q2.isEmpty())\tbreak;\n\t\t\t\t\n\t\t\t\tQ1.clear();\n\t\t\t\tQ1.addAll(Q2);\n\t\t\t\tQ2.clear();\n\t\t\t\ttmp.clear();\n\t\t\t\t\n\t\t\t\tif(i%2==0)\tlane1=(newLane>=INF? lane1 : newLane);\n\t\t\t\telse\t\tlane2=(newLane>=INF? lane2 : newLane);\n\t\t\t\t\n\t\t\t\t//System.out.println(Q1+\" \"+lane1+\" \"+lane2);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t\t\n\t\tclass Swimmer implements Comparable<Swimmer>{\n\t\t\tint t,c,now;\n\t\t\tSwimmer(int t,int c){\n\t\t\t\tthis.t=t;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override public int compareTo(Swimmer s){\n\t\t\t\treturn this.t-s.t;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn t+\" \"+c+\" \"+now;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint n;\n\tint[] l, c;\n\tdouble[] v;\n\n\tdouble EPS=1e-6;\n\tint INF=1<<28;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tR[] rs=new R[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\trs[i]=new R();\n\t\t\t\trs[i].l=sc.nextInt();\n\t\t\t\trs[i].c=sc.nextInt();\n\t\t\t\trs[i].v=1.0/rs[i].l;\n\t\t\t}\n\t\t\tArrays.sort(rs, new Comparator<R>(){\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(R r1, R r2){\n\t\t\t\t\treturn (int)((r2.v-r1.v)*100000);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor(int t=1;; t++){\n\t\t\t\tdouble first=INF;\n\t\t\t\tdouble end=rs[n-1].x;\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(rs[i].goal){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trs[i].x+=rs[i].v;\n\t\t\t\t\tfirst=rs[i].x=Math.min(rs[i].x, first);\n\t\t\t\t\tif(rs[i].x+EPS>2){\n\t\t\t\t\t\trs[i].c--;\n\t\t\t\t\t\trs[i].x-=2;\n\t\t\t\t\t\tend=rs[i].x=Math.min(rs[i].x, end);\n\t\t\t\t\t\trs[i].goal=rs[i].c==0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrays.sort(rs, new Comparator<R>(){\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(R r1, R r2){\n\t\t\t\t\t\tif((Math.abs(r1.x-0)<EPS&&Math.abs(r2.x-0)<EPS)\n\t\t\t\t\t\t\t\t||(Math.abs(r1.x-1)<EPS&&Math.abs(r2.x-1)<EPS)){\n\t\t\t\t\t\t\t// ツスツタツーツトorツ静慊づィツ陛板つオ\n\t\t\t\t\t\t\treturn (int)((r2.v-r1.v)*100000);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (int)((r2.x-r1.x)*100000);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tint sumC=0;\n\t\t\t\tfor(R r : rs){\n\t\t\t\t\tsumC+=r.c;\n\t\t\t\t}\n\t\t\t\tif(sumC==0){\n\t\t\t\t\tprintln(t+\"\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tclass R{\n\t\tint l, c;\n\t\tdouble v, x, r;\n\t\tboolean goal;\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Swimming Jam\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint speed, lap, now;\n\t\tpublic R(int speed, int lap) {\n\t\t\tthis.speed = speed;\n\t\t\tthis.lap = lap;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.speed-speed;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i]=new R(sc.nextInt(), sc.nextInt()*2);\n\t\t\tArrays.sort(r);\n\t\t\tint[][] lane = new int[n][500*250];\n\t\t\tint[][] begin = new int[n][501];\n\t\t\tint t = 0, res = 0;\n\t\t\tfor(int i=1;i<=r[0].lap;i++){\n\t\t\t\tbegin[0][i] = t;\n\t\t\t\tfor(int j=0;j<r[0].speed;j++){\n\t\t\t\t\tlane[0][t++] = i;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, t);\n\t\t\t}\n\t\t\t//Ú\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tt = 0;\n\t\t\t\tfor(int j=1;j<=r[i].lap;j++){\n\t\t\t\t\tbegin[i][j] = t;\n\t\t\t\t\tfor(int k=0;k<r[i].speed;k++){\n\t\t\t\t\t\tlane[i][t++] = j;\n\t\t\t\t\t}\n\t\t\t\t\tint max = t;\n\t\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t\tif(lane[k][t-1]==0)continue;\n\t\t\t\t\t\tif(j%2!=lane[k][t-1]%2)continue;\n\t\t\t\t\t\tint x = lane[k][t-1];\n\t\t\t\t\t\tif(begin[i][j]<=begin[k][x])continue;\n\t\t\t\t\t\tint pos = t;\n\t\t\t\t\t\twhile(lane[k][pos]==x)pos++;\n\t\t\t\t\t\tmax = Math.max(max, pos);\n\t\t\t\t\t}\n\t\t\t\t\twhile(t<max)lane[i][t++] = j;\n\t\t\t\t\tres = Math.max(res, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Swimming Jam\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint speed, lap, now;\n\t\tpublic R(int speed, int lap) {\n\t\t\tthis.speed = speed;\n\t\t\tthis.lap = lap;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.speed-speed;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] lane = new int[50][150001], begin = new int[50][501];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i]=new R(sc.nextInt(), sc.nextInt()*2);\n\t\t\tArrays.sort(r);\n\t\t\tfor(int[]a:lane)Arrays.fill(a, 0);\n\t\t\tfor(int[]a:begin)Arrays.fill(a, 0);\n\t\t\tint t = 0, res = 0;\n\t\t\tfor(int i=1;i<=r[0].lap;i++){\n\t\t\t\tbegin[0][i] = t;\n\t\t\t\tfor(int j=0;j<r[0].speed;j++){\n\t\t\t\t\tlane[0][t++] = i;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, t);\n\t\t\t}\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tt = 0;\n\t\t\t\tfor(int j=1;j<=r[i].lap;j++){\n\t\t\t\t\tbegin[i][j] = t;\n\t\t\t\t\tfor(int k=0;k<r[i].speed;k++){\n\t\t\t\t\t\tlane[i][t++] = j;\n\t\t\t\t\t}\n\t\t\t\t\tint max = t;\n\t\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t\tif(lane[k][t-1]==0)continue;\n\t\t\t\t\t\tif(j%2!=lane[k][t-1]%2)continue;\n\t\t\t\t\t\tint x = lane[k][t-1];\n\t\t\t\t\t\tif(begin[i][j]<=begin[k][x])continue;\n\t\t\t\t\t\tint pos = t;\n\t\t\t\t\t\twhile(lane[k][pos]==x)pos++;\n\t\t\t\t\t\tmax = Math.max(max, pos);\n\t\t\t\t\t}\n\t\t\t\t\twhile(t<max)lane[i][t++] = j;\n\t\t\t\t\tres = Math.max(res, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\tArrayList<LinkedList<P>> data;\n\t\n\tclass P implements Comparable<P>{\n\t\tint time,lap, lest, nowlane;\n\t\tpublic P(int time, int lap) {\n\t\t\tthis.time = time;\n\t\t\tthis.lap = lap * 2;\n\t\t\tthis.lest = time;\n\t\t\tthis.nowlane = 0;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"P [time=\" + time + \", lap=\" + lap + \", lest=\" + lest\n\t\t\t\t\t+ \", nowlane=\" + nowlane + \"]\";\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn this.time - o.time;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new ArrayList<LinkedList<P>>();\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tdata.add(new LinkedList<P>());\n\t\t\t\tif(i == 0){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tint t = sc.nextInt(), l = sc.nextInt();\n\t\t\t\t\t\tdata.get(i).add(new P(t, l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint nowtime = 1;\n\t\t\tint count = 0;\n\t\t\tfor(nowtime = 1;; nowtime++){\n\t\t\t\t\n\t\t\t\tArrayList<ArrayList<P>> temp = new ArrayList<ArrayList<P>>();\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\ttemp.add(new ArrayList<Main.P>());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\tfor(int j =0;j <  data.get(i).size(); j++){\n\t\t\t\t\t\tdata.get(i).get(j).lest--;\n\t\t\t\t\t\tif(data.get(i).get(j).lest <= 0 && j == 0){\n\t\t\t\t\t\t\tdata.get(i).get(0).lap--;\n\t\t\t\t\t\t\tdata.get(i).get(0).nowlane ^= 1;\n\t\t\t\t\t\t\tdata.get(i).get(0).lest = data.get(i).get(0).time;\n\t\t\t\t\t\t\tP now = data.get(i).remove(0);\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\tif(now.lap == 0){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ttemp.get(i ^ 1).add(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(ArrayList<P> a: temp){\n\t\t\t\t\tCollections.sort(a);\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\tfor(int j = 0; j < temp.get(i).size(); j++){\n\t\t\t\t\t\tdata.get(i).add(temp.get(i).get(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//debug\n//\t\t\t\tSystem.out.println(\"time = \" + nowtime + \" count = \" + count);\n//\t\t\t\tfor(int i = 0; i < 2; i++){\n//\t\t\t\t\tSystem.out.println(\"i = \" + i);\n//\t\t\t\t\tSystem.out.println(data.get(i));\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//end cond\n\t\t\t\tif(count >= n){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(nowtime);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass S implements Comparable<S> {\n\t\tint t;\n\t\tint c;\n\t\tint time2;\n\n\t\tS(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(S tar) {\n\t\t\treturn t - tar.t;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tS[] s = new S[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\ts[i] = new S(t, c);\n\t\t\t}\n\n\t\t\tArrays.sort(s);\n\n\t\t\tint time = 0;\n\t\t\t// forward\n\t\t\tLinkedList<S> fw = new LinkedList<S>();\n\t\t\t// backward\n\t\t\tLinkedList<S> bw = new LinkedList<S>();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfw.add(s[i]);\n\t\t\t}\n\n\t\t\tint time2[] = new int[n];\n\t\t\tint ans = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (fw.isEmpty() && bw.isEmpty()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!fw.isEmpty()) {\n\t\t\t\t\t// waiting to back\n\t\t\t\t\tLinkedList<S> wfb = new LinkedList<S>();\n\n\t\t\t\t\twhile (!fw.isEmpty()&& fw.getFirst().time2 >= fw.getFirst().t) {\n\t\t\t\t\t\tS g = fw.pollFirst();\n\t\t\t\t\t\tg.time2 = 0;\n\t\t\t\t\t\twfb.addLast(g);\n\t\t\t\t\t}\n\n\t\t\t\t\tCollections.sort(wfb);\n\t\t\t\t\tbw.addAll(wfb);\n\t\t\t\t}\n\t\t\t\tif (!bw.isEmpty()) {\n\t\t\t\t\t// waiting to forward\n\t\t\t\t\tLinkedList<S> wbf = new LinkedList<S>();\n\n\t\t\t\t\twhile (!bw.isEmpty() && bw.getFirst().time2 >= bw.getFirst().t) {\n\t\t\t\t\t\tS g = bw.pollFirst();\n\t\t\t\t\t\tg.time2 = 0;\n\t\t\t\t\t\tg.c--;\n\t\t\t\t\t\tif (g.c != 0) {\n\t\t\t\t\t\t\twbf.addLast(g);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tCollections.sort(wbf);\n\t\t\t\t\tfw.addAll(wbf);\n\t\t\t\t}\n\t\t\t\tfor (S a : fw) {\n\t\t\t\t\ta.time2++;\n\t\t\t\t}\n\t\t\t\tfor (S a : bw) {\n\t\t\t\t\ta.time2++;\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans-1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] a) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T1\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tclass Swimmer implements Comparable<Swimmer> {\n\t\tint t;\n\t\tint c;\n\n\t\tSwimmer(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(Swimmer s) {\n\t\t\treturn s.t - t;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + t + \" \" + c;\n\t\t}\n\t}\n\t\n\tint MAX = 1000000;\n\tint[] A = new int[MAX];\n\tint[] B = new int[MAX];\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tSwimmer[] swimmer = new Swimmer[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tswimmer[i] = new Swimmer(in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(swimmer);\n\t\t\t\n\t\t\tArrays.fill(A, 0);\n\t\t\tArrays.fill(B, 0);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint t = swimmer[i].t;\n\t\t\t\tint c = swimmer[i].c;\n\t\t\t\tint start = 0;\n\t\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\t\tfor (int j = start + 1; j < start + t; j++) {\n\t\t\t\t\t\tA[j] = Math.max(A[j], start + t);\n\t\t\t\t\t}\n\t\t\t\t\tstart = Math.max(start + t, A[start]);\n\t\t\t\t\tSystem.out.println(\"A : \" + Arrays.toString(A) + \" \" + start);\n\t\t\t\t\tfor (int j = start + 1; j < start + t; j++) {\n\t\t\t\t\t\tB[j] = Math.max(B[j], start + t);\n\t\t\t\t\t}\n\t\t\t\t\tstart = Math.max(start + t, B[start]);\n\t\t\t\t\tSystem.out.println(\"B : \" + Arrays.toString(B) + \" \" + start);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int ans = MAX - 1; ans >= 0; ans--) {\n\t\t\t\tif (A[ans] != 0 || B[ans] != 0) {\n\t\t\t\t\tSystem.out.println(ans+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ans == 0)\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Swimming Jam\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint speed, lap, now;\n\t\tpublic R(int speed, int lap) {\n\t\t\tthis.speed = speed;\n\t\t\tthis.lap = lap;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.speed-speed;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i]=new R(sc.nextInt(), sc.nextInt()*2);\n\t\t\tArrays.sort(r);\n\t\t\tint[][] lane = new int[n][400*250];\n\t\t\tint[][] begin = new int[n][501];\n\t\t\tint t = 0, res = 0;\n\t\t\tfor(int i=1;i<=r[0].lap;i++){\n\t\t\t\tbegin[0][i] = t;\n\t\t\t\tfor(int j=0;j<r[0].speed;j++){\n\t\t\t\t\tlane[0][t++] = i;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, t);\n\t\t\t}\n\t\t\t//Ú\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tt = 0;\n//\t\t\t\tint p = 0;\n\t\t\t\tfor(int j=1;j<=r[i].lap;j++){\n\t\t\t\t\tbegin[i][j] = t;\n//\t\t\t\t\tSystem.out.println(\"Begin:\"+i+\" J:\"+j+\" at:\"+t);\n\t\t\t\t\tfor(int k=0;k<r[i].speed;k++){\n\t\t\t\t\t\tlane[i][t++] = j;\n\t\t\t\t\t}\n\t\t\t\t\tint max = t;\n\t\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t\tif(lane[k][t-1]==0)continue;\n\t\t\t\t\t\tif(j%2!=lane[k][t-1]%2)continue;\n\t\t\t\t\t\tint x = lane[k][t-1];\n\t\t\t\t\t\tif(begin[i][j]<=begin[k][x])continue;\n\t\t\t\t\t\tint pos = t;\n\t\t\t\t\t\twhile(lane[k][pos]==x)pos++;\n\t\t\t\t\t\tmax = Math.max(max, pos);\n\t\t\t\t\t}\n\t\t\t\t\twhile(t<max)lane[i][t++] = j;\n\t\t\t\t\tres = Math.max(res, t);\n//\t\t\t\t\twhile(p<i&&lane[p][t]==0)p++;\n//\t\t\t\t\tif(p==i){\n//\t\t\t\t\t\tres = Math.max(res, t);\n//\t\t\t\t\t\tcontinue;\n//\t\t\t\t\t}\n//\t\t\t\t\tif(lane[p][t-1]%2!=j%2){\n//\t\t\t\t\t\tres = Math.max(res, t);\n//\t\t\t\t\t\tcontinue;\n//\t\t\t\t\t}\n//\t\t\t\t\tif(begin[i][j]<=begin[p][lane[p][t-1]]){\n//\t\t\t\t\t\tres = Math.max(res, t);\n//\t\t\t\t\t\tcontinue;\n//\t\t\t\t\t}\n//\t\t\t\t\tint x = lane[p][t-1];\n//\t\t\t\t\twhile(lane[p][t]==x){\n//\t\t\t\t\t\tlane[i][t++] = j;\n//\t\t\t\t\t}\n//\t\t\t\t\tres = Math.max(res, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new D(), \"RUN\", STACK_SIZE).start();\n\t}\n\t\n\tclass D implements Runnable{\n\t\tD(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N;\n\t\tfinal int INF=1<<29;\n\t\t\n\t\tvoid solve(){\n\t\t\t\n\t\t\tSwimmer[] input=new Swimmer[N];\n\t\t\tfor(int i=0; i<N; ++i)\tinput[i]=new Swimmer( sc.nextInt(), sc.nextInt() );\n\t\t\tArrays.sort(input);\n\t\t\t\n\t\t\tLinkedList<Swimmer> Q1 = new LinkedList<Swimmer>(),\n\t\t\t\t\t\t\t\tQ2 = new LinkedList<Swimmer>();\n\t\t\tfor(int i=0; i<N; ++i)\tQ1.add( input[i] );\n\t\t\t\n\t\t\tint lane1=0, lane2=0;\n\t\t\t\n\t\t\tArrayList<Swimmer> tmp = new ArrayList<Swimmer>();\n\t\t\t\n\t\t\tint ans=-1;\n\t\t\tfor(int i=0; ; ++i){\n\t\t\t\t\n\t\t\t\tint lane=(i%2==0? lane1 : lane2),newLane=INF;\n\t\t\t\t\n\t\t\t\tif(Q1.getFirst().t + Q1.getFirst().now > lane){\n\t\t\t\t\t\n\t\t\t\t\t// trought\n\t\t\t\t\tfor(Swimmer s: Q1){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i%2==0){\n\t\t\t\t\t\t\t--s.c;\n\t\t\t\t\t\t\tif(s.c < 0){\n\t\t\t\t\t\t\t\tans=max(ans, s.now);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(newLane >= s.now)\ts.now+=s.t;\n\t\t\t\t\t\tnewLane = s.now;\n\t\t\t\t\t\t\n\t\t\t\t\t\tQ2.add(s);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t// block\n\t\t\t\t\twhile( !Q1.isEmpty() && Q1.getFirst().t + Q1.getFirst().now <= lane ){\n\t\t\t\t\t\t\n\t\t\t\t\t\tSwimmer s=Q1.removeFirst();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i%2 == 0){\n\t\t\t\t\t\t\t--s.c;\n\t\t\t\t\t\t\tif(s.c < 0)\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.now = lane;\n\t\t\t\t\t\ttmp.add(s);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(!Q1.isEmpty()){\n\t\t\t\t\t\tSwimmer s2 = Q1.removeLast();\n\t\t\t\t\t\t//TODO ayasii\n\t\t\t\t\t\t//s2.now-=lane;\n//\t\t\t\t\t\tif(i%2 == 0){\n//\t\t\t\t\t\t\tif( s2.t+s2.now <= lane2)\t--s2.c;\n//\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s2.c >= 0)\ttmp.add(s2);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tCollections.sort(tmp);\n\t\t\t\t\tQ2.addAll(tmp);\n\t\t\t\t\t\n\t\t\t\t\tfor(Swimmer s: Q1){\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(i%2==0){\n\t\t\t\t\t\t\t--s.c;\n\t\t\t\t\t\t\tif(s.c < 0){\n\t\t\t\t\t\t\t\tans=max(ans, s.now);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ts.now+=s.t;\n\t\t\t\t\t\tnewLane = s.now;\n\t\t\t\t\t\tQ2.addLast(s);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(Q2.isEmpty())\tbreak;\n\t\t\t\t\n\t\t\t\tQ1.clear();\n\t\t\t\tQ1.addAll(Q2);\n\t\t\t\tQ2.clear();\n\t\t\t\ttmp.clear();\n\t\t\t\t\n\t\t\t\tif(i%2==0)\tlane1=(newLane>=INF? lane1 : newLane);\n\t\t\t\telse\t\tlane2=(newLane>=INF? lane2 : newLane);\n\t\t\t\t\n\t\t\t\t//System.out.println(Q1+\" \"+lane1+\" \"+lane2);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t\t\n\t\tclass Swimmer implements Comparable<Swimmer>{\n\t\t\tint t,c,now;\n\t\t\tSwimmer(int t,int c){\n\t\t\t\tthis.t=t;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override public int compareTo(Swimmer s){\n\t\t\t\treturn this.t-s.t;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn t+\" \"+c+\" \"+now;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Swimming Jam\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint speed, lap, now;\n\t\tpublic R(int speed, int lap) {\n\t\t\tthis.speed = speed;\n\t\t\tthis.lap = lap;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn o.speed-speed;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tfor(int i=0;i<n;i++)r[i]=new R(sc.nextInt(), sc.nextInt()*2);\n\t\t\tArrays.sort(r);\n\t\t\tint[][] lane = new int[n][800*250];\n\t\t\tint[][] begin = new int[n][501];\n\t\t\tint t = 0, res = 0;\n\t\t\tfor(int i=1;i<=r[0].lap;i++){\n\t\t\t\tbegin[0][i] = t;\n\t\t\t\tfor(int j=0;j<r[0].speed;j++){\n\t\t\t\t\tlane[0][t++] = i;\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, t);\n\t\t\t}\n\t\t\t//Ú\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tt = 0;\n\t\t\t\tfor(int j=1;j<=r[i].lap;j++){\n\t\t\t\t\tbegin[i][j] = t;\n\t\t\t\t\tfor(int k=0;k<r[i].speed;k++){\n\t\t\t\t\t\tlane[i][t++] = j;\n\t\t\t\t\t}\n\t\t\t\t\tint max = t;\n\t\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\t\tif(lane[k][t-1]==0)continue;\n\t\t\t\t\t\tif(j%2!=lane[k][t-1]%2)continue;\n\t\t\t\t\t\tint x = lane[k][t-1];\n\t\t\t\t\t\tif(begin[i][j]<=begin[k][x])continue;\n\t\t\t\t\t\tint pos = t;\n\t\t\t\t\t\twhile(lane[k][pos]==x)pos++;\n\t\t\t\t\t\tmax = Math.max(max, pos);\n\t\t\t\t\t}\n\t\t\t\t\twhile(t<max)lane[i][t++] = j;\n\t\t\t\t\tres = Math.max(res, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T1\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tclass Swimmer implements Comparable<Swimmer> {\n\t\tint t;\n\t\tint c;\n\n\t\tSwimmer(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(Swimmer s) {\n\t\t\treturn s.t - t;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + t + \" \" + c;\n\t\t}\n\t}\n\t\n\tint MAX = 1000000;\n\tint[] A = new int[MAX];\n\tint[] B = new int[MAX];\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tSwimmer[] swimmer = new Swimmer[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tswimmer[i] = new Swimmer(in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(swimmer);\n\t\t\t\n\t\t\tArrays.fill(A, 0);\n\t\t\tArrays.fill(B, 0);\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint t = swimmer[i].t;\n\t\t\t\tint c = swimmer[i].c;\n\t\t\t\tint start = 0;\n\t\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\t\tfor (int j = start + 1; j < start + t; j++) {\n\t\t\t\t\t\tA[j] = Math.max(A[j], start + t);\n\t\t\t\t\t}\n\t\t\t\t\tstart = Math.max(start + t, A[start]);\n\t\t\t\t\tfor (int j = start + 1; j < start + t; j++) {\n\t\t\t\t\t\tB[j] = Math.max(B[j], start + t);\n\t\t\t\t\t}\n\t\t\t\t\tstart = Math.max(start + t, B[start]);\n\t\t\t\t}\n\t\t\t\tres = Math.max(res, start);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T1\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tclass Swimmer implements Comparable<Swimmer> {\n\t\tint t;\n\t\tint c;\n\n\t\tSwimmer(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(Swimmer s) {\n\t\t\treturn s.t - t;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + t + \" \" + c;\n\t\t}\n\t}\n\t\n\tint MAX = 1000000;\n\tint[] A = new int[MAX];\n\tint[] B = new int[MAX];\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tSwimmer[] swimmer = new Swimmer[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tswimmer[i] = new Swimmer(in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(swimmer);\n\t\t\t\n\t\t\tArrays.fill(A, 0);\n\t\t\tArrays.fill(B, 0);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint t = swimmer[i].t;\n\t\t\t\tint c = swimmer[i].c;\n\t\t\t\tint start = 0;\n\t\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\t\tfor (int j = start + 1; j < start + t; j++) {\n\t\t\t\t\t\tA[j] = Math.max(A[j], start + t);\n\t\t\t\t\t}\n\t\t\t\t\tstart = Math.max(start + t, A[start]);\n\t\t\t\t\tfor (int j = start + 1; j < start + t; j++) {\n\t\t\t\t\t\tB[j] = Math.max(B[j], start + t);\n\t\t\t\t\t}\n\t\t\t\t\tstart = Math.max(start + t, B[start]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int ans = MAX - 1; ans >= 0; ans--) {\n\t\t\t\tif (A[ans] != 0 || B[ans] != 0) {\n\t\t\t\t\tSystem.out.println(ans+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ans == 0)\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tint N;\n\tint[] ts;\n\tint[] cs;\n\n\tclass Swimmer{\n\t\tint speed, res, endLap, curLap;\n\t\tSwimmer(int s, int r, int e, int c){\n\t\t\tthis.speed = s;\n\t\t\tthis.res= r;\n\t\t\tthis.endLap= e;\n\t\t\tthis.curLap= c;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = in.nextInt();\n\t\t\tif(N==0) return ;\n\t\t\tts = new int[N];\n\t\t\tcs = new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tts[i] = in.nextInt();\n\t\t\t\tcs[i] = in.nextInt();\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint solve(){\n\t\tSwimmer[] ss = new Swimmer[N];\n\t\tfor(int i=0; i<N; i++){\n\t\t\tss[i] = new Swimmer(ts[i], ts[i], cs[i], 0);\n\t\t}\n\t\tArrays.sort(ss, new Comparator<Swimmer>(){\n\t\t\tpublic int compare(Swimmer a, Swimmer b){\n\t\t\t\treturn a.speed > b.speed?1:a.speed == b.speed?0:-1;\n\t\t\t}\n\t\t});\n\t\tArrayList<Swimmer> Q1 = new ArrayList<Swimmer>(), Q2 = new ArrayList<Swimmer>();\n\t\tfor(int i=0; i<N; i++){\n\t\t\tQ1.add(ss[i]);\n\t\t}\n\t\tint t = 0;\n\t\tfor(;;){\n\t\t\tArrayList<Swimmer> t1 = new ArrayList<Swimmer>(), t2 = new ArrayList<Swimmer>();\n\t\t\tArrayList<Swimmer> s1 = new ArrayList<Swimmer>(), s2 = new ArrayList<Swimmer>();\n\t\t\tint proc = Q1.isEmpty()?Q2.get(0).res:Q2.isEmpty()?Q1.get(0).res:Math.min(Q1.get(0).res, Q2.get(0).res);\n\t\t\tt += proc;\n\t\t\tfor(int i=0; i<Q1.size(); i++){\n\t\t\t\tQ1.get(i).res -= proc;\n\t\t\t}\n\t\t\tfor(int i=0; i<Q2.size(); i++){\n\t\t\t\tQ2.get(i).res -= proc;\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\tfor(int i=0; i<Q1.size(); i++){\n\t\t\t\tSwimmer s = Q1.get(i);\n\t\t\t\tif(s.res > 0) flag = false;\n\t\t\t\tif(flag){\n\t\t\t\t\ts.res = s.speed;\n\t\t\t\t\ts2.add(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt1.add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tflag = true;\n\t\t\tfor(int i=0; i<Q2.size(); i++){\n\t\t\t\tSwimmer s = Q2.get(i);\n\t\t\t\tif(s.res > 0) flag = false;\n\t\t\t\tif(flag){\n\t\t\t\t\tif(++s.curLap < s.endLap){\n\t\t\t\t\t\ts.res = s.speed;\n\t\t\t\t\t\ts1.add(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tt2.add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(s1, new Comparator<Swimmer>(){\n\t\t\t\tpublic int compare(Swimmer a, Swimmer b){\n\t\t\t\t\treturn a.speed > b.speed?1:a.speed == b.speed?0:-1;\n\t\t\t\t}\n\t\t\t});\n\t\t\tCollections.sort(s2, new Comparator<Swimmer>(){\n\t\t\t\tpublic int compare(Swimmer a, Swimmer b){\n\t\t\t\t\treturn a.speed > b.speed?1:a.speed == b.speed?0:-1;\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0; i<s1.size(); i++){\n\t\t\t\tt1.add(s1.get(i));\n\t\t\t}\n\t\t\tfor(int i=0; i<s2.size(); i++){\n\t\t\t\tt2.add(s2.get(i));\n\t\t\t}\n\t\t\tif(t1.isEmpty() && t2.isEmpty()) break;\n\t\t\tQ1.clear();\n\t\t\tQ2.clear();\n\t\t\tfor(int i=0; i<t1.size(); i++){\n\t\t\t\tQ1.add(t1.get(i));\n\t\t\t}\n\t\t\tfor(int i=0; i<t2.size(); i++){\n\t\t\t\tQ2.add(t2.get(i));\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T1\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tclass Swimmer implements Comparable<Swimmer> {\n\t\tint t;\n\t\tint c;\n\n\t\tSwimmer(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(Swimmer s) {\n\t\t\treturn s.t - t;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + t + \" \" + c;\n\t\t}\n\t}\n\t\n\tint MAX = 1000000;\n\tint[] A = new int[MAX];\n\tint[] B = new int[MAX];\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tSwimmer[] swimmer = new Swimmer[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tswimmer[i] = new Swimmer(in.nextInt(), in.nextInt());\n\t\t\t}\n\t\t\tArrays.sort(swimmer);\n\t\t\t\n\t\t\tArrays.fill(A, 0);\n\t\t\tArrays.fill(B, 0);\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint t = swimmer[i].t;\n\t\t\t\tint c = swimmer[i].c;\n\t\t\t\tint start = 0;\n\t\t\t\tfor (int k = 0; k < c; k++) {\n\t\t\t\t\tfor (int j = start + 1; j < start + t; j++) {\n\t\t\t\t\t\tA[j] = Math.max(A[j], start + t);\n\t\t\t\t\t}\n\t\t\t\t\tstart = Math.max(start + t, A[start]);\n\t\t\t\t\tfor (int j = start + 1; j < start + t; j++) {\n\t\t\t\t\t\tB[j] = Math.max(B[j], start + t);\n\t\t\t\t\t}\n\t\t\t\t\tstart = Math.max(start + t, B[start]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int ans = MAX - 1; ans >= 0; ans--) {\n\t\t\t\tif (A[ans] != 0 || B[ans] != 0) {\n\t\t\t\t\tSystem.out.println(ans+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'mathn'\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\ta = []\n\tb = []\n\tn.times {\n\t\tt, c = gets.split.map &:to_i\n\t\ta << [-1/t, 1, c]\n\t}\n\ta.sort!\n\tt = 0\n\t\n\tuntil a.empty? && b.empty?\n\t\tdt1 = (a.empty? ? Float::INFINITY : -a[0][1] / a[0][0])\n\t\tdt2 = (b.empty? ? Float::INFINITY : -b[0][1] / b[0][0])\n\t\tdt = (dt1 < dt2 ? dt1 : dt2)\n\t\ta[0][1] += dt * a[0][0] if !a.empty?\n\t\t(1..a.size-1).each{|i| a[i][1] = [a[i][1] + dt * a[i][0],  a[i-1][1]].max}\n\t\tb[0][1] += dt * b[0][0] if !b.empty?\n\t\t(1..b.size-1).each{|i| b[i][1] = [b[i][1] + dt * b[i][0],  b[i-1][1]].max}\n\n\t\tf = []\n\t\tf << a.shift while !a.empty? && a[0][1] == 0\n\t\tf.each{|s| s[1] = 1}\n\t\tf.sort!\n\t\tb += f\n\n\t\tf = []\n\t\twhile !b.empty? && b[0][1] == 0\n\t\t\tf << b.shift \n\t\t\tf.pop if f[-1][2] == 1\n\t\tend\n\t\tf.each{|s| s[1] = 1; s[2] -= 1}\n\t\tf.sort!\n\t\ta += f\n\t\tt += dt\n\tend\n\tp t\n}"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  swmrs = []\n  n.times do\n    ti, ci = gets.split.map(&:to_i)\n    vi = Rational(1, ti)\n    swmrs << [vi, ti, ci]\n  end\n  swmrs.sort!\n  #p swmrs\n\n  lanes = 2.times.map{[]}\n\n  for i in (0...n)\n    vi, ti, ci = swmrs[i]\n    t0 = 0\n    lanes0 = 2.times.map{[]}\n    ci.times do\n      for l in (0..1)\n        t1 = t0 + ti\n        done = false\n\n        lanes[l].each do |tc0, tc1|\n          break if tc1 <= t0\n          if tc0 < t0 && t1 < tc1\n            done = true\n            t1 = tc1\n            break\n          end\n        end\n        lanes0[l] << [t0, t1] if ! done\n        \n        t0 = t1\n      end\n    end\n\n    for l in (0..1)\n      lanes[l] = (lanes[l] + lanes0[l]).sort{|a, b| b <=> a}\n    end\n    \n  end\n  #p lanes\n\n  puts lanes.map{|l| l.first.last}.max\nend"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start)\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, 0)\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield [e.opposite[u], e.length]\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nitr = 0\nloop {\n\tbreak if (itr += 1) > 5\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tstart, goal = gets.split.map &:to_i\n\n\t$g = Graph.new\n\t$nodes = (0..n).map {|i| $g.add_node({:index => i}) }\n\t$limit = {}\n\tm.times {\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\t$g.add_edge($nodes[i], $nodes[j], {:length => d})\n\t\tif i < j\n\t\t\t$limit[[i,j]] = c\n\t\telse\n\t\t\t$limit[[j, i]] = c\n\t\tend\n\t}\n\n\tunless $g.reachable_from($nodes[start]).include?($nodes[goal])\n\t\tputs 'unreachable'\n\t\tnext\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(a)\n\t\ti, prev, speed = a\n\t\t$g.each_out_connection_of($nodes[i]){|v, d|\n\t\t\tj = v.property[:index]\n\t\t\tnext if j == prev\n\t\t\t[speed-1, speed, speed+1].each{|next_speed|\n\t\t\t\tnext if next_speed <= 0\n\t\t\t\t\t\n\t\t\t\tyield [[j, i, next_speed], d / next_speed.to_f] if next_speed <= $limit[(i < j ? [i, j] : [j, i])]\n\t\t\t}\n\t\t}\n\tend\n\n\tt = dijkstra([start, nil, 0]){|a, key|\n\t\ti, prev, speed = a\n\t\ti == goal && speed == 1\n\t}\n\n\tprintf(\"%.7f\\n\", t);\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef lower_bound(arr, key, i0 = 0, i1 = arr.length)\n  lb = i0 - 1\n  ub = i1\n\n  while lb + 1 < ub\n    m = (lb + ub) / 2\n    if arr[m] >= key\n      ub = m\n    else\n      lb = m\n    end\n  end\n  ub\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  swmrs = []\n  n.times do\n    ti, ci = gets.split.map(&:to_i)\n    swmrs << [ti, ci]\n  end\n  swmrs.sort!{|a, b| b <=> a}\n  #p swmrs\n\n  t0s = 2.times.map{[]}\n  t0tot1s = 2.times.map{{}}\n  t0used = 2.times.map{[]}\n  max_t = 0\n  \n  for i in (0...n)\n    ti, ci = swmrs[i]\n    t0 = 0\n    t0s0 = 2.times.map{[]}\n    for j in (0...ci)\n      for l in (0..1)\n        t1 = t0 + ti\n\n        k = lower_bound(t0s[l], t0) - 1\n        #p ['  lower_bound-1', t0, k]\n          \n        if k < 0\n          if t0used[l][t0].nil?\n            t0s0[l] << t0\n            t0tot1s[l][t0] = t1\n            t0used[l][t0] = true\n          end\n        else\n          t1k = t0tot1s[l][t0s[l][k]]\n          if t1 < t1k\n            t1 = t1k\n          elsif t0used[l][t0].nil?\n            t0s0[l] << t0\n            t0tot1s[l][t0] = t1\n            t0used[l][t0] = true\n          end\n        end\n        #p [i, j, l, t0, t1]\n        \n        t0 = t1\n      end\n    end\n    \n    for l in (0..1)\n      t0s[l] = (t0s[l] + t0s0[l]).sort\n    end\n    #p (0..1).map{|l| t0s[l].map{|tt0| [tt0, t0tot1s[l][tt0]]}}\n\n    max_t = t0 if max_t < t0\n  end\n  \n  puts max_t\nend"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start)\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, 0)\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield [e.opposite[u], e.length]\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\tstart, goal = gets.split.map &:to_i\n\n\t$g = Graph.new\n\t$nodes = (0..n).map {|i| $g.add_node({:index => i}) }\n\t$limit = {}\n\tm.times {\n\t\ti, j, d, c = gets.split.map &:to_i\n\t\t$g.add_edge($nodes[i], $nodes[j], {:length => d})\n\t\tif i < j\n\t\t\t$limit[[i,j]] = c\n\t\telse\n\t\t\t$limit[[j, i]] = c\n\t\tend\n\t}\n\n\tunless $g.reachable_from($nodes[start]).include?($nodes[goal])\n\t\tputs 'unreachable'\n\t\tnext\n\tend\n\n\textend Graphical\n\tdef each_out_connection_of(a)\n\t\ti, prev, speed = a\n\t\t$g.each_out_connection_of($nodes[i]){|v, d|\n\t\t\tj = v.property[:index]\n\t\t\tnext if j == prev\n\t\t\t[speed-1, speed, speed+1].each{|next_speed|\n\t\t\t\tnext if next_speed <= 0\n\t\t\t\t\t\n\t\t\t\tyield [[j, i, next_speed], d / next_speed.to_f] if next_speed <= $limit[(i < j ? [i, j] : [j, i])]\n\t\t\t}\n\t\t}\n\tend\n\n\tt = dijkstra([start, nil, 0]){|a, key|\n\t\ti, prev, speed = a\n\t\ti == goal && speed == 1\n\t}\n\n\tprintf(\"%.7f\\n\", t);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N;\n    int[] T, C;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        T = new int[N];\n        C = new int[N];\n        foreach (i; 0 .. N) {\n            scanf(\"%d %d\\n\", &T[i], &C[i]);\n        }\n        return true;\n    }\n    struct Swimmer {\n        int time;\n        int C;\n    }\n    struct S {\n        int time;\n        int which;\n        Swimmer s;\n    }\n    void solve() {\n        BinaryHeap!(Array!S, (x, y) => (x.time == y.time ? x.s.time > y.s.time : x.time > y.time)) PQ;\n        foreach (i; 0 .. N) {\n            PQ.insert(S(0, 0, Swimmer(T[i], C[i])));\n        }\n        int time0, time1;\n        while (!PQ.empty) {\n            S event = PQ.front; PQ.removeFront;\n            //writeln(event);\n            if (event.which == 0) {\n                int ntime = max(time0, event.time + event.s.time);\n                time0 = ntime;\n                PQ.insert(S(ntime, 1, event.s));\n            } else {\n                int ntime = max(time1, event.time + event.s.time);\n                time1 = ntime;\n                event.s.C--;\n                if (event.s.C == 0) continue;\n                PQ.insert(S(ntime, 0, event.s));\n            }\n        }\n        writeln(time1);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = [LI() for _ in range(n)]\n        q = []\n        d = [0] * 2\n        for t,c in a:\n            heapq.heappush(q, (0,0,t,c*2))\n\n        while q:\n            ct, l, t, c = heapq.heappop(q)\n            nx = l ^ 1\n            nt = ct + t\n            if d[nx] > nt:\n                nt = d[nx]\n            else:\n                d[nx] = nt\n            if c > 1:\n                heapq.heappush(q, (nt,nx,t,c-1))\n\n        return max(d)\n\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile 1:\n    N = int(input())\n    if N == 0:\n        break\n\n    T = [0]*N; C = [0]*N\n    que0 = deque()\n    que1 = deque()\n    P = [list(map(int, input().split())) for i in range(N)]\n    P.sort()\n    for i in range(N):\n        t, c = P[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n\n    INF = 10**18\n    ans = 0\n    rest = N\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []; st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t+T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t+T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    print(ans)\n\n"
  }
]