[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int pace;\n    int laps;\n    int position; // 0 or 1 representing the ends\n    int time;\n} Swimmer;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint simulate(Swimmer* swimmers, int n) {\n    int time = 0;\n    int lane[2] = {0}; // Current swimmers in each lane (0 or 1)\n    int next_available_time[2] = {0}; // Next available time for each lane end\n\n    while (1) {\n        int all_done = 1;\n        for (int i = 0; i < n; i++) {\n            if (swimmers[i].laps > 0) {\n                all_done = 0;\n                break;\n            }\n        }\n        if (all_done) break;\n\n        // Find the next event time\n        int next_event_time = -1;\n        for (int i = 0; i < n; i++) {\n            if (swimmers[i].laps > 0) {\n                if (next_event_time == -1 || swimmers[i].time < next_event_time) {\n                    next_event_time = swimmers[i].time;\n                }\n            }\n        }\n\n        time = next_event_time;\n\n        // Process all swimmers that reach the end at this time\n        for (int i = 0; i < n; i++) {\n            if (swimmers[i].time == time && swimmers[i].laps > 0) {\n                int current_end = swimmers[i].position;\n                lane[current_end]--;\n\n                swimmers[i].laps--;\n                if (swimmers[i].laps > 0) {\n                    swimmers[i].position = 1 - current_end;\n                    swimmers[i].time = time + swimmers[i].pace;\n                    lane[swimmers[i].position]++;\n                }\n            }\n        }\n\n        // Check for overtaking at the ends\n        for (int end = 0; end < 2; end++) {\n            if (lane[end] > 1) {\n                // Sort swimmers at this end by pace (ascending)\n                for (int i = 0; i < n; i++) {\n                    for (int j = i + 1; j < n; j++) {\n                        if (swimmers[i].position == end && swimmers[j].position == end && swimmers[i].laps > 0 && swimmers[j].laps > 0) {\n                            if (swimmers[i].pace > swimmers[j].pace) {\n                                Swimmer temp = swimmers[i];\n                                swimmers[i] = swimmers[j];\n                                swimmers[j] = temp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return time;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Swimmer* swimmers = malloc(n * sizeof(Swimmer));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &swimmers[i].pace, &swimmers[i].laps);\n        swimmers[i].position = 0;\n        swimmers[i].time = swimmers[i].pace;\n    }\n\n    int total_time = simulate(swimmers, n);\n    printf(\"%d\\n\", total_time);\n\n    free(swimmers);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:48:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Swimmer {\n    int id;\n    int pace;\n    int laps;\n    int position; // 0: left end, 1: right end\n    int time;\n    bool operator<(const Swimmer& other) const {\n        if (time != other.time) return time > other.time;\n        return position < other.position;\n    }\n};\n\nint calculateTotalTime(vector<pair<int, int>>& swimmers_data) {\n    priority_queue<Swimmer> event_queue;\n    int time = 0;\n    \n    for (int i = 0; i < swimmers_data.size(); ++i) {\n        Swimmer s;\n        s.id = i;\n        s.pace = swimmers_data[i].first;\n        s.laps = swimmers_data[i].second;\n        s.position = 0;\n        s.time = 0;\n        event_queue.push(s);\n    }\n    \n    vector<Swimmer> lane_a;\n    vector<Swimmer> lane_b;\n    \n    while (!event_queue.empty()) {\n        Swimmer current = event_queue.top();\n        event_queue.pop();\n        \n        time = current.time;\n        \n        if (current.laps <= 0) continue;\n        \n        vector<Swimmer>& current_lane = (current.position == 0) ? lane_a : lane_b;\n        vector<Swimmer>& opposite_lane = (current.position == 0) ? lane_b : lane_a;\n        \n        bool can_pass = true;\n        for (auto& s : current_lane) {\n            if (s.time <= time && s.pace < current.pace) {\n                can_pass = false;\n                break;\n            }\n        }\n        \n        if (can_pass) {\n            current.laps--;\n            if (current.laps == 0) continue;\n            current.position ^= 1;\n            current.time += current.pace;\n            opposite_lane.push_back(current);\n            event_queue.push(current);\n        } else {\n            current.time = current_lane.back().time + current_lane.back().pace;\n            event_queue.push(current);\n        }\n    }\n    \n    return time;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int>> swimmers(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> swimmers[i].first >> swimmers[i].second;\n    }\n    cout << calculateTotalTime(swimmers) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Swimmer {\n    int id;\n    int pace;\n    int laps;\n    int position; // 0 for start end, 1 for far end\n    int distance; // distance covered in current direction\n\n    Swimmer(int id, int pace, int laps) {\n        this.id = id;\n        this.pace = pace;\n        this.laps = laps;\n        this.position = 0;\n        this.distance = 0;\n    }\n}\n\npublic class SwimmingPool {\n    public static int calculateTotalTime(int[] paces, int[] laps) {\n        List<Swimmer> swimmers = new ArrayList<>();\n        for (int i = 0; i < paces.length; i++) {\n            swimmers.add(new Swimmer(i, paces[i], laps[i]));\n        }\n\n        int time = 0;\n        while (true) {\n            boolean allDone = true;\n            for (Swimmer s : swimmers) {\n                if (s.laps > 0) {\n                    allDone = false;\n                    break;\n                }\n            }\n            if (allDone) break;\n\n            // Find the next event time\n            int nextEvent = Integer.MAX_VALUE;\n            for (Swimmer s : swimmers) {\n                if (s.laps > 0) {\n                    int timeToNextEnd = s.pace - s.distance;\n                    if (timeToNextEnd < nextEvent) {\n                        nextEvent = timeToNextEnd;\n                    }\n                }\n            }\n\n            time += nextEvent;\n\n            // Update distances and handle arrivals\n            for (Swimmer s : swimmers) {\n                if (s.laps > 0) {\n                    s.distance += nextEvent;\n                    if (s.distance == s.pace) {\n                        s.position = 1 - s.position;\n                        s.distance = 0;\n                        s.laps--;\n                    }\n                }\n            }\n\n            // Reorder swimmers at the ends if necessary\n            // Start end (position 0)\n            List<Swimmer> startEnd = new ArrayList<>();\n            List<Swimmer> farEnd = new ArrayList<>();\n            for (Swimmer s : swimmers) {\n                if (s.laps > 0) {\n                    if (s.position == 0) {\n                        startEnd.add(s);\n                    } else {\n                        farEnd.add(s);\n                    }\n                }\n            }\n\n            // Sort by pace (ascending for start end, descending for far end)\n            Collections.sort(startEnd, (a, b) -> a.pace - b.pace);\n            Collections.sort(farEnd, (a, b) -> b.pace - a.pace);\n\n            // Reassign swimmers to lanes (assuming two lanes)\n            for (int i = 0; i < startEnd.size(); i++) {\n                if (i >= 2) {\n                    // Swimmers beyond the first two must wait\n                    startEnd.get(i).distance = 0;\n                }\n            }\n            for (int i = 0; i < farEnd.size(); i++) {\n                if (i >= 2) {\n                    farEnd.get(i).distance = 0;\n                }\n            }\n        }\n\n        return time;\n    }\n\n    public static void main(String[] args) {\n        int[] paces = {5, 10};\n        int[] laps = {2, 1};\n        System.out.println(calculateTotalTime(paces, laps));\n    }\n}",
    "timestamp": "2025-08-05 20:49:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Swimmer {\n    int id;\n    int pace;\n    int laps;\n    \n    Swimmer(int id, int pace, int laps) {\n        this.id = id;\n        this.pace = pace;\n        this.laps = laps;\n    }\n}\n\npublic class SwimmingPoolSimulation {\n    public static double calculateTotalTime(List<Swimmer> swimmers) {\n        PriorityQueue<Swimmer> pq = new PriorityQueue<>((a, b) -> a.pace - b.pace);\n        pq.addAll(swimmers);\n        \n        double totalTime = 0;\n        \n        while (!pq.isEmpty()) {\n            Swimmer current = pq.poll();\n            \n            if (current.laps > 0) {\n                totalTime += current.pace;\n                current.laps--;\n                \n                if (current.laps > 0) {\n                    pq.offer(current);\n                }\n            }\n        }\n        \n        return totalTime;\n    }\n    \n    public static void main(String[] args) {\n        List<Swimmer> swimmers = Arrays.asList(\n            new Swimmer(1, 2, 3),\n            new Swimmer(2, 1, 4),\n            new Swimmer(3, 3, 2)\n        );\n        \n        double totalTime = calculateTotalTime(swimmers);\n        System.out.printf(\"Total time: %.2f\\n\", totalTime);\n    }\n}",
    "timestamp": "2025-08-05 20:49:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int pace;\n    int total_laps;\n    int current_lap;\n    double current_time;\n} Swimmer;\n\nint compare_swimmers(const void* a, const void* b) {\n    Swimmer* swimmer1 = (Swimmer*)a;\n    Swimmer* swimmer2 = (Swimmer*)b;\n    return swimmer1->pace - swimmer2->pace;\n}\n\ndouble calculate_swimming_time(Swimmer* swimmers, int num_swimmers) {\n    qsort(swimmers, num_swimmers, sizeof(Swimmer), compare_swimmers);\n    \n    double max_time = 0;\n    for (int i = 0; i < num_swimmers; i++) {\n        swimmers[i].current_time = (swimmers[i].total_laps * 2.0 * swimmers[i].pace);\n        max_time = (swimmers[i].current_time > max_time) ? swimmers[i].current_time : max_time;\n    }\n    \n    return max_time;\n}\n\nint main() {\n    int num_swimmers;\n    scanf(\"%d\", &num_swimmers);\n    \n    Swimmer* swimmers = malloc(num_swimmers * sizeof(Swimmer));\n    \n    for (int i = 0; i < num_swimmers; i++) {\n        scanf(\"%d %d %d\", &swimmers[i].id, &swimmers[i].pace, &swimmers[i].total_laps);\n        swimmers[i].current_lap = 0;\n        swimmers[i].current_time = 0;\n    }\n    \n    double total_time = calculate_swimming_time(swimmers, num_swimmers);\n    \n    printf(\"%.2f\\n\", total_time);\n    \n    free(swimmers);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nclass Swimmer {\npublic:\n    int id;\n    double pace;\n    int laps;\n    double totalTime;\n\n    Swimmer(int i, double p, int l) : id(i), pace(p), laps(l), totalTime(0.0) {}\n};\n\ndouble calculateTotalTime(std::vector<Swimmer>& swimmers, double poolLength) {\n    std::sort(swimmers.begin(), swimmers.end(), \n        [](const Swimmer& a, const Swimmer& b) { return a.pace < b.pace; });\n\n    double currentTime = 0.0;\n    while (!swimmers.empty()) {\n        Swimmer& frontSwimmer = swimmers.front();\n        double lapTime = frontSwimmer.pace * 2;\n        currentTime += lapTime;\n        frontSwimmer.laps--;\n        frontSwimmer.totalTime += lapTime;\n\n        if (frontSwimmer.laps == 0) {\n            swimmers.erase(swimmers.begin());\n        } else {\n            std::rotate(swimmers.begin(), swimmers.begin() + 1, swimmers.end());\n        }\n    }\n\n    return currentTime;\n}\n\nint main() {\n    int n;\n    double poolLength;\n    std::cin >> n >> poolLength;\n\n    std::vector<Swimmer> swimmers;\n    for (int i = 0; i < n; ++i) {\n        int id, laps;\n        double pace;\n        std::cin >> id >> pace >> laps;\n        swimmers.emplace_back(id, pace, laps);\n    }\n\n    double totalTime = calculateTotalTime(swimmers, poolLength);\n    std::cout << std::fixed << std::setprecision(2) << totalTime << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Swimmer:\n    def __init__(self, id, pace, laps):\n        self.id = id\n        self.pace = pace\n        self.remaining_laps = laps\n\ndef calculate_swimming_time(swimmers):\n    time = 0\n    while any(swimmer.remaining_laps > 0 for swimmer in swimmers):\n        swimmers.sort(key=lambda s: (s.remaining_laps > 0, s.pace))\n        next_swimmers = [swimmer for swimmer in swimmers if swimmer.remaining_laps > 0]\n        \n        if not next_swimmers:\n            break\n        \n        slowest_pace = next_swimmers[0].pace\n        time += slowest_pace\n        \n        for swimmer in next_swimmers:\n            swimmer.remaining_laps -= 1\n            \n    return time\n\n# Example usage:\nswimmers_data = [\n    (1, 3, 5),\n    (2, 2, 4),\n    (3, 1, 6)\n]\n\nswimmers = [Swimmer(id, pace, laps) for id, pace, laps in swimmers_data]\ntotal_time = calculate_swimming_time(swimmers)\nprint(total_time)  # Output: the total time to complete the laps",
    "timestamp": "2025-08-13 03:37:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SwimmingCompetition {\n\n    static class Swimmer {\n        int pace; // pace in seconds per lap\n        int laps; // planned number of laps\n        int remainingLaps;\n\n        Swimmer(int pace, int laps) {\n            this.pace = pace;\n            this.laps = laps;\n            this.remainingLaps = laps;\n        }\n    }\n    \n    public static int calculateTotalTime(List<Swimmer> swimmers) {\n        int currentTime = 0;\n        Map<Swimmer, Integer> swimmerTimes = new HashMap<>();\n        \n        for (Swimmer s : swimmers) {\n            swimmerTimes.put(s, 0);\n        }\n        \n        while (true) {\n            List<Swimmer> lane = new ArrayList<>(swimmers);\n            Collections.sort(lane, Comparator.comparingInt(s -> s.pace));\n            \n            boolean allFinished = true;\n            for (Swimmer swimmer : lane) {\n                if (swimmer.remainingLaps > 0) {\n                    allFinished = false;\n                    swimmerTimes.put(swimmer, swimmerTimes.get(swimmer) + swimmer.pace);\n                    swimmer.remainingLaps -= 1;\n                    break; // Only one swimmer can start their lap in one unit of time\n                }\n            }\n            if (allFinished) {\n                break;\n            }\n            currentTime++;\n        }\n        \n        return currentTime;\n    }\n\n    public static void main(String[] args) {\n        List<Swimmer> swimmers = new ArrayList<>();\n        swimmers.add(new Swimmer(4, 3));\n        swimmers.add(new Swimmer(5, 2));\n        swimmers.add(new Swimmer(6, 1));\n\n        System.out.println(\"Total time for all swimmers to complete laps: \" + calculateTotalTime(swimmers));\n    }\n}",
    "timestamp": "2025-08-13 03:37:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int pace;  // time in seconds to swim one length\n    int laps;  // total number of laps to swim\n} Swimmer;\n\nint compare(const void *a, const void *b) {\n    Swimmer *swimmerA = (Swimmer *)a;\n    Swimmer *swimmerB = (Swimmer *)b;\n    return swimmerA->pace - swimmerB->pace; // ascends by pace\n}\n\nint calculateTotalTime(Swimmer swimmers[], int numSwimmers) {\n    qsort(swimmers, numSwimmers, sizeof(Swimmer), compare);\n    \n    int totalTime = 0;\n    for (int lap = 0; lap < swimmers[0].laps; lap++) {\n        for (int i = 0; i < numSwimmers; i++) {\n            totalTime += swimmers[i].pace;\n        }\n    }\n    \n    return totalTime;\n}\n\nint main() {\n    int numSwimmers;\n    printf(\"Enter number of swimmers: \");\n    scanf(\"%d\", &numSwimmers);\n    \n    Swimmer swimmers[numSwimmers];\n    for (int i = 0; i < numSwimmers; i++) {\n        printf(\"Enter pace and laps for swimmer %d: \", i + 1);\n        scanf(\"%d %d\", &swimmers[i].pace, &swimmers[i].laps);\n    }\n    \n    int totalTime = calculateTotalTime(swimmers, numSwimmers);\n    printf(\"Total time for all swimmers to finish: %d seconds\\n\", totalTime);\n    return 0;\n}",
    "timestamp": "2025-08-13 03:37:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def swimming_race(swimmers):\n    # Sort swimmers by pace (slower first)\n    swimmers.sort(key=lambda x: x['pace'])\n    \n    total_laps = swimmers[0]['laps']\n    lane_length = 1\n    \n    # Track each swimmer's current position and time\n    positions = [0] * len(swimmers)\n    times = [0] * len(swimmers)\n    completed = [False] * len(swimmers)\n    \n    current_time = 0\n    \n    while not all(completed):\n        # Move slowest swimmers first\n        for i in range(len(swimmers)):\n            if not completed[i]:\n                # Calculate time to next end\n                distance_to_end = lane_length - positions[i]\n                time_to_end = distance_to_end / swimmers[i]['pace']\n                \n                # Update swimmer's position and time\n                current_time += time_to_end\n                positions[i] = lane_length\n                times[i] = current_time\n                \n                # Check if swimmer completed laps\n                if sum(1 for p in positions if p == lane_length) == len(swimmers):\n                    swimmers[i]['current_lap'] += 1\n                    positions = [0] * len(swimmers)\n                    \n                    # Reset lane if all haven't finished\n                    if swimmers[i]['current_lap'] == total_laps:\n                        completed[i] = True\n    \n    return max(times)",
    "timestamp": "2025-08-13 03:37:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_total_time(swimmers):\n    if not swimmers:\n        return 0\n    \n    # Each swimmer is represented as (pace, laps)\n    # We'll track their current position and direction\n    # Initialize each swimmer: (position, direction, remaining_laps, pace)\n    # position: 0 (start end), 1 (other end)\n    # direction: 1 (moving to other end), -1 (moving back to start)\n    swimmers_state = []\n    for pace, laps in swimmers:\n        swimmers_state.append({\n            'position': 0,\n            'direction': 1,\n            'remaining_laps': laps,\n            'pace': pace\n        })\n    \n    current_time = 0\n    active_swimmers = [s for s in swimmers_state if s['remaining_laps'] > 0]\n    \n    while active_swimmers:\n        # Find the next event time (when any swimmer reaches the end)\n        next_event_time = min(\n            s['pace'] for s in active_swimmers\n        )\n        current_time += next_event_time\n        \n        # Update positions and directions for all active swimmers\n        for s in active_swimmers:\n            s['pace'] -= next_event_time\n            if s['pace'] == 0:\n                s['position'] += s['direction']\n                if s['position'] in (0, 1):\n                    s['remaining_laps'] -= 1\n                    if s['remaining_laps'] == 0:\n                        continue\n                    # Change direction\n                    s['direction'] *= -1\n                    s['pace'] = abs(s['pace'])  # Reset pace for next segment\n                else:\n                    # Should not happen as they reach ends\n                    pass\n        \n        # Rebuild active_swimmers list\n        active_swimmers = [s for s in swimmers_state if s['remaining_laps'] > 0]\n        \n        # At the ends, swimmers can reorder based on their paces\n        # Group swimmers by their current position (0 or 1)\n        from collections import defaultdict\n        position_groups = defaultdict(list)\n        for s in active_swimmers:\n            position_groups[s['position']].append(s)\n        \n        # For each position group, sort by pace (ascending, faster swimmers first)\n        for position, group in position_groups.items():\n            group.sort(key=lambda x: x['pace'])\n            # Reassign directions if needed (but direction is already correct)\n    \n    return current_time",
    "timestamp": "2025-08-13 03:37:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Swimmer {\n    int pace; // time to swim one length of the pool\n    int laps; // total laps to complete\n};\n\nint calculateTotalTime(std::vector<Swimmer> swimmers, int lane_count) {\n    // Sort swimmers by pace, slower swimmers go first\n    std::sort(swimmers.begin(), swimmers.end(), [](const Swimmer &a, const Swimmer &b) {\n        return a.pace < b.pace;\n    });\n\n    int currentTime = 0;\n    std::vector<int> laneTime(lane_count, 0); // Tracks the time for each lane\n\n    for (Swimmer &swimmer : swimmers) {\n        // Assign swimmer to the lane that will get free the earliest\n        int minLaneTime = laneTime[0];\n        int chosenLane = 0;\n        \n        for (int lane = 1; lane < lane_count; ++lane) {\n            if (laneTime[lane] < minLaneTime) {\n                minLaneTime = laneTime[lane];\n                chosenLane = lane;\n            }\n        }\n        \n        currentTime = std::max(currentTime, minLaneTime);\n        currentTime += swimmer.pace * swimmer.laps;\n        laneTime[chosenLane] = currentTime;\n    }\n\n    // Return the maximum time across all lanes\n    return *std::max_element(laneTime.begin(), laneTime.end());\n}\n\nint main() {\n    int n; // Number of swimmers\n    int lane_count = 2;\n    std::cin >> n;\n\n    std::vector<Swimmer> swimmers(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> swimmers[i].pace >> swimmers[i].laps;\n    }\n\n    int totalTime = calculateTotalTime(swimmers, lane_count);\n    std::cout << totalTime << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:13:54"
  }
]