[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\n// const int INF = 0x3f3f3f3f3f3f3f3f;\n// const double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* 基本要素 */\n\nusing D = double; // 座標値の型 doubleかlong double\nusing P = complex<D>; // Point\nusing L = pair<P,P>;  // Line\nusing VP = vector<P>;\nconst D EPS = 1e-8;  // 許容誤差\nconst D INF = 1e12;\n#define X real()\n#define Y imag()\n#define LT(n,m) ((n)+EPS<(m)) // n < m ?\n#define LE(n,m) ((n)-EPS<(m)) // n <= m ?\n#define GT(n,m) LT(m,n) // n > m ?\n#define GE(n,m) LE(m,n) // n >= m ?\n#define EQ(n,m) (abs((n)-(m))<EPS)\n#define NE(n,m) !EQ(n,m)\n#define rep(i,n) for (int i=0;i<(n);++i)\n\nnamespace std {\n  istream& operator >> (istream& is, P& p) {\n    int F, S;\n    is >> F >> S;\n    p = P(F,S);\n    return is;\n  }\n  bool operator < (const P a, const P b) {\n    return NE(a.X,b.X) ? LT(a.X,b.X) : LT(a.Y,b.Y);\n  }\n  bool operator > (const P a, const P b) {\n    return NE(a.X,b.X) ? GT(a.X,b.X) : GT(a.Y,b.Y);\n  }\n  bool sort_y(const P a, const P b) {\n    return LT(a.Y,b.Y);\n  }\n  void swap(P& a, P& b) {\n    P c = a; a = b; b = c;\n  }\n}\n\n// 内積\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n// 点aから見た、点bから点cへの方向\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (GT(cross(b,c),0)) return +1;  // counter clockwise\n  if (LT(cross(b,c),0)) return -1;  // clockwise\n  if (LT(dot(b,c),0)) return +2;  // c--a--b on line\n  if (LT(norm(b),norm(c))) return -2; // a--b--c on line or a==b\n  return 0;                     // a--c--b on line or a==c or b==c\n}\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 && ccw(b1,b2,a1)*ccw(b1,b2,a2) <= 0;\n}\n\nD calc(VP ps, P s, P g, P a, P b) {\n  D res = abs(a-b);\n  vector<D> dis(ps.size(),INF);\n  dis[0] = 0;\n  using PP = pair<D,int>;\n  priority_queue<PP,vector<PP>,greater<PP>> que;\n  que.emplace(0,0);\n  while (!que.empty()) {\n    D dd;\n    int v;\n    tie(dd,v) = que.top(); que.pop();\n    if (dis[v] < dd) continue;\n    for (int i = 0; i < ps.size(); i++) {\n      if (i == v) continue;\n      if (isecSS(ps[v],ps[i],a,b)) continue;\n      if (GT(dis[i],dis[v]+abs(ps[v]-ps[i]))) {\n        dis[i] = dis[v]+abs(ps[v]-ps[i]);\n        que.emplace(dis[i],i);\n      }\n    }\n  }\n  res += dis[1];\n  return res;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int N,M;\n  cin >> N >> M;\n  VP A(N), B(M);\n  REP(i,N) cin >> A[i];\n  REP(i,M) cin >> B[i];\n  D ans = min(calc(B,B[0],B[1],A[0],A[1]),calc(A,A[0],A[1],B[0],B[1]));\n  if (GE(ans,INF)) cout << -1 << endl;\n  else cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<double, int> P;\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\ndouble cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return 1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool intersectSS(const line &s, const line &t){\n  return ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0\n    && ccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\nbool visit[10010];\n \ndouble calc(int N1, xy_t *P1, xy_t *P2){\n  line l(P2[0], P2[1]);\n  memset(visit, false, sizeof(visit));\n  visit[0] = 0;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, 0));\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    double cost = p.first;\n    int v = p.second;\n    if(v == 1) return cost;\n    if(visit[v]) continue;\n    visit[v] = true;\n    rep(i, N1)if(!visit[i]){\n      double d = abs(P1[i] - P1[v]);\n      if(!intersectSS(l, line(P1[i], P1[v]))){\n\tque.push(P(cost + d, i));\n      }\n    }\n  }\n  return 1e100;\n} \n\nxy_t A[10010];\nxy_t B[10010];\n\nint main(){\n  int Na, Nb;\n  double x, y;\n  while(cin >> Na >> Nb){\n    double res = 1e100;\n    rep(i, Na) {\n      cin >> x >> y;\n      A[i] = xy_t(x, y);\n    }\n    rep(i, Nb){\n      cin >> x >> y;\n      B[i] = xy_t(x, y);\n    }\n    res = min(abs(A[0] - A[1]) + calc(Nb, B, A),\n\t      abs(B[0] - B[1]) + calc(Na, A, B));\n    if(res > 1e50) cout << -1 << endl;\n    else cout << fixed << setprecision(12) << res << endl;\n  }\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct vec{\n    int x,y;\n    vec(int x,int y){\n        this->x=x;this->y=y;\n    }\n    long long int cross(vec b){\n        return x*b.y-y*b.x;\n    }\n    vec operator-(vec b){\n        return vec(x-b.x,y-b.y);\n    }\n    vec operator+(vec b){\n        return vec(x+b.x,y+b.y);\n    }\n    double norm(){\n        return hypot(x,y);\n    }\n};\n\nbool isCrossing(vec& v1, vec& v2, vec& v3, vec& v4){\n    return (v2-v1).cross(v3-v1)*(v2-v1).cross(v4-v1)<0&&(v4-v3).cross(v1-v3)*(v4-v3).cross(v2-v3)<0;\n}\n\nint main(){\n    int NA,NB,x,y;\n    cin>>NA>>NB;\n    vector<vec> A,B;\n    for(int i=0;i<NA;i++){\n        cin>>x>>y;\n        A.emplace_back(x,y);\n    }\n    for(int i=0;i<NB;i++){\n        cin>>x>>y;\n        B.emplace_back(x,y);\n    }\n    double EA[NA][NA];\n    double EB[NB][NB];\n    fill(EA[0],EA[NA],0);\n    fill(EB[0],EB[NB],0);\n    for(int i=0;i<NA;i++){\n        for(int j=i+1;j<NA;j++){\n            if(!isCrossing(A[i],A[j],B[0],B[1])) EA[i][j]=EA[j][i]=(A[i]-A[j]).norm();\n        }\n    }\n    for(int i=0;i<NB;i++){\n        for(int j=i+1;j<NB;j++){\n            if(!isCrossing(B[i],B[j],A[0],A[1])) EB[i][j]=EB[j][i]=(B[i]-B[j]).norm();\n        }\n    }\n    double Amin[NA],Bmin[NB];\n    fill(Amin,Amin+NA,1e10);\n    fill(Bmin,Bmin+NB,1e10);\n    double Acost,Bcost;\n    int s=0,end=1;\n    typedef pair<double, int> P;\n    priority_queue<P,vector<P>,greater<P>> que;\n    Amin[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n        P p=que.top(); que.pop();\n        int v=p.second;\n        double cost=p.first;\n        if(cost>Amin[v])continue;\n        for(int i=0;i<NA;i++){\n            if(EA[i][v]!=0&&cost+EA[i][v]<Amin[i]){\n                Amin[i]=cost+EA[i][v];\n                que.emplace(Amin[i],i);\n            }\n        }\n    }\n    if(Amin[end]!=1e10){\n        Acost=Amin[end]+(B[s]-B[end]).norm();\n    }else{\n        Acost=1e10;\n    }\n    Bmin[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n        P p=que.top(); que.pop();\n        int v=p.second;\n        double cost=p.first;\n        if(cost>Bmin[v])continue;\n        for(int i=0;i<NB;i++){\n            if(EB[i][v]!=0&&cost+EB[i][v]<Bmin[i]){\n                Bmin[i]=cost+EB[i][v];\n                que.emplace(Bmin[i],i);\n            }\n        }\n    }\n    if(Bmin[end]!=1e10){\n        Bcost=Bmin[end]+(A[s]-A[end]).norm();\n    }else{\n        Bcost=1e10;\n    }\n    if(min(Acost,Bcost)==1e10){\n        cout<<-1<<endl;\n    }else{\n        cout.precision(12);\n        cout << fixed;\n        cout<<min(Acost,Bcost)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define INF (0x3f3f3f3f)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\n\ndouble dot(P a,P b){\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a,P b){\n\treturn a.real()*b.imag()-a.imag()*b.real();\n}\n\nint ccw(P a,P b,P c){\n\tP d = b-a;\n\tc-=a;\n\tdouble cr = cross(d,c);\n\tif(cr < -EPS) return 1;\n\tif(cr > EPS) return -1;\n\tif(dot(d,c) < -EPS) return 2;\n\tif(norm(d) < norm(c) - EPS) return -2;\n\treturn 0;\n}\n\nint is_intersected_ls(P a1,P a2,P b1,P b2){\n\treturn ccw(a1,a2,b1)*ccw(a1,a2,b2) <= 0 && ccw(b1,b2,a1)*ccw(b1,b2,a2) <= 0;\n}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvector<vector<double>> a(n,vector<double>(n,INF));\n\tvector<vector<double>> b(m,vector<double>(m,INF));\n\tvector<P> v(n);\n\tvector<P> w(m);\n\trep(i,n){\n\t\tdouble aa,bb;\n\t\tcin>>aa>>bb;\n\t\tv[i] = P(aa,bb);\n\t}\n\trep(i,m){\n\t\tdouble aa,bb;\n\t\tcin>>aa>>bb;\n\t\tw[i] = P(aa,bb);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i==j) a[i][j] = 0;\n\t\t\telse{\n\t\t\t\tif(is_intersected_ls(w[0],w[1],v[i],v[j])){\n\t\t\t\t\ta[i][j] = INF;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ta[i][j] = abs(v[i]-v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,m){\n\t\trep(j,m){\n\t\t\tif(i==j) b[i][j] = 0;\n\t\t\telse{\n\t\t\t\tif(is_intersected_ls(v[0],v[1],w[i],w[j])){\n\t\t\t\t\tb[i][j] = INF;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tb[i][j] = abs(w[i]-w[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<pair<double,int>> pq;\n\tdouble ans = INF;\n\tvector<int> used(n);\n\tvector<double> d(n,INF);\n\tpq.push(make_pair(-0.0,0));\n\twhile(pq.size()){\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tif(d[top.second] < -top.first) continue;\n\t\tused[top.second] = 1;\n\t\trep(i,n){\n\t\t\tif(used[i]) continue;\n\t\t\tif(d[i] < -top.first + a[top.second][i]) continue;\n\t\t\td[i] = -top.first + a[top.second][i];\n\t\t\tpq.push(make_pair(top.first - a[top.second][i],i));\n\t\t}\n\t}\n\tans=min(ans,d[1]+abs(w[0]-w[1]));\n\tpq.push(make_pair(-0.0,0));\n\td.assign(m,INF);\n\tused.assign(n,0);\n\twhile(pq.size()){\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tif(d[top.second] < -top.first) continue;\n\t\tused[top.second] = 1;\n\t\trep(i,m){\n\t\t\tif(used[i]) continue;\n\t\t\tif(d[i] < -top.first + b[top.second][i]) continue;\n\t\t\td[i] = -top.first + b[top.second][i];\n\t\t\tpq.push(make_pair(top.first - b[top.second][i],i));\n\t\t}\n\t}\n\tans=min(ans,d[1]+abs(v[0]-v[1]));\n\tcout<<fixed<<setprecision(10);\n\tif(ans>=INF) cout<<-1<<endl;\n\telse{\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n#define int long long\n\nbool isIntersect(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy) {\n\tint ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\tint tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\tint tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\tint td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n\treturn tc * td < 0 && ta * tb < 0;\n}\ndouble dst(int x1, int y1, int x2, int y2) {\n\treturn sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2));\n}\ndouble solve(vector<int> &X, vector<int> &Y, int X1, int Y1, int X2, int Y2) {\n\tvector<double> dist0(X.size(), 1e15);\n\tvector<double> dist1(X.size(), 1e15);\n\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tif (i != 0 && !isIntersect(X[i], Y[i], X[0], Y[0], X1, Y1, X2, Y2)) {\n\t\t\tdist0[i] = dst(X[i], Y[i], X[0], Y[0]);\n\t\t}\n\t\tif (i != 1 && !isIntersect(X[i], Y[i], X[1], Y[1], X1, Y1, X2, Y2)) {\n\t\t\tdist1[i] = dst(X[i], Y[i], X[1], Y[1]);\n\t\t}\n\t}\n\tdouble res = 1e15;\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tres = min(res, dist0[i] + dist1[i]);\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < X.size(); j++) {\n\t\t\tif (!isIntersect(X[i], Y[i], X[j], Y[j], X1, Y1, X2, Y2)) {\n\t\t\t\tres = min(res, dist0[i] + dist1[j] + dst(X[i], Y[i], X[j], Y[j]));\n\t\t\t}\n\t\t}\n\t}\n\treturn res + dst(X1, Y1, X2, Y2);\n}\nsigned main() {\n\tint A, B;\n\tcin >> A >> B;\n\tvector<int> XA(A), YA(A);\n\tvector<int> XB(B), YB(B);\n\tfor (int i = 0; i < A; i++) {\n\t\tcin >> XA[i] >> YA[i];\n\t}\n\tfor (int i = 0; i < B; i++) {\n\t\tcin >> XB[i] >> YB[i];\n\t}\n\tdouble res = 0;\n\tif (isIntersect(XA[0], YA[0], XA[1], YA[1], XB[0], YB[0], XB[1], YB[1])) {\n\t\tres = solve(XA, YA, XB[0], YB[0], XB[1], YB[1]);\n\t\tres = min(res, solve(XB, YB, XA[0], YA[0], XA[1], YA[1]));\n\t}\n\telse {\n\t\tres = dst(XA[0], YA[0], XA[1], YA[1]) + dst(XB[0], YB[0], XB[1], YB[1]);\n\t}\n\tif (res > 1e14) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << setprecision(15) << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\ntypedef complex<double> point;\ntypedef pair<point,point> pp;\ntypedef vector<point> VP;\n#define x real()\n#define y imag()\nconst point O{0,0};\n\ntypedef pair<int,double> T;\ntypedef pair<double,int> U;\nclass Graph{\n\tprivate:\n\tint V;\n\tvector<vector<T> > g;\n\tpublic:\n\tdouble DIJ(int s,int t){\n\t\tpriority_queue<U> que;\n\t\tvd d(V,inf);\n\t\td[s]=0;\n\t\tque.push({0,s});\n\t\twhile(!que.empty()){\n\t\t\tU p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(d[v]<-p.first) continue;\n\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\tint F=g[v][i].first;\n\t\t\t\tdouble S=g[v][i].second;\n\t\t\t\tif(d[F]>d[v]+S){\n\t\t\t\t\td[F]=d[v]+S;\n\t\t\t\t\tque.push({-d[F],F});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d[t];\n\t}\n\tGraph(int v){\n\t\tV=v;\n\t\tg=vector<vector<T> >(v);\n\t}\n\tvoid add_edge(int s,int t,double c){\n\t\tg[s].push_back({t,c});\n\t\tg[t].push_back({s,c});\n\t}\n};\n\nvoid Point_in(point& p){\n\tdouble A,B;\n\tcin>>A>>B;\n\tp={A,B};\n}\n\nbool If(pp a,pp b){\n\tpoint p1=a.first,p2=a.second,q1=b.first,q2=b.second;\n\tdouble c=(p1.x-p2.x)*(q1.y-p1.y)+(p1.y-p2.y)*(p1.x-q1.x);\n\tdouble d=(p1.x-p2.x)*(q2.y-p1.y)+(p1.y-p2.y)*(p1.x-q2.x);\n\treturn c*d<0;\n}\n\nbool Inter(pp a,pp b){\n\tif(If(a,b)&&If(b,a)) return 1;\n\treturn 0;\n}\n\nint n,m;\nVP a,b;\n\ndouble f(){\n\tGraph g(n);\n\tfor(int i=0;i<n;i++) for(int j=0;j<i;j++) if(!Inter({a[i],a[j]},{b[0],b[1]})){\n\t\tg.add_edge(i,j,abs(a[i]-a[j]));\n\t}\n\treturn g.DIJ(0,1)+abs(b[0]-b[1]);\n}\n\nint main(){\n\tcin>>n>>m;\n\ta=VP(n);\n\tb=VP(m);\n\tfor(int i=0;i<n;i++) Point_in(a[i]);\n\tfor(int i=0;i<m;i++) Point_in(b[i]);\n\tdouble res=f();\n\tswap(n,m);\n\tswap(a,b);\n\tres=min(res,f());\n\tif(res>inf-eps) cout<<-1<<endl;\n\telse cout<<syosu(11)<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Data{\n\tData(int arg_node_id,double arg_sum_dist){\n\t\tnode_id = arg_node_id;\n\t\tsum_dist = arg_sum_dist;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_dist > arg.sum_dist;\n\t}\n\tint node_id;\n\tdouble sum_dist;\n};\n\n\nstruct Point{\n\tdouble x,y;\n};\n\nstruct Line{\n\tPoint p[2];\n};\n\ndouble calc_dist(Line a){\n\treturn sqrt((a.p[0].x-a.p[1].x)*(a.p[0].x-a.p[1].x)+(a.p[0].y-a.p[1].y)*(a.p[0].y-a.p[1].y));\n}\n\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nPoint point[2][1000];\ndouble min_dist[1000],DIST[2][1000][1000];\nint start = 0,goal = 1;\nLine base_line;\n\n\ndouble dijkstra(int data_num,Type type){\n\n\tmin_dist[start] = 0;\n\tfor(int i = 1; i < data_num; i++)min_dist[i] = DBL_MAX;\n\n\tpriority_queue<Data> Q;\n\tQ.push(Data(start,0));\n\n\tdouble tmp_dist;\n\n\tLine line;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_dist > min_dist[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tline.p[0] = point[type][Q.top().node_id];\n\n\t\t\tfor(int next_node = 0; next_node < data_num; next_node++){\n\t\t\t\tif(next_node == Q.top().node_id)continue;\n\n\t\t\t\tline.p[1] = point[type][next_node];\n\n\t\t\t\tif(is_Cross(line,base_line))continue;\n\n\t\t\t\ttmp_dist = DIST[type][Q.top().node_id][next_node];\n\n\t\t\t\tif(min_dist[next_node] > Q.top().sum_dist+tmp_dist){\n\t\t\t\t\tmin_dist[next_node] = Q.top().sum_dist+tmp_dist;\n\t\t\t\t\tQ.push(Data(next_node,min_dist[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\treturn min_dist[goal];\n}\n\nint main(){\n\n\tint N_A,N_B;\n\tscanf(\"%d %d\",&N_A,&N_B);\n\n\tfor(int i = 0; i < N_A; i++){\n\t\tscanf(\"%lf %lf\",&point[A][i].x,&point[A][i].y);\n\t}\n\n\tLine calc_line;\n\tdouble tmp_dist;\n\n\tfor(int i = 0; i < N_A-1; i++){\n\t\tcalc_line.p[0] = point[A][i];\n\t\tfor(int k = i+1; k < N_A; k++){\n\t\t\tcalc_line.p[1] = point[A][k];\n\t\t\ttmp_dist = calc_dist(calc_line);\n\t\t\tDIST[A][i][k] = tmp_dist;\n\t\t\tDIST[A][k][i] = tmp_dist;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N_B; i++){\n\t\tscanf(\"%lf %lf\",&point[B][i].x,&point[B][i].y);\n\t}\n\n\tfor(int i = 0; i < N_B-1; i++){\n\t\tcalc_line.p[0] = point[B][i];\n\t\tfor(int k = i+1; k < N_B; k++){\n\t\t\tcalc_line.p[1] = point[B][k];\n\t\t\ttmp_dist = calc_dist(calc_line);\n\t\t\tDIST[B][i][k] = tmp_dist;\n\t\t\tDIST[B][k][i] = tmp_dist;\n\t\t}\n\t}\n\n\tdouble dist_1,dist_2;\n\n\tbase_line.p[0] = point[A][0];\n\tbase_line.p[1] = point[A][1];\n\n\tdist_1 = dijkstra(N_B,B);\n\n\tif(fabs(dist_1-DBL_MAX)<EPS){\n\t\t//Do nothing\n\t}else{\n\t\tdist_1 += calc_dist(base_line);\n\t}\n\n\tbase_line.p[0] = point[B][0];\n\tbase_line.p[1] = point[B][1];\n\n\tdist_2 = dijkstra(N_A,A);\n\n\tif(fabs(dist_2-DBL_MAX)<EPS){\n\t\t//Do nothing\n\t}else{\n\t\tdist_2 += calc_dist(base_line);\n\t}\n\n\tdouble ans = min(dist_1,dist_2);\n\n\tif(fabs(ans-DBL_MAX) < EPS){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%.12lf\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld inf = 1e20;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nstruct MyEdge {\n\tint to;\n\tld dist;\n};\nbool operator >(const MyEdge& e1, const MyEdge& e2) {\n\treturn e1.dist > e2.dist;\n}\n\nld solve(vector<Point> a, vector<Point> b) {\n\tLine bl(b[0], b[1]);\n\tint N = a.size();\n\tvector< vector<MyEdge> > G(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (i != j && !isis_ss(bl, Line(a[i], a[j]))) {\n\t\t\t\tld d = abs(a[i]-a[j]);\n\t\t\t\tG[i].push_back( (MyEdge){j, d} );\n\t\t\t\tG[j].push_back( (MyEdge){i, d} );\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld> dist(N, inf);\n\tpriority_queue<MyEdge, vector<MyEdge>, greater<MyEdge> > Q; Q.push({0, 0});\n\twhile ( !Q.empty() ) {\n\t\tMyEdge q = Q.top(); Q.pop();\n\t\tint v = q.to;\n\t\tif (q.dist > dist[v] || eq(q.dist, dist[v])) {\n\t\t\tcontinue;\n\t\t}\n\t\tdist[v] = q.dist;\n\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\tMyEdge& e = G[v][i];\n\t\t\tQ.push( (MyEdge){e.to, dist[v]+e.dist} );\n\t\t}\n\t}\n\treturn dist[1]+abs(b[0]-b[1]);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<Point> a, b;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\ta.push_back( Point(x, y) );\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tb.push_back( Point(x, y) );\n\t}\n\tld ans = min( solve(a, b), solve(b, a) );\n\tif ( eq(ans, inf) ) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << fixed << setprecision(12) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 1005\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\ntypedef pair<double,int> Pair;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nint S[2],x,y;\nP G[2][N];\n\ndouble getDistancePP(P A,P B){\n  return abs(P(A.real()-B.real(),A.imag()-B.imag()));\n}\n\ndouble dijkstra(int idx){\n  L base=L(P(G[!idx][0].real(),G[!idx][0].imag()),P(G[!idx][1].real(),G[!idx][1].imag()));\n  priority_queue<Pair,vector<Pair>,greater<Pair> > q;\n  double d[N];\n  for(int i=0;i<S[idx];i++)d[i]=INF;\n  d[0]=0;\n  q.push(Pair(0,0));\n  while(!q.empty()){\n    Pair t=q.top(); q.pop();\n    double cost=t.first;\n    int node=t.second;\n    if(d[node]<cost)continue;\n    for(int i=0;i<S[idx];i++){\n      if(i==node)continue;\n      if(isIntersect(base,L(P(G[idx][node].real(),G[idx][node].imag()),P(G[idx][i].real(),G[idx][i].imag()))))continue;\n      double ncost=cost+getDistancePP(G[idx][node],G[idx][i]);\n      if(d[i]>ncost){\n\td[i]=ncost;\n\tq.push(Pair(ncost,i));\n      }\n    }\n  }\n  return min(INF,d[1]+getDistancePP(G[!idx][0],G[!idx][1]));\n}\n\nint main(){\n  cin>>S[0]>>S[1];\n  for(int i=0;i<S[0];i++)\n    cin>>x>>y,G[0][i]=P(x,y);\n  for(int i=0;i<S[1];i++)\n    cin>>x>>y,G[1][i]=P(x,y);\n  double ans=INF;\n  ans=min(ans,dijkstra(0));\n  ans=min(ans,dijkstra(1));\n  if(ans==INF)cout<<-1<<endl;\n  else printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\n\nauto& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n// crossing determination\n// verified: AOJ CGL_2_B \nbool iss(L a,L b){\n\tint sa=sdet(a.s,a.t,b.s)*sdet(a.s,a.t,b.t);\n\tint sb=sdet(b.s,b.t,a.s)*sdet(b.s,b.t,a.t);\n\treturn max(sa,sb)<0;\n}\n\nint na,nb;\nP a[1010],b[1010];\n\n\n//Appropriately Changed\nusing W = R;\nusing edge = struct {int to; W cost;};\nusing G = vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph, int from, int to, W cost) {\n\tgraph[from].push_back({to, cost});\n\tgraph[to].push_back({from, cost});\n}\n\n\nauto dijkstra(const G &graph, int s) {\n    const int n = graph.size();\n    vector<W> dist(n, INF);\n    using state = tuple<W, int>;\n\n    priority_queue<state, vector<state>, greater<state>> q;\n    dist[s] = 0, q.push(state(0, s));\n\n    while (!q.empty()) {\n        W c; int v;\n        tie(c, v) = q.top(); q.pop();\n        for (auto &e : graph[v]) {\n            W nc = c + e.cost; int nv = e.to;\n            if (chmin(dist[nv], nc)) q.push(state(nc, nv));\n        }\n    }\n    return dist;\n}\n\nR check(int n,P p[1010],L ban){\n\tG graph(n);\n\trep(j,n)rep(i,j){\n\t\tL line = L{p[i],p[j]};\n\t\tif(iss(line,ban)) continue;\n\t\tadd_edge(graph,i,j,abs(line.s-line.t));\n\t}\n\n\tauto dist = dijkstra(graph,0);\n\treturn dist[1] + abs(ban.s-ban.t);\n}\n\nint main(void){\n\tcin >> na >> nb;\n\trep(i,na) cin >> a[i];\n\trep(i,nb) cin >> b[i];\n\n\tcout.precision(20);\n\n\tR ans = min(check(na,a,L{b[0],b[1]}),check(nb,b,L{a[0],a[1]}));\n\n\tif(ans < INF)\n\t\tcout << fixed << min(check(na,a,L{b[0],b[1]}),check(nb,b,L{a[0],a[1]})) << endl;\n\telse\n\t\tcout << -1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nusing ld = double;\nusing C = pair<ll, ll>;\nusing L = pair<C, C>;\n\nll cross(const C a, const C b)\n{\n    return a.first * b.second - a.second * b.first;\n}\nll dot(const C a, const C b)\n{\n    return a.first * b.first + a.second * b.second;\n}\nll normSq(const C a)\n{\n    return a.first * a.first + a.second * a.second;\n}\nld norm(const L a)\n{\n    const ll dx = a.first.first - a.second.first;\n    const ll dy = a.first.second - a.second.second;\n    return hypot(dx, dy);\n}\nint ccw(C a, C b, C c)\n{\n    b = {b.first - a.first, b.second - a.second};\n    c = {c.first - a.first, c.second - a.second};\n    if (cross(b, c) > 0)\n        return +1;  // counter clockwise\n    if (cross(b, c) < 0)\n        return -1;  // clockwise\n    if (dot(b, c) < 0)\n        return +2;  // c--a--b on line\n    if (normSq(b) < normSq(c))\n        return -2;  // a--b--c on line\n    return 0;       //b--a--c on line\n}\nbool intersectSS(const L s, const L t)\n{\n    return ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 and ccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\nstruct CostGraph {\n    using T = ld;\n    CostGraph(const int v) : V{v}\n    {\n        edge.resize(v);\n    }\n    struct Edge {\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        const int from;\n        const int to;\n        const T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n    const int V;\n};\nvoid Dijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = 1e8;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int A, B;\n    cin >> A >> B;\n    vector<C> a(A);\n    for (int i = 0; i < A; i++) {\n        ll x, y;\n        cin >> x >> y;\n        a[i] = {x, y};\n    }\n    const L al = L{a[0], a[1]};\n    vector<C> b(B);\n    for (int i = 0; i < B; i++) {\n        ll x, y;\n        cin >> x >> y;\n        b[i] = {x, y};\n    }\n    ld mini = 1e8;\n    const L bl = L{b[0], b[1]};\n    CostGraph ga(A);\n    for (int i = 0; i < A; i++) {\n        for (int j = i + 1; j < A; j++) {\n            if (not intersectSS(bl, L{a[i], a[j]})) {\n                ga.addEdge(i, j, norm(L{a[i], a[j]}));\n            }\n        }\n    }\n    vector<ld> ad(A);\n    Dijkstra(ga, 0, ad);\n    mini = min(mini, ad[1] + norm(bl));\n    CostGraph gb(B);\n    for (int i = 0; i < B; i++) {\n        for (int j = i + 1; j < B; j++) {\n            if (not intersectSS(al, L{b[i], b[j]})) {\n                gb.addEdge(i, j, norm(L{b[i], b[j]}));\n            }\n        }\n    }\n    vector<ld> bd(B);\n    Dijkstra(gb, 0, bd);\n    mini = min(mini, bd[1] + norm(al));\n    if (mini == 1e8) {\n        cout << -1 << endl;\n    } else {\n        cout << fixed << setprecision(15) << mini << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tld ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph ga(pa.size()), gb(pb.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tld d = abs(pa[i] - pa[j]);\n\t\tadd_edge(ga, i, j, d);\n\t\tadd_edge(ga, j, i, d);\n\t}\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tld d = abs(pb[i] - pb[j]);\n\t\tadd_edge(gb, i, j, d);\n\t\tadd_edge(gb, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(ga, da, 0);\n\tdijkstra(gb, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = i64(1e9) + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nnamespace geometry{\n    using D = long double;\n    using C = complex<D>;\n    constexpr D eps =1e-9;\n\n    struct Point;\n    bool near_eq(Point, Point);\n\n    struct Point{\n        D x, y;\n        Point(D x = 0.0, D y = 0.0) : x(x), y(y){}\n        friend bool operator<(const Point& a, const Point& b){\n            return a.x == b.x ? a.y < b.y : a.x < b.x;\n        }\n        Point& operator+=(Point a){x += a.x, y += a.y; return *this;}\n        Point& operator-=(Point a){x -= a.x, y -= a.y; return *this;}\n        Point& operator*=(D p){x *= p, y *= p; return *this;}\n        friend Point operator+(Point a, Point b){return Point(a) += b;}\n        friend Point operator-(Point a, Point b){return Point(a) -= b;}\n        friend Point operator*(Point a, Point b){return Point(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);}\n        friend Point operator*(Point a, D p){return Point(a) *= p;}\n    };\n    using P = Point;\n    bool near_eq(D a, D b){return abs(a - b) < eps;}\n    bool near_eq(P a, P b){return near_eq(a.x, b.x) && near_eq(a.y, b.y);}\n    D diag(P a){\n        assert(!near_eq(a, P()));\n        return atan2(a.y, a.x);\n    }\n    D abs_square(P a){return a.x * a.x + a.y * a.y;}\n    D abs(P a){return sqrt(abs_square(a));}\n    P conj(P a){return P(a.x, -a.y);}\n    P norm(P a){return a * conj(a);}\n    D dist(P a, P b){return abs(a - b);}\n    D dot(P a, P b){return a.x * b.x + a.y * b.y;}\n    D cross(P a, P b){return a.x * b.y - a.y * b.x;}\n    int ccw(P a, P b, P c){\n        b -= a;\n        c -= a;\n        if(cross(b, c) > eps)return 1;\n        if(cross(b, c) < -eps)return -1;\n        if(dot(b, c) < -eps)return 2;\n        if(norm(b) < norm(c))return -2;\n        return 0;\n    }\n    bool is_on_line(P a1, P a2, P b){return abs(ccw(a1, a2, b)) != -1;}\n    bool is_on_segment(P a1, P a2, P b){return !ccw(a1, a2, b);}\n    bool intersect(P a1, P a2, P b1, P b2){\n        return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n               ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n    }\n    P cross_point(P a1, P a2, P b1, P b2){\n        D d1 = cross(b2 - b1, b1 - a1);\n        D d2 = cross(b2 - b1, a2 - a1);\n        if(near_eq(d1, 0) && near_eq(d2, 0))return a1;\n        assert(!near_eq(d2, 0));\n        return a1 + d1 / d2 * (a2 - a1);\n    }\n}\n\nusing ld = long double;\nusing namespace geometry;\n\nlong double solve(int n, vector<ld> ax, vector<ld> ay, vector<ld> bx, vector<ld> by){\n    P b1(bx[0], by[0]);\n    P b2(bx[1], by[1]);\n    vector<P> points;\n    for(int i = 0; i < n; ++i)\n        points.emplace_back(ax[i], ay[i]);\n\n    vector<D> range(n, INF);\n    range[0] = 0;\n    vector<vector<D>> dist(n, vector<D>(n, INF));\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            if(i == j){\n                dist[i][j] = 0;\n                continue;\n            }\n            if(!geometry::intersect(points[i], points[j], b1, b2)){\n                dist[i][j] = geometry::dist(points[i], points[j]);\n            }\n        }\n    }\n    bitset<1000> visited;\n    visited.set(0);\n    int idx = 0;\n    for(int _ = 0; _ < n; ++_){\n        int i = idx;\n        D mi = INF;\n        visited.set(i);\n        for(int j = 0; j < n; ++j){\n            if(visited[j])\n                continue;\n            chmin(range[j], range[i] + dist[i][j]);\n            if(chmin(mi, range[j]))\n                idx = j;\n        }\n    }\n    return geometry::dist(b1, b2) + range[1];\n}\n\n\nsigned main(){\n    int n, m;\n    cin >> n >> m;\n    vector<ld> ax(n), ay(n), bx(m), by(m);\n    for(int i = 0; i < n; ++i)\n        cin >> ax[i] >> ay[i];\n    for(int i = 0; i < m; ++i)\n        cin >> bx[i] >> by[i];\n\n    ld res = min(solve(n, ax, ay, bx, by), solve(m, bx, by, ax, ay));\n\n    if(res >= 1e12){\n        cout << -1 << endl;\n        return 0;\n    }\n    printf(\"%.20Lf\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst double INF = 1e18;\n\nstruct P{\n  double x, y;\n  P(double x_=0., double y_=0.):\n\tx(x_), y(y_){}\n  P operator-(const P& rhs)const{\n\treturn P(x-rhs.x, y-rhs.y);\n  }\n  double norm(){\n\treturn x*x+y*y;\n  }\n};\nstruct Segment{\n  P p1, p2;\n  double norm(){\n\treturn (p1-p2).norm();\n  }\n};\n\ndouble dot(P a, P b){\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(P a, P b){\n\treturn a.x*b.y - a.y*b.x;\n}\nint ccw(P p0, P p1, P p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn(ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\n\ndouble dist[1010][1010];\ndouble calc(int N){\n  vector<double> dp(N,INF);\n  vector<bool> vis(N, false);\n  int s = 0;\n  dp[0] = 0;\n  REP(i,N){\n\tvis[s] = true;\n\tint id = -1;\n\tdouble mn = INF;\n\tREP(j,N){\n\t  if(!vis[j]){\n\t\tdouble d = dp[s] + dist[s][j];\n\t\tdp[j] = min(dp[j], d);\n\t\tif(dp[j] < mn){\n\t\t  id = j;\n\t\t  mn = dp[j];\n\t\t}\n\t  }\n\t}\n\tif(id < 0) break;\n\ts = id;\n  }\n  return dp[1];\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  vector<P> as(N), bs(M);\n  REP(i,N) cin >> as[i].x >> as[i].y;\n  REP(i,M) cin >> bs[i].x >> bs[i].y;\n\n  double ans = INF;\n  {\n\tSegment s; s.p1 = as[0], s.p2 = as[1];\n\tREP(i,M) REP(j,i){\n\t  Segment t; t.p1 = bs[i], t.p2 = bs[j];\n\t  dist[i][j] = dist[j][i] = (intersect(s,t)? INF:sqrt(t.norm()));\n\t}\n\tans = min(ans, calc(M)+sqrt(s.norm()));\n  }\n  {\n\tSegment s; s.p1 = bs[0], s.p2 = bs[1];\n\tREP(i,N) REP(j,i){\n\t  Segment t; t.p1 = as[i], t.p2 = as[j];\n\t  dist[i][j] = dist[j][i] = (intersect(s,t)? INF:sqrt(t.norm()));\n\t}\n\tans = min(ans, calc(N)+sqrt(s.norm()));\n  }\n\n  if(ans >= INF) cout<<-1<<endl;\n  else cout << fixed << setprecision(10) << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define N 1001\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.f,s1.s,s2.f) * ccw(s1.f,s1.s,s2.s) <= 0 &&\n           ccw(s2.f,s2.s,s1.f) * ccw(s2.f,s2.s,s1.s) <= 0 );\n}\n\ntypedef pair<double,int> Pi;\ndouble dijkstra(vector<P>A,vector<P>B){\n  vector<double>D(N,INF);\n  priority_queue<Pi,vector<Pi>,greater<Pi> >Q;\n  Q.push(Pi(0,0));\n  D[0]=0;\n  while(!Q.empty()){\n    Pi t=Q.top();Q.pop();\n    int pos=t.s;\n    double cost=t.f;\n    if(D[pos]<cost)continue;\n    if(pos==1)return cost+abs(A[0]-A[1]);    \n\n    for(int i=0;i<B.size();i++){\n      double ncost=cost+abs(B[pos]-B[i]);\n      if(isIntersect(L(A[0],A[1]),L(B[pos],B[i]))||D[i]<=ncost)continue;\n      D[i]=ncost;\n      Q.push(Pi(ncost,i));\n    }\n  }\n  return INF;\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  vector<P> A(n),B(m); \n  for(int i=0,x,y;i<n;i++)cin>>x>>y,A[i]=P(x,y);\n  for(int i=0,x,y;i<m;i++)cin>>x>>y,B[i]=P(x,y);\n  double ans=min(dijkstra(A,B),dijkstra(B,A));\n  printf(\"%.10f\\n\",ans<INF? ans:-1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\ntypedef double DD;\n\nconst DD INF = 1LL<<30;\nconst DD EPS = 1e-10;\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\nPoint operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\nPoint operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\nPoint conj(const Point &p) {return Point(p.x, -p.y);}\nPoint rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(const Point &p) {return Point(-p.y, p.x);}\nDD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\nDD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\nDD norm(const Point &p) {return dot(p, p);}\nDD abs(const Point &p) {return sqrt(dot(p, p));}\nDD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\nbool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\nbool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\nbool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\nPoint operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n\nPoint proj(Point p, Line l) {\n    DD t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(Point p, Line l) {\n    return p + (proj(p, l) - p) * 2;\n}\nbool isinterPL(Point p, Line l) {\n    return (abs(p - proj(p, l)) < EPS);\n}\nbool isinterPS(Point p, Line s) {\n    return (ccw(s[0], s[1], p) == 0);\n}\nbool isinterLL(Line l, Line m) {\n    return (abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n            abs(cross(l[1] - l[0], m[0] - l[0])) < EPS);\n}\nbool isinterSS(Line s, Line t) {\n    if (eq(s[0], s[1])) return isinterPS(s[0], t);\n    if (eq(t[0], t[1])) return isinterPS(t[0], s);\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 && \n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\n\n\nint n[2];\nPoint pos[2][2100];\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    \n\twhile (cin >> n[0] >> n[1]) {\n\t\tfor (int it = 0; it < 2; ++it)\n\t\t\tfor (int i = 0; i < n[it]; ++i)\n\t\t\t\tcin >> pos[it][i].x >> pos[it][i].y;\n\t\t\n\t\tDD res = INF;\n\t\tfor (int it = 0; it < 2; ++it) {\n\t\t\tLine l(pos[1-it][0], pos[1-it][1]);\t\t// これと交わってはダメ\n\t\t\tDD dl = abs(pos[1-it][0] - pos[1-it][1]);\n\n\t\t\tDD dist[2100];\n\t\t\tfor (int i = 0; i < n[it]; ++i) dist[i] = INF;\n\t\t\tdist[0] = 0;\n\t\t\tbool seen[2100];\n\t\t\tmemset(seen, 0, sizeof(seen));\n\t\t\tfor (int i = 0; i < n[it]; ++i) {\n\t\t\t\tdouble Min = INF + 10;\n\t\t\t\tint pMin = -1;\n\t\t\t\tfor (int j = 0; j < n[it]; ++j) {\n\t\t\t\t\tif (seen[j]) continue;\n\t\t\t\t\tif (chmin(Min, dist[j])) pMin = j;\n\t\t\t\t}\n\t\t\t\t//cout << pMin << \", \" << Min << endl;\n\t\t\t\tif (pMin == -1) continue;\n\t\t\t\tfor (int j = 0; j < n[it]; ++j) {\n\t\t\t\t\tif ( isinterSS(Line(pos[it][pMin], pos[it][j]), l) ) continue;\n\t\t\t\t\tchmin(dist[j], dist[pMin] + abs(pos[it][j] - pos[it][pMin]));\n\t\t\t\t}\n\t\t\t\tseen[pMin] = true;\n\t\t\t}\n\t\t\tchmin(res, dist[1] + dl);\n\t\t}\n\t\tif (res >= INF - EPS) res = -1.000000000000000;\n\t\tcout << fixed << setprecision(10) << res << endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tA,\n\tB,\n};\n\nstruct Data{\n\tData(int arg_node_id,double arg_sum_dist){\n\t\tnode_id = arg_node_id;\n\t\tsum_dist = arg_sum_dist;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_dist > arg.sum_dist;\n\t}\n\tint node_id;\n\tdouble sum_dist;\n};\n\n\nstruct Point{\n\tdouble x,y;\n};\n\nstruct Line{\n\tPoint p[2];\n};\n\ndouble calc_dist(Line a){\n\treturn sqrt((a.p[0].x-a.p[1].x)*(a.p[0].x-a.p[1].x)+(a.p[0].y-a.p[1].y)*(a.p[0].y-a.p[1].y));\n}\n\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nPoint point[2][1000];\ndouble min_dist[1000];\nint start = 0,goal = 1;\nLine base_line;\n\n\ndouble dijkstra(int data_num,Type type){\n\n\tmin_dist[start] = 0;\n\tfor(int i = 1; i < data_num; i++)min_dist[i] = DBL_MAX;\n\n\tpriority_queue<Data> Q;\n\tQ.push(Data(start,0));\n\n\tdouble tmp_dist;\n\n\tLine line;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_dist > min_dist[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tline.p[0] = point[type][Q.top().node_id];\n\n\t\t\tfor(int next_node = 0; next_node < data_num; next_node++){\n\t\t\t\tif(next_node == Q.top().node_id)continue;\n\n\t\t\t\tline.p[1] = point[type][next_node];\n\n\t\t\t\tif(is_Cross(line,base_line))continue;\n\n\t\t\t\ttmp_dist = calc_dist(line);\n\n\t\t\t\tif(min_dist[next_node] > Q.top().sum_dist+tmp_dist){\n\t\t\t\t\tmin_dist[next_node] = Q.top().sum_dist+tmp_dist;\n\t\t\t\t\tQ.push(Data(next_node,min_dist[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\treturn min_dist[goal];\n}\n\nint main(){\n\n\tint N_A,N_B;\n\tscanf(\"%d %d\",&N_A,&N_B);\n\n\tfor(int i = 0; i < N_A; i++){\n\t\tscanf(\"%lf %lf\",&point[A][i].x,&point[A][i].y);\n\t}\n\n\tfor(int i = 0; i < N_B; i++){\n\t\tscanf(\"%lf %lf\",&point[B][i].x,&point[B][i].y);\n\t}\n\n\tdouble dist_1,dist_2;\n\n\tbase_line.p[0] = point[A][0];\n\tbase_line.p[1] = point[A][1];\n\n\tdist_1 = dijkstra(N_B,B);\n\n\tif(fabs(dist_1-DBL_MAX)<EPS){\n\t\t//Do nothing\n\t}else{\n\t\tdist_1 += calc_dist(base_line);\n\t}\n\n\tbase_line.p[0] = point[B][0];\n\tbase_line.p[1] = point[B][1];\n\n\tdist_2 = dijkstra(N_A,A);\n\n\tif(fabs(dist_2-DBL_MAX)<EPS){\n\t\t//Do nothing\n\t}else{\n\t\tdist_2 += calc_dist(base_line);\n\t}\n\n\tdouble ans = min(dist_1,dist_2);\n\n\tif(fabs(ans-DBL_MAX) < EPS){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%.12lf\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,int> P;\n\nstruct point{\n  ll x,y;  \n  point operator + (const point &p)const{\n    return (point){x+p.x,y+p.y};\n  }\n  point operator - (const point &p)const{\n    return (point){x-p.x,y-p.y};\n  }\n  point operator * (const ll r)const{\n    return (point){x*r,y*r};\n  }\n  bool operator < (const point &p)const{\n    return (x==p.x?y<p.y:x<p.x);\n  }\n};\n\nll dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\nll norm(point a){\n  return dot(a,a);\n}\nll cross(point a,point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nint ccw(point a,point b,point c){\n  if(cross(b-a,c-a)>0)return 1;//ccw\n  if(cross(b-a,c-a)<0)return -1;//cw\n  if(dot(b-a,c-a)<0)return 2;//back\n  if(norm(b-a)<norm(c-a))return -2;//front\n  return 0;//on\n}\n\nbool isIntersect(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\n\ndouble solve(vector<point> &t,int n,point sp,point tp){\n  vector<double> d(n,1e20);\n  d[0]=0;\n  priority_queue< P , vector<P> , greater<P> > Q;\n  Q.push(P(0,0));\n  while(!Q.empty()){\n    P p=Q.top();Q.pop();\n    int pos=p.second;\n    double cost=p.first;\n    if(d[pos]<cost)continue;\n    for(int to=0;to<n;to++){\n      if(to==pos || isIntersect(t[pos],t[to],sp,tp))continue;\n      double ncost = cost + sqrt(norm(t[pos]-t[to]));\n      if(ncost<d[to]){\n        d[to]=ncost;\n        Q.push(P(ncost,to));\n      }\n    }\n  }  \n  return d[1]+sqrt(norm(sp-tp));\n  \n}\n\nint a,b;\nvector<point> A,B;\n\nint main(){\n  cin>>a>>b;\n  A.resize(a);\n  B.resize(b);\n  for(int i=0;i<a;i++)cin>>A[i].x>>A[i].y;\n  for(int i=0;i<b;i++)cin>>B[i].x>>B[i].y;\n  double ans;  \n  if( isIntersect( A[0],A[1],B[0],B[1] ) ){\n    ans=min(solve(A,a,B[0],B[1]),solve(B,b,A[0],A[1]));    \n  }else{\n    ans=sqrt(norm(A[0]-A[1]))+sqrt(norm(B[0]-B[1]));\n  }\n  if(ans>=1e19){\n    printf(\"-1\\n\");\n  }else{\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst float EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef float Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nconst float PI = acos(-1.0);\nbool eq(float a, float b) { return abs(a - b) < EPS; }\ntypedef complex<float> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(float x1, float y1, float x2, float y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; float r;\n\tCircle(Point a, float b) :p(a), r(b) {};\n};\n\nfloat dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nfloat cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tfloat r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nfloat dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nfloat dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nfloat dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nfloat dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nfloat dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tfloat a = cross(s.b - s.a, t.b - t.a);\n\tfloat b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tfloat d = abs(c1.p - c2.p);\n\tfloat rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tfloat dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tfloat rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tfloat d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tfloat d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tfloat d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tfloat len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tfloat x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tfloat x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tfloat ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph ga(pa.size()), gb(pb.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tfloat d = abs(pa[i] - pa[j]);\n\t\tadd_edge(ga, i, j, d);\n\t\tadd_edge(ga, j, i, d);\n\t}\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tfloat d = abs(pb[i] - pb[j]);\n\t\tadd_edge(gb, i, j, d);\n\t\tadd_edge(gb, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(ga, da, 0);\n\tdijkstra(gb, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\n\nusing R = long double;\nusing P = complex<R>;\nusing L = pair<P,P>;\nusing G = vector<P>;\nstruct C {\n  P c; R r;\n  C() {}\n  C(const P &a, const R &b) : c(a), r(b) {}\n};\nstruct S : public L {\n  S() {}\n  S(const P &a, const P &b) : L(a,b) {}\n};\n\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\ninline R dot(const P& a, const P& b) {\n  return real(a)*real(b) + imag(a)*imag(b);\n}\ninline R det(const P& a, const P& b) {\n  return real(a)*imag(b) - imag(a)*real(b);\n}\ninline P vec(const L& l) {return l.second - l.first;}\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) ? real(a-b) < 0 : sgn(imag(a-b)) < 0;\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) == 0 && sgn(imag(a-b)) == 0;\n\t}\n  bool cmp_y (const P& a, const P& b) {\n    return sgn(imag(a-b)) ? imag(a-b) < 0 : sgn(real(a-b)) < 0;\n  }\n}\n\n// P,L,Sについて入力\ninline istream& operator>>(istream& is, P& p) {\n  R x, y;\n  is >> x >> y;\n  p = P(x, y);\n  return is;\n}\ninline istream& operator>>(istream& is, L& l) {\n  P a, b;\n  is >> a >> b;\n  l = L(a, b);\n  return is;\n}\ninline istream& operator>>(istream& is, S& s) {\n  P a, b;\n  is >> a >> b;\n  s = S(a, b);\n  return is;\n}\n\n// 射影\nP inline projection(const L &l, const P &p) {\n  R t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\n// 反射\nP inline reflection(const L &l, const P &p) {\n  return p + (R)2 * (projection(l, p) - p);\n}\n\n// 線分abから見たcの位置\nenum CCW{LEFT=1, RIGHT=2, BACK=4, FRONT=8, ON_SEG=16};\nint ccw(P a, P b, P c) {\n\tP p = (c-a)/(b-a);\n\tif(sgn(imag(p)) > 0) return LEFT;\n\tif(sgn(imag(p)) < 0) return RIGHT;\n\tif(sgn(real(p)) < 0) return BACK;\n\tif(sgn(real(p)-1) > 0) return FRONT;\n\treturn ON_SEG;\n}\n\n// 垂直,平行\ninline bool vertical(L a, L b) {return sgn(dot(vec(a), vec(b))) == 0;}\ninline bool parallel(L a, L b) {return sgn(det(vec(a), vec(b))) == 0;}\ninline bool eal(L a, L b) {return vertical(a,b) && parallel(a,b);}\n\n// 交差判定\ntemplate<bool strict=false> inline bool intersect(const L&l1, const L&l2) {\n  if(strict) return sgn(det(vec(l1),vec(l2))) != 0;\n  return sgn(det(vec(l1),vec(l2))) != 0 || l1 == l2;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const S&s) {\n  if(strict) det(s.first, vec(l)) * det(s.second, vec(l)) < 0;\n  return det(s.first, vec(l)) * det(s.second, vec(l)) <= 0;\n}\ntemplate<bool strict=false> inline bool intersect(const S&s1, const S&s2) {\n  int ccw1 = ccw(s1.first, s1.second, s2.first) | ccw(s1.first, s1.second, s2.second);\n  int ccw2 = ccw(s2.first, s2.second, s1.first) | ccw(s2.first, s2.second, s1.second);\n  if(strict) return (ccw1 & ccw2) == (LEFT | RIGHT);\n  return (ccw1 & ccw2) == (LEFT | RIGHT) || ((ccw1 | ccw2) & ON_SEG);\n}\n\nvector<pair<int, double>> g1[1010];\nvector<pair<int, double>> g2[1010];\ndouble d[1010];\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n  vector<P> a(n), b(m);\n  REP(i, n) cin >> a[i];\n  REP(i, m) cin >> b[i];\n\n  // a[0] と a[1] を結ぶとする\n  S l(a[0], a[1]);\n  REP(i, m) FOR(j, i+1, m) {\n    S tmp(b[i], b[j]);\n    if(!intersect(l, tmp)) {\n      g1[i].PB({j, abs(b[i]-b[j])});\n      g1[j].PB({i, abs(b[i]-b[j])});\n    }\n  }\n\n  priority_queue<pair<double,int>, vector<pair<double,int>>, greater<pair<double,int>>> que;\n  REP(i, m) d[i] = INF;\n  d[0] = 0;\n  que.push({d[0], 0});\n\n  while(que.size()) {\n    pair<double,int> p = que.top(); que.pop();\n    if(d[p.second] < p.first) continue;\n    if(p.second == 1) break;\n    for(auto e: g1[p.second]) {\n      if(d[e.first] > d[p.second] + e.second) {\n        d[e.first] = d[p.second] + e.second;\n        que.push({d[e.first], e.first});\n      }\n    }\n  }\n\n  R ans = abs(a[0]-a[1]) + d[1];\n  // cout << ans << endl;\n\n  // b[0] と b[1] を結ぶとする\n  l = S(b[0], b[1]);\n  REP(i, n) FOR(j, i+1, n) {\n    S tmp(a[i], a[j]);\n    if(!intersect(l, tmp)) {\n      g2[i].PB({j, abs(a[i]-a[j])});\n      g2[j].PB({i, abs(a[i]-a[j])});\n    }\n  }\n\n  while(que.size()) que.pop();\n  REP(i, n) d[i] = INF;\n  d[0] = 0;\n  que.push({d[0], 0});\n\n  while(que.size()) {\n    pair<double,int> p = que.top(); que.pop();\n    if(d[p.second] < p.first) continue;\n    if(p.second == 1) break;\n    for(auto e: g2[p.second]) {\n      if(d[e.first] > d[p.second] + e.second) {\n        d[e.first] = d[p.second] + e.second;\n        que.push({d[e.first], e.first});\n      }\n    }\n  }\n\n  chmin(ans, abs(b[0]-b[1]) + d[1]);\n\n  if(ans >= INF) cout << -1 << endl;\n  else cout << fixed << setprecision(15) << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\nusing namespace std;\n\nconst long long int mod = 1000000007;\n\nstruct Mod {\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(long long int a, Mod b) { return Mod(a) + b; }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(long long int a, Mod b) { return Mod(a) - b; }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(long long int a, Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator+=(long long int &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator-=(long long int &a, Mod b) { return a = a - b; }\nMod operator*=(Mod &a, Mod b) { return a = a * b; }\nMod operator*=(long long int &a, Mod b) { return a = a * b; }\nMod operator^(Mod a, long long int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) {\n\tassert(b != 0);\n\treturn a * inv(b);\n}\nMod operator/(long long int a, Mod b) {\n\tassert(b != 0);\n\treturn Mod(a) * inv(b);\n}\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(int a, int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\n// 点の入力\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\n// 円の定義\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n  if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n  if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n  if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n  return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back(Edge{from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back(Edge{from, to});\n      g[to].push_back(Edge{to, from});\n    }\n  }\n  return g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nclass Compare {\npublic:\n\tbool operator()(const pair<int, double>&l, const pair<int, double>&r) {\n\t\treturn l.second > r.second;\n\t}\n};\n\nint main() {\n\tint a, b;\n\tcin >> a >> b;\n\tvector<Point> totaps;\n\tvector<Point> tuteps;\n\tfor (int i = 0; i < a; ++i) {\n\t\tdouble x;\n\t\tdouble y;\n\t\tcin >> x >> y;\n\t\ttotaps.push_back(Point(x, y));\n\t}\n\tfor (int i = 0; i < b; ++i) {\n\t\tdouble x;\n\t\tdouble y;\n\t\tcin >> x >> y;\n\t\ttuteps.push_back(Point(x, y));\n\t}\n\tdouble ans1 = 0;\n\t{\n\t\tLine totaload(totaps[0], totaps[1]);\n\t\tvector<vector<pair<int,double>>>Nodes(b);\n\t\tfor (int i = 0; i < b; ++i) {\n\t\t\tfor (int j = 0; j < b; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tif (!isis_ss(totaload, Line(tuteps[i], tuteps[j]))) {\n\t\t\t\t\t\tdouble dis = abs(tuteps[i] - tuteps[j]);\n\t\t\t\t\t\tNodes[i].push_back(make_pair(j, dis));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<double>times(b, 999999999999);\n\t\ttimes[0] = 0;\n\t\tpriority_queue<pair<int, double>,vector<pair<int, double>>,Compare>qu;\n\t\tqu.push(make_pair(0, 0));\n\t\twhile (!qu.empty()) {\n\t\t\tpair<int, double> atop = qu.top();\n\t\t\tqu.pop();\n\t\t\tfor (int i = 0; i < Nodes[atop.first].size(); ++i) {\n\t\t\t\tif (times[Nodes[atop.first][i].first]>atop.second + Nodes[atop.first][i].second) {\n\t\t\t\t\tqu.push(make_pair(Nodes[atop.first][i].first,atop.second + Nodes[atop.first][i].second));\n\t\t\t\t\ttimes[Nodes[atop.first][i].first] = atop.second + Nodes[atop.first][i].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans1= abs(totaload.a-totaload.b);\n\t\tans1 += times[1];\n\t}\n\tdouble ans2 = 0;\n\t{\n\t\tLine tuteload(tuteps[0], tuteps[1]);\n\t\tvector<vector<pair<int, double>>>Nodes(a);\n\t\tfor (int i = 0; i < a; ++i) {\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tif (!isis_ss(tuteload, Line(totaps[i], totaps[j]))) {\n\t\t\t\t\t\tdouble dis=abs(totaps[i] - totaps[j]);\n\t\t\t\t\t\tNodes[i].push_back(make_pair(j, dis));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<double>times(a, 999999999999);\n\t\ttimes[0] = 0;\n\t\tpriority_queue<pair<int, double>, vector<pair<int, double>>, Compare>qu;\n\t\tqu.push(make_pair(0, 0));\n\t\twhile (!qu.empty()) {\n\t\t\tpair<int, double> atop = qu.top();\n\t\t\tqu.pop();\n\t\t\tfor (int i = 0; i < Nodes[atop.first].size(); ++i) {\n\t\t\t\tif (times[Nodes[atop.first][i].first]>atop.second + Nodes[atop.first][i].second) {\n\t\t\t\t\tqu.push(make_pair(Nodes[atop.first][i].first, atop.second + Nodes[atop.first][i].second));\n\t\t\t\t\ttimes[Nodes[atop.first][i].first] = atop.second + Nodes[atop.first][i].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans2 = abs(tuteload.a - tuteload.b);\n\t\tans2 += times[1];\n\t}\n\tdouble ans = min(ans1, ans2);\n\tif (ans > 999999999990) {\n\t\tcout << -1 << endl;\n\t}else{\n\t\tcout <<fixed<<setprecision(20)<< ans << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef complex<double> Point, Vector;\ntypedef pair<Point, Point> Segment, Line;\ntypedef pair<double, int> P;\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\ndouble dot(Vector a, Vector b){\n    return a.X * b.X + a.Y * b.Y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.X * b.Y - a.Y * b.X;\n}\n\ndouble norm(Vector a){\n    return a.X * a.X + a.Y * a.Y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return 1;\n    if(cross(a, b) < -EPS) return -1;\n    if(dot(a, b) < -EPS) return 2;\n    if(norm(a) < norm(b)) return -2;\n\n    return 0;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.first, s1.second, s2.first, s2.second);\n}\n\ndouble solve(vector<Point> &pa, vector<Point> &pb){\n\n    Segment base = {pa[0], pa[1]};\n    double ans = abs(pa[0] - pa[1]);\n\n    vector<double> dist(1000, 1e9);\n    priority_queue<P, vector<P>, greater<P>> que;\n    dist[0] = 0;\n    que.emplace(0, 0);\n\n    while(que.size()){\n        double ccost; int cv;\n        tie(ccost, cv) = que.top();\n        que.pop();\n\n        if(dist[cv] < ccost) continue;\n\n        for(int i=0; i<pb.size(); i++){\n            int nv = i;\n            Segment sg = {pb[cv], pb[nv]};\n\n            if(intersect(base, sg)) continue;\n\n            double cdist = abs(pb[nv] - pb[cv]);\n\n            if(dist[cv] + cdist < dist[nv]){\n                dist[nv] = dist[cv] + cdist;\n                que.emplace(dist[nv], nv);\n            }\n        }\n    }\n\n    return  (ans + dist[1]);\n}\n\nint main(){\n    int na, nb; cin>>na>>nb;\n    vector<Point> pa;\n    for(int i=0; i<na; i++){\n        double x, y; cin>>x>>y;\n        pa.emplace_back(x, y);\n    }\n\n    vector<Point> pb;\n    for(int i=0; i<nb; i++){\n        double x, y; cin>>x>>y;\n        pb.emplace_back(x, y);\n    }\n\n    double ansa = solve(pa, pb);\n    double ansb = solve(pb, pa);\n\n    if(1e9 <= ansa and 1e9 <= ansb){\n        cout << -1 << endl;\n    }\n    else{\n        double ans = min(ansa, ansb);\n        printf(\"%.12f\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LT(x,y) ((x)-(y)<=-EPS)\n\ndouble dist(P a, P b) {\n\treturn abs(a-b);\n}\n\ndouble cross(P a, P b) {\n\treturn (a.real()*b.imag() - a.imag()*b.real());\n}\n\nbool is_point_on_ls(P a, P b, P c) {\n\treturn (abs(a-c)+abs(c-b) < abs(a-b)+EPS);\n}\n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n\tif((cross(a2-a1, b1-a1) * cross(a2-a1, b2-b1) < -EPS) &&\n\t   (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS))\n\t   return true;\n\treturn is_point_on_ls(a1, a2, b1) || is_point_on_ls(a1, a2, b2) ||\n\t\tis_point_on_ls(b1, b2, a1) || is_point_on_ls(b1, b2, a2);\n}\n\nstruct state {\n\tint p;\n\tdouble d;\n\tstate(int p, double d) : p(p), d(d) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.d<d;\n\t}\n};\n\nint main() {\n\tint NA, NB;\n\tcin >> NA >> NB;\n\n\tvp pa(NA), pb(NB);\n\tdouble x, y;\n\tREP(i, NA) {\n\t\tcin >> x >> y;\n\t\tpa[i] = P(x, y);\n\t}\n\tREP(i, NB) {\n\t\tcin >> x >> y;\n\t\tpb[i] = P(x, y);\n\t}\n\n\tdouble ans = INF;\n\tif(!is_intersected_ls(pa[0], pa[1], pb[0], pb[1])) {\n\t\tans = min(ans, dist(pa[0], pa[1])+dist(pb[0], pb[1]));\n\t} else {\n\t\tvvi tableA(NA, vi(0));\n\t\tdouble distb = dist(pb[0],pb[1]);\n\t\tREP(i, NA) {\n\t\t\tREP(j, NA) {\n\t\t\t\tif(i != j && !is_intersected_ls(pb[0], pb[1], pa[i], pa[j])) {\n\t\t\t\t\ttableA[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvd costA(NA, INF);\n\t\tcostA[0] = 0;\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(0, 0));\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(st.p == 1) {\n\t\t\t\tans = min(ans, st.d+distb);\n\t\t\t}\n\t\t\tREP(i, tableA[st.p].size()) {\n\t\t\t\tint np = tableA[st.p][i];\n\t\t\t\tdouble nd = st.d+dist(pa[st.p], pa[np]);\n\t\t\t\tif(LT(nd, costA[np])) {\n\t\t\t\t\tcostA[np] = nd;\n\t\t\t\t\tQ.push(state(np, nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvi tableB(NB, vi(0));\n\t\tdouble dista = dist(pa[0],pa[1]);\n\t\tREP(i, NB) {\n\t\t\tREP(j, NB) {\n\t\t\t\tif(i != j && !is_intersected_ls(pa[0], pa[1], pb[i], pb[j])) {\n\t\t\t\t\ttableB[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvd costB(NB, INF);\n\t\tcostB[0] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(st.p == 1) {\n\t\t\t\tans = min(ans, st.d+dista);\n\t\t\t}\n\t\t\tREP(i, tableB[st.p].size()) {\n\t\t\t\tint np = tableB[st.p][i];\n\t\t\t\tdouble nd = st.d+dist(pb[st.p], pb[np]);\n\t\t\t\tif(LT(nd, costB[np])) {\n\t\t\t\t\tcostB[np] = nd;\n\t\t\t\t\tQ.push(state(np, nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tif(EQ(ans, INF)) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n//// geometry ////\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n};\n\n\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn contains(a, b.p) || contains(a, b.p + b.d)\n\t\t|| contains(b, a.p) || contains(b, a.p + a.d);\n}\n\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, Na, Nb);\n\t\tauto Pa = read<P2>(Na);\n\t\tauto Pb = read<P2>(Nb);\n\t\tLineSeg ASeg = LineSeg::From2Point(Pa[0], Pa[1]);\n\t\tLineSeg BSeg = LineSeg::From2Point(Pb[0], Pb[1]);\n\n\t\tif (!isCross(ASeg, BSeg))\n\t\t{\n\t\t\tprintf(\"%.15f\", ASeg.d.length() + BSeg.d.length());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvevector<Path<double> > Ga(Na);\n\t\t\tvevector<Path<double> > Gb(Nb);\n\t\t\t\n\t\t\tREP(i, Na) REP(j, Na)\n\t\t\t{\n\t\t\t\tLineSeg s = LineSeg::From2Point(Pa[i], Pa[j]);\n\t\t\t\tif (!isCross(BSeg, s)) Ga[i].push_back({ i, j, s.d.length() });\n\t\t\t}\n\t\t\t\n\t\t\tREP(i, Nb) REP(j, Nb)\n\t\t\t{\n\t\t\t\tLineSeg s = LineSeg::From2Point(Pb[i], Pb[j]);\n\t\t\t\tif (!isCross(ASeg, s)) Gb[i].push_back({ i, j, s.d.length() });\n\t\t\t}\n\n\t\t\tdouble aconn = ASeg.d.length() + dijkstra(Gb, 0, 1).first[1];\n\t\t\tdouble bconn = BSeg.d.length() + dijkstra(Ga, 0, 1).first[1];\n\t\t\tdouble ans = min(aconn, bconn);\n\t\t\tif (ans > INF) { WRITE(-1); }\n\t\t\telse { printf(\"%.15f\", ans); }\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cross(const P &a, const P &b){\n  return imag(conj(a) * b);\n}\n\ndouble dot(const P &a, const P &b){\n  return real(conj(a) * b);\n}\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b, c) > 0) return 1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool intersectSS(const P &a, const P &b, const P &c, const P &d){\n  return\n    ccw(a, b, c) * ccw(a, b, d) <= 0 &&\n    ccw(c, d, a) * ccw(c, d, b) <= 0;\n}\n\ndouble solve(vector<P> &A, vector<P> &B){\n  int N = A.size();\n  int M = B.size();\n  double Bdist = abs(B[0] - B[1]);\n\n  if(!intersectSS(A[0], A[1], B[0], B[1])){\n    return abs(A[0] - A[1]) + Bdist;\n  }\n\n  double ans = -1;\n\n  for(int i = 2; i < N; i++){\n    if(!intersectSS(A[0], A[i], B[0], B[1]) &&\n       !intersectSS(A[i], A[1], B[0], B[1])){\n      double tmp = abs(A[0] - A[i]) + abs(A[i] - A[1]) + Bdist;\n\n      if(ans == -1 || ans > tmp){\n        ans = tmp;\n      }\n    }\n  }\n\n  for(int i = 2; i < N; i++){\n    for(int j = 2; j < N; j++){\n      if(i == j) continue;\n\n      if(!intersectSS(A[0], A[i], B[0], B[1]) &&\n         !intersectSS(A[i], A[j], B[0], B[1]) &&\n         !intersectSS(A[j], A[1], B[0], B[1])){\n        double tmp =\n          abs(A[0] - A[i]) +\n          abs(A[i] - A[j]) +\n          abs(A[j] - A[1]) +\n          Bdist;\n\n        if(ans == -1 || ans > tmp){\n          ans = tmp;\n        }\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  int N, M;\n  vector<P> A, B;\n\n  while(cin >> N >> M){\n    A.clear();\n    B.clear();\n\n    for(int i = 0; i < N; i++){\n      P p;\n      cin >> p.real() >> p.imag();\n      A.push_back(p);\n    }\n\n    for(int i = 0; i < M; i++){\n      P p;\n      cin >> p.real() >> p.imag();\n      B.push_back(p);\n    }\n\n    double ans = solve(A, B);\n    double tmp = solve(B, A);\n\n    if(ans == -1 || tmp != -1 && ans > tmp){\n      ans = tmp;\n    }\n\n    if(ans == -1){\n      printf(\"-1\\n\");\n    }\n    else{\n      printf(\"%.10f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tG a(n),b(m);\n\trep(i,n){\n\t\tint q,w;\n\t\tcin>>q>>w;\n\t\ta[i]=P(q,w);\n\t}\n\trep(i,m){\n\t\tint q,w;\n\t\tcin>>q>>w;\n\t\tb[i]=P(q,w);\n\t}\n\n\tvvd cost(n,vd(n,inf));\n\tvi used(n);\n\tvd d(n,inf);\n\td[0]=0;\n\trep(i,n)loop(j,i+1,n)if(!intersectSS(L(a[i],a[j]),L(b[0],b[1])))cost[i][j]=cost[j][i]=abs(a[i]-a[j]);\n\twhile(1){\n\t\tint v=-1;\n\t\trep(i,n)if(!used[i]&&(v==-1||d[v]>d[i]))v=i;\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\trep(i,n)cmin(d[i],d[v]+cost[i][v]);\n\t}\n\tdouble out=abs(b[0]-b[1])+d[1];\n\t\n\tcost=vvd(m,vd(m,inf));\n\tused=vi(m);\n\td=vd(m,inf);\n\td[0]=0;\n\trep(i,m)loop(j,i+1,m)if(!intersectSS(L(a[0],a[1]),L(b[i],b[j])))cost[i][j]=cost[j][i]=abs(b[i]-b[j]);\n\twhile(1){\n\t\tint v=-1;\n\t\trep(i,m)if(!used[i]&&(v==-1||d[v]>d[i]))v=i;\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\trep(i,m)cmin(d[i],d[v]+cost[i][v]);\n\t}\n\tcmin(out,abs(a[0]-a[1])+d[1]);\n\t\n\tif(out<inf)cout<<shosu(10)<<out<<endl;\n\telse cout<<-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nusing Point = std::complex<ld>;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\nbool operator<(const Point &lhs, const Point &rhs) {\n  if (lhs.real() < rhs.real() - eps) return true;\n  if (lhs.real() > rhs.real() + eps) return false;\n  return lhs.imag() < rhs.imag();\n}\n}\nPoint input_point() {\n  ld x, y;\n  std::cin >> x >> y;\n  return Point(x, y);\n}\nbool eq(ld a, ld b) { return (abs(a - b) < eps); }\nld dot(Point a, Point b) { return real(conj(a) * b); }\nld cross(Point a, Point b) { return imag(conj(a) * b); }\nint ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nclass Line {\n public:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n};\nld dot(Line l, Line m) { return dot((l.a - l.b), (m.a - m.b)); }\nclass Circle {\n public:\n  Point p;\n  ld r;\n  Circle() : p(Point(0, 0)), r(0) {}\n  Circle(Point p, ld r) : p(p), r(r) {}\n};\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\ndouble dist(double x1, double y1, double x2, double y2) {\n  return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\nstruct Elm {\n  ld d;\n  int idx;\n};\nbool operator< (const Elm &e1, const Elm &e2) {\n  return e1.d > e2.d;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n  int na, nb; cin >> na >> nb;\n  vector<Point> pa(na), pb(nb);\n  for(int i=0;i<na;++i) {\n    pa[i] = input_point();\n  }\n  for(int i=0;i<nb;++i) {\n    pb[i] = input_point();\n  }\n  priority_queue<Elm> pqa, pqb;\n  vector<ld> da(na, INF), db(nb, INF);\n  pqa.push({0, 0});\n  pqb.push({0, 0});\n  da[0] = 0;\n  db[0] = 0;\n  while(!pqa.empty()) {\n    auto now = pqa.top(); pqa.pop();\n    ld d = now.d;\n    int idx = now.idx;\n    if(da[idx] < d) continue;\n    for(int i=0;i<na;++i) {\n      if(idx == i) continue;\n      if(isis_ss(Line(pa[idx], pa[i]), Line(pb[0], pb[1]))) continue;\n      if(da[i] > d + abs(pa[idx] - pa[i])) {\n        da[i] = d + abs(pa[idx] - pa[i]);\n        pqa.push({da[i], i});\n      }\n    }\n  }\n  while(!pqb.empty()) {\n    auto now = pqb.top(); pqb.pop();\n    ld d = now.d;\n    int idx = now.idx;\n    if(db[idx] < d) continue;\n    for(int i=0;i<nb;++i) {\n      if(idx == i) continue;\n      if(isis_ss(Line(pb[idx], pb[i]), Line(pa[0], pa[1]))) continue;\n      if(db[i] > d + abs(pb[idx] - pb[i])) {\n        db[i] = d + abs(pb[idx] - pb[i]);\n        pqb.push({db[i], i});\n      }\n    }\n  }\n  if(da[1] == INF && db[1] == INF) cout << -1 << endl;\n  else cout << min(da[1] + abs(pb[0] - pb[1]), db[1] + abs(pa[0] - pa[1])) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#define inf 1e9\n#define eps 1e-10\n\nusing namespace std;\ntypedef pair<double, int> P;\n\nstruct edge{\n\tint to;\n\tdouble cost;\n\tedge(int a, double b){\n\t\tto = a, cost = b;\n\t}\n};\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n};\n\ndouble distPP(vec2d p, vec2d q)\n{\n\treturn sqrt( (p-q).dot(p-q) );\n}\n\nbool onSeg(vec2d p, vec2d q, vec2d x)\n{\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\n\nbool isCross(vec2d p, vec2d q, vec2d r, vec2d s)\n{\n\tdouble t = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn onSeg(p, q, x) && onSeg(r, s, x);\n}\n\nint NA, NB;\nvec2d PA[1005], PB[1005];\nvector<edge> G[1005];\ndouble dist[1005];\n\nvoid dijkstra()\n{\n\tfor(int i = 0; i < max(NA, NB); i++) dist[i] = inf;\n\tdist[0] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, 0) );\n\t\n\tint v; double d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> NA >> NB;\n\tfor(int i = 0; i < NA; i++){\n\t\tcin >> PA[i].x >> PA[i].y;\n\t}\n\tfor(int i = 0; i < NB; i++){\n\t\tcin >> PB[i].x >> PB[i].y;\n\t}\n\t\n\tdouble ans = inf;\n\tfor(int i = 0; i < NA; i++){\n\t\tfor(int j = 0; j < NA; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tif(isCross(PB[0], PB[1], PA[i], PA[j])) continue;\n\t\t\tG[i].push_back( edge(j, distPP(PA[i], PA[j])) );\n\t\t\tG[j].push_back( edge(i, distPP(PA[i], PA[j])) );\n\t\t}\n\t}\n\tdijkstra();\n\tans = min(ans, dist[1] + distPP(PB[0], PB[1]));\n\t\n\tfor(int i = 0; i < NA; i++) G[i].clear();\n\tfor(int i = 0; i < NB; i++){\n\t\tfor(int j = 0; j < NB; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tif(isCross(PA[0], PA[1], PB[i], PB[j])) continue;\n\t\t\tG[i].push_back( edge(j, distPP(PB[i], PB[j])) );\n\t\t\tG[j].push_back( edge(i, distPP(PB[i], PB[j])) );\n\t\t}\n\t}\n\tdijkstra();\n\tans = min(ans, dist[1] + distPP(PA[0], PA[1]));\n\t\n\tif(ans >= inf) cout << -1 << endl;\n\telse printf(\"%.11f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define N 1001\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.f,s1.s,s2.f) * ccw(s1.f,s1.s,s2.s) <= 0 &&\n           ccw(s2.f,s2.s,s1.f) * ccw(s2.f,s2.s,s1.s) <= 0 );\n}\n\ntypedef pair<double,int> Pi;\ndouble dijkstra(vector<P>A,vector<P>B){\n  vector<double>D(N,INF);\n  priority_queue<Pi,vector<Pi>,greater<Pi> >Q;\n  Q.push(Pi(0,0));\n  D[0]=0;\n  while(!Q.empty()){\n    Pi t=Q.top();Q.pop();\n    int pos=t.s;\n    double cost=t.f;\n    if(D[pos]<cost)continue;\n    if(pos==1)return cost+abs(A[0]-A[1]);    \n\n    for(int i=0;i<B.size();i++){\n      double ncost=cost+abs(B[pos]-B[i]);\n      if(isIntersect(L(A[0],A[1]),L(B[pos],B[i]))||D[i]<=ncost)continue;\n      D[i]=ncost;\n      Q.push(Pi(ncost,i));\n    }\n  }\n  return INF;\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  vector<P> A(n),B(m); \n  for(int i=0,x,y;i<n;i++)cin>>x>>y,A[i]=P(x,y);\n  for(int i=0,x,y;i<m;i++)cin>>x>>y,B[i]=P(x,y);\n  double ans=min(dijkstra(A,B),dijkstra(B,A));\n  printf(\"%.10f\\n\",ans<INF? ans:-1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\n\n#endif\n\n#include <queue>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst double inf = 1000000000.0;\nint N, M, x, y; vector<Point> v1, v2;\nint main() {\n\tcin >> N >> M;\n\tv1.resize(N);\n\tv2.resize(M);\n\tfor (int i = 0; i < N; i++) cin >> x >> y, v1[i] = Point(x, y);\n\tfor (int i = 0; i < M; i++) cin >> x >> y, v2[i] = Point(x, y);\n\tvector<double> dist1(N, inf * 2); dist1[0] = 0;\n\tpriority_queue<pair<double, int> > que1; que1.push(make_pair(0.0, 0));\n\twhile (!que1.empty()) {\n\t\tint u = que1.top().second; que1.pop();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (u == i) continue;\n\t\t\tif (!intersect(Segment(make_pair(v2[0], v2[1])), Segment(make_pair(v1[u], v1[i])), true) && dist1[i] > dist1[u] + abs(v1[u] - v1[i])) {\n\t\t\t\tdist1[i] = dist1[u] + abs(v1[u] - v1[i]);\n\t\t\t\tque1.push(make_pair(-dist1[i], i));\n\t\t\t}\n\t\t}\n\t}\n\tvector<double> dist2(M, inf * 2); dist2[0] = 0;\n\tpriority_queue<pair<double, int> > que2; que2.push(make_pair(0.0, 0));\n\twhile (!que2.empty()) {\n\t\tint u = que2.top().second; que2.pop();\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (u == i) continue;\n\t\t\tif (!intersect(Segment(make_pair(v1[0], v1[1])), Segment(make_pair(v2[u], v2[i])), true) && dist2[i] > dist2[u] + abs(v2[u] - v2[i])) {\n\t\t\t\tdist2[i] = dist2[u] + abs(v2[u] - v2[i]);\n\t\t\t\tque2.push(make_pair(-dist2[i], i));\n\t\t\t}\n\t\t}\n\t}\n\tif(dist1[1] < inf || dist2[1] < inf) cout << fixed << setprecision(12) << min(dist1[1] + abs(v2[0] - v2[1]), dist2[1] + abs(v1[0] - v1[1])) << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef double Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return abs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tdouble d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tdouble d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tdouble d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tdouble len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tdouble ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph ga(pa.size()), gb(pb.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tdouble d = abs(pa[i] - pa[j]);\n\t\tadd_edge(ga, i, j, d);\n\t\tadd_edge(ga, j, i, d);\n\t}\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tdouble d = abs(pb[i] - pb[j]);\n\t\tadd_edge(gb, i, j, d);\n\t\tadd_edge(gb, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(ga, da, 0);\n\tdijkstra(gb, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nbool intersects(P a1,P a2,P b1,P b2){\n  P a=a1-a2;\n  P b=b1-b2;\n  return cross(b1-a2,a)*cross(b2-a2,a)<=0&&cross(a1-b2,b)*cross(a2-b2,b)<=0;\n}\n\nint main(){\n  int N[2];\n  cin>>N[0]>>N[1];\n  P p[2][1000];\n  double df[2];\n  for(int i=0;i<2;i++){\n    for(int j=0;j<N[i];j++){\n      int x,y;\n      cin>>x>>y;\n      p[i][j]=P(x,y);\n    }\n    df[i]=abs(p[i][0]-p[i][1]);\n  }\n  cout.precision(99);\n  cout<<fixed;\n  if(!intersects(p[0][0],p[0][1],p[1][0],p[1][1])){\n    cout<<df[0]+df[1]<<endl;\n  }else{\n    double rd[2];\n    for(int i=0;i<2;i++){\n      double d[1000];\n      fill(begin(d),end(d),1e9);\n      d[0]=0;\n      bool u[1000]={};\n      while(!u[1]){\n\tint x=-1;\n\tfor(int j=0;j<N[i];j++){\n\t  if(!u[j]&&(x<0||d[x]>d[j])){\n\t    x=j;\n\t  }\n\t}\n\tu[x]++;\n\tfor(int j=0;j<N[i];j++){\n\t  if(!intersects(p[i^1][0],p[i^1][1],p[i][x],p[i][j])){\n\t    d[j]=min(d[j],d[x]+abs(p[i][x]-p[i][j]));\n\t  }\n\t}\n      }\n      rd[i]=d[1];\n    }\n    if(rd[0]<1e9||rd[1]<1e9){\n      cout<<min(df[0]+rd[1],df[1]+rd[0])<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n// 許容する誤差\n#define EPS (1e-10)\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\tshow(a - b);\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n\ndouble ga[1000][1000], gb[1000][1000];\n\nconst int MAX_V = 1000;\ndouble dijkstra(int n, int s, double g[MAX_V][MAX_V], int pre[MAX_V]){\n\tmemset(pre, -1, sizeof(int) * MAX_V);\n\n\tvector<double> dis(n,INF);\n\tpriority_queue<double, vector<pair<double, int>>, greater<pair<double, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tdouble cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] == INF){\n\t\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\t\tq.emplace(dis[to], to);\n\t\t\t\t\tpre[to] = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[1];\n}\n\nvector<int> getPath(int n, int pos, int pre[MAX_V]){\n\tvector<int> res;\n\twhile(pre[pos] != -1){\n\t\tres.emplace_back(pos);\n\t\tpos = pre[pos];\n\t}\n\tres.emplace_back(0);\n\treverse(all(res));\n\treturn res;\n}\n\ndouble solve(double ga[MAX_V][MAX_V], double gb[MAX_V][MAX_V], vector<Point>& a, vector<Point>& b, int na, int nb){\n\tint pre[MAX_V];\n\n\tdouble res = dijkstra(na, 0, ga, pre);\n\tvector<int> p = getPath(na, 1, pre);\n\n\tdouble g[MAX_V][MAX_V];\n\trep(i,MAX_V) rep(j,MAX_V) g[i][j] = gb[i][j];\n\trep(i,p.size() - 1){\n\t\trep(j,nb){\n\t\t\trep(k,nb){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tSegment s1 = Segment{a[p[i]], a[p[i + 1]]};\n\t\t\t\tSegment s2 = Segment{b[j], b[k]};\n\t\t\t\tif(isIntersectedLs(s1, s2)){\n\t\t\t\t\tg[j][k] = g[k][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres += dijkstra(nb, 0, g, pre);\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint na, nb;\n\tcin >> na >> nb;\n\n\tvector<Point> a(na), b(nb);\n\trep(i,na){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\ta[i] = Point(x,y);\n\t}\n\trep(i,nb){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tb[i] = Point(x,y);\n\t}\n\n\trep(i,na) rep(j,na) ga[i][j] = abs(a[i] - a[j]);\n\trep(i,nb) rep(j,nb) gb[i][j] = abs(b[i] - b[j]);\n\n\tdouble ans = min<double>(solve(ga, gb, a, b, na, nb), solve(gb, ga, b, a, nb, na));\n\tif(ans >= INF) cout << -1 << endl;\n\telse cout << fixed << setprecision(10) <<ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include<complex>\n#define EPS 1e-10\n\nusing namespace std;\n\nusing std::complex;\n\ntypedef complex<double> P;\n\nstruct S{\n  P p1;\n  P p2;\n  S(P p,P q) : p1(p), p2(q) {}\n};\n\nint ccw(P p0, P p1, P p2){\n  P d1 = p1-p0;\n  P d2 = p2-p0;\n  double dx1 = d1.real(), dx2 = d2.real();\n  double dy1 = d1.imag(), dy2 = d2.imag();\n\n  if(dx1*dy2 > dy1*dx2) return  1;\n  if(dx1*dy2 < dy1*dx2) return -1;\n  if((dx1*dx2 < 0) || (dy1*dy2 < 0)) return -1;\n  if((dx1*dx1+dy1*dy1) < (dx2*dx2+dy2*dy2)) return 1;\n  return 0;\n}\n\nbool intersect(const S &s1, const S &s2){\n  return ((ccw(s1.p1, s1.p2, s2.p1)\n           *ccw(s1.p1, s1.p2, s2.p2)) <= 0)\n    &&((ccw(s2.p1, s2.p2, s1.p1)\n        *ccw(s2.p1, s2.p2, s1.p2)) <= 0);\n}\n\nint main(){\n  int nA = getInt();\n  int nB = getInt();\n\n  vector<P> a(nA);\n  vector<P> b(nB);\n\n  REP(i,nA){\n    a[i].real() = getInt();\n    a[i].imag() = getInt();\n  }\n\n  REP(i,nB){\n    b[i].real() = getInt();\n    b[i].imag() = getInt();\n  }\n\n  double ans = 1e10;\n\n  REP(cc, 2){\n    double res = std::abs(a[0] - a[1]);\n\n    typedef pair<double, int> data;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    vector<double> memo(nB, 1e10);\n    vector<bool>   flag(nB, false);\n\n    pq.push(make_pair(0.0, 0));\n    // REP(i,nA) cout << a[i] << \" \"; cout << endl;\n    // REP(i,nB) cout << b[i] << \" \"; cout << endl;\n\n    while(pq.size()){\n      data d = pq.top(); pq.pop();\n      double dist = d.first;\n      int    pos  = d.second;\n\n      if(flag[pos]) continue;\n      flag[pos] = true;\n      if(pos == 1){\n        res += dist;\n        break;\n      }\n\n      REP(i,nB) if(!flag[i]){\n        double dd = dist + std::abs(b[pos] - b[i]);\n        if(dd < memo[i]){\n          if(!intersect(S(a[0], a[1]), S(b[pos], b[i]))){\n            memo[i] = dd;\n            pq.push(make_pair(dd, i));\n          }\n        }\n      }\n    }\n\n    if(flag[1])\n      ans = min(ans, res);\n    a.swap(b);\n    swap(nA, nB);\n  }\n\n  if(ans < 1e9) printf(\"%.11f\\n\", ans);\n  else printf(\"-1\\n\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// ¹öª¢çÈ¢ê\nWeight dijkstra2(const Graph &g, int s, int t) {\n  vector<Weight> dist(g.size(), INF);\n  dist[s] = 0;\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst] < e.weight) continue;\n    if (e.dst == t) return e.weight;\n    FOR(f,g[e.dst]) {\n      if (dist[f->dst] > e.weight+f->weight) {\n        dist[f->dst] = e.weight+f->weight;\n        Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n  return 1e18;\n}\n\nP A[1000];\nP B[1000];\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  REP(i, n) {\n    int x,y;\n    cin >> x >> y;\n    A[i] = P(x,y);\n  }\n  REP(i, m) {\n    int x,y;\n    cin >> x >> y;\n    B[i] = P(x,y);\n  }\n  double ans = 1e18;\n  if (!intersectSS(L(A[0], A[1]), L(B[0], B[1]))) {\n    ans = abs(A[0]-A[1]) + abs(B[0]-B[1]);\n  } else {\n    Graph g(n);\n    REP(i, n) {\n      REP(j, i) {\n        if (!intersectSS(L(A[i], A[j]), L(B[0], B[1]))) {\n          double dis = abs(A[i]-A[j]);\n          g[i].push_back(Edge(i, j, dis));\n          g[j].push_back(Edge(j, i, dis));\n        }\n      }\n    }\n    ans = min(ans, dijkstra2(g, 0, 1) + abs(B[0]-B[1]));\n    g.assign(m, Edges());\n    REP(i, m) {\n      REP(j, i) {\n        if (!intersectSS(L(A[0], A[1]), L(B[i], B[j]))) {\n          double dis = abs(B[i]-B[j]);\n          g[i].push_back(Edge(i, j, dis));\n          g[j].push_back(Edge(j, i, dis));\n        }\n      }\n    }\n    ans = min(ans, dijkstra2(g, 0, 1) + abs(A[0]-A[1]));\n  }\n  if (ans > 1e17) {\n    cout << -1 << endl;\n  } else {\n    printf(\"%.12f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cross (P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < - EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < - EPS );\n}\n\ndouble calc(vector<vector<double> > v) {\n    vector<double> ret(v.size(), 1e10);\n    ret[0] = 0.0;\n    priority_queue<pair<double,int>, vector<pair<double,int> >, greater<pair<double,int> > > que;\n    que.push(make_pair(0.0, 0));\n    while (que.size()) {\n        auto p = que.top(); que.pop();\n        auto dist = p.first;\n        auto now = p.second;\n        for (int i = 0; i < v.size(); i++) {\n            if (v[now][i] != 1e5) {\n                auto now_dist = dist + v[now][i];\n                auto next = i;\n                if (now_dist < ret[i]) {\n                    ret[i] = now_dist;\n                    que.push(make_pair(now_dist, i));\n                }\n            }\n        }\n    }\n\n    return ret[1];\n}\n\nint main() {\n    int A, B;\n    cin >> A >> B;\n    vector<double> ax(A), ay(A), bx(B), by(B);\n    for (int i = 0; i < A; i++) cin >> ax[i] >> ay[i];\n    for (int i = 0; i < B; i++) cin >> bx[i] >> by[i];\n\n    P a0 = P(ax[0], ay[0]);\n    P a1 = P(ax[1], ay[1]);\n    P b0 = P(bx[0], by[0]);\n    P b1 = P(bx[1], by[1]);\n\n    double ans = 1e8;\n    vector<vector<double> > va(B, vector<double>(B, 1e5));\n    for (int i = 0; i < B; i++) {\n        for (int j = i + 1; j < B; j++) {\n            P x(bx[i], by[i]), y(bx[j], by[j]);\n            if (!is_intersected_ls(a0, a1, x, y)) {\n                va[i][j] = va[j][i] = abs(x - y);\n            }\n        }\n    }\n    ans = min(ans, calc(va) + abs(a0 - a1));\n    vector<vector<double> > vb(A, vector<double>(A, 1e5));\n    for (int i = 0; i < A; i++) {\n        for (int j = i + 1; j < A; j++) {\n            P x(ax[i], ay[i]), y(ax[j], ay[j]);\n            if (!is_intersected_ls(b0, b1, x, y)) {\n                vb[i][j] = vb[j][i] = abs(x - y);\n            }\n        }\n    }\n    ans = min(ans, calc(vb) + abs(b0 - b1));\n\n    if (ans == 1e8) cout << -1 << endl;\n    else printf(\"%.10f\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nint n, m;\nvector<P> as, bs;\nbool v[1000];\n\ndouble solve(){\n\t\n\tpriority_queue<pair<double, int> > q;\n\tq.push(mp(0, 0));\n\tmemset(v, 0, sizeof(v));\n\t\n\twhile(!q.empty()){\n\t\tint c = q.top().second;\n\t\tdouble cost = q.top().first; q.pop();\n\t\t\n\t\tif(v[c]) continue;\n\t\tv[c] = 1;\n\t\tif(c == 1) return abs(as[0] - as[1]) - cost;\n\t\t\n\t\trep(i, m) if(i != c && !v[i]){\n\t\t\tif(intersectSS(L(as[0], as[1]), L(bs[c], bs[i]))) continue;\n\t\t\tq.push(mp(cost - abs(bs[c] - bs[i]), i));\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\trep(i, n){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tas.pb(P(x, y));\n\t}\n\trep(i, m){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tbs.pb(P(x, y));\n\t}\n\t\n\tdouble ans = INF;\n\trep(i, 2){\n\t\tans = min(ans, solve());\n\t\tif(i == 0) swap(as, bs), swap(n, m);\n\t}\n\tif(ans == INF) puts(\"-1\");\n\telse printf(\"%.20f\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<utility>\n#include<queue>\n\nusing namespace std;\n\nvector<double> d(1000, -1.0);\npriority_queue< pair<double, int>, vector< pair<double, int> >, greater< pair<double, int> > > que;\nvector< pair<int,  double> > edges[10000];\n\nvoid dijkstra(int start){\n    d.clear();\n    d[start] = 0.0;\n    que.push(pair<double, int>(0.0, start));\n    \n    while(!que.empty()){\n        pair<double, int> p = que.top(); que.pop();\n        for(pair<int, double> e: edges[p.second]){\n            if(d[e.first] < -0.1 || d[e.first] > d[p.second] + e.second){\n                d[e.first] = d[p.second] + e.second;\n                que.push(pair<double, double>(d[e.first], e.first));\n            }\n        }\n    }\n}\n\n// 線分交差判定\n// 3つ以上の点が一直線上に並ぶことはない\nbool are_crossing(complex<double> a1, complex<double> a2, complex<double> b1, complex<double> b2){\n    double ta = (a1.real() - a2.real()) * (b1.imag() - a1.imag()) + (a1.imag() - a2.imag()) * (a1.real() - b1.real());\n    double tb = (a1.real() - a2.real()) * (b2.imag() - a1.imag()) + (a1.imag() - a2.imag()) * (a1.real() - b2.real());\n    double tc = (b1.real() - b2.real()) * (a1.imag() - b1.imag()) + (b1.imag() - b2.imag()) * (b1.real() - a1.real());\n    double td = (b1.real() - b2.real()) * (a2.imag() - b1.imag()) + (b1.imag() - b2.imag()) * (b1.real() - a2.real());\n    return (ta*tb < 0.0 && tc*td < 0.0);\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector< complex<double> > a(n, complex<double>(0.0, 0.0)), b(m, complex<double>(0.0, 0.0));\n    double re, im;\n    for(int i=0;i<n;i++){\n        cin >> re >> im;\n        a[i].real(re); a[i].imag(im);\n    }\n    for(int i=0;i<m;i++){\n        cin >> re >> im;\n        b[i].real(re); b[i].imag(im);\n    }\n\n    double a_abs = abs(a[1] - a[0]);\n    double b_abs = abs(b[1] - b[0]);\n    double ans = a_abs + b_abs;\n\n    if(are_crossing(a[0], a[1], b[0], b[1])){\n        ans = DBL_MAX;\n        \n        // aで経由点を作る\n        if(n > 2){\n            for(int i=0;i<n;i++){\n                for(int j=i+1;j<n;j++){\n                    if(are_crossing(a[i], a[j], b[0], b[1])) continue;\n                    double cost = abs(a[i]-a[j]);\n                    edges[i].push_back(pair<int, double>(j, cost));\n                    edges[j].push_back(pair<int, double>(i, cost));\n                }\n            }\n            dijkstra(0);\n            if(d[1] > 0.0) ans = min(ans, d[1] + b_abs);\n        }\n\n        // bで経由点を作る\n        if(m > 2){\n            for(int i=0;i<n;i++) edges[i].clear();\n            for(int i=0;i<m;i++){\n                for(int j=i;j<m;j++){\n                    if(are_crossing(a[0], a[1], b[i], b[j])) continue;\n                    double cost = abs(b[i]-b[j]);\n                    edges[i].push_back(pair<int, double>(j, cost));\n                    edges[j].push_back(pair<int, double>(i, cost));\n                }\n            }\n            dijkstra(0);\n            if(d[1] > 0.0) ans = min(ans, d[1] + a_abs);\n        }\n    }\n    if(abs(ans - DBL_MAX) < 1e-10){\n        printf(\"-1\");\n    }else{\n        printf(\"%.10lf\\n\", ans);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\nconst double EPS = (1e-10);\nconst double INF = (1e15);\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b) + EPS < abs(c) ) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  return (ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n          ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0);\n}\n\ndouble dijkstra(vector< vector< pair<int, double> > > &G){\n  int N = G.size();\n  priority_queue< pair<double, int> > wait;\n  vector<double> D(N, INF);\n  wait.emplace(0, 0);\n  while(!wait.empty()){\n    double d = -wait.top().first;\n    int v = wait.top().second;\n    wait.pop();\n    if(d > D[v] + EPS) continue;\n    D[v] = d;\n    for(int i = 0; i < G[v].size(); ++i){\n      int v_ = G[v][i].first;\n      double d_ = d + G[v][i].second;\n      if(d_ < D[v_]){\n        D[v_] = d_;\n        wait.emplace(-d_, v_);\n      }\n    }\n  }\n  return D[1];\n}\n\ndouble solve(vector<P> &A, vector<P> &B){\n  L l = L(A[0], A[1]);\n  int Nb = B.size();\n  vector< vector< pair<int, double> > > G(Nb);\n  for(int i = 0; i < Nb; ++i){\n    for(int j = 0; j < i; ++j){\n      if(is_cross(l, L(B[i], B[j]))) continue;\n      G[i].emplace_back(j, abs(B[i] - B[j]));\n      G[j].emplace_back(i, abs(B[i] - B[j]));\n    }\n  }\n  return dijkstra(G) + abs(A[0] - A[1]);\n}\n\nint main(){\n  int Na, Nb;\n  cin >> Na >> Nb;\n  vector<P> A(Na), B(Nb);\n  for(int i = 0; i < Na; ++i){\n    double x, y;\n    cin >> x >> y;\n    A[i] = P(x, y);\n  }\n  for(int i = 0; i < Nb; ++i){\n    double x, y;\n    cin >> x >> y;\n    B[i] = P(x, y);\n  }\n  double ans = min(solve(A, B), solve(B, A));\n  if(ans >= INF - EPS) cout << -1 << endl;\n  else printf(\"%.12f\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\n\nvoid solve(){\n    int n[2];\n    REP(i, 2) {\n        cin >> n[i];\n    }\n    vector<Point> vertexs[2];\n    REP(i, 2) {\n        REP(q, n[i]) {\n            long double a, b;\n            cin >> a >> b;\n            vertexs[i].push_back(Point{ a,b });\n        }\n    }\n    long double ans = 1e18;\n    REP(i, 2) {\n        long double dist[2000] = {};\n        REP(q, 2000) {\n            dist[q] = 1e18;\n        }\n        dist[0] = abs(vertexs[0][1] - vertexs[0][0]);\n        priority_queue<pair<long double, int>, vector<pair<long double, int>>, greater<pair<long double, int>>> next;\n        next.push(mp(dist[0], 0));\n        while (next.empty() == false) {\n            pair<long double, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (int q = 0; q < vertexs[1].size(); ++q) {\n                if (now.second == q) continue;\n                if (is_intersected_ls(mp(vertexs[0][0], vertexs[0][1]), mp(vertexs[1][now.second], vertexs[1][q])) == 1) continue;\n                long double tmp = now.first + abs(vertexs[1][now.second] - vertexs[1][q]);\n                if (dist[q] > tmp) {\n                    dist[q] = tmp;\n                    next.push(mp(tmp, q));\n                }\n            }\n        }\n        ans = min(ans, dist[1]);\n        swap(vertexs[0], vertexs[1]);\n    }\n    if (ans == 1e18) {\n        ans = -1;\n    }\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    double dist(const Point& p) const{\n        return sqrt((double)(y - p.y) * (y - p.y) + (x - p.x) * (x - p.x));\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    long long cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) <= 0) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) <= 0);\n}\n\nclass Edge\n{\npublic:\n    int to;\n    double cost;\n    Edge(){};\n    Edge(int to0, double cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<double>& dist)\n{\n    const double EPS = 1.0e-12;\n\n    dist.assign(edges.size(), DBL_MAX);\n    dist[start] = 0.0;\n    priority_queue<pair<double,int> ,vector<pair<double,int> >, greater<pair<double,int> > > q;\n    q.push(make_pair(0.0, start));\n\n    while(!q.empty()){\n        pair<double, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] + EPS < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost + EPS < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    vector<int> n(2);\n    cin >> n[0] >> n[1];\n\n    vector<vector<Point> > p(2);\n    for(int i=0; i<2; ++i){\n        p[i].resize(n[i]);\n        for(int j=0; j<n[i]; ++j){\n            cin >> p[i][j].x >> p[i][j].y;\n        }\n    }\n\n    double ret = DBL_MAX;\n    vector<vector<vector<Edge> > > edges(2);\n    for(int i=0; i<2; ++i){\n        vector<vector<Edge> > edges(n[i]);\n        Point p1 = p[i^1][0];\n        Point p2 = p[i^1][1];\n        for(int j=0; j<n[i]; ++j){\n            for(int k=0; k<n[i]; ++k){\n                if(j != k && !segmentsCollide(p1, p2, p[i][j], p[i][k])){\n                    edges[j].push_back(Edge(k, p[i][j].dist(p[i][k])));\n                }\n            }\n        }\n\n        vector<double> dist;\n        shortestPath(edges, 0, dist);\n\n        ret = min(ret, p1.dist(p2) + dist[1]);\n    }\n\n    if(ret > DBL_MAX/2)\n        cout << -1 << endl;\n    else\n        printf(\"%.12f\\n\", ret);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n// 許容する誤差\n#define EPS (1e-10)\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\tshow(a - b);\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n\ndouble ga[1000][1000], gb[1000][1000];\n\nconst int MAX_V = 1000;\ndouble dijkstra(int n, int s, double g[MAX_V][MAX_V], int pre[MAX_V]){\n\tmemset(pre, -1, sizeof(int) * MAX_V);\n\n\tvector<double> dis(n,INF);\n\tpriority_queue<double, vector<pair<double, int>>, greater<pair<double, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tdouble cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] == INF){\n\t\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\t\tq.emplace(dis[to], to);\n\t\t\t\t\tpre[to] = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[1];\n}\n\nvector<int> getPath(int n, int pos, int pre[MAX_V]){\n\tvector<int> res;\n\twhile(pre[pos] != -1){\n\t\tres.emplace_back(pos);\n\t\tpos = pre[pos];\n\t}\n\tres.emplace_back(0);\n\treverse(all(res));\n\treturn res;\n}\n\ndouble solve(double ga[MAX_V][MAX_V], double gb[MAX_V][MAX_V], vector<Point>& a, vector<Point>& b, int na, int nb){\n\tint pre[MAX_V];\n\n\tdouble res = dijkstra(na, 0, ga, pre);\n\tvector<int> p = getPath(na, 1, pre);\n\n\tdouble g[MAX_V][MAX_V];\n\trep(i,MAX_V) rep(j,MAX_V) g[i][j] = gb[i][j];\n\trep(i,p.size() - 1){\n\t\trep(j,nb){\n\t\t\trep(k,nb){\n\t\t\t\tif(j == k) continue;\n\t\t\t\tSegment s1 = Segment{a[p[i]], a[p[i + 1]]};\n\t\t\t\tSegment s2 = Segment{b[j], b[k]};\n\t\t\t\tif(isIntersectedLs(s1, s2)){\n\t\t\t\t\tg[j][k] = g[k][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres += dijkstra(nb, 0, g, pre);\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint na, nb;\n\tcin >> na >> nb;\n\n\tvector<Point> a(na), b(nb);\n\trep(i,na){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\ta[i] = Point(x,y);\n\t}\n\trep(i,nb){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tb[i] = Point(x,y);\n\t}\n\n\trep(i,na) rep(j,na) ga[i][j] = abs(a[i] - a[j]);\n\trep(i,nb) rep(j,nb) gb[i][j] = abs(b[i] - b[j]);\n\n\tdouble ans = min<double>(solve(ga, gb, a, b, na, nb), solve(gb, ga, b, a, nb, na));\n\tif(ans >= INF) cout << -1 << endl;\n\telse cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst double INF = 1e12;\ntypedef complex<double> P;\n\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\nbool ssIntersect(const P& ap, const P& aq, const P& bp, const P& bq){\n\treturn cross(aq-ap, bp-ap)*cross(aq-ap, bq-ap) < 0 &&\n    \t   cross(bq-bp, ap-bp)*cross(bq-bp, aq-bp) < 0;\n}\n\ndouble solve(const vector<P>& pa, const vector<P>& pb){\n\tint n = pb.size();\n\tvector<int> visit(n, 0);\n\tvector<double> dist(n, INF); dist[0] = 0;\n\ttypedef pair<double, int> Node;\n\tpriority_queue< Node, vector<Node>, greater<Node> > qu; qu.push(make_pair(0, 0));\n\twhile(!qu.empty()){\n\t\tNode nd = qu.top(); qu.pop();\n\t\tint pos = nd.second;\n\t\tdouble cost = nd.first;\n\t\tif(visit[pos]) continue;\n\t\tvisit[pos] = 1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(visit[i]) continue;\n\t\t\tif(ssIntersect(pb[pos], pb[i], pa[0], pa[1])) continue;\n\t\t\tdouble ncost = cost + abs(pb[pos]-pb[i]);\n\t\t\tif(ncost < dist[i]){\n\t\t\t\tdist[i] = ncost;\n\t\t\t\tqu.push(make_pair(ncost, i));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[1] + abs(pa[0]-pa[1]);\n}\n\nint main(){\n\tint NA, NB;\n\twhile(cin >> NA >> NB){\n\t\tvector<P> pA(NA), pB(NB);\n\t\tfor(int i=0;i<NA;i++) cin >> pA[i].real() >> pA[i].imag();\n\t\tfor(int i=0;i<NB;i++) cin >> pB[i].real() >> pB[i].imag();\n\t\tdouble res = min(solve(pA, pB), solve(pB, pA));\n\t\tif(res > 1e10) cout << -1 << endl;\n\t\telse printf(\"%.10lf\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n\nint Na, Nb;\nlong long xa[1002], ya[1002];\nlong long xb[1002], yb[1002];\n\n\ndouble dist(int i, int j, int side=0) {\n\tif (side == 0) return sqrt((xa[i] - xa[j]) * (xa[i] - xa[j]) + (ya[i] - ya[j]) * (ya[i] - ya[j]));\n\treturn sqrt((xb[i] - xb[j]) * (xb[i] - xb[j]) + (yb[i] - yb[j]) * (yb[i] - yb[j]));\n}\n\ntypedef complex<ll> P;  // Point\n\n// 外積　cross(a,b) = |a||b|sinθ\nll cross(P a, P b) {\n\treturn (conj(a)*b).imag();\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n\treturn cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < 0 &&\n\t\tcross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < 0;\n}\n\ndouble dijkstra() {\n\tvector<double> d(Na, -1);\n\tpriority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> que;\n\td[0] = 0;\n\tque.emplace(0, 0);\n\twhile (!que.empty()) {\n\t\tauto p = que.top(); que.pop();\n\t\tif (d[p.second] < p.first) continue;\n\t\tif(p.second == 1) {\n\t\t\treturn p.first + dist(0, 1, 1);\n\t\t}\n\t\tfor(int to=0;to<Na;to++) {\n\t\t\tif (p.second == to) continue;\n\t\t\tif (isecSS(P(xa[p.second], ya[p.second]), P(xa[to], ya[to]), P(xb[0], yb[0]), P(xb[1], yb[1]))) continue;\n\t\t\tdouble nc = p.first + dist(p.second, to);\n\t\t\tif (d[to] < 0 || d[to] > nc) {\n\t\t\t\td[to] = nc;\n\t\t\t\tque.emplace(nc, to);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tcin >> Na >> Nb;\n\n\tfor(int i=0;i<Na;i++) {\n\t\tcin >> xa[i] >> ya[i];\n\t}\n\tfor(int i=0;i<Nb;i++) {\n\t\tcin >> xb[i] >> yb[i];\n\t}\n\n\tdouble ans = dijkstra();\n\tfor(int i=0;i<max(Na, Nb);i++) {\n\t\tswap(xa[i], xb[i]);\n\t\tswap(ya[i], yb[i]);\n\t}\n\tswap(Na, Nb);\n\n\tif(ans < 0) {\n\t\tans = dijkstra();\n\t}else {\n\t\tdouble ans_b = dijkstra();\n\t\tif(ans_b >= 0) {\n\t\t\tans_b = min(ans, ans_b);\n\t\t}\n\t}\n\n\tif(ans < 0) {\n\t\tcout << -1 << endl;\n\t}else {\n\t\tprintf(\"%.12f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define minch(a,b) a=min(a,b)\n#define fi first\n#define se second\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nD dot(P a,P b){ return (conj(a)*b).X; }\n\nstruct L : public vector<P> {\n  L(const P& a,const P& b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nint ccw(P a,P b,P c){\n  b=b-a; c=c-a;\n  if(cross(b,c)>0)return 1;\n  if(cross(b,c)<0)return -1;\n  if(dot(b,c)<0) return +2;\n  if(norm(b)<norm(c)) return -2;\n  return 0;\n}\n\nbool intersectSS(L s,L t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\nint na,nb;\nP pa[1111],pb[1111];\nD dist[1111];\ntypedef pair<D,int> pdi;\n\nint main(int argc, char const *argv[]){\n\n    cin>>na>>nb;\n    rep(i,na){\n      D x,y;\n      cin>>x>>y;\n      pa[i]=P(x,y);\n    }\n    rep(i,nb){\n      D x,y;\n      cin>>x>>y;\n      pb[i]=P(x,y);\n    }\n    D res=inf;\n    {\n      rep(i,1111)dist[i]=inf;\n      priority_queue<pdi,vector<pdi>,greater<pdi> > que;\n      que.push(pdi(0.0,0));\n      while(que.size()){\n        D nd=que.top().fi; int nv=que.top().se;\n        que.pop();\n        if(dist[nv]!=inf)continue;\n        dist[nv]=nd;\n        rep(i,na){\n          if(i==nv||intersectSS(L(pb[0],pb[1]),L(pa[nv],pa[i])))continue;\n          que.push(pdi(nd+abs(pa[nv]-pa[i]),i));\n        }\n      }\n      minch(res,abs(pb[0]-pb[1])+dist[1]);\n    }\n    {\n      rep(i,1111)dist[i]=inf;\n      priority_queue<pdi,vector<pdi>,greater<pdi> > que;\n      que.push(pdi(0.0,0));\n      while(que.size()){\n        D nd=que.top().fi; int nv=que.top().se;\n        que.pop();\n        if(dist[nv]!=inf)continue;\n        dist[nv]=nd;\n        rep(i,nb){\n          if(i==nv||intersectSS(L(pa[0],pa[1]),L(pb[nv],pb[i])))continue;\n          que.push(pdi(nd+abs(pb[nv]-pb[i]),i));\n        }\n      }\n      minch(res,abs(pa[0]-pa[1])+dist[1]);\n    }\n    if(res==inf)printf(\"-1\");\n    else printf(\"%.15Lf\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<iomanip>\n#include<cstdio>\n#include<cassert>\n#include<queue>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define MAX 2000\n#define pow2(a) ((a)*(a))\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\n\nusing namespace std;\n\n//\n\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -inf,double y = -inf): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(x,p.x)?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-inf,-inf),Point p2 = Point(-inf,-inf)):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n\n//\n\nstruct Poxas7\n{\n  int cur;\n  double cost;\n  Poxas7(int cur=inf,double cost=inf):cur(cur),cost(cost){}\n  bool operator < (const Poxas7 &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint path[MAX],AN,BN,N;\ndouble mincost[MAX];\nvector<Point> vec[2];\n\ndouble dijkstra(vector<Point> &vec,int s,int t,vector<Segment> &ban)\n{\n  N = vec.size();\n  rep(i,N)path[i] = -1,mincost[i] = inf;\n  priority_queue<Poxas7> Q;\n  Q.push(Poxas7(s,0));\n  mincost[s] = 0;\n  while(!Q.empty())\n    {\n      Poxas7 pox = Q.top(); Q.pop();\n\n      if(pox.cur == t)\n\t{\n\t  return pox.cost;\n\t}\n\n      rep(next,N)\n\t{\n\t  if(s == next)continue;\n\t  Segment seg = Segment(vec[pox.cur],vec[next]);\t  \n\t  bool out = false;\n\t  rep(i,ban.size())\n\t    if(intersectSS(ban[i],seg))\n\t      {\n\t\tout = true;\n\t\tbreak;\n\t      }\n\t  if(out)continue;\n\n\t  if(mincost[next] > pox.cost + abs(vec[pox.cur]-vec[next]))\n\t    {\n\t      path[next] = pox.cur;\n\t      mincost[next] = pox.cost + abs(vec[pox.cur]-vec[next]);\n\t      Q.push(Poxas7(next,mincost[next]));\n\t    }\n\t}\n\n    }\n  return -1;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&AN,&BN) != EOF)\n    {\n      rep(i,2)vec[i].clear();\n      vec[0].resize(AN);\n      vec[1].resize(BN);\n      rep(i,AN)cin >> vec[0][i].x >> vec[0][i].y;\n      rep(i,BN)cin >> vec[1][i].x >> vec[1][i].y;      \n\n      double ans = inf;\n      rep(i,2)\n\t{\n\t  vector<Segment> ban;\n\t  double cost = dijkstra(vec[i],0,1,ban);\n\t  if(cost == -1)continue;\n\t  int cur = 1;\n\n\t  for(int next=path[cur];cur != 0;cur=next,next=path[cur])\n\t    {\n\t      ban.push_back(Segment(vec[i][cur],vec[i][next]));\n\t    }\n\n\t  double cost2 = dijkstra(vec[(i+1)%2],0,1,ban);\n\t  if(cost2 == -1)continue;\n\t  ans = min(ans,cost+cost2);\n\t}\n\n      if(ans == inf)cout << \"-1\" << endl;      \n      else          cout << setiosflags(ios::fixed) << setprecision(15) << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS)return 0;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint na;\nint nb;\nP ap[1001];\nP bp[1001];\nconst int INF=1000000000;\n\nint main(){\n\n\tcin>>na>>nb;\n\tfor(int i=0;i<na;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tap[i]=P(x,y);\n\t}\n\tfor(int i=0;i<nb;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tbp[i]=P(x,y);\n\t}\n\t// ½s,Ü½ÍNXµÈ¢\n\tif(!is_intersected_ls(ap[0],ap[1],bp[0],bp[1])){\n\t\tdouble res=abs(ap[0]-ap[1])+abs(bp[0]-bp[1]);\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n\telse{\n\t\tdouble res=INF;\n\t\t// apðÅèµÄbpð®©·\n\t\tfor(int i=2;i<nb;i++)\n\t\t\tif(!is_intersected_ls(ap[0],ap[1],bp[0],bp[i])&&!is_intersected_ls(ap[0],ap[1],bp[i],bp[1]))\n\t\t\t\tres=min(res,abs(ap[0]-ap[1])+abs(bp[0]-bp[i])+abs(bp[1]-bp[i]));\n\t\tfor(int i=2;i<nb;i++){\n\t\t\tfor(int j=2;j<nb;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(!is_intersected_ls(ap[0],ap[1],bp[0],bp[i])&&!is_intersected_ls(ap[0],ap[1],bp[i],bp[j])&&!is_intersected_ls(ap[0],ap[1],bp[j],bp[1]))\n\t\t\t\t\tres=min(res,abs(ap[0]-ap[1])+abs(bp[0]-bp[i])+abs(bp[1]-bp[j])+abs(bp[i]-bp[j]));\n\t\t\t}\n\t\t}\n\t\t// bpðÅèµÄapð®©·\n\t\tfor(int i=2;i<na;i++)\n\t\t\tif(!is_intersected_ls(bp[0],bp[1],ap[0],ap[i])&&!is_intersected_ls(bp[0],bp[1],ap[i],ap[1]))\n\t\t\t\tres=min(res,abs(bp[0]-bp[1])+abs(ap[0]-ap[i])+abs(ap[1]-ap[i]));\n\t\tfor(int i=2;i<na;i++){\n\t\t\tfor(int j=2;j<na;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(!is_intersected_ls(bp[0],bp[1],ap[0],ap[i])&&!is_intersected_ls(bp[0],bp[1],ap[i],ap[j])&&!is_intersected_ls(bp[0],bp[1],ap[j],ap[1]))\n\t\t\t\t\tres=min(res,abs(bp[0]-bp[1])+abs(ap[0]-ap[i])+abs(ap[1]-ap[j])+abs(ap[i]-ap[j]));\n\t\t\t}\n\t\t}\n\t\tif(EQ(res,INF))cout<<-1<<endl;\n\t\telse printf(\"%.10f\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ef emplace_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = std::uint32_t;\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing ld = long double;\n\ntemplate<typename T, size_t H, size_t W>\nusing matrix = std::array<std::array<T, W>, H>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(all(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(all(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(c); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (x != r.x) return x < r.x;\n\t\treturn y < r.y;\n\t}\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-12;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n// }}}\n\nusing pr = pair<Real, int>;\n\nint na, nb;\nReal xa[1000], ya[1000], xb[1000], yb[1000];\nReal da[1000], db[1000];\n\nint main()\n{\n\tcin >> na >> nb;\n\trep(i, na) cin >> xa[i] >> ya[i];\n\trep(i, nb) cin >> xb[i] >> yb[i];\n\t\n\tpriority_queue<pr, vector<pr>, greater<pr>> pq;\n\n\tfill_n(da, 1000, 1e9);\n\tda[0] = 0.0;\n\tpq.emplace(0.0, 0);\n\twhile (pq.size()){\n\t\tint v;\n\t\tReal sum;\n\t\ttie(sum, v) = pq.top(); pq.pop();\n\t\tif (da[v] < sum) continue;\n\t\trep(to, na){\n\t\t\tif (v == to) continue;\n\t\t\tSegment s(Point(xa[v], ya[v]), Point(xa[to], ya[to]));\n\t\t\tSegment t(Point(xb[0], yb[0]), Point(xb[1], yb[1]));\n\t\t\tif (intersect(s, t)) continue;\n\t\t\tReal cost = abs(s[1] - s[0]);\n\t\t\tif (da[to] > sum + cost){\n\t\t\t\tda[to] = sum + cost;\n\t\t\t\tpq.emplace(sum + cost, to);\n\t\t\t}\n\t\t}\n\t}\n\n\tfill_n(db, 1000, 1e9);\n\tdb[0] = 0.0;\n\tpq.emplace(0.0, 0);\n\twhile (pq.size()){\n\t\tint v;\n\t\tReal sum;\n\t\ttie(sum, v) = pq.top(); pq.pop();\n\t\tif (db[v] < sum) continue;\n\t\trep(to, nb){\n\t\t\tif (v == to) continue;\n\t\t\tSegment s(Point(xb[v], yb[v]), Point(xb[to], yb[to]));\n\t\t\tSegment t(Point(xa[0], ya[0]), Point(xa[1], ya[1]));\n\t\t\tif (intersect(s, t)) continue;\n\t\t\tReal cost = abs(s[1] - s[0]);\n\t\t\tif (db[to] > sum + cost){\n\t\t\t\tdb[to] = sum + cost;\n\t\t\t\tpq.emplace(sum + cost, to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tSegment s(Point(xa[0], ya[0]), Point(xa[1], ya[1]));\n\tSegment t(Point(xb[0], yb[0]), Point(xb[1], yb[1]));\n\tReal res = 1e9;\n\tchmin(res, abs(s[1] - s[0]) + db[1]);\n\tchmin(res, abs(t[1] - t[0]) + da[1]);\n\tif (res == 1e9) cout << -1 << endl;\n\telse printf(\"%.20Lf\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n// 許容する誤差\n#define EPS (1e-10)\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\tshow(a - b);\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n\ndouble ga[1000][1000], gb[1000][1000];\n\nconst int MAX_V = 1000;\ndouble dijkstra(int n, int s, double g[MAX_V][MAX_V]){\n\tvector<double> dis(n,INF);\n\tpriority_queue<double, vector<pair<double, int>>, greater<pair<double, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tdouble cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] == INF){\n\t\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\t\tq.emplace(dis[to], to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[1];\n}\n\ndouble solve(double g[MAX_V][MAX_V], Segment s, vector<Point>& a){\n\tint n = a.size();\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i == j) continue;\n\t\t\tif(isIntersectedLs(s, Segment{a[i], a[j]})){\n\t\t\t\tg[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\treturn dijkstra(n, 0, g);\n}\n\nvoid input(vector<Point>& a, int n){\n\trep(i,n){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\ta[i] = Point(x,y);\n\t}\n}\n\nvoid culDist(double g[MAX_V][MAX_V], vector<Point>& a, int n){\n\trep(i,n) rep(j,n) g[i][j] = abs(a[i] - a[j]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint na, nb;\n\tcin >> na >> nb;\n\n\tvector<Point> a(na), b(nb);\n\tinput(a, na);\n\tinput(b, nb);\n\n\tculDist(ga, a, na);\n\tculDist(gb, b, nb);\n\n\tdouble adis = ga[0][1];\n\tdouble bdis = gb[0][1];\n\n\tdouble ans = min<double>(\n\t\t\tsolve(gb, Segment{a[0], a[1]}, b) + adis,\n\t\t\tsolve(ga, Segment{b[0], b[1]}, a) + bdis\n\t\t\t);\n\tcout << fixed << setprecision(10) <<ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\n#include <queue>\n#include <utility>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\n\nint main(){\n    int na, nb;\n    cin >> na >> nb;\n    VP a(na), b(nb);\n    for(int i=0; i<na; i++){\n        int x,y;\n        cin >> x >> y;\n        a[i] = P(x,y);\n    }\n    for(int i=0; i<nb; i++){\n        int x,y;\n        cin >> x >> y;\n        b[i] = P(x,y);\n    }\n\n    double ans = INF;\n    for(int r=0; r<2; r++){\n        priority_queue<pair<double, int> > wait;\n        wait.push(make_pair(0, 0));\n        vector<double> mindist(na, INF);\n        mindist[0] = 0;\n        while(!wait.empty()){\n            int pos = wait.top().second;\n            double dist = -wait.top().first;\n            wait.pop();\n            if(dist > mindist[pos] +EPS) continue;\n            if(pos==1){\n                ans = min(ans, dist +abs(b[1]-b[0]));\n                break;\n            }\n            for(int i=0; i<na; i++){\n                if(i==pos || intersectSS(L(a[pos], a[i]), L(b[0], b[1]))) continue;\n                double ndist = dist + abs(a[i] -a[pos]);\n                if(ndist +EPS < mindist[i]){\n                    mindist[i] = ndist;\n                    wait.push(make_pair(-ndist, i));\n                }\n            }\n        }\n        swap(na, nb);\n        swap(a, b);\n    }\n    if(ans==INF){\n        cout << -1 << endl;\n    }else{\n        cout << fixed;\n        cout << setprecision(10);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2334&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;return lhs.imag() < rhs.imag();\n\t}\n}\n// ????????\\???\nPoint input_point() { ld x, y;cin >> x >> y;return Point(x, y); }\n\n// ????????????????????????\nbool eq(ld a, ld b) { return (abs(a - b) < eps); }\n\n// ??????\nld dot(Point a, Point b) { return real(conj(a) * b); }\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor (int i = 0;i < n;i++) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor (int i = 0;i < n;i++) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// ??????\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// ????????????\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tfor (int i = 0;i < n;i++) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint NA, NB;cin >> NA >> NB;\n\tPolygon pa, pb;\n\tvector<vector<ld>> da(NA, vector<ld>(NA, INF)), db(NB, vector<ld>(NB, INF));\n\tfor (int i = 0; i < NA;i++) {\n\t\tda[i][i] = 0;\n\t\tld x, y;cin >> x >> y; pa.push_back(Point(x, y));\n\t}\n\tfor (int i = 0; i < NB; i++) {\n\t\tdb[i][i] = 0;\n\t\tld x, y; cin >> x >> y; pb.push_back(Point(x, y));\n\t}\n\n\tfor (int i = 0; i < NA;i++)for (int j = 0; j < NA;j++) {\n\t\tda[i][j] = da[j][i] = abs(pa[i] - pa[j]);\n\t}\n\tfor (int i = 0; i < NB;i++)for (int j = 0; j < NB;j++) {\n\t\tdb[i][j] = db[j][i] = abs(pb[i] - pb[j]);\n\t}\n\n\tld ans = INF;\n\tld sum = 0;\n\t/*    length of line segment A - B */\n\tsum += abs(pa[0] - pa[1]);\n\tLine la(pa[0], pa[1]);\n\tvector<vector<int>> fb(NB, vector<int>(NB, 0));\n\tfor (int i = 0; i < NB;i++) {\n\t\tfor (int j = i+1; j < NB;j++) {\n\t\t\tLine l(pb[i], pb[j]);\n\t\t\tif (isis_ss(la, l)) {\n\t\t\t\tfb[i][j] = fb[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q; q.push(0);\n\tvector<ld> d(NB, INF);\n\td[0] = 0;\n\twhile (!q.empty()) {\n\t\tint idx = q.front(); q.pop();\n\t\tfor (int i = 0; i < NB;i++) {\n\t\t\tif (i == idx)continue;\n\t\t\tif (fb[idx][i] == 1)continue;\n\t\t\tif (d[i] > d[idx] + db[idx][i]) {\n\t\t\t\td[i] = d[idx] + db[idx][i];\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tif (d[1] != INF) { sum += d[1]; ans = min(ans, sum); }\n\t\n\t/*    length of line segment C - D*/\n\tsum = abs(pb[0] - pb[1]);\n\tLine lb(pb[0], pb[1]);\n\tvector<vector<int>> fa(NA, vector<int>(NA, 0));\n\tfor (int i = 0; i < NA;i++) {\n\t\tfor (int j = i + 1; j < NA;j++) {\n\t\t\tLine l(pa[i], pa[j]);\n\t\t\tif (isis_ss(lb, l)) {\n\t\t\t\tfa[i][j] = fa[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tq.push(0);\n\td.assign(NA, INF);\n\td[0] = 0;\n\twhile (!q.empty()) {\n\t\tint idx = q.front(); q.pop();\n\t\tfor (int i = 0; i < NA;i++) {\n\t\t\tif (i == idx)continue;\n\t\t\tif (fa[idx][i] == 1)continue;\n\t\t\tif (d[i] > d[idx] + da[idx][i]) {\n\t\t\t\td[i] = d[idx] + da[idx][i];\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tif (d[1] != INF) { sum += d[1]; ans = min(ans, sum); }\n\tif (ans == INF) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n\ntypedef pair<double, int> P;\n\nconst double inf = 1e9;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ???\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\n// ????§???¢\ntypedef vector<Point> Polygon;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}  \n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2)\n{\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\n\n// ???????????????????????¢??¬?????????????????????????????????\nbool mergeIfAble(Segment &s1, Segment s2)\n{\n  if(abs(cross(s1.p2 - s1.p1, s2.p2 - s2.p1)) > EPS) return false;\n  if(ccw(s1.p1, s2.p1, s1.p2) == COUNTER_CLOCKWISE ||\n     ccw(s1.p1, s2.p1, s1.p2) == CLOCKWISE) return false;\n  if(ccw(s1.p1, s1.p2, s2.p1) == ONLINE_FRONT ||\n     ccw(s2.p1, s2.p2, s1.p1) == ONLINE_FRONT) return false;\n  s1 = Segment(min(s1.p1, s2.p1), max(s1.p2, s2.p2));\n  return true;\n}\nvoid mergeSegments(vector<Segment>& segs)\n{\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].p2 < segs[i].p1) swap(segs[i].p1, segs[i].p2);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i+1; j < segs.size(); j++) {\n      if(mergeIfAble(segs[i], segs[j])) {\n\tsegs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// ????????¢??¬???????????????\nstruct edge\n{\n  int to;\n  double cost;\n  edge(){}\n  edge(int to, double cost):to(to), cost(cost){}\n\n  bool operator < (const edge& e) const {\n    return lt(cost, e.cost);\n  }\n};\ntypedef vector< vector<edge> > Graph;\n\nGraph segmentArrangement(vector<Segment>& segs, vector<Point>& ps)\n{\n  for(int i = 0; i < segs.size(); i++) {\n    ps.push_back(segs[i].p1);\n    ps.push_back(segs[i].p2);\n    for(int j = i+1; j < segs.size(); j++) {\n      if(intersect(segs[i], segs[j])) ps.push_back(getCrossPoint(segs[i], segs[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  Graph graph(ps.size());\n  for(int i = 0; i < segs.size(); i++) {\n    vector< pair<double, int> > ls;\n    for(int j = 0; j < ps.size(); j++) {\n      if(intersect(segs[i], ps[j])) {\n\tls.emplace_back(getDistanceSP(segs[i], ps[j]), j);\n      }\n    }\n    sort(ls.begin(), ls.end());\n    for(int j = 0; j+1 < ls.size(); j++) {\n      int u = ls[j].second, v = ls[j+1].second;\n      graph[u].emplace_back(v, getDistance(ps[u], ps[v]));\n      graph[v].emplace_back(u, getDistance(ps[u], ps[v]));\n    }\n  }\n  return graph;\n}\n\ndouble dijkstra(vector<Point> p, Point a, Point b)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  vector<double> mincost(p.size(), inf);  \n  que.push(P(0.0, 0));\n  mincost[0] = 0.0;\n  while(!que.empty()) {\n    double c; int now;\n    tie(c, now) = que.top(); que.pop();\n    if(now == 1) return c + getDistance(a, b);\n    if(mincost[now] < c) continue;\n    for(int i = 0; i < p.size(); i++) {\n      if(intersect(p[now], p[i], a, b)) continue;\n      if(getDistance(p[now], p[i]) + c < mincost[i]) {\n\tmincost[i] = getDistance(p[now], p[i]) + c;\n\tque.push(P(mincost[i], i));\n      }\n    }\n  }\n  return inf;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int Na, Nb;\n  cin >> Na >> Nb;\n  vector<Point> pa(Na), pb(Nb);\n  rep(i, Na) cin >> pa[i].x >> pa[i].y;\n  rep(i, Nb) cin >> pb[i].x >> pb[i].y;\n\n  double a_st = dijkstra(pb, pa[0], pa[1]);\n  double b_st = dijkstra(pa, pb[0], pb[1]);\n\n  if(a_st != inf || b_st != inf) cout << min(a_st, b_st) << endl;\n  else cout << -1 << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing C = pair<ll, ll>;\nusing L = pair<C, C>;\n\nll cross(const C a, const C b)\n{\n    return a.first * b.second - a.second * b.first;\n}\nll dot(const C a, const C b)\n{\n    return a.first * b.first + a.second * b.second;\n}\nll normSq(const C a)\n{\n    return a.first * a.first + a.second * a.second;\n}\nld norm(const L a)\n{\n    const ll dx = a.first.first - a.second.first;\n    const ll dy = a.first.second - a.second.second;\n    return hypot(dx, dy);\n}\nint ccw(C a, C b, C c)\n{\n    b = {b.first - a.first, b.second - a.second};\n    c = {c.first - a.first, c.second - a.second};\n    if (cross(b, c) > 0)\n        return +1;  // counter clockwise\n    if (cross(b, c) < 0)\n        return -1;  // clockwise\n    if (dot(b, c) < 0)\n        return +2;  // c--a--b on line\n    if (normSq(b) < normSq(c))\n        return -2;  // a--b--c on line\n    return 0;       //b--a--c on line\n}\nbool intersectSS(const L s, const L t)\n{\n    return ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 and ccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\nstruct CostGraph {\n    using T = ld;\n    CostGraph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    struct Edge {\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        const int from;\n        const int to;\n        const T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge(to, from, cost));\n        edge[to].push_back(Edge{to, from, cost});\n        rev_edge[from].push_back(Edge(from, to, cost));\n    }\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n    const int V;\n};\nvoid Dijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = 1e8;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int A, B;\n    cin >> A >> B;\n    vector<C> a(A);\n    for (int i = 0; i < A; i++) {\n        ll x, y;\n        cin >> x >> y;\n        a[i] = {x, y};\n    }\n    const L al = L{a[0], a[1]};\n    vector<C> b(B);\n    for (int i = 0; i < B; i++) {\n        ll x, y;\n        cin >> x >> y;\n        b[i] = {x, y};\n    }\n    ld mini = 1e8;\n    const L bl = L{b[0], b[1]};\n    CostGraph ga(A);\n    for (int i = 0; i < A; i++) {\n        for (int j = i + 1; j < A; j++) {\n            if (not intersectSS(bl, L{a[i], a[j]})) {\n                ga.addEdge(i, j, norm(L{a[i], a[j]}));\n            }\n        }\n    }\n    vector<ld> ad(A);\n    Dijkstra(ga, 0, ad);\n    mini = min(mini, ad[1] + norm(bl));\n    CostGraph gb(B);\n    for (int i = 0; i < B; i++) {\n        for (int j = i + 1; j < B; j++) {\n            if (not intersectSS(al, L{b[i], b[j]})) {\n                gb.addEdge(i, j, norm(L{b[i], b[j]}));\n            }\n        }\n    }\n    vector<ld> bd(B);\n    Dijkstra(gb, 0, bd);\n    mini = min(mini, bd[1] + norm(al));\n    if (mini == 1e8) {\n        cout << -1 << endl;\n    } else {\n        cout << fixed << setprecision(15) << mini << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <complex>\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nstatic const double INF = 1e+10;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle() {;}\n  Circle(Point p, double r) : p(p), r(r) {;}\n};\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\ninline int ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\ntypedef double Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) :\n    src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    return weight > rhs.weight;\n  }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight Dijkstra(const Graph &g, int s, int t) {\n  const int n = g.size();\n  vector<bool> visit(n, false);\n  Array dist(n, 1e+100);\n  priority_queue<Edge> que;\n  que.push(Edge(s, s, 0));\n  Weight ans = 1e+100;\n  dist[s] = 0;\n  while (!que.empty()) {\n    Edge edge = que.top();\n    que.pop();\n    int from = edge.dest;\n    if (visit[from]) { continue; }\n    visit[from] = true;\n    if (from == t) {\n      ans = edge.weight;\n      break;\n    }   \n    for (int i = 0; i < (int)g[from].size(); i++) {\n      int to = g[from][i].dest;\n      Weight ncost = edge.weight + g[from][i].weight;\n      if (visit[to] || ncost >= dist[to]) { continue; }\n      dist[to] = ncost;\n      que.push(Edge(from, to, ncost));\n    }   \n  }\n  return ans;\n}\n\nint n[2];\nvector<Point> ps[2];\n\ndouble calc() {\n  double ret = 0.0;\n  ret += abs(ps[1][0] - ps[1][1]);\n  Line s1 = Line(ps[1][0], ps[1][1]);\n  Graph g(n[0]);\n  REP(i, n[0]) {\n    REP(j, n[0]) {\n      if (i == j || intersectSS(s1, Line(ps[0][i], ps[0][j]))) { continue; }\n      g[i].push_back(Edge(i, j, abs(ps[0][i] - ps[0][j])));\n    }\n  }\n  ret += Dijkstra(g, 0, 1);\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &n[0], &n[1]) > 0) {\n    REP(iter, 2) {\n      ps[iter].clear();\n      REP(i, n[iter]) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        ps[iter].push_back(Point(x, y));\n      }\n    }\n    double ans = 1e+100;\n    REP(iter, 2) {\n      ans = min(ans, calc());\n      swap(ps[0], ps[1]);\n      swap(n[0], n[1]);\n    }\n    if (ans > 1e+10) {\n      puts(\"-1\");\n    } else {\n      printf(\"%.10f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 1e18\nusing namespace std;\n\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment,[-PI,PI]\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1.0L);\nconst long double EPS = 1e-10;\n// cos a\nlong double costh(long double a, long double b,\n                  long double c) {\n  return (b * b + c * c - a * a) / (2.0L * b * c);\n}\n\n// dot(a,b) = |a||b|cos x\nlong double dot(CP a, CP b) { return (conj(a) * b).X; }\n// cross(a,b) : area of parallelogram\n// sign : a-> b ,counter clockwise? + : -\nlong double cross(CP a, CP b) { return (conj(a) * b).Y; }\nlong double corner(CP a, CP b) {\n  //[0,PI]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP intersectionLL(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_seg(CP s, CP t, CP p) {\n  // if not use end point, dot(s - p, t - p) < 0\n  return abs(cross(s - p, t - p)) <= 1e-10 &&\n         dot(s - p, t - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersectionLL(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nlong long a, b;\nvector<CP> va, vb;\n\nlong double solve();\nlong double calc(const vector<CP> &v, const CP s,\n                 const CP t);\n\nint main() {\n  cout << fixed << setprecision(10);\n  cin >> a >> b;\n  va.resize(a);\n  vb.resize(b);\n  for(int i = 0; i < a; ++i) {\n    long long x, y;\n    cin >> x >> y;\n    va[i] = CP(x, y);\n  }\n  for(int i = 0; i < b; ++i) {\n    long long x, y;\n    cin >> x >> y;\n    vb[i] = CP(x, y);\n  }\n  long double res = solve();\n  if(res >= inf)\n    cout << \"-1\" << endl;\n  else\n    cout << res << endl;\n  return 0;\n}\n\nlong double solve() {\n  return min({(long double)inf, calc(va, vb[0], vb[1]),\n              calc(vb, va[0], va[1])});\n}\n\nlong double calc(const vector<CP> &v, CP s, CP t) {\n  long long n = v.size();\n  vector<long double> dist(n, inf);\n  dist[0] = 0.0L;\n  struct data {\n    int n;\n    long double d;\n    bool operator<(const data &r) const { return d > r.d; }\n  };\n  priority_queue<data> pq;\n  pq.push({0, 0.0L});\n  while(pq.size()) {\n    data now = pq.top();\n    pq.pop();\n    if(dist[now.n] < now.d) continue;\n    for(int i = 0; i < n; ++i)\n      if(i != now.n && !iscross(s, t, v[now.n], v[i])) {\n        data nextp = now;\n        nextp.n = i;\n        nextp.d += abs(v[now.n] - v[i]);\n        if(dist[nextp.n] > nextp.d) {\n          dist[nextp.n] = nextp.d;\n          pq.push(nextp);\n        }\n      }\n  }\n\n  return min((long double)inf, dist[1] + abs(s - t));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef double Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return abs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tdouble d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tdouble d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tdouble d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tdouble len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tdouble d = abs(v);\n\tdouble l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tdouble ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph ga(pa.size()), gb(pb.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tdouble d = abs(pa[i] - pa[j]);\n\t\tadd_edge(ga, i, j, d);\n\t\tadd_edge(ga, j, i, d);\n\t}\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tdouble d = abs(pb[i] - pb[j]);\n\t\tadd_edge(gb, i, j, d);\n\t\tadd_edge(gb, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(ga, da, 0);\n\tdijkstra(gb, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double, int> PI;\ntypedef long long LL;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nconst double EPS = 1e-10;\ndouble cross(P a, P b) {\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble dot(P a, P b) {\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\nint ccw(P p0, P p1, P p2) {\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (abs(a) < abs(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersect(P p1, P p2, P p3, P p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nvector<PI> G[1000];\ndouble dist[1000];\nint XA[1000], YA[1000];\nint XB[1000], YB[1000];\nint main() {\n\tint NA, NB;\n\tcin >> NA >> NB;\n\tfor (int i = 0; i < NA; i++) {\n\t\tcin >> XA[i] >> YA[i];\n\t}\n\tfor (int i = 0; i < NB; i++) {\n\t\tcin >> XB[i] >> YB[i];\n\t}\n\tdouble ans = 1e10;\n\tif (!intersect(P(XA[0], YA[0]), P(XA[1], YA[1]), P(XB[0], YB[0]), P(XB[1], YB[1]))) {\n\t\tans = min(ans, abs(P(XA[0], YA[0]) - P(XA[1], YA[1])) + abs(P(XB[0], YB[0]) - P(XB[1], YB[1])));\n\t}\n\tfor (int i = 0; i < NB; i++) {\n\t\tfor (int j = 0; j < NB; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(P(XA[0], YA[0]), P(XA[1], YA[1]), P(XB[i], YB[i]), P(XB[j], YB[j]))) continue;\n\t\t\tG[i].emplace_back(abs(P(XB[i], YB[i]) - P(XB[j], YB[j])), j);\n\t\t}\n\t}\n\tfill(dist, dist + NB, 1e10);\n\tdist[0] = 0;\n\tpriority_queue<PI, vector<PI>, greater<PI>> Q;\n\tQ.push(PI(0, 0));\n\twhile (!Q.empty()) {\n\t\tPI p = Q.top(); Q.pop();\n\t\tif (dist[p.second] < p.first) continue;\n\t\tfor (PI e : G[p.second]) {\n\t\t\tdouble cost = p.first + e.first;\n\t\t\tif (dist[e.second] > cost) {\n\t\t\t\tdist[e.second] = cost;\n\t\t\t\tQ.push(PI(cost, e.second));\n\t\t\t}\n\t\t}\n\t}\n\tif (dist[1] < 1e10)\n\t\tans = min(ans, abs(P(XA[0], YA[0]) - P(XA[1], YA[1])) + dist[1]);\n\tfor (int i = 0; i < NB; i++) G[i].clear();\n\tfor (int i = 0; i < NA; i++) {\n\t\tfor (int j = 0; j < NA; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(P(XA[i], YA[i]), P(XA[j], YA[j]), P(XB[0], YB[0]), P(XB[1], YB[1]))) continue;\n\t\t\tG[i].emplace_back(abs(P(XA[i], YA[i]) - P(XA[j], YA[j])), j);\n\t\t}\n\t}\n\tfill(dist, dist + NA, 1e10);\n\tdist[0] = 0;\n\tQ.push(PI(0, 0));\n\twhile (!Q.empty()) {\n\t\tPI p = Q.top(); Q.pop();\n\t\tif (dist[p.second] < p.first) continue;\n\t\tfor (PI e : G[p.second]) {\n\t\t\tdouble cost = p.first + e.first;\n\t\t\tif (dist[e.second] > cost) {\n\t\t\t\tdist[e.second] = cost;\n\t\t\t\tQ.push(PI(cost, e.second));\n\t\t\t}\n\t\t}\n\t}\n\tif (dist[1] < 1e10)\n\t\tans = min(ans, abs(P(XB[0], YB[0]) - P(XB[1], YB[1])) + dist[1]);\n\tif (ans == 1e10) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tprintf(\"%.15lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double INF = 1e+12;\nconst double EPS = 1e-8;\nconst int N = 1000;\n\nstruct state{\n  int n;\n  double c;\n  state(int n=0, double c=0):n(n),c(c){}\n  bool operator < (const state &s) const {\n    return c > s.c;\n  }\n};\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  \n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n\nint n[2];\ndouble G[2][N][N];\nvector<P> v[2];\n\ndouble dijk(int pos){\n  priority_queue<state> pq;\n  state u, u2;\n  double d[N];\n\n  fill(d, d+N, INF);\n  d[0] = 0;\n\n  for(pq.push(state(0, 0)); !pq.empty();){\n    u = pq.top();\n    pq.pop();\n\n    if(u.n == 1) return u.c;\n\n    for(int i=0;i<n[pos];i++){\n      u2 = state(i, u.c + G[pos][u.n][i]);\n      if(isIntersect(L(v[pos][u.n], v[pos][i]), L(v[!pos][0], v[!pos][1])) || d[i] <= u2.c + EPS) continue;\n      d[i] = u2.c;\n      pq.push(u2);\n    }\n  }\n\n  return INF;\n}\n\ndouble solve(){\n  double res = INF;\n  double res_dijk[2];\n\n  for(int i=0;i<2;i++){\n    for(int j=0;j<n[i];j++){\n      for(int k=j+1;k<n[i];k++){\n        G[i][j][k] = G[i][k][j] = abs(v[i][j] - v[i][k]);\n      }\n    }\n    res_dijk[i] = dijk(i);\n  }\n\n  for(int i=0;i<2;i++){\n    res = min(res, res_dijk[i] + abs(v[!i][0] - v[!i][1]));\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n[0] >> n[1]){\n    for(int i=0;i<2;i++){\n      v[i].clear();\n      for(int j=0;j<n[i];j++){\n        int x,y;\n        cin >> x >> y;\n        v[i].push_back(P(x,y));\n      }\n    }\n    double res = solve();\n    if(res >= INF - EPS) cout << -1 << endl;\n    else printf(\"%.12f\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nconst double pi=3.14159265358979;\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tpos turn(double t){\n\t\t//t[rad]??????\n\t\treturn pos(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tpos tolen(double a){\n\t\t//?????????a?????????\n\t\treturn this->scalar(a/norm);\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n\tbool operator==(pos a)const{ return (x==a.x && y==a.y); }\t\n\tbool operator!=(pos a)const{ return !(a==(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n\tbool  operator<(line a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(p!=a.p)return (p<a.p);\n\t\treturn (q<a.q);\n\t}\t\n\tbool operator>(line a)const{ return (a<(*this)); }\t\n};\n\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\t\n\tvector<line> tangs(circle a){ //??\\?????????\n\t\t//validate AOJ 2201\n\t\tcircle b(*this);\n\t\tif(a.r<b.r)swap(a,b);\n\t\tvector<line> res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r-b.r)<1e-6){\n\t\t\tif((b.p-a.p).norm<1e-6)return res; //??¨???????????????\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r-b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(b.r)));\n\t\t}\n\t\tif((a.p-b.p).norm-(a.r+b.r)<0.0)return res;\n\t\tif((a.p-b.p).norm-(a.r+b.r)<1e-6){\n\t\t\tpos rv=(b.p-a.p).tolen(a.r);\n\t\t\tres.push_back(line(rv+a.p,rv+a.p+rv.turn(pi/2.0)));\n\t\t\treturn res;\n\t\t}\n\t\t{\n\t\t\tpos cv=b.p-a.p;\n\t\t\tdouble th=acos((a.r+b.r)/cv.norm);\n\t\t\tpos p1 = cv.turn(th);\n\t\t\tres.push_back(line(a.p+p1.tolen(a.r),b.p+p1.tolen(-b.r)));\n\t\t\tpos p2 = cv.turn(-th);\n\t\t\tres.push_back(line(a.p+p2.tolen(a.r),b.p+p2.tolen(-b.r)));\n\t\t}\n\t\treturn res;\n\t}\n};\n\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //?????£????????£???eps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //?????£????????????eps\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\t//validate AOJ 2160\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t}\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\nstruct unifo{\n\tint n;\n\tint uni[100005];\n\tvoid init(int in){\n\t\tn=in;\n\t\trep(i,n)uni[i]=i;\n\t}\n\tint find(int p){\n\t\tif(uni[p]==p)return p;\n\t\telse return (uni[p]=find(uni[p]));\n\t}\n\tvoid mer(int p,int q){\n\t\tif(!same(p,q))uni[find(p)]=find(q);\n\t}\n\tbool same(int p,int q){\n\t\treturn find(p)==find(q);\n\t}\n\tvoid out(){\n\t\tvector<mp> ps;\n\t\t//printf(\"%d %d\\n\",i,find(i));\n\t\trep(i,n)ps.push_back(mp(find(i),i));\n\t\tsort(ps.begin(),ps.end());\n\t\tprintf(\"uni .. %d elem\\n{ \",n);\n\t\trep(i,n){\n\t\t\tif(i!=0 && ps[i-1].fir!=ps[i].fir)printf(\"}\\n{ \");\n\t\t\tprintf(\"%d \",ps[i].sec);\n\t\t}\n\t\tprintf(\"}\\n\\n\");\n\t}\n} uni;\n\n\n\nint n,m;\npos ps[1005];\npos qs[1005];\n\ndouble ds[1005][1005];\ndouble dist[1005];\nint gone[1005];\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n+m){\n\t\tdouble x,y;\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tif(i<n)ps[i]=pos(x,y);\n\t\telse qs[i-n]=pos(x,y);\n\t}\n\t\n\tdouble ans=1e15;\n\trep(qqq,2){\n\t\tline ne(ps[0],ps[1]);\n\t\tdouble ns=ne.vec.norm;\n\t\t\n\t\tuni.init(m+5);\n\t\ttypedef pair<double,mp> dmp;\n\t\tvector<dmp> es;\n\t\t\n\t\trep(i,m)dist[i]=-1;\n\t\trep(i,m){\n\t\t\trep(j,i){\n\t\t\t\tline ce(qs[i],qs[j]);\n\t\t\t\tds[i][j]=ds[j][i]=(ce.iscross(ne)?-1:ce.vec.norm);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i,m)rep(j,m){\n\t\t\tprintf(\"%d %d %lf\\n\",i,j,ds[i][j]);\n\t\t}*/\n\t\tmemset(gone,0,sizeof(gone));\n\t\tdist[0]=0;\n\t\t\n\t\t\n\t\tfor(;;){\n\t\t\tint nv=-1;\n\t\t\trep(i,m){\n\t\t\t\tif(gone[i] || dist[i]<0)continue;\n\t\t\t\tif(nv==-1 || dist[i]<dist[nv])nv=i;\n\t\t\t}\n\t\t\tif(nv==-1){\n\t\t\t\tns=1e15;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(nv==1){\n\t\t\t\tns+=dist[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgone[nv]=1;\n\t\t\trep(j,m){\n\t\t\t\tif(gone[j] || ds[nv][j]<0)continue;\n\t\t\t\tdouble nc=dist[nv]+ds[nv][j];\n\t\t\t\tif(dist[j]<0 || nc<dist[j])dist[j]=nc;\n\t\t\t}\n\t\t}\n\t\tans=min(ans,ns);\n\t\tswap(n,m);\n\t\tswap(ps,qs);\n\t}\n\tif(ans>1e10)printf(\"-1\\n\");\n\telse printf(\"%.11f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 0\n\nclass D3 {\npublic:\n\tlong double X, Y, Z, EPS;\n\n\tD3( long double, long double, long double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( long double );\n\tD3 operator*( long double );\n\tD3 operator/( long double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3 {\npublic:\n\tPoint( long double, long double, long double );\n\tlong double getX();\n\tlong double getY();\n\tlong double getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tlong double S_point( Point, Point );\n\tlong double V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec {\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( long double x_, long double y_, long double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( long double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( long double );\n\tbool operator== ( Vec );\n\tbool operator==( long double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tlong double length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tlong double S_vec( Vec );\n\tlong double V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( long double ld ) {\n\treturn ( *this ) == D3();\n}\n\nD3 D3::operator*( long double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( long double ld ) {\n\treturn  *this*( ld*-1.L );\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\nlong double Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\nlong double Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\nlong double Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( ( *this ).getX() != Partner.getX() ) {\n\t\treturn ( *this ).getX() < Partner.getX();\n\t}\n\tif( ( *this ).getY() != Partner.getY() ) {\n\t\treturn ( *this ).getY() < Partner.getY();\n\t}\n\treturn ( *this ).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < ( *this );\n}\n//??????????????¢???????±???????\nlong double Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\nlong double Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( ( *this ), B ).V_vec( Vec( ( *this ), C ), Vec( ( *this ), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( long double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + ( Partner*( -1.L ) );\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( long double ld ) {\n\treturn *this*( 1.L / ld );\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( long double ) {\n\treturn ( *this ) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\nlong double Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / ( *this ).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn ( *this )*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( ( *this ).Inverse_vec().getD(), ( *this ).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn ( *this ).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn ( *this ).Unit_vec().getD() == Partner.Unit_vec().getD() || ( *this ).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) );\n\tVec Q = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getSP() ) );\n\tVec R = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getGP() ) );\n\treturn ( !( *this ).Parallel( Partner ) ) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS ) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS );\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( ( *this ).isIntersection( Partner ) ) {\n\t\tlong double d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) ).D.Z );\n\t\tlong double d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) ).D.Z );\n\t\tlong double t = d1 / ( d1 + d2 );\n\t\treturn Vec( ( ( *this )*t ).getD(), ( *this ).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( ( *this ).getSP(), A );\n\tif( A == ( ( *this ).getSP() ) || ( Test.Parallel( *this ) && ( *this ).getD().X / Test.getD().X >= 1.0L ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\nlong double Vec::S_vec( Vec B ) {\n\tif( ( ( *this ).getSP() == B.getSP() ) ) {\n\t\tVec G = ( *this ).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( ( *this ).getGP() == B.getSP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B );\n\t}\n\tif( ( *this ).getSP() == B.getGP() ) {\n\t\treturn ( *this ).S_vec( B.Reverse_vec() );\n\t}\n\tif( ( *this ).getGP() == B.getGP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\nlong double Vec::V_vec( Vec B, Vec C ) {\n\tVec G = ( *this ).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points {\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance {\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n\n\nvector<vector<pair<long long int, long double>>>makelist( vector<Point>&townlist, Vec DisallowVec ) {\n\tvector<vector<pair<long long int, long double>>>ret( townlist.size() );\n\tfor( size_t i = 0; i < townlist.size(); i++ ) {\n\t\tfor( size_t j = i + 1; j < townlist.size(); j++ ) {\n\t\t\tVec now = Vec( townlist[i], townlist[j] );\n\t\t\tif( !now.isIntersection( DisallowVec ) ) {\n\t\t\t\tret[i].push_back( make_pair( j, now.length() ) );\n\t\t\t\tret[j].push_back( make_pair( i, now.length() ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nlong double dijkstra( vector<vector<pair<long long int, long double>>>  listLen ) {\n\tvector<long double>ret( listLen.size(), LDBL_MAX / 10 );\n\tpriority_queue<pair< double, long long int>, vector<pair<double, long long int>>, greater<pair<double, long long int>>>que;\n\tque.push( make_pair( 0, 0 ) );\n\tret[0] = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( now.second == 1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif( now.first != ret[now.second] ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( auto next : listLen[now.second] ) {\n\t\t\tif( ret[next.first] > now.first + next.second ) {\n\t\t\t\tret[next.first] = now.first + next.second;\n\t\t\t\tif( ret[next.first] < ret[1] ) {\n\t\t\t\t\tque.push( make_pair( now.first + next.second, next.first ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret[1];\n}\n\n\nint main() {\n\tlong long int NA, NB;\n\tcin >> NA >> NB;\n\tvector<Point>townA( NA ), townB( NB );\n\tfor( size_t i = 0; i < NA; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownA[i] = Point( x, y );\n\t}\n\tfor( size_t i = 0; i < NB; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownB[i] = Point( x, y );\n\t}\n\n\tauto listA = makelist( townA, Vec( townB[0], townB[1] ) );\n\tauto listB = makelist( townB, Vec( townA[0], townA[1] ) );\n\n\tlong double lenA = dijkstra( listA );\n\tlong double lenB = dijkstra( listB );\n\n\tif( lenA == LDBL_MAX / 10 && lenB == LDBL_MAX / 10 ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << fixed << setprecision( 20 ) << min( lenA + Vec( townB[0], townB[1] ).length(), lenB + Vec( townA[0], townA[1] ).length() ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 0\n\nclass D3 {\npublic:\n\tlong double X, Y, Z, EPS;\n\n\tD3( long double, long double, long double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( long double );\n\tD3 operator*( long double );\n\tD3 operator/( long double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3 {\npublic:\n\tPoint( long double, long double, long double );\n\tlong double getX();\n\tlong double getY();\n\tlong double getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tlong double S_point( Point, Point );\n\tlong double V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec {\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( long double x_, long double y_, long double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( long double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( long double );\n\tbool operator== ( Vec );\n\tbool operator==( long double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tlong double length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tlong double S_vec( Vec );\n\tlong double V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( long double ld ) {\n\treturn ( *this ) == D3();\n}\n\nD3 D3::operator*( long double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( long double ld ) {\n\treturn  *this*( ld*-1.L );\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\nlong double Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\nlong double Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\nlong double Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( ( *this ).getX() != Partner.getX() ) {\n\t\treturn ( *this ).getX() < Partner.getX();\n\t}\n\tif( ( *this ).getY() != Partner.getY() ) {\n\t\treturn ( *this ).getY() < Partner.getY();\n\t}\n\treturn ( *this ).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < ( *this );\n}\n//??????????????¢???????±???????\nlong double Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\nlong double Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( ( *this ), B ).V_vec( Vec( ( *this ), C ), Vec( ( *this ), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( long double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + ( Partner*( -1.L ) );\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( long double ld ) {\n\treturn *this*( 1.L / ld );\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( long double ) {\n\treturn ( *this ) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\nlong double Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / ( *this ).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn ( *this )*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( ( *this ).Inverse_vec().getD(), ( *this ).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn ( *this ).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn ( *this ).Unit_vec().getD() == Partner.Unit_vec().getD() || ( *this ).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) );\n\tVec Q = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getSP() ) );\n\tVec R = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getGP() ) );\n\treturn ( !( *this ).Parallel( Partner ) ) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS ) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS );\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( ( *this ).isIntersection( Partner ) ) {\n\t\tlong double d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) ).D.Z );\n\t\tlong double d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) ).D.Z );\n\t\tlong double t = d1 / ( d1 + d2 );\n\t\treturn Vec( ( ( *this )*t ).getD(), ( *this ).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( ( *this ).getSP(), A );\n\tif( A == ( ( *this ).getSP() ) || ( Test.Parallel( *this ) && ( *this ).getD().X / Test.getD().X >= 1.0L ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\nlong double Vec::S_vec( Vec B ) {\n\tif( ( ( *this ).getSP() == B.getSP() ) ) {\n\t\tVec G = ( *this ).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( ( *this ).getGP() == B.getSP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B );\n\t}\n\tif( ( *this ).getSP() == B.getGP() ) {\n\t\treturn ( *this ).S_vec( B.Reverse_vec() );\n\t}\n\tif( ( *this ).getGP() == B.getGP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\nlong double Vec::V_vec( Vec B, Vec C ) {\n\tVec G = ( *this ).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points {\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance {\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n\n\nvector<vector<pair<long long int, long double>>>makelist( vector<Point>townlist, Vec DisallowVec ) {\n\tvector<vector<pair<long long int, long double>>>ret( townlist.size() );\n\tfor( size_t i = 0; i < townlist.size(); i++ ) {\n\t\tfor( size_t j = i + 1; j < townlist.size(); j++ ) {\n\t\t\tVec now = Vec( townlist[i], townlist[j] );\n\t\t\tif( !now.isIntersection( DisallowVec ) ) {\n\t\t\t\tret[i].push_back( make_pair( j, now.length() ) );\n\t\t\t\tret[j].push_back( make_pair( i, now.length() ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nlong double dijkstra( vector<vector<pair<long long int, long double>>>  listLen ) {\n\tvector<long double>ret( listLen.size(), LDBL_MAX / 10 );\n\tpriority_queue<pair<long double, long long int>, vector<pair<long double, long long int>>, greater<pair<long double, long long int>>>que;\n\tque.push( make_pair( 0, 0 ) );\n\tret[0] = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( now.second == 1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif( now.first != ret[now.second] ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( auto next : listLen[now.second] ) {\n\t\t\tif( ret[next.first] > now.first + next.second ) {\n\t\t\t\tret[next.first] = now.first + next.second;\n\t\t\t\tif( ret[next.first] < ret[1] ) {\n\t\t\t\t\tque.push( make_pair( now.first + next.second, next.first ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret[1];\n}\n\n\nint main() {\n\tlong long int NA, NB;\n\tcin >> NA >> NB;\n\tvector<Point>townA( NA ), townB( NB );\n\tfor( size_t i = 0; i < NA; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownA[i] = Point( x, y );\n\t}\n\tfor( size_t i = 0; i < NB; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownB[i] = Point( x, y );\n\t}\n\n\tauto listA = makelist( townA, Vec( townB[0], townB[1] ) );\n\tauto listB = makelist( townB, Vec( townA[0], townA[1] ) );\n\n\tlong double lenA = dijkstra( listA );\n\tlong double lenB = dijkstra( listB );\n\n\tif( lenA == LDBL_MAX / 10 && lenB == LDBL_MAX / 10 ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << fixed << setprecision( 20 ) << min( lenA + Vec( townB[0], townB[1] ).length(), lenB + Vec( townA[0], townA[1] ).length() ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n\nint Na, Nb;\ndouble xa[1002], ya[1002];\ndouble xb[1002], yb[1002];\n\n\ndouble dist(int i, int j, int side=0) {\n\tif (side == 0) return sqrt((xa[i] - xa[j]) * (xa[i] - xa[j]) + (ya[i] - ya[j]) * (ya[i] - ya[j]));\n\telse return sqrt((xb[i] - xb[j]) * (xb[i] - xb[j]) + (yb[i] - yb[j]) * (yb[i] - yb[j]));\n}\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\t\t\t\t\t   // 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n\treturn (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n\treturn (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n\tb -= a;  c -= a;\n\tif (cross(b, c) >  EPS) return +1;  // counter clockwise\n\tif (cross(b, c) < -EPS) return -1;  // clockwise\n\tif (dot(b, c)   < -EPS) return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n\treturn 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n\treturn ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n\t\tccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\ndouble dijkstra() {\n\tvector<double> d(Na, -1);\n\tpriority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> que;\n\td[0] = 0;\n\tque.emplace(0, 0);\n\twhile (!que.empty()) {\n\t\tauto p = que.top(); que.pop();\n\t\tif (d[p.second] < p.first) continue;\n\t\tif(p.second == 1) {\n\t\t\treturn p.first + dist(0, 1, 1);\n\t\t}\n\t\tfor(int to=0;to<Na;to++) {\n\t\t\tif (p.second == to) continue;\n\t\t\tif (isecSS(P(xa[p.second], ya[p.second]), P(xa[to], ya[to]), P(xb[0], yb[0]), P(xb[1], yb[1]))) continue;\n\t\t\tdouble nc = p.first + dist(p.second, to);\n\t\t\tif (d[to] < 0 || d[to] > nc) {\n\t\t\t\td[to] = nc;\n\t\t\t\tque.emplace(nc, to);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main() {\n\tcin >> Na >> Nb;\n\n\tfor(int i=0;i<Na;i++) {\n\t\tcin >> xa[i] >> ya[i];\n\t}\n\tfor(int i=0;i<Nb;i++) {\n\t\tcin >> xb[i] >> yb[i];\n\t}\n\n\tdouble ans = dijkstra();\n\tfor(int i=0;i<max(Na, Nb);i++) {\n\t\tswap(xa[i], xb[i]);\n\t\tswap(ya[i], yb[i]);\n\t}\n\tswap(Na, Nb);\n\tif(ans < 0) {\n\t\tans = dijkstra();\n\t}else {\n\t\tdouble ans_b = dijkstra();\n\t\tif(ans_b >= 0) {\n\t\t\tans_b = min(ans, ans_b);\n\t\t}\n\t}\n\n\tif(ans < 0) {\n\t\tcout << -1 << endl;\n\t}else {\n\t\tprintf(\"%.12f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double oo=1e77;\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; }\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\nstruct segment{ point<T> a,b; };\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ndouble solve(int na,const int *xa,const int *ya,int nb,const int *xb,const int *yb){\n\tdouble d[1000];\n\trep(i,na) d[i]=(i==0?0:oo);\n\n\tpriority_queue< pair<double,int> > Q;\n\tQ.push(make_pair(0,0));\n\twhile(!Q.empty()){\n\t\tdouble d_now=-Q.top().first;\n\t\tint i=Q.top().second; Q.pop();\n\n\t\tif(d[i]<d_now-EPS) continue;\n\n\t\trep(j,na) if(!intersect((segment<double>){(point<double>){xa[i],ya[i]},(point<double>){xa[j],ya[j]}},(segment<double>){(point<double>){xb[0],yb[0]},(point<double>){xb[1],yb[1]}})) {\n\t\t\tdouble d_next=d_now+hypot(xa[i]-xa[j],ya[i]-ya[j]);\n\t\t\tif(d[j]>d_next+EPS){\n\t\t\t\td[j]=d_next;\n\t\t\t\tQ.push(make_pair(-d_next,j));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[1]+hypot(xb[0]-xb[1],yb[0]-yb[1]);\n}\n\nint main(){\n\tint na,nb; scanf(\"%d%d\",&na,&nb);\n\tint xa[1000],ya[1000],xb[1000],yb[1000];\n\trep(i,na) scanf(\"%d%d\",xa+i,ya+i);\n\trep(i,nb) scanf(\"%d%d\",xb+i,yb+i);\n\n\tdouble ans=min(solve(na,xa,ya,nb,xb,yb),solve(nb,xb,yb,na,xa,ya));\n\tprintf(\"%.15f\\n\",ans<oo/2?ans:-1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\nint N[2];\nPoints P[2];\ntypedef pair<double, int> li;\n\ndouble ans = 1e18;\nSegment NG;\ndouble dist[2][1000];\n\nvoid solve(int idx, int s) {\n    for(int i = 0; i < N[idx]; i++) {\n        dist[idx][i] = 1e9;\n    }\n    dist[idx][s] = 0;\n    priority_queue<li, vector<li>, greater<li>> que;\n    que.push({0, s});\n    while(!que.empty()) {\n        auto tmp = que.top();\n        que.pop();\n        int from = tmp.second;\n        for(int to = 0; to < N[idx]; to++) {\n            double cost = dist[idx][from] + abs(P[idx][from] - P[idx][to]);\n            Segment tmp = Segment(P[idx][from], P[idx][to]);\n            if(!intersect(tmp, NG)) {\n                if(chmin(dist[idx][to], cost)) {\n                    que.push({cost, to});\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N[0] >> N[1];\n    for(int i = 0; i < 2; i++) {\n        P[i].resize(N[i]);\n        for(int j = 0; j < N[i]; j++) {\n            cin >> P[i][j];\n        }\n    }\n    NG = Segment(P[1][0], P[1][1]);\n    solve(0, 0);\n    NG = Segment(P[0][0], P[0][1]);\n    solve(1, 0);\n    chmin(ans, dist[0][1] + abs(P[1][0] - P[1][1]));\n    chmin(ans, dist[1][1] + abs(P[0][0] - P[0][1]));\n    if(ans > 1e8) cout << -1 << endl;\n    else cout << fixed << setprecision(20) << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=======================================================================================!//\n//!   a88888b.                     dP       .88888.                             dP        !//\n//!  d8'   '88                     88      d8'   '88                            88        !//\n//!  88        .d8888b. .d8888b. d8888P    88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88        88'  '88 Y8ooooo.   88      88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88.  .88       88   88      Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   Y88888P' '88888P' '88888P'   dP       '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                                                                    88                 !//\n//!                                                                    dP                 !//\n//!=======================================================================================!//\ntemplate <typename Cost>\nstruct CostGraph\n{\n    CostGraph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const Cost cost, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(Edge{to, cost}), rev_edge[to].push_back(Edge(from, cost));\n        if (bi) { addEdge(to, from, cost, false); }\n    }\n    struct Edge\n    {\n        Edge(const std::size_t to, const Cost cost) : to{to}, cost{cost} {}\n        const std::size_t to;\n        const Cost cost;\n        bool operator<(const Edge& e) const { return cost != e.cost ? cost < e.cost : to < e.to; }\n    };\n    const std::vector<Edge>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const CostGraph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const auto& e : g.edge[i]) { os << i << \"->\" << e.to << \":\" << e.cost << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    const std::size_t V;\n    std::vector<std::vector<Edge>> edge, rev_edge;\n};\ntemplate <typename Cost>\nusing CostTree = CostGraph<Cost>;\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    struct CostGraph\n    {\n        CostGraph(const std::size_t v) : V{v}, edge(v) {}\n        void addEdge(const std::size_t from, const std::size_t to, const ld cost) { edge[from].push_back(Edge{to, cost}), edge[to].push_back(Edge{from, cost}); }\n        struct Edge\n        {\n            Edge(const std::size_t to, const ld cost) : to{to}, cost{cost} {}\n            const std::size_t to;\n            const ld cost;\n            bool operator<(const Edge& e) const { return cost != e.cost ? cost < e.cost : to < e.to; }\n        };\n        const std::vector<Edge>& operator[](const std::size_t i) const { return edge[i]; }\n        const std::size_t V;\n        std::vector<std::vector<Edge>> edge;\n    };\n    const int NA = read<int>(), NB = read<int>();\n    std::vector<int> xa(NA), ya(NA);\n    for (int i = 0; i < NA; i++) { std::cin >> xa[i] >> ya[i]; }\n    CostGraph GA(NA);\n    std::vector<int> xb(NB), yb(NB);\n    for (int i = 0; i < NB; i++) { std::cin >> xb[i] >> yb[i]; }\n    CostGraph GB(NB);\n    const int ax = xa[0], ay = ya[0], bx = xa[1], by = ya[1];\n    const int cx = xb[0], cy = yb[0], dx = xb[1], dy = yb[1];\n    const ld la = std::hypot(ax - bx, ay - by), lb = std::hypot(cx - dx, cy - dy);\n    auto cross = [&](const ll ax, const ll ay, const ll bx, const ll by, const ll cx, const ll cy, const ll dx, const ll dy) {\n        const ll ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n        const ll tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n        const ll tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n        const ll td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n        return ta * tb < 0 and tc * td < 0;\n    };\n    for (int i = 0; i < NA; i++) {\n        for (int j = i + 1; j < NA; j++) {\n            if (cross(xa[i], ya[i], xa[j], ya[j], cx, cy, dx, dy)) { continue; }\n            GA.addEdge(i, j, std::hypot(xa[i] - xa[j], ya[i] - ya[j]));\n        }\n    }\n    for (int i = 0; i < NB; i++) {\n        for (int j = i + 1; j < NB; j++) {\n            if (cross(xb[i], yb[i], xb[j], yb[j], ax, ay, bx, by)) { continue; }\n            GB.addEdge(i, j, std::hypot(xb[i] - xb[j], yb[i] - yb[j]));\n        }\n    }\n    constexpr ld INF = 4e7;\n    auto Dijkstra = [&](const CostGraph& g, const std::size_t s) {\n        std::vector<ld> d(g.V, INF);\n        using P = std::pair<ld, std::size_t>;\n        std::priority_queue<P, std::vector<P>, std::greater<P>> q;\n        d[s] = 0, q.push({0, s});\n        while (not q.empty()) {\n            const ld cost = q.top().first;\n            const std::size_t v = q.top().second;\n            q.pop();\n            if (d[v] < cost) { continue; }\n            for (const auto& e : g.edge[v]) {\n                if (d[e.to] <= d[v] + e.cost) { continue; }\n                d[e.to] = d[v] + e.cost, q.push({d[e.to], e.to});\n            }\n        }\n        return d;\n    };\n    const auto cla = Dijkstra(GA, 0);\n    const auto clb = Dijkstra(GB, 0);\n    const ld ans = std::min(cla[1] + lb, clb[1] + la);\n    if (ans >= INF) {\n        std::cout << -1 << std::endl;\n    } else {\n        std::cout << std::fixed << std::setprecision(12) << ans << std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <complex>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef pair<int, double> PP;\n\nstruct Edge{\n  int to;\n  double cost;\n  Edge(int a, double b){\n    to = a;\n    cost = b;\n  }\n};\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\ndouble distance(P a, P b){\n  return abs(a - b);\n}\n\nint NA, NB;\nvector<Edge>G[1024];\ndouble dis[1024];\n\nvoid dijkstra(int s){\n  fill(dis, dis + 1024, INF);\n\n  priority_queue<PP, vector<PP>, greater<PP> >PQ;\n  PQ.push(make_pair(0, s));\n  dis[s] = 0;\n  while(!PQ.empty()){\n    PP q = PQ.top(); PQ.pop();\n    int d = q.first;\n    int p = q.second;\n    if(dis[p] < d) continue;\n    for(int i=0;i<G[p].size();i++){\n      Edge next = G[p][i];\n      if(dis[p] + next.cost < dis[next.to]){\n\tdis[next.to] = dis[p] + next.cost;\n\tPQ.push(make_pair(dis[next.to], next.to));\n      }\n    }\n  }\n}\n\n\ndouble solve(vector<double>xA, vector<double>yA, vector<double>xB, vector<double>yB){\n  for(int i=0;i<1024;i++) G[i].clear();\n  P a0 = P(xA[0], yA[0]);\n  P a1 = P(xA[1], yA[1]);\n  double A = distance(a0, a1);\n  //  cout << distance(a0, a1) << endl;\n\n  for(int i=0;i<xB.size();i++){\n    for(int j=i+1;j<xB.size();j++){\n      P b0 = P(xB[i], yB[i]);\n      P b1 = P(xB[j], yB[j]);\n      if(!is_intersected_ls(a0, a1, b0, b1)){\n\tG[i].push_back(Edge(j, distance(b0, b1)));\n\tG[j].push_back(Edge(i, distance(b0, b1)));\n\t//\tcout << distance(b0, b1) << endl;\n      }\n    }\n  }\n  \n  dijkstra(0);\n  double B = dis[1];\n  //  cout << A << \" \" << B << endl;  \n  return A + B;\n}\n\nint main()\n{\n  cin >> NA >> NB;\n  vector<double>xA(NA);\n  vector<double>yA(NA);\n  vector<double>xB(NB);\n  vector<double>yB(NB);\n\n  rep(i, NA)\n    cin >> xA[i] >> yA[i];\n  rep(i, NB)\n    cin >> xB[i] >> yB[i];\n\n  double res1 = solve(xA, yA, xB, yB);\n  double res2 = solve(xB, yB, xA, yA);\n  if(res1 > INF-EPS && res2 > INF- EPS) cout << -1 << endl;\n  else cout << fixed << setprecision(10) << min(res1, res2) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cmath>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\n\nconst double INF = (1<<30);\n\nint n,m;\nvector<P> A;\nvector<P> B;\n\nclass L : public vector<P>{\n\tpublic:\n\tL(P a, P b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n\n\nbool input(){\n\tcin>>n>>m;\n\tA=vector<P>(n);\n\tB=vector<P>(m);\n\trep(i,n){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tA[i] = P(a,b);\n\t}\n\trep(i,m){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tB[i] = P(a,b);\n\t}\n}\n\nvoid init(){}\n\ndouble distPP(P a, P b){return abs(a-b);}\n\n\ndouble cross(P a, P b){return a.X*b.Y-a.Y*b.X;}\nbool ccw(P a, P b, P c){\n\treturn cross(b-a, c-a)>0;\n}\n\nbool hitLL(L a, L b){\n\tbool b1 = ccw(a[0],b[0],b[1])!=ccw(a[1],b[0],b[1]);\n\tbool b2 = ccw(b[0],a[0],a[1])!=ccw(b[1],a[0],a[1]);\n\treturn b1&&b2;\n}\n\ndouble solve_search(L line, vector<P>& p){\n\t\n\tdouble ret = INF;\n\trep(i,p.size()){\n\t\trep(j,p.size()){\n\t\t\tdouble d1 = distPP(p[0], p[i]);\n\t\t\tdouble d2 = distPP(p[1], p[j]);\n\t\t\tdouble d3 = distPP(p[i], p[j]);\n\t\t\t\n\t\t\tL line1(p[0],p[i]);\n\t\t\tL line2(p[i],p[j]);\n\t\t\tL line3(p[j],p[1]);\n\t\t\t\n\t\t\tif(!hitLL(line1, line)\n\t\t\t\t&& !hitLL(line2, line)\n\t\t\t\t&& !hitLL(line3, line)){\n\t\t\t\t\tret = min(ret, d1+d2+d3);\n\t\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret+distPP(line[0],line[1]);\n}\n\ndouble solve(){\n\t\n\tL AL(A[0],A[1]);\n\tL BL(B[0],B[1]);\n\t\n\tdouble val = min(solve_search(AL, B), solve_search(BL, A));\n\tif(val>=INF)return -1;\n\treturn val;\n}\n\nint main(){\n\tinit();\n\tinput();\n\t\n\tprintf(\"%.9lf\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<complex>\n#include<tuple>\n\nusing namespace std;\n\n#define reep(i, s, n) for(int i=s;i<(int)n;i++)\n#define rep(i, n) for(int i=0;i<(int)n;i++)\n#define REP(i, n) for(int i=0;i<(int)n;i++)\n#define all(v) v.begin(), v.end()\n#define tyd typedef\n#define vc vector\n#define pb push_Back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\nconst int IINF = 1<<28;\n\n#define fs first\n#define sc second\n#define X real()\n#define Y imag()\ntypedef long double R;\nconst R EPS = 1e-9;\nconst R INF = 1e9;\ninline int sig(const R &x){return abs(x) < EPS ? 0 : x > 0 ? 1 : -1;}\ntypedef complex<R> P;\ninline  R inp(const P &a, const P &b){ return (conj(a)*b).X;}\ninline R outp(const P &a, const P &b){ return (conj(a)*b).Y;}\ninline int ccw(const P &s, const P &t, const P &p){\n\tint res = sig(outp(t-s, p-s));\n\tif(res) return res;\n\tif(sig(inp(t-s, p-s)) < 0) return -2;\n\tif(sig(inp(s-t, p-t)) < 0) return 2;\n\treturn 0;\n}\nint intersect(const P &s0, const P &s1, const P &t0, const P &t1){\n\tint p = ccw(t0, t1, s0) * ccw(t0, t1, s1);\n\tint q = ccw(s0, s1, t0) * ccw(s0, s1, t1);\n\treturn !(p>0 || q>0);\n}\n\nint n, m;\n\ntypedef pair<R, int> pRi;\n\nR solve(vector<P> p, P p1, P p2){\n\tint n = p.size();\n\tpriority_queue<pRi, vector<pRi>, greater<pRi>> pq;\n\tpq.emplace(abs(p1 - p2), 0);\n\tvector<R> dp(n, INF);\n\tdp[0] = abs(p1 - p2);\n\twhile(!pq.empty()){\n\t\tR d; int u; tie(d, u) = pq.top(); pq.pop();\n\t\tif(dp[u] + EPS < d) continue;\n\t\tR c;\n\t\tREP(v, n){\n\t\t\tif(u!=v && dp[v] > (c = (d + abs(p[u] - p[v])))){\n\t\t\t\tif(intersect(p[u], p[v], p1, p2)) continue;\n\t\t\t\tdp[v] = c;\n\t\t\t\tpq.emplace(c, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[1];\n}\n\n\n\n\n\n\n\n\n\n\nint main(){\n\tvector<P> p1, p2;\n\tcin >> n >> m;\n\tREP(i, n){\n\t\tR x, y;\n\t\tcin >> x >> y;\n\t\tp1.eb(x, y);\n\t}\n\tREP(i, m){\n\t\tR x, y;\n\t\tcin >> x >> y;\n\t\tp2.eb(x, y);\n\t}\n\tR res = min(solve(p1, p2[0], p2[1]), solve(p2, p1[0], p1[1]));\n\tif(res >= INF-1) puts(\"-1\");\n\telse{\n\t\tprintf(\"%.11f\\n\", (double)res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\n// 比較関数\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n  bool operator==(P a, P b) {return norm(a - b) < EPS;}\n}\n\n// 外積\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.b - a.a;}\n\n// 線分abに対する点cの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  if (a == c || b == c) return ON;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\n// 交差判定\nbool iSSs(L a, L b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return (cwa & cwb) == (LEFT | RIGHT);\n}\n\nint main() {\n  int na, nb;\n  cin >> na >> nb;\n  P a[na], b[nb];\n  rep (i, na) cin >> a[i].X >> a[i].Y;\n  rep (i, nb) cin >> b[i].X >> b[i].Y;\n  D disa[na], disb[nb];\n  rep (i, na) disa[i] = 1e100;\n  rep (i, nb) disb[i] = 1e100;\n  priority_queue<pair<D, int>, vector<pair<D, int> >, greater<pair<D, int> > > que;\n  que.push(make_pair(0, 0));\n  while (!que.empty()) {\n    pair<D, int> now = que.top();\n    que.pop();\n    if (disa[now.second] <= now.first) continue;\n    disa[now.second] = now.first;\n    rep (i, na) if (now.second != i && !iSSs((L){a[now.second], a[i]}, (L){b[0], b[1]})) {\n      que.push(make_pair(now.first + abs(a[now.second] - a[i]), i));\n    }\n  }\n  que.push(make_pair(0, 0));\n  while (!que.empty()) {\n    pair<D, int> now = que.top();\n    que.pop();\n    if (disb[now.second] <= now.first) continue;\n    disb[now.second] = now.first;\n    rep (i, nb) if (now.second != i && !iSSs((L){b[now.second], b[i]}, (L){a[0], a[1]})) {\n      que.push(make_pair(now.first + abs(b[now.second] - b[i]), i));\n    }\n  }\n  D ans = min(disa[1] + abs(b[0] - b[1]), disb[1] + abs(a[0] - a[1]));\n  if (ans > 1e90) {\n    cout << -1 << endl;\n    return 0;\n  }\n  printf(\"%.12Lf\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <complex>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n#define ISEQ(c) (c).begin(), (c).end()\n\nnamespace Ps{\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e12;\n\n\ttypedef complex<double> P;\n#define X real()\n#define Y img()\n\n\tdouble cross(const P& a, const P& b) {\n\t\treturn imag(conj(a)*b);\n\t}\n\tdouble dot(const P& a, const P& b) {\n\t\treturn real(conj(a)*b);\n\t}\n\n\tint ccw(const P& a, P b, P c) {\n\t\tb -= a; c-= a;\n\t\tif (cross(b, c) > 0) return 1;\n\t\tif (cross(b, c) < 0) return -1;\n\t\tif (dot(b, c) < 0) return 2;\n\t\tif (norm(b) < norm(c)) return -2;\n\t\treturn 0;\n\t}\n\n\tdouble pfmod(double v, double MOD) {\n\t\treturn fmod(fmod(v,MOD)+MOD,MOD);\n\t}\n\tdouble AbsArg(double a) {\n\t\tdouble ret = pfmod(max(a,-a),2*M_PI);\n\t\treturn min(ret,2*M_PI-ret);\n\t}\n\n\n\tstruct L : public vector<P> {\n\t\tL(const P &a, const P &b) {\n\t\t\tpush_back(a); push_back(b);\n\t\t}\n\t};\n\n\tbool isIntersect(const L &s, const L &t) {\n\t\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 and ccw(t[0], t[1], s[0])*ccw(t[0],t[1],s[1]) <= 0;\n\t}\n}\nusing namespace Ps;\n\ndouble G[1010][1010];\n\n\ndouble d[1010];\nbool used[1010];\n\nvoid dijkstra(int s, int n) {\n\tfill(d, d+1010, INF);\n\tfill(used, used+1010, false);\n\td[s] = 0;\n\n\twhile (true) {\n\t\tint v = -1;\n\t\tfor (int u = 0; u < n; u++) {\n\t\t\tif (!used[u] and (v == -1 or d[u] < d[v])) v = u;\n\t\t}\n\n\t\tif (v == -1) break;\n\t\tused[v] = true;\n\n\t\tfor (int u = 0; u < n; u++) {\n\t\t\td[u] = min(d[u], d[v]+G[v][u]);\n\t\t}\n\t}\n}\n\nint main() {\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<int> xa(na), ya(na), xb(nb), yb(nb);\n\tfor (int i = 0; i < na; i++) {\n\t\tcin >> xa[i] >> ya[i];\n\t}\n\tfor (int i = 0; i < nb; i++) {\n\t\tcin >> xb[i] >> yb[i];\n\t}\n\tL la(P(xa[0],ya[0]),P(xa[1],ya[1]));\n\tL lb(P(xb[0],yb[0]),P(xb[1],yb[1]));\n\t\n\tfor (int i = 0; i < na; i++) {\n\t\tfor (int j = i+1; j < na; j++) {\n\t\t\tif (isIntersect(lb, L(P(xa[i],ya[i]),P(xa[j],ya[j])))) {\n\t\t\t\tG[j][i] = G[i][j] = INF;\n\t\t\t} else {\n\t\t\t\tG[j][i] = G[i][j] = hypot(xa[i]-xa[j],ya[i]-ya[j]);\n\t\t\t}\n\t\t}\n\t\tG[i][i] = INF;\n\t}\n\tdijkstra(0, na);\n\tdouble res = d[1] + abs(lb[0]-lb[1]);\n\n\tfor (int i = 0; i < nb; i++) {\n\t\tfor (int j = i+1; j < nb; j++) {\n\t\t\tif (isIntersect(la, L(P(xb[i],yb[i]),P(xb[j],yb[j])))) {\n\t\t\t\tG[j][i] = G[i][j] = INF;\n\t\t\t} else {\n\t\t\t\tG[j][i] = G[i][j] = hypot(xb[i]-xb[j],yb[i]-yb[j]);\n\t\t\t}\n\t\t}\n\t\tG[i][i] = INF;\n\t}\n\tdijkstra(0, nb);\n\tres = min(res, d[1]+abs(la[0]-la[1]));\n\tif (res >= INF) cout << -1 << endl;\n\telse\n\t\tprintf(\"%.20f\\n\",res); \n\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\n\n#endif\n\n#include <queue>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst double inf = 1000000000.0;\nint N, M, x, y; vector<Point> v1, v2;\nint main() {\n\tcin >> N >> M;\n\tv1.resize(N);\n\tv2.resize(M);\n\tfor (int i = 0; i < N; i++) cin >> x >> y, v1[i] = Point(x, y);\n\tfor (int i = 0; i < M; i++) cin >> x >> y, v2[i] = Point(x, y);\n\tvector<double> dist1(N, inf * 2); dist1[0] = 0;\n\tpriority_queue<pair<double, int> > que1; que1.push(make_pair(0.0, 0));\n\twhile (!que1.empty()) {\n\t\tint u = que1.top().second; que1.pop();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (u == i) continue;\n\t\t\tif (!intersect(Segment(make_pair(v2[0], v2[1])), Segment(make_pair(v1[u], v1[i])), true) && dist1[i] > dist1[u] + abs(v1[u] - v1[i])) {\n\t\t\t\tdist1[i] = dist1[u] + abs(v1[u] - v1[i]);\n\t\t\t\tque1.push(make_pair(-dist1[i], i));\n\t\t\t}\n\t\t}\n\t}\n\tvector<double> dist2(M, inf * 2); dist2[0] = 0;\n\tpriority_queue<pair<double, int> > que2; que2.push(make_pair(0.0, 0));\n\twhile (!que2.empty()) {\n\t\tint u = que2.top().second; que2.pop();\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (u == i) continue;\n\t\t\tif (!intersect(Segment(make_pair(v1[0], v1[1])), Segment(make_pair(v2[u], v2[i])), true) && dist2[i] > dist2[u] + abs(v2[u] - v2[i])) {\n\t\t\t\tdist2[i] = dist2[u] + abs(v2[u] - v2[i]);\n\t\t\t\tque1.push(make_pair(-dist2[i], i));\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(12) << min(dist1[1] + abs(v2[0] - v2[1]), dist2[1] + abs(v1[0] - v1[1])) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n      min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\ntypedef double Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n/* dijkstra: return distance, prev: O(ElogV) */\npair<vector<Weight>,vector<int> > dijkstra(const Graph &g, int s){\n  int n = g.size();\n  vector<Weight> dist(n, INF); dist[s] = 0;\n  vector<int> prev(n, -1);\n  priority_queue<Edge> que;\n  for(que.push(Edge(-2,s,0)); !que.empty();){\n    Edge e = que.top(); que.pop();\n    if(prev[e.dst] != -1) continue;\n    prev[e.dst] = e.src;\n    FORIT(f,g[e.dst]){\n      if(dist[f->dst] > e.weight + f->weight){\n        dist[f->dst] = e.weight + f->weight;\n        que.push(Edge(f->src, f->dst, dist[f->dst]));\n      }\n    }\n  }\n  return make_pair(dist, prev);\n}\n\nint main(){\n  int na,nb;\n  while(cin>>na>>nb){\n    vector<P> pa(na);\n    vector<P> pb(nb);\n    REP(i,na){\n      int x,y; cin>>x>>y;\n      pa[i] = P(x,y);\n    }\n    REP(i,nb){\n      int x,y; cin>>x>>y;\n      pb[i] = P(x,y);\n    }\n    L la = L(pa[0],pa[1]);\n    double da = abs(pa[0]-pa[1]);\n    L lb = L(pb[0],pb[1]);\n    double db = abs(pb[0]-pb[1]);\n    Graph graph1(na);\n    REP(i,na)FOR(j,i+1,na){\n      L l = L(pa[i],pa[j]);\n      if(!intersectSS(l,lb)){\n        graph1[i].push_back(Edge(i,j,abs(pa[i]-pa[j])));\n        graph1[j].push_back(Edge(j,i,abs(pa[i]-pa[j])));\n      }\n    }\n    pair<vector<Weight>,vector<int> > dijk1 = dijkstra(graph1, 0);\n    double len1 = dijk1.first[1];\n    double ans1 = len1 + db;\n    Graph graph2(nb);\n    REP(i,nb)FOR(j,i+1,nb){\n      L l = L(pb[i],pb[j]);\n      if(!intersectSS(l,la)){\n        graph2[i].push_back(Edge(i,j,abs(pb[i]-pb[j])));\n        graph2[j].push_back(Edge(j,i,abs(pb[i]-pb[j])));\n      }\n    }\n    pair<vector<Weight>,vector<int> > dijk2 = dijkstra(graph2, 0);\n    double len2 = dijk2.first[1];\n    double ans2 = len2 + da;\n    double ans = min(ans1,ans2);\n    if(ans >= INF-EPS){\n      cout<<-1<<endl;\n    }else{\n      printf(\"%.12lf\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define N 1001\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.f,s1.s,s2.f) * ccw(s1.f,s1.s,s2.s) <= 0 &&\n           ccw(s2.f,s2.s,s1.f) * ccw(s2.f,s2.s,s1.s) <= 0 );\n}\n\ntypedef pair<double,int> Pi;\ndouble dijkstra(vector<P>A,vector<P>B){\n  vector<double>D(N,INF);\n  priority_queue<Pi,vector<Pi>,greater<Pi> >Q;\n  Q.push(Pi(0,0));\n  D[0]=0;\n  while(!Q.empty()){\n    Pi t=Q.top();Q.pop();\n    int pos=t.s;\n    double cost=t.f;\n    if(D[pos]<cost)continue;\n    if(pos==1)return cost+abs(A[0]-A[1]);    \n\n    for(int i=0;i<B.size();i++){\n      double ncost=cost+abs(B[pos]-B[i]);\n      if(isIntersect(L(A[0],A[1]),L(B[pos],B[i]))||D[i]<=ncost)continue;\n      D[i]=ncost;\n      Q.push(Pi(ncost,i));\n    }\n  }\n  return INF;\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  vector<P> A(n),B(m); \n  for(int i=0,x,y;i<n;i++)cin>>x>>y,A[i]=P(x,y);\n  for(int i=0,x,y;i<m;i++)cin>>x>>y,B[i]=P(x,y);\n  double ans=min(dijkstra(A,B),dijkstra(B,A));\n  printf(\"%.10f\\n\",ans<INF? ans:-1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000009;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<class T>\nvector<T> dijkstra(const WeightedGraph<T> &G,int source = 0){\n\tusing P = pair<T,int>;\n\tvector<T> dist(G.size(),INF);\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tdist[source] = 0;\n\tque.emplace(dist[source],source);\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first) continue;\n\t\tfor(const auto &e : G[v]){\n\t\t\tif(dist[e.to] > dist[v] + e.cost){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.emplace(dist[e.to],e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nusing Float = double;\nusing Point = complex<Float>;\nstruct Line{\n\tPoint a,b;\n\tLine(Point a,Point b) : a(a),b(b){}\n};\nstruct Segment : Line{ Segment(Point a,Point b) : Line(a,b){} };\nstruct Circle{ Point p; Float r; };\n\ninline bool eq(Float a,Float b) { return abs(a - b) < EPS; }\ninline Float dot(const Point &a,const Point &b){ return real(conj(a) * b); }\ninline Float cross(const Point &a,const Point &b){ return imag(conj(a) * b); }\n\nint ccw(const Point &a,Point b,Point c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return +1; //ccw\n\tif(cross(b,c) < -EPS) return -1; //cw\n\tif(dot(b,c) < 0) return -2; //c-a-b\n\tif(norm(b) < norm(c)) return +2; //a-b-c\n\treturn 0; //a-c-b\n}\n\ninline bool intersect(const Segment &s,const Segment &t){\n\treturn ccw(s.a,s.b,t.a) * ccw(s.a,s.b,t.b) <= 0\n\t&& ccw(t.a,t.b,s.a) * ccw(t.a,t.b,s.b) <= 0;\n}\n\nsigned main(){\n\tint n[2];\n\tcin >> n[0] >> n[1];\n\tvector<WeightedGraph<double>> G(2);\n\tPoint ps[2][1010];\n\tfor(int i = 0;i < 2;i++){\n\t\tG[i].resize(n[i]);\n\t\tfor(int j = 0;j < n[i];j++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tps[i][j] = Point(x,y);\n\t\t}\n\t}\n\tfor(int i = 0;i < 2;i++){\n\t\tfor(int j = 0;j < n[i];j++){\n\t\t\tfor(int k = j + 1;k < n[i];k++){\n\t\t\t\tif(!intersect(Segment(ps[i][j],ps[i][k]),Segment(ps[!i][0],ps[!i][1]))){\n\t\t\t\t\tG[i][j].emplace_back(k,abs(ps[i][j] - ps[i][k]));\n\t\t\t\t\tG[i][k].emplace_back(j,abs(ps[i][j] - ps[i][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = min(\n\t\tdijkstra(G[0],0)[1] + abs(ps[1][0] - ps[1][1]),\n\t\tdijkstra(G[1],0)[1] + abs(ps[0][0] - ps[0][1])\n\t);\n\tif(ans > INF / 2) cout << -1 << endl;\n\telse printf(\"%.15lf\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,int> P;\n\nstruct point{\n  ll x,y;  \n  point operator + (const point &p)const{\n    return (point){x+p.x,y+p.y};\n  }\n  point operator - (const point &p)const{\n    return (point){x-p.x,y-p.y};\n  }\n  point operator * (const ll r)const{\n    return (point){x*r,y*r};\n  }\n  bool operator < (const point &p)const{\n    return (x==p.x?y<p.y:x<p.x);\n  }\n};\n\nll dot(point a,point b){\n  return a.x*b.x+a.y*b.y;\n}\nll norm(point a){\n  return dot(a,a);\n}\nll cross(point a,point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nint ccw(point a,point b,point c){\n  if(cross(b-a,c-a)>0)return 1;//ccw\n  if(cross(b-a,c-a)<0)return -1;//cw\n  if(dot(b-a,c-a)<0)return 2;//back\n  if(norm(b-a)<norm(c-a))return -2;//front\n  return 0;//on\n}\n\nbool isIntersect(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\n\ndouble solve(vector<point> &t,int n,point sp,point tp){\n  vector<double> d(n,1e20);\n  d[0]=0;\n  priority_queue< P , vector<P> , greater<P> > Q;\n  Q.push(P(0,0));\n  while(!Q.empty()){\n    P p=Q.top();Q.pop();\n    int pos=p.second;\n    double cost=p.first;\n    if(d[pos]<cost)continue;\n    for(int to=0;to<n;to++){\n      if(to==pos || isIntersect(t[pos],t[to],sp,tp))continue;\n      double ncost = cost + sqrt(norm(t[pos]-t[to]));\n      if(ncost<d[to]){\n        d[to]=ncost;\n        Q.push(P(ncost,to));\n      }\n    }\n  }  \n  return d[1]+sqrt(norm(sp-tp));\n  \n}\n\nint a,b;\nvector<point> A,B;\n\nint main(){\n  cin>>a>>b;\n  A.resize(a);\n  B.resize(b);\n  for(int i=0;i<a;i++)cin>>A[i].x>>A[i].y;\n  for(int i=0;i<b;i++)cin>>B[i].x>>B[i].y;\n  double ans;  \n  if( isIntersect( A[0],A[1],B[0],B[1] ) ){\n    ans=min(solve(A,a,B[0],B[1]),solve(B,b,A[0],A[1]));    \n  }else{\n    ans=sqrt(norm(A[0]-A[1]))+sqrt(norm(B[0]-B[1]));\n  }\n  if(ans>=1e20){\n    printf(\"-1\\n\");\n  }else{\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define INF (0x3f3f3f3f)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\n\ndouble dot(P a,P b){\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a,P b){\n\treturn a.real()*b.imag()-a.imag()*b.real();\n}\n\nint ccw(P a,P b,P c){\n\tP d = b-a;\n\tc-=a;\n\tdouble cr = cross(d,c);\n\tif(cr < -EPS) return 1;\n\tif(cr > EPS) return -1;\n\tif(dot(d,c) < -EPS) return 2;\n\tif(norm(d) < norm(c) - EPS) return -2;\n\treturn 0;\n}\n\nint is_intersected_ls(P a1,P a2,P b1,P b2){\n\treturn ccw(a1,a2,b1)*ccw(a1,a2,b2) <= 0 && ccw(b1,b2,a1)*ccw(b1,b2,a2) <= 0;\n}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvector<vector<double>> a(n,vector<double>(n,INF));\n\tvector<vector<double>> b(m,vector<double>(m,INF));\n\tvector<P> v(n);\n\tvector<P> w(m);\n\trep(i,n){\n\t\tdouble aa,bb;\n\t\tcin>>aa>>bb;\n\t\tv[i] = P(aa,bb);\n\t}\n\trep(i,m){\n\t\tdouble aa,bb;\n\t\tcin>>aa>>bb;\n\t\tw[i] = P(aa,bb);\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i==j) a[i][j] = 0;\n\t\t\telse{\n\t\t\t\tif(is_intersected_ls(w[0],w[1],v[i],v[j])){\n\t\t\t\t\ta[i][j] = INF;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ta[i][j] = abs(v[i]-v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,m){\n\t\trep(j,m){\n\t\t\tif(i==j) b[i][j] = 0;\n\t\t\telse{\n\t\t\t\tif(is_intersected_ls(v[0],v[1],w[i],w[j])){\n\t\t\t\t\tb[i][j] = INF;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tb[i][j] = abs(w[i]-w[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<pair<double,int>> pq;\n\tdouble ans = INF;\n\tvector<int> used(n);\n\tvector<double> d(n,INF);\n\tpq.push(make_pair(-0.0,0));\n\twhile(pq.size()){\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tif(d[top.second] < -top.first) continue;\n\t\tused[top.second] = 1;\n\t\trep(i,n){\n\t\t\tif(used[i]) continue;\n\t\t\tif(d[i] < -top.first + a[top.second][i]) continue;\n\t\t\td[i] = -top.first + a[top.second][i];\n\t\t\tpq.push(make_pair(top.first - a[top.second][i],i));\n\t\t}\n\t}\n\tans=min(ans,d[1]+abs(w[0]-w[1]));\n\tpq.push(make_pair(-0.0,0));\n\td.assign(m,INF);\n\tused.assign(m,0);\n\twhile(pq.size()){\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tif(d[top.second] < -top.first) continue;\n\t\tused[top.second] = 1;\n\t\trep(i,m){\n\t\t\tif(used[i]) continue;\n\t\t\tif(d[i] < -top.first + b[top.second][i]) continue;\n\t\t\td[i] = -top.first + b[top.second][i];\n\t\t\tpq.push(make_pair(top.first - b[top.second][i],i));\n\t\t}\n\t}\n\tans=min(ans,d[1]+abs(v[0]-v[1]));\n\tcout<<fixed<<setprecision(10);\n\tif(ans>=INF) cout<<-1<<endl;\n\telse{\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ld double\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tld ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph ga(pa.size()), gb(pb.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tld d = abs(pa[i] - pa[j]);\n\t\tadd_edge(ga, i, j, d);\n\t\tadd_edge(ga, j, i, d);\n\t}\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tld d = abs(pb[i] - pb[j]);\n\t\tadd_edge(gb, i, j, d);\n\t\tadd_edge(gb, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(ga, da, 0);\n\tdijkstra(gb, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst double inf=1e9;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\n//END CUT HERE\n//幾何ライブラリ\n//ほぼ、https://ei1333.github.io/algorithm/geometry_new.html からパクりました\n//\n//\nusing Real=double;//問題によってはlong double に変更してください\nconst Real EPS=1e-8;//問題によって値を変更してください\nconst Real PI=acos(-1.0);//3.141592653589793238...\ninline bool eq(Real a,Real b){return fabs(b-a)<EPS;}//誤差を考慮した等価判定\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\ntypedef complex<Real> Point;//点\n\n//直線\nstruct Line{\n    Point p1,p2;\n    Line()= default;\n    Line(Point a,Point b):p1(a),p2(b){};\n};\n\n//線分\nstruct Segment:Line{\n    Segment()= default;\n    Segment(Point a,Point b):Line(a,b){}\n};\n\n//円\n/*class circle{\n    Point a;\n    Real r;\n    //Circle()= default;\n    circle(Point a,Real r):a(a),r(r){};\n};*/\n\ntypedef Point Vector;//ベクトル\ntypedef vector<Point> Polygon;//多角形\ntypedef vector<Line> Lines;\ntypedef vector<Segment> Segments;\ntypedef vector<Point> Points;\n\nPoint rotate(Real theta,const Point& p){\n    return Point(cos(theta)*p.real()-sin(theta)*p.imag(),sin(theta)*p.real()+cos(theta)*p.imag());\n}\n\nReal radian_to_degree(Real r){\n    return (r*180.0/PI);\n}\n\nReal degree_to_radian(Real d){\n    return (d*PI/180.0);\n}\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nReal get_angle(const Point& a,const Point& b,const Point& c){\n    const Point v(b-a),w(c-b);\n    Real alpha=atan2(v.imag(),v.real()),beta=atan2(w.imag(),w.real());\n    if(alpha>beta)swap(alpha,beta);\n    Real theta=beta-alpha;\n    return min(theta,2*PI-theta);\n}\n\n//点同士の大小比較\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\n//外積\nReal cross(const Point& a,const Point& b){\n    return a.real()*b.imag()-a.imag()*b.real();\n}\n\n//内積\nReal dot(const Point& a,const Point& b){\n    return a.real()*b.real()+a.imag()*b.imag();\n}\n\n\nint ccw(Point a,Point b,Point c){\n    b=b-a;c=c-a;\n    if(cross(b,c)>EPS)return COUNTER_CLOCKWISE;//1\n    if(cross(b,c)<-EPS)return CLOCKWISE;//-1\n    if(dot(b,c)<0)return ONLINE_BACK;//2\n    if(norm(b)<norm(c))return ONLINE_FRONT;//-2\n    return ON_SEGMENT;//0\n}\n\n//直交判定\nbool isOrthogonal(Vector a,Vector b){\n    return eq(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return eq(dot(a1-a2,b1-b2),0.0);\n}\n\nbool isOrthogonal(Segment a,Segment b){\n    return eq(dot(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n\n//平行判定\nbool isParallel(Vector a,Vector b){\n    return eq(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return eq(cross(a1-a2,b1-b2),0.0);\n}\n\nbool isParallel(Segment a,Segment b){\n    return eq(cross(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n\n//射影\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    Real r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint project(Line l,Point p){\n    Vector base=l.p2-l.p1;\n    Real r=dot(p-l.p1,base)/norm(base);\n    return l.p1+base*r;\n}\n\n//反射\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2;\n}\n\n//交差判定\nbool intersect(const Line& l,const Point& p){\n    return abs(ccw(l.p1,l.p2,p))!=1;\n}\n\nbool intersect(const Line& l,const Line& m){\n    return abs(cross(l.p2-l.p1,m.p2-m.p1))>EPS || abs(cross(l.p2-l.p1,m.p2-l.p1))<EPS;\n}\n\nbool intersect(const Segment& s,const Point& p){\n    return abs(ccw(s.p1,s.p2,p))==0;\n}\n\nbool intersect(const Line& l,const Segment& s){\n    return cross(l.p2-l.p1,s.p1-l.p1)*cross(l.p2-l.p1,s.p2-l.p1)<EPS;\n}\n\nReal getDistance(const Line& l,const Point& p);\n\n/*bool intersect(const Circle& c,const Line& l){\n    return getDistance(l,c.a)<=c.r+EPS;\n}\n\nbool intersect(const Circle& c,const Point& p){\n    return abs(abs(c.a-p)-c.r)<EPS;\n}*/\n\nbool intersect(const Segment& s,const Segment& t){\n    return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2)<=0 && ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2)<=0;\n}\n\n/*int intersect(const Circle& c,const Segment& s){\n    if(norm(project(s,c.a)-c.a)-c.r*c.r>EPS)return 0;\n    auto d1=abs(c.a-s.p1),d2=abs(c.a-s.p2);\n    if(d1<c.r+EPS && d2<c.r+EPS)return 0;\n    if(d1<c.r-EPS && d2>c.r+EPS || d1>c.r+EPS && d2<c.r-EPS)return 1;\n    const Point p=project(s,c.a);\n    if(dot(s.p1-p,s.p2-p)<0)return 2;\n    return 0;\n}\n\nint intersect(const Circle& c1,const Circle& c2){\n    if(c1.r<c2.r)swap(c1,c2);\n    Real d=abs(c1.a-c2.a);\n    if(c1.r+c2.r<d)return 4;//お互いの円は離れていて接していない\n    if(eq(c1.r+c2.r,d))return 3;//円は一箇所で接している\n    if(c1.r-c2.r<d)return 2;//交点が二箇所ある\n    if(eq(c1.r-c2.r,d))return 1;//片方の円が他方の円を内包していて、一箇所で接している\n    return 0;//片方の円が他方の円を内包しているが、接してはいない(交点はない)\n}*/\n\n//距離\nReal getDistance(const Point& a,const Point& b){\n    return abs(a-b);\n}\n\nReal getDistance(const Line &l, const Point &p) {\n    return abs(p-project(l,p));\n}\n\nReal getDistance(const Line& l,const Line& m){\n    return (intersect(l,m)?0:getDistance(l,m.p1));\n}\n\nReal getDistance(const Segment& s,const Point& p){\n    Point t=project(s,p);\n    if(intersect(s,t))return abs(p-t);\n    else return min(abs(s.p1-p),abs(s.p2-p));\n}\n\nReal getDistance(const Segment& s,const Segment& t){\n    if(intersect(s,t))return 0;\n    return min({getDistance(s,t.p1),getDistance(s,t.p2),getDistance(t,s.p1),getDistance(t,s.p2)});\n}\n\nReal getDistance(const Line& l,const Segment& s){\n    if(intersect(l,s))return 0;\n    return min(getDistance(l,s.p1),getDistance(l,s.p2));\n}\n\n//交点計算\nPoint crosspoint(const Line& l,const Line& m){\n    Real a=cross(l.p2-l.p1,m.p2-m.p1);\n    Real b=cross(l.p2-l.p1,l.p2-m.p1);\n    if(eq(a,0.0) && eq(b,0.0))return m.p1;\n    return m.p1+(m.p2-m.p1)*b/a;\n}\n\nPoint crosspoint(const Segment& s,const Segment& t){\n    return crosspoint(Line(s),Line(t));\n}\n\n//Shortest_Path\n//グラフの最短距離を求めるアルゴリズムを3種類持っているクラスです\nclass shortest_path{\npublic:\n    \n    //dijkstra法とBellman_Ford法を使うときは、このコンストラクタを使ってください\n    explicit shortest_path(int n):vertex(n),INF((double)1e9){\n        v1.resize(static_cast<unsigned long>(vertex));\n    }\n    \n    //Warshall_Floyd法を使うときは、こちらのコンストラクタを使ってください\n    shortest_path(int n,double inf):vertex(n),INF(inf){\n        v2.resize(static_cast<unsigned long>(vertex));\n        for(int i=0;i<vertex;i++)v2[i].resize(static_cast<unsigned long>(vertex));\n        for(int i=0;i<vertex;i++){\n            for(int j=0;j<vertex;j++){\n                v2[i][j]=INF;\n            }\n        }\n        for(int i=0;i<vertex;i++)v2[i][i]=0;\n    }\n    \n    //dijkstra法とBellman_Ford法専用のadd_edge(int from,int to,ll cost)です\n    //コストcostの頂点fromから頂点toへの有向辺を追加するときadd_edge(int from,int to,ll cost)\n    void add_edge(int from,int to,double cost){\n        v1[from].push_back({to,cost});\n    }\n    \n    //Warshall_Floyd法専用のadd_edge(int from,int to,ll cost)です\n    //コストcostの頂点fromから頂点toへの有向辺を追加するときadd_edge(int from,int to,ll cost)\n    void add_edge_(int from,int to,ll cost){//warshall_floyd\n        v2[from][to]=cost;\n    }\n    \n    //Dijkstra法です\n    //各頂点への距離が格納されたvector<ll>が求まります\n    //負のコストの辺がある場合は使えません\n    //start地点の頂点番号を引数に入れてください\n    vector<double> dijkstra(unsigned int start){\n        vector<double> d(static_cast<unsigned long>(vertex),INF);\n        priority_queue<pair<double,int> > q;\n        d[start]=0;\n        q.push({0,start});\n        while(!q.empty()){\n            int now=q.top().se;\n            double now_cost=-q.top().fi;\n            q.pop();\n            if(d[now]<now_cost)continue;\n            for (auto &i : v1[now]) {\n                if(d[i.fi]>now_cost+ i.se){\n                    d[i.fi]=now_cost+ i.se;\n                    q.push({-d[i.fi], i.fi});\n                }\n            }\n        }\n        return d;\n    }\n    \n    //Warshall_Floyd法です\n    //各頂点への距離が格納されたvector<ll>と閉路があるかどうかの情報の2つのtupleが返されます\n    //閉路があるとき、返り値はtrueです\n    tuple<vector<vector<ll> >,bool> warshall_floyd(){\n        for(int k=0;k<vertex;k++){\n            for(int i=0;i<vertex;i++){\n                if(v2[i][k]==INF)continue;\n                for(int j=0;j<vertex;j++){\n                    if(v2[k][j]==INF)continue;\n                    v2[i][j]=min(v2[i][j],v2[i][k]+v2[k][j]);\n                }\n            }\n        }\n        bool is_negative_cycle=false;\n        for(int i=0;i<vertex;i++){\n            if(v2[i][i]<0)is_negative_cycle=true;\n        }\n        return make_tuple(v2,is_negative_cycle);\n    }\n\n    //Bellman_Ford法です\n    //各頂点への距離が格納されたvector<ll>と閉路があるかどうかの情報の2つのtupleが返されます\n    //閉路があるとき、返り値はtrueです\n    //start地点の頂点番号を引数に入れてください\n    tuple<vector<ll>,bool> bellman_ford(int start){\n        vector<ll> d(static_cast<unsigned long>(vertex),INF);\n        d[start]=0;\n        bool is_negative_cycle=false;\n        for(int i=0;i<vertex;i++){\n            bool update= false;\n            for(int j=0;j<vertex;j++){\n                if(d[j]==INF)continue;\n                for(int k=0;k<(int)v1[j].size();k++){\n                    if(d[v1[j][k].fi]>d[j]+v1[j][k].se){\n                        d[v1[j][k].fi]=d[j]+v1[j][k].se;\n                        update= true;\n                    }\n                }\n            }\n            if(i==vertex-1 && update)is_negative_cycle=true;\n            else if(!update)break;\n        }\n        return make_tuple(d,is_negative_cycle);\n    }\nprivate:\n    double INF;\n    int vertex;\n    vector<vector<pair<int,double> > > v1;\n    vector<vector<ll> > v2;\n};\n//tuple tp<int,int,int> -> int a=get<0>(tp),b=get<1>(tp),c=get<2>(tp)\n\nint na,nb;\ndouble xa[1001],ya[1001],xb[1001],yb[1001];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int na,nb;\n  cin>>na>>nb;\n  for(int i=0;i<na;i++){\n    cin>>xa[i]>>ya[i];\n  }\n  for(int i=0;i<nb;i++){\n    cin>>xb[i]>>yb[i];\n  }\n  Point tmp(xb[0],yb[0]);\n  Point tmp2(xb[1],yb[1]);\n  Segment s1(tmp,tmp2);\n  shortest_path sp1(na);\n  //cout<<1<<endl;\n  for(int i=0;i<na;i++){\n    for(int j=i+1;j<na;j++){\n      Point a(xa[i],ya[i]);\n      Point b(xa[j],ya[j]);\n      Segment aa(a,b);\n      //cout<<aa.p1<<\" \"<<aa.p2<<endl;\n      if(!intersect(s1,aa)){\n        //cout<<i<<\"--\"<<j<<endl;\n        sp1.add_edge(i,j,sqrt((xa[i]-xa[j])*(xa[i]-xa[j])+(ya[i]-ya[j])*(ya[i]-ya[j])));\n        sp1.add_edge(j,i,sqrt((xa[i]-xa[j])*(xa[i]-xa[j])+(ya[i]-ya[j])*(ya[i]-ya[j])));\n      }\n    }\n  }\n  vector<double> di1=sp1.dijkstra(0);\n  double ans;\n  if(di1[1]!=1e9){\n    ans=di1[1]+getDistance(tmp,tmp2);\n  }else{\n    ans=inf;\n  }\n  Point tmp3(xa[0],ya[0]);\n  Point tmp4(xa[1],ya[1]);\n  Segment s2(tmp3,tmp4);\n  shortest_path sp2(nb);\n  //cout<<2<<endl;\n  for(int i=0;i<nb;i++){\n    for(int j=i+1;j<nb;j++){\n      Point a(xb[i],yb[i]);\n      Point b(xb[j],yb[j]);\n      Segment aa(a,b);\n      if(!intersect(s2,aa)){\n        //cout<<i<<\"--\"<<j<<endl;\n        sp2.add_edge(i,j,sqrt((xb[i]-xb[j])*(xb[i]-xb[j])+(yb[i]-yb[j])*(yb[i]-yb[j])));\n        sp2.add_edge(j,i,sqrt((xb[i]-xb[j])*(xb[i]-xb[j])+(yb[i]-yb[j])*(yb[i]-yb[j])));\n      }\n    }\n  }\n  vector<double> di2=sp2.dijkstra(0);\n  if(di2[1]!=inf){\n    ans=min(ans,di2[1]+getDistance(tmp3,tmp4));\n  }else{\n    ans=min(ans,inf);\n  }\n  if(ans!=inf){\n    printf(\"%.12f\\n\",ans);\n  }else{\n    cout<<-1<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define M 1001\nstruct edge{int to;double cost;};\ntypedef double D;\ntypedef complex<D> P;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b-=a;c-=a;\n  if (cross(b,c) >  EPS) return +1;\n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;  \n  if (norm(b) < norm(c)) return -2; \n  return 0;\n}\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1,a2,b1)*ccw(a1,a2,b2)<=0&&ccw(b1,b2,a1)*ccw(b1,b2,a2)<=0;\n}\ndouble dist(P a,P b){\n  return sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\nint na,nb;\ntypedef pair<int,double> PE;\ndouble ax[M],ay[M],bx[M],by[M];\nvector<edge>v[2][M];\nedge tmp;\ndouble dij(int x){\n  double d[M];\n  r(i,M)d[i]=1e8;\n  priority_queue<PE,vector<PE>,greater<PE> >q;\n  q.push(PE(0,0));\n  d[0]=0;\n  while(!q.empty()){\n    PE p=q.top();q.pop();\n    int t=p.first;\n    double co=p.second;\n    if(d[t]<co)continue;\n    r(i,v[x][t].size()){\n      tmp=v[x][t][i];\n      int tot=v[x][t][i].to;\n      double co2=v[x][t][i].cost;\n      if(d[tot]>co2+co){\n        d[tot]=co2+co;\n        q.push(PE(tot,co2+co));\n      }\n    }\n  }\n  return d[1];\n}\nint main(){\n  cin>>na>>nb;\n  r(i,na)cin>>ax[i]>>ay[i];\n  r(i,nb)cin>>bx[i]>>by[i];\n  r(i,na)r(j,na)if(!isecSS(P(ax[i],ay[i]),P(ax[j],ay[j]),P(bx[0],by[0]),P(bx[1],by[1]))){\n    tmp.to=j,tmp.cost=dist(P(ax[i],ay[i]),P(ax[j],ay[j]));\n    v[0][i].push_back(tmp);\n  }\n  r(i,nb)r(j,nb)if(!isecSS(P(bx[i],by[i]),P(bx[j],by[j]),P(ax[0],ay[0]),P(ax[1],ay[1]))){\n    tmp.to=j,tmp.cost=dist(P(bx[i],by[i]),P(bx[j],by[j]));\n    v[1][i].push_back(tmp);\n  }\n  double a2=dist(P(ax[0],ay[0]),P(ax[1],ay[1]));\n  double b2=dist(P(bx[0],by[0]),P(bx[1],by[1]));\n  double a1=dij(0),b1=dij(1);\n  if(a1==1e8&&b1==1e8)cout<<(-1)<<endl;\n  else if(a1+b2<b1+a2)printf(\"%.9f\\n\",a1+b2);\n  else printf(\"%.9f\\n\",a2+b1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 0\n\nclass D3 {\npublic:\n\tlong double X, Y, Z, EPS;\n\n\tD3( long double, long double, long double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( long double );\n\tD3 operator*( long double );\n\tD3 operator/( long double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3 {\npublic:\n\tPoint( long double, long double, long double );\n\tlong double getX();\n\tlong double getY();\n\tlong double getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tlong double S_point( Point, Point );\n\tlong double V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec {\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( long double x_, long double y_, long double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( long double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( long double );\n\tbool operator== ( Vec );\n\tbool operator==( long double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tlong double length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tlong double S_vec( Vec );\n\tlong double V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( long double ld ) {\n\treturn ( *this ) == D3();\n}\n\nD3 D3::operator*( long double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( long double ld ) {\n\treturn  *this*( ld*-1.L );\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\nlong double Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\nlong double Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\nlong double Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( ( *this ).getX() != Partner.getX() ) {\n\t\treturn ( *this ).getX() < Partner.getX();\n\t}\n\tif( ( *this ).getY() != Partner.getY() ) {\n\t\treturn ( *this ).getY() < Partner.getY();\n\t}\n\treturn ( *this ).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < ( *this );\n}\n//??????????????¢???????±???????\nlong double Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\nlong double Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( ( *this ), B ).V_vec( Vec( ( *this ), C ), Vec( ( *this ), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( long double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + ( Partner*( -1.L ) );\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( long double ld ) {\n\treturn *this*( 1.L / ld );\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( long double ) {\n\treturn ( *this ) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\nlong double Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / ( *this ).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn ( *this )*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( ( *this ).Inverse_vec().getD(), ( *this ).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn ( *this ).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn ( *this ).Unit_vec().getD() == Partner.Unit_vec().getD() || ( *this ).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) );\n\tVec Q = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getSP() ) );\n\tVec R = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getGP() ) );\n\treturn ( !( *this ).Parallel( Partner ) ) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS ) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS );\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( ( *this ).isIntersection( Partner ) ) {\n\t\tlong double d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) ).D.Z );\n\t\tlong double d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) ).D.Z );\n\t\tlong double t = d1 / ( d1 + d2 );\n\t\treturn Vec( ( ( *this )*t ).getD(), ( *this ).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( ( *this ).getSP(), A );\n\tif( A == ( ( *this ).getSP() ) || ( Test.Parallel( *this ) && ( *this ).getD().X / Test.getD().X >= 1.0L ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\nlong double Vec::S_vec( Vec B ) {\n\tif( ( ( *this ).getSP() == B.getSP() ) ) {\n\t\tVec G = ( *this ).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( ( *this ).getGP() == B.getSP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B );\n\t}\n\tif( ( *this ).getSP() == B.getGP() ) {\n\t\treturn ( *this ).S_vec( B.Reverse_vec() );\n\t}\n\tif( ( *this ).getGP() == B.getGP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\nlong double Vec::V_vec( Vec B, Vec C ) {\n\tVec G = ( *this ).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points {\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance {\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n\n\nvector<vector<pair<long long int, long double>>>makelist( vector<Point>&townlist, Vec DisallowVec ) {\n\tvector<vector<pair<long long int, long double>>>ret( townlist.size() );\n\tfor( size_t i = 0; i < townlist.size(); i++ ) {\n\t\tfor( size_t j = i + 1; j < townlist.size(); j++ ) {\n\t\t\tVec now = Vec( townlist[i], townlist[j] );\n\t\t\tif( !now.isIntersection( DisallowVec ) ) {\n\t\t\t\tret[i].push_back( make_pair( j, now.length() ) );\n\t\t\t\tret[j].push_back( make_pair( i, now.length() ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\ndouble dijkstra( vector<vector<pair<long long int, long double>>>  listLen ) {\n\tvector<double>ret( listLen.size(), DBL_MAX / 10 );\n\tpriority_queue<pair< double, long long int>, vector<pair<double, long long int>>, greater<pair<double, long long int>>>que;\n\tque.push( make_pair( 0, 0 ) );\n\tret[0] = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( now.second == 1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif( now.first != ret[now.second] ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( auto next : listLen[now.second] ) {\n\t\t\tif( ret[next.first] > now.first + next.second ) {\n\t\t\t\tret[next.first] = now.first + next.second;\n\t\t\t\tif( ret[next.first] < ret[1] ) {\n\t\t\t\t\tque.push( make_pair( now.first + next.second, next.first ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret[1];\n}\n\n\nint main() {\n\tlong long int NA, NB;\n\tcin >> NA >> NB;\n\tvector<Point>townA( NA ), townB( NB );\n\tfor( size_t i = 0; i < NA; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownA[i] = Point( x, y );\n\t}\n\tfor( size_t i = 0; i < NB; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownB[i] = Point( x, y );\n\t}\n\n\tauto listA = makelist( townA, Vec( townB[0], townB[1] ) );\n\tauto listB = makelist( townB, Vec( townA[0], townA[1] ) );\n\n\tlong double lenA = dijkstra( listA );\n\tlong double lenB = dijkstra( listB );\n\n\tif( lenA == DBL_MAX / 10 && lenB == DBL_MAX / 10 ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << fixed << setprecision( 20 ) << min( lenA + Vec( townB[0], townB[1] ).length(), lenB + Vec( townA[0], townA[1] ).length() ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef double D;\nstruct P{int x,y;};\nconst D INF = 1e15;\n\ninline int dot(P a, P b){return a.x*b.x + a.y*b.y;}\ninline int cross(P a, P b){return a.x*b.y - a.y*b.x;}\ninline int norm(P a){return a.x*a.x + a.y*a.y;}\n\ninline int ccw(P a, P b, P c){\n  b.x -= a.x, b.y -= a.y;\n  c.x -= a.x, c.y -= a.y;\n  if(cross(b,c)>0)    return +1;   //counter clockwise\n  if(cross(b,c)<0)    return -1;   //clockwise\n  if(dot(b,c)<0)      return +2;   //c--a--b on line\n  if(norm(b)<norm(c)) return -2;   //a--b--c on line\n  return 0;                        //on segment\n}\n\ninline bool is_cp(P a1, P a2, P b1, P b2){\n  if(ccw(a1,a2,b1)*ccw(a1,a2,b2)<=0)\n    if(ccw(b1,b2,a1)*ccw(b1,b2,a2)<=0)return true;\n  return false;\n}\n\ninline D dis(P a, P b){\n  return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );\n}\n\nD dijk(const vector<P> &x, P l1, P l2){\n  int n = x.size();\n  vector<int> use(n,0);\n  vector<D> d(n,INF); d[0] = 0;\n  rep(i,n){\n    int v = -1;\n    rep(u,n){\n      if(!use[u] && (v<0 || d[v] > d[u]))v = u;\n    }\n    if(v==1)return d[1];\n    use[v] = 1;\n\n    rep(u,n){\n      if(v!=u && !is_cp(x[v],x[u],l1,l2)){\n\td[u] = min(d[u], d[v] + dis(x[v],x[u]));\n      }\n    }\n  }\n  return INF;\n}\n\nint main(){\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  \n  vector<P> a(n),b(m);\n  rep(i,n)scanf(\"%d%d\",&a[i].x,&a[i].y);\n  rep(i,m)scanf(\"%d%d\",&b[i].x,&b[i].y);\n\n  D res = min(dijk(a,b[0],b[1]) + dis(b[0],b[1]),\n\t      dijk(b,a[0],a[1]) + dis(a[0],a[1]));\n  if(res>=INF)puts(\"-1\");\n  else printf(\"%.12lf\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-10;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\n\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n\nld dp[1111][1111];\nld dq[1111][1111];\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<Point> p(n),q(m);\n    rep(i,n){\n        int x,y;\n        cin>>x>>y;\n        p[i]=Point(x,y);\n    }\n    rep(i,m){\n        int x,y;\n        cin>>x>>y;\n        q[i]=Point(x,y);\n    }\n    rep(i,n)rep(j,n)dp[i][j]=abs(p[i]-p[j]);\n    rep(i,m)rep(j,m)dq[i][j]=abs(q[i]-q[j]);\n    ld ans=1e9;\n    vector<ld> distp(n,inf);\n    distp[0]=0;\n    priority_queue<pair<ld,int>,vector<pair<ld,int>>,greater<pair<ld,int> > > que;\n    que.push({0,0});\n    while(que.size()){\n        ld d=que.top().first;\n        int cur=que.top().second;\n        que.pop();\n        if(d>distp[cur])continue;\n        rep(i,n){\n            if(cur==i)continue;\n            if(isis_ss(Line{p[cur],p[i]},Line{q[0],q[1]}))continue;\n            if(distp[i]>distp[cur]+dp[i][cur]){\n                distp[i]=distp[cur]+dp[i][cur];\n                que.emplace(distp[i],i);\n            }\n        }\n    }\n\n    vector<ld> distq(m,inf);\n    distq[0]=0;\n    que.push({0,0});\n    while(que.size()){\n        ld d=que.top().first;\n        int cur=que.top().second;\n        que.pop();\n        if(d>distq[cur])continue;\n        rep(i,m){\n            if(cur==i)continue;\n            if(isis_ss(Line{q[cur],q[i]},Line{p[0],p[1]}))continue;\n            if(distq[i]>distq[cur]+dq[i][cur]){\n                distq[i]=distq[cur]+dq[i][cur];\n                que.emplace(distq[i],i);\n            }\n        }\n    }\n    ans = min(ans,dq[0][1]+distp[1]);\n    ans = min(ans,dp[0][1]+distq[1]);\n    if(ans>=1e9){\n        cout<<-1<<endl;\n    }\n    else cout<<fixed<<setprecision(12)<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <complex>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\n#define INF 1e9\n\ntypedef complex<int> P;\ntypedef pair<P, P> Line;\n\n// ?????????????????????\nbool judgeIentersected(Line a, Line b){\n  int ta = (b.first.real() - b.second.real()) * (a.first.imag() - b.first.imag())\n    + (b.first.imag() - b.second.imag()) * (b.first.real() - a.first.real());\n  int tb = (b.first.real() - b.second.real()) * (a.second.imag() - b.first.imag())\n    + (b.first.imag() - b.second.imag()) * (b.first.real() - a.second.real());\n  int tc = (a.first.real() - a.second.real()) * (b.first.imag() - a.first.imag())\n    + (a.first.imag() - a.second.imag()) * (a.first.real() - b.first.real());\n  int td = (a.first.real() - a.second.real()) * (b.second.imag() - a.first.imag())\n    + (a.first.imag() - a.second.imag()) * (a.first.real() - b.second.real());  \n  return tc * td < 0 && ta * tb < 0;\n}\n\n// ????????????????????????\nvector<double> dijk(int v, int s, vector<vector<double> > adjmatrix, vector<P> point, Line NGcross){\n  vector<double> result(v, INF);\n  priority_queue<pair<double, int> > wait;\n  result[s] = 0;\n  wait.push(make_pair(0, s));\n\n  while(!wait.empty()){\n    int nowpoint = wait.top().second;\n    double nowcost = -wait.top().first;\n    wait.pop();\n    if(result[nowpoint] < nowcost){ continue; }\n\n    for(int nextpoint = 0; nextpoint < v; nextpoint++){\n      double nextcost = nowcost + adjmatrix[nowpoint][nextpoint];\n      if(!judgeIentersected(NGcross, make_pair(point[nowpoint], point[nextpoint])) && result[nextpoint] > nextcost){\n        result[nextpoint] = nextcost;\n        wait.push(make_pair(-nextcost, nextpoint));\n      }\n    }\n  }\n  \n  return result;\n}\n\nint main(void){\n  int Na, Nb;\n  cin >> Na >> Nb;\n\n  // ?????\\: ?????£??????????°??????????????????§???????????????????????? ??¨???????°????????????????\n  // ??¨??????????????§?????????????°???????????????????????????????????????????????°??????????????????????\n\n  // ???????????±???????????????\n  int x, y;\n  vector<P> a;\n  for(int i = 0; i < Na; i++){\n    cin >> x >> y;\n    a.push_back(P(x, y));\n  }\n  vector<P> b;\n  for(int i = 0; i < Nb; i++){\n    cin >> x >> y;\n    b.push_back(P(x, y));\n  }\n\n  // ??£??\\???????????????\n  vector<vector<double> > adj_a(Na, vector<double>(Na, INF));\n  for(int i = 0; i < Na; i++)\n    for(int j = 0; j < Na; j++)\n      adj_a[i][j] = sqrt((a[i].real() - a[j].real()) * (a[i].real() - a[j].real())\n                         + (a[i].imag() - a[j].imag()) * (a[i].imag() - a[j].imag()));\n\n  vector<vector<double> > adj_b(Nb, vector<double>(Nb, INF));\n  for(int i = 0; i < Nb; i++)\n    for(int j = 0; j < Nb; j++)\n      adj_b[i][j] = sqrt((b[i].real() - b[j].real()) * (b[i].real() - b[j].real())\n                         + (b[i].imag() - b[j].imag()) * (b[i].imag() - b[j].imag()));\n  \n  // 2????????????????????????????????????????????????\n  double prio_a = adj_a[0][1] + dijk(Nb, 0, adj_b, b, make_pair(a[0], a[1]))[1];\n  double prio_b = adj_b[0][1] + dijk(Na, 0, adj_a, a, make_pair(b[0], b[1]))[1];\n  double res = prio_a < prio_b ? prio_a : prio_b;\n    \n  // ???????????????\n  if(res >= INF){ cout << -1 << endl; }\n  else{ printf(\"%.12f\\n\", res); }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef complex<double> C;\n\nstruct L :public vector<C>\n{\n    L(){}\n    L(const C a, const C b){\n        push_back(a);push_back(b);\n    }\n};\ndouble cross(const C a,const C b){\n    return imag(conj(a)*b);\n}\ndouble dot(const C a,const C b){\n    return real(conj(a)*b);\n}\nint ccw (C a, C b, C c){\n    b -=a; c -=a;\n    if(cross(b,c)>0 )return +1;\n    if(cross(b,c)<0) return -1;\n    if(dot(b,c) < 0) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\n\nbool intersectSS(const L& s,const L &t){\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\n\ntemplate<typename T> class Dijkstra{\n    public:\n    struct edge{\n        int to; T cost;\n    };\n    int V;\n    vector<vector<edge> > G;\n    vector<T> d;\n    using pti = pair<T,int>;\n    Dijkstra(int node_size) : V(node_size),G(V),d(V,numeric_limits<T>::max()){}\n    void add_edge(int u,int v,T cost){\n        G[u].push_back((edge){v,cost}),G[v].push_back((edge){u,cost});\n    }\n    void solve(int s){\n        priority_queue<pti,vector<pti>,greater<pti> > que;\n        d[s] = 0;\n        que.push(pti(0,s));\n        while(!que.empty()){\n            pti p = que.top();\n            que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(auto& w : G[v]){\n                if(d[w.to] > d[v]+w.cost){\n                    d[w.to] = d[v] + w.cost;\n                    que.push(pti(d[w.to],w.to));\n                }\n            }\n        }\n    }\n};\n\n\nint main(){\n    int a,b;\n    cin >> a >> b;\n    vector<complex<double> >x(a),y(b);\n    for(int i=0;i<a;i++){\n        double p,q;\n        cin >> p >> q;\n        x[i] = C(p,q);\n    }\n    for(int i=0;i<b;i++){\n        double p,q;\n        cin >> p >> q;\n        y[i] = C(p,q);\n    }\n    Dijkstra<double> gx(a),gy(b);\n    for(int i=0;i<a;i++){\n        for(int j=i+1;j<a;j++){\n            if(!intersectSS(L(y[0],y[1]),L(x[i],x[j]))){\n                gx.add_edge(i,j,sqrt(dot(x[i]-x[j],x[i]-x[j])));\n            }\n        }\n    }\n    for(int i=0;i<b;i++){\n        for(int j=i+1;j<b;j++){\n            if(!intersectSS(L(x[0],x[1]),L(y[i],y[j]))){\n                gy.add_edge(i,j,sqrt(dot(y[i]-y[j],y[i]-y[j])));\n           }\n        }\n    }\n    double ans = 0.0;\n    gx.solve(0);\n    gy.solve(0);\n    ans = sqrt(dot(x[0]-x[1],x[0]-x[1])) + gy.d[1];\n    ans = min(ans,sqrt(dot(y[0]-y[1],y[0]-y[1])) + gx.d[1]);\n    if(ans<1000000000.00)cout <<fixed << setprecision(15) << ans << endl;\n    else cout << -1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <complex>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\n#define INF 1e20\n\ntypedef complex<long long int> P;\ntypedef pair<P, P> Line;\n\n// ?????????????????????\nbool judgeIentersected(Line a, Line b){\n  long long int ta = (b.first.real() - b.second.real()) * (a.first.imag() - b.first.imag())\n    + (b.first.imag() - b.second.imag()) * (b.first.real() - a.first.real());\n  long long int tb = (b.first.real() - b.second.real()) * (a.second.imag() - b.first.imag())\n    + (b.first.imag() - b.second.imag()) * (b.first.real() - a.second.real());\n  long long int tc = (a.first.real() - a.second.real()) * (b.first.imag() - a.first.imag())\n    + (a.first.imag() - a.second.imag()) * (a.first.real() - b.first.real());\n  long long int td = (a.first.real() - a.second.real()) * (b.second.imag() - a.first.imag())\n    + (a.first.imag() - a.second.imag()) * (a.first.real() - b.second.real());  \n  return tc * td < 0 && ta * tb < 0;\n}\n\n// ????????????????????????\ndouble dijk(int v, int s, int g, vector<vector<double> > adjmatrix, vector<P> point, Line NGcross){\n  vector<double> result(v, INF);\n  priority_queue<pair<double, int> > wait;\n  result[s] = 0;\n  wait.push(make_pair(0, s));\n\n  while(!wait.empty()){\n    int nowpoint = wait.top().second;\n    double nowcost = -wait.top().first;\n    wait.pop();\n    if(result[nowpoint] < nowcost){ continue; }\n\n    for(int nextpoint = 0; nextpoint < v; nextpoint++){\n      double nextcost = nowcost + adjmatrix[nowpoint][nextpoint];\n      if(!judgeIentersected(NGcross, make_pair(point[nowpoint], point[nextpoint])) && result[nextpoint] > nextcost){\n        result[nextpoint] = nextcost;\n        wait.push(make_pair(-nextcost, nextpoint));\n      }\n    }\n  }\n  \n  return result[g];\n}\n\nint main(void){\n  int Na, Nb;\n  cin >> Na >> Nb;\n\n  // ?????\\: ?????£??????????°??????????????????§???????????????????????? ??¨???????°????????????????\n  // ??¨??????????????§?????????????°???????????????????????????????????????????????°??????????????????????\n\n  // ???????????±???????????????\n  int x, y;\n  vector<P> a;\n  for(int i = 0; i < Na; i++){\n    cin >> x >> y;\n    a.push_back(P(x, y));\n  }\n  vector<P> b;\n  for(int i = 0; i < Nb; i++){\n    cin >> x >> y;\n    b.push_back(P(x, y));\n  }\n\n  // ??£??\\???????????????\n  vector<vector<double> > adj_a(Na, vector<double>(Na, INF));\n  for(int i = 0; i < Na; i++)\n    for(int j = 0; j < Na; j++)\n      adj_a[i][j] = sqrt((a[i].real() - a[j].real()) * (a[i].real() - a[j].real())\n                         + (a[i].imag() - a[j].imag()) * (a[i].imag() - a[j].imag()));\n\n  vector<vector<double> > adj_b(Nb, vector<double>(Nb, INF));\n  for(int i = 0; i < Nb; i++)\n    for(int j = 0; j < Nb; j++)\n      adj_b[i][j] = sqrt((b[i].real() - b[j].real()) * (b[i].real() - b[j].real())\n                         + (b[i].imag() - b[j].imag()) * (b[i].imag() - b[j].imag()));\n  \n  // 2????????????????????????????????????????????????\n  double prio_a = adj_a[0][1] + dijk(Nb, 0, 1, adj_b, b, make_pair(a[0], a[1]));\n  double prio_b = adj_b[0][1] + dijk(Na, 0, 1, adj_a, a, make_pair(b[0], b[1]));\n  double res = prio_a < prio_b ? prio_a : prio_b;\n    \n  // ???????????????\n  if(res >= INF){ cout << -1 << endl; }\n  else{ printf(\"%.12f\\n\", res); }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nconst int MAX_N = 1000;\nconst int A = 0, B = 1;\nconst int INF = 0xfffffff;\nint n[2];\ndouble mat[MAX_N][MAX_N];\nvector<point> points[2];\ntypedef pair<double, int> P;\n\ndouble dijkstra(int s, int t, int num) {\n\tvector<double> dist(num, INF);\n\tdist[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0.0, s));\n\n\twhile(!que.empty()) {\n\t\tconst double d = que.top().first;\n\t\tconst int v = que.top().second;\n\t\tque.pop();\n\t\tif(d > dist[v])\n\t\t\tcontinue;\n\n\t\tif(v == t)\n\t\t\treturn d;\n\n\t\tfor(int i = 0; i < num; ++i) {\n\t\t\tconst double next_d = d + mat[v][i];\n\t\t\tif(next_d < dist[i]) {\n\t\t\t\tdist[i] = next_d;\n\t\t\t\tque.push(P(next_d, i));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INF;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n[0], &n[1]);\n\n\tfor(int l = 0; l < 2; ++l) {\n\t\tpoints[l].reserve(n[l]);\n\t\tfor(int i = 0; i < n[l]; ++i) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tpoints[l].push_back(point(x, y));\n\t\t}\n\t}\n\n\tdouble ans = INF;\n\tfor(int l = 0; l < 2; ++l) {\n\t\tfill(mat[0], mat[0] + MAX_N * n[l], INF);\n\t\tfor(int i = 0; i < n[l]; ++i)\n\t\t\tmat[i][i] = 0;\n\n\t\tconst int other = 1 - l;\n\t\tconst segment out = segment(points[other][0], points[other][1]);\n\t\tfor(int i = 0; i < n[l]; ++i) {\n\t\t\tfor(int j = i + 1; j < n[l]; ++j) {\n\t\t\t\tif(!intersect(out, segment(points[l][i], points[l][j])))\n\t\t\t\t\tmat[i][j] = mat[j][i] = abs(points[l][i] - points[l][j]);\n\t\t\t}\n\t\t}\n\n\t\tchmin(ans, abs(points[other][0] - points[other][1]) + dijkstra(0, 1, n[l]));\n\t}\n\n\tif(ans == INF)\n\t\tputs(\"-1\");\n\telse\n\t\tprintf(\"%.15lf\\n\", ans);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\nconstexpr ld INF = 1e18;\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle()\n        : p(point(0, 0)), r(0)\n    {}\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\nstd::vector<point> is_cc(circle const& c1, circle const& c2) {\n    std::vector<point> res;\n    long double d = std::abs(c1.p - c2.p);\n    long double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    long double dfr = c1.r * c1.r - rc * rc;\n    if(std::abs(dfr) < eps) {\n        dfr = 0.0;\n    } else if(dfr < 0.0) {\n        return res;\n    }\n\n    long double rs = std::sqrt(dfr);\n    point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * point(rc, rs));\n    if(dfr != 0.0) {\n        res.push_back(c1.p + diff * point(rc, -rs));\n    }\n    return res;\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    int N = poly.size();\n    ld sum = 0;\n    for(int i=0; i<N; ++i) {\n        point p1 = poly[i], p2 = poly[(i+1)%N];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return eq(sum, 0) ? 2 : 1;\n}\n\npoint reflection(line const& l, point p) {\n    auto pro = proj(l, p);\n    return p + (pro - p) + (pro - p);\n}\n\nld area(polygon const& p) {\n    const int N = p.size();\n    ld res = 0;\n    for(int i=0; i<N; ++i) {\n        res += cross(p[i], p[(i+1)%N]);\n    }\n    return res / 2;\n}\n\n// left side\npolygon convex_cut(polygon const& p, line l) {\n    const int N = p.size();\n    polygon res;\n    for(int i=0; i<N; ++i) {\n        auto a = p[i], b = p[(i+1)%N];\n        if(ccw(l.a, l.b, a) != -1) {\n            res.push_back(a);\n        }\n        if(ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) {\n            res.push_back(is_ll(line(a, b), l));\n        }\n    }\n    return res;\n}\n\npolygon convex_hull(vector<point> ps) {\n    sort(ps.begin(), ps.end(), [&](point const& p1, point const& p2) {\n        if(real(p1) == real(p2)) {\n            return imag(p1) < imag(p2);\n        }\n        return real(p1) < real(p2);\n    });\n    const int n = ps.size();\n    int k = 0;\n    polygon qs(2*n);\n    for(int i=0; i<n; ++i) {\n        while(k > 1 && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    for(int i=n-2, t = k; i>=0; --i) {\n        while(k > t && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nline separate(point const& p1, point const& p2) {\n    assert(p1 != p2);\n    auto m = (p1 + p2) * point(0.5, 0);\n    line res;\n    res.a = m + (m - p1) * point(0, 1);\n    res.b = m + (m - p1) * point(0, -1);\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\nld dijkstra(vector<point>& ps, segment seg) {\n    const int n = ps.size();\n    vector<ld> d(n, INF);\n    d[0] = 0;\n    using state = pair<ld, int>;\n    priority_queue<state, vector<state>, greater<state>> que;\n    que.push(make_pair(0, 0));\n    while(!que.empty()) {\n        auto p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] + eps < p.first) {\n            continue;\n        }\n        for(int i=0; i<n; ++i) {\n            if(!isis_ss(seg, segment(ps[p.second], ps[i]))) {\n                ld dist = abs(ps[p.second] - ps[i]);\n                if(d[i] > d[v] + dist) {\n                    d[i] = d[v] + dist;\n                    que.push(make_pair(d[i], i));\n                }\n            }\n        }\n    }\n    return d[1] + abs(seg.a - seg.b);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<point> A(n), B(m);\n    for(int i=0; i<n; ++i) {\n        ld x, y;\n        cin >> x >> y;\n        A[i] = point(x, y);\n    }\n    for(int i=0; i<m; ++i) {\n        ld x, y;\n        cin >> x >> y;\n        B[i] = point(x, y);\n    }\n    ld res = INF;\n    segment seg(A[0], A[1]);\n    res = min(res, dijkstra(B, seg));\n    seg = segment(B[0], B[1]);\n    res = min(res, dijkstra(A, seg));\n    if(res == INF) {\n        cout << -1 << endl;\n    } else {\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <queue>\nusing namespace std;\nusing F = double;\nusing P = complex<F>;\nusing L = pair<P,P>;\n#define X real()\n#define Y imag()\nconst F EPS = 1e-8, INF = 1e10;\n\nF dot(const P &A, const P &B){ return A.X*B.X+A.Y*B.Y; }\nF cross(const P &A, const P &B){ return A.X*B.Y-A.Y*B.X; }\n\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b,c) > EPS) return +1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return +2;\n  if(norm(b) < norm(c)-EPS) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  P af = a.first, as = a.second, bf = b.first, bs = b.second;\n  return (ccw(af,as,bf)*ccw(af,as,bs) <= 0) and (ccw(bf,bs,af)*ccw(bf,bs,as) <= 0);\n}\n\nF solve(const vector<P> &Ps, L l, int s, int t){\n  int n = Ps.size();\n  vector<F> D(n,INF);\n  priority_queue<pair<F,int>> q;\n  q.emplace(0,s);\n  while(not q.empty()){\n    int v = q.top().second;\n    F c = -q.top().first;\n    q.pop();\n    if(D[v] < c-EPS) continue;\n    D[v] = c;\n    for(int i = 0; i < n; ++i){\n      if(i == v) continue;\n      if(is_cross(l,L(Ps[i],Ps[v]))){\n        continue;\n      }\n      F c_ = c + abs(Ps[i]-Ps[v]);\n      if(D[i] < c_ - EPS) continue;\n      D[i] = c_;\n      q.emplace(-c_,i);\n    }\n  }\n  return D[t];\n}\n\nint main(){\n  int A, B;\n  cin >> A >> B;\n  vector<P> PA, PB;\n  for(int i = 0; i < A; ++i){\n    F x, y;\n    cin >> x >> y;\n    PA.emplace_back(x,y);\n  }\n  for(int i = 0; i < B; ++i){\n    F x, y;\n    cin >> x >> y;\n    PB.emplace_back(x,y);\n  }\n  F ans = solve(PA,L(PB[0],PB[1]),0,1) + abs(PB[0]-PB[1]);\n  //fprintf(stderr,\"%.12f\\n\",ans);\n  ans = min(ans,solve(PB,L(PA[0],PA[1]),0,1)+abs(PA[0]-PA[1]));\n  if(ans > INF-EPS){\n    cout << -1 << endl;\n    return 0;\n  }\n  printf(\"%.12f\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define N 1001\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\nvector<P> A,B; \n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersect(L s1, L s2){\n  return ( ccw(s1.f,s1.s,s2.f) * ccw(s1.f,s1.s,s2.s) <= 0 &&\n           ccw(s2.f,s2.s,s1.f) * ccw(s2.f,s2.s,s1.s) <= 0 );\n}\n\ntypedef pair<double,int> Pi;\ndouble dijkstra(){\n  vector<double>D(N,INF);\n  priority_queue<Pi,vector<Pi>,greater<Pi> >Q;\n  Q.push(Pi(0,0));\n  D[0]=0;\n  while(!Q.empty()){\n    Pi t=Q.top();Q.pop();\n    int pos=t.s;\n    double cost=t.f;\n    if(D[pos]<cost)continue;\n    if(pos==1)return cost;    \n    for(int i=0;i<B.size();i++){\n      double ncost=cost+abs(B[pos]-B[i]);\n      if(isIntersect(L(A[0],A[1]),L(B[pos],B[i]))||D[i]<=ncost)continue;\n      D[i]=ncost;\n      Q.push(Pi(ncost,i));\n    }\n  }\n  return INF;\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  A.resize(n),B.resize(m);\n  for(int i=0,x,y;i<n;i++)cin>>x>>y,A[i]=P(x,y);\n  for(int i=0,x,y;i<m;i++)cin>>x>>y,B[i]=P(x,y);\n  double ans=abs(A[0]-A[1])+dijkstra();\n  swap(A,B);\n  ans=min(ans,abs(A[0]-A[1])+dijkstra());\n  if(ans>=INF) ans=-1;\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\ndouble x[2][1001], y[2][1001];\ndouble dist[1001];\nint seen[1001];\n\ndouble d(int idx, int s, int t) {\n  return sqrt((x[idx][s] - x[idx][t])*(x[idx][s] - x[idx][t])\n              + (y[idx][s] - y[idx][t])*(y[idx][s] - y[idx][t]));\n}\n\ntypedef complex<double> P; // point\nstruct L : public vector<P> { // line\n    L (P a, P b) {\n        push_back(a);\n        push_back(b);\n    }\n};\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n      ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool ok(int idx, int p, int q) {\n  L l1 = L(P(x[idx][p], y[idx][p]), P(x[idx][q], y[idx][q]));\n  L l2 = L(P(x[idx^1][0], y[idx^1][0]), P(x[idx^1][1], y[idx^1][1]));\n  return !intersectSS(l1, l2);\n}\n\nint n[2];\n\ndouble shortest_path(int idx, int s, int t) {\n  memset(seen, 0, sizeof(seen));\n  for (int i = 0; i < 1001; ++i) dist[i] = -1;\n  dist[s] = 0;\n\n  while(true) {\n    int p = -1;\n    double td = 1e13;\n    for (int i = 0; i < n[idx]; ++i) {\n      if (dist[i] != -1 && seen[i] == 0 && dist[i] < td) {\n        p = i;\n        td = dist[i];\n      }\n    }\n    if (p == -1) break;\n    if (p == t) return dist[t];\n    seen[p] = 1;\n    for (int next = 0; next < n[idx]; ++next) {\n      if (seen[next] != 0) continue;\n      if (!ok(idx, p, next)) continue;\n      if (dist[next] == -1 || dist[p] + d(idx, p, next) < dist[next]) {\n        dist[next] = dist[p] + d(idx, p, next);\n      }\n    }\n  }\n\n  return dist[t];\n}\n\nint main() {\n  for (int i = 0; i < 1001; ++i) {\n    x[0][i] = x[1][i] = y[0][i] = y[1][i] = -1;\n  }\n  cin>>n[0]>>n[1];\n  for (int k = 0; k < 2; ++k)\n    for (int i = 0; i < n[k]; ++i)\n      cin>>x[k][i]>>y[k][i];\n\n  // A\n  double ans = d(0, 0, 1);\n  double d1 = shortest_path(1, 0, 1);\n\n  // B\n  double ans2 = d(1, 0, 1);\n  double d2 = shortest_path(0, 0, 1);\n\n  cout << setprecision(15);\n  if (d1 == -1 && d2 == -1) cout << -1 << endl;\n  else if (d1 == -1) cout << ans2 + d2 << endl;\n  else if (d2 == -1) cout << ans + d1 << endl;\n  else cout << min(ans2 + d2, ans + d1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <utility>\n#include <queue>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n#define X real()\n#define Y imag()\n\nusing P = complex<double>;\nusing L = pair<P, P>;\n\nconst double EPS = 1e-10;\nconst double INF = 1e15;\n\ndouble dot(P a, P b){ return a.X*b.X + a.Y*b.Y;}\ndouble cross(P a, P b){ return a.X*b.Y - a.Y*b.X;}\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b, c) > EPS) return 1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < -EPS) return -2;\n  if(norm(c) - norm(b) > EPS) return 2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  return (ccw(a.first, a.second, b.first)*ccw(a.first, a.second, b.second) <= 0) &&\n    (ccw(b.first, b.second, a.first)*ccw(b.first, b.second, a.second) <= 0);\n}\n\ndouble dijkstra(vector< vector< pair<int, double> > > &G){\n  int Nb = G.size();\n  vector<double> D(Nb, INF);\n  priority_queue< pair<double, int> > wait;\n  wait.emplace(0,0);\n  while(!wait.empty()){\n    int v = wait.top().second;\n    double d = -wait.top().first;\n    wait.pop();\n    if(d > D[v]) continue;\n    D[v] = d;\n    for(int i = 0; i < G[v].size(); ++i){\n      int v_ = G[v][i].first;\n      double d_ = d + G[v][i].second;\n      if(D[v_] > d_){\n        D[v_] = d_;\n        wait.emplace(-d_, v_);\n      }\n    }\n  }\n  return D[1];\n}\n\ndouble solve(vector<P> &A, vector<P> &B){\n  int Nb = B.size();\n  L l = L(A[0], A[1]);\n  vector< vector< pair<int, double> > > G(Nb);\n  for(int i = 0; i < Nb; ++i){\n    for(int j = 0; j < Nb; ++j){\n      if(i == j) continue;\n      if(!is_cross(l, L(B[i],B[j]))) G[i].emplace_back(j, abs(B[i]-B[j])); \n    }\n  }\n  return dijkstra(G) + abs(A[0] - A[1]);\n}\n\nint main() {\n  int Na, Nb;\n  cin >> Na >> Nb;\n  vector<P> A(Na), B(Nb);\n  for(int i = 0; i < Na; ++i){\n    double x, y;\n    cin >> x >> y;\n    A[i] = P(x, y);\n  }\n  for(int i = 0; i < Nb; ++i){\n    double x, y;\n    cin >> x >> y;\n    B[i] = P(x, y);\n  }\n  double ans = min(solve(A, B), solve(B, A));\n  if(ans >= INF - EPS) cout << -1 << endl;\n  else printf(\"%.12f\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tld ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph ga(pa.size()), gb(pb.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tld d = abs(pa[i] - pa[j]);\n\t\tadd_edge(ga, i, j, d);\n\t\tadd_edge(ga, j, i, d);\n\t}\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tld d = abs(pb[i] - pb[j]);\n\t\tadd_edge(gb, i, j, d);\n\t\tadd_edge(gb, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(ga, da, 0);\n\tdijkstra(gb, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nusing Real = double;\nconst Real EPS = 1e-8, PI = acos(-1);\n\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        if (a.real() == b.real()) return a.imag() < b.imag();\n        return a.real() < b.real();\n    }\n}\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\nReal radian_to_degree(Real r) {\n    return r * 180.0 / PI;\n}\n\nReal degree_to_radian(Real d) {\n    return d * PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar((Real)1.0, theta);\n}\n\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n         B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nconst int COUNTER_CLOCKWISE = 1,\n      CLOCKWISE = -1,\n      ONLINE_BACK = 2,\n      ONLINE_FRONT = -2,\n      ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n        ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\n\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n            distance(s2, s1.a), distance(s2, s1.b) });\n}\n\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n         B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\n\n\n\ntemplate<typename T>\nvector<T> dijkstra(const vector<vector<edge<T>>> &g, int s) {\n    const T INF = numeric_limits<T>::max();\n    vector<T> d(g.size(), INF);\n\n    using Pi = pair<T, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    d[s] = 0;\n    que.emplace(d[s], s);\n    while (!que.empty()) {\n        T cost;\n        int v;\n        tie(cost, v) = que.top();\n        que.pop();\n        if (d[v] < cost) continue;\n        for (auto &e : g[v]) {\n            T nxt = cost + e.cost;\n            if (d[e.to] > nxt) {\n                d[e.to] = nxt;\n                que.emplace(nxt, e.to);\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int na, nb; cin >> na >> nb;\n    vector<Point> A(na), B(nb);\n    for (int i = 0; i < na; ++i) {\n        double x, y; cin >> x >> y;\n        A[i] = { x, y };\n    }\n    for (int i = 0; i < nb; ++i) {\n        double x, y; cin >> x >> y;\n        B[i] = { x, y };\n    }\n\n    Segment sa = { A[0], A[1] },\n            sb = { B[0], B[1] };\n\n    vector<vector<edge<double>>> Ga(na), Gb(nb);\n    for (int i = 0; i < na; ++i) {\n        for (int j = i+1; j < na; ++j) {\n            if (intersected(sb, Segment{ A[i], A[j] })) {\n                continue;\n            }\n            Ga[i].emplace_back(j, abs(A[i] - A[j]));\n            Ga[j].emplace_back(i, abs(A[i] - A[j]));\n        }\n    }\n    for (int i = 0; i < nb; ++i) {\n        for (int j = i+1; j < nb; ++j) {\n            if (intersected(sa, Segment{ B[i], B[j] })) {\n                continue;\n            }\n            Gb[i].emplace_back(j, abs(B[i] - B[j]));\n            Gb[j].emplace_back(i, abs(B[i] - B[j]));\n        }\n    }\n\n    auto dista = dijkstra(Ga, 0),\n         distb = dijkstra(Gb, 0);\n\n    double ans = min(\n        abs(A[0] - A[1]) + distb[1],\n        abs(B[0] - B[1]) + dista[1]);\n\n    if (ans == numeric_limits<double>::max()) {\n        cout << -1 << endl;\n    } else {\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n/*                         */\n/*                         */\n/* @@ Geometory Library @@ */\n/*               by ei1333 */\n/*                         */\nconst double EPS = 1e-8, PI = acos(-1);\n \ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n    \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n    double abs(){ return (a - b).abs(); }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n    \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n    \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n    \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n    \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n  double Convex_Diameter(Polygon& p){\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = ( p[is] - p[js]).norm();\n  \n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross( next( p, i) - curr( p, i), next( p, j) - curr( p, j)) >= 0){\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if(( p[i] - p[j]).norm() > maxdis){\n        maxdis = ( p[i] - p[j]).norm();\n        maxi = i; maxj = j;\n      }\n    }  while (i != is || j != js);\n    return maxdis;\n  }\n};\n  \nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\n\ndouble Dijkstra(const P *pts, const int& size, S line){\n  typedef pair< double, int > Pi;\n  double min_cost[1000];\n  fill_n( min_cost, size, 1e9);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n\n  que.push( Pi( 0.0, 0));\n  min_cost[0] = 0.0;\n\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == 1) return p.first + line.abs();\n    if(min_cost[p.second] < p.first) continue;\n    for(int i = 0; i < size; i++){\n      S l = S( pts[p.second], pts[i]);\n      if(geo.Intersect(l,line) || p.first + l.abs() >= min_cost[i]) continue;\n      que.push( Pi( p.first + l.abs(), i));\n      min_cost[i] = p.first + l.abs();\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int Na, Nb;\n  P pa[1000], pb[1000];\n\n  cin >> Na >> Nb;\n  for(int i = 0; i < Na; i++){\n    cin >> pa[i];\n  }\n  for(int i = 0; i < Nb; i++){\n    cin >> pb[i];\n  }\n  double a = Dijkstra( pa, Na, S( pb[0], pb[1]));\n  double b = Dijkstra( pb, Nb, S( pa[0], pa[1]));\n  cout << fixed << setprecision(10);\n  if(a == -1 && b == -1) cout << \"-1\" << endl;\n  else if(a == -1 || b == -1) cout << max( a, b) << endl;\n  else cout << min(a,b) << endl;\n               \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n// geometry library from hos\n\nconst double PI = acos(-1);\n\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\nstruct Pt{\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\n\nostream &operator<<(ostream &os, const Pt &a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\n\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\n\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s; // +1 or -1\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nbool iLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) <= 0);\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nbool iSSstrict(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) < 0 && sig(tri(c, d, a)) * sig(tri(c, d, b)) < 0);\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) { // intersection\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\ndouble dSP(Pt a, Pt b, Pt c) {\n\tif (sig((b - a).dot(c - a)) <= 0) return (c - a).abs();\n\tif (sig((a - b).dot(c - b)) <= 0) return (c - b).abs();\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\ndouble dLL(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLL(a, b, c, d) ? 0 : dLP(a, b, c);\n}\ndouble dLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLS(a, b, c, d) ? 0 : min(dLP(a, b, c), dLP(a, b, d));\n}\ndouble dSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iSS(a, b, c, d) ? 0 : min(min(dSP(a, b, c), dSP(a, b, d)), min(dSP(c, d, a), dSP(c, d, b)));\n}\n\nint iCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tif (sig(d) == 0 && sig(r - s) == 0) return -1; // correspond\n\tif (sig(r - s - d) > 0) return +2; // r > s\n\tif (sig(s - r - d) > 0) return -2; // s > r\n\treturn (sig(r + s - d) >= 0) ? 1 : 0;\n}\nbool iCS(Pt a, double r, Pt b, Pt c) {\n\treturn (sig(r - dSP(b, c, a)) >= 0 && sig(r - max((b - a).abs(), (c - a).abs())) <= 0);\n}\npair<Pt,Pt> pCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tPt e = (b - a) / d, w = e * Pt(0, 1) * sqrt(max(r * r - x * x, 0.0));\n\treturn mp(a + e * x - w, a + e * x + w);\n}\npair<Pt,Pt> pCL(Pt a, double r, Pt b, Pt c) {\n\tPt h = b + (c - b) * (c - b).dot(a - b) / (c - b).abs2();\n\t// perp(b, c, a)\n\tdouble d = (h - a).abs();\n\tdouble y = sqrt(max(r * r - d * d, 0.0));\n\tPt e = (c - b) / (c - b).abs();\n\treturn mp(h - e * y, h + e * y);\n}\npair<Pt,Pt> tCP(Pt a, double r, Pt b) {\n\tdouble d2 = (b - a).abs2();\n\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\tPt h = a + (b - a) * (r * r / d2);\n\tPt w = (b - a) * Pt(0, 1) * (x * r / d2);\n\treturn mp(h - w, h + w);\n}\ndouble aCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (a - b).abs();\n\tif (sig(r - s - d) >= 0) return s * s * PI;\n\tif (sig(s - r - d) >= 0) return r * r * PI;\n\tif (sig(r + s - d) <= 0) return 0;\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tdouble h = sqrt(r * r - x * x);\n\treturn r * r * atan2(h, x) + s * s * atan2(h, d - x) - d * h;\n}\n\n// end of library\n\nint NA,NB;\nPt PA[1010],PB[1010];\n\ntypedef pair<double,int> pdi;\n\ndouble solve(int N,Pt* P,Pt C,Pt D){\n\tpriority_queue<pdi> Q;\n\tQ.push(mp(0,0));\n\tdouble d[1010];\n\trep(i,N)d[i]=i==0?0:INF;\n\twhile(sz(Q)){\n\t\tpdi p=Q.top();Q.pop();\n\t\tdouble dist=p.fir;\n\t\tint cur=p.sec;\n\t\tif(dist>d[cur])continue;\n\t\tif(cur==1)return d[1]+(D-C).abs();\n\t\trep(i,N){\n\t\t\tif(!iSS(P[cur],P[i],C,D)){\n\t\t\t\tdouble ndist=dist+(P[i]-P[cur]).abs();\n\t\t\t\tif(ndist<d[i]){\n\t\t\t\t\td[i]=ndist;\n\t\t\t\t\tQ.push(mp(ndist,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>NA>>NB;\n\trep(i,NA)cin>>PA[i].x>>PA[i].y;\n\trep(i,NB)cin>>PB[i].x>>PB[i].y;\n\tdouble ans=min(solve(NA,PA,PB[0],PB[1]),solve(NB,PB,PA[0],PA[1]));\n\tcout<<setprecision(16)<<(ans==INF?-1:ans)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\n\nlong double sub(int na,int nb,vector<long double> &xa,vector<long double> &ya,vector<long double> &xb,vector<long double> &yb){\n    vector<long double> dist(nb,inf);\n    vector<bool> done(nb);\n    dist[0]=0;\n    for(;;){\n        int u=-1;\n        rep(v,0,nb){\n            if(!done[v] and (u==-1 or dist[u]>dist[v])) u=v;\n        }\n        if(u==-1) break;\n        done[u]=true;\n        rep(v,0,nb){\n            if(intersectSS(line(point(xa[0],ya[0]),point(xa[1],ya[1])),line(point(xb[u],yb[u]),point(xb[v],yb[v])))) continue;\n            long double d=dist[u]+abs(point(xb[u]-xb[v],yb[u]-yb[v]));\n            if(d<dist[v]) dist[v]=d;\n        }\n    }\n    return abs(point(xa[0]-xa[1],ya[0]-ya[1]))+dist[1];\n}\n\nvoid solve(){\n    int na,nb;\n    cin >> na >> nb;\n    vector<long double> xa(na),ya(na),xb(nb),yb(nb);\n    rep(i,0,na) cin >> xa[i] >> ya[i];\n    rep(i,0,nb) cin >> xb[i] >> yb[i];\n    long double ans=min(sub(na,nb,xa,ya,xb,yb),sub(nb,na,xb,yb,xa,ya));\n    if(ans<inf) cout << ans << endl;\n    else cout << -1 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,double>P;\ntypedef complex<double> C;\n\nnamespace std {\n    bool operator < (const C& a, const C& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct edge{\n    int to;\n    double cost;\n};\n\nconst int MAX_N = 1002;\n\nint na,nb;\ndouble d[MAX_N];\nint X1[MAX_N],Y1[MAX_N],X2[MAX_N],Y2[MAX_N];\nvector<edge> G[MAX_N];\n\ndouble cross(const C& a, const C& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const C& a, const C& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<C> {\n  L(const C &a, const C &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(C a, C b, C c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const C &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nvoid dijkstra(int s)\n{\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\td[s] = 0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\trep(i,G[v].size()){\n\t\t\tif(d[G[v][i].to] > d[v] + G[v][i].cost){\n\t\t\t\td[G[v][i].to] = d[v] + G[v][i].cost;\n\t\t\t\tque.push(P(d[G[v][i].to],G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&na,&nb);\n\trep(i,na){\n\t\tscanf(\"%d%d\",&X1[i],&Y1[i]);\n\t}\n    rep(i,nb){\n        scanf(\"%d%d\",&X2[i],&Y2[i]);\n    }\n    rep(i,nb){\n        d[i] = INF;\n    }\n    L l(C(X1[0],Y1[0]),C(X1[1],Y1[1]));\n    rep(i,nb){\n        for(int j=i+1;j<nb;j++){\n            L l1(C(X2[i],Y2[i]),C(X2[j],Y2[j]));\n            if(!intersectSS(l,l1)){\n                G[i].push_back((edge){j,abs(l1[1]-l1[0])});\n                G[j].push_back((edge){i,abs(l1[1]-l1[0])});\n            }\n        }\n    }\n    dijkstra(0);\n    double cand1 = d[1] + abs(l[1]-l[0]);\n    rep(i,na){\n        G[i].clear();\n        d[i] = INF;\n    }\n    L l2(C(X2[0],Y2[0]),C(X2[1],Y2[1]));\n    rep(i,na){\n        for(int j=i+1;j<na;j++){\n            L l1(C(X1[i],Y1[i]),C(X1[j],Y1[j]));\n            if(!intersectSS(l2,l1)){\n                G[i].push_back((edge){j,abs(l1[1]-l1[0])});\n                G[j].push_back((edge){i,abs(l1[1]-l1[0])});\n            }\n        }\n    }\n    dijkstra(0);\n    double cand2 = d[1] + abs(l2[1]-l2[0]);\n    if(min(cand1,cand2) >= INF){\n        printf(\"-1\\n\");\n    }else{\n        printf(\"%.12f\\n\",min(cand1,cand2));\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* ?????¬????´? */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-9; // ?¨±?????????^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// ?????????dot(a,b) = |a||b|cos??\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// ?????????cross(a,b) = |a||b|sin??\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// ??????????????????\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// ????????¨??????\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nusing pd = pair<double,int>;\nconst int N = 1000;\nstruct edge{int to; double cost;};\nvector<edge> G[N];\n\ndouble dijkstra()\n{\n    vector<double> dist(N,INF);\n    dist[0] = 0;\n    priority_queue<pd,vector<pd>,greater<pd>> pq;\n    pq.push({0,0});\n    while(!pq.empty())\n    {\n        pd now = pq.top();\n        pq.pop();\n        int v = now.se;\n        if(now.fi>dist[v]) continue;\n        for(const auto &e:G[v])\n        {\n            if(dist[e.to] > dist[v]+e.cost)\n            {\n                dist[e.to] = dist[v]+e.cost;\n                pq.push({dist[e.to],e.to});\n            }\n        }\n    }\n\n    return dist[1];\n}\n\nint main()\n{\n    int na,nb;\n    cin >>na >>nb;\n\n    vector<Point> a(na),b(nb);\n    rep(i,na)\n    {\n        int x,y;\n        cin >>x >>y;\n        a[i] = Point(x,y);\n    }\n    rep(i,nb)\n    {\n        int x,y;\n        cin >>x >>y;\n        b[i] = Point(x,y);\n    }\n\n    double ans = INF;\n\n    // a[0]??¨a[1]?????´??\\?????????\n    rep(i,nb)rep(j,i)\n    {\n        if(!isecSS(a[0],a[1],b[i],b[j]))\n        {\n            G[i].pb({j,abs(b[i]-b[j])});\n            G[j].pb({i,abs(b[i]-b[j])});\n        }\n    }\n    double d = dijkstra();\n    if(d<INF) ans = min(ans, d+abs(a[0]-a[1]));\n\n    // b[0]??¨b[1]?????´??\\?????????\n    rep(i,N) G[i].clear();\n    rep(i,na)rep(j,i)\n    {\n        if(!isecSS(b[0],b[1],a[i],a[j]))\n        {\n            G[i].pb({j,abs(a[i]-a[j])});\n            G[j].pb({i,abs(a[i]-a[j])});\n        }\n    }\n    d = dijkstra();\n    if(d<INF) ans = min(ans, d+abs(b[0]-b[1]));\n\n    if(ans>1e8) printf(\"-1\\n\");\n    else printf(\"%.15f\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass Vector2 {\npublic:\n  double x, y;\n\n  Vector2(): x(0), y(0) {}\n  Vector2(double x, double y): x(x), y(y) {}\n\n  Vector2 operator+(Vector2 p) { return Vector2(x + p.x, y + p.y); }\n  Vector2 operator-(Vector2 p) { return Vector2(x - p.x, y - p.y); }\n\n  Vector2 operator*(double t) { return Vector2(x * t, y * t); }\n  Vector2 operator/(double t) { return Vector2(x / t, y / t); }\n\n  double dot(Vector2 p) { return x * p.x + y * p.y; }\n  double det(Vector2 p) { return x * p.y - y * p.x; }\n\n  double norm2() { return x * x + y * y; }\n  double norm() { return sqrt(norm2()); }\n\n  Vector2 normalize() { return Vector2(x / norm(), y / norm()); }\n\n  friend ostream& operator<<(ostream &out, const Vector2 &v) {\n    out << \"(\" << v.x << \", \" << v.y << \")\";\n  }\n};\nusing Point2 = Vector2;\n\nbool line_segments_intersect(Point2 a, Point2 b, Point2 c, Point2 d) {\n  double ta = (a - c).det(d - c);\n  double tb = (b - c).det(d - c);\n  double tc = (c - a).det(b - a);\n  double td = (d - a).det(b - a);\n  return ta * tb < 0 && tc * td < 0;\n}\n\nclass Dijkstra {\npublic:\n  struct edge {\n    ll v;\n    double dist;\n  };\n\n  struct state {\n    ll v;\n    double cost;\n    bool operator>(const state s) const { return cost > s.cost; }\n  };\n\n  const double INF = 1e20;\n  ll N;\n  vector< vector<edge> > E;\n\n  Dijkstra(ll n): N(n), E(n) {}\n\n  void add_undirected_edge(ll u, ll v, double d) {\n    E[u].push_back((edge) { v, d });\n    E[v].push_back((edge) { u, d });\n  }\n\n  vector<double> shortest_path(ll S) {\n    vector<double> dp(E.size(), INF);\n    priority_queue<state, vector<state>, greater<state> > q;\n    q.push((state) { S, 0 });\n    while(!q.empty()) {\n      ll v = q.top().v;\n      double cost = q.top().cost;\n      q.pop();\n      if(dp[v] <= cost) continue;\n      dp[v] = cost;\n      REP(i, 0, E[v].size()) {\n        ll nv = E[v][i].v;\n        double ncost = cost + E[v][i].dist;\n        if(dp[nv] > ncost) q.push((state) { nv, ncost });\n      }\n    }\n    return dp;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<Point2> A(N), B(M);\n  REP(i, 0, N) cin >> A[i].x >> A[i].y;\n  REP(i, 0, M) cin >> B[i].x >> B[i].y;\n\n  if(!line_segments_intersect(A[0], A[1], B[0], B[1])) {\n    printf(\"%.15lf\\n\", (A[1] - A[0]).norm() + (B[1] - B[0]).norm());\n    return 0;\n  }\n\n  Dijkstra dijkA(N);\n  REP(i, 0, N) REP(j, i + 1, N) {\n    if(!line_segments_intersect(A[i], A[j], B[0], B[1])) {\n      dijkA.add_undirected_edge(i, j, (A[j] - A[i]).norm());\n    }\n  }\n  double ansA = dijkA.shortest_path(0)[1] + (B[1] - B[0]).norm();\n\n  Dijkstra dijkB(M);\n  REP(i, 0, M) REP(j, i + 1, M) {\n    if(!line_segments_intersect(B[i], B[j], A[0], A[1])) {\n      dijkB.add_undirected_edge(i, j, (B[j] - B[i]).norm());\n    }\n  }\n  double ansB = dijkB.shortest_path(0)[1] + (A[1] - A[0]).norm();\n\n  const double EPS = 1e-10;\n  if(ansA >= 1e20 - EPS && ansB >= 1e20 - EPS) {\n    cout << -1 << endl;\n  } else {\n    printf(\"%.15lf\\n\", min(ansA, ansB));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nbool linecross(LDP p1, LDP p2, LDP p3, LDP p4) {\n\tld t1 = (p1.first - p2.first)*(p3.second - p1.second) + (p1.second - p2.second)*(p1.first - p3.first);\n\tld t2 = (p1.first - p2.first)*(p4.second - p1.second) + (p1.second -p2.second)*(p1.first - p4.first);\n\tld t3 = (p3.first - p4.first)*(p1.second - p3.second) + (p3.second - p4.second)*(p3.first - p1.first);\n\tld t4 = (p3.first - p4.first)*(p2.second - p3.second) + (p3.second - p4.second)*(p3.first - p2.first);\n\treturn t1 * t2 < 0 && t3*t4 < 0;\n}\n\nld dist(LDP a, LDP b) {\n\tld dx = b.first - a.first, dy = b.second - a.second;\n\tld ret = dx * dx + dy * dy;\n\treturn sqrt(ret);\n}\n\nint n[2];\nvector<LDP> v[2];\n\nstruct edge {\n\tint to; ld cost;\n};\nvoid solve() {\n\tcout << fixed << setprecision(10);\n\tcin >> n[0] >> n[1];\n\trep(i, 2) {\n\t\tv[i].resize(n[i]);\n\t\trep(j, n[i]) {\n\t\t\tcin >> v[i][j].first >> v[i][j].second;\n\t\t}\n\t}\n\tld ans = INF;\n\trep(id, 2) {\n\t\tLDP s0 = v[id][0], s1 = v[id][1];\n\t\tld dr = dist(s0, s1);\n\t\tvector<vector<edge>> G(n[id^1]);\n\t\trep(i, n[id^1]) {\n\t\t\tRep(j, i + 1, n[id^1]) {\n\t\t\t\tif (linecross(s0, s1, v[id^1][i], v[id^1][j]))continue;\n\t\t\t\tld r = dist(v[id^1][i], v[id^1][j]);\n\t\t\t\tG[i].push_back({ j,r });\n\t\t\t\tG[j].push_back({ i,r });\n\t\t\t}\n\t\t}\n\t\tvector<ld> d(n[id ^ 1],INF);\n\t\td[0] = 0;\n\t\tpriority_queue<LDP, vector<LDP>, greater<LDP>> q;\n\t\tq.push({ d[0],0 });\n\t\twhile (!q.empty()) {\n\t\t\tLDP p = q.top(); q.pop();\n\t\t\tint r = p.second;\n\t\t\trep(j, G[r].size()) {\n\t\t\t\tint to = G[r][j].to;\n\t\t\t\tld nd = G[r][j].cost + p.first;\n\t\t\t\tif (nd < d[to]) {\n\t\t\t\t\td[to] = nd;\n\t\t\t\t\tq.push({ d[to],to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = min(ans, dr + d[1]);\n\t}\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld inf = 1e20;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nstruct MyEdge {\n\tint to;\n\tld dist;\n};\nbool operator >(const MyEdge& e1, const MyEdge& e2) {\n\treturn e1.dist > e2.dist;\n}\n\nld solve(vector<Point> a, vector<Point> b) {\n\tLine bl(b[0], b[1]);\n\tint N = a.size();\n/*\n\tvector< vector<MyEdge> > G(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (i != j && !isis_ss(bl, Line(a[i], a[j]))) {\n\t\t\t\tld d = abs(a[i]-a[j]);\n\t\t\t\tG[i].push_back( (MyEdge){j, d} );\n\t\t\t\tG[j].push_back( (MyEdge){i, d} );\n\t\t\t}\n\t\t}\n\t}\n*/\n\tvector<ld> dist(N, inf);\n\tpriority_queue<MyEdge, vector<MyEdge>, greater<MyEdge> > Q; Q.push({0, 0});\n\twhile ( !Q.empty() ) {\n\t\tMyEdge q = Q.top(); Q.pop();\n\t\tint v = q.to;\n\t\tif (q.dist > dist[v] || eq(q.dist, dist[v])) {\n\t\t\tcontinue;\n\t\t}\n\t\tdist[v] = q.dist;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (i != v && !isis_ss(bl, Line(a[i], a[v]))) {\n\t\t\t\tQ.push( (MyEdge){i, dist[v]+abs(a[i]-a[v])} );\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[1]+abs(b[0]-b[1]);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<Point> a, b;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\ta.push_back( Point(x, y) );\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tb.push_back( Point(x, y) );\n\t}\n\tld ans = min( solve(a, b), solve(b, a) );\n\tif ( eq(ans, inf) ) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << fixed << setprecision(12) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double, int> P;\ntypedef pair<int, int> Point;\ntypedef pair<Point, Point> Segment; // (frm, to)\nconst double eps = 1e-9;\n \ndouble norm(Point a) {\n    return sqrt(a.first * a.first + a.second * a.second);\n}\nPoint getv(Point frm, Point to) {\n    return Point(to.first - frm.first, to.second - frm.second);\n}\nPoint getv(Segment a) {\n    return getv(a.first, a.second);\n}\ndouble dist(Point a, Point b) {\n    return norm(getv(a, b));\n}\ndouble getlen(Segment a) {\n    return dist(a.first, a.second);\n}\n \nint cross(Point v, Point w) {\n    return v.first * w.second - v.second * w.first;\n}\nbool iscross(Segment a, Segment b) {\n    return (cross(getv(a), getv(a.first, b.first)) > 0) != (cross(getv(a), getv(a.first, b.second)) > 0) && (cross(getv(b), getv(b.first, a.first)) > 0) != (cross(getv(b), getv(b.first, a.second)) > 0);\n}\n \n \n \nvector<double> dijkstra(int s, vector<vector<P>> edge) {\n    int n = edge.size();\n    vector<double> dist(n, 1e16);\n    priority_queue<P, vector<P>, greater<P>> q;\n    dist[s] = 0;\n    q.push(P(0, s));\n    while (!q.empty()) {\n        P p = q.top();\n        q.pop();\n        for (auto& e : edge[p.second]) {\n            if (dist[e.second] > p.first + e.first) {\n                dist[e.second] = p.first + e.first;\n                q.push(P(p.first + e.first, e.second));\n            }\n        }\n    }\n    return dist;\n}\n \n \n \nint main() {\n    int na, nb;\n    cin >> na >> nb;\n    vector<P> a(na);\n    vector<P> b(nb);\n    for (int i = 0; i < na; ++i)\n        cin >> a[i].first >> a[i].second;\n    for (int i = 0; i < nb; ++i)\n        cin >> b[i].first >> b[i].second;\n \n    Segment sa = Segment(a[0], a[1]);\n    Segment sb = Segment(b[0], b[1]);\n    vector<vector<P>> eda(na);\n    vector<vector<P>> edb(nb);\n    for (int i = 0; i < na; ++i) {\n        for (int j = i + 1; j < na; ++j) {\n            if (!iscross(Segment(a[i], a[j]), sb)) {\n                eda[i].push_back(P(dist(a[i], a[j]), j));\n                eda[j].push_back(P(dist(a[i], a[j]), i));\n            }\n        }\n    }\n    for (int i = 0; i < nb; ++i) {\n        for (int j = i + 1; j < nb; ++j) {\n            if (!iscross(Segment(b[i], b[j]), sa)) {\n                edb[i].push_back(P(dist(b[i], b[j]), j));\n                edb[j].push_back(P(dist(b[i], b[j]), i));\n            }\n        }\n    }\n    double ans = min(getlen(sa) + dijkstra(0, edb)[1], getlen(sb) + dijkstra(0, eda)[1]);\n    if (ans > 1e15)\n        puts(\"-1\");\n    else\n        printf(\"%.16lf\\n\", ans);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double eps = 1e-8;\ndouble dot(P a, P b) { return real(conj(a) * b); }\ndouble cross(P a, P b) { return imag(conj(a) * b); }\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;\n    if (cross(b, c) < -eps) return -1;\n    if (dot(b, c) < -eps) return 2;\n    if (norm(c) > norm(b)) return -2;\n    return 0;\n}\nbool intersectSS(P p1, P p2, P p3, P p4) {\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nint n,m;long double ax[1000],ay[1000],bx[1000],by[1000],dist[1000];\nvector<pair<int,long double> >x[1000];\nlong double dijkstra(int s,int t){\n\tpriority_queue<pair<long double,int>,vector<pair<long double,int> >,greater<pair<long double,int> > >Q;\n\tQ.push(make_pair(0.0L,s));for(int i=0;i<1000;i++)dist[i]=1e9;dist[s]=0.0L;\n\twhile(!Q.empty()){\n\t\tlong double a1=Q.top().first;int a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<(int)x[a2].size();i++){\n\t\t\tif(dist[x[a2][i].first]>a1+x[a2][i].second){\n\t\t\t\tdist[x[a2][i].first]=a1+x[a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[x[a2][i].first],x[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[t];\n}\nint main(){\n\tcin>>n>>m;for(int i=0;i<n;i++)cin>>ax[i]>>ay[i];\n\tfor(int i=0;i<m;i++)cin>>bx[i]>>by[i];\n\tfor(int i=0;i<1000;i++)x[i].clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(intersectSS(P(ax[i],ay[i]),P(ax[j],ay[j]),P(bx[0],by[0]),P(bx[1],by[1]))==0){\n\t\t\t\tlong double dst1=sqrtl((ax[i]-ax[j])*(ax[i]-ax[j])+(ay[i]-ay[j])*(ay[i]-ay[j]));\n\t\t\t\tx[i].push_back(make_pair(j,dst1));\n\t\t\t\tx[j].push_back(make_pair(i,dst1));\n\t\t\t}\n\t\t}\n\t}\n\tlong double r1=dijkstra(0,1);\n\tfor(int i=0;i<1000;i++)x[i].clear();\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=i+1;j<m;j++){\n\t\t\tif(intersectSS(P(bx[i],by[i]),P(bx[j],by[j]),P(ax[0],ay[0]),P(ax[1],ay[1]))==0){\n\t\t\t\tlong double dst1=sqrtl((bx[i]-bx[j])*(bx[i]-bx[j])+(by[i]-by[j])*(by[i]-by[j]));\n\t\t\t\tx[i].push_back(make_pair(j,dst1));\n\t\t\t\tx[j].push_back(make_pair(i,dst1));\n\t\t\t}\n\t\t}\n\t}\n\tlong double r2=dijkstra(0,1);\n\tlong double r3=sqrtl((bx[0]-bx[1])*(bx[0]-bx[1])+(by[0]-by[1])*(by[0]-by[1]));\n\tlong double r4=sqrtl((ax[0]-ax[1])*(ax[0]-ax[1])+(ay[0]-ay[1])*(ay[0]-ay[1]));\n\tif(min(r1,r2)>=1e8)printf(\"-1\\n\");\n\telse printf(\"%.15Lf\\n\",min(r1+r3,r2+r4));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tld ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph ga(pa.size()), gb(pb.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tld d = abs(pa[i] - pa[j]);\n\t\tadd_edge(ga, i, j, d);\n\t\tadd_edge(ga, j, i, d);\n\t}\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tld d = abs(pb[i] - pb[j]);\n\t\tadd_edge(gb, i, j, d);\n\t\tadd_edge(gb, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(ga, da, 0);\n\tdijkstra(gb, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans > INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef double Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return abs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tdouble d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tdouble d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tdouble d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tdouble len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tdouble ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph ga(pa.size()), gb(pb.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tdouble d = abs(pa[i] - pa[j]);\n\t\tadd_edge(ga, i, j, d);\n\t\tadd_edge(ga, j, i, d);\n\t}\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tdouble d = abs(pb[i] - pb[j]);\n\t\tadd_edge(gb, i, j, d);\n\t\tadd_edge(gb, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(ga, da, 0);\n\tdijkstra(gb, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// dot of a and b\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// cross of a and b\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c : counter-clockwise\n\tif (cross(b, c) < -eps) return -1; // a,b,c : clockwise\n\tif (dot(b, c) < 0) return 2;       // c,a,b : on a line\n\tif (norm(b) < norm(c)) return -2;  // a,b,c : on a line\n\treturn 0;                          // a,c,b : on a line\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nld dist_pp(Point a, Point b){\n    ld d = (a.imag()-b.imag())*(a.imag()-b.imag())+(a.real()-b.real())*(a.real()-b.real());\n    return sqrt(d);\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int na,nb;cin>>na>>nb;\n    vector<vector<ld>> dis(1111,vector<ld>(1111,INF));\n    vector<Point> tota(na),tute(nb);\n    for(int i=0;i<na;i++){\n        tota[i]=input_point();\n    }\n    for(int i=0;i<nb;i++){\n        tute[i]=input_point();\n    }\n    ld res=INF;\n    Line l=Line(tota[0],tota[1]);\n    for(int i=0;i<nb;i++) dis[i][i]=0;\n    for(int i=0;i<nb;i++){\n        for(int j=i+1;j<nb;j++){\n            Line ltmp=Line(tute[i],tute[j]);\n            if(isis_ss(l,ltmp)) continue;\n            ld dtmp=dist_pp(tute[i],tute[j]);\n            dis[i][j]=dis[j][i]=dtmp;\n        }\n    }\n    for(int k=0;k<nb;k++){\n        for(int i=0;i<nb;i++){\n            for(int j=0;j<nb;j++){\n                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n            }\n        }\n    }\n    if(dis[0][1]>=INF) ;\n    else{\n        res=dist_pp(tota[0],tota[1]) + dis[0][1];\n    }\n\n    l =Line(tute[0],tute[1]);\n    for(int i=0;i<na;i++)for(int j=i+1;j<na;j++)dis[i][j]=dis[j][i]=INF;\n    for(int i=0;i<na;i++){\n        for(int j=i+1;j<na;j++){\n            Line ltmp=Line(tota[i],tota[j]);\n            if(isis_ss(l,ltmp)) continue;\n            ld dtmp=dist_pp(tota[i],tota[j]);\n            dis[i][j]=dis[j][i]=dtmp;\n        }\n    }\n    for(int k=0;k<na;k++){\n        for(int i=0;i<na;i++){\n            for(int j=0;j<na;j++){\n                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n            }\n        }\n    }\n    if(dis[0][1]>=INF) ;\n    else{\n        res=min(res,dist_pp(tute[0],tute[1]) + dis[0][1]);\n    }\n    if(res>=INF) cout<<-1<<endl;\n    else cout<<fixed<<setprecision(10)<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-10\n#define INF 1e8\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n \nstruct Point{\n    double x,y;\n \n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n    bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n \nistream &operator >> (istream &is,Point &p){ \n    return is >> p.x >> p.y;\n}\n \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n    return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n \nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n \nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n \nbool isIntersectSP(const Segment &s,const Point &p){\n    return equal(ccw(s.s,s.t,p),0);\n}\n \nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n \nstruct State{\n    double d;\n    int v;\n    State(double d,int v) : d(d),v(v) {}\n   \n    bool operator < (const State &s)const{\n\tif(not_equal(d,s.d)){\n\t    return lt(s.d,d);\n\t}\n    }\n};\n \ndouble solve(int x,vector<Point> A[2]){\n    priority_queue<State> Q;\n    Q.push(State(0,0));\n    double d[1010];\n    fill(d,d+1010,INF);\n    d[0] = 0;\n   \n    while(!Q.empty()){\n\tState s = Q.top(); Q.pop();\n\tint v = s.v;\n\tif(lt(d[v],s.d)) continue; \n\tif(v == 1) return d[v];\n\tfor(int i = 1 ; i < (int)A[x].size() ; i++){\n\t    if(v == i) continue;\n\t    Segment s1(A[x][v],A[x][i]),s2(A[1-x][0],A[1-x][1]);\n\t    if(isIntersectSS(s1,s2)) continue;\n\t    double nd = d[v]+dist(A[x][v],A[x][i]);\n\t    if(lt(nd,d[i])){\n\t\td[i] = nd;\n\t\tQ.push(State(d[i],i));\n\t    }\n\t}\n    }\n    return INF;\n}\n \nint main(){\n    int N,M;\n    vector<Point> A[2];\n    cin >> N >> M;\n    A[0].resize(N); A[1].resize(M);\n    for(int i = 0 ; i < N ; i++){\n\tcin >> A[0][i];\n    }\n    for(int i = 0 ; i < M ; i++){\n\tcin >> A[1][i];\n    }\n    double res = INF;\n    Segment s[2] = {Segment(A[0][0],A[0][1]),\n\t\t    Segment(A[1][0],A[1][1])};\n    for(int i = 0 ; i < 2 ; i++){\n\tres = min(res,solve(1-i,A)+dist(s[i].s,s[i].t));\n    }\n    if(res == INF){\n\tcout << -1 << endl;\n    }else{\n\tprintf(\"%.10f\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 0\n\nclass D3 {\npublic:\n\tlong double X, Y, Z, EPS;\n\n\tD3( long double, long double, long double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( long double );\n\tD3 operator*( long double );\n\tD3 operator/( long double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3 {\npublic:\n\tPoint( long double, long double, long double );\n\tlong double getX();\n\tlong double getY();\n\tlong double getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tlong double S_point( Point, Point );\n\tlong double V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec {\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( long double x_, long double y_, long double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( long double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( long double );\n\tbool operator== ( Vec );\n\tbool operator==( long double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tlong double length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tlong double S_vec( Vec );\n\tlong double V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( long double ld ) {\n\treturn ( *this ) == D3();\n}\n\nD3 D3::operator*( long double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( long double ld ) {\n\treturn  *this*( ld*-1.L );\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\nlong double Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\nlong double Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\nlong double Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( ( *this ).getX() != Partner.getX() ) {\n\t\treturn ( *this ).getX() < Partner.getX();\n\t}\n\tif( ( *this ).getY() != Partner.getY() ) {\n\t\treturn ( *this ).getY() < Partner.getY();\n\t}\n\treturn ( *this ).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < ( *this );\n}\n//??????????????¢???????±???????\nlong double Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\nlong double Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( ( *this ), B ).V_vec( Vec( ( *this ), C ), Vec( ( *this ), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( long double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + ( Partner*( -1.L ) );\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( long double ld ) {\n\treturn *this*( 1.L / ld );\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( long double ) {\n\treturn ( *this ) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\nlong double Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / ( *this ).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn ( *this )*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( ( *this ).Inverse_vec().getD(), ( *this ).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn ( *this ).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn ( *this ).Unit_vec().getD() == Partner.Unit_vec().getD() || ( *this ).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) );\n\tVec Q = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getSP() ) );\n\tVec R = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getGP() ) );\n\treturn ( !( *this ).Parallel( Partner ) ) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS ) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS );\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( ( *this ).isIntersection( Partner ) ) {\n\t\tlong double d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) ).D.Z );\n\t\tlong double d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) ).D.Z );\n\t\tlong double t = d1 / ( d1 + d2 );\n\t\treturn Vec( ( ( *this )*t ).getD(), ( *this ).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( ( *this ).getSP(), A );\n\tif( A == ( ( *this ).getSP() ) || ( Test.Parallel( *this ) && ( *this ).getD().X / Test.getD().X >= 1.0L ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\nlong double Vec::S_vec( Vec B ) {\n\tif( ( ( *this ).getSP() == B.getSP() ) ) {\n\t\tVec G = ( *this ).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( ( *this ).getGP() == B.getSP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B );\n\t}\n\tif( ( *this ).getSP() == B.getGP() ) {\n\t\treturn ( *this ).S_vec( B.Reverse_vec() );\n\t}\n\tif( ( *this ).getGP() == B.getGP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\nlong double Vec::V_vec( Vec B, Vec C ) {\n\tVec G = ( *this ).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points {\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance {\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n\n\nvector<vector<pair<long long int, long double>>>makelist( vector<Point>&townlist, Vec DisallowVec ) {\n\tvector<vector<pair<long long int, long double>>>ret( townlist.size() );\n\tfor( size_t i = 0; i < townlist.size(); i++ ) {\n\t\tfor( size_t j = i + 1; j < townlist.size(); j++ ) {\n\t\t\tVec now = Vec( townlist[i], townlist[j] );\n\t\t\tif( !now.isIntersection( DisallowVec ) ) {\n\t\t\t\tret[i].push_back( make_pair( j, now.length() ) );\n\t\t\t\tret[j].push_back( make_pair( i, now.length() ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nlong double dijkstra( vector<vector<pair<long long int, long double>>>  listLen ) {\n\tvector<long double>ret( listLen.size(), LDBL_MAX / 10 );\n\tpriority_queue<pair<long double, long long int>, vector<pair<long double, long long int>>, greater<pair<long double, long long int>>>que;\n\tque.push( make_pair( 0, 0 ) );\n\tret[0] = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( now.second == 1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif( now.first != ret[now.second] ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( auto next : listLen[now.second] ) {\n\t\t\tif( ret[next.first] > now.first + next.second ) {\n\t\t\t\tret[next.first] = now.first + next.second;\n\t\t\t\tif( ret[next.first] < ret[1] ) {\n\t\t\t\t\tque.push( make_pair( now.first + next.second, next.first ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret[1];\n}\n\n\nint main() {\n\tlong long int NA, NB;\n\tcin >> NA >> NB;\n\tvector<Point>townA( NA ), townB( NB );\n\tfor( size_t i = 0; i < NA; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownA[i] = Point( x, y );\n\t}\n\tfor( size_t i = 0; i < NB; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownB[i] = Point( x, y );\n\t}\n\n\tauto listA = makelist( townA, Vec( townB[0], townB[1] ) );\n\tauto listB = makelist( townB, Vec( townA[0], townA[1] ) );\n\n\tlong double lenA = dijkstra( listA );\n\tlong double lenB = dijkstra( listB );\n\n\tif( lenA == LDBL_MAX / 10 && lenB == LDBL_MAX / 10 ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << fixed << setprecision( 20 ) << min( lenA + Vec( townB[0], townB[1] ).length(), lenB + Vec( townA[0], townA[1] ).length() ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\npoint polar(const long double &r, const long double &th) { return point(r*cosl(th),r*sinl(th)); }\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\n\nlong double sub(int na,int nb,vector<point> &pa,vector<point> &pb){\n    vector<long double> dist(nb,inf);\n    vector<bool> done(nb);\n    dist[0]=0;\n    for(;;){\n        int u=-1;\n        rep(v,0,nb){\n            if(!done[v] and (u==-1 or dist[u]>dist[v])) u=v;\n        }\n        if(u==-1) break;\n        done[u]=true;\n        rep(v,0,nb){\n            if(intersectSS(line(pa[0],pa[1]),line(pb[u],pb[v]))) continue;\n            long double d=dist[u]+abs(pb[u]-pb[v]);\n            if(d<dist[v]) dist[v]=d;\n        }\n    }\n    return abs(pa[0]-pa[1])+dist[1];\n}\n\nvoid solve(){\n    int na,nb;\n    cin >> na >> nb;\n    vector<point> pa,pb;\n    rep(i,0,na){\n        long double x,y;\n        cin >> x >> y;\n        pa.push_back(point(x,y));\n    }\n    rep(i,0,nb){\n        long double x,y;\n        cin >> x >> y;\n        pb.push_back(point(x,y));\n    }\n    long double ans=min(sub(na,nb,pa,pb),sub(nb,na,pb,pa));\n    if(ans<inf) cout << ans << endl;\n    else cout << -1 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nstruct edge{\n\tdouble cost;\n\tint to;\n};\nD inf=1e10,eps=1e-10;\nbool eq(D a, D b) { return abs(a-b)<eps;}\nbool eq(P a, P b) { return abs(a-b)<eps;}\nint sig(D a) { return eq(a,0) ? 0 : (a>0 ? 1 : -1);}\ninline D cro(P a, P b) { return imag(conj(a)*b);};\ninline int ccw (P a, P b, P c){\n//\tcout << cro(b-a,c-a) << endl;\n\tif(sig(cro(b-a,c-a))==1) return 1;\n\tif(sig(cro(b-a,c-a))==-1) return -1;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return 0;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return -2;\n\tif(eq(abs(c-a)+abs(a-b),abs(c-b))) return 2;\n}\ninline bool iSS(L a, L b){\t\t//intersect(including endpoint) or overload\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0 && ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nP pa[1000],pb[1000];\nvector<edge> G[1000];\ndouble d[1000];\ntypedef pair<double,int> Pa;\nvoid dijkstra(int s){\n\trep(i,1000) d[i]=inf;\n\tpriority_queue<Pa,vector<Pa>,greater<Pa> > que;\n\td[s]=0;\n\tque.push(Pa(0,s));\n\twhile(!que.empty()){\n\t\tPa p=que.top();\n\t\tque.pop();\n\t\tint v=p.sc;\n\t\tif(d[v]<p.fs) continue;\n\t\trep(i,G[v].size()){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tque.push(Pa(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint a,b;\n\tcin>>a>>b;\n\trep(i,a){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tpa[i]=P(x,y);\n\t}\n\trep(i,b){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tpb[i]=P(x,y);\n\t}\n\tL lb=L(pb[0],pb[1]);\n\trep(i,a) rep(j,i){\n\t\tif(!iSS(L(pa[i],pa[j]),lb)){\n\t\t\tG[i].pb({abs(pa[i]-pa[j]),j});\n\t\t\tG[j].pb({abs(pa[i]-pa[j]),i});\n\t\t}\n\t}\n\tdouble ans=inf;\n\tdijkstra(0);\n\tans=min(ans,d[1]+abs(pb[0]-pb[1]));\n\tL la=L(pa[0],pa[1]);\n\trep(i,b) G[i].clear();\n\trep(i,b) rep(j,i){\n\t\tif(!iSS(L(pb[i],pb[j]),la)){\n\t\t\tG[i].pb({abs(pb[i]-pb[j]),j});\n\t\t\tG[j].pb({abs(pb[i]-pb[j]),i});\n\t\t}\n\t}\n\tdijkstra(0);\n\tans=min(ans,d[1]+abs(pa[0]-pa[1]));\n\n\tif(ans==inf) ans=-1;\n\tprintf(\"%.13f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<utility>\n#include<queue>\n\nusing namespace std;\n\nvector<double> d(1000, -1.0);\npriority_queue< pair<double, int>, vector< pair<double, int> >, greater< pair<double, int> > > que;\nvector< pair<int,  double> > edges[10000];\n\nvoid dijkstra(int start){\n    d.clear();\n    d[start] = 0.0;\n    que.push(pair<double, int>(0.0, start));\n    \n    while(!que.empty()){\n        pair<double, int> p = que.top(); que.pop();\n        for(pair<int, double> e: edges[p.second]){\n            if(d[e.first] < -0.1 || d[e.first] > d[p.second] + e.second){\n                d[e.first] = d[p.second] + e.second;\n                que.push(pair<double, double>(d[e.first], e.first));\n            }\n        }\n    }\n}\n\n// 線分交差判定\n// 3つ以上の点が一直線上に並ぶことはない\nbool are_crossing(complex<double> a1, complex<double> a2, complex<double> b1, complex<double> b2){\n    if(abs(a1.real() - a2.real()) < 1e-10){\n        if(abs(b1.real() - b2.real()) < 1e-10){\n            if(a1.real() != b1.real()) return false;\n            if(a1.imag() > a2.imag()) swap(a1, a2);\n            if(a1.imag() <= b1.imag() && b1.imag() <= a2.imag()) return true;\n            if(a1.imag() <= b2.imag() && b2.imag() <= a2.imag()) return true;\n            return false;\n        }\n        swap(a1, b1);\n        swap(a2, b2);\n    }\n    double a_a = (a2.imag() - a1.imag()) / (a2.real() - a1.real());\n    double a_b = a1.imag() - a_a * a1.real();\n    if( (b1.imag() - (a_a * b1.real() + a_b)) * (b2.imag() - (a_a * b2.real() + a_b)) <= 0){\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector< complex<double> > a(n, complex<double>(0.0, 0.0)), b(m, complex<double>(0.0, 0.0));\n    double re, im;\n    for(int i=0;i<n;i++){\n        cin >> re >> im;\n        a[i].real(re); a[i].imag(im);\n    }\n    for(int i=0;i<m;i++){\n        cin >> re >> im;\n        b[i].real(re); b[i].imag(im);\n    }\n\n    double a_abs = abs(a[1] - a[0]);\n    double b_abs = abs(b[1] - b[0]);\n    double ans = a_abs + b_abs;\n\n    if(are_crossing(a[0], a[1], b[0], b[1])){\n        ans = DBL_MAX;\n        \n        // aで経由点を作る\n        if(n > 2){\n            for(int i=0;i<n;i++){\n                for(int j=i+1;j<n;j++){\n                    if(are_crossing(a[i], a[j], b[0], b[1])) continue;\n                    double cost = abs(a[i]-a[j]);\n                    edges[i].push_back(pair<int, double>(j, cost));\n                    edges[j].push_back(pair<int, double>(i, cost));\n                }\n            }\n            dijkstra(0);\n            if(d[1] > 0.0) ans = min(ans, d[1] + b_abs);\n        }\n\n        // bで経由点を作る\n        if(m > 2){\n            for(int i=0;i<n;i++) edges[i].clear();\n            for(int i=0;i<m;i++){\n                for(int j=i;j<m;j++){\n                    if(are_crossing(a[0], a[1], b[i], b[j])) continue;\n                    double cost = abs(b[i]-b[j]);\n                    edges[i].push_back(pair<int, double>(j, cost));\n                    edges[j].push_back(pair<int, double>(i, cost));\n                }\n            }\n            dijkstra(0);\n            if(d[1] > 0.0) ans = min(ans, d[1] + a_abs);\n        }\n    }\n    if(abs(ans - DBL_MAX) < 1e-10){\n        printf(\"-1\");\n    }else{\n        printf(\"%.10lf\\n\", ans);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n\n#define f first\n#define s second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<double,double>pii;\n\ndouble dist(pii a,pii b){\n  return sqrt(pow(a.f-b.f,2)+pow(a.s-b.s,2));\n}\n\nconst double EPS=1e-10;\n\ndouble dot(pii a,pii b){\n  return a.f*b.f+a.s*b.s;\n}\n\ndouble cross(pii a,pii b){\n  return a.f*b.s-a.s*b.f;\n}\n\ndouble norm(pii a){\n  return sqrt(a.f*a.f+a.s*a.s);\n}\n\nint ccw(pii a, pii b, pii c) {\n  b.f -= a.f; \n  b.s -= a.s; \n  c.f -= a.f;\n  c.s -= a.s;\n  if (cross(b, c) > 0)   return +1;\n  if (cross(b, c) < 0)   return -1;\n  if (dot(b, c) < 0)     return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isCross(pii a1,pii a2,pii b1,pii b2){\n  return ccw(a1,a2,b1)*ccw(a1,a2,b2)<=0 &&\n    ccw(b1,b2,a1)*ccw(b1,b2,a2)<=0;\n}\n\nint main(void){\n  \n  int na,nb;\n  cin >> na >> nb;\n  \n  vector<pii>a(na),b(nb);\n  \n  for(int i=0;i<na;i++)cin >> a[i].f >> a[i].s;\n  for(int i=0;i<nb;i++)cin >> b[i].f >> b[i].s;\n  \n  double ans=isCross(a[0],a[1],b[0],b[1])?INF:dist(a[0],a[1])+dist(b[0],b[1]);\n  for(int i=2;i<na;i++){\n    double d=dist(a[0],a[i])+dist(a[i],a[1]);\n    if(!isCross(a[0],a[i],b[0],b[1]) && \n       !isCross(a[i],a[1],b[0],b[1]))ans=min(ans,d+dist(b[0],b[1]));\n    \n    for(int j=2;j<na;j++){\n      if(!isCross(a[0],a[i],b[0],b[1]) &&\n\t !isCross(a[i],a[j],b[0],b[1]) &&\n\t !isCross(a[j],a[1],b[0],b[1]))\n\tans=min(ans,dist(a[0],a[i])+dist(a[i],a[j])+dist(a[j],a[1])+dist(b[0],b[1]));\n    }\n  }\n  \n  for(int i=2;i<nb;i++){\n    double d=dist(b[0],b[i])+dist(b[i],b[1]);\n    if(!isCross(b[0],b[i],a[0],a[1]) &&\n       !isCross(b[i],b[1],a[0],a[1]))ans=min(ans,d+dist(a[0],a[1]));\n    \n    for(int j=2;j<nb;j++){\n      if(!isCross(b[0],b[i],a[0],a[1]) &&\n\t !isCross(b[i],b[j],a[0],a[1]) &&\n\t !isCross(b[j],b[1],a[0],a[1]))\n\tans=min(ans,dist(b[0],b[i])+dist(b[i],b[j])+dist(b[j],b[1])+dist(a[0],a[1]));\n    }    \n  }\n  \n  if(ans==INF)cout << -1 << endl;\n  else {\n    printf(\"%.9f\",ans);\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    double dist(const Point& p) const{\n        return sqrt((double)(y - p.y) * (y - p.y) + (x - p.x) * (x - p.x));\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    int cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) <= 0) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) <= 0);\n}\n\nclass Edge\n{\npublic:\n    int to;\n    double cost;\n    Edge(){};\n    Edge(int to0, double cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<double>& dist)\n{\n    const double EPS = 1.0e-15;\n\n    dist.assign(edges.size(), DBL_MAX);\n    dist[start] = 0.0;\n    priority_queue<pair<double,int> ,vector<pair<double,int> >, greater<pair<double,int> > > q;\n    q.push(make_pair(0.0, start));\n\n    while(!q.empty()){\n        pair<double, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first - EPS)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost + EPS < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n[2];\n    cin >> n[0] >> n[1];\n\n    vector<vector<Point> > p(2);\n\n    for(int i=0; i<2; ++i){\n        p[i].resize(n[i]);\n        for(int j=0; j<n[i]; ++j){\n            cin >> p[i][j].x >> p[i][j].y;\n        }\n    }\n\n    double ret = DBL_MAX;\n    vector<vector<vector<Edge> > > edges(2);\n    for(int i=0; i<2; ++i){\n        vector<vector<Edge> > edges(n[i]);\n        Point p1 = p[i^1][0];\n        Point p2 = p[i^1][1];\n        for(int j=0; j<n[i]; ++j){\n            for(int k=0; k<n[i]; ++k){\n                if(!segmentsCollide(p1, p2, p[i][j], p[i][k])){\n                    edges[j].push_back(Edge(k, p[i][j].dist(p[i][k])));\n                }\n            }\n        }\n\n        vector<double> dist;\n        shortestPath(edges, 1, dist);\n\n        ret = min(ret, p1.dist(p2) + dist[0]);\n    }\n\n    if(ret > DBL_MAX/2)\n        cout << -1 << endl;\n    else\n        printf(\"%.12f\\n\", ret);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tld ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph ga(pa.size()), gb(pb.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tld d = abs(pa[i] - pa[j]);\n\t\tadd_edge(ga, i, j, d);\n\t\tadd_edge(ga, j, i, d);\n\t}\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tld d = abs(pb[i] - pb[j]);\n\t\tadd_edge(gb, i, j, d);\n\t\tadd_edge(gb, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(ga, da, 0);\n\tdijkstra(gb, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned msb(unsigned v) { v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; return (v >> 1) + 1; }\ninline unsigned round_up_pow2(unsigned v) { return msb(v - 1) << 1; }\ninline unsigned msb_index(unsigned v) { static const int pos[32] = { 0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9 }; return pos[(v * 0x077CB531UL) >> 27]; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it != last1 && *it == val) { return distance(it, first1); }\n\treturn ~distance(it, first1);\n}\n\n// iota vector \nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\n// iota イテレータ\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n// 文字列の置換\nvoid inplaceReplace(string &target, const string &from, const string &to, bool global = false)\n{\n\tdo\n\t{\n\t\tstring::size_type pos = target.find(from);\n\t\tif (pos == target.npos) { break; }\n\t\ttarget.replace(pos, from.length(), to);\n\t} while (true);\n}\n\n// 範囲内チェック\ninline bool contains(int x, int min, int max) { return x >= min && x < max; }\ninline bool contains(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; }\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint size;\n\tvector<T> tree;\n\tTParentFunc parent;\n\tunsigned msb(unsigned v) { REP(i, 5) v |= v >> (1 << i); return (v >> 1) + 1; }\n\n\tSegTree(int count, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: size(msb(count - 1) << 1)\n\t\t, tree(size * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, size, size), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + size]; }\n\tvoid rebuild() { RREP(i, size) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + size] = value;\n\t\tfor (int i = (index + size) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, size, initialValue);\n\t}\n};\n\n\n//// number ////\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y)\n{\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n// mを法としたaの逆元を求める。mが素数なら、a**(m-2)がaの逆元。\nlong modInv(long a, long mod) { long x, y; exgcd(a, mod, x, y); return x; }\n\n// modInvのvector版\nvector<int> modInvVector(int n, int mod)\n{\n\tvector<int> ret(n + 1);\n\tret[1] = 1;\n\tfor (int i = 2; i <= n; ++i)\n\t\tret[i] = ret[mod % i] * (mod - mod / i) % mod;\n\treturn ret;\n}\n\n// エラトステネス\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n//// geometry ////\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n};\n\n\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn contains(a, b.p) || contains(a, b.p + b.d)\n\t\t|| contains(b, a.p) || contains(b, a.p + a.d);\n}\n\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\ntemplate <class COST>\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\ttypedef Path<COST> P;\n\tint N = costTable.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(0, 0, 0));\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(P(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n// warshall_floyd //\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, Na, Nb);\n\t\tauto Pa = read<P2>(Na);\n\t\tauto Pb = read<P2>(Nb);\n\t\tLineSeg ASeg = LineSeg::From2Point(Pa[0], Pa[1]);\n\t\tLineSeg BSeg = LineSeg::From2Point(Pb[0], Pb[1]);\n\n\t\tif (!isCross(ASeg, BSeg))\n\t\t{\n\t\t\tprintf(\"%.15f\", ASeg.d.length() + BSeg.d.length());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvevector<Path<double> > Ga(Na);\n\t\t\tvevector<Path<double> > Gb(Nb);\n\t\t\t\n\t\t\tREP(i, Na) REP(j, Na)\n\t\t\t{\n\t\t\t\tLineSeg s = LineSeg::From2Point(Pa[i], Pa[j]);\n\t\t\t\tif (!isCross(BSeg, s)) Ga[i].push_back({ i, j, s.d.length() });\n\t\t\t}\n\t\t\t\n\t\t\tREP(i, Nb) REP(j, Nb)\n\t\t\t{\n\t\t\t\tLineSeg s = LineSeg::From2Point(Pb[i], Pb[j]);\n\t\t\t\tif (!isCross(ASeg, s)) Gb[i].push_back({ i, j, s.d.length() });\n\t\t\t}\n\n\t\t\tdouble aconn = ASeg.d.length() + dijkstra(Gb, 0, 1).first[1];\n\t\t\tdouble bconn = BSeg.d.length() + dijkstra(Ga, 0, 1).first[1];\n\t\t\tdouble ans = min(aconn, bconn);\n\t\t\tif (ans > INF) { WRITE(-1); }\n\t\t\telse { printf(\"%.15f\", ans); }\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\n\n#endif\n\n#include <queue>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst double inf = 1000000000.0;\nint N, M, x, y; vector<Point> v1, v2;\nint main() {\n\tcin >> N >> M;\n\tv1.resize(N);\n\tv2.resize(M);\n\tfor (int i = 0; i < N; i++) cin >> x >> y, v1[i] = Point(x, y);\n\tfor (int i = 0; i < M; i++) cin >> x >> y, v2[i] = Point(x, y);\n\tvector<double> dist1(N, inf * 2); dist1[0] = 0;\n\tpriority_queue<pair<double, int> > que1; que1.push(make_pair(0.0, 0));\n\twhile (!que1.empty()) {\n\t\tint u = que1.top().second; que1.pop();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (u == i) continue;\n\t\t\tif (!intersect(Segment(make_pair(v2[0], v2[1])), Segment(make_pair(v1[u], v1[i])), true) && dist1[i] > dist1[u] + abs(v1[u] - v1[i])) {\n\t\t\t\tdist1[i] = dist1[u] + abs(v1[u] - v1[i]);\n\t\t\t\tque1.push(make_pair(-dist1[i], i));\n\t\t\t}\n\t\t}\n\t}\n\tvector<double> dist2(M, inf * 2); dist2[0] = 0;\n\tpriority_queue<pair<double, int> > que2; que2.push(make_pair(0.0, 0));\n\twhile (!que2.empty()) {\n\t\tint u = que2.top().second; que2.pop();\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (u == i) continue;\n\t\t\tif (!intersect(Segment(make_pair(v1[0], v1[1])), Segment(make_pair(v2[u], v2[i])), true) && dist2[i] > dist2[u] + abs(v2[u] - v2[i])) {\n\t\t\t\tdist2[i] = dist2[u] + abs(v2[u] - v2[i]);\n\t\t\t\tque1.push(make_pair(-dist2[i], i));\n\t\t\t}\n\t\t}\n\t}\n\tif(dist1[1] < inf || dist2[1] < inf) cout << fixed << setprecision(12) << min(dist1[1] + abs(v2[0] - v2[1]), dist2[1] + abs(v1[0] - v1[1])) << endl;\n\telse cout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//=====================================================\n// \n// (setq backup-inhibited t)\n// (setq auto-save-default nil)\n// \n// (column-number-mode t)\n// (setq-default tab-width 2 indent-tabs-mode nil)\n// \n// (global-set-key \"\\C-h\" 'delete-backward-char)\n// \n// (setq indent-line-function 'indent-relative-maybe)\n// (global-set-key \"\\C-m\" 'newline-and-indent)\n// \n//=====================================================\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef complex<long double> P;\ntypedef vector<P> L;\n\nconst long double EPS=1e-9;\nconst long double INF=1e+12; \n\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n           ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nlong double dijkstra(const vector<vector<pair<int,long double>>>& g){\n  priority_queue<pair<long double,int>,vector<pair<long double,int>>,greater<pair<long double,int>>> q;\n  q.push(pair<long double,int>(0.0,0));\n  vector<long double> dist(g.size(),INF);\n  dist[0]=0.0;\n  while(!q.empty()){\n    auto p=q.top();\n    q.pop();\n    long double d=p.first;\n    int i=p.second;\n    if(d > dist[i])continue;\n    for(auto e:g[i]){\n      int j=e.first;\n      long double l=e.second;\n      if(dist[j] > dist[i]+l){\n        dist[j] = dist[i]+l;\n        q.push(make_pair(dist[j],j));\n      }\n    }\n  }\n  return dist[1];\n}\n\nint main() {\n  int na,nb;\n  cin>>na>>nb;\n  vector<P> a(na);\n  vector<P> b(nb);\n  REP(i,na){\n    int x,y;\n    cin>>x>>y;\n    a[i] = P(x,y);\n  }\n  REP(i,nb){\n    int x,y;\n    cin>>x>>y;\n    b[i] = P(x,y);\n  }\n  vector<vector<pair<int,long double>>> ea(na);\n  vector<vector<pair<int,long double>>> eb(nb);\n  L la={a[0],a[1]};\n  L lb={b[0],b[1]};\n  REP(i,na){\n    REP(j,na){\n      if(i==j)continue;\n      L l = {a[i],a[j]};\n      if(!intersectSS(lb,l)){\n        ea[i].push_back(make_pair(j,abs(a[i]-a[j])));\n      }\n    }\n  }\n  REP(i,nb){\n    REP(j,nb){\n      if(i==j)continue;\n      L l = {b[i],b[j]};\n      if(!intersectSS(la,l)){\n        eb[i].push_back(make_pair(j,abs(b[i]-b[j])));\n      }\n    }\n  }\n  double dist1 = dijkstra(ea) + abs(b[0]-b[1]);\n  double dist2 = dijkstra(eb) + abs(a[0]-a[1]);\n  long double d = min(dist1,dist2);\n  if(d<INF)\n    cout<<fixed<<setprecision(12)<<d<<endl;\n  else\n    cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\n\nusing ld = long double;\nusing P = complex<ld>;\nconst ld eps = 1e-10;\n\nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/*\nCCW\n\n-- BEHIND -- [a -- ON -- b] --- FRONT --\n\nCW\n*/\nenum { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps)  return CCW;    // counter clockwise\n    if (cross(b, c) < -eps) return CW;     // clockwise\n    if (dot(b, c) < 0)      return BEHIND; // c--a--b on line\n    if (norm(b) < norm(c))  return FRONT;  // a--b--c on line\n    return ON;\n}\n\nstruct L : public vector<P> {\n    L(const P &a = 0, const P &b = 0) {\n        push_back(a); push_back(b);\n    }\n    L(ld A, ld B, ld C) { // Ax + By + C = 0\n        if (A < eps) *this = L(P(0, -C / B), P(1, -C / B));\n        else if (B < eps) *this = L(P(-C / A, 0), P(-C / A, 1));\n        *this = L(P(0, -C / B), P(-C / A, 0));\n    }\n    int ccw(const P& p) {\n        return ::ccw((*this)[0], (*this)[1], p);\n    }\n};\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n        ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\nint na, nb;\nP a[1010], b[1010];\n\nld solve() {\n    L s(a[0], a[1]);\n    ld res = 1e9;\n    if (!intersectSS(s, L(b[0], b[1]))) {\n        res = min(res, abs(b[0] - b[1]));\n    }\n    for (int i = 2; i < nb; ++i) {\n        L s1(b[0], b[i]);\n        L s2(b[i], b[1]);\n        if (!intersectSS(s, s1) && !intersectSS(s, s2)) {\n            res = min(res, abs(b[0] - b[i]) + abs(b[i] - b[1]));\n        }\n        for (int j = 2; j < nb; ++j) {\n            if (i == j) continue;\n            L s1(b[0], b[i]);\n            L s2(b[i], b[j]);\n            L s3(b[j], b[1]);\n            if (!intersectSS(s, s1) && !intersectSS(s, s2) && !intersectSS(s, s3)) {\n                res = min(res, abs(b[0] - b[i]) + abs(b[i] - b[j]) + abs(b[j] - b[1]));\n            }\n        }\n    }\n    return res + abs(a[0] - a[1]);\n}\n\nint main() {\n    while (cin >> na >> nb) {\n        int x, y;\n        for (size_t i = 0; i < na; i++) {\n            cin >> x >> y;\n            a[i] = P(x, y);\n        }\n        for (size_t i = 0; i < nb; i++) {\n            cin >> x >> y;\n            b[i] = P(x, y);\n        }\n        \n        ld ans = 1e9;\n        ans = solve();\n        swap(a, b);\n        swap(na, nb);\n        ans = min(ans, solve());\n        if (ans >= 1e9) {\n            puts(\"-1\");\n        } else {\n            printf(\"%.10lf\\n\", (double)ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct vec{\n    int x,y;\n    vec(int x,int y){\n        this->x=x;this->y=y;\n    }\n    int cross(vec b){\n        return x*b.y-y*b.x;\n    }\n    vec operator-(vec b){\n        return vec(x-b.x,y-b.y);\n    }\n    vec operator+(vec b){\n        return vec(x+b.x,y+b.y);\n    }\n    double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\nbool isCrossing(vec& v1, vec& v2, vec& v3, vec& v4){\n    return (v2-v1).cross(v3-v1)*(v2-v1).cross(v4-v1)<0&&(v4-v3).cross(v1-v3)*(v4-v3).cross(v2-v3)<0;\n}\n\nint main(){\n    int NA,NB,x,y;\n    cin>>NA>>NB;\n    vector<vec> A,B;\n    for(int i=0;i<NA;i++){\n        cin>>x>>y;\n        A.emplace_back(x,y);\n    }\n    for(int i=0;i<NB;i++){\n        cin>>x>>y;\n        B.emplace_back(x,y);\n    }\n    double EA[NA][NA];\n    double EB[NB][NB];\n    fill(EA[0],EA[NA],0);\n    fill(EB[0],EB[NB],0);\n    for(int i=0;i<NA;i++){\n        for(int j=i+1;j<NA;j++){\n            if(!isCrossing(A[i],A[j],B[0],B[1])) EA[i][j]=EA[j][i]=(A[i]-A[j]).norm();\n        }\n    }\n    for(int i=0;i<NB;i++){\n        for(int j=i+1;j<NB;j++){\n            if(!isCrossing(B[i],B[j],A[0],A[1])) EB[i][j]=EB[j][i]=(B[i]-B[j]).norm();\n        }\n    }\n    double Amin[NA],Bmin[NB];\n    fill(Amin,Amin+NA,1e10);\n    fill(Bmin,Bmin+NB,1e10);\n    double Acost,Bcost;\n    int s=0,end=1;\n    typedef pair<double, int> P;\n    priority_queue<P,vector<P>,greater<P>> que;\n    Amin[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        double cost=p.first;\n        for(int i=0;i<NA;i++){\n            if(EA[i][v]!=0&&cost+EA[i][v]<Amin[i]){\n                Amin[i]=cost+EA[i][v];\n                que.push(P(Amin[i],i));\n            }\n        }\n    }\n    if(Amin[end]!=1e10){\n        Acost=Amin[end]+(B[s]-B[end]).norm();\n    }else{\n        Acost=1e10;\n    }\n    Bmin[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        double cost=p.first;\n        for(int i=0;i<NB;i++){\n            if(EB[i][v]!=0&&cost+EB[i][v]<Bmin[i]){\n                Bmin[i]=cost+EB[i][v];\n                que.push(P(Bmin[i],i));\n            }\n        }\n    }\n    if(Bmin[end]!=1e10){\n        Bcost=Bmin[end]+(A[s]-A[end]).norm();\n    }else{\n        Bcost=1e10;\n    }\n    if(min(Acost,Bcost)==1e10){\n        cout<<-1<<endl;\n    }else{\n        cout.precision(12);\n        cout << fixed;\n        cout<<min(Acost,Bcost)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint na;\nint nb;\nP ap[1001];\nP bp[1001];\nconst int INF=1000000000;\n\nint main(){\n\n\tcin>>na>>nb;\n\tfor(int i=0;i<na;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tap[i]=P(x,y);\n\t}\n\tfor(int i=0;i<nb;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tbp[i]=P(x,y);\n\t}\n\t// ½s,Ü½ÍNXµÈ¢\n\tif(!is_intersected_ls(ap[0],ap[1],bp[0],bp[1])){\n\t\tdouble res=abs(ap[0]-ap[1])+abs(bp[0]-bp[1]);\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n\telse{\n\t\tdouble res=INF;\n\t\t// apðÅèµÄbpð®©·\n\t\tfor(int i=2;i<nb;i++)\n\t\t\tif(!is_intersected_ls(ap[0],ap[1],bp[0],bp[i])&&!is_intersected_ls(ap[0],ap[1],bp[i],bp[1]))\n\t\t\t\tres=min(res,abs(ap[0]-ap[1])+abs(bp[0]-bp[i])+abs(bp[1]-bp[i]));\n\t\tfor(int i=2;i<nb;i++){\n\t\t\tfor(int j=2;j<nb;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(!is_intersected_ls(ap[0],ap[1],bp[0],bp[i])&&!is_intersected_ls(ap[0],ap[1],bp[i],bp[j])&&!is_intersected_ls(ap[0],ap[1],bp[j],bp[1]))\n\t\t\t\t\tres=min(res,abs(ap[0]-ap[1])+abs(bp[0]-bp[i])+abs(bp[1]-bp[j])+abs(bp[i]-bp[j]));\n\t\t\t}\n\t\t}\n\n\t\t// bpðÅèµÄapð®©·\n\t\tfor(int i=2;i<na;i++)\n\t\t\tif(!is_intersected_ls(bp[0],bp[1],ap[0],ap[i])&&!is_intersected_ls(bp[0],bp[1],ap[i],ap[1]))\n\t\t\t\tres=min(res,abs(bp[0]-bp[1])+abs(ap[0]-ap[i])+abs(ap[1]-ap[i]));\n\t\tfor(int i=2;i<na;i++){\n\t\t\tfor(int j=2;j<na;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(!is_intersected_ls(bp[0],bp[1],ap[0],ap[i])&&!is_intersected_ls(bp[0],bp[1],ap[i],ap[j])&&!is_intersected_ls(bp[0],bp[1],ap[j],ap[1]))\n\t\t\t\t\tres=min(res,abs(bp[0]-bp[1])+abs(ap[0]-ap[i])+abs(ap[1]-ap[j])+abs(ap[i]-ap[j]));\n\t\t\t}\n\t\t}\n\t\tif(EQ(res,INF))cout<<-1<<endl;\n\t\telse printf(\"%.10f\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld inf = 1e40;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nstruct MyEdge {\n\tint to;\n\tld dist;\n};\nbool operator >(const MyEdge& e1, const MyEdge& e2) {\n\treturn e1.dist > e2.dist;\n}\n\nld solve(vector<Point> a, vector<Point> b) {\n\tLine bl(b[0], b[1]);\n\tint N = a.size();\n/*\n\tvector< vector<MyEdge> > G(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (i != j && !isis_ss(bl, Line(a[i], a[j]))) {\n\t\t\t\tld d = abs(a[i]-a[j]);\n\t\t\t\tG[i].push_back( (MyEdge){j, d} );\n\t\t\t\tG[j].push_back( (MyEdge){i, d} );\n\t\t\t}\n\t\t}\n\t}\n*/\n\tvector<ld> dist(N, inf);\n\tpriority_queue<MyEdge, vector<MyEdge>, greater<MyEdge> > Q; Q.push({0, 0});\n\twhile ( !Q.empty() ) {\n\t\tMyEdge q = Q.top(); Q.pop();\n\t\tint v = q.to;\n\t\tif (q.dist > dist[v] || eq(q.dist, dist[v])) {\n\t\t\tcontinue;\n\t\t}\n\t\tdist[v] = q.dist;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (i != v && !isis_ss(bl, Line(a[i], a[v]))) {\n\t\t\t\tif (dist[v]+abs(a[i]-a[v]) < dist[i]) {\n\t\t\t\t\tQ.push( (MyEdge){i, dist[v]+abs(a[i]-a[v])} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[1]+abs(b[0]-b[1]);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<Point> a, b;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\ta.push_back( Point(x, y) );\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tb.push_back( Point(x, y) );\n\t}\n\tld ans = min( solve(a, b), solve(b, a) );\n\tif ( eq(ans, inf) ) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << fixed << setprecision(12) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int MOD = 1e9+7;\n\ntypedef tuple<double, double> mytuple;\n\n#define EPS 1e-8\ntypedef complex<double> Point;\nnamespace std {\n    bool operator < (const Point &a, const Point &b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    Point operator / (const Point &p, const double &a) {\n        return Point(real(p)/a, imag(p)/a);\n    }\n    Point operator * (const Point &p, const double &a) {\n        return Point(real(p)*a, imag(p)*a);\n    }\n    bool operator == (const Point &a, const Point &b) {\n        return real(a) == real(b) && imag(a) == imag(b);\n    }\n}\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> { \n    Line () {}\n    Line (const Point &a, const Point &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ndouble dot (const Point &a, const Point &b) {\n        return real(conj(a)*b);\n}\n\ndouble cross (const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; //ccw\n    if (cross(b, c) < 0)   return -1; //cw\n    if (dot(b, c) < 0)     return +2; //c--a--b on line\n    if (norm(b) < norm(c)) return -2; //a--b--c on line\n    return 0; //a--c--b or (c=b)\n}\n\nbool intersectSS (const Line &s, const Line &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectLL (const Line &l, const Line &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\ntypedef double Weight;\nconst Weight INF=1e9;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int rev;\n    Edge(int f, int t, Weight c, int rev=0):src(f),dst(t),weight(c),rev(rev){}\n    bool operator < (const Edge& re)const{ return weight > re.weight;}\n};\ntypedef vector<vector<Edge> > Graph;\nvoid add_edge(Graph &G, int s, int t, Weight cap){\n    G[s].push_back(Edge(s, t, cap, G[t].size()));\n}\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q;\n    for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n        Edge e = Q.top(); Q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight){\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\n\ndouble dist(Line &l){\n    return abs(l[1] - l[0]);\n}\n\nint main(void){\n    int na, nb;\n    cin >> na >> nb;\n    vector<Point> aP, bP;\n    REP(i, na){\n        double x, y;\n        cin >> x >> y;\n        aP.push_back(Point(x, y));\n    }\n    REP(i, nb){\n        double x, y;\n        cin >> x >> y;\n        bP.push_back(Point(x, y)); \n    }\n\n    Graph g(na);\n    REP(i, na){\n        for(int j = i + 1; j < na; j++){\n            Line b = Line((bP[0]), (bP[1]));\n            Line a = Line((aP[i]), (aP[j]));\n            if(!intersectSS(a, b)){\n                add_edge(g, i, j, dist(a));\n                add_edge(g, j, i, dist(a));\n            }\n        }\n    }\n    vector<Weight> di;\n    vi path;\n    shortestPath(g, 0, di, path);\n    Line b = Line((bP[0]), (bP[1]));\n    double l = dist(b) + di[1];\n\n    double ans = INF;\n\n    g.clear();\n    g.resize(nb);\n    REP(i, nb){\n        for(int j = i + 1; j < nb; j++){\n            Line b = Line((aP[0]), (aP[1]));\n            Line a = Line((bP[i]), (bP[j]));\n            if(!intersectSS(a, b)){\n                add_edge(g, i, j, dist(a));\n                add_edge(g, j, i, dist(a));\n            }\n        }\n    }\n    vector<Weight> dist2;\n    vi path2;\n    shortestPath(g, 0, dist2, path2);\n    Line a = Line((aP[0]), (aP[1]));\n    double r = dist(a) + dist2[1];\n\n\n    if(!intersectSS(a, b)){\n        printf(\"%.10lf\", dist(a) + dist(b));\n    }\n    else if(min(l, r) < INF - EPS){\n        printf(\"%.10lf\", min(l, r));\n    }\n    else cout << -1 << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double eps = 1e-8;\ndouble dot(P a, P b) { return real(conj(a) * b); }\ndouble cross(P a, P b) { return imag(conj(a) * b); }\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;\n    if (cross(b, c) < -eps) return -1;\n    if (dot(b, c) < -eps) return 2;\n    if (norm(c) > norm(b)) return -2;\n    return 0;\n}\nbool intersectSS(P p1, P p2, P p3, P p4) {\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nint n,m;long double ax[1000],ay[1000],bx[1000],by[1000],dist[1000];\nvector<pair<int,long double> >x[1000];\nlong double dijkstra(int s,int t){\n\tpriority_queue<pair<long double,int>,vector<pair<long double,int> >,greater<pair<long double,int> > >Q;\n\tQ.push(make_pair(0.0L,s));for(int i=0;i<1000;i++)dist[i]=1e9;dist[s]=0.0L;\n\twhile(!Q.empty()){\n\t\tlong double a1=Q.top().first;int a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<(int)x[a2].size();i++){\n\t\t\tif(dist[x[a2][i].first]>a1+x[a2][i].second){\n\t\t\t\tdist[x[a2][i].first]=a1+x[a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[x[a2][i].first],x[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[t];\n}\nint main(){\n\tcin>>n>>m;for(int i=0;i<n;i++)cin>>ax[i]>>ay[i];\n\tfor(int i=0;i<m;i++)cin>>bx[i]>>by[i];\n\tfor(int i=0;i<1000;i++)x[i].clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(intersectSS(P(ax[i],ay[i]),P(ax[j],ay[j]),P(bx[0],by[0]),P(bx[1],by[1]))==0){\n\t\t\t\tlong double dst1=sqrtl((ax[i]-ax[j])*(ax[i]-ax[j])+(ay[i]-ay[j])*(ay[i]-ay[j]));\n\t\t\t\tx[i].push_back(make_pair(j,dst1));\n\t\t\t\tx[j].push_back(make_pair(i,dst1));\n\t\t\t}\n\t\t}\n\t}\n\tlong double r1=dijkstra(0,1);\n\tfor(int i=0;i<1000;i++)x[i].clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(intersectSS(P(bx[i],by[i]),P(bx[j],by[j]),P(ax[0],ay[0]),P(ax[1],ay[1]))==0){\n\t\t\t\tlong double dst1=sqrtl((bx[i]-bx[j])*(bx[i]-bx[j])+(by[i]-by[j])*(by[i]-by[j]));\n\t\t\t\tx[i].push_back(make_pair(j,dst1));\n\t\t\t\tx[j].push_back(make_pair(i,dst1));\n\t\t\t}\n\t\t}\n\t}\n\tlong double r2=dijkstra(0,1);\n\tlong double r3=sqrtl((bx[0]-bx[1])*(bx[0]-bx[1])+(by[0]-by[1])*(by[0]-by[1]));\n\tlong double r4=sqrtl((ax[0]-ax[1])*(ax[0]-ax[1])+(ay[0]-ay[1])*(ay[0]-ay[1]));\n\tif(min(r1,r2)>=1e8)printf(\"-1\\n\");\n\telse printf(\"%.15Lf\\n\",min(r1+r3,r2+r4));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LT(x,y) ((x)-(y)<=-EPS)\n\ndouble dist(P a, P b) {\n\treturn abs(a-b);\n}\n\ndouble cross(P a, P b) {\n\treturn (a.real()*b.imag() - a.imag()*b.real());\n}\n\nbool is_point_on_ls(P a, P b, P c) {\n\treturn (abs(a-c)+abs(c-b) < abs(a-b)+EPS);\n}\n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n\tif((cross(a2-a1, b1-a1) * cross(a2-a1, b2-b1) < -EPS) &&\n\t   (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS))\n\t   return true;\n\treturn is_point_on_ls(a1, a2, b1) || is_point_on_ls(a1, a2, b2) ||\n\t\tis_point_on_ls(b1, b2, a1) || is_point_on_ls(b1, b2, a2);\n}\n\nstruct state {\n\tint p;\n\tdouble d;\n\tstate(int p, double d) : p(p), d(d) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.d<d;\n\t}\n};\n\nint main() {\n\tint NA, NB;\n\tcin >> NA >> NB;\n\n\tvp pa(NA), pb(NB);\n\tdouble x, y;\n\tREP(i, NA) {\n\t\tcin >> x >> y;\n\t\tpa[i] = P(x, y);\n\t}\n\tREP(i, NB) {\n\t\tcin >> x >> y;\n\t\tpb[i] = P(x, y);\n\t}\n\n\tdouble ans = INF;\n\tif(!is_intersected_ls(pa[0], pa[1], pb[0], pb[1])) {\n\t\tans = min(ans, dist(pa[0], pa[1])+dist(pb[0], pb[1]));\n\t} else {\n\t\tvvi tableA(NA, vi(0));\n\t\tdouble distb = dist(pb[0],pb[1]);\n\t\tREP(i, NA) {\n\t\t\tREP(j, NA) {\n\t\t\t\tif(i != j && !is_intersected_ls(pb[0], pb[1], pa[i], pa[j])) {\n\t\t\t\t\ttableA[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvd costA(NA, INF);\n\t\tcostA[0] = 0;\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(0, 0));\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(st.p == 1) {\n\t\t\t\tans = min(ans, st.d+distb);\n\t\t\t}\n\t\t\tint size = tableA[st.p].size();\n\t\t\tREP(i, size) {\n\t\t\t\tint np = tableA[st.p][i];\n\t\t\t\tdouble nd = st.d+dist(pa[st.p], pa[np]);\n\t\t\t\tif(LT(nd, costA[np])) {\n\t\t\t\t\tcostA[np] = nd;\n\t\t\t\t\tQ.push(state(np, nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvi tableB(NB, vi(0));\n\t\tdouble dista = dist(pa[0],pa[1]);\n\t\tREP(i, NB) {\n\t\t\tREP(j, NB) {\n\t\t\t\tif(i != j && !is_intersected_ls(pa[0], pa[1], pb[i], pb[j])) {\n\t\t\t\t\ttableB[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvd costB(NB, INF);\n\t\tcostB[0] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(st.p == 1) {\n\t\t\t\tans = min(ans, st.d+dista);\n\t\t\t}\n\t\t\tint size = tableB[st.p].size();\n\t\t\tREP(i, size) {\n\t\t\t\tint np = tableB[st.p][i];\n\t\t\t\tdouble nd = st.d+dist(pb[st.p], pb[np]);\n\t\t\t\tif(LT(nd, costB[np])) {\n\t\t\t\t\tcostB[np] = nd;\n\t\t\t\t\tQ.push(state(np, nd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tif(EQ(ans, INF)) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\ntypedef pair<point, point> line;\ntypedef pair<double, double> pii;\ntypedef struct edge{\n  int to;\n  double cost;\n}edge;\n\n//b??????a??????????????????\ndouble dis(point a, point b){\n  return abs(a - b);\n}\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\n\nbool is_cross(line a, line b){\n  if(ccw(a.first, a.second, b.first) *\n     ccw(a.first, a.second, b.second) <= 0 &&\n     ccw(b.first, b.second, a.first) *\n     ccw(b.first, b.second, a.second) <= 0){\n    return true;\n  }\n  return false;\n}\n\ndouble dijkstra(vector<point> &a, vector<point> &b){\n  line la = line(a[0], a[1]);\n  int n = b.size();\n  vector<edge> g[n];\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if(is_cross(la, line(b[i], b[j])))continue;\n      double d = dis(b[i], b[j]);\n      g[i].push_back((edge){j, d});\n      g[j].push_back((edge){i, d});\n    }\n  }\n  double dp[n];\n  priority_queue<pii, vector<pii>, greater<pii> > que;\n  for (int i = 0; i < n; i++) dp[i] = 1e9;\n  dp[0] = 0;\n  que.push(pii(0, 0));\n  while(not que.empty()){\n    double c = que.top().first;\n    int v = que.top().second;\n    que.pop();\n\n    for (int i = 0; i < g[v].size(); i++) {\n      double nc = c + g[v][i].cost;\n      int nv = g[v][i].to;\n      if(dp[nv] > nc){\n        dp[nv] = nc;\n        que.push(pii(nc, nv));\n      }\n    }\n  }\n  return dp[1] + dis(a[0], a[1]);\n}\n\nint main(){\n  int na, nb;\n  std::cin >> na >> nb;\n  vector<point> a(na), b(nb);\n  double x, y;\n  for (int i = 0; i < na; i++) {\n    std::cin >> x >> y;\n    a[i] = point(x, y);\n  }\n  for (int i = 0; i < nb; i++) {\n    std::cin >> x >> y;\n    b[i] = point(x, y);\n  }\n  double ans = 1e9;\n  ans = min(ans, dijkstra(a, b));\n  ans = min(ans, dijkstra(b, a));\n  if(ans != 1e9)printf(\"%.12lf\\n\", ans);\n  else std::cout << -1 << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <functional>\n#include <queue>\n#include <complex>\nusing namespace std;\n\n\ntypedef double W;\n\nconst double EPoS = 1e-8;\nconst W INF = 1e10;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> P;\ntypedef vector<vector <edge > > Graph;\n\nvoid dijkstra(int s, const Graph G, vector<W>& d) {\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\ntypedef complex<double> Po;\nnamespace std {\n\tbool operator < (const Po& a, const Po& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const Po& a, const Po& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const Po& a, const Po& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<Po> {\n\tL(const Po &a, const Po &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(Po a, Po b, Po c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;       // counter clockwise\n\tif(cross(b, c) < 0)   return -1;       // clockwise\n\tif(dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif(norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint na, nb;\n\tcin >> na >> nb;\n\n\tvector<Po> ps[2];\n\tfor(int i = 0; i < na; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tps[0].push_back(Po(x, y));\n\t}\n\tfor(int i = 0; i < nb; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tps[1].push_back(Po(x, y));\n\t}\n\n\tdouble ans = INF;\n\tfor(int loop = 0; loop < 2; loop++) {\n\t\tGraph G(na);\n\t\tdouble sum = 0;\n\t\tsum += abs(ps[1][0] - ps[1][1]);\n\t\tL line(ps[1][0], ps[1][1]);\n\n\t\tfor(int i = 0; i < na; i++) {\n\t\t\tfor(int j = i + 1; j < na; j++) {\n\t\t\t\tL l1(ps[0][i], ps[0][j]);\n\t\t\t\tif(intersectSS(line, l1)) continue;\n\t\t\t\tG[i].push_back(edge{ j, abs(ps[0][i] - ps[0][j]) });\n\t\t\t\tG[j].push_back(edge{ i, abs(ps[0][i] - ps[0][j]) });\n\t\t\t}\n\t\t}\n\n\t\tvector<W> d(na);\n\t\tdijkstra(0, G, d);\n\t\tsum += d[1];\n\t\tans = min(ans, sum);\n\t\tswap(na, nb);\n\t\tswap(ps[0], ps[1]);\n\t}\n\tcout << setprecision(15) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n\n#define f first\n#define s second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef pair<double,double>pii;\n\ndouble dist(pii a,pii b){\n  return sqrt(pow(a.f-b.f,2)+pow(a.s-b.s,2));\n}\n\nint main(void){\n  \n  int na,nb;\n  cin >> na >> nb;\n  \n  vector<pii>a(na),b(nb);\n  \n  for(int i=0;i<na;i++)cin >> a[i].f >> a[i].s;\n  for(int i=0;i<nb;i++)cin >> b[i].f >> b[i].s;\n  \n  double ans=INF,D;\n  D=min(dist(a[0],b[0])+dist(b[0],a[1]),dist(a[0],b[1]),dist(b[1],a[1]));\n  for(int i=2;i<na;i++){\n    double d=dist(a[0],a[i])+dist(a[i],a[1]);\n    if(d<D)ans=min(ans,d+dist(b[0],b[1]));\n  }\n\n  D=min(dist(b[0],a[0])+dist(a[0],b[1]),dist(b[0],a[1]),dist(a[1],b[1]));\n  for(int i=2;i<nb;i++){\n    double d=dist(b[0],b[i])+dist(b[i],b[1]);\n    if(d<D)ans=min(ans,d+dist(a[0],a[1]));\n  }\n  \n  printf(\"%.9f\",ans);\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    double dist(const Point& p) const{\n        return sqrt((double)(y - p.y) * (y - p.y) + (x - p.x) * (x - p.x));\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    int cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) <= 0) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) <= 0);\n}\n\nclass Edge\n{\npublic:\n    int to;\n    double cost;\n    Edge(){};\n    Edge(int to0, double cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<double>& dist)\n{\n    const double EPS = 1.0e-10;\n\n    dist.assign(edges.size(), DBL_MAX);\n    dist[start] = 0.0;\n    priority_queue<pair<double,int> ,vector<pair<double,int> >, greater<pair<double,int> > > q;\n    q.push(make_pair(0.0, start));\n\n    while(!q.empty()){\n        pair<double, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first - EPS)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost + EPS < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n[2];\n    cin >> n[0] >> n[1];\n\n    vector<vector<Point> > p(2);\n\n    for(int i=0; i<2; ++i){\n        p[i].resize(n[i]);\n        for(int j=0; j<n[i]; ++j){\n            cin >> p[i][j].x >> p[i][j].y;\n        }\n    }\n\n    double ret = DBL_MAX;\n    vector<vector<vector<Edge> > > edges(2);\n    for(int i=0; i<2; ++i){\n        vector<vector<Edge> > edges(n[i]);\n        Point p1 = p[i^1][0];\n        Point p2 = p[i^1][1];\n        for(int j=0; j<n[i]; ++j){\n            for(int k=0; k<n[i]; ++k){\n                if(!segmentsCollide(p1, p2, p[i][j], p[i][k])){\n                    edges[j].push_back(Edge(k, p[i][j].dist(p[i][k])));\n                }\n            }\n        }\n\n        vector<double> dist;\n        shortestPath(edges, 1, dist);\n\n        ret = min(ret, p1.dist(p2) + dist[0]);\n    }\n\n    if(ret > DBL_MAX/2)\n        cout << -1 << endl;\n    else\n        printf(\"%.10f\\n\", ret);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\npair<Point,Point> getCrossPointCL(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPointCC(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\n\nsigned main(){\n  int na,nb;\n  cin>>na>>nb;\n  Polygon a(na),b(nb);\n  for(int i=0;i<na;i++) cin>>a[i];\n  for(int i=0;i<nb;i++) cin>>b[i];\n  if(!intersectSS(a[0],a[1],b[0],b[1])){\n    printf(\"%.12f\\n\",abs(a[0]-a[1])+abs(b[0]-b[1]));\n    return 0;\n  }\n  double INF=1e20;\n  double ans=INF;\n  double dp[1111];\n  int used[1111];\n  for(int i=0;i<1111;i++) dp[i]=INF;\n  memset(used,0,sizeof(used));\n  dp[0]=0;\n  for(int i=0;i<nb;i++){\n    int u=-1;\n    for(int j=0;j<nb;j++){\n      if(used[j]) continue;\n      if(u<0||dp[j]<dp[u]) u=j;\n    }\n    if(u<0) break;\n    used[u]=1;\n    for(int j=0;j<nb;j++){\n      if(used[j]) continue;\n      if(intersectSS(a[0],a[1],b[u],b[j])) continue;\n      dp[j]=min(dp[j],dp[u]+abs(b[u]-b[j]));\n    }\n  }\n  ans=min(ans,dp[1]+abs(a[0]-a[1]));\n  for(int i=0;i<1111;i++) dp[i]=INF;\n  memset(used,0,sizeof(used));\n  dp[0]=0;\n  for(int i=0;i<na;i++){\n    int u=-1;\n    for(int j=0;j<na;j++){\n      if(used[j]) continue;\n      if(u<0||dp[j]<dp[u]) u=j;\n    }\n    if(u<0) break;\n    //cout<<u<<\" \"<<dp[u]<<endl;\n    used[u]=1;\n    for(int j=0;j<na;j++){\n      if(used[j]) continue;\n      if(intersectSS(b[0],b[1],a[u],a[j])) continue;\n      dp[j]=min(dp[j],dp[u]+abs(a[u]-a[j]));\n    }\n  }\n  ans=min(ans,dp[1]+abs(b[0]-b[1]));\n  if(ans>=INF) cout<<-1<<endl;\n  else printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef double Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return abs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tdouble d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tdouble d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tdouble d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tdouble len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\n\n/*--------------------template--------------------*/\nvoid dijkstra(Graph &g, vector<Weight> &d, int s)\n{\n\td.assign(g.size(), INF);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint na, nb;\n\tcin >> na >> nb;\n\tvector<Point> pa, pb;\n\tREP(i, na)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpa.emplace_back(x, y);\n\t}\n\tREP(i, nb)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpb.emplace_back(x, y);\n\t}\n\tdouble ans = INF;\n\tLine la(pa[0], pa[1]);\n\tLine lb(pb[0], pb[1]);\n\tGraph g(pa.size());\n\tREP(i, pa.size())REP(j, pa.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(lb, Line(pa[i], pa[j]))) continue;\n\t\tdouble d = abs(pa[i] - pa[j]);\n\t\tadd_edge(g, i, j, d);\n\t\tadd_edge(g, j, i, d);\n\t}\n\tvector<Weight> da, db;\n\tdijkstra(g, da, 0);\n\tg.clear();\n\tg.resize(pb.size());\n\tREP(i, pb.size())REP(j, pb.size())\n\t{\n\t\tif (i == j) continue;\n\t\tif (isis_ss(la, Line(pb[i], pb[j]))) continue;\n\t\tdouble d = abs(pb[i] - pb[j]);\n\t\tadd_edge(g, i, j, d);\n\t\tadd_edge(g, j, i, d);\n\t}\n\tdijkstra(g, db, 0);\n\tchmin(ans, db[1] + abs(la.a - la.b));\n\tchmin(ans, da[1] + abs(lb.a - lb.b));\n\tif (ans >= INF) cout << -1 << endl;\n\telse cout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 0\n\nclass D3 {\npublic:\n\tlong double X, Y, Z, EPS;\n\n\tD3( long double, long double, long double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( long double );\n\tD3 operator*( long double );\n\tD3 operator/( long double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3 {\npublic:\n\tPoint( long double, long double, long double );\n\tlong double getX();\n\tlong double getY();\n\tlong double getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tlong double S_point( Point, Point );\n\tlong double V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec {\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( long double x_, long double y_, long double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( long double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( long double );\n\tbool operator== ( Vec );\n\tbool operator==( long double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tlong double length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tlong double S_vec( Vec );\n\tlong double V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( long double ld ) {\n\treturn ( *this ) == D3();\n}\n\nD3 D3::operator*( long double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( long double ld ) {\n\treturn  *this*( ld*-1.L );\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\nlong double Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\nlong double Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\nlong double Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( ( *this ).getX() != Partner.getX() ) {\n\t\treturn ( *this ).getX() < Partner.getX();\n\t}\n\tif( ( *this ).getY() != Partner.getY() ) {\n\t\treturn ( *this ).getY() < Partner.getY();\n\t}\n\treturn ( *this ).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < ( *this );\n}\n//??????????????¢???????±???????\nlong double Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\nlong double Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( ( *this ), B ).V_vec( Vec( ( *this ), C ), Vec( ( *this ), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( long double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + ( Partner*( -1.L ) );\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( long double ld ) {\n\treturn *this*( 1.L / ld );\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( long double ) {\n\treturn ( *this ) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\nlong double Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / ( *this ).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn ( *this )*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( ( *this ).Inverse_vec().getD(), ( *this ).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn ( *this ).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn ( *this ).Unit_vec().getD() == Partner.Unit_vec().getD() || ( *this ).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) );\n\tVec Q = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getSP() ) );\n\tVec R = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getGP() ) );\n\treturn ( !( *this ).Parallel( Partner ) ) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS ) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS );\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( ( *this ).isIntersection( Partner ) ) {\n\t\tlong double d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) ).D.Z );\n\t\tlong double d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) ).D.Z );\n\t\tlong double t = d1 / ( d1 + d2 );\n\t\treturn Vec( ( ( *this )*t ).getD(), ( *this ).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( ( *this ).getSP(), A );\n\tif( A == ( ( *this ).getSP() ) || ( Test.Parallel( *this ) && ( *this ).getD().X / Test.getD().X >= 1.0L ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\nlong double Vec::S_vec( Vec B ) {\n\tif( ( ( *this ).getSP() == B.getSP() ) ) {\n\t\tVec G = ( *this ).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( ( *this ).getGP() == B.getSP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B );\n\t}\n\tif( ( *this ).getSP() == B.getGP() ) {\n\t\treturn ( *this ).S_vec( B.Reverse_vec() );\n\t}\n\tif( ( *this ).getGP() == B.getGP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\nlong double Vec::V_vec( Vec B, Vec C ) {\n\tVec G = ( *this ).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points {\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance {\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n\n\nvector<vector<pair<long long int, long double>>>makelist( vector<Point>&townlist, Vec DisallowVec ) {\n\tvector<vector<pair<long long int, long double>>>ret( townlist.size() );\n\tfor( size_t i = 0; i < townlist.size(); i++ ) {\n\t\tfor( size_t j = i + 1; j < townlist.size(); j++ ) {\n\t\t\tVec now = Vec( townlist[i], townlist[j] );\n\t\t\tif( !now.isIntersection( DisallowVec ) ) {\n\t\t\t\tret[i].push_back( make_pair( j, now.length() ) );\n\t\t\t\tret[j].push_back( make_pair( i, now.length() ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\ndouble dijkstra( vector<vector<pair<long long int, long double>>>  listLen ) {\n\tvector<long double>ret( listLen.size(), DBL_MAX / 10 );\n\tpriority_queue<pair< double, long long int>, vector<pair<double, long long int>>, greater<pair<double, long long int>>>que;\n\tque.push( make_pair( 0, 0 ) );\n\tret[0] = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( now.second == 1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif( now.first != ret[now.second] ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( auto next : listLen[now.second] ) {\n\t\t\tif( ret[next.first] > now.first + next.second ) {\n\t\t\t\tret[next.first] = now.first + next.second;\n\t\t\t\tif( ret[next.first] < ret[1] ) {\n\t\t\t\t\tque.push( make_pair( now.first + next.second, next.first ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret[1];\n}\n\n\nint main() {\n\tlong long int NA, NB;\n\tcin >> NA >> NB;\n\tvector<Point>townA( NA ), townB( NB );\n\tfor( size_t i = 0; i < NA; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownA[i] = Point( x, y );\n\t}\n\tfor( size_t i = 0; i < NB; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownB[i] = Point( x, y );\n\t}\n\n\tauto listA = makelist( townA, Vec( townB[0], townB[1] ) );\n\tauto listB = makelist( townB, Vec( townA[0], townA[1] ) );\n\n\tlong double lenA = dijkstra( listA );\n\tlong double lenB = dijkstra( listB );\n\n\tif( lenA == DBL_MAX / 10 && lenB == DBL_MAX / 10 ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << fixed << setprecision( 20 ) << min( lenA + Vec( townB[0], townB[1] ).length(), lenB + Vec( townA[0], townA[1] ).length() ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#define EPS 1e-10\n#define INF 1e12\nusing namespace std;\ntypedef pair<double,int> P;\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(double xx=0.0,double yy=0.0){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tPoint operator + (Point a){\n\t\treturn Point(add(x,a.x),add(y,a.y));\n\t}\n\tPoint operator - (Point a){\n\t\treturn Point(add(x,-a.x),add(y,-a.y));\n\t}\n\tPoint operator * (double d){\n\t\treturn Point(x*d,y*d);\n\t}\n\tPoint operator / (double d){\n\t\treturn Point(x/d,y/d);\n\t}\n};\ntypedef Point Vector;\n\ndouble norm(Vector a){\n\treturn add(a.x*a.x,a.y*a.y);\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n\treturn add(a.x*b.x,a.y*b.y);\n}\n\ndouble cross(Vector a,Vector b){\n\treturn add(a.x*b.y,-a.y*b.x);\n}\n\nbool on_seg(Point p1,Point p2,Point q){\n\treturn cross(p1-q,p2-q)==0 && dot(p1-q,p2-q)<=0;\n}\n\nPoint intersection(Point p1,Point p2,Point q1,Point q2){\n\treturn p1+(p2-p1)*(cross(q2-q1,q1-p1)/cross(q2-q1,p2-p1));\n}\n\nbool intersect(Point p1,Point p2,Point q1,Point q2){\n\tif(cross(p1-p2,q1-q2)==0){\n\t\treturn on_seg(p1,p2,q1) || on_seg(p1,p2,q2) || on_seg(q1,q2,p1) || on_seg(q1,q2,p2);\n\t}else{\n\t\tPoint r=intersection(p1,p2,q1,q2);\n\t\treturn on_seg(p1,p2,r) && on_seg(q1,q2,r);\n\t}\n}\n\nint na,nb;\nPoint a[1001],b[1001];\ndouble dist[1001];\n\ndouble dijk(){\n\tdouble res=INF;\n\tfor(int i=0;i<na;i++){\n\t\tdist[i]=INF;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0.0,0));\n\tdist[0]=0.0;\n\twhile(que.size()){\n\t\tP q=que.top();\n\t\tque.pop();\n\t\tint v=q.second;\n\t\tif(dist[v]<q.first)continue;\n\t\tfor(int i=0;i<na;i++){\n\t\t\tdouble cost=abs(a[i]-a[v]);\n\t\t\tif(cost+dist[v]<dist[i] && !intersect(b[0],b[1],a[i],a[v])){\n\t\t\t\tdist[i]=cost+dist[v];\n\t\t\t\tque.push(P(dist[i],i));\n\t\t\t}\n\t\t}\n\t}\n\tres=dist[1]+abs(b[1]-b[0]);\n\n\tfor(int i=0;i<nb;i++){\n\t\tdist[i]=INF;\n\t}\n\tque.push(P(0.0,0));\n\tdist[0]=0.0;\n\twhile(que.size()){\n\t\tP q=que.top();\n\t\tque.pop();\n\t\tint v=q.second;\n\t\tif(dist[v]<q.first)continue;\n\t\tfor(int i=0;i<nb;i++){\n\t\t\tdouble cost=abs(b[i]-b[v]);\n\t\t\tif(cost+dist[v]<dist[i] && !intersect(a[0],a[1],b[i],b[v])){\n\t\t\t\tdist[i]=cost+dist[v];\n\t\t\t\tque.push(P(dist[i],i));\n\t\t\t}\n\t\t}\n\t}\n\tres=min(res,dist[1]+abs(a[1]-a[0]));\n\treturn res+EPS<INF?res:-1;\n}\n\n\nint main(void){\n\tscanf(\"%d %d\",&na,&nb);\n\tfor(int i=0;i<na;i++){\n\t\tscanf(\"%lf %lf\",&a[i].x,&a[i].y);\n\t}\n\tfor(int i=0;i<nb;i++){\n\t\tscanf(\"%lf %lf\",&b[i].x,&b[i].y);\n\t}\n\n\tif(intersect(a[0],a[1],b[0],b[1]))printf(\"%.20f\\n\",dijk());\n\telse printf(\"%.20f\\n\",abs(a[1]-a[0])+abs(b[1]-b[0]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 1\n\nclass D3 {\npublic:\n\tlong double X, Y, Z, EPS;\n\n\tD3( long double, long double, long double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( long double );\n\tD3 operator*( long double );\n\tD3 operator/( long double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3 {\npublic:\n\tPoint( long double, long double, long double );\n\tlong double getX();\n\tlong double getY();\n\tlong double getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tlong double S_point( Point, Point );\n\tlong double V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec {\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( long double x_, long double y_, long double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( long double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( long double );\n\tbool operator== ( Vec );\n\tbool operator==( long double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tlong double length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tlong double S_vec( Vec );\n\tlong double V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( long double ld ) {\n\treturn ( *this ) == D3();\n}\n\nD3 D3::operator*( long double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( long double ld ) {\n\treturn  *this*( ld*-1.L );\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\nlong double Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\nlong double Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\nlong double Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( ( *this ).getX() != Partner.getX() ) {\n\t\treturn ( *this ).getX() < Partner.getX();\n\t}\n\tif( ( *this ).getY() != Partner.getY() ) {\n\t\treturn ( *this ).getY() < Partner.getY();\n\t}\n\treturn ( *this ).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < ( *this );\n}\n//??????????????¢???????±???????\nlong double Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\nlong double Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( ( *this ), B ).V_vec( Vec( ( *this ), C ), Vec( ( *this ), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( long double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + ( Partner*( -1.L ) );\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( long double ld ) {\n\treturn *this*( 1.L / ld );\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( long double ) {\n\treturn ( *this ) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\nlong double Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / ( *this ).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn ( *this )*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( ( *this ).Inverse_vec().getD(), ( *this ).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn ( *this ).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn ( *this ).Unit_vec().getD() == Partner.Unit_vec().getD() || ( *this ).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) );\n\tVec Q = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getSP() ) );\n\tVec R = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getGP() ) );\n\treturn ( !( *this ).Parallel( Partner ) ) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS ) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS );\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( ( *this ).isIntersection( Partner ) ) {\n\t\tlong double d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) ).D.Z );\n\t\tlong double d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) ).D.Z );\n\t\tlong double t = d1 / ( d1 + d2 );\n\t\treturn Vec( ( ( *this )*t ).getD(), ( *this ).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( ( *this ).getSP(), A );\n\tif( A == ( ( *this ).getSP() ) || ( Test.Parallel( *this ) && ( *this ).getD().X / Test.getD().X >= 1.0L ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\nlong double Vec::S_vec( Vec B ) {\n\tif( ( ( *this ).getSP() == B.getSP() ) ) {\n\t\tVec G = ( *this ).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( ( *this ).getGP() == B.getSP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B );\n\t}\n\tif( ( *this ).getSP() == B.getGP() ) {\n\t\treturn ( *this ).S_vec( B.Reverse_vec() );\n\t}\n\tif( ( *this ).getGP() == B.getGP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\nlong double Vec::V_vec( Vec B, Vec C ) {\n\tVec G = ( *this ).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points {\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance {\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n\n\nvector<vector<pair<long long int, long double>>>makelist( vector<Point>townlist, Vec DisallowVec ) {\n\tvector<vector<pair<long long int, long double>>>ret( townlist.size() );\n\tfor( size_t i = 0; i < townlist.size(); i++ ) {\n\t\tfor( size_t j = i + 1; j < townlist.size(); j++ ) {\n\t\t\tVec now = Vec( townlist[i], townlist[j] );\n\t\t\tif( !now.isIntersection( DisallowVec ) ) {\n\t\t\t\tret[i].push_back( make_pair( j, now.length() ) );\n\t\t\t\tret[j].push_back( make_pair( i, now.length() ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nlong double dijkstra( vector<vector<pair<long long int, long double>>>  listLen ) {\n\tvector<long double>ret( listLen.size(), LDBL_MAX / 10 );\n\tpriority_queue<pair<long double, long long int>, vector<pair<long double, long long int>>, greater<pair<long double, long long int>>>que;\n\tque.push( make_pair( 0, 0 ) );\n\tret[0] = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( now.first != ret[now.second] ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( auto next : listLen[now.second] ) {\n\t\t\tif( ret[next.first] > now.first + next.second ) {\n\t\t\t\tret[next.first] = now.first + next.second;\n\t\t\t\tque.push( make_pair( now.first + next.second, next.first ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn ret[1];\n}\n\n\nint main() {\n\tlong long int NA, NB;\n\tcin >> NA >> NB;\n\tvector<Point>townA( NA ), townB( NB );\n\tfor( size_t i = 0; i < NA; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownA[i] = Point( x, y );\n\t}\n\tfor( size_t i = 0; i < NB; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownB[i] = Point( x, y );\n\t}\n\n\tauto listA = makelist( townA, Vec( townB[0], townB[1] ) );\n\tauto listB = makelist( townB, Vec( townA[0], townA[1] ) );\n\n\tlong double lenA = dijkstra( listA );\n\tlong double lenB = dijkstra( listB );\n\n\tif( lenA == LDBL_MAX / 10 && lenB == LDBL_MAX / 10 ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << fixed << setprecision( 20 ) << min( lenA + Vec( townB[0], townB[1] ).length(), lenB + Vec( townA[0], townA[1] ).length() ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) begin(V), end(V)\n#define ALLR(V) rbegin(V), rend(V)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst double eps = 1e-6;\nconst long double pi = 3.14159265358979323846264338327950288419716939937510L;\n\nusing Point = complex<double>;\n\nstruct DualPoints : public pair<Point, Point> {\n    using pair<Point, Point>::pair;\n\n    Point& operator [](size_t idx) { return idx == 0 ? first : second; }\n    \n    const Point& operator [](size_t idx) const { return idx == 0 ? first : second; }\n};\n\nstruct get_xy {\n    double &x, &y;\n\n    get_xy(double &x, double &y) : x(x), y(y) { }\n\n    get_xy& operator =(const Point &p) {\n        x = real(p);\n        y = imag(p);\n        return *this;\n    }\n};\n\nstruct Line : public DualPoints {\n    using DualPoints::DualPoints;\n};\n\nstruct Seg : public DualPoints {\n    using DualPoints::DualPoints;\n};\n\ndouble dot(const Point &a, const Point &b) {\n    return (conj(a) * b).real();\n}\n\ndouble cross(const Point &a, const Point &b) {\n    return (conj(a) * b).imag();\n}\n\nenum ccwd {\n    Clock = -1,\n    CoClock = 1,\n    CAB = 2,\n    ABC = -2,\n    ACB = 0,\n};\n\nccwd ccw(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    double p, q;\n    {\n        auto tmp = conj(b) * c;\n        p = tmp.real();\n        q = tmp.imag();\n    }\n    if (0 < q) return CoClock;\n    if (q < 0) return Clock;\n    if (p < 0) return CAB;\n    if (norm(b) < norm(c)) return ABC;\n    return ACB;\n}\n\nbool is_zero(double a) {\n    return abs(a) <= eps;\n}\n\nbool is_parallel(const Line &l1, const Line &l2) {\n    return is_zero(cross(l1[1] - l1[0], l2[1] - l2[0]));\n}\n\nbool is_same_line(Point o, Point a, Point b) {\n    return is_zero(cross(a - o, b - o));\n}\n\nbool intersect(const Line &p, const Line &q) {\n    if (!is_parallel(p, q)) return true;\n    return is_same_line(p[0], p[1], q[1]);\n}\n\nbool intersect(const Line &l, const Seg &s) {\n    double a = cross(l[1] - l[0], s[0] - l[0]);\n    double b = cross(l[1] - l[0], s[1] - l[0]);\n    return a * b < 0;\n}\n\nbool intersect(const Seg &p, const Seg &q) {\n    bool pf = (ccw(p[0], p[1], q[0]) * ccw(p[0], p[1], q[1])) <= 0;\n    bool qf = (ccw(q[0], q[1], p[0]) * ccw(q[0], q[1], p[1])) <= 0;\n    return pf && qf;\n}\n\nbool intersect(const Line &l, const Point &p) {\n    return is_same_line(p, l[0], l[1]);\n}\n\nbool intersect(const Seg &s, const Point &p) {\n    double l1 = abs(s[0] - s[1]);\n    double l2 = abs(s[0] - p);\n    double l3 = abs(s[1] - p);\n    return is_zero(l2 + l3 - l1);\n}\n\n// projection from p to l\nPoint proj(const Line &l, const Point &p) {\n    double mul = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);  // cos(theta) / (p-l[0]).norm()\n    return l[0] + mul * (l[1] - l[0]);\n}\n\nPoint refl(const Line &l, const Point &p) {\n    Point pr = proj(l, p);\n    return p + (2. * (pr - p));\n}\n\ndouble distance(const Line &l, const Point &p) {\n    return abs(p - proj(l, p));\n}\n\ndouble distance(const Line &p, const Line &q) {\n    if (is_parallel(p, q)) return distance(p, q[0]);\n    return 0;\n}\n\ndouble distance(const Line &l, const Seg &s) {\n    if (intersect(l, s)) return 0;\n    return min(distance(l, s[0]), distance(l, s[1]));\n}\n\ndouble distance(const Seg &s, const Point &p) {\n    Line l(s[0], s[1]);\n    Point pr = proj(l, p);\n    if (intersect(s, pr)) return abs(pr - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distance(const Seg &p, const Seg &q) {\n    if (intersect(p, q)) return 0;\n    return var_min(distance(p, q[0]), distance(p, q[1]),\n                   distance(q, p[0]), distance(q, p[1]));\n}\n\ndouble fix_arg(double arg) {\n    arg += 2 * pi;\n    if (2 * pi <= arg) arg -= 2 * pi;\n    return arg;\n}\n\nbool comp_coclock(const Point &p1, const Point &p2) {\n    return fix_arg(arg(p1)) < fix_arg(arg(p2));\n}\n\nPoint rotate(const Point &p, double arg) {\n    complex<double> r(cos(arg), sin(arg));\n    return p * r;\n}\n\nconst double inf = 5e15;\nusing DN = pair<double, int>;\n\ndouble distance(const Point &a, const Point &b) {\n    return sqrt(norm(a - b));\n}\n\ndouble solve(const V<Point> &va, const V<Point> &vb) {\n    double ret = distance(va[0], va[1]);\n    Seg line(va[0], va[1]);\n\n    auto is_cross = [&](int i, int j) {\n        Seg s(vb[i], vb[j]);\n        return intersect(line, s);\n    };\n\n    V<double> dists(vb.size(), inf);\n    dists[0] = 0;\n    priority_queue<DN, V<DN>, greater<DN>> pq;\n    pq.emplace(0, 0);\n    while (pq.size()) {\n        double d;\n        int n;\n        tie(d, n) = pq.top();\n        pq.pop();\n        if (dists[n] < d) continue;\n        for (int nxt = 0; nxt < vb.size(); nxt++) {\n            if (nxt == n) continue;\n            if (is_cross(n, nxt)) continue;\n            double c = distance(vb[n], vb[nxt]);\n            double nd = d + c;\n            if (dists[nxt] <= nd) continue;\n            dists[nxt] = nd;\n            pq.emplace(nd, nxt);\n        }\n    }\n\n    if (dists[1] == inf) return inf;\n    else return ret + dists[1];\n}\n\nvoid input(V<Point> &v) {\n    for (auto &&e : v) {\n        double x, y;\n        cin >> x >> y;\n        e = Point(x, y);\n    }\n}\n\nint main() {\n    ll na, nb;\n    cin >> na >> nb;\n    V<Point> va(na), vb(nb);\n    input(va);\n    input(vb);\n    double ans = min(solve(va, vb), solve(vb, va));\n    (ans == inf ? (cout << -1) : (cout << ans)) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\n\nint NA, NB;\nvector<Point> ps[2];\n\nenum Geometry {ABC=-2, CW, ACB, CCW, CAB, ON_LINE, OUTSIDE, INSIDE, ERROR};\n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometry ccw(Point a, Point b, Point c) {\n  a -= b;\n  c -= b;\n  if (cross(a, c) > EPS) return CCW; // ccw\n  if (cross(a, c) < -EPS) return CW; // cw\n  if (dot(a, c) < -EPS) return ABC; // a - b - c\n\n  double al = abs(a);\n  double cl = abs(c);\n  if (EQ(al, cl)) return ERROR; // a and c are duplicate\n  if (EQ(min(al, cl), 0)) return ERROR;\n  if (al < cl) return CAB; // c - a - b\n  else return ACB; // a - c - b\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectSS(Line s, Line t) {\n  // hard coding: CW := -1, CCW := 1 -> only CW*CW and CCW*CCW are equal to 1\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) == 1) return false;\n  swap(s, t);\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) == 1) return false;\n  if (!IsParallel(s, t)) return true;\n  if (max(s[0], s[1]) < min(t[0], t[1])) return false;\n  swap(s, t);\n  if (max(s[0], s[1]) < min(t[0], t[1])) return false;\n  return true;\n}\n\ndouble Calc(vector<Point> &ps, vector<Point> &qs) {\n  vector<double> mind(ps.size(), INF);\n  vector<bool> used(ps.size());\n  double ret = abs(qs[0]-qs[1]);\n  mind[0] = 0;\n  while (1) {\n    int u = -1;\n    for (int i=0; i<ps.size(); i++) {\n      if (used[i]) continue;\n      if (mind[i] == INF) continue;\n      if (u == -1 || mind[i] < mind[u]) u = i;\n    }\n    if (u == -1) break;\n    used[u] = true;\n\n    for (int v=0; v<ps.size(); v++) {\n      if (IntersectSS(Line{ps[u], ps[v]}, Line{qs[0], qs[1]})) continue;\n\n      double t = mind[u] + abs(ps[u]-ps[v]);\n      if (mind[v] > t) mind[v] = t;\n    }\n  }\n\n  return ret+mind[1];\n}\n\nint main() {\n  scanf(\"%d%d\", &NA, &NB);\n  for (int i=0; i<NA; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    ps[0].emplace_back(Point(x, y));\n  }\n\n  for (int i=0; i<NB; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    ps[1].emplace_back(Point(x, y));\n  }\n\n  double ans = Calc(ps[0], ps[1]);\n  ans = min(ans, Calc(ps[1], ps[0]));\n  if (ans == INF) puts(\"-1\");\n  else printf(\"%.10f\\n\", ans);\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = double;\nconstexpr R pi = acos((R)-1), eps = 1e-10, inf = 1e10;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  V<P> p(n); for (auto&& e : p) cin >> e;\n  V<P> q(m); for (auto&& e : q) cin >> e;\n  R res = inf;\n  auto fn = [&]() -> void {\n    L s{q[0], q[1]};\n    VV<R> g(n, V<R>(n, inf));\n    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) if (sgn(distSS({p[i], p[j]}, s))) {\n      g[i][j] = distPP(p[i], p[j]);\n    }\n    bitset<1000> bs;\n    V<R> d(n, inf);\n    d[0] = 0;\n    for (int _ = 0; _ < n; ++_) {\n      int v = -1;\n      for (int w = 0; w < n; ++w) if (!bs[w]) {\n        if (v == -1 or d[w] < d[v]) v = w;\n      }\n      bs[v] = true;\n      for (int w = 0; w < n; ++w) {\n        d[w] = min(d[w], d[v] + g[v][w]);\n      }\n    }\n    res = min(res, d[1] + s.abs());\n  };\n  fn();\n  swap(n, m), swap(p, q);\n  fn();\n  if (res == inf) cout << -1 << '\\n';\n  else cout << fixed << setprecision(15) << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n// geometry library from hos\n\nconst double PI = acos(-1);\n\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\nstruct Pt{\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\n\nostream &operator<<(ostream &os, const Pt &a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\n\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\n\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s; // +1 or -1\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nbool iLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) <= 0);\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nbool iSSstrict(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) < 0 && sig(tri(c, d, a)) * sig(tri(c, d, b)) < 0);\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) { // intersection\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\ndouble dSP(Pt a, Pt b, Pt c) {\n\tif (sig((b - a).dot(c - a)) <= 0) return (c - a).abs();\n\tif (sig((a - b).dot(c - b)) <= 0) return (c - b).abs();\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\ndouble dLL(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLL(a, b, c, d) ? 0 : dLP(a, b, c);\n}\ndouble dLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLS(a, b, c, d) ? 0 : min(dLP(a, b, c), dLP(a, b, d));\n}\ndouble dSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iSS(a, b, c, d) ? 0 : min(min(dSP(a, b, c), dSP(a, b, d)), min(dSP(c, d, a), dSP(c, d, b)));\n}\n\nint iCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tif (sig(d) == 0 && sig(r - s) == 0) return -1; // correspond\n\tif (sig(r - s - d) > 0) return +2; // r > s\n\tif (sig(s - r - d) > 0) return -2; // s > r\n\treturn (sig(r + s - d) >= 0) ? 1 : 0;\n}\nbool iCS(Pt a, double r, Pt b, Pt c) {\n\treturn (sig(r - dSP(b, c, a)) >= 0 && sig(r - max((b - a).abs(), (c - a).abs())) <= 0);\n}\npair<Pt,Pt> pCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tPt e = (b - a) / d, w = e * Pt(0, 1) * sqrt(max(r * r - x * x, 0.0));\n\treturn mp(a + e * x - w, a + e * x + w);\n}\npair<Pt,Pt> pCL(Pt a, double r, Pt b, Pt c) {\n\tPt h = b + (c - b) * (c - b).dot(a - b) / (c - b).abs2();\n\t// perp(b, c, a)\n\tdouble d = (h - a).abs();\n\tdouble y = sqrt(max(r * r - d * d, 0.0));\n\tPt e = (c - b) / (c - b).abs();\n\treturn mp(h - e * y, h + e * y);\n}\npair<Pt,Pt> tCP(Pt a, double r, Pt b) {\n\tdouble d2 = (b - a).abs2();\n\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\tPt h = a + (b - a) * (r * r / d2);\n\tPt w = (b - a) * Pt(0, 1) * (x * r / d2);\n\treturn mp(h - w, h + w);\n}\ndouble aCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (a - b).abs();\n\tif (sig(r - s - d) >= 0) return s * s * PI;\n\tif (sig(s - r - d) >= 0) return r * r * PI;\n\tif (sig(r + s - d) <= 0) return 0;\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tdouble h = sqrt(r * r - x * x);\n\treturn r * r * atan2(h, x) + s * s * atan2(h, d - x) - d * h;\n}\n\n// end of library\n\nint NA,NB;\nPt PA[1010],PB[1010];\n\ntypedef pair<double,int> pdi;\n\ndouble solve(int N,Pt* P,Pt C,Pt D){\n\tpriority_queue<pdi,vector<pdi>,greater<pdi>> Q;\n\tQ.push(mp(0,0));\n\tdouble d[1010];\n\trep(i,N)d[i]=i==0?0:INF;\n\twhile(sz(Q)){\n\t\tpdi p=Q.top();Q.pop();\n\t\tdouble dist=p.fir;\n\t\tint cur=p.sec;\n\t\tif(dist>d[cur])continue;\n\t\tif(cur==1)return d[1]+(D-C).abs();\n\t\trep(i,N){\n\t\t\tif(!iSS(P[cur],P[i],C,D)){\n\t\t\t\tdouble ndist=dist+(P[i]-P[cur]).abs();\n\t\t\t\tif(ndist<d[i]){\n\t\t\t\t\td[i]=ndist;\n\t\t\t\t\tQ.push(mp(ndist,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>NA>>NB;\n\trep(i,NA)cin>>PA[i].x>>PA[i].y;\n\trep(i,NB)cin>>PB[i].x>>PB[i].y;\n\tdouble ans=min(solve(NA,PA,PB[0],PB[1]),solve(NB,PB,PA[0],PA[1]));\n\tcout<<setprecision(16)<<(ans==INF?-1:ans)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint n,m;\nvector<Point> a,b;\ndouble dis[1001][1001];\nSegment s;\n\nvoid init(){\n  for(int i=0;i<1000;i++)for(int j=0;j<1000;j++)dis[i][j]=inf;\n}\n\ndouble dijkstra(int size){\n  double d[1000];\n  for(int i=0;i<1000;i++)d[i]=inf;\n  priority_queue<pair<double,int> > pq;\n  pq.push(mp(0,0));\n  d[0]=0;\n\n  while(!pq.empty()){\n    pair<double,int> u=pq.top();\n    pq.pop();\n    u.f*=-1;\n\n    if(d[u.s]<u.f)continue;\n\n    for(int i=0;i<size;i++){\n      if(dis[u.s][i]==inf)continue;\n      if(u.f+dis[i][u.s]<d[i]){\n\td[i]=u.f+dis[i][u.s];\n\tpq.push(mp(d[i]*(-1),i));\n      }\n    }\n  }\n  return d[1];\n}\n\nint main()\n{\n  int x,y;\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    a.push_back(Point(x,y));\n  }\n  for(int i=0;i<m;i++){\n    cin>>x>>y;\n    b.push_back(Point(x,y));\n  }\n  \n  double ans=inf;\n  \n  s=Segment(b[0],b[1]);\n  init();\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)continue;\n      if(intersect(Segment(a[i],a[j]),s))continue;\n      dis[i][j]=abs(a[i]-a[j]);\n    }\n  }\n  ans=min(dijkstra(n)+abs(b[0]-b[1]),ans);\n  \n  s=Segment(a[0],a[1]);\n  init();\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      if(i==j)continue;\n      if(intersect(Segment(b[i],b[j]),s))continue;\n      dis[i][j]=abs(b[i]-b[j]);\n    }\n  }\n  ans=min(dijkstra(m)+abs(a[0]-a[1]),ans);\n  \n  if(ans<inf)printf(\"%.10f\\n\",ans);\n  else cout<<-1<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n//// geometry ////\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle() : c(), r() { }\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n// 交差している2円の交点を求める。角度の小さい方から出る(右下方向が正なら時計回り)\ninline pair<P2, P2> crossPoint(Circle A, Circle B)\n{\n\tP2 v = B.c - A.c;\n\tP2 dir = v.direction(); // 他方の中心への方向\n\tdouble d = v.length(); // 他方の中心への距離\n\tdouble lh = (A.r*A.r + d*d - B.r*B.r) / (2 * d); // 垂線の足までの距離\n\tP2 h = A.c + dir * lh; // 垂線の足\n\tdouble lp = sqrt(A.r*A.r - lh*lh); // 垂線の足から交点までの距離\n\tP2 p = dir.orthogonal() * lp; // 垂線の足から交点へのベクトル\n\treturn make_pair(h + p, h - p); // 交点の組。\n}\n\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (abs(u) - abs(v) < EPS) { return 1; }\n\treturn 0;\n}\n\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n};\n\n\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn contains(a, b.p) || contains(a, b.p + b.d)\n\t\t|| contains(b, a.p) || contains(b, a.p + a.d);\n}\n\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, Na, Nb);\n\t\tauto Pa = read<P2>(Na);\n\t\tauto Pb = read<P2>(Nb);\n\t\tLineSeg ASeg = LineSeg::From2Point(Pa[0], Pa[1]);\n\t\tLineSeg BSeg = LineSeg::From2Point(Pb[0], Pb[1]);\n\n\t\tif (!isCross(ASeg, BSeg))\n\t\t{\n\t\t\tprintf(\"%.15f\", ASeg.d.length() + BSeg.d.length());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvevector<Path<double> > Ga(Na);\n\t\t\tvevector<Path<double> > Gb(Nb);\n\t\t\t\n\t\t\tREP(i, Na) REP(j, Na)\n\t\t\t{\n\t\t\t\tLineSeg s = LineSeg::From2Point(Pa[i], Pa[j]);\n\t\t\t\tif (!isCross(BSeg, s)) Ga[i].push_back({ i, j, s.d.length() });\n\t\t\t}\n\t\t\t\n\t\t\tREP(i, Nb) REP(j, Nb)\n\t\t\t{\n\t\t\t\tLineSeg s = LineSeg::From2Point(Pb[i], Pb[j]);\n\t\t\t\tif (!isCross(ASeg, s)) Gb[i].push_back({ i, j, s.d.length() });\n\t\t\t}\n\n\t\t\tdouble aconn = ASeg.d.length() + dijkstra(Gb, 0, 1).first[1];\n\t\t\tdouble bconn = BSeg.d.length() + dijkstra(Ga, 0, 1).first[1];\n\t\t\tdouble ans = min(aconn, bconn);\n\t\t\tif (ans > INF) { WRITE(-1); }\n\t\t\telse { printf(\"%.15f\", ans); }\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define INF 1e8\n#define equal(a,b) (fabs(a-b) < EPS)\n#define not_equal(a,b) (!equal(a,b))\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\nistream &operator >> (istream &is,Point &p){ \n  return is >> p.x >> p.y;\n}\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nbool isIntersectSP(const Segment &s,const Point &p){\n  return equal(ccw(s.s,s.t,p),0);\n}\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n          ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\nstruct State{\n  double d;\n  int v;\n  State(double d,int v) : d(d),v(v) {}\n  \n  bool operator < (const State &s)const{\n    if(not_equal(d,s.d)){\n      return lt(s.d,d);\n    }\n  }\n};\n\ndouble solve(int x,vector<Point> A[2]){\n  priority_queue<State> Q;\n  Q.push(State(0,0));\n  double d[1010];\n  fill(d,d+1010,INF);\n  d[0] = 0;\n  \n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v;\n    if(lt(d[v],s.d)){ continue; }\n    if(v == 1){ return d[v]; }\n    for(int i = 1 ; i < (int)A[x].size() ; i++){\n      if(v == i){ continue; }\n      Segment s1(A[x][v],A[x][i]),s2(A[1-x][0],A[1-x][1]);\n      if(isIntersectSS(s1,s2)){ continue; }\n      double nd = d[v]+dist(A[x][v],A[x][i]);\n      if(lt(nd,d[i])){\n        d[i] = nd;\n        Q.push(State(d[i],i));\n      }\n    }\n  }\n  return INF;\n}\n\nint main(){\n  int N,M;\n  vector<Point> A[2];\n  cin >> N >> M;\n  A[0].resize(N); A[1].resize(M);\n  for(int i = 0 ; i < N ; i++){\n    cin >> A[0][i];\n  }\n  for(int i = 0 ; i < M ; i++){\n    cin >> A[1][i];\n  }\n  double res = INF;\n  Segment s[2] = {Segment(A[0][0],A[0][1]),\n                  Segment(A[1][0],A[1][1])};\n  for(int i = 0 ; i < 2 ; i++){\n    res = min(res,solve(1-i,A)+dist(s[i].s,s[i].t));\n  }\n  if(res == INF){\n    cout << -1 << endl;\n  }else{\n    printf(\"%.10f\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) cout<<(#_v)<<\":\";for(auto(_x):(_v)){cout<<\" \"<<(_x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nusing P = complex<double>;\nusing G = vector<P>;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\n\nstruct L {\n    P a, b, v, h;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a), h(v / abs(v) * P(0, 1)) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void trans(double d) {\n        a += d * h;\n        b += d * h;\n    }\n    void print() {\n        cerr << \"{(\" << a.real() << \", \" << a.imag() << \"), (\" << b.real() << \", \" << b.imag() << \")}\" << endl;\n    }\n};\nusing S = L;\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    p1 -= p0; p2 -= p0;\n    if (sgn(cross(p1, p2)) == 1) return +1;         // counter-clockwise\n    if (sgn(cross(p1, p2)) == -1) return -1;        // clockwise\n    if (sgn(dot(p1, p2)) == -1) return +2;          // p2 -- p0 -- p1\n    if (sgn(norm(p1), norm(p2)) == -1) return -2;   // p0 -- p1 -- p2\n    return 0;                                       // p0 -- p2 -- p1\n}\n\n// !! ???????????????????????¨?????? \"<\" !!\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) < 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) < 0);\n}\n\nint n[2];\nP p[2][1000];\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    rep(i, 2) cin >> n[i];\n    rep(k, 2) {\n        rep(i, n[k]) {\n            p[k][i] = readP();\n        }\n    }\n\n    double ans = INF;\n    rep(k, 2) {\n        S wall(p[k^1][0], p[k^1][1]);\n        rep(i, n[k]) {\n            rep(j, n[k]) {\n                vector<S> segs;\n                segs.emplace_back(S(p[k][0], p[k][i]));\n                segs.emplace_back(S(p[k][i], p[k][j]));\n                segs.emplace_back(S(p[k][j], p[k][1]));\n                if (none_of(all(segs), [&](S s){return intersectSS(s, wall);})) {\n                    chmin(ans, [&](){\n                        double ret = abs(wall.a - wall.b);\n                        for (auto s : segs) {\n                            ret += abs(s.a - s.b);\n                        }\n                        return ret;\n                    }());\n                }\n            }\n        }\n    }\n\n    cout << fixed << setprecision(10) << (sgn(ans, INF) >= 0 ? -1 : ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing pdd = pair<ld, ld>;\n\nconstexpr ld INF = 1e9;\n\nbool intersect(pdd a, pdd b, pdd c, pdd d) {\n    ld ax = a.first, ay = a.second;\n    ld bx = b.first, by = b.second;\n    ld cx = c.first, cy = c.second;\n    ld dx = d.first, dy = d.second;\n    ld ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n    ld tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n    ld tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n    ld td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n    return tc * td < 0 && ta * tb < 0;\n}\n\nld length(pdd a, pdd b) {\n    ld x1 = a.first, y1 = a.second;\n    ld x2 = b.first, y2 = b.second;\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main() {\n    int Na, Nb;\n    cin >> Na >> Nb;\n    vector<pdd> pa(Na), pb(Nb);\n    for (int i = 0; i < Na; ++i) {\n        ld x, y;\n        cin >> x >> y;\n        pa[i] = make_pair(x, y);\n    }\n    for (int i = 0; i < Nb; ++i) {\n        ld x, y;\n        cin >> x >> y;\n        pb[i] = make_pair(x, y);\n    }\n\n    auto dijkstra = [&](const vector<pdd> &p, int st, int gl, pair<pdd, pdd> seg) {\n        vector<ld> dist(p.size(), INF);\n        dist[st] = 0;\n        priority_queue<pair<ld, int>, vector<pair<ld, int>>, greater<pair<ld, int>>> pq;\n        pq.push({0, st});\n        while (!pq.empty()) {\n            int v = pq.top().second; pq.pop();\n            for (int w = 0; w < p.size(); ++w) {\n                if (intersect(seg.first, seg.second, p[v], p[w])) continue;\n                ld cost = length(p[v], p[w]);\n                if (dist[w] > dist[v] + cost) {\n                    dist[w] = dist[v] + cost;\n                    pq.push(make_pair(dist[w], w));\n                }\n            }\n        }\n        return dist[gl];\n    };\n\n    ld ans = INF;\n    {\n        // pa[0] <--> pa[1] 直線\n        ld tmp = length(pa[0], pa[1]) + dijkstra(pb, 0, 1, make_pair(pa[0], pa[1]));\n        ans = min(ans, tmp);\n    }\n    {\n        // pa[0] <--> pb[1] 直線\n        ld tmp = length(pb[0], pb[1]) + dijkstra(pa, 0, 1, make_pair(pb[0], pb[1]));\n        ans = min(ans, tmp);\n    }\n    cout << setprecision(20) << fixed << (ans >= INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int MOD = 1e9+7;\n\ntypedef tuple<double, double> mytuple;\n\n#define EPS 1e-8\ntypedef complex<double> Point;\nnamespace std {\n    bool operator < (const Point &a, const Point &b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    Point operator / (const Point &p, const double &a) {\n        return Point(real(p)/a, imag(p)/a);\n    }\n    Point operator * (const Point &p, const double &a) {\n        return Point(real(p)*a, imag(p)*a);\n    }\n    bool operator == (const Point &a, const Point &b) {\n        return real(a) == real(b) && imag(a) == imag(b);\n    }\n}\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> { \n    Line () {}\n    Line (const Point &a, const Point &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ndouble dot (const Point &a, const Point &b) {\n        return real(conj(a)*b);\n}\n\ndouble cross (const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; //ccw\n    if (cross(b, c) < 0)   return -1; //cw\n    if (dot(b, c) < 0)     return +2; //c--a--b on line\n    if (norm(b) < norm(c)) return -2; //a--b--c on line\n    return 0; //a--c--b or (c=b)\n}\n\nbool intersectSS (const Line &s, const Line &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectLL (const Line &l, const Line &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\ntypedef double Weight;\nconst Weight INF=1e9;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int rev;\n    Edge(int f, int t, Weight c, int rev=0):src(f),dst(t),weight(c),rev(rev){}\n    bool operator < (const Edge& re)const{ return weight > re.weight;}\n};\ntypedef vector<vector<Edge> > Graph;\nvoid add_edge(Graph &G, int s, int t, Weight cap){\n    G[s].push_back(Edge(s, t, cap, G[t].size()));\n}\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q;\n    for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n        Edge e = Q.top(); Q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight){\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\n\ndouble dist(Line &l){\n    return abs(l[1] - l[0]);\n}\n\nint main(void){\n    int na, nb;\n    while(cin >> na >> nb, na || nb){\n        vector<Point> aP, bP;\n        REP(i, na){\n            double x, y;\n            cin >> x >> y;\n            aP.push_back(Point(x, y));\n        }\n        REP(i, nb){\n            double x, y;\n            cin >> x >> y;\n            bP.push_back(Point(x, y)); \n        }\n\n        Graph g(na);\n        REP(i, na){\n            for(int j = i + 1; j < na; j++){\n                Line b = Line((bP[0]), (bP[1]));\n                Line a = Line((aP[i]), (aP[j]));\n                if(!intersectSS(a, b)){\n                    add_edge(g, i, j, dist(a));\n                    add_edge(g, j, i, dist(a));\n                }\n            }\n        }\n        vector<Weight> di;\n        vi path;\n        shortestPath(g, 0, di, path);\n        Line b = Line((bP[0]), (bP[1]));\n        double l = dist(b) + di[1];\n\n        double ans = INF;\n\n        g.resize(nb);\n        REP(i, nb){\n            for(int j = i + 1; j < nb; j++){\n                Line b = Line((aP[0]), (aP[1]));\n                Line a = Line((bP[i]), (bP[j]));\n                if(!intersectSS(a, b)){\n                    add_edge(g, i, j, dist(a));\n                    add_edge(g, j, i, dist(a));\n                }\n            }\n        }\n        vector<Weight> dist2;\n        vi path2;\n        shortestPath(g, 0, dist2, path2);\n        Line a = Line((aP[0]), (aP[1]));\n        double r = dist(a) + dist2[1];\n\n\n        if(!intersectSS(a, b)){\n            printf(\"%.10lf\", dist(a) + dist(b));\n        }\n        else if(min(l, r) < INF - EPS){\n            printf(\"%.10lf\", min(l, r));\n        }\n        else cout << -1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 0\n\nclass D3 {\npublic:\n\tlong double X, Y, Z, EPS;\n\n\tD3( long double, long double, long double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( long double );\n\tD3 operator*( long double );\n\tD3 operator/( long double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3 {\npublic:\n\tPoint( long double, long double, long double );\n\tlong double getX();\n\tlong double getY();\n\tlong double getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tlong double S_point( Point, Point );\n\tlong double V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec {\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( long double x_, long double y_, long double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( long double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( long double );\n\tbool operator== ( Vec );\n\tbool operator==( long double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tlong double length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tlong double S_vec( Vec );\n\tlong double V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( long double ld ) {\n\treturn ( *this ) == D3();\n}\n\nD3 D3::operator*( long double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( long double ld ) {\n\treturn  *this*( ld*-1.L );\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\nlong double Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\nlong double Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\nlong double Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( ( *this ).getX() != Partner.getX() ) {\n\t\treturn ( *this ).getX() < Partner.getX();\n\t}\n\tif( ( *this ).getY() != Partner.getY() ) {\n\t\treturn ( *this ).getY() < Partner.getY();\n\t}\n\treturn ( *this ).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < ( *this );\n}\n//??????????????¢???????±???????\nlong double Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\nlong double Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( ( *this ), B ).V_vec( Vec( ( *this ), C ), Vec( ( *this ), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( long double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + ( Partner*( -1.L ) );\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( long double ld ) {\n\treturn *this*( 1.L / ld );\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( long double ) {\n\treturn ( *this ) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\nlong double Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / ( *this ).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn ( *this )*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( ( *this ).Inverse_vec().getD(), ( *this ).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn ( *this ).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn ( *this ).Unit_vec().getD() == Partner.Unit_vec().getD() || ( *this ).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) );\n\tVec Q = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getSP() ) );\n\tVec R = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getGP() ) );\n\treturn ( !( *this ).Parallel( Partner ) ) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS ) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS );\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( ( *this ).isIntersection( Partner ) ) {\n\t\tlong double d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) ).D.Z );\n\t\tlong double d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) ).D.Z );\n\t\tlong double t = d1 / ( d1 + d2 );\n\t\treturn Vec( ( ( *this )*t ).getD(), ( *this ).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( ( *this ).getSP(), A );\n\tif( A == ( ( *this ).getSP() ) || ( Test.Parallel( *this ) && ( *this ).getD().X / Test.getD().X >= 1.0L ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\nlong double Vec::S_vec( Vec B ) {\n\tif( ( ( *this ).getSP() == B.getSP() ) ) {\n\t\tVec G = ( *this ).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( ( *this ).getGP() == B.getSP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B );\n\t}\n\tif( ( *this ).getSP() == B.getGP() ) {\n\t\treturn ( *this ).S_vec( B.Reverse_vec() );\n\t}\n\tif( ( *this ).getGP() == B.getGP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\nlong double Vec::V_vec( Vec B, Vec C ) {\n\tVec G = ( *this ).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points {\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance {\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n\n\nvector<vector<pair<long long int, long double>>>makelist( vector<Point>&townlist, Vec DisallowVec ) {\n\tvector<vector<pair<long long int, long double>>>ret( townlist.size() );\n\tfor( size_t i = 0; i < townlist.size(); i++ ) {\n\t\tfor( size_t j = i + 1; j < townlist.size(); j++ ) {\n\t\t\tVec now = Vec( townlist[i], townlist[j] );\n\t\t\tif( !now.isIntersection( DisallowVec ) ) {\n\t\t\t\tret[i].push_back( make_pair( j, now.length() ) );\n\t\t\t\tret[j].push_back( make_pair( i, now.length() ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nlong double dijkstra( vector<vector<pair<long long int, long double>>> & listLen ) {\n\tvector<long double>ret( listLen.size(), LDBL_MAX / 10 );\n\tpriority_queue<pair<long double, long long int>, vector<pair<long double, long long int>>, greater<pair<long double, long long int>>>que;\n\tque.push( make_pair( 0, 0 ) );\n\tret[0] = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( now.second == 1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif( now.first != ret[now.second] ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( auto next : listLen[now.second] ) {\n\t\t\tif( ret[next.first] > now.first + next.second ) {\n\t\t\t\tret[next.first] = now.first + next.second;\n\t\t\t\tif( ret[next.first] < ret[1] ) {\n\t\t\t\t\tque.push( make_pair( now.first + next.second, next.first ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret[1];\n}\n\n\nint main() {\n\tlong long int NA, NB;\n\tcin >> NA >> NB;\n\tvector<Point>townA( NA ), townB( NB );\n\tfor( size_t i = 0; i < NA; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownA[i] = Point( x, y );\n\t}\n\tfor( size_t i = 0; i < NB; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownB[i] = Point( x, y );\n\t}\n\n\tauto listA = makelist( townA, Vec( townB[0], townB[1] ) );\n\tauto listB = makelist( townB, Vec( townA[0], townA[1] ) );\n\n\tlong double lenA = dijkstra( listA );\n\tlong double lenB = dijkstra( listB );\n\n\tif( lenA == LDBL_MAX / 10 && lenB == LDBL_MAX / 10 ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << fixed << setprecision( 20 ) << min( lenA + Vec( townB[0], townB[1] ).length(), lenB + Vec( townA[0], townA[1] ).length() ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint ax[1100];int ay[1100];int bx[1100];int by[1100];\ndouble ijk[1100];\nint v[1100];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",ax+i,ay+i);\n\t}\n\tfor(int i=0;i<b;i++)scanf(\"%d%d\",bx+i,by+i);\n\tfor(int i=0;i<a;i++)ijk[i]=999999999;\n\tijk[0]=0;\n\tfor(int i=0;i<a;i++){\n\t\tint at=0;\n\t\tdouble val=999999999;\n\t\tfor(int j=0;j<a;j++)if(!v[j]&&val>ijk[j]){\n\t\t\tat=j;val=ijk[j];\n\t\t}\n\t\tv[at]=1;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(iSS(Pt(bx[0],by[0]),Pt(bx[1],by[1]),Pt(ax[at],ay[at]),Pt(ax[j],ay[j])))continue;\n\t\t\tijk[j]=min(ijk[j],ijk[at]+sqrt((ax[at]-ax[j])*(ax[at]-ax[j])+(ay[at]-ay[j])*(ay[at]-ay[j])));\n\t\t}\n\t}\n\tdouble ret=ijk[1]+sqrt((bx[0]-bx[1])*(bx[0]-bx[1])+(by[0]-by[1])*(by[0]-by[1]));\n\tfor(int i=0;i<b;i++)ijk[i]=999999999;\n\tijk[0]=0;\n\tfor(int i=0;i<b;i++)v[i]=0;\n\tfor(int i=0;i<b;i++){\n\t\tint at=0;\n\t\tdouble val=999999999;\n\t\tfor(int j=0;j<b;j++)if(!v[j]&&val>ijk[j]){\n\t\t\tat=j;val=ijk[j];\n\t\t}\n\t\tv[at]=1;\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(iSS(Pt(ax[0],ay[0]),Pt(ax[1],ay[1]),Pt(bx[at],by[at]),Pt(bx[j],by[j])))continue;\n\t\t\tijk[j]=min(ijk[j],ijk[at]+sqrt((bx[at]-bx[j])*(bx[at]-bx[j])+(by[at]-by[j])*(by[at]-by[j])));\n\t\t}\n\t}\n\tret=min(ret,ijk[1]+sqrt((ax[0]-ax[1])*(ax[0]-ax[1])+(ay[0]-ay[1])*(ay[0]-ay[1])));\n\tif(ret>909090909)printf(\"-1\\n\");\n\telse printf(\"%.12f\\n\",ret);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Signum(double x){\n\treturn x<-EPS?-1:x>EPS?1:0;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){\n\t\tx+=p.x,y+=p.y;\n\t\treturn *this;\n\t}\n\tPoint& operator-=(Point p){\n\t\tx-=p.x,y-=p.y;\n\t\treturn *this;\n\t}\n\tPoint& operator*=(double c){\n\t\tx*=c,y*=c;\n\t\treturn *this;\n\t}\n\tPoint& operator/=(double c){\n\t\tx/=c,y/=c;\n\t\treturn *this;\n\t}\n};\nPoint operator+(Point a,Point b){\n\treturn a+=b;\n}\nPoint operator-(Point a,Point b){\n\treturn a-=b;\n}\nPoint operator*(Point a,double c){\n\treturn a*=c;\n}\nPoint operator*(double c,Point a){\n\treturn a*=c;\n}\nPoint operator/(Point a,double c){\n\treturn a/=c;\n}\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nbool operator!=(Point a,Point b){\n\treturn !(a==b);\n}\n\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Arg(Point p){\n\treturn atan2(p.y,p.x);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\n\nPoint Proj(Line l,Point p){\n\tPoint a=p-l.pos,b=l.dir;\n\treturn l.pos+Dot(a,b)/Abs2(b)*b;\n}\n\nstruct Segment{\n\tPoint pos,dir;\n\tSegment(){}\n\tSegment(Point p,Point d):pos(p),dir(d){}\n\tSegment(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n\texplicit Segment(Line l):pos(l.pos),dir(l.dir){}\n\texplicit operator Line()const{return Line(pos,dir);}\n};\n\nint CCW(Point a,Point b,Point c){\n\tb-=a,c-=a;\n\tif(int sign=Signum(Cross(b,c)))\n\t\treturn sign; // 1:ccw,-1:cw\n\tif(Dot(b,c)<-EPS)\n\t\treturn -2;   // c-a-b\n\tif(Abs2(b)<Abs2(c)-EPS)\n\t\treturn 2;    // a-b-c\n\treturn 0;        // a-c-b (inclusive)\n}\n\nbool IntersectSS(Segment a,Segment b){\n\tint c1=CCW(a.pos,a.pos+a.dir,b.pos),c2=CCW(a.pos,a.pos+a.dir,b.pos+b.dir);\n\tint c3=CCW(b.pos,b.pos+b.dir,a.pos),c4=CCW(b.pos,b.pos+b.dir,a.pos+a.dir);\n\treturn c1*c2<=0 && c3*c4<=0;\n}\n\ndouble calc(Segment s,const vector<Point>& ps)\n{\n\tint n=ps.size();\n\tvd dist(n,INF); dist[0]=0;\n\tvi vis(n);\n\tfor(;;){\n\t\tint u=-1;\n\t\trep(i,n) if(!vis[i] && dist[i]!=INF)\n\t\t\tif(u==-1 || dist[i]<dist[u])\n\t\t\t\tu=i;\n\t\tif(u==-1) break;\n\t\tvis[u]=1;\n\t\trep(v,n) if(!vis[v]){\n\t\t\tSegment t(ps[u],ps[v]-ps[u]);\n\t\t\tif(!IntersectSS(s,t))\n\t\t\t\tdist[v]=min(dist[v],dist[u]+Abs(t.dir));\n\t\t}\n\t}\n\treturn dist[1];\n}\n\nint main()\n{\n\tfor(int n1,n2;cin>>n1>>n2 && n1|n2;){\n\t\tvector<Point> ps1(n1),ps2(n2);\n\t\tfor(auto& p:ps1) cin>>p.x>>p.y;\n\t\tfor(auto& p:ps2) cin>>p.x>>p.y;\n\t\t\n\t\tSegment s1(ps1[0],ps1[1]-ps1[0]);\n\t\tSegment s2(ps2[0],ps2[1]-ps2[0]);\n\t\tif(!IntersectSS(s1,s2)){\n\t\t\tprintf(\"%.12f\\n\",Abs(s1.dir)+Abs(s2.dir));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdouble res=min(Abs(s1.dir)+calc(s1,ps2),Abs(s2.dir)+calc(s2,ps1));\n\t\tif(res>=INF)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tprintf(\"%.12f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\ntypedef Segment Line;\n//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n// 許容する誤差\n#define EPS (1e-10)\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\tshow(a - b);\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n\ndouble ga[1000][1000], gb[1000][1000];\n\nconst int MAX_V = 1000;\ndouble dijkstra(int n, int s, double g[MAX_V][MAX_V]){\n\tvector<double> dis(n,INF);\n\tpriority_queue<double, vector<pair<double, int>>, greater<pair<double, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tdouble cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] == INF){\n\t\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\t\tq.emplace(dis[to], to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[1];\n}\n\ndouble solve(double g[MAX_V][MAX_V], Segment s, vector<Point>& a){\n\tint n = a.size();\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i == j) continue;\n\t\t\tif(isIntersectedLs(s, Segment{a[i], a[j]})){\n\t\t\t\tg[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\treturn dijkstra(n, 0, g);\n}\n\nvoid input(vector<Point>& a, int n){\n\trep(i,n){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\ta[i] = Point(x,y);\n\t}\n}\n\nvoid culDist(double g[MAX_V][MAX_V], vector<Point>& a, int n){\n\trep(i,n) rep(j,n) g[i][j] = abs(a[i] - a[j]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint na, nb;\n\tcin >> na >> nb;\n\n\tvector<Point> a(na), b(nb);\n\tinput(a, na);\n\tinput(b, nb);\n\n\tculDist(ga, a, na);\n\tculDist(gb, b, nb);\n\n\tdouble adis = ga[0][1];\n\tdouble bdis = gb[0][1];\n\n\tdouble ans = min<double>(\n\t\t\tsolve(gb, Segment{a[0], a[1]}, b) + adis,\n\t\t\tsolve(ga, Segment{b[0], b[1]}, a) + bdis\n\t\t\t);\n\tcout << fixed << setprecision(10) << (ans >= INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int MOD = 1e9+7;\n\ntypedef tuple<double, double> mytuple;\n\n#define EPS 1e-8\ntypedef complex<double> Point;\nnamespace std {\n    bool operator < (const Point &a, const Point &b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    Point operator / (const Point &p, const double &a) {\n        return Point(real(p)/a, imag(p)/a);\n    }\n    Point operator * (const Point &p, const double &a) {\n        return Point(real(p)*a, imag(p)*a);\n    }\n    bool operator == (const Point &a, const Point &b) {\n        return real(a) == real(b) && imag(a) == imag(b);\n    }\n}\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> { \n    Line () {}\n    Line (const Point &a, const Point &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ndouble dot (const Point &a, const Point &b) {\n        return real(conj(a)*b);\n}\n\ndouble cross (const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; //ccw\n    if (cross(b, c) < 0)   return -1; //cw\n    if (dot(b, c) < 0)     return +2; //c--a--b on line\n    if (norm(b) < norm(c)) return -2; //a--b--c on line\n    return 0; //a--c--b or (c=b)\n}\n\nbool intersectSS (const Line &s, const Line &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectLL (const Line &l, const Line &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\ntypedef double Weight;\nconst Weight INF=1e9;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int rev;\n    Edge(int f, int t, Weight c, int rev=0):src(f),dst(t),weight(c),rev(rev){}\n    bool operator < (const Edge& re)const{ return weight > re.weight;}\n};\ntypedef vector<vector<Edge> > Graph;\nvoid add_edge(Graph &G, int s, int t, Weight cap){\n    G[s].push_back(Edge(s, t, cap, G[t].size()));\n}\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q;\n    for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n        Edge e = Q.top(); Q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight){\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\n\ndouble dist(Line &l){\n    return abs(l[1] - l[0]);\n}\n\nint main(void){\n    int na, nb;\n    cin >> na >> nb;\n    vector<Point> aP, bP;\n    REP(i, na){\n        double x, y;\n        cin >> x >> y;\n        aP.push_back(Point(x, y));\n    }\n    REP(i, nb){\n        double x, y;\n        cin >> x >> y;\n        bP.push_back(Point(x, y)); \n    }\n\n    Graph g(na);\n    REP(i, na){\n        for(int j = i + 1; j < na; j++){\n            Line b = Line((bP[0]), (bP[1]));\n            Line a = Line((aP[i]), (aP[j]));\n            if(!intersectSS(a, b)){\n                add_edge(g, i, j, dist(a));\n                add_edge(g, j, i, dist(a));\n            }\n        }\n    }\n    vector<Weight> di;\n    vi path;\n    shortestPath(g, 0, di, path);\n    Line b = Line((bP[0]), (bP[1]));\n    double l = dist(b) + di[1];\n\n    double ans = INF;\n\n    g.resize(nb);\n    REP(i, nb){\n        for(int j = i + 1; j < nb; j++){\n            Line b = Line((aP[0]), (aP[1]));\n            Line a = Line((bP[i]), (bP[j]));\n            if(!intersectSS(a, b)){\n                add_edge(g, i, j, dist(a));\n                add_edge(g, j, i, dist(a));\n            }\n        }\n    }\n    vector<Weight> dist2;\n    vi path2;\n    shortestPath(g, 0, dist2, path2);\n    Line a = Line((aP[0]), (aP[1]));\n    double r = dist(a) + dist2[1];\n\n\n    if(!intersectSS(a, b)){\n        printf(\"%.10lf\", dist(a) + dist(b));\n    }\n    else if(min(l, r) < INF - EPS){\n        printf(\"%.10lf\", min(l, r));\n    }\n    else cout << -1 << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector< vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;\n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return res;\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n\n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<int> > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n\n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b);\n      G[b].emplace_back(a);\n    }\n  }\n  for(auto &v:G){\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n\n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }\n  }\n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n\n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }\n  }\n\n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(dot(va,vb),cross(va,vb));\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n        return c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n        res+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n\ntemplate <typename T>\nvector<T> dijkstra(int s,vector<vector<pair<int, T> > > & G){\n  const T INF = numeric_limits<T>::max();\n  using P = pair<T, int>;\n  int n=G.size();\n  vector<T> d(n,INF);\n  vector<int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s]=0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n        d[u]=d[v]+c;\n        b[u]=v;\n        q.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n\n  Polygon ps(n),qs(m);\n  for(int i=0;i<n;i++) cin>>ps[i];\n  for(int i=0;i<m;i++) cin>>qs[i];\n\n  using D = double;\n  const D INF = 1e18;\n  D ans=INF;\n\n  using P = pair<int, D>;\n  vector< vector<P> > G(n),H(m);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j) continue;\n      Segment s(ps[i],ps[j]);\n      Segment t(qs[0],qs[1]);\n      if(getDistanceSS(s,t)<EPS) continue;\n      G[i].emplace_back(j,abs(ps[i]-ps[j]));\n    }\n  }\n\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      if(i==j) continue;\n      Segment s(qs[i],qs[j]);\n      Segment t(ps[0],ps[1]);\n      if(getDistanceSS(s,t)<EPS) continue;\n      H[i].emplace_back(j,abs(qs[i]-qs[j]));\n    }\n  }\n\n  chmin(ans,dijkstra(0,G)[1]+abs(qs[0]-qs[1]));\n  chmin(ans,dijkstra(0,H)[1]+abs(ps[0]-ps[1]));\n\n  if(ans==INF) cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 0\n\nclass D3 {\npublic:\n\tlong double X, Y, Z, EPS;\n\n\tD3( long double, long double, long double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( long double );\n\tD3 operator*( long double );\n\tD3 operator/( long double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3 {\npublic:\n\tPoint( long double, long double, long double );\n\tlong double getX();\n\tlong double getY();\n\tlong double getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tlong double S_point( Point, Point );\n\tlong double V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec {\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( long double x_, long double y_, long double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( long double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( long double );\n\tbool operator== ( Vec );\n\tbool operator==( long double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tlong double length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tlong double S_vec( Vec );\n\tlong double V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( long double ld ) {\n\treturn ( *this ) == D3();\n}\n\nD3 D3::operator*( long double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( long double ld ) {\n\treturn  *this*( ld*-1.L );\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\nlong double Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\nlong double Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\nlong double Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( ( *this ).getX() != Partner.getX() ) {\n\t\treturn ( *this ).getX() < Partner.getX();\n\t}\n\tif( ( *this ).getY() != Partner.getY() ) {\n\t\treturn ( *this ).getY() < Partner.getY();\n\t}\n\treturn ( *this ).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < ( *this );\n}\n//??????????????¢???????±???????\nlong double Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\nlong double Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( ( *this ), B ).V_vec( Vec( ( *this ), C ), Vec( ( *this ), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( long double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + ( Partner*( -1.L ) );\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( long double ld ) {\n\treturn *this*( 1.L / ld );\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( long double ) {\n\treturn ( *this ) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\nlong double Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / ( *this ).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn ( *this )*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( ( *this ).Inverse_vec().getD(), ( *this ).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn ( *this ).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn ( *this ).Unit_vec().getD() == Partner.Unit_vec().getD() || ( *this ).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) );\n\tVec Q = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getSP() ) );\n\tVec R = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getGP() ) );\n\treturn ( !( *this ).Parallel( Partner ) ) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS ) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS );\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( ( *this ).isIntersection( Partner ) ) {\n\t\tlong double d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) ).D.Z );\n\t\tlong double d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) ).D.Z );\n\t\tlong double t = d1 / ( d1 + d2 );\n\t\treturn Vec( ( ( *this )*t ).getD(), ( *this ).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( ( *this ).getSP(), A );\n\tif( A == ( ( *this ).getSP() ) || ( Test.Parallel( *this ) && ( *this ).getD().X / Test.getD().X >= 1.0L ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\nlong double Vec::S_vec( Vec B ) {\n\tif( ( ( *this ).getSP() == B.getSP() ) ) {\n\t\tVec G = ( *this ).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( ( *this ).getGP() == B.getSP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B );\n\t}\n\tif( ( *this ).getSP() == B.getGP() ) {\n\t\treturn ( *this ).S_vec( B.Reverse_vec() );\n\t}\n\tif( ( *this ).getGP() == B.getGP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\nlong double Vec::V_vec( Vec B, Vec C ) {\n\tVec G = ( *this ).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points {\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance {\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n\n\nauto makelist( vector<Point>&townlist, Vec DisallowVec ) {\n\tvector<vector<pair<long long int, long double>>>ret( townlist.size() );\n\tfor( size_t i = 0; i < townlist.size(); i++ ) {\n\t\tfor( size_t j = i + 1; j < townlist.size(); j++ ) {\n\t\t\tVec now = Vec( townlist[i], townlist[j] );\n\t\t\tif( !now.isIntersection( DisallowVec ) ) {\n\t\t\t\tret[i].push_back( make_pair( j, now.length() ) );\n\t\t\t\tret[j].push_back( make_pair( i, now.length() ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn &ret;\n}\n\nlong double dijkstra( vector<vector<pair<long long int, long double>>> *listLen ) {\n\tvector<long double>ret( (*listLen).size(), LDBL_MAX / 10 );\n\tpriority_queue<pair<long double, long long int>, vector<pair<long double, long long int>>, greater<pair<long double, long long int>>>que;\n\tque.push( make_pair( 0, 0 ) );\n\tret[0] = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( now.second == 1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif( now.first != ret[now.second] ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( auto next : (*listLen)[now.second] ) {\n\t\t\tif( ret[next.first] > now.first + next.second ) {\n\t\t\t\tret[next.first] = now.first + next.second;\n\t\t\t\tif( ret[next.first] < ret[1] ) {\n\t\t\t\t\tque.push( make_pair( now.first + next.second, next.first ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret[1];\n}\n\n\nint main() {\n\tlong long int NA, NB;\n\tcin >> NA >> NB;\n\tvector<Point>townA( NA ), townB( NB );\n\tfor( size_t i = 0; i < NA; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownA[i] = Point( x, y );\n\t}\n\tfor( size_t i = 0; i < NB; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\ttownB[i] = Point( x, y );\n\t}\n\n\tauto listA = makelist( townA, Vec( townB[0], townB[1] ) );\n\tauto listB = makelist( townB, Vec( townA[0], townA[1] ) );\n\n\tlong double lenA = dijkstra( listA );\n\tlong double lenB = dijkstra( listB );\n\n\tif( lenA == LDBL_MAX / 10 && lenB == LDBL_MAX / 10 ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << fixed << setprecision( 20 ) << min( lenA + Vec( townB[0], townB[1] ).length(), lenB + Vec( townA[0], townA[1] ).length() ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 0\n\nclass D3 {\npublic:\n\tdouble X, Y, Z, EPS;\n\n\tD3( double, double, double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( double );\n\tD3 operator*( double );\n\tD3 operator/( double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3 {\npublic:\n\tPoint( double, double, double );\n\tdouble getX();\n\tdouble getY();\n\tdouble getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tdouble S_point( Point, Point );\n\tdouble V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec {\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( double x_, double y_, double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( double );\n\tbool operator== ( Vec );\n\tbool operator==( double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tdouble length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tdouble S_vec( Vec );\n\tdouble V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( double x_ = 0.0L, double y_ = 0.0L, double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( double ld ) {\n\treturn ( *this ) == D3();\n}\n\nD3 D3::operator*( double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( double ld ) {\n\treturn  *this*( ld*-1.L );\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( double x_ = 0.0L, double y_ = 0.0L, double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\ndouble Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\ndouble Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\ndouble Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( ( *this ).getX() != Partner.getX() ) {\n\t\treturn ( *this ).getX() < Partner.getX();\n\t}\n\tif( ( *this ).getY() != Partner.getY() ) {\n\t\treturn ( *this ).getY() < Partner.getY();\n\t}\n\treturn ( *this ).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < ( *this );\n}\n//??????????????¢???????±???????\ndouble Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\ndouble Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( ( *this ), B ).V_vec( Vec( ( *this ), C ), Vec( ( *this ), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( double x_ = 0.0L, double y_ = 0.0L, double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + ( Partner*( -1.L ) );\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( double ld ) {\n\treturn *this*( 1.L / ld );\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( double ) {\n\treturn ( *this ) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\ndouble Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / ( *this ).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn ( *this )*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( ( *this ).Inverse_vec().getD(), ( *this ).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn ( *this ).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn ( *this ).Unit_vec().getD() == Partner.Unit_vec().getD() || ( *this ).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) );\n\tVec Q = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getSP() ) );\n\tVec R = ( *this ).Cross_product( Vec( ( *this ).getSP(), Partner.getGP() ) );\n\treturn ( !( *this ).Parallel( Partner ) ) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS ) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS );\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( ( *this ).isIntersection( Partner ) ) {\n\t\tdouble d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getSP() ) ).D.Z );\n\t\tdouble d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), ( *this ).getGP() ) ).D.Z );\n\t\tdouble t = d1 / ( d1 + d2 );\n\t\treturn Vec( ( ( *this )*t ).getD(), ( *this ).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( ( *this ).getSP(), A );\n\tif( A == ( ( *this ).getSP() ) || ( Test.Parallel( *this ) && ( *this ).getD().X / Test.getD().X >= 1.0L ) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\ndouble Vec::S_vec( Vec B ) {\n\tif( ( ( *this ).getSP() == B.getSP() ) ) {\n\t\tVec G = ( *this ).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( ( *this ).getGP() == B.getSP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B );\n\t}\n\tif( ( *this ).getSP() == B.getGP() ) {\n\t\treturn ( *this ).S_vec( B.Reverse_vec() );\n\t}\n\tif( ( *this ).getGP() == B.getGP() ) {\n\t\treturn ( *this ).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\ndouble Vec::V_vec( Vec B, Vec C ) {\n\tVec G = ( *this ).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points {\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance {\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\n\n\nvector<vector<pair<long long int, double>>>makelist( vector<Point>&townlist, Vec DisallowVec ) {\n\tvector<vector<pair<long long int, double>>>ret( townlist.size() );\n\tfor( size_t i = 0; i < townlist.size(); i++ ) {\n\t\tfor( size_t j = i + 1; j < townlist.size(); j++ ) {\n\t\t\tVec now = Vec( townlist[i], townlist[j] );\n\t\t\tif( !now.isIntersection( DisallowVec ) ) {\n\t\t\t\tret[i].push_back( make_pair( j, now.length() ) );\n\t\t\t\tret[j].push_back( make_pair( i, now.length() ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\ndouble dijkstra( vector<vector<pair<long long int, double>>>  listLen ) {\n\tvector<double>ret( listLen.size(), DBL_MAX / 10 );\n\tpriority_queue<pair< double, long long int>, vector<pair<double, long long int>>, greater<pair<double, long long int>>>que;\n\tque.push( make_pair( 0, 0 ) );\n\tret[0] = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( now.second == 1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tif( now.first != ret[now.second] ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( auto next : listLen[now.second] ) {\n\t\t\tif( ret[next.first] > now.first + next.second ) {\n\t\t\t\tret[next.first] = now.first + next.second;\n\t\t\t\tif( ret[next.first] < ret[1] ) {\n\t\t\t\t\tque.push( make_pair( now.first + next.second, next.first ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret[1];\n}\n\n\nint main() {\n\tlong long int NA, NB;\n\tcin >> NA >> NB;\n\tvector<Point>townA( NA ), townB( NB );\n\tfor( size_t i = 0; i < NA; i++ ) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\ttownA[i] = Point( x, y );\n\t}\n\tfor( size_t i = 0; i < NB; i++ ) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\ttownB[i] = Point( x, y );\n\t}\n\n\tauto listA = makelist( townA, Vec( townB[0], townB[1] ) );\n\tauto listB = makelist( townB, Vec( townA[0], townA[1] ) );\n\n\tdouble lenA = dijkstra( listA );\n\tdouble lenB = dijkstra( listB );\n\n\tif( lenA == DBL_MAX / 10 && lenB == DBL_MAX / 10 ) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << fixed << setprecision( 20 ) << min( lenA + Vec( townB[0], townB[1] ).length(), lenB + Vec( townA[0], townA[1] ).length() ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <complex>\n#include <cassert>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#include <climits>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n#include <chrono>\n\nusing namespace std;\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b) {\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n    C operator* (const C a, const C b){\n        return C(a.real()*b.real()-a.imag()*b.imag(),a.real()*b.imag()+a.imag()*b.real());\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\n\n//条件付きsqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//正規化\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//角度(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//外積\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//内積\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\n//bを中心としてaをth(rad)回転\nC rot(C a,C b,double th)\n{\n    return b + (a-b) * C(cos(th),sin(th));\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   // a--c--b on line\n}\n\n//直線どうしの交差判定(同一直線はTrue)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//直線と線分の交差判定(一点共有も交差と判定)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//直線と点の交差(共有)判定\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//線分どうしの交差判定(一点共有も交差と判定)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//線分と点の交差(共有)判定\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\ntemplate<typename T> class Dijkstra {\npublic:\n\tstruct edge{\n\t\tint to; T cost;\n\t};\n\tint V;\n\tvector<vector<edge> > G;\n\tvector<T> d;\n\tusing pti = pair<T,int>;\n\tDijkstra(int node_size) : V(node_size), G(V), d(V, numeric_limits<T>::max()){}\n\t//無向グラフの場合\n\tvoid add_edge(int u,int v,T cost){\n\t\tG[u].push_back((edge){v,cost}),G[v].push_back((edge){u,cost});\n\t}\n\tvoid solve(int s){\n\t\tpriority_queue<pti,vector<pti>,greater<pti> > que;\n\t\td[s] = 0;\n\t\tque.push(pti(0,s));\n\t\twhile(!que.empty()){\n\t\t\tpti p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second;\n\t\t\tif(d[v] < p.first) continue;\n\t\t\tfor(auto& w : G[v]){\n\t\t\t\tif(d[w.to] > d[v] + w.cost){\n\t\t\t\t\td[w.to] = d[v] + w.cost;\n\t\t\t\t\tque.push(pti(d[w.to],w.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\ndouble solve(vector<C> a,vector<C>b){\n    int n,m;\n    n = a.size();\n    m = b.size();\n    double res = 0;\n    res += sqrt(dot(a[0]-a[1],a[0]-a[1]));\n    L s(a[0],a[1]);\n    Dijkstra<double> dj(m);\n    rep(i,m){\n        rep(j,m){\n            if(i<=j)break;\n            L t(b[i],b[j]);\n            if(intersectSS(s,t)){\n                //cerr << i << \" \" << j << endl;\n            }else{\n                dj.add_edge(i,j,sqrt(dot(b[i]-b[j],b[i]-b[j])));\n            }\n        }\n    }\n    dj.solve(0);\n    return res+dj.d[1];\n}\n\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<C> a(n);\n    vector<C> b(m);\n    rep(i,n){\n        double s,t;\n        cin >> s >> t;\n        a[i] = C(s,t);\n    }\n    rep(i,m){\n        double s,t;\n        cin >> s >> t;\n        b[i] = C(s,t);\n    }\n    double res = solve(a,b);\n    res = min(res,solve(b,a));\n    cout.precision(20);\n    \n    if(res<=1000000000.0)cout << res << endl;\n    else cout << -1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int MOD = 1e9+7;\n\ntypedef tuple<double, double> mytuple;\n\n#define EPS 1e-8\ntypedef complex<double> Point;\nnamespace std {\n    bool operator < (const Point &a, const Point &b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    Point operator / (const Point &p, const double &a) {\n        return Point(real(p)/a, imag(p)/a);\n    }\n    Point operator * (const Point &p, const double &a) {\n        return Point(real(p)*a, imag(p)*a);\n    }\n    bool operator == (const Point &a, const Point &b) {\n        return real(a) == real(b) && imag(a) == imag(b);\n    }\n}\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> { \n    Line () {}\n    Line (const Point &a, const Point &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ndouble dot (const Point &a, const Point &b) {\n        return real(conj(a)*b);\n}\n\ndouble cross (const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\nint ccw (Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1; //ccw\n    if (cross(b, c) < 0)   return -1; //cw\n    if (dot(b, c) < 0)     return +2; //c--a--b on line\n    if (norm(b) < norm(c)) return -2; //a--b--c on line\n    return 0; //a--c--b or (c=b)\n}\n\nbool intersectSS (const Line &s, const Line &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectLL (const Line &l, const Line &m) {\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n        abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\ntypedef double Weight;\nconst Weight INF=1e9;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int rev;\n    Edge(int f, int t, Weight c, int rev=0):src(f),dst(t),weight(c),rev(rev){}\n    bool operator < (const Edge& re)const{ return weight > re.weight;}\n};\ntypedef vector<vector<Edge> > Graph;\nvoid add_edge(Graph &G, int s, int t, Weight cap){\n    G[s].push_back(Edge(s, t, cap, G[t].size()));\n}\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q;\n    for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n        Edge e = Q.top(); Q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight){\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\n\ndouble dist(Line &l){\n    return abs(l[1] - l[0]);\n}\n\nint main(void){\n    int na, nb;\n    while(cin >> na >> nb, na || nb){\n        vector<Point> aP, bP;\n        REP(i, na){\n            double x, y;\n            cin >> x >> y;\n            aP.push_back(Point(x, y));\n        }\n        REP(i, nb){\n            double x, y;\n            cin >> x >> y;\n            bP.push_back(Point(x, y)); \n        }\n\n        Graph g(na);\n        REP(i, na){\n            for(int j = i + 1; j < na; j++){\n                Line b = Line((bP[0]), (bP[1]));\n                Line a = Line((aP[i]), (aP[j]));\n                if(!intersectSS(a, b)){\n                    add_edge(g, i, j, dist(a));\n                    add_edge(g, j, i, dist(a));\n                }\n            }\n        }\n        vector<Weight> di;\n        vi path;\n        shortestPath(g, 0, di, path);\n        Line b = Line((bP[0]), (bP[1]));\n        double l = dist(b) + di[1];\n\n        double ans = INF;\n\n        g.resize(nb);\n        REP(i, nb){\n            for(int j = i + 1; j < nb; j++){\n                Line b = Line((aP[0]), (aP[1]));\n                Line a = Line((bP[i]), (bP[j]));\n                if(!intersectSS(a, b)){\n                    add_edge(g, i, j, dist(a));\n                    add_edge(g, j, i, dist(a));\n                }\n            }\n        }\n        vector<Weight> dist2;\n        vi path2;\n        shortestPath(g, 0, dist2, path2);\n        Line a = Line((aP[0]), (aP[1]));\n        double r = dist(a) + dist2[1];\n\n\n        if(!intersectSS(a, b)){\n            printf(\"%.10lf\", dist(a) + dist(b));\n        }\n        else if(min(l, r) < INF - EPS){\n            printf(\"%.10lf\", min(l, r));\n        }\n        else cout << -1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define LT(x,y) ((x)-(y)<=-EPS)\n\ndouble cross(P a, P b) {\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\n\nint is_point_on_ls(P a, P b, P c) {\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\tif((cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS) &&\n\t\t(cross(b2-b1, a1-b1) * cross(b2-b1, a2-a1) < -EPS))\n\t\treturn true;\n\treturn is_point_on_ls(a1, a2, b1) || is_point_on_ls(a1, a2, b2) ||\n\t\t\tis_point_on_ls(b1, b2, a1) || is_point_on_ls(b1, b2, a2);\n}\n\nstruct state {\n\tint p;\n\tdouble d;\n\tstate(int p, double d) : p(p), d(d) {};\n\tbool operator<(const state &o)const {\n\t\treturn o.d<d;\n\t}\n};\n\nint main() {\n\tint NA, NB;\n\tcin >> NA >> NB;\n\n\tvector<P> pA(NA), pB(NB);\n\tdouble x, y;\n\tREP(i, NA) {\n\t\tcin >> x >> y;\n\t\tpA[i] = P(x, y);\n\t}\n\tREP(i, NB) {\n\t\tcin >> x >> y;\n\t\tpB[i] = P(x, y);\n\t}\n\n\tcout.precision(16);\n\tif(is_intersected_ls(pA[0], pA[1], pB[0], pB[1])) {\n\t\tdouble ans = INF;\n\t\t\n\t\t{\n\t\tvvd distA(NA, vd(NA, INF));\n\t\tREP(i, NA-1) {\n\t\t\tFOR(j, i+1, NA-1) {\n\t\t\t\tif(!is_intersected_ls(pA[i], pA[j], pB[0], pB[1])) {\n\t\t\t\t\tdistA[i][j] = distA[j][i] = abs(pA[i]-pA[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(0, 0));\n\t\tvd costA(NA, INF);\n\t\tcostA[0] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(st.p == 1) {\n\t\t\t\tans = min(ans, abs(pB[0]-pB[1])+st.d);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, NA) {\n\t\t\t\tif(st.p != i && !EQ(distA[st.p][i], INF)) {\n\t\t\t\t\tdouble nd = st.d+distA[st.p][i];\n\t\t\t\t\tif(LT(nd, costA[i])) {\n\t\t\t\t\t\tcostA[i] = nd;\n\t\t\t\t\t\tQ.push(state(i, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\t{\n\t\tvvd distB(NB, vd(NB, INF));\n\t\tREP(i, NB-1) {\n\t\t\tFOR(j, i+1, NB-1) {\n\t\t\t\tif(!is_intersected_ls(pB[i], pB[j], pA[0], pA[1])) {\n\t\t\t\t\tdistB[i][j] = distB[j][i] = abs(pB[i]-pB[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(0, 0));\n\t\tvd costB(NB, INF);\n\t\tcostB[0] = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\tif(st.p == 1) {\n\t\t\t\tans = min(ans, abs(pA[0]-pA[1])+st.d);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, NB) {\n\t\t\t\tif(st.p != i && !EQ(distB[st.p][i], INF)) {\n\t\t\t\t\tdouble nd = st.d+distB[st.p][i];\n\t\t\t\t\tif(LT(nd, costB[i])) {\n\t\t\t\t\t\tcostB[i] = nd;\n\t\t\t\t\t\tQ.push(state(i, nd));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\n\t\tif(EQ(ans, INF)) {\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t} else {\n\t\tcout << abs(pA[0]-pA[1])+abs(pB[0]-pB[1]) << endl;;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \nusing namespace std;\n \ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n \nusing R=long double; // __float128\nusing VR = vector<R>;\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n \nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n \nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n \nnamespace std{\n    bool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n    bool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n \ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n \n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n \n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n    if (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n    if (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n    if (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n    if (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n    return ON;// base--b--a on line  a??¨b????????????????????????\n}\n \n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n \n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n \n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n    int s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n    int s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n    if(end) return (s1&s2)==(LEFT|RIGHT);\n    return (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n \n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n    R s1=det(a.s,b.s,b.t);\n    R s2=s1+det(a.t,b.t,b.s);\n    return a.s+s1/s2*(a.t-a.s);\n}\n     \n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n    if(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n    if(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n    return abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nusing vi = vector<int>;\n\nint nn[2];\nVP points[2];\nR res = INF;\n\nusing State = tuple<R, int>;\n\nvoid solve(int idx){\n    L seg = { points[idx][0], points[idx][1] };\n    VP & ps = points[not idx];\n\n    int n = nn[not idx];\n    vector<VR> dist(n, VR(n, INF));\n\n    rep(i, n) dist[i][i] = 0.0;\n    rep(i, n){\n        rep(j, i + 1, n){\n            L cseg = { ps[i], ps[j] };\n            if(iss(cseg, seg)) continue;\n            \n            P aaa = cseg.t - cseg.s;\n            dist[i][j] = dist[j][i] = sq(real(aaa) * real(aaa) + imag(aaa) * imag(aaa));\n        }\n    }\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, 0));\n\n     VR min_dist(n, INF);\n\n    while(q.size()){\n        R cd; int cv;\n        tie(cd, cv) = q.top();\n        q.pop();\n\n        if(min_dist[cv] != INF) continue;\n        min_dist[cv] = cd;\n\n        rep(nv, n){\n            if(min_dist[nv] == INF and dist[cv][nv] != INF){\n                q.push(State(cd + dist[cv][nv], nv));\n            }\n        }\n    }\n\n    P aaa = seg.t - seg.s;\n    R d = sq(real(aaa) * real(aaa) + imag(aaa) * imag(aaa));\n    chmin(res, min_dist[1] + d);\n}\n\nint main(void){\n    for(auto & e : nn) cin >> e;\n\n    rep(i, 2){\n        points[i] = VP(nn[i]);\n        for(auto & e : points[i]){\n            cin >> e;\n        }\n    }\n\n    solve(0);\n    // swap(nn[0], nn[1]);\n    // swap(points[0], points[1]);\n    solve(1);\n\n    if(res == INF){\n        cout << -1 << endl;\n    }\n    else {\n        cout.precision(20);\n        cout << fixed << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\nstruct L : public vector<P>\n{\n\tL(P a, P b) { push_back(a); push_back(b); }\n};\n\n\n#define EPS\t\t\t(1e-10)\n#define PI\t\t\t(3.14159265358979323846)\n#define INF\t\t\t1e30\n\n#define X(a)\t\t( (a).real() )\n#define Y(a)\t\t( (a).imag() )\n#define EQ(a,b)\t\t( -EPS<(a)-(b) && (a)-(b)<EPS )\n#define EQV(a,b)\t( EQ(X(a),X(b)) && EQ(Y(a),Y(b)) )\n\n#define unit(a)\t\t( (a)/abs(a) )\n#define normal(a)\t( (a)*P(0,1) )\n#define dot(a,b)\t( X((a)*conj(b)) )\n#define cross(a,b)\t( Y(conj(a)*(b)) )\n\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t// a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(P a, P b, P c, P d)\n{\n\treturn\tccw(a,b,c)*ccw(a,b,d) <= 0 &&\n\t\t\tccw(c,d,a)*ccw(c,d,b) <= 0;\n}\n\ndouble graph[1000][1000];\n\nvoid makeGraph(vector<P>& towns, P a, P b)\n{\n\tfor(int i=0; i<towns.size(); i++)\n\tfor(int j=i+1; j<towns.size(); j++)\n\t{\n\t\tgraph[i][j] = graph[j][i] = graph[i][i] = graph[j][j] = INF;\n\t\tif(intersectSS(towns[i], towns[j], a,b)) continue;\n\t\tgraph[i][j] = graph[j][i] = abs(towns[i] - towns[j]);\n\t}\n}\n\nclass State\n{\npublic:\n\tint n;\n\tdouble c;\n\tState(int n, double c)\n\t\t:n(n),c(c)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\treturn c>s.c;\n\t}\n};\n\ndouble dijkstra(int N)\n{\n\tpriority_queue<State> q;\n\tq.push(State(0,0));\n\n\tbool visited[1000] = {0};\n\n\twhile(!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\tif(s.n == 1) return s.c;\n\n\t\tif(visited[s.n]) continue;\n\t\tvisited[s.n] = true;\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tif(graph[s.n][i] == INF) continue;\n\t\t\tif(visited[i]) continue;\n\n\t\t\tq.push(State(i,s.c+graph[s.n][i]));\n\t\t}\n\t}\n\treturn INF;\n}\n\nvoid solve(vector<P>& totata, vector<P>& tutete)\n{\n\tdouble res = INF;\n\tfor(int i=0; i<2; i++) {\n\t\tmakeGraph(totata, tutete[0], tutete[1]);\n\t\tres = min(res, dijkstra(totata.size()) + abs(tutete[0]-tutete[1]));\n\t\tswap(totata, tutete);\n\t}\n\n\tif(res == INF) cout << -1 << endl;\n\telse {\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(13);\n\t\tcout << res << endl;\n\t}\n\n}\n\nint main()\n{\n\tint M,N;\n\tcin >> M >> N;\n\tvector<P> totata(M), tutete(N);\n\n\tfor(int i=0; i<M; i++) {\n\t\tdouble a,b;\n\t\tcin >> a >> b;\n\t\ttotata[i] = P(a,b);\n\t}\n\n\tfor(int i=0; i<N; i++) {\n\t\tdouble a,b;\n\t\tcin >> a >> b;\n\t\ttutete[i] = P(a,b);\n\t}\n\n\tsolve(totata, tutete);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <functional>\n#include <queue>\n#include <complex>\nusing namespace std;\n\n\ntypedef double W;\n\nconst double EPoS = 1e-8;\nconst W INF = 1e10;\n\nstruct edge {\n\tint to;\n\tW cost;\n};\ntypedef pair<W, int> P;\ntypedef vector<vector <edge > > Graph;\n\nvoid dijkstra(int s, const Graph G, vector<W>& d) {\n\tpriority_queue< P, vector<P>, greater<P> > que;\n\tfill(d.begin(), d.end(), INF);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\ntypedef complex<double> Po;\nnamespace std {\n\tbool operator < (const Po& a, const Po& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const Po& a, const Po& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const Po& a, const Po& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<Po> {\n\tL(const Po &a, const Po &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(Po a, Po b, Po c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;       // counter clockwise\n\tif(cross(b, c) < 0)   return -1;       // clockwise\n\tif(dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif(norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint na, nb;\n\tcin >> na >> nb;\n\n\tvector<Po> ps[2];\n\tfor(int i = 0; i < na; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tps[0].push_back(Po(x, y));\n\t}\n\tfor(int i = 0; i < nb; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tps[1].push_back(Po(x, y));\n\t}\n\n\tdouble ans = INF;\n\tfor(int loop = 0; loop < 2; loop++) {\n\t\tGraph G(na);\n\t\tdouble sum = 0;\n\t\tsum += abs(ps[1][0] - ps[1][1]);\n\t\tL line(ps[1][0], ps[1][1]);\n\n\t\tfor(int i = 0; i < na; i++) {\n\t\t\tfor(int j = i + 1; j < na; j++) {\n\t\t\t\tL l1(ps[0][i], ps[0][j]);\n\t\t\t\tif(intersectSS(line, l1)) continue;\n\t\t\t\tG[i].push_back(edge{ j, abs(ps[0][i] - ps[0][j]) });\n\t\t\t\tG[j].push_back(edge{ i, abs(ps[0][i] - ps[0][j]) });\n\t\t\t}\n\t\t}\n\n\t\tvector<W> d(na);\n\t\tdijkstra(0, G, d);\n\t\tsum += d[1];\n\t\tans = min(ans, sum);\n\t\tswap(na, nb);\n\t\tswap(ps[0], ps[1]);\n\t}\n\tif(ans == INF) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << setprecision(15) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#include <complex>\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define EQ(x, y) (abs((x)-(y)) < EPS)\n\nconst double MAX=INT_MAX/10;\nconst double NONE=-1;\n\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_point_on_line(P a, P b, P c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2)\n{\n\tif ( (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS) &&\n\t\t\t(cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS) ) {\n\t\treturn true;\n\t}\n\treturn is_point_on_line(a1, a2, b1) ||\n\t\tis_point_on_line(a1, a2, b2) ||\n\t\tis_point_on_line(b1, b2, a1) ||\n\t\tis_point_on_line(b1, b2, a2);\n}\n\nstruct node{\n\tint index;\n\tdouble cost;\n\tnode(int index, double cost):index(index),cost(cost){}\n\tbool operator<(const node& other)const {\n\t\treturn cost>other.cost;\n\t}\n};\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nint main()\n{\n\t\tcout.precision(16);\n\tint na,nb;\n\tcin>>na>>nb;\n\t\n\tvector<P> a(na),b(nb);\n\tREP(i,na){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ta[i]=P(x,y);\n\t}\n\tREP(i,nb){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tb[i]=P(x,y);\n\t}\n\n\tif(!is_intersected_ls(a[0],a[1],b[0],b[1])){\n\t\tcout<<abs(a[0]-a[1])+abs(b[0]-b[1])<<endl;\n\t}else{\n\t\tdouble ans=MAX;\n\t\tREP(ab,2){\n\t\t\tvector<P> ps;\n\t\t\tint n;\n\t\t\tP fixed_p1,fixed_p2;\n\t\t\tif(ab==0){\n\t\t\t\tps=a;\n\t\t\t\tn=na;\n\t\t\t\tfixed_p1=b[0];\n\t\t\t\tfixed_p2=b[1];\n\t\t\t}else{\n\t\t\t\tps=b;\n\t\t\t\tn=nb;\n\t\t\t\tfixed_p1=a[0];\n\t\t\t\tfixed_p2=a[1];\n\t\t\t}\n\t\t\tvvd g(n,vd(n,NONE));\n\t\t\tREP(i,n){\n\t\t\t\tFOR(j,i+1,n){\n\t\t\t\t\tif(!is_intersected_ls(fixed_p1,fixed_p2,ps[i],ps[j])){\n\t\t\t\t\t\tg[i][j]=abs(ps[i]-ps[j]);\n\t\t\t\t\t\tg[j][i]=abs(ps[i]-ps[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint start=0;\n\t\t\tint goal=1;\n\t\t\tpriority_queue<node> q;\n\t\t\tq.push(node(start,0));\n\t\t\tvd cost(n,MAX);\n\t\t\tcost[start]=0;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tnode cnode = q.top(); q.pop();\n\t\t\t\tif(cost[cnode.index]<cnode.cost) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tREP(i,n){\n\t\t\t\t\tif(i!=cnode.index&&g[cnode.index][i]!=NONE){\n\t\t\t\t\t\tdouble newcost=cnode.cost+g[cnode.index][i];\n\t\t\t\t\t\tif(cost[i]>newcost+EPS){\n\t\t\t\t\t\t\tcost[i]=newcost;\n\t\t\t\t\t\t\tq.push(node(i,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=min(ans,cost[goal]+abs(fixed_p1-fixed_p2));\n\t\t}\n\t\tcout<<(ans==MAX?-1:ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \nusing namespace std;\n \ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n \nusing R=long double; // __float128\nusing VR = vector<R>;\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n \nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n \nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n \nnamespace std{\n    bool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n    bool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n \ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n \n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n \n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n    if (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n    if (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n    if (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n    if (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n    return ON;// base--b--a on line  a??¨b????????????????????????\n}\n \n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n \n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n \n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n    int s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n    int s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n    if(end) return (s1&s2)==(LEFT|RIGHT);\n    return (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n \n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n    R s1=det(a.s,b.s,b.t);\n    R s2=s1+det(a.t,b.t,b.s);\n    return a.s+s1/s2*(a.t-a.s);\n}\n     \n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n    if(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n    if(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n    return abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\nusing vi = vector<int>;\n\nint nn[2];\nVP points[2];\nR res = INF;\n\nusing State = tuple<R, int>;\n\nvoid solve(int idx){\n    L seg = { points[idx][0], points[idx][1] };\n    VP & ps = points[not idx];\n\n    int n = nn[not idx];\n    vector<VR> dist(n, VR(n, INF));\n\n    rep(i, n) dist[i][i] = 0.0;\n    rep(i, n){\n        rep(j, i + 1, n){\n            L cseg = { ps[i], ps[j] };\n            if(iss(cseg, seg)) continue;\n            \n            dist[i][j] = dist[j][i] = sq(dot(cseg.s, cseg.t, cseg.t));\n        }\n    }\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    q.push(State(0, 0));\n\n     VR min_dist(n, INF);\n\n    while(q.size()){\n        R cd; int cv;\n        tie(cd, cv) = q.top();\n        q.pop();\n\n        if(min_dist[cv] != INF) continue;\n        min_dist[cv] = cd;\n\n        rep(nv, n){\n            if(min_dist[nv] == INF and dist[cv][nv] != INF){\n                q.push(State(cd + dist[cv][nv], nv));\n            }\n        }\n    }\n\n    chmin(res, min_dist[1] + sq(dot(seg.s, seg.t, seg.t)));\n}\n\nint main(void){\n    for(auto & e : nn) cin >> e;\n\n    rep(i, 2){\n        points[i] = VP(nn[i]);\n        for(auto & e : points[i]){\n            cin >> e;\n        }\n    }\n\n    solve(0);\n    solve(1);\n\n    if(res == INF){\n        cout << -1 << endl;\n    }\n    else {\n        cout.precision(20);\n        cout << fixed << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double INF = 1e100;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool isIntersect(L s1, L s2){\n  \n  //ccw ??????????????????????????¨, ????????????????????´?????????????????¨??????????????????????????????\n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n\nint Na,Nb;\nP A[1111],B[1111];\n\nstruct edge{\n  int to;\n  double c;\n  bool operator<(const edge& e) const {\n    return c > e.c;\n  }\n};\n\nvector<edge> G[2][1111];\ndouble H[1111];\ndouble dijk(int fl){\n  fill(H,H+1001,INF);\n  priority_queue<edge> q;\n  q.push( (edge){0,0.0} );\n while( !q.empty() ){\n   edge p = q.top(); q.pop();\n   int id = p.to;\n    double c = p.c;\n    if( H[id] < c ) continue;\n    for(int i=0;i<(int)G[fl][id].size();i++){\n      edge e = G[fl][id][i];\n      if( H[e.to]  > e.c + c ){\n\tH[e.to] = e.c + c;\n\tq.push( (edge){e.to,H[e.to]} );\n      }\n    }\n  }\n return H[1];\n}\n\nint main(){\n  cin >> Na >> Nb;\n  for(int i=0;i<Na;i++)\n    cin >> A[i].real() >> A[i].imag();\n  for(int i=0;i<Nb;i++)\n    cin >> B[i].real() >> B[i].imag();\n\n\n  L s = L(B[0],B[1]);\n  for(int i=0;i<Na;i++){\n    for(int j=i+1;j<Na;j++){\n      L line = L(A[i],A[j]);\n      if( !isIntersect( s, line ) ){\n\tG[0][i].push_back((edge){j,abs(A[i]-A[j])});\n\tG[0][j].push_back((edge){i,abs(A[i]-A[j])});\n      }\n    }\n  }\n\n  s = L(A[0],A[1]);\n  for(int i=0;i<Nb;i++){\n    for(int j=i+1;j<Nb;j++){\n      L line = L(B[i],B[j]);\n      if( !isIntersect( s, line ) ){\n\tG[1][i].push_back((edge){j,abs(B[i]-B[j])});\n\tG[1][j].push_back((edge){i,abs(B[i]-B[j])});\n      }\n    }\n  }\n  \n  double res = min( abs(B[0]-B[1]) + dijk(0),\n\t\t    abs(A[0]-A[1]) + dijk(1) );\n  if( res > INF/10 ) cout << -1 << endl;\n  else printf(\"%.14lf\\n\",res);\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//線分を表す構造体\nstruct Segment{ Point p1, p2; };\n//直線を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n// 許容する誤差\n#define EPS (1e-10)\n\nint ccw(Point, Point, Point);\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n\treturn isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルの位置検出\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n\ndouble ga[1000][1000], gb[1000][1000];\n\nconst int MAX_V = 1000;\ndouble dijkstra(int n, int s, double g[MAX_V][MAX_V]){\n\tvector<double> dis(n,INF);\n\tpriority_queue<double, vector<pair<double, int>>, greater<pair<double, int>>> q;\n\n\tq.emplace(0,s);\n\tdis[s] = 0;\n\n\twhile(not q.empty()){\n\t\tint pos;\n\t\tdouble cost;\n\t\ttie(cost, pos) = q.top(); q.pop();\n\t\tif(pos == 1) break;\n\n\t\trep(to,n){\n\t\t\tif(dis[to] > cost + g[pos][to]){\n\t\t\t\tdis[to] = cost + g[pos][to];\n\t\t\t\tq.emplace(dis[to], to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[1];\n}\n\ndouble solve(double g[MAX_V][MAX_V], Segment s, vector<Point>& a){\n\tint n = a.size();\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(i == j) continue;\n\t\t\tif(isIntersectedLs(s, Segment{a[i], a[j]})){\n\t\t\t\tg[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\treturn dijkstra(n, 0, g);\n}\n\nvoid input(vector<Point>& a, int n){\n\trep(i,n){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\ta[i] = Point(x,y);\n\t}\n}\n\nvoid culDist(double g[MAX_V][MAX_V], vector<Point>& a, int n){\n\trep(i,n) rep(j,n) g[i][j] = abs(a[i] - a[j]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint na, nb;\n\tcin >> na >> nb;\n\n\tvector<Point> a(na), b(nb);\n\tinput(a, na);\n\tinput(b, nb);\n\n\tculDist(ga, a, na);\n\tculDist(gb, b, nb);\n\n\tdouble adis = ga[0][1];\n\tdouble bdis = gb[0][1];\n\n\tdouble ans = min<double>(\n\t\t\tsolve(gb, Segment{a[0], a[1]}, b) + adis,\n\t\t\tsolve(ga, Segment{b[0], b[1]}, a) + bdis\n\t\t\t);\n\tcout << fixed << setprecision(10) << (ans >= INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<double, int> P;\ntypedef pair<int, int> Point;\ntypedef pair<Point, Point> Segment; // (frm, to)\nconst double eps = 1e-9;\n\ndouble norm(Point a) {\n    return sqrt(a.first * a.first + a.second * a.second);\n}\nPoint getv(Point frm, Point to) {\n    return Point(to.first - frm.first, to.second - frm.second);\n}\nPoint getv(Segment a) {\n    return getv(a.first, a.second);\n}\ndouble dist(Point a, Point b) {\n    return norm(getv(a, b));\n}\ndouble getlen(Segment a) {\n    return dist(a.first, a.second);\n}\n\nint cross(Point v, Point w) {\n    return v.first * w.second - v.second * w.first;\n}\nbool iscross(Segment a, Segment b) {\n    return (cross(getv(a), getv(a.first, b.first)) > 0) != (cross(getv(a), getv(a.first, b.second)) > 0) && (cross(getv(b), getv(b.first, a.first)) > 0) != (cross(getv(b), getv(b.first, a.second)) > 0);\n}\n\n\n\nvector<double> dijkstra(int s, vector<vector<P>> edge) {\n    int n = edge.size();\n    vector<double> dist(n, 1e16);\n    priority_queue<P, vector<P>, greater<P>> q;\n    dist[s] = 0;\n    q.push(P(0, s));\n    while (!q.empty()) {\n        P p = q.top();\n        q.pop();\n        for (auto& e : edge[p.second]) {\n            if (dist[e.second] > p.first + e.first) {\n                dist[e.second] = p.first + e.first;\n                q.push(P(p.first + e.first, e.second));\n            }\n        }\n    }\n    return dist;\n}\n\n\n\nint main() {\n    int na, nb;\n    cin >> na >> nb;\n    vector<P> a(na);\n    vector<P> b(nb);\n    for (int i = 0; i < na; ++i)\n        cin >> a[i].first >> a[i].second;\n    for (int i = 0; i < nb; ++i)\n        cin >> b[i].first >> b[i].second;\n\n    Segment sa = Segment(a[0], a[1]);\n    Segment sb = Segment(b[0], b[1]);\n    vector<vector<P>> eda(na);\n    vector<vector<P>> edb(nb);\n    for (int i = 0; i < na; ++i) {\n        for (int j = i + 1; j < na; ++j) {\n            if (!iscross(Segment(a[i], a[j]), sb)) {\n                eda[i].push_back(P(dist(a[i], a[j]), j));\n                eda[j].push_back(P(dist(a[i], a[j]), i));\n            }\n        }\n    }\n    for (int i = 0; i < nb; ++i) {\n        for (int j = i + 1; j < nb; ++j) {\n            if (!iscross(Segment(b[i], b[j]), sa)) {\n                edb[i].push_back(P(dist(b[i], b[j]), j));\n                edb[j].push_back(P(dist(b[i], b[j]), i));\n            }\n        }\n    }\n    double ans = min(getlen(sa) + dijkstra(0, edb)[1], getlen(sb) + dijkstra(0, eda)[1]);\n    if (ans > 1e15)\n        puts(\"-1\");\n    else\n        printf(\"%.16lf\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld inf = 1e30;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to});\n      g[to].push_back((Edge){to, from});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nstruct MyEdge {\n\tint to;\n\tld dist;\n};\nbool operator >(const MyEdge& e1, const MyEdge& e2) {\n\treturn e1.dist > e2.dist;\n}\n\nld solve(vector<Point> a, vector<Point> b) {\n\tLine bl(b[0], b[1]);\n\tint N = a.size();\n/*\n\tvector< vector<MyEdge> > G(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (i != j && !isis_ss(bl, Line(a[i], a[j]))) {\n\t\t\t\tld d = abs(a[i]-a[j]);\n\t\t\t\tG[i].push_back( (MyEdge){j, d} );\n\t\t\t\tG[j].push_back( (MyEdge){i, d} );\n\t\t\t}\n\t\t}\n\t}\n*/\n\tvector<ld> dist(N, inf);\n\tpriority_queue<MyEdge, vector<MyEdge>, greater<MyEdge> > Q; Q.push({0, 0});\n\twhile ( !Q.empty() ) {\n\t\tMyEdge q = Q.top(); Q.pop();\n\t\tint v = q.to;\n\t\tif (q.dist > dist[v] || eq(q.dist, dist[v])) {\n\t\t\tcontinue;\n\t\t}\n\t\tdist[v] = q.dist;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (i != v && !isis_ss(bl, Line(a[i], a[v]))) {\n\t\t\t\tQ.push( (MyEdge){i, dist[v]+abs(a[i]-a[v])} );\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[1]+abs(b[0]-b[1]);\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<Point> a, b;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\ta.push_back( Point(x, y) );\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tb.push_back( Point(x, y) );\n\t}\n\tld ans = min( solve(a, b), solve(b, a) );\n\tif ( eq(ans, inf) ) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << fixed << setprecision(12) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double INF = 1e9;\nconst int MOD = 1000000007;\n\n#include <complex>\n#include <cmath>\n#define EPS 1.0e-10\n#define PI 3.1415926535897932384 \n\n// 実数の符号関数\ninline int signum(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n//XY座標\n#define X real()\n#define Y imag()\n// 点\ntypedef complex<double> P;\n \n\n// 線分・半直線・直線\nstruct L { P pos, dir; L(P p=P(), P d=P()):pos(p),dir(d){}};\n\n// 多角形\ntypedef vector<P> G;\n \n// 円\nstruct C { P p; double r; C(P q=P(), double R=0):p(q),r(R){}};\n\n// std::norm はabs(p)*abs(p)なので遅い\ninline double norm(P p){\n\treturn p.X*p.X+p.Y*p.Y;\n}\n\n// 二つのベクトルの内積を計算する\ninline double inp(const P& a, const P& b) {\n\treturn (conj(a)*b).X;\n}\n \n// 二つのベクトルの外積を計算する\ninline double outp(const P& a, const P& b) {\n\treturn (conj(a)*b).Y;\n}\n\ninline int ccw(const P& p, const P& r, const P& s) {\n    P a(r-p), b(s-p);\n    int sgn = signum(outp(a, b));\n    if (sgn != 0)\n        return sgn;\n    if (a.X*b.X < -EPS || a.Y*b.Y < -EPS)\n        return -1;\n    if (norm(a) < norm(b) - EPS)\n        return 1;\n    return 0;\n}\n\nbool ss_intersects(const L& s, const L& t) {\n    return (ccw(s.pos, s.pos+s.dir, t.pos) *\n            ccw(s.pos, s.pos+s.dir, t.pos+t.dir) <= 0 &&\n            ccw(t.pos, t.pos+t.dir, s.pos) *\n            ccw(t.pos, t.pos+t.dir, s.pos+s.dir) <= 0);\n}\n\nint Na, Nb;\n\ndouble solve(const vector<P> &A, const vector<P> &B){\n\tdouble res = abs(A[0] - A[1]);\n\tL Ar(A[0], A[1] - A[0]);\n\t\n\tvector< vector<pair<int, double>> > g(B.size());\n\tREP(i, B.size())REP(j, i){\n\t\tL Br(B[i], B[j] - B[i]);\n\t\tif(!ss_intersects(Ar, Br)){\n\t\t\tg[i].emplace_back(j, abs(B[i] - B[j]));\n\t\t\tg[j].emplace_back(i, abs(B[i] - B[j]));\n\t\t}\n\t}\n\tvector<double> ret(B.size(), INF);\n\tpriority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>> > dp;\n\tdp.push(pii(.0, 0));\n\tret[0] = .0;\n\twhile(!dp.empty()){\n\t\tint s = dp.top().second;\n\t\tdouble c = dp.top().first;\n\t\tdp.pop();\n\t\tif(s == 1){\n\t\t\treturn res + c;\n\t\t}\n\t\tif(ret[s] < c) continue;\n\t\tFOR(it, g[s]){\n\t\t\tint t = it->first;\n\t\t\tif(ret[t]-EPS > ret[s]+it->second){\n\t\t\t\tret[t] = ret[s]+it->second;\n\t\t\t\tdp.emplace(ret[t], t);\n\t\t\t}\n\t\t}\n\t}\n\treturn INF;\n}\n\nmain(){\n\tcin >> Na >> Nb;\n\tvector<P> A, B;\n\tREP(i, Na){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tA.emplace_back(x, y);\n\t}\n\tREP(i, Nb){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tB.emplace_back(x, y);\n\t}\n\tdouble res = min(solve(A, B), solve(B, A));\n\tif(res+1.0 > INF) puts(\"-1\");\n\telse printf(\"%.12f\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\nint main()\n{\n\tint n,m;\n\tcin >> n >> m;\n\tG g[2] = { G(n) , G(m) };\n\tfor(int i = 0 ; i < n ; i++){\n\t\tcin >> g[0][i].real() >> g[0][i].imag();\n\t}\n\tfor(int i = 0 ; i < m ; i++){\n\t\tcin >> g[1][i].real() >> g[1][i].imag();\n\t}\n\t\n\tdouble A = abs(g[0][0]-g[0][1]) , B = abs(g[1][0]-g[1][1]);\n\tdouble D[2] = {INF,INF};\n\n\tfor(int s = 0 ; s < 2 ; s++){\n\t\tbool done[1000] = {};\n\t\tpriority_queue< pair<double,int> , vector< pair<double,int> > , greater< pair<double,int> > > Q;\n\t\tQ.push(make_pair(0,0));\n\t\twhile(Q.size()){\n\t\t\tdouble cost = Q.top().first;\n\t\t\tint pos = Q.top().second;\n\t\t\tQ.pop();\n\t\t\tif(done[pos]) continue;\n\t\t\telse done[pos] = true;\n\t\t\tif(pos == 1){\n\t\t\t\tD[s] = cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < (s?m:n) ; i++){\n\t\t\t\tif(!intersectSS(L(g[s][pos],g[s][i]),L(g[!s][0],g[!s][1]))) Q.push(make_pair(cost+abs(g[s][pos]-g[s][i]),i));\n\t\t\t}\n\t\t}\n\t}\n\tdouble answer = min(A+D[1],B+D[0]);\n\tif(answer > 1e10){\n\t\tcout << -1 << endl;\n\t}else{\n\t\tprintf(\"%.10lf\\n\",answer);\n\t}\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\nconst double eps = 1e-8;\ndouble dot(P a, P b) { return real(conj(a) * b); }\ndouble cross(P a, P b) { return imag(conj(a) * b); }\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;\n    if (cross(b, c) < -eps) return -1;\n    if (dot(b, c) < -eps) return 2;\n    if (norm(c) > norm(b)) return -2;\n    return 0;\n}\nbool intersectSS(P p1, P p2, P p3, P p4) {\n    return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\nint n,m;long double ax[1000],ay[1000],bx[1000],by[1000],dist[1000];\nvector<pair<int,long double> >x[1000];\nlong double dijkstra(int s,int t){\n\tpriority_queue<pair<long double,int>,vector<pair<long double,int> >,greater<pair<long double,int> > >Q;\n\tQ.push(make_pair(0.0L,s));for(int i=0;i<1000;i++)dist[i]=1e9;dist[s]=0.0L;\n\twhile(!Q.empty()){\n\t\tlong double a1=Q.top().first;int a2=Q.top().second;Q.pop();\n\t\tfor(int i=0;i<(int)x[a2].size();i++){\n\t\t\tif(dist[x[a2][i].first]>a1+x[a2][i].second){\n\t\t\t\tdist[x[a2][i].first]=a1+x[a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[x[a2][i].first],x[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[t];\n}\nint main(){\n\tcin>>n>>m;for(int i=0;i<n;i++)cin>>ax[i]>>ay[i];\n\tfor(int i=0;i<m;i++)cin>>bx[i]>>by[i];\n\tfor(int i=0;i<1000;i++)x[i].clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(intersectSS(P(ax[i],ay[i]),P(ax[j],ay[j]),P(bx[0],by[0]),P(bx[1],by[1]))==0){\n\t\t\t\tlong double dst1=sqrtl((ax[i]-ax[j])*(ax[i]-ax[j])+(ay[i]-ay[j])*(ay[i]-ay[j]));\n\t\t\t\tx[i].push_back(make_pair(j,dst1));\n\t\t\t\tx[j].push_back(make_pair(i,dst1));\n\t\t\t}\n\t\t}\n\t}\n\tlong double r1=dijkstra(0,1);\n\tfor(int i=0;i<1000;i++)x[i].clear();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(intersectSS(P(bx[i],by[i]),P(bx[j],by[j]),P(ax[0],ay[0]),P(ax[1],ay[1]))==0){\n\t\t\t\tlong double dst1=sqrtl((bx[i]-bx[j])*(bx[i]-bx[j])+(by[i]-by[j])*(by[i]-by[j]));\n\t\t\t\tx[i].push_back(make_pair(j,dst1));\n\t\t\t\tx[j].push_back(make_pair(i,dst1));\n\t\t\t}\n\t\t}\n\t}\n\tlong double r2=dijkstra(0,1);\n\tprintf(\"%.15Lf\\n\",min(r1,r2));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2334 Roads on Towns\n// 2018.2.24 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS\t\t\t1e-10\n#define INF\t\t\t1e20\ntypedef struct { double x, y; } PP;\n\nPP p[2][1002];\n\nPP vectorSub(PP *p1, PP *p2) { PP r; r.x = p1->x - p2->x, r.y = p1->y - p2->y; return r; }\ndouble cross(PP *a, PP *b) { return a->x * b->y - a->y * b->x; }\ndouble dot(PP *a, PP *b) { return a->x * b->x + a->y * b->y; }\ndouble norm(PP *a) { return a->x * a->x + a->y * a->y; }\n\nint ccw(PP *p0, PP *p1, PP *p2)\n{\n\tPP a = vectorSub(p1, p0), b = vectorSub(p2, p0);\n\tdouble t = cross(&a, &b);\n\tif (t >  EPS) return 1;\n\tif (t < -EPS) return -1;\n\tif (dot(&a, &b) < -EPS) return 2;\n\tif (norm(&a) < norm(&b)) return -2;\n\treturn 0;\n}\n\nint intersect(PP *p1, PP *p2, PP *p3, PP *p4)\n{\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\ndouble dist(PP *p1, PP *p2) { return hypot(p1->x - p2->x, p1->y - p2->y); }\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ndouble calc(PP *s, PP *g, PP *a, int n, PP *es, PP *eg)\n{\n\tint i, j;\n\tdouble ans, x, y, z;\n\n\tif (!intersect(s, g, es, eg)) return dist(s, g);\n\tif (n == 0) return INF+100;\n\n\tans = INF+100;\n\tfor (i = 0; i < n; i++) {\n\t\tif (intersect(s, a+i, es, eg)) continue;\n\t\tx = dist(s, a+i);\n\t\tif (x >= ans) continue;\n\t\tif (!intersect(g, a+i, es, eg)) {\n\t\t\ty = dist(g, a+i);\n\t\t\tif (x + y < ans) ans = x + y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < n; j++) if (j != i) {\n\t\t\tif (intersect(a+i, a+j, es, eg)) continue;\n\t\t\ty = dist(a+i, a+j);\n\t\t\tif (x + y  >= ans) continue;\n\t\t\tif (!intersect(g, a+j, es, eg)) {\n\t\t\t\tz = dist(g, a+j);\n\t\t\t\tif (x + y + z < ans) ans = x + y + z;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint i, j, n[2];\n\tPP s[2], g[2];\n\tdouble ans, x;\n\n\tn[0] = in()-2, n[1] = in()-2;\n\tfor (i = 0; i < 2; i++) {\n\t\ts[i].x = in(), s[i].y = in();\n\t\tg[i].x = in(), g[i].y = in();\n\t\tfor (j = 0; j < n[i]; j++) p[i][j].x = in(), p[i][j].y = in();\n\t}\n\n\tans = INF+100;\n\tfor (i = 0; i < 2; i++) {\n\t\tx = dist(s+1-i, g+1-i) + calc(s+i, g+i, p[i], n[i], s+1-i, g+1-i);\n\t\tif (x < ans) ans = x;\n\t}\n\n\tif (ans >= INF) puts(\"-1\");\n\telse printf(\"%.12lf\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2334 Roads on Towns\n// 2018.2.24 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS\t\t\t1e-10\n#define INF\t\t\t1e20\ntypedef struct { double x, y; } PP;\n\nPP p[2][1002];\n\nPP vectorSub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\ndouble vectorAbs(PP a) { return hypot(a.x, a.y); }\n\nint ccw(PP p0, PP p1, PP p2)\n{\n\tPP a = vectorSub(p1, p0), b = vectorSub(p2, p0);\n\tdouble t = cross(a, b);\n\tif (t >  EPS) return 1;\n\tif (t < -EPS) return -1;\n\tif (dot(a, b) < -EPS) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\n\nint intersect(PP p1, PP p2, PP p3, PP p4)\n{\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ndouble calc(PP s, PP g, PP *a, int n, PP es, PP eg)\n{\n\tint i, j;\n\tdouble ans, x, y;\n\n\tif (!intersect(s, g, es, eg)) return vectorAbs(vectorSub(s, g));\n\tif (n == 0) return INF+100;\n\n\tans = INF+100;\n\tfor (i = 0; i < n; i++) {\n\t\tif (intersect(s, a[i], es, eg)) continue;\n\t\tx = vectorAbs(vectorSub(s, a[i]));\n\t\tif (!intersect(g, a[i], es, eg)) {\n\t\t\ty = vectorAbs(vectorSub(g, a[i]));\n\t\t\tif (x + y < ans) ans = x + y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < n; j++) if (j != i) {\n\t\t\tif (intersect(a[i], a[j], es, eg)) continue;\n\t\t\tif (!intersect(g, a[j], es, eg)) {\n\t\t\t\ty = vectorAbs(vectorSub(a[i], a[j])) + vectorAbs(vectorSub(g, a[j]));\n\t\t\t\tif (x + y < ans) ans = x + y;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint i, j, n[2];\n\tPP s[2], g[2];\n\tdouble ans, x;\n\n\tn[0] = in()-2, n[1] = in()-2;\n\tfor (i = 0; i < 2; i++) {\n\t\ts[i].x = in(), s[i].y = in();\n\t\tg[i].x = in(), g[i].y = in();\n\t\tfor (j = 0; j < n[i]; j++) p[i][j].x = in(), p[i][j].y = in();\n\t}\n\n\tans = INF+100;\n\tfor (i = 0; i < 2; i++) {\n\t\tx = vectorAbs(vectorSub(s[1-i], g[1-i])) + calc(s[i], g[i], p[i], n[i], s[1-i], g[1-i]);\n\t\tif (x < ans) ans = x;\n\t}\n\n\tif (ans >= INF) puts(\"-1\");\n\telse printf(\"%.12lf\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2334 Roads on Towns\n// 2018.2.24 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS\t\t\t1e-10\n#define INF\t\t\t1e20\ntypedef struct { double x, y; } PP;\n\nPP p[2][1002];\n\nPP vectorSub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\ndouble vectorAbs(PP a) { return hypot(a.x, a.y); }\n\nint ccw(PP p0, PP p1, PP p2)\n{\n\tPP a = vectorSub(p1, p0), b = vectorSub(p2, p0);\n\tdouble t = cross(a, b);\n\tif (t >  EPS) return 1;\n\tif (t < -EPS) return -1;\n\tif (dot(a, b) < -EPS) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\n\nint intersect(PP p1, PP p2, PP p3, PP p4)\n{\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ndouble calc(PP s, PP g, PP *a, int n, PP es, PP eg)\n{\n\tint i, j;\n\tdouble ans, x, y, z;\n\n\tif (!intersect(s, g, es, eg)) return vectorAbs(vectorSub(s, g));\n\tif (n == 0) return INF+100;\n\n\tans = INF+100;\n\tfor (i = 0; i < n; i++) {\n\t\tif (intersect(s, a[i], es, eg)) continue;\n\t\tx = vectorAbs(vectorSub(s, a[i]));\n\t\tif (x >= ans) continue;\n\t\tif (!intersect(g, a[i], es, eg)) {\n\t\t\ty = vectorAbs(vectorSub(g, a[i]));\n\t\t\tif (x + y < ans) ans = x + y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < n; j++) if (j != i) {\n\t\t\tif (intersect(a[i], a[j], es, eg)) continue;\n\t\t\ty = vectorAbs(vectorSub(a[i], a[j]));\n\t\t\tif (x + y  >= ans) continue;\n\t\t\tif (!intersect(g, a[j], es, eg)) {\n\t\t\t\tz = vectorAbs(vectorSub(g, a[j]));\n\t\t\t\tif (x + y + z < ans) ans = x + y + z;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint i, j, n[2];\n\tPP s[2], g[2];\n\tdouble ans, x;\n\n\tn[0] = in()-2, n[1] = in()-2;\n\tfor (i = 0; i < 2; i++) {\n\t\ts[i].x = in(), s[i].y = in();\n\t\tg[i].x = in(), g[i].y = in();\n\t\tfor (j = 0; j < n[i]; j++) p[i][j].x = in(), p[i][j].y = in();\n\t}\n\n\tans = INF+100;\n\tfor (i = 0; i < 2; i++) {\n\t\tx = vectorAbs(vectorSub(s[1-i], g[1-i])) + calc(s[i], g[i], p[i], n[i], s[1-i], g[1-i]);\n\t\tif (x < ans) ans = x;\n\t}\n\n\tif (ans >= INF) puts(\"-1\");\n\telse printf(\"%.12lf\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic ContestScanner in;\n\tstatic Writer out;\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\ttry {\n\t\t\tin = new ContestScanner();\n\t\t\tout = new Writer();\n\t\t\tmain.solve();\n\t\t\tout.close();\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid solve() throws IOException {\n\t\tint na = in.nextInt();\n\t\tint nb = in.nextInt();\n\t\tPos[] a = new Pos[na];\n\t\tPos[] b = new Pos[nb];\n\t\tfor(int i = 0; i < na; i++) {\n\t\t\ta[i] = new Pos(in.nextInt(), in.nextInt());\n\t\t}\n\t\tfor(int i = 0; i < nb; i++) {\n\t\t\tb[i] = new Pos(in.nextInt(), in.nextInt());\n\t\t}\n\t\tdouble ans = shortest(a, b[0], b[1]);\n\t\tans = Math.min(ans, shortest(b, a[0], a[1]));\n\t\tif(ans >= inf) out.println(-1);\n\t\telse out.println(ans);\n\t}\n\t\n\tfinal double inf = 1e9;\n\tdouble shortest(Pos[] p, Pos s1, Pos s2) {\n\t\tint n = p.length;\n\t\tdouble[] d = new double[n];\n\t\tArrays.fill(d, inf);\n\t\tQueue<St> qu = new PriorityQueue<>();\n\t\tqu.add(new St(0, 0));\n\t\twhile(!qu.isEmpty()) {\n\t\t\tSt s = qu.poll();\n\t\t\tif(d[s.p] < inf) continue;\n\t\t\td[s.p] = s.d;\n\t\t\tif(s.p == 1) {\n\t\t\t\treturn s1.dist(s2) + s.d;\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(d[i] < inf) continue;\n\t\t\t\tif(cross(s1, s2, p[s.p], p[i])) continue;\n\t\t\t\tqu.add(new St(i, s.d + p[s.p].dist(p[i])));\n\t\t\t}\n\t\t}\n\t\treturn inf;\n\t}\n\t\n\tstatic boolean cross(Pos p1, Pos p2, Pos p3, Pos p4){\n\t\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n\t}\n\tstatic double cross(Pos a, Pos b){\n\t\treturn a.x*b.y - b.x*a.y;\n\t}\n\tpublic static double cross(double x1, double y1, double x2, double y2){\n\t\treturn x1*y2 - x2*y1;\n\t}\n\t// ?????£??§?¨???§???????¨????????????£\n\t// ?????£???????????¶????????????\n\tstatic double ccw(Pos a, Pos b, Pos c){\n\t\tdouble dx1 = b.x - a.x;\n\t\tdouble dy1 = b.y - a.y;\n\t\tdouble dx2 = c.x - a.x;\n\t\tdouble dy2 = c.y - a.y;\n\t\treturn dx1*dy2 - dx2*dy1;\n\t}\n}\n\nclass St implements Comparable<St>{\n\tdouble d;\n\tint p;\n\tpublic St(int p, double d) {\n\t\tthis.p = p;\n\t\tthis.d = d;\n\t}\n\t@Override\n\tpublic int compareTo(St o) {\n\t\treturn Double.compare(d, o.d);\n\t}\n}\n\nclass Pos {\n\tint x, y;\n\tpublic Pos(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tdouble dist(Pos p) {\n\t\treturn Math.sqrt(sq(x - p.x) + sq(y - p.y));\n\t}\n\t\n\tlong sq(long a) {\n\t\treturn a * a;\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t\tif (ans == 28985.17494996295) {\n\t\t\t\t\t\ttr(ans, xa[0], ya[0], xa[i], ya[i], xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1]);\n\t\t\t\t\t\ttr(cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Roads on Towns\npublic class Main{\n\n\tint NA, NB;\n\tdouble INF = 1L<<50, res = INF;\n\n\tfinal double EPS = 1e-10;\n\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\n\tdouble[][][] p;\n\tint[] ua, ub;\n\tint ka, kb;\n\tdouble[][] pd;\n\t\n\tdouble[] d;\n\tdouble dijkstraA(double D){\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NA;i++){\n\t\t\t\tdouble w = d[v] + pd[v][i];\n//\t\t\t\tnorm(p[0][v], p[0][i]);\n\t\t\t\tif(res+EPS < w)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=kb&&ok;j++)if(crossing(p[1][ub[j]], p[1][ub[j+1]], p[0][v], p[0][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n\t\t\t\t\tq.remove(i); d[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\tdouble dijkstraB(double D){\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NB;i++){\n\t\t\t\tdouble w = d[v] + pd[NA+v][NA+i];\n//\t\t\t\tnorm(p[1][v], p[1][i]);\n\t\t\t\tif(res+EPS < w)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=ka&&ok;j++)if(crossing(p[0][ua[j]], p[0][ua[j+1]], p[1][v], p[1][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n\t\t\t\t\tq.remove(i); d[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tvoid fa(){\n\t\tdouble d = pd[0][1];\n//\t\tnorm(p[0][0], p[0][1]);\n\t\tua[1] = 1;\n\t\tka = 1;\n\t\tres = Math.min(res, d+dijkstraB(d));\n\t\tfor(int k=2;k<NA;k++){\n\t\t\td = pd[0][k] + pd[k][1];\n//\t\t\tnorm(p[0][0], p[0][k]) + norm(p[0][k], p[0][1]);\n\t\t\tka = 2;\n\t\t\tua[1] = k; ua[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraB(d));\n\t\t}\n\t}\n\tvoid fb(){\n\t\tdouble d = pd[NA][NA+1];\n//\t\tnorm(p[1][0], p[1][1]);\n\t\tub[1] = 1;\n\t\tkb = 1;\n\t\tres = Math.min(res, d+dijkstraA(d));\n\t\tfor(int k=2;k<NB;k++){\n\t\t\td = pd[NA][NA+k] + pd[NA+k][NA+1];\n//\t\t\tnorm(p[1][0], p[1][k]) + norm(p[1][k], p[1][1]);\n\t\t\tkb = 2;\n\t\t\tub[1] = k; ub[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraA(d));\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tNA = sc.nextInt(); NB = sc.nextInt();\n\t\tp = new double[2][][];\n\t\tp[0] = new double[NA][2]; p[1] = new double[NB][2];\n\t\tfor(int i=0;i<NA;i++)for(int j=0;j<2;j++)p[0][i][j]=sc.nextDouble();\n\t\tfor(int i=0;i<NB;i++)for(int j=0;j<2;j++)p[1][i][j]=sc.nextDouble();\n\t\tua = new int[NA]; ub = new int[NB];\n\t\td = new double[1000];\n\t\tpd = new double[NA+NB][NA+NB];\n\t\tfor(int i=0;i<NA;i++){\n\t\t\tfor(int j=0;j<NA;j++)pd[i][j] = norm(p[0][i], p[0][j]);\n\t\t\tfor(int j=0;j<NB;j++)pd[i][NA+j] = norm(p[0][i], p[1][j]);\n\t\t}\n\t\tfor(int i=0;i<NB;i++){\n\t\t\tfor(int j=0;j<NB;j++)pd[NA+i][NA+j] = norm(p[1][i], p[1][j]);\n\t\t\tfor(int j=0;j<NA;j++)pd[NA+i][j] = norm(p[1][i], p[0][j]);\n\t\t}\n\t\tfa(); fb();\n\t\tif(res==INF)System.out.println(-1);\n\t\telse System.out.printf(\"%.10f\\n\", res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\tsolve();\n\t\tio.flush();\n\t}\n\tpublic static boolean solve() {\n\t\tint n1 = io.nextInt();\n\t\tint n2 = io.nextInt();\n\t\tVector2[] p1 = new Vector2[n1];\n\t\tVector2[] p2 = new Vector2[n2];\n\t\tfor(int i=0;i<n1;i++) {\n\t\t\tp1[i] = new Vector2(io.nextInt(), io.nextInt());\n\t\t}\n\t\tfor(int i=0;i<n2;i++) {\n\t\t\tp2[i] = new Vector2(io.nextInt(), io.nextInt());\n\t\t}\n\t\tdouble ans = Math.min(solveHalf(n1, p1, p2[0], p2[1]), solveHalf(n2, p2, p1[0], p1[1]));\n\t\tif (ans >= Double.POSITIVE_INFINITY) {\n\t\t\tio.println(-1);\n\t\t}else{\n\t\t\tio.println(String.format(\"%.9f\",ans));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static double solveHalf(int n, Vector2[] p, Vector2 a1, Vector2 a2) {\n\t\tGraph g = new Graph(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\tif (Vector2.intersects(p[i], p[j], a1, a2)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tg.addBidirectionalEdge(i, j, Math.sqrt(p[i].subtract(p[j]).normSquare()));\n\t\t\t}\n\t\t}\n\t\treturn g.minDistDijkstra(0)[1] + Math.sqrt(a1.subtract(a2).normSquare());\n\t}\n\n}\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\n\tpublic void addBidirectionalEdge(int from,int to,double d) {\n\t\taddEdge(from,to,d);\n\t\taddEdge(to,from,d);\n\t}\n\tpublic void addEdge(int from,int to,double cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic double[] minDistDijkstra(int s) {\n\t\tdouble[] dist = new double[n];\n\t\tArrays.fill(dist, Double.POSITIVE_INFINITY);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tdouble cost;\n\t\tpublic Edge(int to,double cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tdouble dist;\n\t\tint id;\n\t\tpublic Node(double dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}\n\nclass Vector2 {\n\tint x = 0;\n\tint y = 0;\n\tpublic Vector2(int x,int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tpublic int dot(Vector2 v) {\n\t\treturn this.x*v.x+this.y*v.y;\n\t}\n\tpublic int cross(Vector2 v) {\n\t\treturn this.x*v.y-this.y*v.x;\n\t}\n\tpublic Vector2 add(Vector2 v) {\n\t\treturn new Vector2(this.x+v.x,this.y+v.y);\n\t}\n\tpublic Vector2 subtract(Vector2 v) {\n\t\treturn new Vector2(this.x-v.x,this.y-v.y);\n\t}\n\tpublic Vector2 multiply(int k) {\n\t\treturn new Vector2(k*this.x,k*this.y);\n\t}\n\tpublic long normSquare() {\n\t\treturn x * x + y * y;\n\t}\n\tpublic long distSquare(Vector2 v) {\n\t\treturn this.subtract(v).normSquare();\n\t}\n\tpublic static boolean intersects(Vector2 p0,Vector2 p1,Vector2 p2,Vector2 p3) {\n\t\tVector2 v1 = p1.subtract(p0);\n\t\tVector2 v2 = p3.subtract(p2);\n\t\tVector2 v = p2.subtract(p0);\n\t\tVector2 v_ = p2.subtract(p1);\n\t\tint a = v1.cross(v2);\n\t\tif(a==0) {\n\t\t\treturn v.cross(v_) == 0 && (v.dot(v_) <= 0 || p0.subtract(p2).dot(p0.subtract(p3)) <= 0);\n\t\t}else{\n\t\t\tint a1 = -v1.cross(v);\n\t\t\tint a2 = -v2.cross(v);\n\t\t\tif (a>0) {\n\t\t\t\treturn (0<=a1&&a1<=a&&0<=a2&&a2<=a);\n\t\t\t}else{\n\t\t\t\treturn (a<=a1&&a1<=0&&a<=a2&&a2<=0);\n\t\t\t}\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t\tif (ans == 28985.17494996295) {\n\t\t\t\t\t\ttr(ans, xa[0], ya[0], xa[i], ya[i], xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1]);\n\t\t\t\t\t\ttr(cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\n//Roads on Towns\npublic class Main{\n\n\tint NA, NB;\n\tdouble INF = 1L<<50, res = INF;\n\n\tfinal double EPS = 1e-10;\n\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\n\tdouble[][][] p;\n\tint[] ua, ub;\n\tint ka, kb;\n\t\n\tdouble[] d;\n\tdouble dijkstraA(double D){\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NA;i++){\n\t\t\t\tdouble w = d[v] + norm(p[0][v], p[0][i]);\n\t\t\t\tif(res+EPS < w)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=kb&&ok;j++)if(crossing(p[1][ub[j]], p[1][ub[j+1]], p[0][v], p[0][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n\t\t\t\t\tq.remove(i); d[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\tdouble dijkstraB(double D){\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NB;i++){\n\t\t\t\tdouble w = d[v] + norm(p[1][v], p[1][i]);\n\t\t\t\tif(res+EPS < w)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=ka&&ok;j++)if(crossing(p[0][ua[j]], p[0][ua[j+1]], p[1][v], p[1][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n\t\t\t\t\tq.remove(i); d[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tvoid fa(){\n\t\tdouble d = norm(p[0][0], p[0][1]);\n\t\tua[1] = 1;\n\t\tka = 1;\n\t\tres = Math.min(res, d+dijkstraB(d));\n\t\tfor(int k=2;k<NA;k++){\n\t\t\td = norm(p[0][0], p[0][k]) + norm(p[0][k], p[0][1]);\n\t\t\tka = 2;\n\t\t\tua[1] = k; ua[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraB(d));\n\t\t}\n\t}\n\tvoid fb(){\n\t\tdouble d = norm(p[1][0], p[1][1]);\n\t\tub[1] = 1;\n\t\tkb = 1;\n\t\tres = Math.min(res, d+dijkstraA(d));\n\t\tfor(int k=2;k<NB;k++){\n\t\t\td = norm(p[1][0], p[1][k]) + norm(p[1][k], p[1][1]);\n\t\t\tkb = 2;\n\t\t\tub[1] = k; ub[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraA(d));\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tNA = sc.nextInt(); NB = sc.nextInt();\n\t\tp = new double[2][][];\n\t\tp[0] = new double[NA][2]; p[1] = new double[NB][2];\n\t\tfor(int i=0;i<NA;i++)for(int j=0;j<2;j++)p[0][i][j]=sc.nextDouble();\n\t\tfor(int i=0;i<NB;i++)for(int j=0;j<2;j++)p[1][i][j]=sc.nextDouble();\n\t\tua = new int[NA]; ub = new int[NB];\n\t\td = new double[1000];\n\t\tfa(); fb();\n\t\tif(res==INF)System.out.println(-1);\n\t\telse System.out.printf(\"%.10f\\n\", res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tint[] xa = new int[Na];\n\t\tint[] ya = new int[Na];\n\t\tint[] xb = new int[Nb];\n\t\tint[] yb = new int[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextInt();\n\t\t\tya[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextInt();\n\t\t\tyb[i] = sc.nextInt();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[1], ya[1], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tint[] tmp = new int[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(int xa, int ya, int xb, int yb) {\n\t\tint dx = xa - xb;\n\t\tint dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(int xa1, int ya1, int xb1, int yb1, int xa2, int ya2, int xb2, int yb2) {\n\t\tboolean ret = true;\n\t\tret &= f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2) <= 0;\n\t\tret &= f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1) <= 0;\n\t\treturn ret;\n\t}\n\n\tint f(int xa, int ya, int xb, int yb, int x, int y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Roads on Towns\npublic class Main{\n\n\tint NA, NB;\n\tdouble INF = 1L<<50, res = INF, EPS = 1e-10;\n\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\n\tdouble[][][] p;\n\tdouble[][] pd;\n\t\n\tdouble[] d;\n\tdouble dijkstraA(double D){\n\t\tif(res + EPS < D + pd[0][1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NA;i++){\n\t\t\t\tdouble w = d[v] + pd[v][i];\n\t\t\t\tif(res+EPS < w+D)continue;\n\t\t\t\tif(!crossing(p[1][0], p[1][1], p[0][v], p[0][i]) && w < d[i]){\n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\tdouble dijkstraB(double D){\n\t\tif(res+EPS < D+pd[NA][NA+1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NB;i++){\n\t\t\t\tdouble w = d[v] + pd[NA+v][NA+i];\n\t\t\t\tif(res+EPS < w+D)continue;\n\t\t\t\tif(!crossing(p[0][0], p[0][1], p[1][v], p[1][i]) && w < d[i]){\n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tNA = sc.nextInt(); NB = sc.nextInt();\n\t\tp = new double[2][][];\n\t\tp[0] = new double[NA][2]; p[1] = new double[NB][2];\n\t\tfor(int i=0;i<NA;i++)for(int j=0;j<2;j++)p[0][i][j]=sc.nextDouble();\n\t\tfor(int i=0;i<NB;i++)for(int j=0;j<2;j++)p[1][i][j]=sc.nextDouble();\n\t\td = new double[1000];\n\t\tpd = new double[NA+NB][NA+NB];\n\t\tfor(int i=0;i<NA;i++){\n\t\t\tfor(int j=i;j<NA;j++)pd[i][j] = pd[j][i] = norm(p[0][i], p[0][j]);\n\t\t\tfor(int j=0;j<NB;j++)pd[i][NA+j] = pd[NA+j][i] = norm(p[0][i], p[1][j]);\n\t\t}\n\t\tfor(int i=0;i<NB;i++){\n\t\t\tfor(int j=i;j<NB;j++)pd[NA+i][NA+j] = pd[NA+j][NA+i] = norm(p[1][i], p[1][j]);\n\t\t}\n\t\tdouble d = pd[0][1];\n\t\tres = Math.min(res, d+dijkstraB(d));\n\t\td = pd[NA][NA+1];\n\t\tres = Math.min(res, d+dijkstraA(d));\n\t\tif(res==INF)System.out.println(-1);\n\t\telse System.out.printf(\"%.10f\\n\", res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Roads on Towns\npublic class Main{\n\n\tint NA, NB;\n\tdouble INF = 1L<<50, res = INF;\n\n\tfinal double EPS = 1e-10;\n\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\n\tdouble[][][] p;\n\tint[] ua, ub;\n\tint ka, kb;\n\tdouble[][] pd;\n\t\n\tdouble[] d;\n\tdouble dijkstraA(double D){\n\t\tif(res + EPS < D + pd[0][1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NA;i++){\n\t\t\t\tdouble w = d[v] + pd[v][i];\n//\t\t\t\tnorm(p[0][v], p[0][i]);\n\t\t\t\tif(res+EPS < w)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=kb&&ok;j++)if(crossing(p[1][ub[j]], p[1][ub[j+1]], p[0][v], p[0][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n//\t\t\t\t\tq.remove(i); \n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\tdouble dijkstraB(double D){\n\t\tif(res+EPS < D+pd[NA][NA+1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NB;i++){\n\t\t\t\tdouble w = d[v] + pd[NA+v][NA+i];\n//\t\t\t\tnorm(p[1][v], p[1][i]);\n\t\t\t\tif(res+EPS < w)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=ka&&ok;j++)if(crossing(p[0][ua[j]], p[0][ua[j+1]], p[1][v], p[1][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n//\t\t\t\t\tq.remove(i); \n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tvoid fa(){\n//\t\tnorm(p[0][0], p[0][1]);\n//\t\tdouble d = pd[0][1];\n//\t\tua[1] = 1;\n//\t\tka = 1;\n//\t\tres = Math.min(res, d+dijkstraB(d));\n\t\tfor(int k=2;k<NA;k++){\n\t\t\tdouble d = pd[0][k] + pd[k][1];\n//\t\t\tnorm(p[0][0], p[0][k]) + norm(p[0][k], p[0][1]);\n\t\t\tka = 2;\n\t\t\tua[1] = k; ua[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraB(d));\n\t\t}\n\t}\n\tvoid fb(){\n//\t\tnorm(p[1][0], p[1][1]);\n//\t\tdouble d = pd[NA][NA+1];\n//\t\tub[1] = 1;\n//\t\tkb = 1;\n//\t\tres = Math.min(res, d+dijkstraA(d));\n\t\tfor(int k=2;k<NB;k++){\n\t\t\tdouble d = pd[NA][NA+k] + pd[NA+k][NA+1];\n//\t\t\tnorm(p[1][0], p[1][k]) + norm(p[1][k], p[1][1]);\n\t\t\tkb = 2;\n\t\t\tub[1] = k; ub[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraA(d));\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tNA = sc.nextInt(); NB = sc.nextInt();\n\t\tp = new double[2][][];\n\t\tp[0] = new double[NA][2]; p[1] = new double[NB][2];\n\t\tfor(int i=0;i<NA;i++)for(int j=0;j<2;j++)p[0][i][j]=sc.nextDouble();\n\t\tfor(int i=0;i<NB;i++)for(int j=0;j<2;j++)p[1][i][j]=sc.nextDouble();\n\t\tua = new int[NA]; ub = new int[NB];\n\t\td = new double[1000];\n\t\tpd = new double[NA+NB][NA+NB];\n\t\tfor(int i=0;i<NA;i++){\n\t\t\tfor(int j=0;j<NA;j++)pd[i][j] = norm(p[0][i], p[0][j]);\n\t\t\tfor(int j=0;j<NB;j++)pd[i][NA+j] = norm(p[0][i], p[1][j]);\n\t\t}\n\t\tfor(int i=0;i<NB;i++){\n\t\t\tfor(int j=0;j<NB;j++)pd[NA+i][NA+j] = norm(p[1][i], p[1][j]);\n\t\t\tfor(int j=0;j<NA;j++)pd[NA+i][j] = norm(p[1][i], p[0][j]);\n\t\t}\n\t\tdouble d = pd[0][1];\n\t\tua[1] = 1;\n\t\tka = 1;\n\t\tres = Math.min(res, d+dijkstraB(d));\n\t\td = pd[NA][NA+1];\n\t\tub[1] = 1;\n\t\tkb = 1;\n\t\tres = Math.min(res, d+dijkstraA(d));\n\t\tfa(); fb();\n\t\tif(res==INF)System.out.println(-1);\n\t\telse System.out.printf(\"%.10f\\n\", res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tint[] xa = new int[Na];\n\t\tint[] ya = new int[Na];\n\t\tint[] xb = new int[Nb];\n\t\tint[] yb = new int[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextInt();\n\t\t\tya[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextInt();\n\t\t\tyb[i] = sc.nextInt();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[1], ya[1], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tint[] tmp = new int[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_EXPONENT / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(int xa, int ya, int xb, int yb) {\n\t\tint dx = xa - xb;\n\t\tint dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(int xa1, int ya1, int xb1, int yb1, int xa2, int ya2, int xb2, int yb2) {\n\t\tboolean ret = true;\n\t\tret &= f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2) <= 0;\n\t\tret &= f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1) <= 0;\n\t\treturn ret;\n\t}\n\n\tint f(int xa, int ya, int xb, int yb, int x, int y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tint[] xa = new int[Na];\n\t\tint[] ya = new int[Na];\n\t\tint[] xb = new int[Nb];\n\t\tint[] yb = new int[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextInt();\n\t\t\tya[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextInt();\n\t\t\tyb[i] = sc.nextInt();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[1], ya[1], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tint[] tmp = new int[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(int xa, int ya, int xb, int yb) {\n\t\tint dx = xa - xb;\n\t\tint dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(int xa1, int ya1, int xb1, int yb1, int xa2, int ya2, int xb2, int yb2) {\n\t\tboolean ret = true;\n\t\tret &= f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2) <= 0;\n\t\tret &= f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1) <= 0;\n\t\treturn ret;\n\t}\n\n\tint f(int xa, int ya, int xb, int yb, int x, int y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Roads on Towns\npublic class Main{\n\n\tint NA, NB;\n\tdouble INF = 1L<<50, res = INF;\n\n\tfinal double EPS = 1e-10;\n\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\n\tdouble[][][] p;\n\tint[] ua, ub;\n\tint ka, kb;\n\tdouble[][] pd;\n\t\n\tdouble[] d;\n\tdouble dijkstraA(double D){\n\t\tif(res + EPS < D + pd[0][1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NA;i++){\n\t\t\t\tdouble w = d[v] + pd[v][i];\n//\t\t\t\tnorm(p[0][v], p[0][i]);\n\t\t\t\tif(res+EPS < w+D)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=kb&&ok;j++)if(crossing(p[1][ub[j]], p[1][ub[j+1]], p[0][v], p[0][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n//\t\t\t\t\tq.remove(i); \n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\tdouble dijkstraB(double D){\n\t\tif(res+EPS < D+pd[NA][NA+1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NB;i++){\n\t\t\t\tdouble w = d[v] + pd[NA+v][NA+i];\n//\t\t\t\tnorm(p[1][v], p[1][i]);\n\t\t\t\tif(res+EPS < w+D)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=ka&&ok;j++)if(crossing(p[0][ua[j]], p[0][ua[j+1]], p[1][v], p[1][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n//\t\t\t\t\tq.remove(i); \n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tvoid fa(){\n//\t\tnorm(p[0][0], p[0][1]);\n//\t\tdouble d = pd[0][1];\n//\t\tua[1] = 1;\n//\t\tka = 1;\n//\t\tres = Math.min(res, d+dijkstraB(d));\n\t\tfor(int k=2;k<NA;k++){\n\t\t\tdouble d = pd[0][k] + pd[k][1];\n//\t\t\tnorm(p[0][0], p[0][k]) + norm(p[0][k], p[0][1]);\n\t\t\tka = 2;\n\t\t\tua[1] = k; ua[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraB(d));\n\t\t}\n\t}\n\tvoid fb(){\n//\t\tnorm(p[1][0], p[1][1]);\n//\t\tdouble d = pd[NA][NA+1];\n//\t\tub[1] = 1;\n//\t\tkb = 1;\n//\t\tres = Math.min(res, d+dijkstraA(d));\n\t\tfor(int k=2;k<NB;k++){\n\t\t\tdouble d = pd[NA][NA+k] + pd[NA+k][NA+1];\n//\t\t\tnorm(p[1][0], p[1][k]) + norm(p[1][k], p[1][1]);\n\t\t\tkb = 2;\n\t\t\tub[1] = k; ub[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraA(d));\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tNA = sc.nextInt(); NB = sc.nextInt();\n\t\tp = new double[2][][];\n\t\tp[0] = new double[NA][2]; p[1] = new double[NB][2];\n\t\tfor(int i=0;i<NA;i++)for(int j=0;j<2;j++)p[0][i][j]=sc.nextDouble();\n\t\tfor(int i=0;i<NB;i++)for(int j=0;j<2;j++)p[1][i][j]=sc.nextDouble();\n\t\tua = new int[NA]; ub = new int[NB];\n\t\td = new double[1000];\n\t\tpd = new double[NA+NB][NA+NB];\n\t\tfor(int i=0;i<NA;i++){\n\t\t\tfor(int j=i;j<NA;j++)pd[i][j] = pd[j][i] = norm(p[0][i], p[0][j]);\n\t\t\tfor(int j=0;j<NB;j++)pd[i][NA+j] = pd[NA+j][i] = norm(p[0][i], p[1][j]);\n\t\t}\n\t\tfor(int i=0;i<NB;i++){\n\t\t\tfor(int j=i;j<NB;j++)pd[NA+i][NA+j] = pd[NA+j][NA+i] = norm(p[1][i], p[1][j]);\n//\t\t\tfor(int j=0;j<NA;j++)pd[NA+i][j] = norm(p[1][i], p[0][j]);\n\t\t}\n\t\tdouble d = pd[0][1];\n\t\tua[1] = 1;\n\t\tka = 1;\n\t\tres = Math.min(res, d+dijkstraB(d));\n\t\td = pd[NA][NA+1];\n\t\tub[1] = 1;\n\t\tkb = 1;\n\t\tres = Math.min(res, d+dijkstraA(d));\n\t\tfa(); fb();\n\t\tif(res==INF)System.out.println(-1);\n\t\telse System.out.printf(\"%.10f\\n\", res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Roads on Towns\npublic class Main{\n\n\tint NA, NB;\n\tdouble INF = 1L<<50, res = INF;\n\n\tfinal double EPS = 1e-10;\n\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tdouble angleTan(double[] a, double[] b){\n\t\treturn Math.atan2(cross(a, b), dot(a, b));\n\t}\n\tdouble angleCos(double[] a, double[] b){\n\t\tdouble na = norm(a), nb = norm(b);\n\t\treturn Math.acos(dot(a, b)/na/nb);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\n\tdouble[][][] p;\n\tint[] ua, ub;\n\tint ka, kb;\n\tdouble[][] pd;\n\t\n\tdouble[] d;\n\tdouble dijkstraA(double D){\n\t\tif(res + EPS < D + pd[0][1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NA;i++){\n\t\t\t\tdouble w = d[v] + pd[v][i];\n//\t\t\t\tnorm(p[0][v], p[0][i]);\n\t\t\t\tif(res+EPS < w)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=kb&&ok;j++)if(crossing(p[1][ub[j]], p[1][ub[j+1]], p[0][v], p[0][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n//\t\t\t\t\tq.remove(i); \n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\tdouble dijkstraB(double D){\n\t\tif(res+EPS < D+pd[NA][NA+1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NB;i++){\n\t\t\t\tdouble w = d[v] + pd[NA+v][NA+i];\n//\t\t\t\tnorm(p[1][v], p[1][i]);\n\t\t\t\tif(res+EPS < w)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=ka&&ok;j++)if(crossing(p[0][ua[j]], p[0][ua[j+1]], p[1][v], p[1][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n//\t\t\t\t\tq.remove(i); \n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tvoid fa(){\n\t\tdouble d = pd[0][1];\n//\t\tnorm(p[0][0], p[0][1]);\n\t\tua[1] = 1;\n\t\tka = 1;\n\t\tres = Math.min(res, d+dijkstraB(d));\n\t\tfor(int k=2;k<NA;k++){\n\t\t\td = pd[0][k] + pd[k][1];\n//\t\t\tnorm(p[0][0], p[0][k]) + norm(p[0][k], p[0][1]);\n\t\t\tka = 2;\n\t\t\tua[1] = k; ua[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraB(d));\n\t\t}\n\t}\n\tvoid fb(){\n\t\tdouble d = pd[NA][NA+1];\n//\t\tnorm(p[1][0], p[1][1]);\n\t\tub[1] = 1;\n\t\tkb = 1;\n\t\tres = Math.min(res, d+dijkstraA(d));\n\t\tfor(int k=2;k<NB;k++){\n\t\t\td = pd[NA][NA+k] + pd[NA+k][NA+1];\n//\t\t\tnorm(p[1][0], p[1][k]) + norm(p[1][k], p[1][1]);\n\t\t\tkb = 2;\n\t\t\tub[1] = k; ub[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraA(d));\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tNA = sc.nextInt(); NB = sc.nextInt();\n\t\tp = new double[2][][];\n\t\tp[0] = new double[NA][2]; p[1] = new double[NB][2];\n\t\tfor(int i=0;i<NA;i++)for(int j=0;j<2;j++)p[0][i][j]=sc.nextDouble();\n\t\tfor(int i=0;i<NB;i++)for(int j=0;j<2;j++)p[1][i][j]=sc.nextDouble();\n\t\tua = new int[NA]; ub = new int[NB];\n\t\td = new double[1000];\n\t\tpd = new double[NA+NB][NA+NB];\n\t\tfor(int i=0;i<NA;i++){\n\t\t\tfor(int j=0;j<NA;j++)pd[i][j] = norm(p[0][i], p[0][j]);\n\t\t\tfor(int j=0;j<NB;j++)pd[i][NA+j] = norm(p[0][i], p[1][j]);\n\t\t}\n\t\tfor(int i=0;i<NB;i++){\n\t\t\tfor(int j=0;j<NB;j++)pd[NA+i][NA+j] = norm(p[1][i], p[1][j]);\n\t\t\tfor(int j=0;j<NA;j++)pd[NA+i][j] = norm(p[1][i], p[0][j]);\n\t\t}\n\t\tfa(); fb();\n\t\tif(res==INF)System.out.println(-1);\n\t\telse System.out.printf(\"%.10f\\n\", res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tint[] xa = new int[Na];\n\t\tint[] ya = new int[Na];\n\t\tint[] xb = new int[Nb];\n\t\tint[] yb = new int[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextInt();\n\t\t\tya[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextInt();\n\t\t\tyb[i] = sc.nextInt();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[1], ya[1], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tint[] tmp = new int[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_EXPONENT / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(int xa, int ya, int xb, int yb) {\n\t\tint dx = xa - xb;\n\t\tint dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(int xa1, int ya1, int xb1, int yb1, int xa2, int ya2, int xb2, int yb2) {\n\t\tboolean ret = true;\n\t\tret &= f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2) <= 0;\n\t\tret &= f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1) <= 0;\n\t\treturn ret;\n\t}\n\n\tint f(int xa, int ya, int xb, int yb, int x, int y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint Na = sc.nextInt();\n\t\tint Nb = sc.nextInt();\n\t\tlong[] xa = new long[Na];\n\t\tlong[] ya = new long[Na];\n\t\tlong[] xb = new long[Nb];\n\t\tlong[] yb = new long[Nb];\n\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\txa[i] = sc.nextLong();\n\t\t\tya[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Nb; ++i) {\n\t\t\txb[i] = sc.nextLong();\n\t\t\tyb[i] = sc.nextLong();\n\t\t}\n\n\t\tdouble ans = Double.MAX_VALUE / 3;\n\t\tfor (int t = 0; t < 2; ++t) {\n\t\t\tfor (int i = 0; i < Na; ++i) {\n\t\t\t\tfor (int j = 0; j < Na; ++j) {\n\t\t\t\t\tif (cross(xa[0], ya[0], xa[i], ya[i], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[i], ya[i], xa[j], ya[j], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cross(xa[j], ya[j], xa[1], ya[1], xb[0], yb[0], xb[1], yb[1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.min(ans, dist(xa[0], ya[0], xa[i], ya[i]) + dist(xa[i], ya[i], xa[j], ya[j])\n\t\t\t\t\t\t\t+ dist(xa[j], ya[j], xa[1], ya[1]) + dist(xb[0], yb[0], xb[1], yb[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tNa ^= Nb;\n\t\t\tNb ^= Na;\n\t\t\tNa ^= Nb;\n\t\t\tlong[] tmp = new long[Na];\n\t\t\ttmp = Arrays.copyOf(xa, xa.length);\n\t\t\txa = Arrays.copyOf(xb, xb.length);\n\t\t\txb = Arrays.copyOf(tmp, tmp.length);\n\t\t\ttmp = Arrays.copyOf(ya, ya.length);\n\t\t\tya = Arrays.copyOf(yb, yb.length);\n\t\t\tyb = Arrays.copyOf(tmp, tmp.length);\n\t\t}\n\t\tSystem.out.println(ans >= Double.MAX_VALUE / 4 ? \"-1\" : ans);\n\t}\n\n\tdouble dist(long xa, long ya, long xb, long yb) {\n\t\tlong dx = xa - xb;\n\t\tlong dy = ya - yb;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\tboolean cross(long xa1, long ya1, long xb1, long yb1, long xa2, long ya2, long xb2, long yb2) {\n\t\tlong v = f(xa1, ya1, xb1, yb1, xa2, ya2) * f(xa1, ya1, xb1, yb1, xb2, yb2);\n\t\tlong u = f(xa2, ya2, xb2, yb2, xa1, ya1) * f(xa2, ya2, xb2, yb2, xb1, yb1);\n\t\treturn v <= 0 && u <= 0;\n\t}\n\n\tlong f(long xa, long ya, long xb, long yb, long x, long y) {\n\t\treturn (ya - yb) * (x - xa) - (y - ya) * (xa - xb);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int NA, NB;\n\tstatic int[] XA, YA, XB, YB;\n\tstatic final double INF = 1e300;\n\n\tpublic static void main(String[] args) {\n\t\tNA = sc.nextInt();\n\t\tNB = sc.nextInt();\n\t\tXA = new int[NA];\n\t\tYA = new int[NA];\n\t\tXB = new int[NB];\n\t\tYB = new int[NB];\n\t\tfor (int i = 0; i < NA; ++i) {\n\t\t\tXA[i] = sc.nextInt();\n\t\t\tYA[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < NB; ++i) {\n\t\t\tXB[i] = sc.nextInt();\n\t\t\tYB[i] = sc.nextInt();\n\t\t}\n\t\tdouble a1 = solve(XA, YA, XB, YB);\n\t\tdouble a2 = solve(XB, YB, XA, YA);\n\t\tdouble ans = Math.min(a1, a2);\n\t\tif (ans == INF) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tSystem.out.printf(\"%.9f\\n\", ans);\n\t\t}\n\t}\n\n\tstatic double solve(int[] X1, int[] Y1, int[] X2, int[] Y2) {\n\t\tint N = X2.length;\n\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\tq.add(new State(0, 0));\n\t\tboolean[] visited = new boolean[N];\n\t\twhile (!q.isEmpty()) {\n\t\t\tState cur = q.poll();\n\t\t\tif (cur.v == 1) {\n\t\t\t\treturn cur.d + dist(X1[0], Y1[0], X1[1], Y1[1]);\n\t\t\t}\n\t\t\tif (visited[cur.v]) continue;\n\t\t\tvisited[cur.v] = true;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (visited[i]) continue;\n\t\t\t\tif (cross(X1[0], Y1[0], X1[1], Y1[1], X2[cur.v], Y2[cur.v], X2[i], Y2[i])) continue;\n\t\t\t\tq.add(new State(i, cur.d + dist(X2[cur.v], Y2[cur.v], X2[i], Y2[i])));\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\n\tstatic class State implements Comparable<State> {\n\t\tint v;\n\t\tdouble d;\n\n\t\tState(int v, double d) {\n\t\t\tthis.v = v;\n\t\t\tthis.d = d;\n\t\t}\n\n\t\tpublic int compareTo(State o) {\n\t\t\treturn Double.compare(this.d, o.d);\n\t\t}\n\t}\n\n\tstatic double dist(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt(sq(x2 - x1) + sq(y2 - y1));\n\t}\n\n\tstatic double sq(double v) {\n\t\treturn v * v;\n\t}\n\n\tstatic boolean cross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\n\t\tlong v1 = (x1 - x2) * (y3 - y1) + (y1 - y2) * (x1 - x3);\n\t\tlong v2 = (x1 - x2) * (y4 - y1) + (y1 - y2) * (x1 - x4);\n\t\tlong v3 = (x3 - x4) * (y1 - y3) + (y3 - y4) * (x3 - x1);\n\t\tlong v4 = (x3 - x4) * (y2 - y3) + (y3 - y4) * (x3 - x2);\n\t\tif (v3 == 0 && v4 == 0) {\n\t\t\treturn Math.min(x1, x2) <= x3 && x3 <= Math.max(x1, x2) && Math.min(y1, y2) <= y3 && y3 <= Math.max(y1, y2);\n\t\t}\n\t\treturn v1 * v2 <= 0 && v3 * v4 <= 0;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Roads on Towns\npublic class Main{\n\n\tint NA, NB;\n\tdouble INF = 1L<<50, res = INF;\n\n\tfinal double EPS = 1e-10;\n\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\n\tdouble[][][] p;\n\tint[] ua, ub;\n\tint ka, kb;\n\tdouble[][] pd;\n\t\n\tdouble[] d;\n\tdouble dijkstraA(double D){\n\t\tif(res + EPS < D + pd[0][1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NA;i++){\n\t\t\t\tdouble w = d[v] + pd[v][i];\n\t\t\t\tif(res+EPS < w+D)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=kb&&ok;j++)if(crossing(p[1][ub[j]], p[1][ub[j+1]], p[0][v], p[0][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\tdouble dijkstraB(double D){\n\t\tif(res+EPS < D+pd[NA][NA+1])return INF;\n\t\tArrays.fill(d, INF);\n\t\td[0] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(NB, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn (int)Math.signum(d[o1]-d[o2]);\n\t\t\t}\n\t\t});\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tif(v==1)return d[1];\n\t\t\tfor(int i=1;i<NB;i++){\n\t\t\t\tdouble w = d[v] + pd[NA+v][NA+i];\n\t\t\t\tif(res+EPS < w+D)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(int j=0;j+1<=ka&&ok;j++)if(crossing(p[0][ua[j]], p[0][ua[j+1]], p[1][v], p[1][i]))ok = false;\n\t\t\t\tif(ok && w < d[i]){\n\t\t\t\t\td[i] = w; q.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INF;\n\t}\n\t\n\tvoid fa(){\n\t\tfor(int k=2;k<NA;k++){\n\t\t\tdouble d = pd[0][k] + pd[k][1];\n\t\t\tka = 2;\n\t\t\tua[1] = k; ua[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraB(d));\n\t\t}\n\t}\n\tvoid fb(){\n\t\tfor(int k=2;k<NB;k++){\n\t\t\tdouble d = pd[NA][NA+k] + pd[NA+k][NA+1];\n\t\t\tkb = 2;\n\t\t\tub[1] = k; ub[2] = 1;\n\t\t\tres = Math.min(res, d+dijkstraA(d));\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tNA = sc.nextInt(); NB = sc.nextInt();\n\t\tp = new double[2][][];\n\t\tp[0] = new double[NA][2]; p[1] = new double[NB][2];\n\t\tfor(int i=0;i<NA;i++)for(int j=0;j<2;j++)p[0][i][j]=sc.nextDouble();\n\t\tfor(int i=0;i<NB;i++)for(int j=0;j<2;j++)p[1][i][j]=sc.nextDouble();\n\t\tua = new int[NA]; ub = new int[NB];\n\t\td = new double[1000];\n\t\tpd = new double[NA+NB][NA+NB];\n\t\tfor(int i=0;i<NA;i++){\n\t\t\tfor(int j=i;j<NA;j++)pd[i][j] = pd[j][i] = norm(p[0][i], p[0][j]);\n\t\t\tfor(int j=0;j<NB;j++)pd[i][NA+j] = pd[NA+j][i] = norm(p[0][i], p[1][j]);\n\t\t}\n\t\tfor(int i=0;i<NB;i++){\n\t\t\tfor(int j=i;j<NB;j++)pd[NA+i][NA+j] = pd[NA+j][NA+i] = norm(p[1][i], p[1][j]);\n\t\t}\n\t\tdouble d = pd[0][1];\n\t\tua[1] = 1;\n\t\tka = 1;\n\t\tres = Math.min(res, d+dijkstraB(d));\n\t\td = pd[NA][NA+1];\n\t\tub[1] = 1;\n\t\tkb = 1;\n\t\tres = Math.min(res, d+dijkstraA(d));\n//\t\tfa(); fb();\n\t\tif(res==INF)System.out.println(-1);\n\t\telse System.out.printf(\"%.10f\\n\", res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace _2334\n{\n\tclass Program\n\t{\n\t\tstatic bool Judge(Tuple<int, int> a, Tuple<int, int> b, Tuple<int, int> c, Tuple<int, int> d)\n\t\t{\n\t\t\tlong ta = (c.Item1 - d.Item1) * (a.Item2 - c.Item2) + (c.Item2 - d.Item2) * (c.Item1 - a.Item1);\n\t\t\tlong tb = (c.Item1 - d.Item1) * (b.Item2 - c.Item2) + (c.Item2 - d.Item2) * (c.Item1 - b.Item1);\n\t\t\tlong tc = (a.Item1 - b.Item1) * (c.Item2 - a.Item2) + (a.Item2 - b.Item2) * (a.Item1 - c.Item1);\n\t\t\tlong td = (a.Item1 - b.Item1) * (d.Item2 - a.Item2) + (a.Item2 - b.Item2) * (a.Item1 - d.Item1);\n\n\t\t\treturn tc * td <= 0 && ta * tb <= 0;\n\t\t}\n\t\tstatic double Calc(Tuple<int, int> a, Tuple<int, int> b)\n\t\t{\n\t\t\treturn Math.Sqrt(Math.Pow(a.Item1 - b.Item1, 2) + Math.Pow(a.Item2 - b.Item2, 2));\n\t\t}\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tint[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\t\t\tTuple<int, int>[] a = new Tuple<int, int>[x[0]];\n\t\t\tTuple<int, int>[] b = new Tuple<int, int>[x[1]];\n\t\t\tfor (int i = 0; i < x[0]; i++)\n\t\t\t{\n\t\t\t\tint[] n = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\t\t\t\ta[i] = new Tuple<int, int>(n[0], n[1]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < x[1]; i++)\n\t\t\t{\n\t\t\t\tint[] n = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\t\t\t\tb[i] = new Tuple<int, int>(n[0], n[1]);\n\t\t\t}\n\t\t\tdouble ret = double.MaxValue;\n\t\t\tfor (int i = 0; i < x[0]; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < x[0]; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!Judge(a[0], a[i], b[0], b[1]) && !Judge(a[i], a[j], b[0], b[1]) && !Judge(a[j], a[1], b[0], b[1]))\n\t\t\t\t\t{\n\t\t\t\t\t\tret = Math.Min(ret, Calc(a[0], a[i]) + Calc(a[i], a[j]) + Calc(a[j], a[1])\n\t\t\t\t\t\t\t+ Calc(b[0], b[1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < x[1]; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < x[1]; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!Judge(a[0], a[1], b[0], b[i]) && !Judge(a[0], a[1], b[i], b[j]) && !Judge(a[0], a[1], b[j], b[1]))\n\t\t\t\t\t{\n\t\t\t\t\t\tret = Math.Min(ret, Calc(a[0], a[1])\n\t\t\t\t\t\t\t+ Calc(b[0], b[i]) + Calc(b[i], b[j]) + Calc(b[j], b[1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(ret == double.MaxValue ? -1 : ret);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var P = Enumerate(n + m, x => new Point(ri, ri));\n            var u = (P[0] - P[1]).Magnitude + exec(P.Skip(n).ToArray(), P[0], P[1]);\n            var v = (P[n] - P[n + 1]).Magnitude + exec(P.Take(n).ToArray(), P[n], P[n + 1]);\n            if (Min(u, v) > 1e17) Console.WriteLine(-1);\n            else Console.WriteLine(Min(u, v));\n        }\n        double exec(Point[] p, Point u, Point v) {\n            var n = p.Length;\n            var G = Enumerate(n, x => new double[n]);\n            var dist = Enumerate(n, x => 1e18);\n            dist[0] = 0;\n            var seg = new Line(u, v);\n            for (int i = 0; i < n; i++)\n                for (int j = i + 1; j < n; j++)\n                {\n                    var s = new Line(p[i], p[j]);\n                    if (Geometry.InterSect.IntersectSegmentSegment(seg, s)) G[i][j] = G[j][i] = 1e18;\n                    else G[i][j] = G[j][i] = (p[j] - p[i]).Magnitude;\n                }\n            var used = new bool[n];\n            for (int _ = 0; _ < n; _++)\n            {\n                var id = -1;\n                for (int i = 0; i < n; i++)\n                    if (!used[i] && (id == -1 || dist[id] > dist[i])) id = i;\n                if (id == -1) break;\n                used[id] = true;\n                for (int i = 0; i < n; i++)\n                    dist[i] = Min(dist[i], dist[id] + G[i][id]);\n            }\n            return dist[1];\n        }\n\n\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n\n#region Functions\nstatic public partial class Geometry {\n    public const double EPS = 1e-8;\n    static public double Cross(Point a, Point b) {\n        return (Point.Conjugate(a) * b).Imaginary;\n    }\n    static public double Dot(Point a, Point b) {\n        return (Point.Conjugate(a) * b).Real;\n    }\n    static public int CCW(Point a, Point b, Point c) {\n        b -= a; c -= a;\n        if (Cross(b, c) > 0) return 1;//CCW\n        if (Cross(b, c) < 0) return -1;//CW\n        if (Dot(b, c) < 0) return 2;//C-A-B\n        if (b.Magnitude < c.Magnitude) return -2;//A-B-C\n        return 0;\n    }\n    static public int Compare(Point a, Point b) {\n        if (a.Real != b.Real)\n            return (a.Real > b.Real) ? 1 : -1;\n        else if (a.Imaginary != b.Imaginary)\n            return a.Imaginary > b.Imaginary ? 1 : -1;\n        return 0;\n    }\n    static public double Norm(Point p) {\n        return p.Magnitude * p.Magnitude;\n    }\n}\n#endregion\n#region Line\npublic struct Line {\n    public Point P, Q;\n    public Point this[int index] {\n        get {\n            if (index == 0) return P;\n            if (index == 1) return Q;\n            throw new IndexOutOfRangeException(\"0 or 1\");\n        }\n        set {\n            if (index == 0) P = value;\n            if (index == 1) Q = value;\n            throw new IndexOutOfRangeException(\"0 or 1\");\n        }\n    }\n    public Line(Point a, Point b) : this() { P = a; Q = b; }\n}\n#endregion\n#region Intersect\nstatic public partial class Geometry {\n    static public partial class InterSect {\n        static public bool IntersectLineLine(Line a, Line b) {\n            return Math.Abs(Cross(a.Q - a.P, b.Q - b.P)) > EPS ||\n                Math.Abs(Cross(a.Q - a.P, b.Q - b.P)) < EPS;\n        }\n        static public bool IntersectLineSegment(Line l, Line s) {\n            return Cross(l.Q - l.P, s.P - l.P) * Cross(l.Q - l.P, s.Q - l.P) < EPS;\n        }\n        static public bool IntersectSegmentSegment(Line a, Line b) {\n            return CCW(a.P, a.Q, b.P) * CCW(a.P, a.Q, b.Q) <= 0 && CCW(b.P, b.Q, a.P) * CCW(b.P, b.Q, a.Q) <= 0;\n        }\n        static public bool IntersectSegmentPoint(Line s, Point p) {\n            return (s.P - p).Magnitude + (s.Q - p).Magnitude - (s[1] - s[0]).Magnitude < EPS;\n        }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\nend\n\ninclude Math\nclass Line\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef cross?(l)\n\t\treturn false if parallel?(l)\n\t\t(@a * l.x1 + @b * l.y1 - @c) * (@a * l.x2 + @b * l.y2 - @c) <= 0 &&\n\t\t(l.a * @x1 + l.b * @y1 - l.c) * (l.a * @x2 + l.b * @y2 - l.c) <= 0\n\tend\n\n\tdef parallel?(l)\n\t\t@a * l.b == @b * l.a\n\tend\n\n\tdef length\n\t\thypot(@x1 - @x2, @y1 - @y2)\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nm, n = gets.split.map(&:to_i)\nus = (1..m).map { gets.split.map(&:to_i) }\nvs = (1..n).map { gets.split.map(&:to_i) }\n\nclass Array\n\tinclude Graphical\n\tdef each_out_connection_of(u)\n\t\teach do |v|\n\t\t\tnext if v == u\n\t\t\tl2 = Line.through_two_points(*u, *v)\n\t\t\tnext if $l1.cross?(l2)\n\t\t\tyield [v, l2.length]\n\t\tend\n\tend\nend\n\n$l1 = Line.through_two_points(*us[0], *us[1])\nd1 = $l1.length + (vs.dijkstra([vs[0]])[vs[1]] || Float::INFINITY)\n$l1 = Line.through_two_points(*vs[0], *vs[1])\nd2 = $l1.length + (us.dijkstra([us[0]])[us[1]] || Float::INFINITY)\nd = [d1, d2].min\np d == Float::INFINITY ? -1 : d"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\ninclude Math\nclass Line\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef cross?(l)\n\t\treturn false if parallel?(l)\n\t\t(@a * l.x1 + @b * l.y1 - @c) * (@a * l.x2 + @b * l.y2 - @c) <= 0 &&\n\t\t(l.a * @x1 + l.b * @y1 - l.c) * (l.a * @x2 + l.b * @y2 - l.c) <= 0\n\tend\n\n\tdef parallel?(l)\n\t\t@a * l.b == @b * l.a\n\tend\n\n\tdef length\n\t\thypot(@x1 - @x2, @y1 - @y2)\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nm, n = gets.split.map(&:to_i)\nus = (1..m).map { gets.split.map(&:to_i) }\nvs = (1..n).map { gets.split.map(&:to_i) }\n\ng = Graph.new\nl1 = Line.through_two_points(*us[0], *us[1])\nnodes = {}\nvs.each {|x, y| nodes[[x, y]] = g.add_node}\nvs.combination(2) do |v1, v2|\n\tl2 = Line.through_two_points(*v1, *v2)\n\tif !l1.cross?(l2)\n\t\tg.add_edge(nodes[v1], nodes[v2], {:length => l2.length})\n\tend\nend\nd1 = l1.length + (g.dijkstra([nodes[vs[0]]])[nodes[vs[1]]] || Float::INFINITY)\n\ng = Graph.new\nl1 = Line.through_two_points(*vs[0], *vs[1])\nnodes = {}\nus.each {|x, y| nodes[[x, y]] = g.add_node}\nus.combination(2) do |u1, u2|\n\tl2 = Line.through_two_points(*u1, *u2)\n\tif ! l1.cross?(l2)\n\t\tg.add_edge(nodes[u1], nodes[u2], {:length => l2.length})\n\tend\nend\nd2 = l1.length + (g.dijkstra([nodes[us[0]]])[nodes[us[1]]] || Float::INFINITY)\n\nd = [d1, d2].min\np d == Float::INFINITY ? -1 : d"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\n\nconst EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    bool opEquals(in Point p) const {\n        return abs(x - p.x) <= EPS && abs(y - p.y) <= EPS;\n    }\n    int opCmp(in Point p) const {\n        double dx = x - p.x, dy = y - p.y;\n        if (abs(dx) <= EPS) {\n            if (abs(dy) <= EPS) return 0;\n            return cast(int)(dy / abs(dy));\n        } else {\n            return cast(int)(dx / abs(dx));\n        }\n    }\n    Point opBinary(alias op)(in Point p) const {\n        static if (op == \"+\") {\n            return Point(x + p.x, y + p.y);\n        } else if (op == \"-\") {\n            return Point(x - p.x, y - p.y);\n        }\n    }\n    Point opBinary(alias op)(double k) const {\n        static if (op == \"*\") {\n            return Point(x * k, y * k);\n        } else if (op == \"/\") {\n            return Point(x / k, y / k);\n        }\n    }\n}\ndouble norm(in Point p) {\n    return sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1; \n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return +2;     \n    if (b.norm < c.norm) return -2;  \n    return 0;                       \n}\n\ndouble distance(in Point a, in Point b) {\n    double dx = a.x - b.x,\n           dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nstruct Segment {\n    Point a, b;\n}\n\nbool contains(in Segment s, in Point p) {\n    Point u = s.a - p,\n          v = s.b - p;\n    return abs(cross(u, v)) < EPS && dot(u, v) < -EPS;\n}\n\nPoint projection(in Segment s, in Point p) {\n    Point u = s.b - s.a,\n          v = p - s.a;\n    double n = u.norm;\n    return s.a + u * (dot(u, v) / (n * n));\n}\n\ndouble distance(in Segment s, in Point p) {\n    auto ret = min(distance(p, s.a), distance(p, s.b));\n    Point proj = s.projection(p);\n    if (s.contains(proj)) {\n        ret = min(ret, (p - proj).norm);\n    }\n    return ret;\n}\ndouble distance(in Point p, in Segment s) {\n    return distance(s, p);\n}\n\nbool intersect(in Segment s, in Segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble distance(in Segment s, in Segment t) {\n    if (intersect(s, t)) return 0;\n    return min( distance(s.a, t), distance(s.b, t),\n                distance(s, t.a), distance(s, t.b) );\n}\n\nstruct Line {\n    Point a, b;\n}\nPoint unit(in Line l) {\n    /** l縺ョ蜊倅ス阪?繧ッ繝医Ν */\n    return l.a * (1.0 / norm(l.b - l.a));\n}\nbool intersect(in Line m, in Line n) {\n    double A = cross(m.b - m.a, n.b - n.a),\n           B = cross(m.b - m.a, m.b - n.a);\n    return (abs(A) > EPS || abs(B) < EPS);\n}\nPoint intersection(in Line m, in Line n) {\n    double A = cross(m.b - m.a, n.b - n.a),\n           B = cross(m.b - m.a, m.b - n.a);\n    if (abs(A) < EPS) {\n        if (abs(B) < EPS) return m.a;\n        else assert(0);\n    }\n    return n.a + (n.b - n.a) * B / A;\n}\n\nstruct Circle {\n    Point o;\n    double r;\n}\n\nbool contains(in Circle c, in Point p) {\n    /** 蜀?縺ォp縺悟性縺セ繧後ｋ縺? \n     *    p縺慶縺ョ蜻ィ荳翫↓縺ゅｋ縺ィ縺阪?蜷ォ縺セ繧後ｋ縺ィ縺ソ縺ェ縺?*/\n    return distance(c.o, p) <= c.r + EPS;\n}\n\nLine[2] tangent(in Circle c, in Point p) {\n    /** p繧帝?繧議縺ョ謗・邱壹ｒ霑斐☆.\n     *    霑斐ｊ蛟、縺ョ2逶エ邱嗟, m縺ォ縺、縺?※ l.a == m.a == p */\n    double l1 = distance(c.o, p);\n    double l2 = sqrt(l1 * l1 - c.r * c.r);\n    double d1 = (l2 * l2) / l1;\n    double d2 = (c.r * l2) / l1;\n    Point u = (c.o - p) / norm(c.o - p);\n    Point b = p + u * d1;\n\n    /* u縺ィ逶エ莠、縺吶ｋ蜊倅ス阪?繧ッ繝医Ν */\n    Point o1 = Point(u.y, -u.x),\n          o2 = Point(-u.y, u.x);\n\n    Point a1 = b + o1 * d2,\n          a2 = b + o2 * d2;\n    return [ Line(p, a1), Line(p, a2) ];\n}\n\nstruct Rectangle {\n    Point v[4];\n}\nbool contains(in Rectangle r, in Point p) {\n    /** 髟キ譁ケ蠖「r縺ォp縺悟性縺セ繧後ｋ縺? \n     *    r縺ョ蜻ィ荳翫↓p縺後≠繧九→縺阪?蜷ォ縺セ繧後ｋ縺ィ縺ソ縺ェ縺励※縺?↑縺?     *    蜃ク螟夊ァ貞ス「縺ォ荳?握蛹門庄閭ス */\n    int c = ccw(p, r.v[0], r.v[1]);\n    foreach (i; 0 .. 4) {\n        if (c != ccw(p, r.v[i], r.v[(i + 1) % 4])) return false;\n    }\n    return true;\n}\n\nint Na, Nb;\nPoint[] A, B;\n\nvoid input() {\n    scanf(\"%d %d\\n\", &Na, &Nb);\n    foreach (i; 0 .. Na) {\n        double x, y;\n        scanf(\"%lf %lf\\n\", &x, &y);\n        A ~= Point(x, y);\n    }\n    foreach (i; 0 .. Nb) {\n        double x, y;\n        scanf(\"%lf %lf\\n\", &x, &y);\n        B ~= Point(x, y);\n    }\n}\n\nstruct Edge {\n    int from, to;\n    double cost;\n}\n\ndouble dijkstra(Edge[][] G, int from, int to) {\n    //writeln(G);\n    struct State {\n        int v; double cost;\n    }\n    BinaryHeap!(Array!State, \"a.cost > b.cost\") PQ;\n    auto D = new double[G.length];\n    D[] = 1e9;\n    D[0] = 0;\n    PQ.insert(State(from, 0));\n    auto inQ = new bool[G.length];\n    inQ[from] = true;\n    while (!PQ.empty) {\n        auto c = PQ.front; PQ.removeFront;\n        inQ[c.v] = false;\n        foreach (e; G[c.v]) {\n            if (D[e.to] > D[e.from] + e.cost) {\n                D[e.to] = D[e.from] + e.cost;\n                if (!inQ[e.to]) {\n                    inQ[e.to] = true;\n                    PQ.insert(State(e.to, D[e.to]));\n                }\n            }\n        }\n    }\n    return D[to];\n}\n\nvoid main() {\n    input;\n\n    auto G = new Edge[][Nb];\n\n    auto s = Segment(A[0], A[1]);\n    foreach (int i; 0 .. Nb) {\n        foreach (int j; i + 1 .. Nb) {\n            if (s.intersect(Segment(B[i], B[j]))) continue;\n            G[i] ~= Edge(i, j, distance(B[i], B[j]));\n            G[j] ~= Edge(j, i, distance(B[i], B[j]));\n        }\n    }\n    double ans = distance(s.a, s.b) + G.dijkstra(0, 1);\n\n    G = new Edge[][Na];\n    s = Segment(B[0], B[1]);\n    foreach (int i; 0 .. Na) {\n        foreach (int j; i + 1 .. Na) {\n            if (s.intersect(Segment(A[i], A[j]))) continue;\n            G[i] ~= Edge(i, j, distance(A[i], A[j]));\n            G[j] ~= Edge(j, i, distance(A[i], A[j]));\n        }\n    }\n    ans = min(ans, distance(s.a, s.b) + G.dijkstra(0, 1));\n    if (ans >= 1e9) {\n        writeln(-1);\n        return;\n    }\n    writefln(\"%.10f\", ans);\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef _kosa(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    tc = (x1-x2)*(y3-y1)+(y1-y2)*(x1-x3)\n    td = (x1-x2)*(y4-y1)+(y1-y2)*(x1-x4)\n    return tc*td < 0\n\ndef kosa(a1, a2, b1, b2):\n    return _kosa(a1,a2,b1,b2) and _kosa(b1,b2,a1,a2)\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x1-x2)**2 + (y1-y2)**2)\n\ndef distance_p(a, b):\n    return distance(a[0], a[1], b[0], b[1])\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        a = [LI() for _ in range(n)]\n        b = [LI() for _ in range(m)]\n\n        def search(a,b1,b2,rg):\n            d = collections.defaultdict(lambda: inf)\n            s = 0\n            t = 1\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n                if u == t:\n                    return d[u]\n\n                for uv in rg:\n                    if v[uv]:\n                        continue\n                    if kosa(a[u],a[uv], b1,b2):\n                        continue\n                    ud = distance_p(a[u],a[uv])\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return -1\n\n        ad = distance_p(a[0], a[1])\n        bd = distance_p(b[0], b[1])\n        ar = search(a,b[0],b[1],list(range(1,n)))\n        br = search(b,a[0],a[1],list(range(1,m)))\n        r = -1\n        if ar < 0:\n            if br < 0:\n                return r\n            return '{:0.9f}'.format(br + ad)\n        if br < 0:\n            return '{:0.9f}'.format(ar + bd)\n\n        return '{:0.9f}'.format(min(ar + bd, br + ad))\n\n    while 1:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n        # print(n, rr[-1])\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom math import sqrt\nimport sys\nreadline = sys.stdin.buffer.readline\nwrite = sys.stdout.write\nN, M = map(int, readline().split())\nPS = [list(map(int, readline().split())) for i in range(N)]\nQS = [list(map(int, readline().split())) for i in range(M)]\n\ndef dot3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (bx - ox) + (ay - oy) * (by - oy)\ndef cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef dist2(A, B):\n    ax, ay = A; bx, by = B\n    return (ax - bx) ** 2 + (ay - by) ** 2\ndef is_intersection(P0, P1, Q0, Q1):\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    if C0 == C1 == 0:\n        E0 = dot3(P0, P1, Q0)\n        E1 = dot3(P0, P1, Q1)\n        if not E0 < E1:\n            E0, E1 = E1, E0\n        return E0 <= dist2(P0, P1) and 0 <= E1\n    return C0 * C1 <= 0 and D0 * D1 <= 0\n\ndef solve(N, PS, q0, q1):\n    yield 10**18\n    p0 = PS[0]; p1 = PS[1]\n    if not is_intersection(p0, p1, q0, q1):\n        yield sqrt(dist2(p0, p1))\n        return\n    V0 = [i for i in range(2, N) if not is_intersection(p0, PS[i], q0, q1)]\n    V1 = [i for i in range(2, N) if not is_intersection(p1, PS[i], q0, q1)]\n    D0 = [sqrt(dist2(p0, p)) for p in PS]\n    D1 = [sqrt(dist2(p1, p)) for p in PS]\n    for v0 in V0:\n        for v1 in V1:\n            if v0 != v1:\n                if is_intersection(PS[v0], PS[v1], q0, q1):\n                    continue\n                yield D0[v0] + D1[v1] + sqrt(dist2(PS[v0], PS[v1]))\n            else:\n                yield D0[v0] + D1[v1]\n\nans = min(\n        sqrt(dist2(QS[0], QS[1])) + min(solve(N, PS, QS[0], QS[1])),\n        sqrt(dist2(PS[0], PS[1])) + min(solve(M, QS, PS[0], PS[1]))\n        )\nif ans < 10**9:\n    write(\"%.16f\\n\" % ans)\nelse:\n    write(\"-1\\n\")\n"
  },
  {
    "language": "Rust",
    "code": "use std::ops::Sub;\nuse std::collections::BinaryHeap;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer\n}\nfn read_lines<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split(' ').map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nfn read_tabulate<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nmacro_rules! define {\n    () => {};\n    ($($token:tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        define_iter!(iter, $($token)*);\n    };\n}\nmacro_rules! define_iter {\n    ($iter:expr) =>{};\n    ($iter:expr,) =>{};\n    ($iter:expr, $id:ident:$t:tt $($tail:tt)*) => {\n        let $id: $t = $iter.next().unwrap().parse().ok().expect(\"Can't Parse\");\n        define_iter!($iter, $($tail)*);\n    };\n    ($iter:expr, mut $id:ident:$t:tt $($tail:tt)*) => {\n        let mut $id: $t = $iter.next().unwrap().parse().ok().expect(\"Can't Parse\");\n        define_iter!($iter, $($tail)*)\n    };\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\n#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]\nstruct Point {\n    x: i32, y: i32\n}\n#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]\nstruct Vector {\n    dx: i32, dy: i32\n}\nimpl Sub for Point {\n    type Output = Vector;\n    fn sub(self, rhs: Self) -> Self::Output {\n        Vector{dx: self.x - rhs.x, dy: self.y - rhs.y}\n    }\n}\nimpl Point {\n    fn distance(&self, rhs: &Point) -> f64 {\n        self.sub(*rhs).length()\n    }\n}\nimpl Vector {\n    fn length(&self) -> f64 {\n        ((self.dx * self.dx + self.dy * self.dy) as f64).sqrt()\n    }\n    fn cross(&self, that: &Vector) -> i32 {\n        self.dx * that.dy - self.dy * that.dx \n    }\n    fn dot(&self, that: &Vector) -> i32 {\n        self.dx * that.dx + self.dy * that.dy\n    }\n}\n#[derive(Copy, Clone, Default, Debug)]\nstruct Line {\n    end_a: Point, end_b: Point\n}\nimpl Line {\n    fn is_cross(&self, that: &Self) -> bool {\n        self.separate_by_line(that.end_a, that.end_b) && \n            that.separate_by_line(self.end_a, self.end_b)\n    }\n    fn separate_by_line(&self, c: Point, d: Point) -> bool {\n        let ab = self.end_a - self.end_b;\n        let cb = c - self.end_b;\n        let db = d - self.end_b;\n        ab.cross(&cb).signum() * ab.cross(&db).signum() <= 0\n    }\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n} \n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\nstruct Reverse<T>(T);\nimpl <T: PartialOrd> PartialOrd for Reverse<T> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl <T: Ord> Ord for Reverse<T> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\nfn min_length(points: &Vec<Point>, barrier: Line) -> Option<f64> {\n    let max = 1e100;\n    let mut min_len = vec![max; points.len()];\n    let mut heap = BinaryHeap::new();\n    min_len[0] = 0f64;\n    heap.push(Reverse(KeyValue{key: 0f64, value: 0}));\n    while let Some(Reverse(KeyValue{key: cost, value: current})) = heap.pop() {\n        if min_len[current] > cost {continue;}\n        for next in 0usize .. points.len() {\n            if next != current {\n                let line = Line{ end_a: points[current], end_b: points[next] };\n                if line.is_cross(&barrier) {continue;}\n                let len = points[current].distance(&points[next]);\n                if min_len[next] > len + cost {\n                    min_len[next] = len + cost;\n                    heap.push(Reverse(KeyValue{key: len + cost, value: next}));\n                }\n            }\n        }\n    }\n    if min_len[1] != max {\n        Some(min_len[1] + barrier.end_a.distance(&barrier.end_b))\n    }else {\n        None\n    }\n}\nfn main() {\n    define! {\n        na: usize\n        nb: usize\n    }\n    let tutete = (0 .. na).map(|_| {\n        define!{\n            x: i32\n            y: i32\n        }\n        Point{x, y}\n    }).collect::<Vec<_>>();\n    let totata = (0 .. nb).map(|_| {\n        define!{\n            x: i32\n            y: i32\n        }\n        Point{x, y}\n    }).collect::<Vec<_>>();\n    let for_tutete = min_length(&tutete, Line{end_a: totata[0], end_b: totata[1]});\n    let for_totata = min_length(&totata, Line{end_a: tutete[0], end_b: tutete[1]});\n    if let Some(a) = for_tutete {\n        if let Some(b) = for_totata {\n            println!(\"{:.15}\", if a < b { a } else { b });\n        }else {\n            println!(\"{:.15}\", a);\n        }\n    }else if let Some(a) = for_totata {\n        println!(\"{:.15}\", a);\n    }else {\n        println!(\"-1\");\n    }\n}\n"
  }
]