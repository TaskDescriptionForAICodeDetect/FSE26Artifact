[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint ccw(Point a, Point b, Point c) {\n    double val = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    if (val < -1e-9) return -1;\n    if (val > 1e-9) return 1;\n    return 0;\n}\n\nint intersect(Point a1, Point a2, Point b1, Point b2) {\n    int ccw1 = ccw(a1, a2, b1);\n    int ccw2 = ccw(a1, a2, b2);\n    int ccw3 = ccw(b1, b2, a1);\n    int ccw4 = ccw(b1, b2, a2);\n    \n    if (ccw1 * ccw2 < 0 && ccw3 * ccw4 < 0) return 1;\n    return 0;\n}\n\ndouble min(double a, double b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    Point A, B, C, D;\n    scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &A.x, &A.y, &B.x, &B.y, &C.x, &C.y, &D.x, &D.y);\n    \n    double min_length = DBL_MAX;\n    \n    if (!intersect(A, B, C, D)) {\n        min_length = distance(A, B) + distance(C, D);\n    }\n    \n    if (!intersect(A, C, B, D)) {\n        min_length = min(min_length, distance(A, C) + distance(B, D));\n    }\n    \n    if (!intersect(A, D, B, C)) {\n        min_length = min(min_length, distance(A, D) + distance(B, C));\n    }\n    \n    if (min_length == DBL_MAX) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%.10lf\\n\", min_length);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(Point a, Point b) {\n    return hypot(a.x - b.x, a.y - b.y);\n}\n\nbool segments_intersect(Point p1, Point p2, Point p3, Point p4) {\n    auto ccw = [](Point a, Point b, Point c) {\n        double val = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n        if (val < -1e-8) return -1;\n        if (val > 1e-8) return 1;\n        return 0;\n    };\n    \n    int d1 = ccw(p3, p4, p1);\n    int d2 = ccw(p3, p4, p2);\n    int d3 = ccw(p1, p2, p3);\n    int d4 = ccw(p1, p2, p4);\n    \n    if ((d1 * d2 < 0) && (d3 * d4 < 0)) return true;\n    \n    if (d1 == 0 && d2 == 0) {\n        if (max(p3.x, p4.x) < min(p1.x, p2.x) || max(p1.x, p2.x) < min(p3.x, p4.x)) return false;\n        if (max(p3.y, p4.y) < min(p1.y, p2.y) || max(p1.y, p2.y) < min(p3.y, p4.y)) return false;\n        return true;\n    }\n    \n    return false;\n}\n\ndouble solve(Point A, Point B, Point C, Point D) {\n    vector<pair<Point, Point>> options = {\n        {A, B}, {C, D},\n        {A, C}, {B, D},\n        {A, D}, {B, C}\n    };\n    \n    double min_length = -1;\n    \n    for (int i = 0; i < 2; ++i) {\n        for (int j = 2; j < 6; j += 2) {\n            Point p1 = options[i].first;\n            Point p2 = options[i].second;\n            Point p3 = options[j].first;\n            Point p4 = options[j].second;\n            \n            if (!segments_intersect(p1, p2, p3, p4)) {\n                double len = distance(p1, p2) + distance(p3, p4);\n                if (min_length < 0 || len < min_length) {\n                    min_length = len;\n                }\n            }\n        }\n    }\n    \n    return min_length;\n}\n\nint main() {\n    Point A, B, C, D;\n    cin >> A.x >> A.y >> B.x >> B.y;\n    cin >> C.x >> C.y >> D.x >> D.y;\n    \n    double result = solve(A, B, C, D);\n    \n    if (result < 0) {\n        cout << -1 << endl;\n    } else {\n        cout << fixed << setprecision(10) << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int xA = scanner.nextInt();\n        int yA = scanner.nextInt();\n        int xB = scanner.nextInt();\n        int yB = scanner.nextInt();\n        int xC = scanner.nextInt();\n        int yC = scanner.nextInt();\n        int xD = scanner.nextInt();\n        int yD = scanner.nextInt();\n\n        if (doIntersect(xA, yA, xB, yB, xC, yC, xD, yD)) {\n            // Find the minimal total length by considering the two possible non-intersecting pairs\n            double option1 = distance(xA, yA, xC, yC) + distance(xB, yB, xD, yD);\n            double option2 = distance(xA, yA, xD, yD) + distance(xB, yB, xC, yC);\n            double minLength = Math.min(option1, option2);\n            System.out.printf(\"%.10f\\n\", minLength);\n        } else {\n            double length = distance(xA, yA, xB, yB) + distance(xC, yC, xD, yD);\n            System.out.printf(\"%.10f\\n\", length);\n        }\n    }\n\n    private static boolean doIntersect(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\n        int o1 = orientation(x1, y1, x2, y2, x3, y3);\n        int o2 = orientation(x1, y1, x2, y2, x4, y4);\n        int o3 = orientation(x3, y3, x4, y4, x1, y1);\n        int o4 = orientation(x3, y3, x4, y4, x2, y2);\n\n        if (o1 != o2 && o3 != o4) {\n            return true;\n        }\n\n        if (o1 == 0 && onSegment(x1, y1, x3, y3, x2, y2)) return true;\n        if (o2 == 0 && onSegment(x1, y1, x4, y4, x2, y2)) return true;\n        if (o3 == 0 && onSegment(x3, y3, x1, y1, x4, y4)) return true;\n        if (o4 == 0 && onSegment(x3, y3, x2, y2, x4, y4)) return true;\n\n        return false;\n    }\n\n    private static int orientation(int x1, int y1, int x2, int y2, int x3, int y3) {\n        int val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2);\n        if (val == 0) return 0;\n        return (val > 0) ? 1 : 2;\n    }\n\n    private static boolean onSegment(int x1, int y1, int x2, int y2, int x3, int y3) {\n        return x2 <= Math.max(x1, x3) && x2 >= Math.min(x1, x3) &&\n               y2 <= Math.max(y1, y3) && y2 >= Math.min(y1, y3);\n    }\n\n    private static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n}",
    "timestamp": "2025-08-05 21:27:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class NevaKingdomRoads {\n    public static double minimumRoadLength(double[] A, double[] B, double[] C, double[] D) {\n        double[] roadA = new double[]{A[0], A[1], B[0], B[1]};\n        double[] roadB = new double[]{C[0], C[1], D[0], D[1]};\n        \n        if (doLinesIntersect(roadA, roadB)) {\n            return -1;\n        }\n        \n        double lenA = distance(A[0], A[1], B[0], B[1]);\n        double lenB = distance(C[0], C[1], D[0], D[1]);\n        \n        return lenA + lenB;\n    }\n    \n    private static boolean doLinesIntersect(double[] line1, double[] line2) {\n        double x1 = line1[0], y1 = line1[1];\n        double x2 = line1[2], y2 = line1[3];\n        double x3 = line2[0], y3 = line2[1];\n        double x4 = line2[2], y4 = line2[3];\n        \n        double denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n        if (denominator == 0) return false;\n        \n        double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n        double ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\n        \n        return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;\n    }\n    \n    private static double distance(double x1, double y1, double x2, double y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        double[] A = new double[2];\n        double[] B = new double[2];\n        double[] C = new double[2];\n        double[] D = new double[2];\n        \n        for (int i = 0; i < 2; i++) A[i] = scanner.nextDouble();\n        for (int i = 0; i < 2; i++) B[i] = scanner.nextDouble();\n        for (int i = 0; i < 2; i++) C[i] = scanner.nextDouble();\n        for (int i = 0; i < 2; i++) D[i] = scanner.nextDouble();\n        \n        System.out.printf(\"%.6f\\n\", minimumRoadLength(A, B, C, D));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:27:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\ndouble dist(double x1, double y1, double x2, double y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint ccw(double x1, double y1, double x2, double y2, double x3, double y3) {\n    double val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2);\n    if (val == 0) return 0;\n    return val > 0 ? 1 : -1;\n}\n\nint intersect(double x1, double y1, double x2, double y2, \n              double x3, double y3, double x4, double y4) {\n    int o1 = ccw(x1, y1, x2, y2, x3, y3);\n    int o2 = ccw(x1, y1, x2, y2, x4, y4);\n    int o3 = ccw(x3, y3, x4, y4, x1, y1);\n    int o4 = ccw(x3, y3, x4, y4, x2, y2);\n\n    if (o1 != o2 && o3 != o4) return 1;\n    return 0;\n}\n\nint main() {\n    double ax, ay, bx, by, cx, cy, dx, dy;\n    scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n          &ax, &ay, &bx, &by, &cx, &cy, &dx, &dy);\n\n    double total_length = dist(ax, ay, bx, by) + dist(cx, cy, dx, dy);\n\n    if (intersect(ax, ay, bx, by, cx, cy, dx, dy)) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    printf(\"%.10lf\\n\", total_length);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble dist(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    auto orientation = [](Point p, Point q, Point r) {\n        double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        if (val == 0) return 0;\n        return val > 0 ? 1 : 2;\n    };\n\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4) return true;\n    return false;\n}\n\nint main() {\n    Point A, B, C, D;\n    cin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y >> D.x >> D.y;\n\n    double minLength = numeric_limits<double>::max();\n    bool found = false;\n\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            Point p1 = i ? B : A;\n            Point p2 = i ? A : B;\n            Point q1 = j ? D : C;\n            Point q2 = j ? C : D;\n\n            if (!doIntersect(p1, p2, q1, q2)) {\n                double length = dist(p1, p2) + dist(q1, q2);\n                minLength = min(minLength, length);\n                found = true;\n            }\n        }\n    }\n\n    if (found) {\n        cout << fixed << minLength << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from sys import stdin, stdout\nfrom itertools import combinations\nfrom math import sqrt\n\ndef distance(p1, p2):\n    return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef do_intersect(p1, q1, p2, q2):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def on_segment(p, q, r):\n        if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n            return True\n        return False\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef min_total_length(A, B, C, D):\n    towns = [A, B, C, D]\n    min_len = float('inf')\n    found = False\n\n    for (p1, q1), (p2, q2) in combinations([(A, B), (C, D)], 2):\n        if not do_intersect(p1, q1, p2, q2):\n            total_len = distance(p1, q1) + distance(p2, q2)\n            min_len = min(min_len, total_len)\n            found = True\n\n    return min_len if found else -1\n\n# Input\nA = tuple(map(int, stdin.readline().strip().split()))\nB = tuple(map(int, stdin.readline().strip().split()))\nC = tuple(map(int, stdin.readline().strip().split()))\nD = tuple(map(int, stdin.readline().strip().split()))\n\n# Output\nstdout.write(f\"{min_total_length(A, B, C, D)}\\n\")",
    "timestamp": "2025-08-13 06:28:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class NevaKingdom {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        double xA = scanner.nextDouble();\n        double yA = scanner.nextDouble();\n        double xB = scanner.nextDouble();\n        double yB = scanner.nextDouble();\n        double xC = scanner.nextDouble();\n        double yC = scanner.nextDouble();\n        double xD = scanner.nextDouble();\n        double yD = scanner.nextDouble();\n\n        scanner.close();\n\n        double distanceAB = distance(xA, yA, xB, yB);\n        double distanceCD = distance(xC, yC, xD, yD);\n\n        if (doLinesIntersect(xA, yA, xB, yB, xC, yC, xD, yD)) {\n            System.out.println(-1);\n        } else {\n            System.out.println(distanceAB + distanceCD);\n        }\n    }\n\n    private static double distance(double x1, double y1, double x2, double y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n\n    private static boolean doLinesIntersect(double x1, double y1, double x2, double y2,\n                                            double x3, double y3, double x4, double y4) {\n        return doBoundingBoxesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) &&\n                lineSegmentTouchesOrCrossesLine(x1, y1, x2, y2, x3, y3, x4, y4) &&\n                lineSegmentTouchesOrCrossesLine(x3, y3, x4, y4, x1, y1, x2, y2);\n    }\n\n    private static boolean doBoundingBoxesIntersect(double x1, double y1, double x2, double y2,\n                                                    double x3, double y3, double x4, double y4) {\n        return Math.min(x1, x2) <= Math.max(x3, x4) && Math.min(x3, x4) <= Math.max(x1, x2) &&\n                Math.min(y1, y2) <= Math.max(y3, y4) && Math.min(y3, y4) <= Math.max(y1, y2);\n    }\n\n    private static boolean lineSegmentTouchesOrCrossesLine(double x1, double y1, double x2, double y2,\n                                                           double x3, double y3, double x4, double y4) {\n        int d1 = direction(x3, y3, x4, y4, x1, y1);\n        int d2 = direction(x3, y3, x4, y4, x2, y2);\n        int d3 = direction(x1, y1, x2, y2, x3, y3);\n        int d4 = direction(x1, y1, x2, y2, x4, y4);\n\n        if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0)))\n            return true;\n\n        if (d1 == 0 && isOnSegment(x3, y3, x4, y4, x1, y1)) return true;\n        if (d2 == 0 && isOnSegment(x3, y3, x4, y4, x2, y2)) return true;\n        if (d3 == 0 && isOnSegment(x1, y1, x2, y2, x3, y3)) return true;\n        if (d4 == 0 && isOnSegment(x1, y1, x2, y2, x4, y4)) return true;\n\n        return false;\n    }\n\n    private static int direction(double xi, double yi, double xj, double yj, double xk, double yk) {\n        double a = (xk - xi) * (yj - yi);\n        double b = (xj - xi) * (yk - yi);\n        double crossProduct = a - b;\n\n        if (crossProduct > 0) return 1;\n        if (crossProduct < 0) return -1;\n        return 0;\n    }\n\n    private static boolean isOnSegment(double xi, double yi, double xj, double yj, double xk, double yk) {\n        return Math.min(xi, xj) <= xk && xk <= Math.max(xi, xj) &&\n                Math.min(yi, yj) <= yk && yk <= Math.max(yi, yj);\n    }\n}",
    "timestamp": "2025-08-13 06:28:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ndouble distance(Point p1, Point p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint orientation(Point p, Point q, Point r) {\n    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0; // collinear\n    return (val > 0) ? 1 : 2; // clockwise or counterclockwise\n}\n\nint doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4)\n        return 1;\n\n    return 0;\n}\n\ndouble min(double a, double b) {\n    return (a < b) ? a : b;\n}\n\nint main() {\n    Point A, B, C, D;\n    scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", &A.x, &A.y, &B.x, &B.y, &C.x, &C.y, &D.x, &D.y);\n\n    double d1 = distance(A, B) + distance(C, D);\n    double d2 = distance(A, C) + distance(B, D);\n    double d3 = distance(A, D) + distance(B, C);\n\n    double minDistance = -1;\n    \n    if (!doIntersect(A, B, C, D)) {\n        minDistance = d1;\n    }\n    if (!doIntersect(A, C, B, D)) {\n        if (minDistance == -1) minDistance = d2;\n        else minDistance = min(minDistance, d2);\n    }\n    if (!doIntersect(A, D, B, C)) {\n        if (minDistance == -1) minDistance = d3;\n        else minDistance = min(minDistance, d3);\n    }\n\n    printf(\"%.6lf\\n\", minDistance);\n    return 0;\n}",
    "timestamp": "2025-08-13 06:28:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_road_problem(a1, b1, a2, b2):\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def line_intersection(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        \n        denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n        if denom == 0:\n            return False\n        \n        ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom\n        ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom\n        \n        return 0 <= ua <= 1 and 0 <= ub <= 1\n\n    def check_intersection(road1, road2):\n        return line_intersection(road1, road2)\n\n    min_length = float('inf')\n    \n    for road1 in [(a1[0], a1[1], b1[0], b1[1]), (b1[0], b1[1], a1[0], a1[1])]:\n        for road2 in [(a2[0], a2[1], b2[0], b2[1]), (b2[0], b2[1], a2[0], a2[1])]:\n            if not check_intersection(road1, road2):\n                length = distance(a1, b1) + distance(a2, b2)\n                min_length = min(min_length, length)\n    \n    return round(min_length, 2) if min_length != float('inf') else -1\n\n# Example usage\na1 = (0, 0)\nb1 = (1, 1)\na2 = (2, 0)\nb2 = (3, 1)\nprint(solve_road_problem(a1, b1, a2, b2))",
    "timestamp": "2025-08-13 06:29:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef compute_min_total_length(A, B, C, D):\n    def cross(o, a, b):\n        return (a[0] - o[0])*(b[1] - o[1]) - (a[1] - o[1])*(b[0] - o[0])\n\n    def segments_intersect(a1, a2, b1, b2):\n        c1 = cross(a1, a2, b1)\n        c2 = cross(a1, a2, b2)\n        c3 = cross(b1, b2, a1)\n        c4 = cross(b1, b2, a2)\n        \n        if ((c1 > 0 and c2 < 0) or (c1 < 0 and c2 > 0)) and ((c3 > 0 and c4 < 0) or (c3 < 0 and c4 > 0)):\n            return True\n        return False\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    AB = (A, B)\n    CD = (C, D)\n    \n    if segments_intersect(A, B, C, D):\n        return -1\n    \n    options = [\n        distance(A, B) + distance(C, D),\n        distance(A, C) + distance(B, D),\n        distance(A, D) + distance(B, C)\n    ]\n    \n    min_length = min(options)\n    \n    for option in options:\n        if option == min_length:\n            if option == options[0]:\n                if not segments_intersect(A, B, C, D):\n                    return option\n            elif option == options[1]:\n                if not segments_intersect(A, C, B, D):\n                    return option\n            elif option == options[2]:\n                if not segments_intersect(A, D, B, C):\n                    return option\n    \n    return -1\n\nA = tuple(map(int, input().split()))\nB = tuple(map(int, input().split()))\nC = tuple(map(int, input().split()))\nD = tuple(map(int, input().split()))\n\nresult = compute_min_total_length(A, B, C, D)\nprint(result if result != -1 else -1)",
    "timestamp": "2025-08-13 06:29:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2));\n}\n\nbool isIntersecting(Point A, Point B, Point C, Point D) {\n    auto ccw = [](Point A, Point B, Point C) {\n        return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);\n    };\n    return ccw(A, C, D) != ccw(B, C, D) && ccw(A, B, C) != ccw(A, B, D);\n}\n\nint main() {\n    Point A, B, C, D;\n    cin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y >> D.x >> D.y;\n\n    double distanceAB = distance(A, B);\n    double distanceCD = distance(C, D);\n    \n    if (!isIntersecting(A, B, C, D)) {\n        cout << fixed << distanceAB + distanceCD << endl;\n    } else {\n        cout << -1 << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:32:13"
  }
]