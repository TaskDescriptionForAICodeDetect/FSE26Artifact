[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, a, b, q;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> a >> b >> q;\n\tvector<pair<int, char>> xs;\n\trep(i, a){ int x; char c; cin >> x >> c; xs.emplace_back(--x, c); }\n\t\n\tvector<pi> ys;\n\trep(i, b){ int y, h; cin >> y >> h; ys.emplace_back(--y, --h); }\n\tif(ys.back().second >= 0) ys.emplace_back(n, -1);\n\t\n\tmap<pi, int> left;\n\trep(i, ys.size()){\n\t\tif(ys[i].second < 0) continue;\n\t\tint L = ys[i].first, R = ys[i + 1].first;\n\t\tint l = ys[i].second, r = l + R - L, d = L - l;\n\t\tleft[pi(L, R)] = d;\n\t}\n\t\n\tauto move = [&](int p){\n\t\tmap<pi,int>::iterator it = left.lower_bound(pi(p + 1, 0));\n\t\tif(it == left.begin()) return p;\n\t\t--it;\n\t\t\n\t\tif(!(it->first.first <= p && p < it->first.second)) return p;\n\t\twhile(it->second == 0);\n\t\tint l = it->first.first - it->second, t = (p - l) / it->second;\n\t\treturn p - t * it->second;\n\t};\n\t\n\tunordered_map<int, char> cs;\n\tfor(auto i : xs){\n\t\tint p = i.first;\n\t\tfor(int nxt = p; p != (nxt = move(p)); p = nxt);\n\t\tcs[p] = i.second;\n\t}\n\t/*\n\tfor(auto p : cs) dbg(p.first, p.second);\n\tfor(auto p : left) dbg(p.first, p.second);\n\t*/\n\tstring ans;\n\twhile(q--){\n\t\tint p; cin >> p;\n\t\tfor(int nxt = --p; p != (nxt = move(p)); p = nxt);\n\t\tans += cs.count(p) ? cs[p] : '?';\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nint L, n, m, Q;\nint Y[1010], H[1010];\nchar Res[1010];\nint w[1010];\nchar p[1010];\nmap<int, char>Map[1010];\nvector<int>G[1010];\nint Loc(int x) {\n\treturn (lower_bound(Y, Y + m + 2, x+1) - Y) - 1;\n}\nint main(){\n\tint i;\n\tscanf(\"%d%d%d%d\", &L, &n, &m, &Q);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tscanf(\"%s\", p+i);\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &Y[i],&H[i]);\n\t}\n\tY[m + 1] = L + 1;\n\tfor (i = 0; i <= m; i++)if (!H[i])H[i] = -L;\n\tfor (i = 1; i <= n; i++) {\n\t\tint x = w[i];\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tMap[t][x % (Y[t] - H[t])] = p[i];\n\t\t\tif (H[t] <= 0)break;\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t}\n\tfor (i = 1; i <= Q; i++) {\n\t\tint x;\n\t\tchar u = '?';\n\t\tscanf(\"%d\", &x);\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tif (Map[t].count(x % (Y[t] - H[t]))) u = Map[t][x % (Y[t] - H[t])];\n\t\t\tif (H[t] <= 0)break;\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t\tprintf(\"%c\", u);\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, a, b, q;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> a >> b >> q;\n\tvector<pair<int, char>> xs;\n\trep(i, a){ int x; char c; cin >> x >> c; xs.emplace_back(--x, c); }\n\t\n\tvector<pi> ys;\n\trep(i, b){ int y, h; cin >> y >> h; ys.emplace_back(--y, --h); }\n\tif(ys.back().second >= 0) ys.emplace_back(n, -1);\n\t\n\tmap<pi, int> left;\n\trep(i, ys.size()){\n\t\tif(ys[i].second < 0) continue;\n\t\twhile(i == ys.size()-1);\n\t\tint L = ys[i].first, R = ys[i + 1].first;\n\t\tint l = ys[i].second, r = l + R - L, d = L - l;\n\t\tleft[pi(L, R)] = d;\n\t}\n\t\n\tauto move = [&](int p){\n\t\tmap<pi,int>::iterator it = left.lower_bound(pi(p + 1, 0));\n\t\tif(it == left.begin()) return p;\n\t\t--it;\n\t\t\n\t\tif(!(it->first.first <= p && p < it->first.second)) return p;\n\t\twhile(it->second == 0);\n\t\tint l = it->first.first - it->second, t = (p - l) / it->second;\n\t\treturn p - t * it->second;\n\t};\n\t\n\tmap<int, char> cs;\n\tfor(auto i : xs){\n\t\tint p = i.first;\n\t\tfor(int nxt = p; p != (nxt = move(p)); p = nxt);\n\t\tcs[p] = i.second;\n\t}\n\t/*\n\tfor(auto p : cs) dbg(p.first, p.second);\n\tfor(auto p : left) dbg(p.first, p.second);\n\t*/\n\tstring ans;\n\twhile(q--){\n\t\tint p; cin >> p;\n\t\tfor(int nxt = --p; p != (nxt = move(p)); p = nxt);\n\t\tans += cs.count(p) ? cs[p] : '?';\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<int, char> ans;\n\nconst int N = 1100;\n\nint n, a, b, q;\n\nint x[N], y[N], h[N];\nchar c[N][10];\n\nint get(int pos) {\n\twhile (1) {\n\t\tint now = upper_bound(y, y + b + 1, pos) - y - 1;\n\t\tif (now == 0 || h[now] == 0) return pos;\n\t\tint per = y[now] - h[now];\n\t\tpos -= ((pos - y[now]) / per + 1) * per;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin >> n >> a >> b >> q;\n\tfor (int i = 1; i <= a; i++) cin >> x[i] >> c[i];\n\ty[0] = 1, y[b + 1] = n + 1;\n\tfor (int i = 1; i <= b; i++) cin >> y[i] >> h[i];\n\tfor (int i = 1; i <= a; i++) {\n\t\tans[get(x[i])] = c[i][0];\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tint z; cin >> z; \n//\t\tcerr << z << endl;\n\t\tz = get(z);\n//\t\tcerr << z << endl;\n\t\tif (!ans.count(z)) cout << \"?\";\n\t\telse cout << ans[z];\n\t}\n\tcout << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint main(){\n  int n, a, b, q;\n  int x[SIZE], y[SIZE], h[SIZE];\n  char c[SIZE];\n\n  pair<int,int> from[SIZE], to[SIZE];\n\n  scanf(\"%d%d%d%d\",&n,&a,&b,&q);\n\n  for(int i=0;i<a;i++){\n    scanf(\"%d %c\",x+i, c+i);\n    x[i]--;\n  }\n\n  int s = 0;\n  \n  for(int i=0;i<=b;i++){\n    if(i < b)\n      scanf(\"%d%d\",y+i, h+i);\n    else\n      y[i] = n+1;\n    \n    if(i>0){\n      if(h[i-1] != 0){\n        from[s] = {y[i-1]-1, y[i]-2};\n        to[s] = {h[i-1]-1, h[i-1] + y[i]-y[i-1] - 2};\n        s++;\n      }\n    }\n  }\n\n  unordered_map<int,char> dic;\n  queue<pair<int,char> > que;\n\n  for(int i=0;i<a;i++){\n    que.push({x[i], c[i]});\n  }\n\n  while(que.size()){\n    auto p = que.front();\n    que.pop();\n\n    int pos = p.first;\n    int ch = p.second;\n\n    if(dic.find(pos) != dic.end()) continue;\n    dic[pos] = ch;\n    \n    for(int i=0;i<s;i++){\n      if(from[i].first <= pos && pos <= from[i].second){\n        int newpos = (pos - to[i].first) % (from[i].first - to[i].first) + to[i].first;\n        que.push({newpos, ch});\n      }\n    }\n  }\n\n\n  char ansStr[SIZE] = {};\n  \n  for(int i=0;i<q;i++){\n    int z;\n    char ans = '?';\n    scanf(\"%d\",&z);\n    z--;\n\n    queue<int> que;\n    unordered_set<int> visited;\n\n    if(dic.find(z) != dic.end())\n      ans = dic[z];\n    else\n      que.push(z);\n    \n    while(que.size()){\n      int pos = que.front(); que.pop();\n\n      if(visited.find(pos) != visited.end()) continue;\n      visited.insert(pos);\n      \n      for(int i=0;i<s;i++){\n        if(from[i].first <= pos && pos <= from[i].second){\n          int newpos = (pos - to[i].first) % (from[i].first - to[i].first) + to[i].first;\n\n          if(dic.find(newpos) != dic.end()){\n            que = queue<int>();\n            ans = dic[newpos];\n            break;\n          }else{\n            que.push(newpos);\n          }\n        }\n      }\n    }\n\n    ansStr[i] = ans;\n  }\n\n  printf(\"%s\\n\",ansStr);\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint L, n, m, Q;\nint Y[1010], H[1010];\nchar Res[1010];\nstruct point {\n\tint x, num;\n\tchar ch;\n}w[2010];\nvector<int>G[1010];\nint Loc(int x) {\n\treturn (lower_bound(Y, Y + m + 2, x+1) - Y) - 1;\n}\nvoid Check(int a, int x, int T, char &ch) {\n\tint i;\n\tfor (i = 0; i < G[a].size(); i++) {\n\t\tpoint tp = w[G[a][i]];\n\t\tif (tp.x%T == x%T) {\n\t\t\tif (!ch && tp.ch)ch = tp.ch;\n\t\t\tif (tp.num && ch && !Res[tp.num]) {\n\t\t\t\tRes[tp.num] = ch;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i;\n\tchar p[3];\n\tscanf(\"%d%d%d%d\", &L, &n, &m, &Q);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i].x);\n\t\tscanf(\"%s\", p);\n\t\tw[i].ch = p[0];\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &Y[i],&H[i]);\n\t}\n\tY[m + 1] = L + 1;\n\tfor (i = 1; i <= Q; i++) {\n\t\tscanf(\"%d\", &w[n+i].x);\n\t\tw[n+i].num = i;\n\t\tw[n + i].ch = 0;\n\t}\n\tn = n + Q;\n\tfor (i = 1; i <= n; i++) {\n\t\tint t = Loc(w[i].x);\n\t\tG[t].push_back(i);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tchar ch = w[i].ch;\n\t\tint x = w[i].x;\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tif (!H[t]) {\n\t\t\t\tCheck(t, x, L, ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCheck(t, x, Y[t] - H[t], ch);\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t\tif (w[i].num && !Res[w[i].num])Res[w[i].num] = ch;\n\t}\n\tfor (i = 1; i <= Q; i++) {\n\t\tif (Res[i])printf(\"%c\", Res[i]);\n\t\telse printf(\"?\");\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nint main(){\n  int n, a, b, q;\n  int x[SIZE], y[SIZE], h[SIZE];\n  char c[SIZE];\n\n  pair<int,int> from[SIZE], to[SIZE];\n\n  scanf(\"%d%d%d%d\",&n,&a,&b,&q);\n\n  for(int i=0;i<a;i++){\n    scanf(\"%d %c\",x+i, c+i);\n    x[i]--;\n  }\n\n  int s = 0;\n  \n  for(int i=0;i<=b;i++){\n    if(i < b)\n      scanf(\"%d%d\",y+i, h+i);\n    else\n      y[i] = n+1;\n    \n    if(i>0){\n      if(h[i-1] != 0){\n        from[s] = {y[i-1]-1, y[i]-2};\n        to[s] = {h[i-1]-1, h[i-1] + y[i]-y[i-1] - 2};\n        s++;\n      }\n    }\n  }\n\n  map<int,char> dic;\n  queue<pair<int,char> > que;\n\n  for(int i=0;i<a;i++){\n    que.push({x[i], c[i]});\n  }\n\n  while(que.size()){\n    auto p = que.front();\n    que.pop();\n\n    int pos = p.first;\n    int ch = p.second;\n\n    if(dic.find(pos) != dic.end()) continue;\n    dic[pos] = ch;\n    \n    for(int i=0;i<s;i++){\n      if(from[i].first <= pos && pos <= from[i].second){\n        int newpos = (pos - to[i].first) % (from[i].first - to[i].first) + to[i].first;\n        que.push({newpos, ch});\n      }\n    }\n  }\n\n\n  char ansStr[SIZE] = {};\n  \n  for(int i=0;i<q;i++){\n    int z;\n    char ans = '?';\n    scanf(\"%d\",&z);\n    z--;\n\n    queue<int> que;\n    set<int> visited;\n\n    if(dic.find(z) != dic.end())\n      ans = dic[z];\n    else\n      que.push(z);\n    \n    while(que.size()){\n      int pos = que.front(); que.pop();\n\n      if(visited.find(pos) != visited.end()) continue;\n      visited.insert(pos);\n      \n      for(int i=0;i<s;i++){\n        if(from[i].first <= pos && pos <= from[i].second){\n          int newpos = (pos - to[i].first) % (from[i].first - to[i].first) + to[i].first;\n\n          if(dic.find(newpos) != dic.end()){\n            que = queue<int>();\n            ans = dic[newpos];\n            break;\n          }else{\n            que.push(newpos);\n          }\n        }\n      }\n    }\n\n    ansStr[i] = ans;\n  }\n\n  printf(\"%s\\n\",ansStr);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nint L, n, m, Q;\nint Y[1010], H[1010];\nchar Res[1010];\nint w[1010];\nchar p[1010];\nmap<int, char>Map[1010];\nvector<int>G[1010];\nint Loc(int x) {\n\treturn (lower_bound(Y, Y + m + 2, x+1) - Y) - 1;\n}\nint main(){\n\tint i;\n\tscanf(\"%d%d%d%d\", &L, &n, &m, &Q);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tscanf(\"%s\", p+i);\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &Y[i],&H[i]);\n\t}\n\tY[m + 1] = L + 1;\n\tH[0] = -L;\n\tfor (i = 1; i <= n; i++) {\n\t\tint x = w[i];\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tMap[t][x % (Y[t] - H[t])] = p[i];\n\t\t\tif (H[t] <= 0)break;\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t}\n\tfor (i = 1; i <= Q; i++) {\n\t\tint x;\n\t\tchar u = '?';\n\t\tscanf(\"%d\", &x);\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tif (Map[t].count(x % (Y[t] - H[t]))) u = Map[t][x % (Y[t] - H[t])];\n\t\t\tif (H[t] <= 0)break;\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t\tprintf(\"%c\", u);\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "from bisect import bisect\nn, a, b, q = map(int, input().split())\n\nW = [input().split() for i in range(a)]\nX = [int(x) for x, c in W]\nC = [c for x, c in W]\n\nP = [list(map(int, input().split())) for i in range(b)]\nY = [y for y, h in P] + [n+1]\nD = [0]*b\n\nfor i in range(b):\n    y0, h = P[i]; y1 = Y[i+1]\n    l = y1 - y0\n    D[i] = min(y0 - h, l)\n\nidx = 0\nS = {}\nfor i in range(a):\n    x = X[i]; c = C[i]\n    S[x] = c\n    if x < Y[0]:\n        continue\n    while Y[idx+1] <= x: idx += 1\n    i = idx; j = i\n    while Y[0] <= x:\n        while x < Y[i]: i -= 1\n        y0, h = P[i]; y1 = Y[i+1]\n        if h == 0: break\n        x = h + ((x - y0) % D[i])\n        assert x < y0\n        S[x] = c\ndef check(z):\n    if z in S:\n        return S[z]\n    i = bisect(Y, z)-1\n    while Y[0] <= z:\n        while z < Y[i]: i -= 1\n        y0, h = P[i]; y1 = Y[i+1]\n        if h == 0: break\n        z = h + ((z - y0) % D[i])\n        assert z < y0\n        if z in S:\n            return S[z]\n    return '?'\n\nZ = [int(input()) for i in range(q)]\nprint(*map(check, Z), sep='')"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nint s = 0;\npair<int,int> from[SIZE], to[SIZE];\n\nint getPos(int x){\n  for(int i=s-1;i>=0;i--)\n    if(from[i].first <= x && x<=from[i].second)\n      x = (x - to[i].first) % (from[i].first - to[i].first) + to[i].first;\n  return x;\n}\n\nint main(){\n  int n, a, b, q;\n  int x[SIZE], y[SIZE], h[SIZE];\n  char c[SIZE];\n\n\n  scanf(\"%d%d%d%d\",&n,&a,&b,&q);\n\n  for(int i=0;i<a;i++){\n    scanf(\"%d %c\",x+i, c+i);\n    x[i]--;\n  }\n  \n  for(int i=0;i<=b;i++){\n    if(i < b)\n      scanf(\"%d%d\",y+i, h+i);\n    else\n      y[i] = n+1;\n    \n    if(i>0){\n      if(h[i-1] != 0){\n        from[s] = {y[i-1]-1, y[i]-2};\n        to[s] = {h[i-1]-1, h[i-1] + y[i]-y[i-1] - 2};\n        s++;\n      }\n    }\n  }\n  \n  unordered_map<int,char> dic;\n\n  for(int i=0;i<a;i++){\n    dic[getPos(x[i])] = c[i];\n  }\n\n  char ansStr[SIZE] = {};\n  \n  for(int i=0;i<q;i++){\n    int z;\n    char ans = '?';\n    scanf(\"%d\",&z);\n    z = getPos(z-1);\n\n    if(dic.find(z) != dic.end())\n      ans = dic[z];\n    \n    ansStr[i] = ans;\n  }\n\n  printf(\"%s\\n\",ansStr);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main(){\n    int N,A,B,Q;\n    cin >> N >> A >> B >> Q;\n    vector<int> X(A+1),Y(B+1),H(B+1);\n    vector<char> C(A+1);\n    for(int i=1;i<=A;i++) cin >> X[i] >> C[i];\n    for(int j=1;j<=B;j++) cin >> Y[j] >> H[j];\n    \n    auto f = [&](int x,int id){\n        int k = (x-Y[id])/(Y[id]-H[id])+1;\n        return x+k*(H[id]-Y[id]);\n    };\n\n    auto most_left = [&](int x){\n        while(true){\n            vector<int>::iterator it = upper_bound(Y.begin(),Y.end(),x);\n            it--;\n            int id = it-Y.begin();\n            if(!H[id]) return x;\n            x = f(x,id);\n        }\n        return -1; \n    };\n\n    map<int,char> m;\n    for(int i=1;i<=A;i++) m[most_left(X[i])] = C[i];\n    for(int i=0;i<Q;i++){\n        int z;\n        cin >> z;\n        int l = most_left(z);\n        cout << (m.count(l)? m[l]:'?');\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,a,b,q;\n  cin>>n>>a>>b>>q;\n  vector<Int> x(a),y(b),h(b),z(q);\n  vector<char> c(a);\n  for(Int i=0;i<a;i++) cin>>x[i]>>c[i],x[i]--;\n  for(Int i=0;i<b;i++) cin>>y[i]>>h[i],y[i]--,h[i]--;\n  for(Int i=0;i<q;i++) cin>>z[i],z[i]--;\n\n  y.emplace_back(n);\n\n  auto pos=\n    [&](Int k)->Int{\n      Int j=b;\n      while(1){\n\twhile(j>=0&&k<y[j]) j--;\n\tif(j<0||h[j]<0||y[j+1]<=k) return k;\n\tInt l=y[j+1]-y[j];\n\tif(h[j]+l<=y[j]){\n\t  k=h[j]+(k-y[j]);\n\t  continue;\n\t}\n\tInt m=y[j]-h[j];\n\tk=h[j]+(k-y[j])%m;\n      }\n    };\n  \n  map<Int, char> dp;  \n  for(Int i=0;i<a;i++) dp[pos(x[i])]=c[i];\n  for(Int i=0;i<q;i++){\n    Int k=pos(z[i]);\n    cout<<(dp.count(k)?dp[k]:'?');\n  }\n  cout<<endl;  \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,a,b,q;\n  cin>>n>>a>>b>>q;\n  vector<Int> x(a),y(b),h(b),z(q);\n  vector<char> c(a);\n  for(Int i=0;i<a;i++) cin>>x[i]>>c[i],x[i]--;\n  for(Int i=0;i<b;i++) cin>>y[i]>>h[i],y[i]--,h[i]--;\n  for(Int i=0;i<q;i++) cin>>z[i],z[i]--;\n\n  y.emplace_back(n);\n\n  auto pos=\n    [&](Int k)->Int{\n      Int j=b;\n      while(1){\n\twhile(j>=0&&k<y[j]) j--;\n\tif(j<0||h[j]<0||y[j+1]<=k) return k;\n\tInt l=y[j+1]-y[j];\n\tif(h[j]+l<=y[j]){\n\t  k=h[j]+(k-y[j]);\n\t  continue;\n\t}\n\tInt m=y[j]-h[j];\n\tk=h[j]+(k-y[j])%m;\n      }\n    };\n  \n  map<Int, char> dp;  \n  for(Int i=0;i<a;i++) dp[pos(x[i])]=c[i];\n  for(Int i=0;i<q;i++){\n    Int k=pos(z[i]);\n    cout<<(dp.count(k)?dp[k]:'?');\n  }\n  cout<<endl;  \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, a, b, q;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> a >> b >> q;\n\tvector<pair<int, char>> xs;\n\trep(i, a){ int x; char c; cin >> x >> c; xs.emplace_back(--x, c); }\n\t\n\tvector<pi> ys;\n\trep(i, b){ int y, h; cin >> y >> h; ys.emplace_back(--y, --h); }\n\tif(ys.back().second >= 0) ys.emplace_back(n, -1);\n\t\n\tmap<pi, int> left;\n\trep(i, ys.size()){\n\t\tif(ys[i].second < 0) continue;\n\t\twhile(i == ys.size()-1);\n\t\tint L = ys[i].first, R = ys[i + 1].first;\n\t\tint l = ys[i].second, r = l + R - L, d = L - l;\n\t\tleft[pi(L, R)] = d;\n\t}\n\t\n\tauto move = [&](int p){\n\t\tmap<pi,int>::iterator it = left.lower_bound(pi(p + 1, 0));\n\t\tif(it == left.begin()) return p;\n\t\t--it;\n\t\t\n\t\tif(!(it->first.first <= p && p < it->first.second)) return p;\n\t\twhile(it->second == 0);\n\t\tint l = it->first.first - it->second, t = (p - l) / it->second;\n\t\treturn p - t * it->second;\n\t};\n\t\n\tunordered_map<int, char> cs;\n\tfor(auto i : xs){\n\t\tint p = i.first;\n\t\tfor(int nxt = p; p != (nxt = move(p)); p = nxt);\n\t\tcs[p] = i.second;\n\t}\n\t/*\n\tfor(auto p : cs) dbg(p.first, p.second);\n\tfor(auto p : left) dbg(p.first, p.second);\n\t*/\n\tstring ans;\n\twhile(q--){\n\t\tint p; cin >> p;\n\t\tfor(int nxt = --p; p != (nxt = move(p)); p = nxt);\n\t\tans += cs.count(p) ? cs[p] : '?';\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<ll, int> ll_i;\nstruct edge { int v, w; };\nconst int INF = INT_MAX;\nconst int MOD = 1e9 + 114514;\n\nint f(int x, vector<int>& X, vector<int>& d) {\n\tfor (;;) {\n\t\tint i = upper_bound(X.begin(), X.end(), x) - X.begin() - 1;\n\t\tif (!d[i]) return x;\n\t\tint l = X[i], t = (x - l) / d[i] + 1;\n\t\tx -= t * d[i];\n\t}\n}\n\nint main() {\n\tint gomi, A, N, B;\n\tcin >> gomi >> A >> N >> B;\n\tvector<int> a(A);\n\tvector<char> c(A);\n\trep(i, A) {\n\t\tstring s;\n\t\tcin >> a[i] >> s;\n\t\ta[i]--;\n\t\tc[i] = s[0];\n\t}\n\tvector<int> X;\n\tX.pb(0);\n\tvector<int> d(N + 1);\n\tfor (int i = 1; i < N + 1; i++) {\n\t\tint x; x--;\n\t\tcin >> x >> d[i], x--;\n\t\tif (d[i]) d[i] = x - d[i] + 1;\n\t\tX.pb(x);\n\t}\n\tX.pb(INF);\n\tvector<int> b(B);\n\trep(i, B) cin >> b[i], b[i]--;\n\trep(i, A) a[i] = f(a[i], X, d);\n\trep(i, B) b[i] = f(b[i], X, d);\n\trep(j, B) {\n\t\tchar ans = '?';\n\t\trep(i, A) if (a[i] == b[j]) ans = c[i];\n\t\tcout << ans;\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint main(){\nprintf(\"ICPC\\n\");\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nint L, n, m, Q;\nint Y[1010], H[1010];\nchar Res[1010];\nint w[1010];\nchar p[1010];\nmap<int, char>Map[1010];\nvector<int>G[1010];\nint Loc(int x) {\n\treturn (lower_bound(Y, Y + m + 2, x+1) - Y) - 1;\n}\nint main(){\n\tint i;\n\tchar p[3];\n\tscanf(\"%d%d%d%d\", &L, &n, &m, &Q);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tscanf(\"%s\", p+i);\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &Y[i],&H[i]);\n\t}\n\tY[m + 1] = L + 1;\n\tH[0] = -L;\n\tfor (i = 1; i <= n; i++) {\n\t\tint x = w[i];\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tMap[t][x % (Y[t] - H[t])] = p[i];\n\t\t\tif (H[t] <= 0)break;\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t}\n\tfor (i = 1; i <= Q; i++) {\n\t\tint x;\n\t\tchar u = '?';\n\t\tscanf(\"%d\", &x);\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tif (Map[t].count(x % (Y[t] - H[t]))) u = Map[t][x % (Y[t] - H[t])];\n\t\t\tif (H[t] <= 0)break;\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t\tprintf(\"%c\", u);\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint L, n, m, Q;\nint Y[1010], H[1010];\nchar Res[1010];\nstruct point {\n\tint x, num;\n\tchar ch;\n}w[2010];\nvector<int>G[1010];\nint Loc(int x) {\n\treturn (lower_bound(Y, Y + m + 2, x+1) - Y) - 1;\n}\nvoid Check(int a, int x, int T, char &ch) {\n\tint i;\n\tfor (i = 0; i < G[a].size(); i++) {\n\t\tpoint tp = w[G[a][i]];\n\t\tif (tp.x%T == x%T) {\n\t\t\tif (!ch && tp.ch)ch = tp.ch;\n\t\t\tif (tp.num && ch && !Res[tp.num]) {\n\t\t\t\tRes[tp.num] = ch;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i;\n\tchar p[3];\n\tscanf(\"%d%d%d%d\", &L, &n, &m, &Q);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i].x);\n\t\tscanf(\"%s\", p);\n\t\tw[i].ch = p[0];\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &Y[i],&H[i]);\n\t}\n\tY[m + 1] = L + 1;\n\tfor (i = 1; i <= Q; i++) {\n\t\tscanf(\"%d\", &w[n+i].x);\n\t\tw[n+i].num = i;\n\t}\n\tn = n + Q;\n\tfor (i = 1; i <= n; i++) {\n\t\tint t = Loc(w[i].x);\n\t\tG[t].push_back(i);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tchar ch = w[i].ch;\n\t\tint x = w[i].x;\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tif (!H[t]) {\n\t\t\t\tCheck(t, x, L, ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCheck(t, x, Y[t] - H[t], ch);\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t\tif (w[i].num && !Res[w[i].num])Res[w[i].num] = ch;\n\t}\n\tfor (i = 1; i <= Q; i++) {\n\t\tif (Res[i])printf(\"%c\", Res[i]);\n\t\telse printf(\"?\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, a, b, q; cin >> n >> a >> b >> q;\n    vector<int> x(a);\n    vector<char> c(a);\n    for(int i = 0; i < a; ++i) {\n        cin >> x[i] >> c[i];\n    }\n    vector<int> y(b), h(b);\n    for(int i = 0; i < b; ++i) {\n        cin >> y[i] >> h[i];\n    }\n\n    auto find_left_most_pos = [&] (int p) {\n        while(true) {\n            const int i = upper_bound(begin(y), end(y), p) - begin(y) - 1;\n            if(i < 0 || h[i] == 0) break;\n            p -= ((p - y[i]) / (y[i] - h[i]) + 1) * (y[i] - h[i]);\n        }\n        return p;\n    };\n    map<int, char> ans;\n    for(int i = 0; i < a; ++i) {\n        ans[find_left_most_pos(x[i])] = c[i];\n    }\n\n    while(q--) {\n        int z; cin >> z;\n        z = find_left_most_pos(z);\n        cout << (ans.count(z) ? ans[z] : '?');\n    }\n    cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nint L, n, m, Q;\nint Y[1010], H[1010];\nchar Res[1010];\nint w[1010];\nchar p[1010];\nmap<int, char>Map[1010];\nvector<int>G[1010];\nint Loc(int x) {\n\treturn (lower_bound(Y, Y + m + 2, x+1) - Y) - 1;\n}\nint main(){\n\tint i;\n\tscanf(\"%d%d%d%d\", &L, &n, &m, &Q);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t\tscanf(\"%s\", p+i);\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &Y[i],&H[i]);\n\t}\n\tY[m + 1] = L + 1;\n\tH[0] = -L;\n\tfor (i = 1; i <= n; i++) {\n\t\tint x = w[i];\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tMap[t][x % (Y[t] - H[t])] = p[i];\n\t\t\tif (H[t] <= 0)break;\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t}\n\tfor (i = 1; i <= Q; i++) {\n\t\tint x;\n\t\tchar u = '?';\n\t\tscanf(\"%d\", &x);\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tif (Map[t][x % (Y[t] - H[t])]) u = Map[t][x % (Y[t] - H[t])];\n\t\t\tif (H[t] <= 0)break;\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t\tprintf(\"%c\", u);\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, a, b, q;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> a >> b >> q;\n\tvector<pair<int, char>> xs;\n\trep(i, a){ int x; char c; cin >> x >> c; xs.emplace_back(--x, c); }\n\t\n\tvector<pi> ys;\n\trep(i, b){ int y, h; cin >> y >> h; ys.emplace_back(--y, --h); }\n\tif(ys.size() && ys.back().second >= 0) ys.emplace_back(n, -1);\n\t\n\tmap<pi, int> left;\n\trep(i, ys.size()){\n\t\tif(ys[i].second < 0) continue;\n\t\tint L = ys[i].first, R = ys[i + 1].first;\n\t\tint l = ys[i].second, r = l + R - L, d = L - l;\n\t\tleft[pi(L, R)] = d;\n\t}\n\t\n\tauto move = [&](int p){\n\t\tmap<pi,int>::iterator it = left.lower_bound(pi(p + 1, 0));\n\t\tif(it == left.begin()) return p;\n\t\t--it;\n\t\t\n\t\tif(!(it->first.first <= p && p < it->first.second)) return p;\n\t\tint l = it->first.first - it->second, t = (p - l) / it->second;\n\t\treturn p - t * it->second;\n\t};\n\t\n\tunordered_map<int, char> cs;\n\tfor(auto i : xs){\n\t\tint p = i.first;\n\t\tfor(int nxt = p; p != (nxt = move(p)); p = nxt);\n\t\tcs[p] = i.second;\n\t}\n\t/*\n\tfor(auto p : cs) dbg(p.first, p.second);\n\tfor(auto p : left) dbg(p.first, p.second);\n\t*/\n\tstring ans;\n\twhile(q--){\n\t\tint p; cin >> p;\n\t\tfor(int nxt = --p; p != (nxt = move(p)); p = nxt);\n\t\tans += cs.count(p) ? cs[p] : '?';\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, a, b, q;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> a >> b >> q;\n\tvector<pair<int, char>> xs;\n\trep(i, a){ int x; char c; cin >> x >> c; xs.emplace_back(--x, c); }\n\t\n\tvector<pi> ys;\n\trep(i, b){ int y, h; cin >> y >> h; ys.emplace_back(--y, --h); }\n\tif(ys.back().second >= 0) ys.emplace_back(n, -1);\n\t\n\tmap<pi, int> left;\n\trep(i, ys.size()){\n\t\tif(ys[i].second < 0) continue;\n\t\tint L = ys[i].first, R = ys[i + 1].first;\n\t\tint l = ys[i].second, r = l + R - L, d = L - l;\n\t\tleft[pi(L, R)] = d;\n\t}\n\t\n\tauto move = [&](int p){\n\t\tmap<pi,int>::iterator it = left.lower_bound(pi(p + 1, 0));\n\t\tif(it == left.begin()) return p;\n\t\t--it;\n\t\t\n\t\tif(!(it->first.first <= p && p < it->first.second)) return p;\n\t\tint l = it->first.first - it->second, t = (p - l) / it->second;\n\t\treturn p - t * it->second;\n\t};\n\t\n\tunordered_map<int, char> cs;\n\tfor(auto i : xs){\n\t\tint p = i.first;\n\t\tfor(int nxt = p; p != (nxt = move(p)); p = nxt);\n\t\tcs[p] = i.second;\n\t}\n\t/*\n\tfor(auto p : cs) dbg(p.first, p.second);\n\tfor(auto p : left) dbg(p.first, p.second);\n\t*/\n\tstring ans;\n\twhile(q--){\n\t\tint p; cin >> p;\n\t\tfor(int nxt = --p; p != (nxt = move(p)); p = nxt);\n\t\tans += cs.count(p) ? cs[p] : '?';\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;\nconst int N=1100;\nint n,a,b,q,i,x,m,known[N];char ch[N][9];\nint y[N],h[N];\nmap<int,char>T;\nstruct E{int l,d;E(){}E(int _l,int _d){l=_l,d=_d;}}e[N];\ninline int go(int x){\n    int i=m;\n    while(1){\n        while(i&&e[i].l>x)i--;\n        int l=e[i].l,d=e[i].d;\n        if(!i||!d)break;\n        x-=((x-l)/d+1)*d;\n    }\n    return x;\n}\nint main(){\n    scanf(\"%d%d%d%d\",&n,&a,&b,&q);\n    for(i=1;i<=a;i++)scanf(\"%d%s\",&known[i],ch[i]);\n    for(i=1;i<=b;i++)scanf(\"%d%d\",&y[i],&h[i]);\n    y[b+1]=n+1;\n    for(i=1;i<=b;i++)e[++m]=E(y[i],h[i]?y[i]-h[i]:0);\n    for(i=1;i<=a;i++)T[go(known[i])]=ch[i][0];\n    while(q--){\n        scanf(\"%d\",&x);\n        x=go(x);\n        if(T.find(x)==T.end())putchar('?');else putchar(T[x]);\n    }\n    putchar('\\n');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\nstruct WORD{\n\tint loc;\n\tchar ch;\n};\n\nstruct Info{\n\tint Y,H;\n};\n\nstruct Data{\n\tData(int arg_Y,int arg_length,int arg_index){\n\t\tY = arg_Y;\n\t\tlength = arg_length;\n\t\tindex = arg_index;\n\t}\n\tint Y,length,index;\n};\n\nint N,A,B,num_query;\nmap<int,char> MAP;\nWORD word[NUM];\nInfo info[NUM];\nvector<Data> V;\n\nint get_loc(int loc){\n\n\tbool FLG;\n\tint left,right,mid;\n\n\twhile(true){\n\t\tFLG = false;\n\n\t\tleft = 0,right = V.size()-1,mid = (left+right)/2;\n\n\t\twhile(left <= right){\n\n\t\t\tif(loc >= V[mid].Y && loc <= V[mid].Y+V[mid].length-1){\n\n\t\t\t\tloc = (loc-V[mid].Y)%(V[mid].Y-info[V[mid].index].H)+info[V[mid].index].H;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\n\t\t\t}else if(loc > V[mid].Y){\n\n\t\t\t\tleft = mid+1;\n\n\t\t\t}else{\n\n\t\t\t\tright = mid-1;\n\t\t\t}\n\t\t\tmid = (left+right)/2;\n\t\t}\n\n\t\tif(!FLG)break;\n\t}\n\n\treturn loc;\n}\n\nint main(){\n\n\tscanf(\"%d %d %d %d\",&N,&A,&B,&num_query);\n\n\tint loc;\n\tchar buf[2];\n\n\tfor(int loop = 0; loop < A; loop++){\n\n\t\tscanf(\"%d %s\",&word[loop].loc,buf);\n\t\tword[loop].ch = buf[0];\n\t}\n\n\tfor(int i = 0; i < B; i++){\n\t\tscanf(\"%d %d\",&info[i].Y,&info[i].H);\n\t}\n\tinfo[B].Y = N+1;\n\n\tfor(int i = 0; i < B; i++){\n\t\tif(info[i].H == 0)continue;\n\t\tV.push_back(Data(info[i].Y,info[i+1].Y-info[i].Y,i));\n\t}\n\n\tfor(int loop = 0; loop < A; loop++){\n\n\t\tloc = word[loop].loc;\n\t\tMAP[get_loc(loc)] = word[loop].ch;\n\t}\n\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\n\t\tscanf(\"%d\",&loc);\n\n\t\tauto at = MAP.find(loc = get_loc(loc));\n\n\t\tif(at == MAP.end()){\n\n\t\t\tprintf(\"?\");\n\n\t\t}else{\n\n\t\t\tprintf(\"%c\",MAP[loc]);\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, a, b, q;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> a >> b >> q;\n\tvector<pair<int, char>> xs;\n\trep(i, a){ int x; char c; cin >> x >> c; xs.emplace_back(--x, c); }\n\t\n\tvector<pi> ys;\n\trep(i, b){ int y, h; cin >> y >> h; ys.emplace_back(--y, --h); }\n\tif(ys.back().second >= 0) ys.emplace_back(n, -1);\n\t\n\tmap<pi, int> left;\n\trep(i, ys.size()){\n\t\tint L = ys[i].first, R = ys[i + 1].first;\n\t\tint l = ys[i].second, r = l + R - L, d = L - l;\n\t\tleft[pi(L, R)] = d;\n\t\ti++;\n\t}\n\t\n\tauto move = [&](int p){\n\t\tmap<pi,int>::iterator it = left.lower_bound(pi(p + 1, 0));\n\t\tif(it == left.begin()) return p;\n\t\t--it;\n\t\t\n\t\tif(!(it->first.first <= p && p < it->first.second)) return p;\n\t\tint l = it->first.first - it->second, t = (p - l) / it->second;\n\t\treturn p - t * it->second;\n\t};\n\t\n\tunordered_map<int, char> cs;\n\tfor(auto i : xs){\n\t\tint p = i.first;\n\t\tfor(int nxt = p; p != (nxt = move(p)); p = nxt);\n\t\tcs[p] = i.second;\n\t}\n\t/*\n\tfor(auto p : cs) dbg(p.first, p.second);\n\tfor(auto p : left) dbg(p.first, p.second);\n\t*/\n\tstring ans;\n\twhile(q--){\n\t\tint p; cin >> p;\n\t\tfor(int nxt = --p; p != (nxt = move(p)); p = nxt);\n\t\tans += cs.count(p) ? cs[p] : '?';\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,A,B,Q;\n\nint X[1111];char C[1111];\n\nint Y[1111],H[1111];\n\nint latte(int x){\n    while(true){\n        int k=upper_bound(Y,Y+B,x)-Y;\n        k--;\n        if(H[k]==-1)break;\n        int l=Y[k+1]-Y[k];\n        int d=Y[k]-H[k];\n        if(d<l){\n            x=Y[k]+(x-Y[k])%d;\n        }\n        x-=d;\n    }\n    return x;\n}\n\nsigned main(){\n    cin>>N>>A>>B>>Q;\n    rep(i,A)cin>>X[i]>>C[i],X[i]--;\n\n    Y[0]=0;H[0]=-1;\n    rep(i,B){\n        cin>>Y[i+1]>>H[i+1];\n        Y[i+1]--;H[i+1]--;\n    }\n    Y[B+1]=N;B+=2;\n\n    map<int,char>m;\n    rep(i,A){\n        int x=latte(X[i]);\n        m[x]=C[i];\n    }\n\n    rep(i,Q){\n        int x;cin>>x;\n        x--;\n        x=latte(x);\n        if(m.find(x)==m.end())cout<<\"?\";\n        else cout<<m[x];\n    }cout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint L, n, m, Q;\nint Y[1010], H[1010];\nchar Res[1010];\nstruct point {\n\tint x, num;\n\tchar ch;\n}w[2010];\nvector<int>G[1010];\nint Loc(int x) {\n\treturn (lower_bound(Y, Y + m + 2, x+1) - Y) - 1;\n}\nvoid Check(int a, int x, int T, char &ch) {\n\tint i;\n\tfor (i = 0; i < G[a].size(); i++) {\n\t\tpoint tp = w[G[a][i]];\n\t\tif (tp.x%T == x%T) {\n\t\t\tif (!ch && tp.ch)ch = tp.ch;\n\t\t\tif (tp.num && ch && !Res[tp.num]) {\n\t\t\t\tRes[tp.num] = ch;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint i;\n\tchar p[3];\n\tscanf(\"%d%d%d%d\", &L, &n, &m, &Q);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &w[i].x);\n\t\tscanf(\"%s\", p);\n\t\tw[i].ch = p[0];\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tscanf(\"%d%d\", &Y[i],&H[i]);\n\t}\n\tY[m + 1] = L + 1;\n\tfor (i = 1; i <= Q; i++) {\n\t\tscanf(\"%d\", &w[n+i].x);\n\t\tw[n+i].num = i;\n\t}\n\tn = n + Q;\n\tfor (i = 1; i <= n; i++) {\n\t\tint t = Loc(w[i].x);\n\t\tG[t].push_back(i);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tchar ch = w[i].ch;\n\t\tint x = w[i].x;\n\t\twhile (1) {\n\t\t\tint t = Loc(x);\n\t\t\tif (!H[t]) {\n\t\t\t\tCheck(t, x, L, ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCheck(t, x, Y[t] - H[t], ch);\n\t\t\tx -= ((x - Y[t]) / (Y[t] - H[t]) + 1) * (Y[t] - H[t]);\n\t\t}\n\t\tif (w[i].num && !Res[w[i].num])Res[w[i].num] = ch;\n\t}\n\tfor (i = 1; i <= Q; i++) {\n\t\tif (Res[i])printf(\"%c\", Res[i]);\n\t\telse printf(\"?\");\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn, a, b, q = map(int, input().split())\n\nW = [input().split() for i in range(a)]\nX = [int(x) for x, c in W]\nC = [c for x, c in W]\n\nP = [list(map(int, input().split())) for i in range(b)]\nY = [y for y, h in P] + [n+1]\nD = [0]*b\n\nfor i in range(b):\n    y0, h = P[i]; y1 = Y[i+1]\n    l = y1 - y0\n    D[i] = min(y0 - h, l)\n\nZ = [int(input()) for i in range(q)]\n\nidx = 0\nS = {}\nfor i in range(a):\n    x = X[i]; c = C[i]\n    S[x] = c\n    if x < Y[0]:\n        continue\n    while Y[idx+1] < x: idx += 1\n    i = idx\n    while Y[0] <= x:\n        while x < Y[i]: i -= 1\n        y0, h = P[i]; y1 = Y[i+1]\n        if h == 0: break\n        x = h + ((x - y0) % D[i])\n        assert x < y0\n        S[x] = c\ndef check(z):\n    if z in S:\n        return S[z]\n    i = bisect(Y, z)-1\n    while Y[0] <= z:\n        while z < Y[i]: i -= 1\n        y0, h = P[i]; y1 = Y[i+1]\n        if h == 0: break\n        z = h + ((z - y0) % D[i])\n        assert z < y0\n        if z in S:\n            return S[z]\n    return '?'\nprint(*map(check, Z), sep='')"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn, a, b, q = map(int, input().split())\n\nW = [input().split() for i in range(a)]\nX = [int(x) for x, c in W]\nC = [c for x, c in W]\n\nP = [list(map(int, input().split())) for i in range(b)]\nY = [y for y, h in P] + [n+1]\nD = [0]*b\n\nfor i in range(b):\n    y0, h = P[i]\n    y1 = Y[i+1]\n    l = y1 - y0\n    if y0 < h + l:\n        D[i] = y0 - h\n    else:\n        D[i] = l\n\nZ = [int(input()) for i in range(q)]\n\nidx = 0\nS = {}\nfor i in range(a):\n    x = X[i]; c = C[i]\n    S[x] = c\n    if x < Y[0]:\n        continue\n    while Y[idx+1] < x: idx += 1\n    i = idx\n    while Y[0] <= x:\n        while x < Y[i]: i -= 1\n        y0, h = P[i]; y1 = Y[i+1]\n        if h == 0: break\n        x = h + ((x - y0) % D[i])\n        S[x] = c\nans = []\nfor z in Z:\n    if z not in S:\n        i = bisect(Y, z)-1\n        while Y[0] <= z:\n            while z < Y[i]: i -= 1\n            y0, h = P[i]; y1 = Y[i+1]\n            if h == 0: break\n            z = h + ((z - y0) % D[i])\n            if z in S:\n                break\n    if z in S:\n        ans.append(S[z])\n    else:\n        ans.append('?')\nprint(*ans, sep='')"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn, a, b, q = map(int, input().split())\n\nW = [input().split() for i in range(a)]\nX = [int(x) for x, c in W]\nC = [c for x, c in W]\n\nP = [list(map(int, input().split())) for i in range(b)]\nY = [y for y, h in P] + [n+1]\nD = [0]*b\n\nfor i in range(b):\n    y0, h = P[i]; y1 = Y[i+1]\n    l = y1 - y0\n    D[i] = min(y0 - h, l)\n\nidx = 0\nS = {}\nfor i in range(a):\n    x = X[i]; c = C[i]\n    S[x] = c\n    if x < Y[0]:\n        continue\n    while Y[idx+1] <= x: idx += 1\n    i = idx; j = i\n    while Y[0] <= x:\n        while x < Y[i]: i -= 1\n        y0, h = P[i]; y1 = Y[i+1]\n        if h == 0: break\n        x = h + ((x - y0) % D[i])\n        assert x < y0\n        S[x] = c\ndef check(z):\n    if z in S:\n        return S[z]\n    i = bisect(Y, z)-1\n    while Y[0] <= z:\n        while z < Y[i]: i -= 1\n        y0, h = P[i]; y1 = Y[i+1]\n        if h == 0: break\n        z = h + ((z - y0) % D[i])\n        assert z < y0\n        if z in S:\n            return S[z]\n    return '?'\n\nZ = [int(input()) for i in range(q)]\nprint(*map(check, Z), sep='')"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn, a, b, q = map(int, input().split())\n\nW = [input().split() for i in range(a)]\nX = [int(x) for x, c in W]\nC = [c for x, c in W]\n\nP = [list(map(int, input().split())) for i in range(b)]\nY = [y for y, h in P] + [n+1]\nD = [0]*b\n\nfor i in range(b):\n    y0, h = P[i]\n    y1 = Y[i+1]\n    l = y1 - y0\n    if y0 < h + l:\n        D[i] = y0 - h\n    else:\n        D[i] = l\n\nZ = [int(input()) for i in range(q)]\n\nidx = 0\nS = {}\nfor i in range(a):\n    x = X[i]; c = C[i]\n    S[x] = c\n    while Y[idx+1] < x: idx += 1\n    i = idx\n    while Y[0] <= x:\n        while x < Y[i]: i -= 1\n        y0, h = P[i]; y1 = Y[i+1]\n        if h == 0: break\n        x = h + ((x - y0) % D[i])\n        S[x] = c\nans = []\nfor z in Z:\n    if z not in S:\n        i = bisect(Y, z)\n        while Y[0] <= z:\n            while z < Y[i]: i -= 1\n            y0, h = P[i]; y1 = Y[i+1]\n            if h == 0: break\n            z = h + ((z - y0) % D[i])\n            if z in S:\n                break\n    if z in S:\n        ans.append(S[z])\n    else:\n        ans.append('?')\nprint(*ans, sep='')"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect\nn, a, b, q = map(int, input().split())\n\nW = [input().split() for i in range(a)]\nX = [int(x) for x, c in W]\nC = [c for x, c in W]\n\nP = [list(map(int, input().split())) for i in range(b)]\nY = [y for y, h in P] + [n+1]\nD = [0]*b\n\nfor i in range(b):\n    y0, h = P[i]; y1 = Y[i+1]\n    D[i] = min(y0 - h, y1 - y0)\n\nidx = 0\nS = {}\nfor i in range(a):\n    x = X[i]; c = C[i]\n    S[x] = c\n    if x < Y[0]:\n        continue\n    while Y[idx+1] <= x: idx += 1\n    i = idx\n    while Y[0] <= x:\n        while x < Y[i]: i -= 1\n        y0, h = P[i]\n        if h == 0: break\n        x = h + ((x - y0) % D[i])\n        S[x] = c\ndef check(z):\n    if z in S:\n        return S[z]\n    i = bisect(Y, z)-1\n    while Y[0] <= z:\n        while z < Y[i]: i -= 1\n        y0, h = P[i]\n        if h == 0: break\n        z = h + ((z - y0) % D[i])\n        if z in S:\n            return S[z]\n    return '?'\n\nZ = (int(input()) for i in range(q))\nprint(*map(check, Z), sep='')"
  }
]