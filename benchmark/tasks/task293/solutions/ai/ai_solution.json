[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int N, M, K, Q;\n    scanf(\"%d %d %d %d\", &N, &M, &K, &Q);\n\n    char *secret = (char *)malloc((N + 1) * sizeof(char));\n    for (int i = 0; i < N; i++) {\n        secret[i] = '?';\n    }\n    secret[N] = '\\0';\n\n    for (int i = 0; i < M; i++) {\n        int pos;\n        char c;\n        scanf(\"%d %c\", &pos, &c);\n        secret[pos - 1] = c;\n    }\n\n    for (int i = 0; i < K; i++) {\n        int a, b, l;\n        scanf(\"%d %d %d\", &a, &b, &l);\n        a--;\n        b--;\n        for (int j = 0; j < l; j++) {\n            if (secret[a + j] != '?' && secret[b + j] == '?') {\n                secret[b + j] = secret[a + j];\n            } else if (secret[a + j] == '?' && secret[b + j] != '?') {\n                secret[a + j] = secret[b + j];\n            }\n        }\n    }\n\n    for (int i = 0; i < Q; i++) {\n        int pos;\n        scanf(\"%d\", &pos);\n        printf(\"%c\", secret[pos - 1]);\n    }\n    printf(\"\\n\");\n\n    free(secret);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    int N, M, K, Q;\n    cin >> N >> M >> K >> Q;\n\n    vector<char> secret(N + 1, '?');\n    unordered_map<int, char> fixed;\n\n    for (int i = 0; i < M; ++i) {\n        int pos;\n        char c;\n        cin >> pos >> c;\n        secret[pos] = c;\n        fixed[pos] = c;\n    }\n\n    vector<pair<int, int>> dups;\n    bool possible = true;\n    for (int i = 0; i < K; ++i) {\n        int a, b;\n        cin >> a >> b;\n        if (fixed.count(a) && fixed.count(b)) {\n            if (fixed[a] != fixed[b]) {\n                possible = false;\n            }\n        } else if (fixed.count(a)) {\n            secret[b] = fixed[a];\n            fixed[b] = fixed[a];\n        } else if (fixed.count(b)) {\n            secret[a] = fixed[b];\n            fixed[a] = fixed[b];\n        } else {\n            dups.emplace_back(a, b);\n        }\n    }\n\n    if (!possible) {\n        for (int i = 0; i < Q; ++i) {\n            cout << \"?\";\n        }\n        cout << endl;\n        return 0;\n    }\n\n    for (auto& p : dups) {\n        int a = p.first, b = p.second;\n        if (secret[a] != '?' && secret[b] != '?') {\n            if (secret[a] != secret[b]) {\n                possible = false;\n                break;\n            }\n        } else if (secret[a] != '?') {\n            secret[b] = secret[a];\n        } else if (secret[b] != '?') {\n            secret[a] = secret[b];\n        }\n    }\n\n    if (!possible) {\n        for (int i = 0; i < Q; ++i) {\n            cout << \"?\";\n        }\n        cout << endl;\n        return 0;\n    }\n\n    vector<int> queries(Q);\n    for (int i = 0; i < Q; ++i) {\n        cin >> queries[i];\n    }\n\n    for (int pos : queries) {\n        cout << secret[pos];\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:57:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SecretString {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        int Q = scanner.nextInt();\n\n        char[] secret = new char[N + 1];\n        Arrays.fill(secret, '?');\n\n        for (int i = 0; i < M; i++) {\n            int pos = scanner.nextInt();\n            char c = scanner.next().charAt(0);\n            secret[pos] = c;\n        }\n\n        Map<Integer, Integer> dupMap = new HashMap<>();\n        for (int i = 0; i < K; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            dupMap.put(a, b);\n        }\n\n        for (Map.Entry<Integer, Integer> entry : dupMap.entrySet()) {\n            int a = entry.getKey();\n            int b = entry.getValue();\n            if (secret[a] != '?') {\n                secret[b] = secret[a];\n            } else if (secret[b] != '?') {\n                secret[a] = secret[b];\n            }\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < Q; i++) {\n            int pos = scanner.nextInt();\n            result.append(secret[pos]);\n        }\n\n        System.out.println(result.toString());\n    }\n}",
    "timestamp": "2025-08-05 20:57:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SecretString {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int length = scanner.nextInt();\n        int numHints = scanner.nextInt();\n        \n        char[] result = new char[length];\n        Arrays.fill(result, '?');\n        \n        for (int i = 0; i < numHints; i++) {\n            String hintType = scanner.next();\n            \n            if (hintType.equals(\"letter\")) {\n                int pos = scanner.nextInt() - 1;\n                char letter = scanner.next().charAt(0);\n                result[pos] = letter;\n            } else if (hintType.equals(\"substring\")) {\n                int pos1 = scanner.nextInt() - 1;\n                int pos2 = scanner.nextInt() - 1;\n                \n                if (pos1 >= 0 && pos1 < length && pos2 >= 0 && pos2 < length) {\n                    for (int j = 0; j < Math.min(length - pos1, length - pos2); j++) {\n                        if (result[pos1 + j] != '?' && result[pos2 + j] != '?' \n                            && result[pos1 + j] != result[pos2 + j]) {\n                            break;\n                        }\n                        \n                        if (result[pos1 + j] == '?') {\n                            result[pos1 + j] = result[pos2 + j];\n                        }\n                        \n                        if (result[pos2 + j] == '?') {\n                            result[pos2 + j] = result[pos1 + j];\n                        }\n                    }\n                }\n            }\n        }\n        \n        int numQueries = scanner.nextInt();\n        \n        for (int i = 0; i < numQueries; i++) {\n            int pos = scanner.nextInt() - 1;\n            System.out.print(result[pos]);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 20:58:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LENGTH 100\n\nvoid solve_secret_string() {\n    int string_length, num_fixed_hints, num_duplicate_hints, num_queries;\n    char secret_string[MAX_LENGTH + 1] = {0};\n    int fixed_positions[MAX_LENGTH];\n    char fixed_letters[MAX_LENGTH];\n    int duplicate_pos1[MAX_LENGTH], duplicate_pos2[MAX_LENGTH];\n    int query_positions[MAX_LENGTH];\n    char result[MAX_LENGTH + 1] = {0};\n\n    // Read input\n    scanf(\"%d\", &string_length);\n    scanf(\"%d\", &num_fixed_hints);\n\n    // Process fixed letter hints\n    for (int i = 0; i < num_fixed_hints; i++) {\n        scanf(\"%d %c\", &fixed_positions[i], &fixed_letters[i]);\n        secret_string[fixed_positions[i] - 1] = fixed_letters[i];\n    }\n\n    // Process duplicate substring hints\n    scanf(\"%d\", &num_duplicate_hints);\n    for (int i = 0; i < num_duplicate_hints; i++) {\n        int pos1, pos2, length;\n        scanf(\"%d %d %d\", &pos1, &pos2, &length);\n        \n        // Check and mark duplicated substrings\n        int match = 1;\n        for (int j = 0; j < length; j++) {\n            if (secret_string[pos1 - 1 + j] != 0 && \n                secret_string[pos2 - 1 + j] != 0 && \n                secret_string[pos1 - 1 + j] != secret_string[pos2 - 1 + j]) {\n                match = 0;\n                break;\n            }\n            \n            if (secret_string[pos1 - 1 + j] != 0)\n                secret_string[pos2 - 1 + j] = secret_string[pos1 - 1 + j];\n            else if (secret_string[pos2 - 1 + j] != 0)\n                secret_string[pos1 - 1 + j] = secret_string[pos2 - 1 + j];\n        }\n    }\n\n    // Process query positions\n    scanf(\"%d\", &num_queries);\n    for (int i = 0; i < num_queries; i++) {\n        scanf(\"%d\", &query_positions[i]);\n        \n        // Check if letter is already known\n        if (secret_string[query_positions[i] - 1] != 0)\n            result[i] = secret_string[query_positions[i] - 1];\n        else\n            result[i] = '?';\n    }\n\n    // Output results\n    printf(\"%s\\n\", result);\n}\n\nint main() {\n    solve_secret_string();\n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass SecretStringReconstructor {\nprivate:\n    int stringLength;\n    vector<char> result;\n    unordered_map<int, char> fixedPositions;\n    vector<pair<int, int>> duplicateSubstrings;\n\npublic:\n    SecretStringReconstructor(int length) : stringLength(length), result(length, '?') {}\n\n    void addFixedPosition(int pos, char letter) {\n        fixedPositions[pos] = letter;\n        result[pos] = letter;\n    }\n\n    void addDuplicateSubstring(int start1, int start2) {\n        duplicateSubstrings.push_back({start1, start2});\n    }\n\n    vector<char> reconstruct() {\n        // Apply fixed positions\n        for (const auto& pos : fixedPositions) {\n            result[pos.first] = pos.second;\n        }\n\n        // Handle duplicate substrings\n        for (const auto& substr : duplicateSubstrings) {\n            int start1 = substr.first;\n            int start2 = substr.second;\n            int len = findSubstringLength(start1, start2);\n\n            for (int i = 0; i < len; ++i) {\n                if (result[start1 + i] != '?' && result[start2 + i] != '?') {\n                    if (result[start1 + i] != result[start2 + i]) {\n                        return {}; // Inconsistent hints, no solution\n                    }\n                } else if (result[start1 + i] != '?') {\n                    result[start2 + i] = result[start1 + i];\n                } else if (result[start2 + i] != '?') {\n                    result[start1 + i] = result[start2 + i];\n                }\n            }\n        }\n\n        return result;\n    }\n\nprivate:\n    int findSubstringLength(int start1, int start2) {\n        int maxLen = min(stringLength - start1, stringLength - start2);\n        return maxLen;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, k, q;\n    cin >> n >> k >> q;\n\n    SecretStringReconstructor reconstructor(n);\n\n    // Process fixed letter hints\n    for (int i = 0; i < k; ++i) {\n        int pos;\n        char letter;\n        cin >> pos >> letter;\n        reconstructor.addFixedPosition(pos - 1, letter);\n    }\n\n    // Process duplicate substring hints\n    int duplicates;\n    cin >> duplicates;\n    for (int i = 0; i < duplicates; ++i) {\n        int start1, start2;\n        cin >> start1 >> start2;\n        reconstructor.addDuplicateSubstring(start1 - 1, start2 - 1);\n    }\n\n    // Reconstruct the string\n    vector<char> result = reconstructor.reconstruct();\n\n    // Process query positions\n    for (int i = 0; i < q; ++i) {\n        int pos;\n        cin >> pos;\n        cout << result[pos - 1];\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def determine_secret_string(length, hints, queries):\n    secret = ['?'] * length\n    \n    for hint in hints:\n        if len(hint) == 2:\n            pos, letter = hint\n            secret[pos] = letter\n        elif len(hint) == 3:\n            start, end, step = hint\n            for i in range(start, end, step):\n                secret[i] = secret[i % step]\n                \n    result = ''.join(secret[q] for q in queries)\n    return result\n\n# Example usage:\n# length = 10\n# hints = [(0, 'a'), (2, 'b'), (1, 5, 2)] # (pos, 'letter'), (start, end, step)\n# queries = [0, 1, 2, 3, 4, 5]\n# print(determine_secret_string(length, hints, queries))",
    "timestamp": "2025-08-13 04:17:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SecretStringSolver {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int stringLength = scanner.nextInt();\n        int fixedHintsCount = scanner.nextInt();\n        int duplicateHintsCount = scanner.nextInt();\n        \n        char[] secretString = new char[stringLength];\n        Arrays.fill(secretString, '?');\n\n        // Read fixed hints (specific letters at certain positions)\n        for (int i = 0; i < fixedHintsCount; i++) {\n            int position = scanner.nextInt();\n            char letter = scanner.next().charAt(0);\n            secretString[position] = letter;\n        }\n\n        // Read duplicate hints (substrings that appear twice)\n        for (int i = 0; i < duplicateHintsCount; i++) {\n            int start1 = scanner.nextInt();\n            int start2 = scanner.nextInt();\n            int length = scanner.nextInt();\n            \n            for (int j = 0; j < length; j++) {\n                if (secretString[start1 + j] != '?') {\n                    secretString[start2 + j] = secretString[start1 + j];\n                } else if (secretString[start2 + j] != '?') {\n                    secretString[start1 + j] = secretString[start2 + j];\n                }\n            }\n        }\n\n        int queriesCount = scanner.nextInt();\n        for (int i = 0; i < queriesCount; i++) {\n            int queryPosition = scanner.nextInt();\n            System.out.print(secretString[queryPosition]);\n        }\n    }\n}",
    "timestamp": "2025-08-13 04:17:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LEN 100\n\nvoid decode_string(int length, int fixedHints, int dupHints, char secret[], int queries[], int numQueries) {\n    char result[MAX_LEN];\n    for (int i = 0; i < MAX_LEN; i++) result[i] = '?';\n\n    // Applying fixed letter hints\n    for (int i = 0; i < fixedHints; i++) {\n        int pos;\n        char letter;\n        scanf(\"%d %c\", &pos, &letter);\n        result[pos] = letter;\n    }\n\n    // Applying duplicate substring hints\n    for (int i = 0; i < dupHints; i++) {\n        int start1, start2, len;\n        scanf(\"%d %d %d\", &start1, &start2, &len);\n        for (int j = 0; j < len; j++) {\n            if (result[start1 + j] != '?' && result[start2 + j] == '?') {\n                result[start2 + j] = result[start1 + j];\n            } else if (result[start2 + j] != '?' && result[start1 + j] == '?') {\n                result[start1 + j] = result[start2 + j];\n            }\n        }\n    }\n\n    // Output the letters at queried positions\n    for (int i = 0; i < numQueries; i++) {\n        printf(\"%c\", result[queries[i]]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int len, fixedHints, dupHints, numQueries;\n    scanf(\"%d %d %d\", &len, &fixedHints, &dupHints);\n\n    char secret[MAX_LEN] = {0};\n    int queries[MAX_LEN];\n    scanf(\"%d\", &numQueries);\n    for (int i = 0; i < numQueries; i++) {\n        scanf(\"%d\", &queries[i]);\n    }\n\n    decode_string(len, fixedHints, dupHints, secret, queries, numQueries);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:17:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_secret_string(string_length, fixed_letter_hints, substring_hints, query_positions):\n    # Initialize string with question marks\n    secret_string = ['?'] * string_length\n    \n    # Process fixed letter hints\n    for hint in fixed_letter_hints:\n        pos, letter = hint\n        secret_string[pos] = letter\n    \n    # Process substring hints\n    for hint in substring_hints:\n        start1, start2, length = hint\n        # Check and match substrings\n        for i in range(length):\n            if secret_string[start1 + i] != '?' and secret_string[start2 + i] == '?':\n                secret_string[start2 + i] = secret_string[start1 + i]\n            elif secret_string[start2 + i] != '?' and secret_string[start1 + i] == '?':\n                secret_string[start1 + i] = secret_string[start2 + i]\n    \n    # Return queried positions\n    return ''.join(secret_string[pos] for pos in query_positions)\n\n# Input parsing\nstring_length = int(input())\nnum_fixed_hints = int(input())\nfixed_letter_hints = []\nfor _ in range(num_fixed_hints):\n    pos, letter = input().split()\n    fixed_letter_hints.append((int(pos), letter))\n\nnum_substring_hints = int(input())\nsubstring_hints = []\nfor _ in range(num_substring_hints):\n    start1, start2, length = map(int, input().split())\n    substring_hints.append((start1, start2, length))\n\nnum_query_positions = int(input())\nquery_positions = list(map(int, input().split()))\n\n# Solve and print result\nprint(solve_secret_string(string_length, fixed_letter_hints, substring_hints, query_positions))",
    "timestamp": "2025-08-13 04:18:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "n, h_fixed, h_dup, q = map(int, input().split())\nsecret = ['?'] * n\n\n# Process fixed letters\nfor _ in range(h_fixed):\n    pos, char = input().split()\n    pos = int(pos) - 1\n    secret[pos] = char\n\n# Process duplicated substrings\nfor _ in range(h_dup):\n    src_pos, dst_pos, length = map(int, input().split())\n    src_pos -= 1\n    dst_pos -= 1\n    for i in range(length):\n        if src_pos + i < n and dst_pos + i < n:\n            if secret[src_pos + i] != '?':\n                secret[dst_pos + i] = secret[src_pos + i]\n            elif secret[dst_pos + i] != '?':\n                secret[src_pos + i] = secret[dst_pos + i]\n\n# Process queries\nqueries = list(map(int, input().split()))\noutput = []\nfor pos in queries:\n    pos -= 1\n    output.append(secret[pos] if pos < n else '?')\n\nprint(''.join(output))",
    "timestamp": "2025-08-13 04:18:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nint main() {\n    int stringLength, numHints, numQueries;\n    std::cin >> stringLength >> numHints;\n    \n    std::string secret(stringLength, '?');\n    \n    // Process fixed position hints\n    for (int i = 0; i < numHints; ++i) {\n        char type;\n        std::cin >> type;\n        if (type == 'F') {\n            int pos;\n            char letter;\n            std::cin >> pos >> letter;\n            secret[pos] = letter;\n        } else if (type == 'D') {\n            int start1, start2, length;\n            std::cin >> start1 >> start2 >> length;\n            for (int j = 0; j < length; ++j) {\n                if (secret[start1 + j] != '?' && secret[start2 + j] == '?') {\n                    secret[start2 + j] = secret[start1 + j];\n                }\n                if (secret[start2 + j] != '?' && secret[start1 + j] == '?') {\n                    secret[start1 + j] = secret[start2 + j];\n                }\n            }\n        }\n    }\n    \n    std::cin >> numQueries;\n    std::vector<int> queries(numQueries);\n    for (int i = 0; i < numQueries; ++i) {\n        std::cin >> queries[i];\n    }\n    \n    for (int i = 0; i < numQueries; ++i) {\n        std::cout << secret[queries[i]];\n    }\n    \n    std::cout << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:18:14"
  }
]